<html>
<head>
<title>King is Dead, Long Live the King!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">国王死了，国王万岁！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/king-is-dead-long-live-the-king-95201b81242c#2022-02-07">https://towardsdatascience.com/king-is-dead-long-live-the-king-95201b81242c#2022-02-07</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="dcaf" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">快速开始你的汽车之旅</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/9eac090054a6aa841cc71423b634e362.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VAZWvaQKzejkSml_jT3CFA.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在<a class="ae kz" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的<a class="ae kz" href="https://unsplash.com/@thisisengineering?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> ThisisEngineering RAEng </a></p></figure><p id="2e13" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">传统的机器学习模型开发过程已经死亡，新的流行词是 AutoML。AutoML 已经将机器学习带到了甚至不太懂技术的商业用户也能接触到的范围内。一些数据科学家使用 AutoML 工具来创建他们的机器学习模型。这些工具出色地为您的数据集提供了性能最佳的模型。AutoML 工具允许您基于经典方法和人工神经网络方法设计模型，创建有效的数据管道，使用集成优化模型的准确性，等等。</p><p id="886a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">选择工具并不简单。在本文中，我将介绍我对一些工具的评估，并总结它们的优缺点。我希望，这有助于你决定你的目的的工具。这项研究也将帮助初学者或非数据科学家在 AutoML 领域快速起步。</p><h1 id="d81b" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">我们是如何测试的？</h1><p id="2c72" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">尽管所有工具的 AutoML 过程或多或少是相同的，但它们对数据准备的要求不同。它们产生的输出也不同。我们对所有工具使用相同的数据集，以便您了解它们的数据准备要求。我们使用了两个数据集，一个专门用于回归任务，另一个用于分类任务。我从 UCI 资料库中获取了这两个数据集。</p><p id="da9b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">回归<a class="ae kz" href="https://archive.ics.uci.edu/ml/datasets/Superconductivty+Data" rel="noopener ugc nofollow" target="_blank">数据集</a>包含 81 个决定超导体临界温度(目标)的数字特征。考虑到这个数据集的高维性，我选择它进行回归。该数据集包含 21263 个实例，足以测试回归问题。</p><p id="c001" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">用于分类的<a class="ae kz" href="https://archive.ics.uci.edu/ml/datasets/QSAR+biodegradation" rel="noopener ugc nofollow" target="_blank">数据集</a>包含 41 个属性(分子描述符),这些属性决定了该化学品是否可生物降解。这是一个带有两个目标值的标记数据集(就绪和未就绪，可生物降解)。因此，这是一个二元分类任务。数据集包含 1055 个实例。</p><p id="41a7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我已经将两个数据集上传到我们的 GitHub 库。因此，您不必将数据集上传到您的 Google drive。您使用<em class="mt"> wget </em>将代码下载到项目中。下载完数据集后，通常需要通过删除空值等操作来清理数据集。</p><p id="cd0c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所有的 autoML 工具都有内置的数据清理工具，因此您没有必要进行数据清理。你需要提取特征和目标。您还需要创建训练/测试数据集。对于分类任务，我已经平衡了数据集，因为一些工具在不平衡的数据集上不能正常工作。</p><p id="ac1c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">由于这些是为模型训练准备数据的常见操作，所以我不在文章中描述数据准备代码；有关详细信息，您可以随时参考每个相关的可下载项目。对于某些工具，需要对数据集进行额外的准备。我将在文章中描述这些步骤。</p><p id="3922" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我先从 auto-sklearn 说起。</p><h1 id="d1ac" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">自动 sklearn</h1><p id="e0e9" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">这是该领域的早期启动者之一(2017 年 11 月)，基于流行的 sklearn 机器学习库。最后一次发布是在 2021 年 11 月，因此该产品正在积极维护中。</p><p id="5f7d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">要将此库添加到您的项目中，请运行以下代码片段:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="42c9" class="mz lx iu mv b gz na nb l nc nd">!sudo apt-get install build-essential swig</span><span id="a167" class="mz lx iu mv b gz ne nb l nc nd">!pip install auto-sklearn==0.14.3</span></pre><p id="2587" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">首先，我将向您展示如何使用自动回归器，然后是分类器。</p><h1 id="917f" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">自动回归器</h1><p id="8662" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">要使用自动回归器，请使用以下代码:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="0371" class="mz lx iu mv b gz na nb l nc nd">import autosklearn<br/>from autosklearn.regression import AutoSklearnRegressor<br/>model_auto_reg = AutoSklearnRegressor(time_left_for_this_task=10*60,<br/>                                      per_run_time_limit=30,<br/>                                      n_jobs=-1)<br/>model_auto_reg.fit(X_train_regressor,label_train_regressor)</span></pre><p id="8dc4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">由于 AutoML 工具可能需要很长时间才能找到最佳模型，auto-sklearn 库允许您指定代码执行的时间限制。我们将参数<em class="mt">设置为 10 分钟。这是分配给每个算法的时间。该库测试许多算法，设置这个参数将结束那些算法花费太长时间来执行。</em></p><p id="7b58" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们将参数<em class="mt">每运行时间</em>限制为 30 分钟。如果这个库没有在这个时间段内完成所有它想要的算法的测试，它将停止这个过程，并给你它已经完成的输出。</p><p id="202b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">值为-1 的<em class="mt"> n_jobs </em>参数告诉机器使用所有可用的内核。</p><p id="b740" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如您所料，<em class="mt"> fit </em>方法将特性和目标作为参数。在它完成对所有算法的评估后，您可以打印其执行的统计数据:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="0253" class="mz lx iu mv b gz na nb l nc nd">print(model_auto_reg.sprint_statistics())</span></pre><p id="87de" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我在运行中得到以下输出:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="76fa" class="mz lx iu mv b gz na nb l nc nd">auto-sklearn results:<br/>  Dataset name: 646225b0–8422–11ec-8195–0242ac1c0002<br/>  Metric: r2<br/>  Best validation score: 0.909665<br/>  Number of target algorithm runs: 80<br/>  Number of successful target algorithm runs: 18<br/>  Number of crashed target algorithm runs: 33<br/>  Number of target algorithms that exceeded the time limit: 5<br/>  Number of target algorithms that exceeded the memory limit: 24</span></pre><p id="de4d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">正如您所观察到的，它成功运行了 80 个测试算法中的 18 个，33 个崩溃，5 个超出了 10 分钟的时间限制，24 个超出了内存限制。它仅用 10 分钟就完成了全部评估。</p><p id="d800" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">要查看最终模型，调用它的<em class="mt"> show_models </em>方法。</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="b8eb" class="mz lx iu mv b gz na nb l nc nd">model_auto_reg.show_models()</span></pre><p id="1ff9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这显示了所创建的包括最高性能模型的集合模型。除非您希望进一步微调模型，否则您不必深入细节。在考虑之前，先检查一下误差指标。</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="e8bf" class="mz lx iu mv b gz na nb l nc nd">y_pred_reg = model_auto_reg.predict(X_val_regressor)<br/>error_metrics(y_pred_reg,label_val_regressor)</span></pre><p id="6aee" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这给了我以下输出:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="55b7" class="mz lx iu mv b gz na nb l nc nd">MSE: 89.62974521966439<br/>RMSE: 9.467298728764419<br/>Coefficient of determination: 0.9151071664787114</span></pre><p id="387d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果 R-2 得分高于 91%，您可能不想做进一步的调优。我现在将向您展示如何使用自动分类器。</p><h1 id="ae94" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">自动分类器</h1><p id="4366" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">您使用以下代码片段在我们的分类器数据集上应用自动分类器:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="0bf8" class="mz lx iu mv b gz na nb l nc nd">from autosklearn.classification import AutoSklearnClassifier<br/>model_auto_class =   AutoSklearnClassifier(time_left_for_this_task=10*60,<br/>                               per_run_time_limit=30,<br/>                               n_jobs=-1)<br/>model_auto_class.fit(X_train_classifier,label_train_classifier)</span><span id="784a" class="mz lx iu mv b gz ne nb l nc nd">print(model_auto_class.sprint_statistics())</span></pre><p id="a19c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">功能参数与自动回归的情况相同。</p><p id="307f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是我得到的统计数据:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="25b0" class="mz lx iu mv b gz na nb l nc nd">auto-sklearn results:<br/>  Dataset name: fa958b64–8420–11ec-8195–0242ac1c0002<br/>  Metric: accuracy<br/>  Best validation score: 0.899729<br/>  Number of target algorithm runs: 81<br/>  Number of successful target algorithm runs: 59<br/>  Number of crashed target algorithm runs: 16<br/>  Number of target algorithms that exceeded the time limit: 3<br/>  Number of target algorithms that exceeded the memory limit: 3</span></pre><p id="ee61" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如你所见，在它测试的 81 个算法中，59 个成功运行，只有 3 个超过了时间限制。同样，您可以通过调用 model 的<em class="mt"> show_models </em>方法来检查生成的模型。使用以下代码片段打印分类报告:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="42a5" class="mz lx iu mv b gz na nb l nc nd">y_pred_class = model_auto_class.predict(X_val_classifier)<br/>print(classification_report(label_val_classifier,y_pred_class))</span></pre><p id="88a4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是我运行的输出:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nf"><img src="../Images/d6973ec7897e44a9dbb7a8e4e84a690d.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*fDFP6a7wl-rLbyHA"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><p id="8790" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你可以看到集合模型在我们的数据集上产生了很好的结果。</p><p id="f860" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个项目的<a class="ae kz" href="https://github.com/abcom-mltutorials/ml/blob/main/AutoML_auto_sklearn.ipynb" rel="noopener ugc nofollow" target="_blank">源代码</a>可以在我们的 GitHub 库中找到。</p><p id="5c08" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，我将向您展示如何在这两个数据集上使用 AutoKeras。</p><h1 id="c5f7" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">AutoKeras</h1><p id="e0a9" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">AutoKeras 采用神经网络的方法进行模型开发。它将设计一个包含最佳层数和节点数的网络。</p><h1 id="6b15" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">装置</h1><p id="76fd" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">使用以下代码片段安装 AutoKeras:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="07b3" class="mz lx iu mv b gz na nb l nc nd">!sudo pip install git+https://github.com/keras-team/keras-tuner.git@1.0.2rc1</span><span id="7b63" class="mz lx iu mv b gz ne nb l nc nd">!pip install autokeras</span><span id="d2c6" class="mz lx iu mv b gz ne nb l nc nd">!pip show autokeras</span></pre><h1 id="fce9" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">自动回归器</h1><p id="57d8" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">我定义了一个回调，用于调整网络训练时的学习速率。</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="afaf" class="mz lx iu mv b gz na nb l nc nd">from tensorflow.keras.callbacks import ReduceLROnPlateau <br/>lr_reduction = ReduceLROnPlateau(monitor=’mean_squared_error’,<br/>                                patience=1,<br/>                                verbose=1,<br/>                                factor=0.5,<br/>                                min_lr=0.000001)</span></pre><p id="d52d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用以下代码应用自动回归:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="baff" class="mz lx iu mv b gz na nb l nc nd">from autokeras import StructuredDataRegressor</span><span id="6bd2" class="mz lx iu mv b gz ne nb l nc nd">regressor = StructuredDataRegressor(max_trials=3,   <br/>                                   loss=’mean_absolute_error’)<br/>regressor.fit(x=X_train_regressor, y=label_train_regressor,<br/>            callbacks=[lr_reduction],<br/>            verbose=0, epochs=20)</span></pre><p id="f296" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">正如您在上面的代码中看到的，您只需要设置试验次数和回归损失函数。</p><p id="2649" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">创建模型后，您可以进行预测并打印误差指标。在我的运行中，我得到了以下输出:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="c16c" class="mz lx iu mv b gz na nb l nc nd">MSE: 163.16712072898235<br/>RMSE: 12.7736886109292<br/>Coefficient of determination: 0.8515213997277571</span></pre><h1 id="0625" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">自动分类器</h1><p id="5468" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">使用以下代码创建分类器的模型:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="e7c2" class="mz lx iu mv b gz na nb l nc nd">from autokeras import StructuredDataClassifier</span><span id="5579" class="mz lx iu mv b gz ne nb l nc nd">classifier = StructuredDataClassifier(max_trials=5,num_classes=2)</span><span id="baee" class="mz lx iu mv b gz ne nb l nc nd">classifier.fit(x=X_train_classifier, y=label_train_classifier, <br/>             verbose=0, epochs=20)</span></pre><p id="0a2f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您将类的数量设置为 2，因为我们正在解决一个二元分类问题。</p><p id="186f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">与前面一样，在创建模型之后，您进行推理并打印分类报告。这是我运行的输出:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nf"><img src="../Images/554f3e06a11855dc1b95bdfe3663913b.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*B-dLng_Ydeh9iwJM"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><p id="8114" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个项目的<a class="ae kz" href="https://github.com/abcom-mltutorials/ml/blob/main/AutoML_AutoKeras.ipynb" rel="noopener ugc nofollow" target="_blank">源代码</a>可以在我们的 GitHub 库中找到。</p><p id="7688" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们的下一个图书馆是 TPOT</p><h1 id="3971" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">TPOT</h1><p id="1c82" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">您可以使用 pip 安装来安装 TPOT:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="8225" class="mz lx iu mv b gz na nb l nc nd">!pip install tpot</span></pre><h1 id="0ec4" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">自动回归器</h1><p id="7687" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">使用以下代码应用回归量:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="3a10" class="mz lx iu mv b gz na nb l nc nd">from sklearn.model_selection import RepeatedKFold<br/>cv = RepeatedKFold(n_splits=2, n_repeats=2, random_state=1)</span><span id="293b" class="mz lx iu mv b gz ne nb l nc nd">from tpot import TPOTRegressor<br/>model_reg = TPOTRegressor(generations=5, population_size=50, scoring=’neg_mean_absolute_error’, cv=cv, verbosity=2, random_state=1, n_jobs=-1)</span><span id="e214" class="mz lx iu mv b gz ne nb l nc nd">model_reg.fit(X_train_regressor,label_train_regressor)</span></pre><p id="6145" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是我的测试运行的评估指标</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="65fb" class="mz lx iu mv b gz na nb l nc nd">MSE: 78.55015022333929<br/>RMSE: 8.862852262299045<br/>Coefficient of determination: 0.9260222950313017</span></pre><p id="7a22" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">R-2 系数为 0.925，相当不错。</p><h1 id="70d9" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">自动分类器</h1><p id="5e2c" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">使用以下代码应用分类器:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="6c65" class="mz lx iu mv b gz na nb l nc nd">from sklearn.model_selection import RepeatedStratifiedKFold<br/>cv = RepeatedStratifiedKFold(n_splits=2, n_repeats=2, random_state=1)</span><span id="2b65" class="mz lx iu mv b gz ne nb l nc nd">from tpot import TPOTClassifier<br/>model_class = TPOTClassifier(generations=3, population_size=50, cv=cv, scoring=’accuracy’, verbosity=2, random_state=1, n_jobs=-1)<br/>model_class.fit(X_train_classifier, label_train_classifier)</span></pre><p id="6444" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是我测试运行的分类报告:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nf"><img src="../Images/ef5de139605d310947dcef6721813be2.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*VAxwdOAXpmX2mLvS"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><p id="c495" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个项目的<a class="ae kz" href="https://github.com/abcom-mltutorials/ml/blob/main/AutoML_TPOT.ipynb" rel="noopener ugc nofollow" target="_blank">源代码</a>可以在我们的 GitHub 资源库中找到。</p><h1 id="0223" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">MLBox</h1><p id="cabc" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">和前面的例子一样，使用<em class="mt"> pip </em>命令安装 MLBox:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="53e6" class="mz lx iu mv b gz na nb l nc nd">!pip install mlbox</span></pre><h1 id="e8fc" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">数据准备</h1><p id="ed46" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">与早期工具相比，MLBox 需要额外的数据准备和一些设置。它从 CSV 文件中获取由要素和标注组成的训练数据集。因此，与您通常在其他工具中使用的 dataframe 不同，您需要创建 CSV 文件来训练该模型。像训练数据集一样，它从 CSV 文件中提取测试数据集。当您进行推理时，模型将结果保存在一个 CSV 文件中，因此您需要将它加载到您的程序中来解释结果。就其他要求而言，您需要设置超参数。它为您提供了一个优化器来确定这些参数的最佳值。</p><p id="a925" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有了这样的认识，我现在给你详细的数据准备步骤。让我们首先从回归开始。</p><h1 id="d4bc" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">自动回归器</h1><p id="b20a" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">如前所述，将超导体 CSV 文件加载到数据框中并提取特征和标签:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="cfa6" class="mz lx iu mv b gz na nb l nc nd">regressor_df=pd.read_csv(‘/content/superconductors.csv’)</span><span id="62de" class="mz lx iu mv b gz ne nb l nc nd">features_regressor = regressor_df.iloc[:,:-1]<br/>label_regressor = regressor_df.iloc[:,-1]</span></pre><p id="10c6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后，创建训练/测试数据集:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="3a98" class="mz lx iu mv b gz na nb l nc nd">X_train_regressor, X_test_regressor, label_train_regressor, label_test_regressor = train_test_split(features_regressor, label_regressor, test_size=0.2, random_state=42)</span></pre><p id="e399" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们通过向训练数据添加标签，然后将数据框转换为 CSV 文件来创建训练数据集 CSV 文件。</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="df7c" class="mz lx iu mv b gz na nb l nc nd">training1 = pd.concat([X_train_regressor, label_train_regressor], axis=1)</span><span id="0932" class="mz lx iu mv b gz ne nb l nc nd">training1.to_csv(‘training1_file.csv’)</span></pre><p id="6aea" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">同样，我们创建测试数据集文件，这一次没有添加标签数据。</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="f51d" class="mz lx iu mv b gz na nb l nc nd">testing1 = X_test_regressor</span><span id="bb83" class="mz lx iu mv b gz ne nb l nc nd">testing1.to_csv(‘testing1_file.csv’)</span></pre><p id="0ed4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，我们需要创建一个数据框，使用我们创建的训练文件来训练我们的模型。我们将把训练数据分成训练集和验证集。</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="d8bd" class="mz lx iu mv b gz na nb l nc nd">paths=[‘training1_file.csv’, ‘testing1_file.csv’]<br/>rd = Reader(sep = ‘,’)<br/>df = rd.train_test_split(paths, target_name=’critical_temp’)</span></pre><p id="edc4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Reader 函数在完成后会生成一些统计数据，如下所示:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ng"><img src="../Images/c5672033a5596a3f0306c02a98f89263.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/0*iuuxzQOkC4hSdumx"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><p id="a68e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">请注意，它将任务检测为具有 81 个数字特征的回归类型，并将 critical_temp 作为目标。它将整个数据分成 16969 个训练点和 4253 个验证数据点。</p><p id="e277" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来，通过调用<em class="mt"> Drift </em>转换来检查列中的差异，这将自动删除不需要的列。</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="4353" class="mz lx iu mv b gz na nb l nc nd">dft = Drift_thresholder()<br/>df = dft.fit_transform(df)</span></pre><p id="19a7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是我运行的输出:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nf"><img src="../Images/0e5c0a882759f815b2797690c56a292d.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*fznnT0kIW3--sSI9"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><p id="ba46" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在我们的例子中，它没有丢弃任何变量。</p><p id="e9c7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来，我们将找到超参数的最佳值。我们指定每个参数的范围:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="e871" class="mz lx iu mv b gz na nb l nc nd">space = {‘ne__numerical_strategy’:{“space”:[0]},<br/>‘fs__strategy’:{“search”:”choice”,<br/>               “space”:[‘l1’,’variance’,’rf_feature_importance’]},<br/>‘fs__threshold’:{“search”:”uniform”,<br/>                “space”:[0.01,0.3]},<br/>‘est__strategy’ : {“search”:”choice”,<br/>                 “space” : [‘LightGBM’, ‘RandomForest’, <br/>                           ‘ExtraTrees’, ‘AdaBoost’]},<br/>‘est__max_depth’:{“search”:”choice”,<br/>                  “space”:[3,4,5,6]},<br/>‘est__n_estimators’:{“search”:”choice”,<br/>                     “space”:[250,500,700]}}</span></pre><p id="de11" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们创建了一个优化器，它具有我们想要试验的折叠数，并运行了 20 个时期:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="6c46" class="mz lx iu mv b gz na nb l nc nd">opt=Optimiser(n_folds=3)<br/>best=opt.optimise(space,df,20)</span></pre><p id="f883" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">过一会儿，您将获得最佳的超参数，如下图所示:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="f86d" class="mz lx iu mv b gz na nb l nc nd">{‘est__max_depth’: 5, ‘est__n_estimators’: 700, ‘est__strategy’: ‘LightGBM’, ‘fs__strategy’: ‘l1’, ‘fs__threshold’: 0.290701184999186, ‘ne__numerical_strategy’: 0}</span></pre><p id="f7c7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">将构建的模型和微调的超参数分配给我们指定的<em class="mt">最佳</em>变量。您可以使用这个模型变量来进行推断。</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="d2da" class="mz lx iu mv b gz na nb l nc nd">prd = Predictor()<br/>prd.fit_predict(best, df)</span></pre><p id="8cf8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它将推理结果保存到 CSV 文件中。<em class="mt"> fit_predict </em>方法显示前 10 个数据点的预测目标值，如下图所示:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nh"><img src="../Images/a2536c944f2121a297c4ec618a699d49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/0*YX1a8Vii03zMmZWp"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><p id="9129" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您读取生成的 CSV 文件来创建一个错误指标，如下所示:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="a120" class="mz lx iu mv b gz na nb l nc nd">class_predicted_mlbox=pd.read_csv(‘/content/save/critical_temp_predictions.csv’)</span><span id="c107" class="mz lx iu mv b gz ne nb l nc nd">error_metrics(label_test_regressor, class_predicted_mlbox[‘critical_temp_predicted’])</span></pre><p id="e909" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是我运行的输出:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="51b9" class="mz lx iu mv b gz na nb l nc nd">MSE: 87.77266825021174<br/>RMSE: 9.36870686115281<br/>Coefficient of determination: 0.9237475817171334</span></pre><p id="7d8b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们得到了大约 0.93 的 R-2 分数。现在让我们检查分类器。</p><h1 id="a23c" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">自动分类器</h1><p id="2c69" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">分类器任务的数据准备与回归器的情况相同。创建一个包含特征和目标的训练 CSV 文件。您创建了一个只有特性而没有目标的测试文件。你用<em class="mt">阅读器</em>准备数据帧。</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="59e1" class="mz lx iu mv b gz na nb l nc nd">paths=[‘training2_file.csv’, ‘testing2_file.csv’]<br/>rd = Reader(sep = ‘,’)<br/>df2 = rd.train_test_split(paths, target_name=’label’)</span></pre><p id="5ef1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是我运行中的部分输出:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ni"><img src="../Images/c7d1a33c99e0fc5447472f4924e3885d.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/0*Dd6aIdrt0dT_-ufS"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><p id="4090" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你看，这次的任务是分类，有 41 个特征。我们有 1116 个数据点用于训练，280 个数据点用于测试。</p><p id="74a8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以像前面一样使用漂移变换来检查方差。</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="514e" class="mz lx iu mv b gz na nb l nc nd">dft = Drift_thresholder()<br/>df2 = dft.fit_transform(df2)</span></pre><p id="01c4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您像前面一样声明了<em class="mt">空间</em>变量，用于设置您想要测试的参数值。您创建一个以<em class="mt">精确度</em>作为评分标准的优化器，并运行它 20 个时期，就像回归器的情况一样。</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="a896" class="mz lx iu mv b gz na nb l nc nd">best=opt.optimise(space,df2,20)</span></pre><p id="62b6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，您将获得带有微调参数的<em class="mt">最佳</em>模型，您可以直接将其用于预测:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="3305" class="mz lx iu mv b gz na nb l nc nd">prd = Predictor()<br/>prd.fit_predict(best, df2)</span></pre><p id="d9cd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如前所述，预测存储在 CSV 文件中，您可以读取该文件来创建分类报告:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="dfc4" class="mz lx iu mv b gz na nb l nc nd">reg_predicted_mlbox=pd.read_csv(‘/content/save/label_predictions.csv’)</span><span id="d6b5" class="mz lx iu mv b gz ne nb l nc nd">print(classification_report(reg_predicted_mlbox[‘label_predicted’], label_test_classifier))</span></pre><p id="5862" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是我运行的输出:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nf"><img src="../Images/47d649008d9f3b4fc0fd1182bcb1b1c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*Xtf-3tvIqbz5M3R3"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><p id="0b76" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果我们有更多的数据点，准确性会更好。</p><p id="c4ac" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个项目的<a class="ae kz" href="https://github.com/abcom-mltutorials/ml/blob/main/AutoML_MLBox.ipynb" rel="noopener ugc nofollow" target="_blank">源代码</a>可以在我们的 GitHub 资源库中找到。</p><p id="d3c9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">与早期的库相比，你会发现 MLBox 使用起来更复杂，但它确实创建了一个优秀的模型。让我们现在去下一个图书馆。</p><h1 id="bf39" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">密封罐</h1><p id="d70f" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">这是最容易使用的工具之一。您只需要设置期望的执行时间，并为其提供训练/测试数据集。要安装该工具，您将使用常用的<em class="mt"> pip </em>命令:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="d7bb" class="mz lx iu mv b gz na nb l nc nd">!pip install mljar-supervised</span></pre><h1 id="e8e9" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">自动回归器</h1><p id="56c3" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">要在我们的回归数据集上应用模型，您需要像在 auto-sklearn 案例中那样创建训练/测试数据框。使用以下代码应用模型:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="e34a" class="mz lx iu mv b gz na nb l nc nd">automl_reg = AutoML(total_time_limit=2*60)<br/>automl_reg.fit(X_train_regressor, label_train_regressor)</span></pre><p id="6f2f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">注意，我们刚刚设置了执行的时间上限。这是我运行的输出:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="78e5" class="mz lx iu mv b gz na nb l nc nd">Linear algorithm was disabled.<br/>AutoML directory: AutoML_1<br/>The task is regression with evaluation metric rmse<br/>AutoML will use algorithms: [‘Baseline’, ‘Decision Tree’, ‘Random Forest’, ‘Xgboost’, ‘Neural Network’]<br/>AutoML will ensemble available models<br/>AutoML steps: [‘simple_algorithms’, ‘default_algorithms’, ‘ensemble’]<br/>* Step simple_algorithms will try to check up to 2 models<br/>1_Baseline rmse 34.418723 trained in 0.95 seconds<br/>2_DecisionTree rmse 18.711229 trained in 13.32 seconds<br/>* Step default_algorithms will try to check up to 3 models<br/>3_Default_Xgboost rmse 9.894658 trained in 85.39 seconds<br/>* Step ensemble will try to check up to 1 model<br/>Ensemble rmse 9.894658 trained in 0.24 seconds<br/>AutoML fit time: 149.47 seconds<br/>AutoML best model: 3_Default_Xgboost<br/>AutoML(total_time_limit=120)</span></pre><p id="40a1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">正如您所观察到的，在短短两分钟的时间内，它已经测试了所有指定的算法——基线、决策树、随机森林和 Xgboost。它创造了这些模型的集合。对于每个模型，记录 rmse 和执行时间。执行之后，它会将所有结果存储在一个特定的文件夹中，以供您随时使用。它还生成一个包含比较矩阵的 CSV 文件。</p><p id="942c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用以下语句对测试数据集进行预测:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="1502" class="mz lx iu mv b gz na nb l nc nd">prediction_reg_ml = automl_reg.predict_all(X_test_regressor)</span></pre><p id="4169" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以使用以下命令打印错误度量:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="bf43" class="mz lx iu mv b gz na nb l nc nd">error_metrics(prediction_reg_ml, label_test_regressor)</span></pre><p id="21f3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是我运行的输出:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="6fed" class="mz lx iu mv b gz na nb l nc nd">MSE: 85.32699931235351<br/>RMSE: 9.237261461729526<br/>Coefficient of determination: 0.920540531168528</span></pre><p id="207d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以通过阅读 CSV 文件来打印生成的排行榜:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="1f85" class="mz lx iu mv b gz na nb l nc nd">pd.read_csv(‘/content/AutoML_1/leaderboard.csv’)</span></pre><p id="d19b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是输出:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nj"><img src="../Images/892749c1e14201984edcb275f7fcd812.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x8H4kCFpgSL5LGkr"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><p id="f2d1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来，我们看看分类器。</p><h1 id="f665" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">自动分类器</h1><p id="0c56" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">分类器数据的准备方式与 auto-sklearn 中的准备方式相同。使用以下代码应用分类器:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="89a9" class="mz lx iu mv b gz na nb l nc nd">automl_class = AutoML(total_time_limit=2*60)<br/>automl_class.fit(X_train_classifier, label_train_classifier)</span></pre><p id="f116" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是输出:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="343f" class="mz lx iu mv b gz na nb l nc nd">AutoML directory: AutoML_2<br/>The task is binary_classification with evaluation metric logloss<br/>AutoML will use algorithms: [‘Baseline’, ‘Linear’, ‘Decision Tree’, ‘Random Forest’, ‘Xgboost’, ‘Neural Network’]<br/>AutoML will ensemble available models<br/>AutoML steps: [‘simple_algorithms’, ‘default_algorithms’, ‘ensemble’]<br/>* Step simple_algorithms will try to check up to 3 models<br/>1_Baseline logloss 0.693124 trained in 0.7 seconds<br/>2_DecisionTree logloss 0.526573 trained in 6.5 seconds<br/>3_Linear logloss 0.321759 trained in 5.9 seconds<br/>* Step default_algorithms will try to check up to 3 models<br/>4_Default_Xgboost logloss 0.234433 trained in 15.61 seconds<br/>5_Default_NeuralNetwork logloss 0.813183 trained in 3.01 seconds<br/>6_Default_RandomForest logloss 0.367987 trained in 17.92 seconds<br/>* Step ensemble will try to check up to 1 model<br/>Ensemble logloss 0.234019 trained in 0.81 seconds<br/>AutoML fit time: 80.51 seconds<br/>AutoML best model: Ensemble<br/>AutoML(total_time_limit=120)</span></pre><p id="4742" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如您所见，在短短 2 分钟内，它已经测试了所有指定的型号。最好的模式是合奏。您对测试数据集进行预测，并打印分类报告:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="5748" class="mz lx iu mv b gz na nb l nc nd">prediction_class = automl_class.predict(X_val_classifier)<br/>print(classification_report(label_val_classifier, prediction_class))</span></pre><p id="f683" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是输出:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nf"><img src="../Images/bc91b558fbdf0ba8c212cbd5de67daee.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*NNBuN9KSBzRf7Rwf"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><p id="e0f7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如前所述，您可以通过读取生成的 CSV 文件来打印排行榜:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="47d7" class="mz lx iu mv b gz na nb l nc nd">pd.read_csv(‘/content/AutoML_2/leaderboard.csv’)</span></pre><p id="b249" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是输出:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nk"><img src="../Images/b70fcfb05707f6dc2b2bf30703532a37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wtP0W1sGZrr0YiCU"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><p id="400b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个项目的<a class="ae kz" href="https://github.com/abcom-mltutorials/ml/blob/main/AutoML_MLJAR.ipynb" rel="noopener ugc nofollow" target="_blank">源代码</a>可以在我们的 GitHub 资源库中找到。</p><p id="3876" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个工具非常容易使用，并且在很短的时间内产生了很好的效果。</p><p id="d6c7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们的下一个工具是 H2O。</p><h1 id="5737" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">H2O</h1><p id="80b1" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">这是一个被广泛认可的开源机器学习平台。它是强大的；开发高性能回归和分类模型，但需要额外的数据准备。我将详细介绍使用这个库的所有步骤。</p><p id="45b8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">要安装 H2O，只需<em class="mt"> pip </em>安装以下软件包:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="bcd6" class="mz lx iu mv b gz na nb l nc nd">! apt-get install default-jre</span><span id="4e88" class="mz lx iu mv b gz ne nb l nc nd">!java -version</span><span id="bea0" class="mz lx iu mv b gz ne nb l nc nd">!pip install h2o</span></pre><p id="8272" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">成功安装后，您需要启动 H2O 服务器:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="a605" class="mz lx iu mv b gz na nb l nc nd">import h2o<br/>from h2o.automl import H2OAutoML<br/>h2o.init()</span></pre><p id="37e8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">服务器启动后，您就可以进行模型开发了。</p><h1 id="0def" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">自动回归器</h1><p id="be35" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">首先，你需要准备数据。您可以像在 auto-sklearn 中那样创建训练/测试数据集。H2O 需要特殊格式的数据。使用以下命令将您的数据帧转换为<em class="mt">H2 of frame</em>:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="26ef" class="mz lx iu mv b gz na nb l nc nd">h2o_train1=h2o.H2OFrame(pd.concat([X_train_regressor, label_train_regressor], axis=1))</span></pre><p id="c6f1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你分离出特征和目标:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="31dc" class="mz lx iu mv b gz na nb l nc nd">x1 = h2o_train1.columns<br/>y1 = ‘critical_temp’<br/>x1.remove(y1)</span></pre><p id="b9ea" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">同样，将测试数据转换为 H2O 数据框:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="d47d" class="mz lx iu mv b gz na nb l nc nd">h2o_test1=h2o.H2OFrame(pd.concat([X_test_regressor, label_test_regressor], axis=1))</span></pre><p id="02d2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您为选定数量的模型应用 autoML。以下代码片段测试了 5 个模型:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="4e3b" class="mz lx iu mv b gz na nb l nc nd">model_reg = H2OAutoML(max_models=5, seed=1)<br/>model_reg.train(x=x1, y=y1, training_frame=h2o_train1)</span></pre><p id="d01e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">即使是几个模型也需要相当长的时间。培训过程完成后，您可以打印排行榜。</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="8c6d" class="mz lx iu mv b gz na nb l nc nd">lb = model_reg.leaderboard<br/>lb.head(rows=lb.nrows)</span></pre><p id="02cb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是我运行的输出:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nl"><img src="../Images/483266c4a156204cf370a2838b6a08d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6gQdg8NWF_4ZHIdD"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><p id="809c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">遗憾的是，它没有透露型号配置。使用排行榜中的顶级模型，您可以根据您的测试数据进行推断:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="6522" class="mz lx iu mv b gz na nb l nc nd">preds = model_reg.leader.predict(h2o.H2OFrame(X_test_regressor))</span></pre><p id="a94a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">预测采用 H2O 数据框格式，因此您必须将其转换为 numpy 数组来打印误差度量。将 H2O 数据框转换成如下所示的 numpy 数组:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="138e" class="mz lx iu mv b gz na nb l nc nd">np.array(preds[‘predict’].as_data_frame())</span></pre><p id="f8b2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后，打印误差指标:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="2356" class="mz lx iu mv b gz na nb l nc nd">error_metrics(np.array(preds[‘predict’].as_data_frame()), label_test_regressor)</span></pre><p id="df4e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是我运行的输出:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="868d" class="mz lx iu mv b gz na nb l nc nd">MSE: 77.42394821724238<br/>RMSE: 8.79908791962226<br/>Coefficient of determination: 0.9281053116039564</span></pre><p id="6a0e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来，我们将看看分类器。</p><h1 id="8c37" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">自动分类器</h1><p id="4b2d" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">最初，您将像在 auto-sklearn 中一样创建数据框。然后将它们转换成 H2O 数据框。</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="6712" class="mz lx iu mv b gz na nb l nc nd">h2o_train2=h2o.H2OFrame(pd.concat([X_train_classifier, label_train_classifier], axis=1))</span></pre><p id="ef4e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您将特征和目标分开:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="be8c" class="mz lx iu mv b gz na nb l nc nd">x2 = h2o_train2.columns<br/>y2 = ‘label’<br/>x2.remove(y2)</span></pre><p id="31bf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">将测试数据帧转换为 H2O 数据帧格式:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="fe50" class="mz lx iu mv b gz na nb l nc nd">h2o_test2=h2o.H2OFrame(pd.concat([X_val_classifier, label_val_classifier], axis=1))</span></pre><p id="95bd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于分类，我们需要一个额外的步骤将标签转换成特殊的格式。我们通过在目标变量上调用<em class="mt"> asfactor </em>方法来做到这一点。</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="cbb3" class="mz lx iu mv b gz na nb l nc nd">h2o_train2[y2] = h2o_train2[y2].asfactor()<br/>h2o_test2[y2] = h2o_test2[y2].asfactor()</span></pre><p id="81bb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后，我们在 5 个基本模型上运行 autoML。</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="20a8" class="mz lx iu mv b gz na nb l nc nd">model_class = H2OAutoML(max_models=5, seed=1)<br/>model_class.train(x=x2, y=y2, training_frame=h2o_train2)</span></pre><p id="9df1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">培训结束后，您可以查看排行榜:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="5a08" class="mz lx iu mv b gz na nb l nc nd">lb = model_class.leaderboard<br/>lb.head(rows=lb.nrows)</span></pre><p id="2122" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如前所述，使用排行榜中的顶级模特进行推断:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="6d2b" class="mz lx iu mv b gz na nb l nc nd">preds = model_class.leader.predict(h2o.H2OFrame(X_test_classifier))</span></pre><p id="7e55" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">将结果转换成 numpy 数组并打印分类报告:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="ed4b" class="mz lx iu mv b gz na nb l nc nd">np.array(preds[‘predict’].as_data_frame())</span><span id="1983" class="mz lx iu mv b gz ne nb l nc nd">print(classification_report(label_test_classifier.values, np.array(preds[‘predict’].as_data_frame())))</span></pre><p id="8a84" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是我运行的输出:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nf"><img src="../Images/7838929ed56e7372ef104bf3a3e386f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*9NdgTVnArbyqaIkg"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><p id="d873" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然它产生了良好的结果，但它没有给出模型配置及其超参数值。</p><p id="eb93" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个项目的<a class="ae kz" href="https://github.com/abcom-mltutorials/ml/blob/main/AutoML_H2O.ipynb" rel="noopener ugc nofollow" target="_blank">源代码</a>可以在我们的 GitHub 资源库中找到。</p><p id="cecc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，我将介绍另一个最近发布的 AutoML 工具，它具有数据科学家一直期待的一些额外功能。</p><h1 id="9af2" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">BlobCity AutoAI</h1><p id="35de" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">这是最近在 AutoML 空间中增加的内容(2021 年 10 月发布)。一些对数据科学家来说很珍贵的特性，可以在这个库中看到。它泄露了完整的项目源代码——这对数据科学家来说是一大福音。也很好用。要安装库，再次使用<em class="mt"> pip </em> install。</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="4df2" class="mz lx iu mv b gz na nb l nc nd">!pip install blobcity</span></pre><p id="9a6c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，您需要安装 AutoKeras。很可能，它使用 AutoKeras 为你生成 ANN 模型。</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="ea81" class="mz lx iu mv b gz na nb l nc nd">!sudo pip install git+https://github.com/keras-team/keras-tuner.git@1.0.2rc1</span><span id="51e0" class="mz lx iu mv b gz ne nb l nc nd">!pip install autokeras</span></pre><p id="c94f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">安装完库之后，重新启动运行时并将其导入到项目中</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="2bd9" class="mz lx iu mv b gz na nb l nc nd">import blobcity as bc</span></pre><p id="e525" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">数据准备阶段与 auto-sklearn 的情况相同。首先，我们将在回归数据集上尝试模型拟合。</p><h1 id="1332" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">自动回归</h1><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="fa64" class="mz lx iu mv b gz na nb l nc nd">model_reg = bc.train(df=pd.concat([X_train_regressor, label_train_regressor], axis=1), target=”critical_temp”)</span></pre><p id="0e63" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在模型被训练之后，我可以生成一个特征重要性的图表。</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="edd3" class="mz lx iu mv b gz na nb l nc nd">model_reg.plot_feature_importance()</span></pre><p id="f837" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是输出:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nm"><img src="../Images/ad41c90144c5869acfd48b7040b4fd3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-6xwJ7kjWJpsU4Ql"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><p id="c9b2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">了解要素的重要性有助于数据科学家为最终的模型开发准备数据集。</p><p id="fa62" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我可以绘制实际值与预测值的关系图:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="72be" class="mz lx iu mv b gz na nb l nc nd">model_reg.plot_prediction()</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nn"><img src="../Images/aa3800cdfb779675bc69fa3287defdc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8UGR1oGPj7Esk5Qd"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><p id="71c9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，我生成了错误指标:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="300d" class="mz lx iu mv b gz na nb l nc nd">prediction_reg=model_reg.predict(X_val_regressor)<br/>error_metrics(label_val_regressor, prediction_reg)</span></pre><p id="f2b8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是输出:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="840b" class="mz lx iu mv b gz na nb l nc nd">MSE: 77.74966208588508<br/>RMSE: 8.817576882901848<br/>Coefficient of determination: 0.9324550583579856</span></pre><p id="40ac" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">与我们到目前为止测试的所有模型相比，该模型给了我们极好的 R-2 分数。现在，让我们在分类器数据集上检查它的性能。</p><h1 id="604e" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">自动分类器</h1><p id="88ad" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">数据准备和我们为 auto-sklearn 做的一样。您可以使用以下命令应用该工具:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="3a02" class="mz lx iu mv b gz na nb l nc nd">model_class = bc.train(df=pd.concat([X_train_classifier,label_train_classifier], axis=1), target=”label”)</span></pre><p id="2904" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是分类报告:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nf"><img src="../Images/5443c529abfdcc430a4f4e465c14e1a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*sltVFrGjLRMB-dVQ"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><p id="b121" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它通过调用模型的<em class="mt">溢出</em>方法，在 Jupyter 笔记本中溢出全部源代码和文档:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="af09" class="mz lx iu mv b gz na nb l nc nd">model_class.spill("my_code.ipynb");</span></pre><p id="d48e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它也能产生。py 文件，您可以将它加载到您喜欢的 IDE 中。</p><p id="2df4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您还可以将生成的模型保存到. pkl 文件中。auto-sklearn 和 mljar 中也有类似的功能。</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="42d5" class="mz lx iu mv b gz na nb l nc nd">model_class.save('./my_model.pkl')</span></pre><p id="c9bd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以通过调用 load 方法来加载先前保存的模型文件，以便进行进一步的推断。</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="e8ec" class="mz lx iu mv b gz na nb l nc nd">model = bc.load('./my_model.pkl')</span></pre><p id="331a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它还支持用于 ANN 的. h5 格式和自定义 TensorFlow 文件系统。</p><p id="a821" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个项目的<a class="ae kz" href="https://github.com/abcom-mltutorials/ml/blob/main/AutoML_BlobCity.ipynb" rel="noopener ugc nofollow" target="_blank">源代码</a>可以在我们的 GitHub 库中找到。</p><p id="d555" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我现在将综合所有的观察结果。</p><h1 id="04c9" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">合并报告</h1><p id="5268" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">下表显示了分类器任务的整合。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj no"><img src="../Images/8ce3782d0a351d8e3754f80b5e04f61b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wHQHA2aCGLqZO3A9"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><p id="3ff5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所有工具的精确度几乎相同。创建模型的执行时间显示出很大的差异。</p><p id="f033" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下表合并了回归任务的报告。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj no"><img src="../Images/5df7af7727eeab47256c962ec3f67794.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SiLeN2pyvMQUwY--"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><p id="59cc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">同样，所有工具的模型精度或多或少是相同的。在分类器的情况下，执行时间变化很大。</p><p id="e855" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">请注意，执行时间的差异是由于每个工具生成的细节和报告的差异。</p><p id="106b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，在下面的表格中，我总结了一些特性，这些特性将有助于您选择合适的工具。</p><h2 id="6684" class="mz lx iu bd ly np nq dn mc nr ns dp mg lj nt nu mi ln nv nw mk lr nx ny mm nz bi translated"><strong class="ak">自动 ML 特征比较</strong></h2><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oa"><img src="../Images/0d4bae31e1d2414a1de520b05c398775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jATTZch3HqNSrV_G"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><h1 id="344b" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">摘要</h1><p id="91e7" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">随着对 AutoML 认识的增加，甚至非数据科学家也使用它来开发 ML 模型。本文提供了我们对一些广泛使用的工具进行测试的综合报告。市场上可用的工具数量非常多，我们无法囊括其中的许多工具。这个报告可以让你快速开始你的 AutoML 之旅，并帮助你选择工具。所有测试工具都有免费版本，其中一些是开源的。这些工具在模型生成和报告能力上有所不同。在该报告测试的所有内容中，BlobCity AutoAI 是详细说明该项目的完整源代码的一个，这是一个数据科学家非常想要的功能。</p><h1 id="2334" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">参考资料:</h1><ol class=""><li id="fc16" class="ob oc iu lc b ld mo lg mp lj od ln oe lr of lv og oh oi oj bi translated"><strong class="lc iv">超导体数据集</strong> : Hamidieh，Kam，预测超导体临界温度的数据驱动统计模型，计算材料科学，第 154 卷，2018 年 11 月，第 346–354 页，<a class="ae kz" href="https://doi.org/10.1016/j.commatsci.2018.07.052" rel="noopener ugc nofollow" target="_blank">【网页链接】</a></li><li id="dbab" class="ob oc iu lc b ld ok lg ol lj om ln on lr oo lv og oh oi oj bi translated"><strong class="lc iv"> QSAR 生物降解数据集:</strong>曼苏里，k .，林斯特德，t .，巴拉比奥，d .，托代西尼，r .，康索尼，V. (2013)。化学物质快速生物降解的定量结构-活性关系模型。化学信息与建模杂志，53，867–878</li></ol><h1 id="2e35" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">信用</h1><p id="f003" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated"><a class="ae kz" href="https://pub.towardsai.net/@poojagramo" rel="noopener ugc nofollow" target="_blank"> Pooja Gramopadhye </a> —文字编辑<br/> <a class="ae kz" href="https://medium.com/@georgesaavedra" rel="noopener">乔治·萨维德拉</a> —程序开发</p><blockquote class="op oq or"><p id="7359" class="la lb mt lc b ld le jv lf lg lh jy li os lk ll lm ot lo lp lq ou ls lt lu lv in bi translated">免责声明:本文中的信息仅用于教育目的。作者对本文内容中的任何错误或遗漏不承担任何责任或义务。本文包含的信息按“原样”提供，不保证完整性、准确性、有用性或及时性。</p></blockquote><div class="ov ow gq gs ox oy"><a href="https://medium.com/subscribe/@profsarang" rel="noopener follow" target="_blank"><div class="oz ab fp"><div class="pa ab pb cl cj pc"><h2 class="bd iv gz z fq pd fs ft pe fv fx it bi translated">每当 Poornachandra Sarang 发布内容时，都会收到一封电子邮件。</h2><div class="pf l"><h3 class="bd b gz z fq pd fs ft pe fv fx dk translated">每当 Poornachandra Sarang 发布内容时，都会收到一封电子邮件。通过注册，您将创建一个中等帐户，如果您没有…</h3></div><div class="pg l"><p class="bd b dl z fq pd fs ft pe fv fx dk translated">medium.com</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm kt oy"/></div></div></a></div><div class="ov ow gq gs ox oy"><a href="https://medium.com/@profsarang/membership" rel="noopener follow" target="_blank"><div class="oz ab fp"><div class="pa ab pb cl cj pc"><h2 class="bd iv gz z fq pd fs ft pe fv fx it bi translated">通过我的推荐链接加入 Medium</h2><div class="pf l"><h3 class="bd b gz z fq pd fs ft pe fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pg l"><p class="bd b dl z fq pd fs ft pe fv fx dk translated">medium.com</p></div></div><div class="ph l"><div class="pn l pj pk pl ph pm kt oy"/></div></div></a></div></div></div>    
</body>
</html>