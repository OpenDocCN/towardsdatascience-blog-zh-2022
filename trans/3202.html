<html>
<head>
<title>Understanding Lazy Evaluation in Polars</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Polars中的惰性求值</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-lazy-evaluation-in-polars-b85ccb864d0c#2022-07-15">https://towardsdatascience.com/understanding-lazy-evaluation-in-polars-b85ccb864d0c#2022-07-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="df91" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解什么是急切执行和延迟执行，以及如何使用延迟执行来优化查询</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f15f16e061d7bf5c26adb6723303c218.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ywwiWAyA-uIZTn47"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">汉斯-尤尔根·马格在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="5a05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我上一篇关于Polars的文章中，我向您介绍了Polars数据帧库，它比Pandas数据帧高效得多。</p><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/getting-started-with-the-polars-dataframe-library-6f9e1c014c5c"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">Polars数据帧库入门</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">了解如何使用Polars dataframe库操作表格数据(并替换Pandas)</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="0ec5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将深入探究是什么让Polar如此之快——懒惰评估。你会学到急切执行和懒惰评估/执行的区别。</p><h1 id="a48e" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">隐式懒惰评估</h1><p id="419d" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">为了理解懒惰评估的有效性，与熊猫如何做事情进行比较是有用的。</p><blockquote class="nk nl nm"><p id="10ba" class="kz la nn lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated">在这个练习中，我将使用位于<a class="ae ky" href="https://www.kaggle.com/datasets/usdot/flight-delays" rel="noopener ugc nofollow" target="_blank">https://www.kaggle.com/datasets/usdot/flight-delays</a>的<strong class="lb iu"> flights.csv </strong>文件。该数据集包含2015年美国航班延误和取消的详细信息。它是由交通部运输统计局收集和发布的。</p><p id="a337" class="kz la nn lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated"><strong class="lb iu">许可— </strong> <a class="ae ky" href="https://creativecommons.org/publicdomain/zero/1.0/" rel="noopener ugc nofollow" target="_blank"> CC0:公共领域</a><strong class="lb iu">(</strong><a class="ae ky" href="https://creativecommons.org/publicdomain/zero/1.0/" rel="noopener ugc nofollow" target="_blank">https://creativecommons.org/publicdomain/zero/1.0/</a>)。</p></blockquote><p id="1c7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用Pandas加载flights.csv文件，该文件包含580万行和31列。通常，如果你在内存有限的机器上加载这个，Pandas会花很长时间把它加载到一个dataframe中(如果加载的话)。以下代码执行以下操作:</p><ul class=""><li id="a066" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">将flights.csv文件加载到Pandas数据框架中</li><li id="cac5" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">过滤数据帧以查找12月的航班，这些航班的始发地机场是SEA，目的地机场是DFW</li><li id="22b7" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">测量将CSV文件加载到数据帧和过滤所需的时间</li></ul><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="c4e3" class="ok mo it og b gy ol om l on oo">import pandas as pd<br/>import time</span><span id="c729" class="ok mo it og b gy op om l on oo">start = time.time()</span><span id="4370" class="ok mo it og b gy op om l on oo">df = pd.read_csv('flights.csv')<br/>df = df[(df['MONTH'] == 12) &amp; <br/>        (df['ORIGIN_AIRPORT'] == 'SEA') &amp;<br/>        (df['DESTINATION_AIRPORT'] == 'DFW')]</span><span id="de63" class="ok mo it og b gy op om l on oo">end = time.time()<br/>print(end - start)<br/>df</span></pre><p id="84cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的8GB内存的M1 Mac上，上面的代码片段花了大约7.74秒加载并显示以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/1aa587835cd6afbfec16e15ef9c59490.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*DwBQUQSH65L94MfU0C-KoA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b6a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas的主要问题是，在进行任何过滤以删除所有不需要的行之前，您必须将数据集的所有行加载到dataframe中。</p><blockquote class="nk nl nm"><p id="3026" class="kz la nn lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated">虽然您可以将数据集的前n行或后n行加载到Pandas数据帧中，但要将特定行(基于某些条件)加载到数据帧中，您需要先加载整个数据集，然后才能执行必要的过滤。</p></blockquote><p id="9b8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们使用Polars，看看是否可以减少加载时间。以下代码片段执行以下操作:</p><ul class=""><li id="5e4f" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">使用Polars库的<code class="fe or os ot og b">read_csv()</code>方法加载CSV文件</li><li id="a67d" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">使用<code class="fe or os ot og b">filter()</code>方法执行过滤，并指定保留我们想要的行的条件</li></ul><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="cc08" class="ok mo it og b gy ol om l on oo"><strong class="og iu">import polars as pl</strong><br/>import time</span><span id="ad3f" class="ok mo it og b gy op om l on oo">start = time.time()</span><span id="9e4e" class="ok mo it og b gy op om l on oo">df = <strong class="og iu">pl.read_csv('flights.csv').filter(<br/>        (pl.col('MONTH') == 12) &amp; <br/>        (pl.col('ORIGIN_AIRPORT') == 'SEA') &amp;                                          <br/>        (pl.col('DESTINATION_AIRPORT') == 'DFW'))</strong></span><span id="f883" class="ok mo it og b gy op om l on oo">end = time.time()<br/>print(end - start)<br/>display(df)</span></pre><p id="8f06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的电脑上，上面的代码片段花了大约3.21秒，比熊猫有了很大的改进:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/05057b059e3a29bb373cf326e24e8f2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*fKM8UXxOx1yyOrSaAQppZg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="a013" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，知道<code class="fe or os ot og b">read_csv()</code>方法使用<em class="nn">急切执行模式</em>很重要，这意味着它会在执行任何过滤之前直接将整个数据集加载到数据帧中。在这方面，这段使用Polars的代码与使用Pandas的代码相似。但是你已经可以看到Polars比熊猫快多了。</p><blockquote class="nk nl nm"><p id="1065" class="kz la nn lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated">注意这里的<code class="fe or os ot og b">filter()</code>方法作用于Polars DataFrame对象</p></blockquote><p id="43b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个改进是将<code class="fe or os ot og b">read_csv()</code>方法替换为使用<em class="nn">延迟执行— </em> <code class="fe or os ot og b">scan_csv()</code>的方法。<code class="fe or os ot og b">scan_csv()</code>方法延迟执行，直到<code class="fe or os ot og b">collect()</code>方法被调用。它分析所有查询，直到<code class="fe or os ot og b">collect()</code>方法，并尝试优化操作。以下代码片段显示了如何将<code class="fe or os ot og b">scan_csv()</code>方法与<code class="fe or os ot og b">collect()</code>方法结合使用:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="64d7" class="ok mo it og b gy ol om l on oo">import polars as pl<br/>import time</span><span id="ca1f" class="ok mo it og b gy op om l on oo">start = time.time()<br/>df = pl.<strong class="og iu">scan_csv</strong>('flights.csv').filter(<br/>        (pl.col('MONTH') == 12) &amp; <br/>        (pl.col('ORIGIN_AIRPORT') == 'SEA') &amp;<br/>        (pl.col('DESTINATION_AIRPORT') == 'DFW'))<strong class="og iu">.collect()</strong><br/>end = time.time()<br/>print(end - start)<br/>display(df)</span></pre><blockquote class="nk nl nm"><p id="c913" class="kz la nn lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated"><code class="fe or os ot og b">scan_csv()</code>方法被称为<strong class="lb iu">隐式懒惰方法</strong>，因为默认情况下它使用懒惰评估。记住<code class="fe or os ot og b">scan_csv()</code>方法不返回数据帧是很重要的——它返回的是<code class="fe or os ot og b">LazyFrame</code>。</p></blockquote><p id="a2fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于上面的代码片段，Polars没有将所有行加载到dataframe中，而是优化了查询，只加载那些满足<code class="fe or os ot og b">filter()</code>方法中的条件的行。在我的电脑上，上面的代码片段耗时约2.67秒，与前面的代码片段相比，处理时间进一步减少。</p><blockquote class="nk nl nm"><p id="b2db" class="kz la nn lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated">注意这里的<code class="fe or os ot og b"><em class="it">filter()</em></code>方法适用于Polars LazyFrame对象</p></blockquote><h1 id="e376" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">显式懒惰评估</h1><p id="a92b" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">还记得我之前提到的<code class="fe or os ot og b">read_csv()</code>方法使用急切执行模式吗？如果您想对所有后续查询使用延迟执行模式，该怎么办？嗯，你可以简单地调用上面的<code class="fe or os ot og b">lazy()</code>方法，然后使用<code class="fe or os ot og b">collect()</code>方法结束整个表达式，就像这样:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="d5a3" class="ok mo it og b gy ol om l on oo">import polars as pl<br/>import time</span><span id="a332" class="ok mo it og b gy op om l on oo">start = time.time()<br/>df = pl.read_csv('flights.csv')<br/>       .<strong class="og iu">lazy()<br/>       </strong>.filter(<br/>         (pl.col('MONTH') == 12) &amp; <br/>         (pl.col('ORIGIN_AIRPORT') == 'SEA') &amp;<br/>         (pl.col('DESTINATION_AIRPORT') == 'DFW'))<strong class="og iu">.collect()</strong><br/>end = time.time()</span><span id="9630" class="ok mo it og b gy op om l on oo">print(end - start)<br/>display(df)</span></pre><p id="994f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用<code class="fe or os ot og b">lazy()</code>方法，您指示Polars暂停后续查询的执行，而是优化所有查询，直到使用<code class="fe or os ot og b">collect()</code>方法。<code class="fe or os ot og b">collect()</code>方法开始执行，<em class="nn">将结果收集到</em>数据帧中。本质上，这个方法指示Polars急切地执行查询。</p><h1 id="cf63" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">了解LazyFrame对象</h1><p id="7ec5" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">现在让我们分解一个查询，看看Polars实际上是如何工作的。首先，让我们使用<code class="fe or os ot og b">scan_csv()</code>方法，看看它返回什么:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="da0e" class="ok mo it og b gy ol om l on oo">pl.scan_csv('titanic_train.csv')</span></pre><blockquote class="nk nl nm"><p id="28a0" class="kz la nn lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">数据来源</em> </strong> <em class="it">:本文数据来源于</em><a class="ae ky" href="https://www.kaggle.com/datasets/tedllh/titanic-train" rel="noopener ugc nofollow" target="_blank">https://www.kaggle.com/datasets/tedllh/titanic-train</a>。</p><p id="4c12" class="kz la nn lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated"><strong class="lb iu">许可—【https://opendatacommons.org/licenses/dbcl/1-0/】数据库内容许可(DbCL)1.0版<a class="ae ky" href="https://opendatacommons.org/licenses/dbcl/1-0/" rel="noopener ugc nofollow" target="_blank">T21</a></strong></p></blockquote><p id="3e32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的语句返回一个“<code class="fe or os ot og b">polars.internals.lazy_frame.LazyFrame</code>”对象。在Jupyter Notebook中，它将显示下面的执行图(我将在后面详细介绍):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/ab44009dcf75d5a22c1032f0d834be61.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*WosnV0PhrZcVhyDfBGxHWQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><blockquote class="nk nl nm"><p id="e67e" class="kz la nn lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated"><strong class="lb iu">执行图</strong>显示了Polars执行查询的顺序。</p></blockquote><p id="087e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回的<code class="fe or os ot og b">LazyFrame</code>对象表示您已经制定但尚未执行的查询。要执行查询，您需要使用<code class="fe or os ot og b">collect()</code>方法:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="1e50" class="ok mo it og b gy ol om l on oo">pl.scan_csv('titanic_train.csv')<strong class="og iu">.collect()</strong></span></pre><p id="6f0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还可以用一对括号将查询括起来，并将其赋给一个变量。要执行查询，只需调用查询的<code class="fe or os ot og b">collect()</code>方法，如下所示:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="2ef3" class="ok mo it og b gy ol om l on oo"><strong class="og iu">q = (</strong><br/>    pl.scan_csv('titanic_train.csv')    <br/><strong class="og iu">)</strong><br/><strong class="og iu">q.collect()</strong></span></pre><blockquote class="nk nl nm"><p id="1f66" class="kz la nn lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated">将查询括在一对括号中的好处是，它允许您将多个查询链接起来，并将它们放在单独的行中，从而大大增强可读性。</p></blockquote><p id="0449" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码片段显示了以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/56699b2fed9d50b518f852deebffe869.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1o_Lrar30E0UwDveYXCz2Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="1909" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于调试目的，有时只返回几行来检查输出是有用的，因此您可以使用<code class="fe or os ot og b">fetch()</code>方法来返回前<em class="nn"> n </em>行:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="c862" class="ok mo it og b gy ol om l on oo">q.<strong class="og iu">fetch</strong>(5)</span></pre><p id="755f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述语句返回结果的前五行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/7dd637e39ede5abb246c3e2989e6ed3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jTnQop_UDWgh8cYe_RqW-g.png"/></div></div></figure><p id="5c63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在单个查询中链接各种方法:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="c194" class="ok mo it og b gy ol om l on oo">q = (<br/>    pl.scan_csv('titanic_train.csv')<br/><strong class="og iu">    .select(['Survived','Age'])<br/>    .filter(<br/>        pl.col('Age') &gt; 18<br/>    )<br/></strong>)</span></pre><p id="82fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe or os ot og b">show_graph()</code>方法显示您之前看到的执行图，并带有一个参数来指示您是否想要查看优化的图形:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="cd7c" class="ok mo it og b gy ol om l on oo">q.<strong class="og iu">show_graph(optimized=True)</strong></span></pre><p id="dcdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的语句显示了下面的执行图。您可以看到，基于<em class="nn">年龄</em>列的过滤是在CSV文件加载期间一起完成的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/ebea1f825d3160f8bb681a929c1a76c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*h2rz4tcVirFwi0G1WGaMYA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="9461" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相比之下，让我们来看看如果查询以急切模式(即非优化模式)执行，执行流程会是什么样子:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="8616" class="ok mo it og b gy ol om l on oo">q.show_graph(<strong class="og iu">optimized=False</strong>)</span></pre><p id="c22c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从下面的输出可以看出，首先加载CSV文件，然后选择两列，最后执行过滤:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/84fbae668393f56f5c39b366017d5c34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tT3M0y8MRn2yApZCD7KXIg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="ecc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要执行查询，调用<code class="fe or os ot og b">collect()</code>方法:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="90ff" class="ok mo it og b gy ol om l on oo">q.collect()</span></pre><p id="5d38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将显示以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/f3f6e6a8f910e791f64021547c10d403.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/1*0yWqYGwvQ12PqF8vowQENQ.png"/></div></figure><p id="dc67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果只需要前五行，调用<code class="fe or os ot og b">fetch()</code>方法:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="0001" class="ok mo it og b gy ol om l on oo">q.fetch(5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/3e519ba3e8f753668ea35fad881aeccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*nS5VmbOfXqbhFyUGbwSd0A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><div class="lv lw gp gr lx ly"><a href="https://weimenglee.medium.com/membership" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">加入媒介与我的介绍链接-李伟孟</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">阅读李维孟(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">weimenglee.medium.com</p></div></div><div class="mh l"><div class="pc l mj mk ml mh mm ks ly"/></div></div></a></div><blockquote class="nk nl nm"><p id="5652" class="kz la nn lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated">我将在即将到来的新加坡ML会议(2022年11月22-24日)上主持一个关于Polars的研讨会。如果你想快速启动Polars数据框架，请在<a class="ae ky" href="https://mlconference.ai/machine-learning-advanced-development/using-polars-for-data-analytics-workshop/" rel="noopener ugc nofollow" target="_blank">https://ml conference . ai/machine-learning-advanced-development/using-Polars-for-data-analytics-workshop/</a>注册参加我的研讨会。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/b1bb1beb7127f109628516f77a2b9338.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*3mrWppY0VhWWEoBm5A4qHA.png"/></div></figure><h1 id="8f0d" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">摘要</h1><p id="c850" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">我希望您现在对Polars中的惰性执行是如何工作的，以及如何为只支持急切执行的查询启用惰性执行有了更好的了解。显示执行图使您更容易理解查询是如何被优化的。在接下来的几篇文章中，我将继续讨论Polars数据框架以及操纵它们的各种方法。如果你想让我关注某个特定的话题，请给我留言！</p></div></div>    
</body>
</html>