<html>
<head>
<title>Solving Two-Stage Stochastic Programs in Gurobi</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Gurobi中求解两阶段随机规划</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/solving-two-stage-stochastic-programs-in-gurobi-9372da1e3ba8#2022-10-20">https://towardsdatascience.com/solving-two-stage-stochastic-programs-in-gurobi-9372da1e3ba8#2022-10-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/11fae1a710df015dfbd296162b60b75f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UawflHE__eyzNpWdrNq_kQ.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">泰勒·维克在<a class="ae jd" href="https://unsplash.com/s/photos/servers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""/><div class=""><h2 id="db8a" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">两阶段随机服务器群问题的公式化和求解</h2></div><p id="77fd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">随机规划(SP)是一个框架，用于建模包含不确定性的优化问题[1]。在许多情况下，SP模型采取两阶段问题的形式。第一阶段包括寻找最优的确定性决策。这些决定是基于我们知道是确定的信息(也就是此时此地的决定)。考虑到我们第一阶段的决策，第二阶段涉及做出依赖于随机性的决策(也称为求助决策)。优化问题旨在最小化第一阶段决策导致的损失(或最大化利润)加上第二阶段决策导致的预期损失。从数学上讲，这可以写成以下格式:</p><figure class="ls lt lu lv gt is gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/849e5f14541fca42d80aa9948899bc85.png" data-original-src="https://miro.medium.com/v2/resize:fit:470/format:webp/0*d2hxF2_ZDbPhbO2w.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">2SP通用表格(图片由作者提供)</p></figure><p id="d485" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我将演示如何使用Gurobi来制定和解决其中的一个问题。</p><h1 id="7a6c" class="lw lx jg bd ly lz ma mb mc md me mf mg km mh kn mi kp mj kq mk ks ml kt mm mn bi translated">激励范例</h1><p id="b337" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">让我们用一个例子来透视这个框架:一个服务器场问题。假设我们正在尝试为公司设计一个服务器群，考虑到我们拥有的空间和购买服务器的前期预算，我们需要安装CPU、GPU和TPU核心来帮助处理公司的计算资源。我们对每个资源下个月的需求以及它们的分布有一个大概的估计。为了简单起见，我们将忽略下个月以后的几个月(尽管可以通过一个多阶段随机程序来处理这个问题)。</p><p id="adc3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">未来运行服务器将花费少量成本，但如果我们不能满足需求，我们将不得不利用云计算资源，这将大大增加我们的运营成本。<br/>在这个例子中，我们的第一阶段决策(此时此地的决策)是购买每种资源的数量。第二阶段(追索权)决策是购买云计算的数量。我们的目标是最小化服务器群的运营成本。这个优化问题可以写成如下:</p><figure class="ls lt lu lv gt is gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/d3c3e5c675538ea2ecc7937c3757fba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/0*Gj35lt_eq4w0ZRd3.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">服务器群2SP公式(图片由作者提供)</p></figure><p id="5146" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其中<em class="mu"> x </em>表示我们将购买每个内核的数量，<em class="mu"> y </em>表示我们将利用多少云计算，<em class="mu"> i </em>是我们的安装成本，<em class="mu"> B </em>是我们的安装预算，<em class="mu"> s </em>是内核的大小，<em class="mu"> S </em>是我们的可用空间，<em class="mu"> c </em>是我们的云计算成本，<em class="mu"> d(xi) </em>是我们的随机需求。</p><h1 id="90bb" class="lw lx jg bd ly lz ma mb mc md me mf mg km mh kn mi kp mj kq mk ks ml kt mm mn bi translated">解决SP</h1><p id="d93c" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">为了解决上面的问题，我们将实现一种叫做样本平均近似的技术<a class="ae jd" href="https://doi.org/10.1137/S1052623499363220" rel="noopener ugc nofollow" target="_blank">【2】</a>。这种方法包括通过蒙特卡罗抽样生成随机变量的大量(<em class="mu"> K </em>)潜在实现(场景)，并将每个实现视为一个单独的子问题<a class="ae jd" href="https://doi.org/10.1137/S1052623499363220" rel="noopener ugc nofollow" target="_blank">【2】</a>。这有助于将随机性离散化，从而在不损失太多信息保真度的情况下使其可解。这意味着我们将有<em class="mu"> K </em>个变量，而不是只有一组第二阶段变量，第二阶段值的期望值是我们实现的平均值。这样，我们的公式变为:</p><figure class="ls lt lu lv gt is gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/77c72506e08d249aa883c04b0eafcde5.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/0*J1Bp1FE0PVgzGG1u.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">SAA重构(图片由作者提供)</p></figure><p id="dc8e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然该公式可以在各种编程语言和线性编程求解器(例如SCIP、CPLEX、CVXPY)中实现，但我们将专注于使用商业级、最先进的数学编程求解器Gurobi来解决这个问题。Gurobi有针对Python、MATLAB、R和Java等语言的API，但是它的大多数用户更喜欢使用Python API [4]，所以我们将在这里使用它。</p><p id="12cf" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们将导入我们的包(<code class="fe mw mx my mz b">numpy</code>和<code class="fe mw mx my mz b">gurobipy</code>)并为我们的问题初始化(组成)数据。</p><figure class="ls lt lu lv gt is"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="3798" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个问题中<code class="fe mw mx my mz b">i</code>是投资成本，<code class="fe mw mx my mz b">s</code>是每个项目占用的空间，<code class="fe mw mx my mz b">B</code>是我们的预算，<code class="fe mw mx my mz b">S</code>是我们的最大空间。另一个值得注意的变量是每个场景中的需求<code class="fe mw mx my mz b">d_xi</code>。然后我们可以用古罗比来解决我们的问题。首先，我们将使用<code class="fe mw mx my mz b">gp.model()</code>定义我们的模型，设置目标(最小化)以及初始化我们的决策变量。</p><figure class="ls lt lu lv gt is"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="db24" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从上面的例子中可以看出，我们的需求(<code class="fe mw mx my mz b">d_xi</code>)和我们的第二阶段决策变量(<code class="fe mw mx my mz b">y</code>)都不是一维向量，而是一个矩阵，因为这两个变量在我们的公式中都有一个场景索引。在此之后，我们可以定义我们的目标函数:</p><figure class="ls lt lu lv gt is"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="2976" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Gurobi的一个优点是，在定义约束和目标时，它支持<code class="fe mw mx my mz b">numpy</code>矩阵乘法运算，如果考虑矩阵乘法(例如<code class="fe mw mx my mz b">i @ x</code>)。Gurobi还支持求和运算，这也降低了进入门槛。这里我们计算第一阶段的成本，然后取第二阶段的平均成本。</p><p id="9ed8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在可以继续定义我们的约束条件:</p><figure class="ls lt lu lv gt is"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="8716" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第一行代码确保安装内部服务器的成本不会超出我们的预算<code class="fe mw mx my mz b">B</code>。第二行确保我们只购买我们有空间的服务器。第三行代码确保场景k中安装的服务器数量和利用的云计算资源数量足以满足场景k中的需求。</p><p id="e9f4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在问题已经完全定义好了，我们可以简单地通过调用<code class="fe mw mx my mz b">m.optimize()</code>来解决问题并得到我们的最优决策:</p><figure class="ls lt lu lv gt is"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="6f97" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最佳变量值存储在我们定义的每个变量中，可以通过<code class="fe mw mx my mz b">variable_name.x</code>访问。虽然我们可能已经获得了<em class="mu"> x </em>和<em class="mu"> y </em>变量的最优值，但是我们只关心我们现在可以做出的决定(<em class="mu"> x </em>)。</p><h1 id="dbbd" class="lw lx jg bd ly lz ma mb mc md me mf mg km mh kn mi kp mj kq mk ks ml kt mm mn bi translated">限制</h1><p id="eb6f" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">这种方法为我们提供了高质量的解决方案，但也有缺点。</p><p id="fcd1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第一个不利之处是，随着场景数量的增加，模型将变得更加难以求解。例如，我们只需要做出6个真正的决策，但是使用样本平均近似值使我们的模型做出了153个决策(50个场景中的3个第一阶段，3个第二阶段)。这意味着分解算法(如线性SPs的Benders分解[3])通常需要用于并行化计算。</p><p id="9b4a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一个考虑是，不幸的是，Gurobi不是自由软件。虽然Gurobi确实提供了许多学生和研究人员利用的学术许可证，但不属于大学的个人可能会发现很难获得该软件的访问权限。Gurobi的一个开源替代方案是SCIP [5]。两者共享相似的建模语言，因此Gurobi用户可以很容易地适应SCIP，反之亦然。出于个人偏好以及Gurobi的快速求解性能，我选择用Gurobi而不是SCIP来演示这个概念。这并不意味着SCIP就低人一等。事实上，许多专注于开发或改进优化算法的优化研究人员更喜欢SCIP，因为它的开源特性允许用户调整求解器的每个部分，从而允许他们尝试新的方法。</p><h1 id="162e" class="lw lx jg bd ly lz ma mb mc md me mf mg km mh kn mi kp mj kq mk ks ml kt mm mn bi translated">资源和参考资料</h1><p id="290c" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">这个问题的完整代码可以在<a class="ae jd" href="https://gist.github.com/upadhyan/0473135e849d167a574c7f9bac5e1426" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="41d3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">作品引用</strong></p><p id="37e2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[1] A. Philpott，<a class="ae jd" href="https://stoprog.org/what-stochastic-programming?qt-inroduction_quicktab_block=1#qt-inroduction_quicktab_block" rel="noopener ugc nofollow" target="_blank">什么是随机规划</a>。(2022)，随机规划学会。</p><p id="1238" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[2] A. J. Kleywegt，A. Shapiro，T . Homem-de-Mello<a class="ae jd" href="https://doi.org/10.1137/S1052623499363220" rel="noopener ugc nofollow" target="_blank">随机离散优化的样本平均逼近法</a> (2002)，SIAM优化杂志。</p><p id="c0ae" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[3]尼尔森，泽尼奥斯。<a class="ae jd" href="https://doi.org/10.1016/S0167-8191(97)00044-6" rel="noopener ugc nofollow" target="_blank">随机线性规划的可扩展并行Benders分解</a> (1997)，并行计算第23卷，第8期。</p><p id="2cdc" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[4]古罗比。<a class="ae jd" href="https://www.gurobi.com/resources/starting-with-gurobi/" rel="noopener ugc nofollow" target="_blank">从古罗比开始</a> (2022)，古罗比网站</p><p id="edeb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[5] Bestuzheva等人。艾尔。<a class="ae jd" href="https://www.scipopt.org/index.php#welcome" rel="noopener ugc nofollow" target="_blank">SCIP优化套件8.0 </a> (2021)，在线优化</p></div></div>    
</body>
</html>