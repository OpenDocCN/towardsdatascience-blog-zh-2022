<html>
<head>
<title>A Guide to Managing Datetime Data in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中日期时间数据管理指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-guide-to-managing-datetime-data-in-python-c5b841a50ac4#2022-07-02">https://towardsdatascience.com/a-guide-to-managing-datetime-data-in-python-c5b841a50ac4#2022-07-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f57d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以下是如何解决你的日期时间，熊猫指数和夏令时噩梦</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/87d5f68ed48f62915dd66b71d4b29cbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XELSIv1iFN2oJmWf.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:pixabay上的SplitShire</p></figure><p id="b17c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用日期时间数据集可能是计算机编程中最令人沮丧的方面之一。您不仅需要跟踪日期，还需要学习如何用每种语言表示日期和时间，从这些数据点中创建索引，并确保您的所有数据集以相同的方式处理夏令时。幸运的是，这本关于日期时间数据的入门书将帮助您开始使用Python。</p><h1 id="7a57" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">日期时间</h1><p id="b57c" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">Python中大多数日期和时间的表示都是以datetime对象的形式呈现的，这些对象是从Datetime包中创建的。这意味着了解Datetime包以及如何使用它是至关重要的！</p><p id="dbbd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从根本上说，datetime对象是一个包含日期和时间信息的变量。它还可以包括时区信息，并且有根据需要更改时区的工具。</p><p id="53fe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看几个使用datetime包创建的Datetime对象的例子。首先，我们可以使用包的命令创建一个存储当前时间的变量，如下所示:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="42e9" class="mw lv it ms b gy mx my l mz na">import datetime</span><span id="a5fa" class="mw lv it ms b gy nb my l mz na">import pytz</span><span id="66cf" class="mw lv it ms b gy nb my l mz na">now = datetime.datetime.now(pytz.timezone(‘US/Pacific’))</span><span id="5a33" class="mw lv it ms b gy nb my l mz na">print(now)</span><span id="600f" class="mw lv it ms b gy nb my l mz na">print(now.tzinfo)</span></pre><p id="b5ed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">前两行导入了这个任务的重要包。第一个是datetime包，它使我们能够创建和操作Datetime对象。第二个是Pytz包，它提供时区信息。</p><p id="cac7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第三行调用<strong class="la iu"> datetime.datetime.now </strong>函数来创建一个datetime对象，表示我们运行代码的时间。此行还向datetime添加了一个时区，说明datetime表示美国太平洋时区的时间。</p><p id="ae18" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第四行和第五行都是打印输出，用于演示代码的结果。</p><p id="20e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该代码的输出是:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="81ec" class="mw lv it ms b gy mx my l mz na">2022–05–11 09:19:01.859385–07:00</span><span id="ecd1" class="mw lv it ms b gy nb my l mz na">US/Pacific</span></pre><p id="7fb7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一个输出显示了变量<strong class="la iu">现在</strong>的完整信息。显示该变量创建于2022年5月11日9点19分1.86秒。因为我将时区设置为'<strong class="la iu">美国/太平洋</strong>'，所以程序将适当的<strong class="la iu"> -7 </strong>小时(相对于UTC)附加到变量上。第二个输出通过打印变量的时区是美国太平洋时区来确认时区信息。</p><p id="667a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您会注意到，在上面的代码中，我通过调用<strong class="la iu">pytz . time zone(' US/Pacific ')</strong>将时区设置为美国太平洋时区。如果您想使用不同的时区，您需要知道正确的代码(尽管它们都遵循相同的格式并引用已知的时区，所以它们是相当容易预测的)。如果您想找到您的timez one，您可以使用以下命令打印所有选项的列表。</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="9d2d" class="mw lv it ms b gy mx my l mz na">print(pytz.all_timezones)</span></pre><p id="9f1c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还可以使用<strong class="la iu"> datetime.datetime </strong>函数来创建指定日期的日期时间。请注意前面示例中显示当前时间的datetime对象的格式，因为对<strong class="la iu"> datetime.datetime </strong>的输入是以相同的顺序提供的(年、月、日、小时、分钟、秒)。换句话说，如果我们想要创建一个表示美国太平洋时区2022年5月11日12:11:03的datetime对象，我们可以使用以下代码:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="5fbe" class="mw lv it ms b gy mx my l mz na">specified_datetime = datetime.datetime(2022, 5, 11, 12, 11, 3).astimezone(pytz.timezone(‘US/Pacific’))</span><span id="8c6a" class="mw lv it ms b gy nb my l mz na">print(specified_datetime)</span><span id="95b9" class="mw lv it ms b gy nb my l mz na">print(specified_datetime.tzinfo)</span></pre><p id="7d5f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意上面的<strong class="la iu"> datetime.datetime </strong>的输入是如何出现的。然后是<strong class="la iu">。调用astimezone </strong>方法将时区设置为美国太平洋时区。</p><p id="d22e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该代码的输出是:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="81b0" class="mw lv it ms b gy mx my l mz na">2022–05–11 12:11:03–07:00</span><span id="3868" class="mw lv it ms b gy nb my l mz na">US/Pacific</span></pre><p id="2ef9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果是代码创建了我们想要的变量。根据需要，<strong class="la iu"> specified_datetime </strong>现在返回美国太平洋时区2022年5月11日12:11:03。</p><p id="1d71" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们想在不同的时区表示相同的时间呢？我们可以计算新的时区并相应地创建一个新的datetime对象，但是这需要我们知道时差，进行计算并相应地创建新的对象。另一个选项是将时区转换为所需的时区，并将输出保存到一个新变量中。因此，如果我们想将<strong class="la iu">指定日期时间</strong>转换为美国东部时区，我们可以使用下面的代码。</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="36e7" class="mw lv it ms b gy mx my l mz na">eastern_datetime = specified_datetime.astimezone(pytz.timezone(‘US/Eastern’))</span><span id="b973" class="mw lv it ms b gy nb my l mz na">print(eastern_datetime)</span><span id="cf1d" class="mw lv it ms b gy nb my l mz na">print(eastern_datetime.tzinfo)</span></pre><p id="360b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这段代码调用了<strong class="la iu">。用代表美国东部时区的新时区对象指定日期时间的方法。打印输出为:</strong></p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="86d7" class="mw lv it ms b gy mx my l mz na">2022–05–11 15:11:03–04:00</span><span id="774f" class="mw lv it ms b gy nb my l mz na">US/Eastern</span></pre><p id="544a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意<strong class="la iu">指定日期时间</strong>和<strong class="la iu">大西洋日期时间</strong>之间的变化。由于美国东部时间比美国太平洋时间早三个小时，时间从12点变成了15点。时区信息从<strong class="la iu"> -7 </strong>变为<strong class="la iu"> -4 </strong>，因为美国东部时间与UTC相差4小时，而不是相差7小时。最后，注意打印的时区信息现在是<strong class="la iu">美国/东部</strong>而不是<strong class="la iu">美国/太平洋</strong>。</p><h1 id="c45c" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">熊猫指数</h1><p id="2e5b" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">Pandas数据帧通常使用datetime对象作为索引，因为这使数据集能够跟踪记录测量的日期和时间。因此熊猫提供了许多你可以使用的工具。</p><p id="cb87" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您第一次介绍带有日期时间索引的数据帧很可能是导入别人的数据集，而别人恰好使用了一个数据集。考虑以下示例和提供的输出:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="10fd" class="mw lv it ms b gy mx my l mz na">data = pd.read_csv(r’C:\Users\Peter Grant\Desktop\Sample_Data.csv’, index_col = 0)</span><span id="22c4" class="mw lv it ms b gy nb my l mz na">print(data.index)</span><span id="9975" class="mw lv it ms b gy nb my l mz na">print(type(data.index))</span><span id="f281" class="mw lv it ms b gy nb my l mz na">print(type(data.index[0]))</span></pre><p id="eda0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">示例数据集中的索引使用datetime，所以您会认为dataframe的索引是datetime索引，对吗？很不幸，你错了。让我们来看看输出:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="da8a" class="mw lv it ms b gy mx my l mz na">Index([‘10/1/2020 0:00’, ‘10/1/2020 0:00’, ‘10/1/2020 0:00’, ‘10/1/2020 0:01’,</span><span id="ca71" class="mw lv it ms b gy nb my l mz na">‘10/1/2020 0:01’, ‘10/1/2020 0:01’, ‘10/1/2020 0:01’, ‘10/1/2020 0:02’,</span><span id="7f3d" class="mw lv it ms b gy nb my l mz na">‘10/1/2020 0:02’, ‘10/1/2020 0:02’,</span><span id="3dba" class="mw lv it ms b gy nb my l mz na">…</span><span id="6e77" class="mw lv it ms b gy nb my l mz na">‘4/1/2021 2:01’, ‘4/1/2021 2:01’, ‘4/1/2021 2:02’, ‘4/1/2021 2:02’,</span><span id="738c" class="mw lv it ms b gy nb my l mz na">‘4/1/2021 2:02’, ‘4/1/2021 2:02’, ‘4/1/2021 2:03’, ‘4/1/2021 2:03’,</span><span id="7b0c" class="mw lv it ms b gy nb my l mz na">‘4/1/2021 2:03’, ‘4/1/2021 2:03’],</span><span id="7f5c" class="mw lv it ms b gy nb my l mz na">dtype=’object’, length=1048575)</span><span id="d4f1" class="mw lv it ms b gy nb my l mz na">&lt;class ‘pandas.core.indexes.base.Index’&gt;</span><span id="92be" class="mw lv it ms b gy nb my l mz na">&lt;class ‘str’&gt;</span></pre><p id="9280" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">指数看起来就像我们预期的那样。每个都表示日期和时间，同时遍历日期和时间，直到索引结束。每15秒记录一次样本，每分钟有4个，这很好，但是值没有显示秒数，这有点奇怪。</p><p id="17a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是事情变得奇怪了。当我们希望索引是日期时间索引时，它的类型是泛型。最后，第一个条目的类型是字符串，而不是日期时间对象。</p><p id="1de4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Pandas将日期时间索引作为字符串列表读入，而不是日期时间索引。每次都会这样。好在熊猫有一个<strong class="la iu"> to_datetime() </strong>函数解决了这个问题！考虑以下代码:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="41e4" class="mw lv it ms b gy mx my l mz na">data.index = pd.to_datetime(data.index)</span><span id="b38e" class="mw lv it ms b gy nb my l mz na">print(data.index)</span><span id="ebbe" class="mw lv it ms b gy nb my l mz na">print(type(data.index))</span><span id="4c9d" class="mw lv it ms b gy nb my l mz na">print(type(data.index[0]))</span></pre><p id="da22" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以及输出:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="ebb3" class="mw lv it ms b gy mx my l mz na">DatetimeIndex([‘2020–10–01 00:00:00’, ‘2020–10–01 00:00:00’,</span><span id="43c9" class="mw lv it ms b gy nb my l mz na">‘2020–10–01 00:00:00’, ‘2020–10–01 00:01:00’,</span><span id="0752" class="mw lv it ms b gy nb my l mz na">‘2020–10–01 00:01:00’, ‘2020–10–01 00:01:00’,</span><span id="c1c1" class="mw lv it ms b gy nb my l mz na">‘2020–10–01 00:01:00’, ‘2020–10–01 00:02:00’,</span><span id="ea28" class="mw lv it ms b gy nb my l mz na">‘2020–10–01 00:02:00’, ‘2020–10–01 00:02:00’,</span><span id="3377" class="mw lv it ms b gy nb my l mz na">…</span><span id="a61e" class="mw lv it ms b gy nb my l mz na">‘2021–04–01 02:01:00’, ‘2021–04–01 02:01:00’,</span><span id="7d4d" class="mw lv it ms b gy nb my l mz na">‘2021–04–01 02:02:00’, ‘2021–04–01 02:02:00’,</span><span id="db52" class="mw lv it ms b gy nb my l mz na">‘2021–04–01 02:02:00’, ‘2021–04–01 02:02:00’,</span><span id="14ea" class="mw lv it ms b gy nb my l mz na">‘2021–04–01 02:03:00’, ‘2021–04–01 02:03:00’,</span><span id="0705" class="mw lv it ms b gy nb my l mz na">‘2021–04–01 02:03:00’, ‘2021–04–01 02:03:00’],</span><span id="1885" class="mw lv it ms b gy nb my l mz na">dtype=’datetime64[ns]’, length=1048575, freq=None)</span><span id="affd" class="mw lv it ms b gy nb my l mz na">&lt;class ‘pandas.core.indexes.datetimes.DatetimeIndex’&gt;</span><span id="db0c" class="mw lv it ms b gy nb my l mz na">&lt;class ‘pandas._libs.tslibs.timestamps.Timestamp’&gt;</span></pre><p id="0a00" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">啊哈。这个看起来好多了。数据帧的索引现在是日期时间索引，第一个条目的类型现在是熊猫时间戳(相当于日期时间对象)。这是我们想要的，也是我们可以努力的。</p><p id="9702" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如果您想创建自己的日期时间索引呢？如果您知道想要创建日期时间索引的日期范围和频率，那么可以使用Pandas <strong class="la iu"> date_range() </strong>函数。这里有一个例子:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="ffb2" class="mw lv it ms b gy mx my l mz na">index = pd.date_range(datetime.datetime(2022, 1, 1, 0, 0), datetime.datetime(2022, 12, 31, 23, 55), freq = ‘5min’)</span><span id="0154" class="mw lv it ms b gy nb my l mz na">print(index)</span></pre><p id="9e0c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此代码返回以下输出:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="454d" class="mw lv it ms b gy mx my l mz na">DatetimeIndex([‘2022–01–01 00:00:00’, ‘2022–01–01 00:05:00’,</span><span id="8bff" class="mw lv it ms b gy nb my l mz na">‘2022–01–01 00:10:00’, ‘2022–01–01 00:15:00’,</span><span id="84cd" class="mw lv it ms b gy nb my l mz na">‘2022–01–01 00:20:00’, ‘2022–01–01 00:25:00’,</span><span id="0cab" class="mw lv it ms b gy nb my l mz na">‘2022–01–01 00:30:00’, ‘2022–01–01 00:35:00’,</span><span id="4a13" class="mw lv it ms b gy nb my l mz na">‘2022–01–01 00:40:00’, ‘2022–01–01 00:45:00’,</span><span id="bb26" class="mw lv it ms b gy nb my l mz na">…</span><span id="371a" class="mw lv it ms b gy nb my l mz na">‘2022–12–31 23:10:00’, ‘2022–12–31 23:15:00’,</span><span id="6bd9" class="mw lv it ms b gy nb my l mz na">‘2022–12–31 23:20:00’, ‘2022–12–31 23:25:00’,</span><span id="37dd" class="mw lv it ms b gy nb my l mz na">‘2022–12–31 23:30:00’, ‘2022–12–31 23:35:00’,</span><span id="f22c" class="mw lv it ms b gy nb my l mz na">‘2022–12–31 23:40:00’, ‘2022–12–31 23:45:00’,</span><span id="84a9" class="mw lv it ms b gy nb my l mz na">‘2022–12–31 23:50:00’, ‘2022–12–31 23:55:00’],</span><span id="10b0" class="mw lv it ms b gy nb my l mz na">dtype=’datetime64[ns]’, length=105120, freq=’5T’)</span></pre><p id="b54d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将调用date_range()的代码与函数的<a class="ae nc" href="https://pandas.pydata.org/docs/reference/api/pandas.date_range.html" rel="noopener ugc nofollow" target="_blank">文档进行比较，可以看到前两个条目设置了范围的开始和结束日期。开始日期设置为2022年1月1日午夜，结束范围设置为2022年12月31日23:55:00。第三个条目将日期时间索引的频率设置为五分钟。注意五分钟的代码是<strong class="la iu">‘5min’</strong>。为了获得您想要的频率，您需要使用正确的代码来设置频率。幸运的是，有一个熊猫代码列表</a><a class="ae nc" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases" rel="noopener ugc nofollow" target="_blank">可用。</a></p><p id="9607" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用熊猫日期时间索引也可能有点麻烦。乍一看，似乎需要创建复杂的datetime对象来引用dataframe的正确部分。考虑下面的例子，其中我使用上一个例子中的索引创建了一个新的dataframe，在dataframe中设置一个值并打印该值以确保它正确更新。</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="b57e" class="mw lv it ms b gy mx my l mz na">df = pd.DataFrame(index = index, columns = [‘Example’])</span><span id="97fb" class="mw lv it ms b gy nb my l mz na">df.loc[datetime.datetime(2022, 1, 1, 0, 0, 0), ‘Example’] = 2</span><span id="d923" class="mw lv it ms b gy nb my l mz na">print(df.loc[datetime.datetime(2022, 1, 1, 0, 0, 0), ‘Example’])</span></pre><p id="9888" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这段代码的输出正是我想要的。它打印出<strong class="la iu"> 2 </strong>，显示dataframe在<strong class="la iu"> [datetime.datetime(2022，1，1，0，0，0)，‘Example ']</strong>的值为所需的<strong class="la iu"> 2 </strong>。但是一遍又一遍地指定日期时间变得很乏味。</p><p id="cbc7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">幸运的是，您仍然可以通过位置引用日期时间索引。如果要编辑索引中的第一个条目，可以按如下方式操作。</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="702a" class="mw lv it ms b gy mx my l mz na">df = pd.DataFrame(index = index, columns = [‘Example’])</span><span id="2353" class="mw lv it ms b gy nb my l mz na">df.loc[df.index[0], ‘Example’] = 2</span><span id="f840" class="mw lv it ms b gy nb my l mz na">print(df.loc[df.index[0], ‘Example’])</span></pre><p id="eb8d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意这段代码是如何做完全相同的事情的，只是它通过调用索引的第一个值来提供所需的索引值。你甚至不需要知道有什么价值，你只需要知道你想用第一个——或者第二个，或者第三个，或者任何你想要的价值。您只需要相应地更新呼叫。</p><h1 id="f7ce" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">夏令时</h1><p id="42e0" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">使用夏令时是Python中最大的难题之一，并且会导致非常严重的数据分析错误。考虑将物理测量值与理论近似值进行比较的例子。现在你有两个数据集，你想确保他们说的是同一件事。如果一个数据集使用夏令时，而另一个数据集不使用夏令时，该怎么办？突然间，你开始比较相差一小时的数据集。</p><p id="1e9e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">解决此问题的一种方法是，在夏令时发生的时间内，从具有夏令时的dataframe索引中删除一个小时。为了帮助解决这个问题，熊猫的时间戳有一个<strong class="la iu">。dst() </strong>方法，返回任意点的夏令时差。如果时间戳发生在夏令时，它将返回一个小时的<strong class="la iu"> datetime.timedelta </strong>值。如果时间戳在夏令时期间没有出现，它将返回一个零小时的<strong class="la iu"> datetime.timedelta </strong>值。这使我们能够识别夏令时期间出现的时间戳，并相应地从中删除一个小时。</p><p id="64e9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设您有一个包含夏令时偏移量的datetime索引的数据帧。要删除夏令时，可以遍历索引，使索引时区为naive，并从索引中删除一个小时。不幸的是，索引是不可变的，所以您不能直接编辑它们。您可以做的是创建一个外部值列表，将更新后的索引值添加到该列表中，并在最后用该列表替换索引。这段代码应该是这样的。</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="8a9b" class="mw lv it ms b gy mx my l mz na">temp = []</span><span id="2a4f" class="mw lv it ms b gy nb my l mz na">for ix in range(len(df.index)):</span><span id="692b" class="mw lv it ms b gy nb my l mz na">if df.index[ix].dst() == datetime.timedelta(hours = 1):</span><span id="8079" class="mw lv it ms b gy nb my l mz na">temp.append(df.index[ix].tz_localize(None) — datetime.timedelta(hours = 1))</span><span id="240a" class="mw lv it ms b gy nb my l mz na">else:</span><span id="cdbc" class="mw lv it ms b gy nb my l mz na">temp.append(df.index[ix].tz_localize(None))</span><span id="feaa" class="mw lv it ms b gy nb my l mz na">df.index = temp</span></pre><p id="00c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在你知道了。现在您知道了如何使用datetime对象，使用它们来构成Pandas数据帧的索引，并从您的数据集中删除夏令时。</p></div></div>    
</body>
</html>