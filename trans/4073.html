<html>
<head>
<title>Burrows Wheeler in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的Burrows Wheeler</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/burrows-wheeler-in-python-c07cbf71b3f0#2022-09-09">https://towardsdatascience.com/burrows-wheeler-in-python-c07cbf71b3f0#2022-09-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6586" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">神奇的算法来索引和压缩大型字符串数据，然后迅速找到子字符串</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0c9988a6bd30b339ef0fdadd47d1d2d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YPASUV5dRpnBrgHk"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@soulsana?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> SOULSANA </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="0294" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Burrows Wheeler变换(BWT)是由Michael Burrows和David Wheeler在1994年开发的。简而言之，BWT是一种字符串转换，作为无损压缩的预处理步骤。BWT的实现展示了线性O(n)性能和空间复杂度。最初的设计是为了用bzip2等技术准备压缩数据，BWT在生物信息学中获得了突出的地位，允许快速绘制短阅读图谱，为高通量基因测序铺平了道路。</p><p id="982b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将在python中实现一个简单的BWT，然后展示如何使用简化的后缀数组BWT找到不匹配的小段。</p><p id="9e61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> BWT算法:</strong></p><ol class=""><li id="ca4e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">旋转字母:苹果变成['eappl '，' leapp '，' pleap '，' pplea '，' apple']</li><li id="c1eb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">按字母顺序排列旋转单词:['apple '，' eappl '，' leapp '，' pleap '，' pplea']</li><li id="5386" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">取最后一列:elppa</li></ol><p id="419b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">苹果公司的BWT成为埃尔帕</p><p id="2075" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://gist.github.com/glickmac/0f5bcd0a76d4913f7fbab1d46ac8d026" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">BWT</strong></a>的简单实现</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="5b7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">用后缀数组实现模糊字符串搜索的BWT</strong></p><p id="6732" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个python实现中，我们将生成一个后缀数组，并使用它来执行BWT。</p><p id="f072" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">来自后缀数组的BWT算法:</strong></p><ol class=""><li id="8398" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">生成后缀数组:苹果变成[5，0，4，3，2，1]</li><li id="ef9b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">后缀数组BWT的实现:apple + [5，0，4，3，2，1]变成:e$lppa</li><li id="efa3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">查找匹配位置:apple中的应用程序返回位置[0]</li><li id="862a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">查找不完全匹配:apple中不匹配=1的apl返回位置[0，1]</li></ol><p id="42dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码块定义了用于查找不完全匹配的函数。<strong class="lb iu"> generate_all("apple") </strong>下面块中的terminal函数返回一组唯一字母、BWT输出、<a class="ae ky" href="https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/bwt.pdf#:~:text=BWT%28unabashable%29%20LF%20Mapping%20%E2%88%91%20BWTSearch%28aba%29%20Start%20from%20the,b%20in%20the%20%EF%AC%81rst%20row%20of%20the%20range." rel="noopener ugc nofollow" target="_blank"> LF映射</a>、唯一字母索引和后缀数组。</p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="7209" class="mq mr it mm b gy ms mt l mu mv">generate_all("apple")</span></pre><p id="ca44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">退货:</strong></p><p id="c38e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">({'a '，' e '，' l '，' p'}，<br/> 'e$lppa '，<br/> {'e': [1，1，1，1，1，1，1，0]，<br/> 'p': [0，0，0，1，2，2，2，0]，<br/> 'l': [0，0，1，1，1，1，1，0]，<br/> '$': [0，1，1，1，1，1，0]，【0</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="71c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">在BWT数据中识别(模糊匹配)子串</strong></p><p id="2c38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们通过以下算法识别BWT字符串中的匹配。所有搜索都是反向进行的，例如在苹果中查找应用程序，首先是查找“p”，然后是“pp”，然后是“app”。</p><blockquote class="mw mx my"><p id="43e2" class="kz la mz lb b lc ld ju le lf lg jx lh na lj lk ll nb ln lo lp nc lr ls lt lu im bi translated">注意:Last First (LF)属性是最后一列中第I次出现的字母[X]对应于第一列中第I次出现的字母[X]。</p></blockquote><ol class=""><li id="f849" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">在BWT的第一列中查找搜索字符串中最后一个字母的范围</li><li id="e475" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">看看BWT最后一栏的相同范围</li><li id="a16f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在LF映射中查找下一个要搜索的字符。将“下一个字符”列[NC]设置为等于LF映射矩阵中观察范围的映射条目。将LF映射矩阵中的下一列[NC+1]设置为等于当前范围最后+1行中的“下一个字符”值。</li><li id="5b4c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">找到第一行中“下一个字符”的范围，并使用NC &amp; NC+1在“下一个字符”范围内找到正确的子范围。</li></ol><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="094f" class="mq mr it mm b gy ms mt l mu mv">find("app", 'apple', mismatches=0)</span></pre><p id="3960" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">回报:</strong> [0]</p><p id="8789" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还实现了一种方法来识别子序列中的错配。但是字符必须相同。</p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="4f02" class="mq mr it mm b gy ms mt l mu mv">find("apZ", 'apple', mismatches=1)</span></pre><p id="94c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">返回:</strong> []“空返回，因为<strong class="lb iu"> Z </strong>不在引用字符串中”</p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="b505" class="mq mr it mm b gy ms mt l mu mv">find("ape", 'apple', mismatches=1)</span></pre><p id="d6d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">退货:</strong> [0]</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="edc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/glickmac/Burrows_Wheeler_in_Python" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">执行后缀数组BWT的完整笔记本可以在GitHub上找到。</strong>T13】</a></p><h1 id="d8af" class="nd mr it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">BWT &amp;寻找爱丽丝梦游仙境</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/132105fdc760e169bd9a0b87484f8a4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NlzzngXEgcZ5EWUv"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安妮·斯普拉特在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="f051" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们下面的组块将展示BWT的有用性和速度。我们将从古腾堡的<a class="ae ky" href="https://www.gutenberg.org/ebooks/11" rel="noopener ugc nofollow" target="_blank">项目下载一份</a><a class="ae ky" href="https://www.gutenberg.org/files/11/11-0.txt" rel="noopener ugc nofollow" target="_blank">爱丽丝漫游奇境记</a>，并从第8章开始阅读课文。这留给我们一个61235个字符的文本文档，由3762行27432个单词组成(对于我们的目的来说仍然很大)。然后我们将寻找短语<strong class="lb iu">“砍掉她的头”</strong>被提及的次数。我们将比较我们的BWT搜索和默认的python字符串搜索。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="0cde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建后缀数组并执行BWT大约需要3秒钟。这就是神奇的地方。创建BWT后，我们可以执行比标准字符串搜索快几个数量级的搜索。即使是模糊搜索也比标准字符串搜索快100倍。哇！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/3a1442f5352751ccb11e20f2241e55db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Q3hyDQzOjB40zM91bMfrA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">字符串搜索的速度性能比较。图片作者。</p></figure><h1 id="23ae" class="nd mr it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">包裹</h1><p id="ed03" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">这篇文章的代码可以在我的个人<strong class="lb iu"> </strong> <a class="ae ky" href="https://github.com/glickmac/Burrows_Wheeler_in_Python" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> GitHub </strong> </a>上找到。将小的基因序列映射成一个巨大的基因组串的速度是BWT搜索在生物信息学工具中流行的原因，如<a class="ae ky" href="https://genomebiology.biomedcentral.com/articles/10.1186/gb-2009-10-3-r25#:~:text=Abstract%20Bowtie%20is%20an%20ultrafast%2C%20memory-efficient%20alignment%20program,with%20a%20memory%20footprint%20of%20approximately%201.3%20gigabytes." rel="noopener ugc nofollow" target="_blank">蝴蝶结</a>和<a class="ae ky" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2705234/" rel="noopener ugc nofollow" target="_blank"> BWA </a>。我的名字是<a class="ae ky" href="https://codyglickman.com/" rel="noopener ugc nofollow" target="_blank">科迪·格利克曼</a>，可以在<a class="ae ky" href="https://www.linkedin.com/in/codyglickman/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上找到我。一定要看看我的其他一些文章！</p><div class="ob oc gp gr od oe"><a href="https://glickmancody.medium.com/membership" rel="noopener follow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">通过我的推荐链接加入Medium-Cody Glickman博士</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">阅读科迪·格利克曼博士(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">glickmancody.medium.com</p></div></div><div class="on l"><div class="oo l op oq or on os ks oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a rel="noopener follow" target="_blank" href="/data-augmentation-in-medical-images-95c774e6eaae"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">医学图像中的数据增强</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">如何通过重塑和重采样数据来提高视觉模型的性能</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">towardsdatascience.com</p></div></div><div class="on l"><div class="ot l op oq or on os ks oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a rel="noopener follow" target="_blank" href="/building-a-beautiful-static-webpage-using-github-f0f92c6e1f02"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">使用GitHub创建漂亮的静态网页</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">查找模板和为静态网页创建表单的位置</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">towardsdatascience.com</p></div></div><div class="on l"><div class="ou l op oq or on os ks oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a rel="noopener follow" target="_blank" href="/pfam-database-filtering-using-python-164c3131c897"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">使用Python进行Pfam数据库过滤</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">通过字符串搜索选择隐马尔可夫模型(HMM)</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">towardsdatascience.com</p></div></div><div class="on l"><div class="ov l op oq or on os ks oe"/></div></div></a></div></div></div>    
</body>
</html>