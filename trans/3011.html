<html>
<head>
<title>An introduction to mixed-integer linear programming: The knapsack problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">混合整数线性规划导论:背包问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/an-introduction-to-mixed-integer-linear-programming-the-knapsack-problem-1445452a9fe9#2022-07-01">https://towardsdatascience.com/an-introduction-to-mixed-integer-linear-programming-the-knapsack-problem-1445452a9fe9#2022-07-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d79d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何使用scipy和<em class="kf"> pyomo </em>解决Python中的优化问题</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/139b812929cb96b3decb602b2036f1c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qrRU7hla8gn-6CsW"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">照片由<a class="ae kw" href="https://unsplash.com/es/@denisseleon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹尼斯·莱昂</a>在<a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="0009" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">背包问题可能是学习整数规划、最优化或运筹学时首先面临的问题之一。在这个问题中，从给定的一组物品中，人们必须选择最有价值的组合，以适合特定容量(重量、体积或两者)的背包。</p><p id="79c5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在整篇文章中，我们将使用<em class="lt"> scipy </em>实现背包问题的多维变体，使用<em class="lt"> pyomo </em>和<em class="lt"> GLPK </em>解算器实现整数形式。学习如何使用这两个框架对将来解决更复杂的问题有很大帮助，背包问题是一个惊人的开始。</p><p id="58f7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">多维背包是经典问题的变体，其中考虑了一个以上的约束。它增加了复杂性，这有助于探索连续域和离散域结果之间的差异，如下一节所述。</p><p id="5eb7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">感兴趣的人可以跟随本<a class="ae kw" href="https://github.com/bruscalia/optimization-demo-files/blob/47e1371e9cf4bb04c05b0b31e7f497c3a4b94e62/mip/knapsack/notebooks/simple_knapsack.ipynb" rel="noopener ugc nofollow" target="_blank">示例笔记本</a>中的完整代码。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="35ad" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">线性规划和松弛公式</h1><p id="a8d9" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">当公式化优化问题时，必须定义一个目标，该目标是向量决策变量<strong class="kz ir"> <em class="lt"> x </em> </strong>的函数，并且可能受到一些等式和不等式约束，这些约束也是<strong class="kz ir"> <em class="lt"> x </em> </strong>的函数。该目标通常在<em class="lt">最小化</em>意义上定义，因此目标是在遵守约束的同时找到其最低值。最大化目标可以通过简单地将相应的最小化目标乘以-1来表达。在公式中，<strong class="kz ir"> <em class="lt"> x </em> </strong>的每个分量的上下边界可能是明确的，这减少了搜索空间。按照惯例，由于求解技术的原因，决策变量的下限通常默认等于零。</p><p id="4c94" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">由于线性问题的目标和约束都是其决策变量的线性组合，因此该问题可以表述如下。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi my"><img src="../Images/9766f6cca6bb0f6fde66d3f69e347eab.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*AKJ0LXS19u2Xrgnt9XtS0A.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">线性问题。(图片由作者提供)。</p></figure><p id="c179" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当定义一个<em class="lt">宽松的</em>公式时，意味着原始问题有一些整数决策变量，宽松的形式将这些变量转换成连续变量。这正是第一部分将要发生的事情。因此，让我们首先定义背包问题的要素。</p><p id="dd6a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">决策变量:</strong></p><ul class=""><li id="6639" class="mz na iq kz b la lb ld le lg nb lk nc lo nd ls ne nf ng nh bi translated"><strong class="kz ir"><em class="lt">x</em>:<em class="lt"/></strong><em class="lt">C</em>添加到背包中的各物品数量的列向量。在这个例子中，它将以[0，1]为界。</li></ul><p id="f8ac" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">固定参数:</strong></p><ul class=""><li id="8656" class="mz na iq kz b la lb ld le lg nb lk nc lo nd ls ne nf ng nh bi translated"><strong class="kz ir"> <em class="lt"> c </em> : </strong>与每个决策变量相关的成本(其值为负)。</li><li id="d1d1" class="mz na iq kz b la ni ld nj lg nk lk nl lo nm ls ne nf ng nh bi translated"><strong class="kz ir"> <em class="lt">一个</em> _{ub}: </strong>矩阵的不等式约束条件。</li><li id="35a9" class="mz na iq kz b la ni ld nj lg nk lk nl lo nm ls ne nf ng nh bi translated"><strong class="kz ir"> <em class="lt"> a </em> _{1，i}: </strong>物品单位重量<em class="lt"> i </em>。</li><li id="56b2" class="mz na iq kz b la ni ld nj lg nk lk nl lo nm ls ne nf ng nh bi translated"><strong class="kz ir"> <em class="lt"> a </em> _{2，i}: </strong>项目单位体积<em class="lt"> i </em>。</li><li id="a136" class="mz na iq kz b la ni ld nj lg nk lk nl lo nm ls ne nf ng nh bi translated"><strong class="kz ir"> <em class="lt"> b </em> _{ub}: </strong>带有背包重量和体积容量的列向量。</li></ul><p id="88eb" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们用Python创建这些元素。首先，使用字典，这将在后面的<em class="lt"> pyomo </em>中有用。在这里，我使用一个固定的随机种子来获得相同的结果。</p><pre class="kh ki kj kk gt nn no np bn nq nr bi"><span id="781a" class="ns mc iq no b be nt nu l nv nw"># Import numpy<br/>import numpy as np<br/><br/># Set of items<br/>I = set(range(1, 11))<br/><br/># Random seed<br/>np.random.seed(12)<br/><br/># Weight associated with each item<br/>w = dict(zip(I, np.random.normal(loc=5.0, scale=1.0, size=10).clip(0.5, 10.0)))<br/><br/># Volume associated with each item<br/>v = dict(zip(I, np.random.normal(loc=6.0, scale=2.0, size=10).clip(0.5, 10.0)))<br/><br/># Price associated with each item<br/>price = dict(zip(I, np.random.normal(loc=10.0, scale=1.0, size=10).clip(0.5, 20.0)))<br/><br/># knapsack capacity<br/>kw, kv = 21.0, 22.0</span></pre><p id="6397" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然后在<em class="lt"> numpy </em>样式中使用<em class="lt"> scipy </em>。</p><pre class="kh ki kj kk gt nn no np bn nq nr bi"><span id="aba4" class="ns mc iq no b be nt nu l nv nw"># Costs<br/>c = -np.array(list(price.values()))<br/><br/># Inequality constraints matrix<br/>A_ub = np.array([<br/>    np.array(list(w.values())),<br/>    np.array(list(v.values()))<br/>])<br/><br/># Upper bounds for linear inequality constraints<br/>b_ub = np.array([kw, kv])<br/><br/># Bounds (one quantity of each item)<br/>bounds = [(0, 1),] * 10</span></pre><p id="8c07" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在我们已经拥有了使用来自<em class="lt"> scipy </em>的<em class="lt"> linprog </em>来解决这个问题的所有必要元素。</p><pre class="kh ki kj kk gt nn no np bn nq nr bi"><span id="d993" class="ns mc iq no b be nt nu l nv nw">from scipy.optimize import linprog<br/><br/># Obtain solution<br/>sol = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds)<br/><br/>print(sol)</span></pre><p id="7ee7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">它返回以下内容。</p><pre class="kh ki kj kk gt nn no np bn nq nr bi"><span id="ff57" class="ns mc iq no b be nt nu l nv nw">con: array([], dtype=float64)<br/>fun: -44.817244893700625<br/>message: 'Optimization terminated successfully.'<br/>nit: 6<br/>slack: array([-1.68047194e-08, -2.36582025e-08])<br/>status: 0<br/>success: True<br/>x: array([9.99999999e-01, 8.65571091e-01, 7.40355899e-10, 1.00000000e+00, 2.62434803e-10, 2.98795062e-09, 2.33299681e-10, 8.80512141e-01, 9.99999997e-01, 2.05849974e-10])</span></pre><p id="53ee" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">注意<strong class="kz ir"> <em class="lt"> x </em> </strong>中的一些项目是分数，这在某些情况下是不可能的。因此，对于这些情况，我们必须找到一种方法，使用决策变量的整数值来找到最佳可行解。</p><p id="e69a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">从版本1.9.0开始，<em class="lt"> scipy </em>有了一个混合整数线性规划解算器。因此，我们可以通过将<em class="lt">完整性</em>关键字参数解析为<em class="lt"> linprog </em>来将松弛背包问题转化为整数版本。全整数变量应该被赋予1，而连续变量应该被赋予0，其形状与决策变量向量相同。</p><pre class="kh ki kj kk gt nn no np bn nq nr bi"><span id="fb6e" class="ns mc iq no b be nt nu l nv nw"># Assign ones to integer variables<br/>integrality_vector = np.full(c.shape[0], 1)<br/><br/># Obtain solution<br/>sol_int = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, integrality=integrality_vector)</span></pre><p id="18ec" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">有些问题用矩阵形式表述更复杂，因为它们包含几组在大集合上定义的约束和决策变量。在这些情况下，数学建模语言有利于创建和转换求解器可以成功解释的代数表达式。在下一节中，我们将看到如何使用数学建模Python包<em class="lt"> pyomo </em>将背包问题公式化。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="40d5" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">整数背包问题</h1><p id="29d1" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">为了使用整数变量来表述这个问题，我们将使用<em class="lt"> pyomo </em>来创建代数整数线性模型，这些模型可以由通常的代数优化解算器来解释。所以让我们从进口<em class="lt"> pyomo </em>开始。</p><pre class="kh ki kj kk gt nn no np bn nq nr bi"><span id="52a0" class="ns mc iq no b be nt nu l nv nw">import pyomo.environ as pyo</span></pre><p id="a422" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在<em class="lt"> pyomo </em>中有两种建模方法:<em class="lt">抽象</em>和<em class="lt">具体</em>模型。在第一种方法中，问题的代数表达式是在提供一些数据值之前定义的，而在第二种方法中，模型实例是在定义其元素时立即创建的。你可以在<a class="ae kw" href="https://pyomo.readthedocs.io/en/stable/pyomo_overview/abstract_concrete.html" rel="noopener ugc nofollow" target="_blank">库文档</a>或者拜纳姆等人的书(2021)中找到更多关于这些方法的信息。贯穿本文，我们将采用<em class="lt">具体的</em>模型表述。</p><pre class="kh ki kj kk gt nn no np bn nq nr bi"><span id="41bc" class="ns mc iq no b be nt nu l nv nw">model = pyo.ConcreteModel()</span></pre><p id="8ee2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在代数数学优化语句中，通常在<em class="lt">集合</em>上定义变量和/或表达式。在背包问题中，我们有与每个项目相关的决策变量和参数。因此，我们将创建一个<em class="lt">项目集</em>，每个项目都有一个相关的键。</p><pre class="kh ki kj kk gt nn no np bn nq nr bi"><span id="e339" class="ns mc iq no b be nt nu l nv nw"># Set of items (previously defined)<br/>I = set(range(1, 11))<br/><br/># As an attribute of the problem<br/>model.I = pyo.Set(initialize=I)</span></pre><p id="401d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">第二步，我们将定义这个问题的一些固定参数。下面列出了它们。</p><ul class=""><li id="964b" class="mz na iq kz b la lb ld le lg nb lk nc lo nd ls ne nf ng nh bi translated"><strong class="kz ir"> <em class="lt"> kw: </em> </strong>背包的重量容量。</li><li id="d488" class="mz na iq kz b la ni ld nj lg nk lk nl lo nm ls ne nf ng nh bi translated"><strong class="kz ir"> <em class="lt"> kv: </em> </strong>背包的体积容量。</li><li id="f7d0" class="mz na iq kz b la ni ld nj lg nk lk nl lo nm ls ne nf ng nh bi translated"><strong class="kz ir"><em class="lt">w _</em>I<em class="lt">:</em></strong>集合<em class="lt"> I </em>中每个项目<em class="lt"> i </em>关联的权重。</li><li id="ee8a" class="mz na iq kz b la ni ld nj lg nk lk nl lo nm ls ne nf ng nh bi translated"><strong class="kz ir"><em class="lt">v _</em>I<em class="lt">:</em></strong>与集合<em class="lt"> I </em>中每一项<em class="lt"> i </em>关联的体积。</li><li id="6f91" class="mz na iq kz b la ni ld nj lg nk lk nl lo nm ls ne nf ng nh bi translated"><strong class="kz ir"><em class="lt">c _</em>I<em class="lt">:</em></strong>集合<em class="lt"> I </em>中每一项<em class="lt"> i </em>关联的成本(值)。</li></ul><p id="2b3f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">与背包相关联的参数是固定标量。因此，我们可以通过下面的代码实例化它们。</p><pre class="kh ki kj kk gt nn no np bn nq nr bi"><span id="f0ee" class="ns mc iq no b be nt nu l nv nw"># knapsack capacity<br/>kw, kv = 21.0, 22.0<br/><br/># Parameters of the knapsack<br/>model.kw = pyo.Param(initialize=kw)<br/>model.kv = pyo.Param(initialize=kv)</span></pre><p id="9b5a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然而，必须为集合<em class="lt"> I </em>中的每个元素定义与每个项目相关的参数。这可以通过将集合作为第一个参数在<em class="lt"> pyo中传递来实现。参数</em>定义。如果定义的元素(变量、参数、表达式或约束)由多个集合索引，则可以在此语句中传递多个集合。这个定义是Python <em class="lt"> *args </em>风格的。</p><pre class="kh ki kj kk gt nn no np bn nq nr bi"><span id="7fb6" class="ns mc iq no b be nt nu l nv nw"># Parameters of the items<br/>model.v = pyo.Param(model.I, initialize=v)<br/>model.w = pyo.Param(model.I, initialize=w)<br/>model.c = pyo.Param(model.I, initialize=price)</span></pre><p id="9c86" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">记住<em class="lt"> v </em>、<em class="lt"> w </em>和<em class="lt"> price </em>是之前定义的Python字典，其中key是<em class="lt"> I </em>中的元素。</p><p id="5adf" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在让我们来定义这个问题的决策变量:对于集合<em class="lt"> I </em>中的每个物品，添加到背包中的物品数量。请注意，我在[0，1]中定义了宽松公式的界限。因此，另一种说法可能是在<em class="lt"> pyo中定义这些变量。二进制</em>。</p><pre class="kh ki kj kk gt nn no np bn nq nr bi"><span id="5f46" class="ns mc iq no b be nt nu l nv nw">model.x = pyo.Var(model.I, within=pyo.Integers, bounds=(0, 1))</span></pre><p id="aabc" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">太好了！现在我们已经定义了决策变量和固定参数，我们可以定义问题的约束和目标。</p><p id="ee9e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这些约束可以用下面的等式来表示。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/96f946536023323cb69f7d6f33725efe.png" data-original-src="https://miro.medium.com/v2/resize:fit:356/format:webp/1*-jPJ1oHXBsfa2CykHXnasw.png"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">背包问题的约束。(图片由作者提供)。</p></figure><p id="c469" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Python中的意思是。</p><pre class="kh ki kj kk gt nn no np bn nq nr bi"><span id="6cd0" class="ns mc iq no b be nt nu l nv nw">def weight_constraint(model):<br/>    return sum(model.x[i] * model.w[i] for i in model.I) \<br/>        &lt;= model.kw<br/><br/>model.weight_constraint = pyo.Constraint(rule=weight_constraint)<br/><br/>def volume_constraint(model):<br/>    return sum(model.x[i] * model.v[i] for i in model.I) \<br/>        &lt;= model.kv<br/><br/>model.volume_constraint = pyo.Constraint(rule=volume_constraint)</span></pre><p id="6d19" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">注意，在创建与每个约束相关的函数时，<em class="lt">模型</em>是一个强制参数。当我们将它传递给函数时，我们可以引用之前定义的属性<em class="lt"> x </em>、<em class="lt"> w </em>、<em class="lt"> v </em>、<em class="lt"> kw </em>、<em class="lt"> kv </em>和<em class="lt"> I </em>。</p><p id="7225" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在，让我们定义目标函数。由于<em class="lt"> c </em>被定义为与每个物品相关联的正值，我们的目标将是最大化背包中运输的价值。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/761f32d024e3806b67c2898086a44799.png" data-original-src="https://miro.medium.com/v2/resize:fit:438/format:webp/1*lbFPFQogLCSQ1BJQfROPzw.png"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">背包问题的目标函数。(图片由作者提供)。</p></figure><p id="16a1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Python中是这样的。</p><pre class="kh ki kj kk gt nn no np bn nq nr bi"><span id="ed8a" class="ns mc iq no b be nt nu l nv nw">def obj_function(model):<br/>    return sum(model.x[i] * model.c[i] for i in model.I)<br/><br/>model.objective = pyo.Objective(rule=obj_function, sense=pyo.maximize)</span></pre><p id="2362" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了解决这个问题，我们必须实例化一个求解器。在这个例子中，我将使用<em class="lt"> GLPK </em>，它是开源的，因此任何用户都可以下载并执行。在“您的_路径_到_GLPK”字段中，添加到<em class="lt">glpsol.exe</em>文件的路径。例如，我的路径是“C:\\glpk-4.65\\w64\\glpsol.exe”。</p><p id="047f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">最新可用的<em class="lt"> GLPK </em>版本可在<a class="ae kw" href="http://ftp.gnu.org/gnu/glpk/" rel="noopener ugc nofollow" target="_blank">这里</a>找到，Windows可执行文件可在<a class="ae kw" href="https://sourceforge.net/projects/winglpk/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><pre class="kh ki kj kk gt nn no np bn nq nr bi"><span id="1dea" class="ns mc iq no b be nt nu l nv nw">opt = pyo.SolverFactory('glpk', executable=YOUR_PATH_TO_GLPK)<br/><br/># You can add a time limit by using the following command line<br/>opt.options['tmlim'] = 120<br/><br/>solution = opt.solve(model)</span></pre><p id="98b3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在，我们可以使用<em class="lt">显示</em>方法来检查模型的元素。对于目标函数，请参见下面的代码。</p><pre class="kh ki kj kk gt nn no np bn nq nr bi"><span id="b269" class="ns mc iq no b be nt nu l nv nw">model.objective.display()</span></pre><p id="2c3f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">它应该返回以下输出。</p><pre class="kh ki kj kk gt nn no np bn nq nr bi"><span id="a5ec" class="ns mc iq no b be nt nu l nv nw">objective : Size=1, Index=None, Active=True<br/>Key  : Active : Value<br/>None :   True : 39.88187183116921</span></pre><p id="4a4e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">因此，人们可能会注意到我们的整数解(39.88)比使用<em class="lt">松弛</em>公式(44.82)得到的结果更差。这发生在整数问题中，因为与<em class="lt">松弛</em>问题中的相应空间相比，决策空间必然减少。</p><p id="ccd8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">通过研究决策变量的差异，人们可能会注意到:</p><ul class=""><li id="d883" class="mz na iq kz b la lb ld le lg nb lk nc lo nd ls ne nf ng nh bi translated">在两种情况下都添加了项目1。</li><li id="ee33" class="mz na iq kz b la ni ld nj lg nk lk nl lo nm ls ne nf ng nh bi translated">仅在放松问题中部分添加了第2项—值0.87。</li><li id="5bfe" class="mz na iq kz b la ni ld nj lg nk lk nl lo nm ls ne nf ng nh bi translated">仅在整数题中增加了第3项。</li><li id="f31b" class="mz na iq kz b la ni ld nj lg nk lk nl lo nm ls ne nf ng nh bi translated">在两种情况下都添加了第4项。</li><li id="9878" class="mz na iq kz b la ni ld nj lg nk lk nl lo nm ls ne nf ng nh bi translated">第5项在任何情况下都没有添加。</li><li id="c635" class="mz na iq kz b la ni ld nj lg nk lk nl lo nm ls ne nf ng nh bi translated">第6项在任何情况下都没有添加。</li><li id="485d" class="mz na iq kz b la ni ld nj lg nk lk nl lo nm ls ne nf ng nh bi translated">第7项在任何情况下都没有添加。</li><li id="9d11" class="mz na iq kz b la ni ld nj lg nk lk nl lo nm ls ne nf ng nh bi translated">第8项在松弛问题中被部分添加—值0.88 —但在整数版本中被完全添加。</li><li id="0625" class="mz na iq kz b la ni ld nj lg nk lk nl lo nm ls ne nf ng nh bi translated">第9项仅在放松问题中完全添加。</li><li id="8fd4" class="mz na iq kz b la ni ld nj lg nk lk nl lo nm ls ne nf ng nh bi translated">在任何情况下都没有添加项目10。</li></ul></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="7a35" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">进一步阅读</h1><p id="ae22" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">对<em class="lt">线性规划</em>的更多细节感兴趣的可以参考luen Berger&amp;Ye(2008)；整数规划见Wolsey(2020)；对于运筹学，温斯顿&amp;戈德堡(2004)。</p><p id="e1a6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">只有一个约束和二元变量的整数规划问题通常被称为<em class="lt">背包问题</em> (Winston &amp; Goldberg，2004)。这些问题可以通过动态编程有效地解决，这可能是另一篇文章的重点。</p><p id="a8d4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在另一个<a class="ae kw" href="https://github.com/bruscalia/optimization-demo-files/blob/47e1371e9cf4bb04c05b0b31e7f497c3a4b94e62/mip/knapsack/notebooks/multiple_knapsacks.ipynb" rel="noopener ugc nofollow" target="_blank">示例</a>笔记本中可以找到带有多个背包和一些附加规则的背包问题的扩展公式。</p><p id="b7f9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">分枝定界算法是整数和混合整数问题求解中最常用的算法。对其机制的介绍感兴趣的人可以参考我的另一篇文章:</p><div class="nz oa gp gr ob oc"><a rel="noopener follow" target="_blank" href="/a-gentle-introduction-to-branch-bound-d00a4ee1cad"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd ir gy z fp oh fr fs oi fu fw ip bi translated">分支和绑定的简单介绍</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">用Python解释的最基本的整数和混合整数编程算法</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">towardsdatascience.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq kq oc"/></div></div></a></div></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="067a" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">结论</h1><p id="434c" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">在本文中，我们看到了混合整数线性规划的介绍。使用<em class="lt"> scipy </em>获得多维背包问题的松弛形式的解，使用<em class="lt"> pyomo </em>和<em class="lt"> GLPK </em>解算器获得整数形式的解。这些示例中使用的<a class="ae kw" href="https://github.com/bruscalia/optimization-demo-files/blob/47e1371e9cf4bb04c05b0b31e7f497c3a4b94e62/mip/knapsack/notebooks/simple_knapsack.ipynb" rel="noopener ugc nofollow" target="_blank">完整代码</a>可供进一步使用。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="96b9" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">参考</h1><p id="4daa" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">拜纳姆，马丁等人，2021。<em class="lt">pyo mo-python中的优化建模。</em>斯普林格。</p><p id="caac" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">卢恩伯格，D. G .和叶，2008年。<em class="lt">线性和非线性规划。第三版。斯坦福:斯普林格。</em></p><p id="bb09" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">温斯顿，W. L .和戈德堡，J. B .，2004年。运筹学:应用与算法。4版。加州贝尔蒙特:汤姆森布鲁克斯/科尔贝尔蒙特。</p><p id="4f09" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">2020年洛杉矶沃尔西。<em class="lt">整数编程。</em>第二版。约翰·威利的儿子们。</p></div></div>    
</body>
</html>