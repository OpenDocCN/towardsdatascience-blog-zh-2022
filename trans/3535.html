<html>
<head>
<title>The Benefits of Static Initialization for Your AWS Lambda Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS Lambda函数静态初始化的好处</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-benefits-of-static-initialization-for-your-aws-lambda-functions-c7372f682188#2022-08-05">https://towardsdatascience.com/the-benefits-of-static-initialization-for-your-aws-lambda-functions-c7372f682188#2022-08-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b30b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何有效地编写和优化无服务器函数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7a638050ab2c128502cfe1daaf2af1a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HQ_nccT379HFsd8m"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">约尔格·安格利在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e615" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">无服务器并不是一个流行词。这是用词不当。没有服务器也能运行应用程序的想法听起来像是魔术。如何才能避免让服务器全天候运行的高昂成本呢？</p><p id="19f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实是你不能。无服务器只不过是一个服务器。它会在5分钟不活动后自动关闭。当需要再次调用它时，它会自动重启服务器。您只需在一个文件中指定依赖项，无服务器功能将从那些已安装的依赖项中创建一个容器映像，然后在重新启动时部署该映像和那些依赖项。</p><p id="fdb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么无服务器是一个误称。顾名思义，当在后台使用服务器时，不使用任何服务器。</p><p id="c470" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是无服务器功能仍然比实际的服务器便宜吗？这取决于你的商业案例。如果您的逻辑是轻量级的，可以放在一个函数中，那么无服务器更便宜。如果你的逻辑很重，依赖于巨大的软件包/定制操作系统/大存储，那么一个服务器就比较便宜。</p><blockquote class="me mf mg"><p id="138f" class="kz la mh lb b lc ld ju le lf lg jx lh mi lj lk ll mj ln lo lp mk lr ls lt lu im bi translated">等等，为什么我们的功能必须是轻量级的？</p></blockquote><p id="50be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个想法是，如果你的函数很小，当你需要在几分钟不活动后访问这个函数时，自动重新安装所有的包和依赖项会更容易。不活动后重新安装软件包和设置该功能的容器所需的时间称为<strong class="lb iu">冷启动。</strong></p><p id="f113" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">容器将运行并在5分钟后关闭。如果在这5分钟内调用该函数，它将比在容器不活动期间调用该函数更快地返回结果。容器运行后获得函数结果所需的时间称为<strong class="lb iu">热启动</strong>。</p><p id="0f75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目标是尽量减少冷启动和热启动。从用户体验来说，调用一个函数，1分钟后等待一个结果，会很烦。</p><blockquote class="me mf mg"><p id="efc4" class="kz la mh lb b lc ld ju le lf lg jx lh mi lj lk ll mj ln lo lp mk lr ls lt lu im bi translated">好吧，但是如果在大小和逻辑上受到限制，那么无服务器有什么好处呢？</p></blockquote><p id="c4d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你肯定不想使用无服务器功能…</p><ul class=""><li id="ecd5" class="ml mm it lb b lc ld lf lg li mn lm mo lq mp lu mq mr ms mt bi translated">托管网站</li><li id="d4ce" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mq mr ms mt bi translated">高性能计算</li><li id="c428" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mq mr ms mt bi translated">托管大型机器学习模型(神经网络、基于树的模型)</li><li id="4def" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mq mr ms mt bi translated">灾难恢复</li></ul><p id="93cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些都可以在EC2上托管。机器学习模型可以托管在AWS SageMaker上。</p><p id="80d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以将无服务器功能用于…</p><ul class=""><li id="caa5" class="ml mm it lb b lc ld lf lg li mn lm mo lq mp lu mq mr ms mt bi translated">自动化任务</li><li id="b946" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mq mr ms mt bi translated">触发器(处理上传到AWS S3的对象，发送到AWS SQS的事件)</li><li id="3fa4" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mq mr ms mt bi translated">实时过滤和转换数据</li></ul><p id="1adc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，无服务器函数非常适合于获取数据、转换数据并将结果发送到另一个端点进行处理。它甚至可以用于将转换后的数据发送到AWS SageMaker上托管的机器学习模型，并从该模型中获得预测。</p><p id="7d83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我之前的一个教程中，我设计了一个lambda函数，将上传到S3桶的PDF文件发送到一个托管AWS服务的端点:Textract。</p><p id="3dfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是该功能的要点</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="38b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是详细介绍教程的文章。你有空的时候可以去看看。</p><div class="nb nc gp gr nd ne"><a href="https://medium.com/codex/improving-ocr-recognition-through-human-review-via-amazon-augmented-ai-a9c5f6d51c04" rel="noopener follow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">通过亚马逊增强人工智能的人工审查来改善OCR识别</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">创建一个管道，在13分钟内通过OCR和人工审查从PDF文档中提取数据</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">medium.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns ks ne"/></div></div></a></div><blockquote class="me mf mg"><p id="ebe9" class="kz la mh lb b lc ld ju le lf lg jx lh mi lj lk ll mj ln lo lp mk lr ls lt lu im bi translated">等一下。你提到无服务器应该是轻量级的。但是在你的<em class="it"> send_from_s3_to_textract </em>函数中，你使用的是python包<em class="it"> boto3。</em>那不是超过50 MB，会大幅度影响冷启动吗？</p></blockquote><p id="3be5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正确。为此函数初始化容器所需的时间会很慢。在处理多个请求时，有一个简单的技巧可以优化函数。</p><blockquote class="me mf mg"><p id="7987" class="kz la mh lb b lc ld ju le lf lg jx lh mi lj lk ll mj ln lo lp mk lr ls lt lu im bi translated">真的吗？这是什么？</p></blockquote><p id="a829" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在函数中初始化了两个不同的boto3客户端<strong class="lb iu">:一个textract客户端和一个s3客户端。让我们把它从</strong>函数中移出<strong class="lb iu">。参见下面的要点。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><blockquote class="me mf mg"><p id="4218" class="kz la mh lb b lc ld ju le lf lg jx lh mi lj lk ll mj ln lo lp mk lr ls lt lu im bi translated">等等，你刚刚把第15-17行的<em class="it"> textract </em>和<em class="it"> s3 boto3 </em>客户端移到了第10 -12行的函数之外？这如何优化功能？</p></blockquote><p id="bff6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">初始化boto3客户端已经是一项耗时的任务。如果它在函数处理程序内部(在本例中，在<em class="mh">send _ from _ S3 _ to _ text ract</em>函数内部)，那么客户端将在每次调用时被初始化。从冷启动的角度来看，这并不重要，因为函数和客户端都已初始化和安装。从热启动的角度来看，在容器运行时，每次调用函数都要初始化两个巨大的客户端，这是非常耗时的。</p><p id="667d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想改进，我们希望在函数处理程序之外初始化客户端。这样，该函数将在多次调用中重用客户端。虽然这不会影响冷启动，但它会大大减少热启动，因为它会获取在冷启动/环境初始化阶段已经实例化的两个客户端。</p><p id="a818" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个过程称为<strong class="lb iu">静态初始化。</strong>静态初始化是在函数处理程序中代码开始运行之前，在处理程序之外运行逻辑的过程。开发人员使用静态初始化来导入库和依赖项，初始化与其他服务的连接，并在多个lambda函数处理程序中重用变量。</p><blockquote class="me mf mg"><p id="9398" class="kz la mh lb b lc ld ju le lf lg jx lh mi lj lk ll mj ln lo lp mk lr ls lt lu im bi translated">好吧，但我如何优化冷启动？</p></blockquote><p id="6758" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是另一个超出本文范围的话题。最简单的解释是确保提前创建lambda函数容器，远在按需调用它们之前。AWS Lambda允许<strong class="lb iu">提供并发</strong>，它在可预测的时间初始化Lambda函数。</p><p id="6ef3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对于适应突发流量和重大扩展事件非常有用。启用预配并发后，用户可以避免在lambda调用时遭遇冷启动。</p><p id="1b3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您知道了如何编写和优化无服务器函数。如果有人大胆地宣称无服务器将永远取代服务器，我们是否应该一笑置之。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><p id="4fea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！如果你想阅读更多我的作品，查看我的<a class="ae ky" href="https://hd2zm.medium.com/table-of-contents-read-this-first-a124146f566c" rel="noopener">目录</a>。</p><p id="0519" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不是一个中等收入的会员，但对订阅《走向数据科学》感兴趣，只是为了阅读像这样的教程和文章，<a class="ae ky" href="https://hd2zm.medium.com/membership" rel="noopener">点击这里</a>注册成为会员。注册这个链接意味着我可以通过向你推荐Medium来获得报酬。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><p id="e0e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">参考文献:</strong></p><div class="nb nc gp gr nd ne"><a href="https://lumigo.io/blog/provisioned-concurrency-the-end-of-cold-starts/" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">AWS Lambda提供的并发性:冷启动的终结</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">了解如何使用AWS Lambda调配的并发性来防止无服务器冷启动-了解调配的…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">lumigo.io</p></div></div><div class="nn l"><div class="oa l np nq nr nn ns ks ne"/></div></div></a></div><div class="nb nc gp gr nd ne"><a href="https://aws.amazon.com/blogs/compute/operating-lambda-performance-optimization-part-1/" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">运行Lambda:性能优化-第1部分| Amazon Web Services</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">在操作Lambda系列中，我为开发人员、架构师和系统管理员介绍了一些重要的主题，他们是…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">aws.amazon.com</p></div></div><div class="nn l"><div class="ob l np nq nr nn ns ks ne"/></div></div></a></div><div class="nb nc gp gr nd ne"><a href="https://aws.amazon.com/blogs/compute/operating-lambda-performance-optimization-part-2/" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">运行Lambda:性能优化-第2部分| Amazon Web Services</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">这篇文章是关于Lambda性能优化的3部分系列文章的第二部分。它解释了记忆的作用…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">aws.amazon.com</p></div></div><div class="nn l"><div class="oc l np nq nr nn ns ks ne"/></div></div></a></div></div></div>    
</body>
</html>