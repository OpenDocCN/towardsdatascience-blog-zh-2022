<html>
<head>
<title>Build a Blog Website using Django Rest Framework — Posts App (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Django Rest 框架——Posts 应用程序构建一个博客网站(第 3 部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-a-blog-website-using-django-rest-framework-posts-app-part-3-7334f75983fc#2022-12-15">https://towardsdatascience.com/build-a-blog-website-using-django-rest-framework-posts-app-part-3-7334f75983fc#2022-12-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9164" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在第三部分中，我们处理应用程序的整个 posts 应用程序，从而完成了应用程序的后端</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/164ad83e3da68c2f18af44d6eccbc43e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2CclUvoVVf3rwd0J"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@sincerelymedia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">真诚媒体</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="62e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大家好，我希望你们都过得很好，并且喜欢这个 DRF 文章系列的前两部分。在本系列的第一部分中，我们处理了设置这个项目的基础知识，你们都已经对我们将要构建的项目有了一个大致的了解，而在第二部分中，我们处理了我们的应用程序的<code class="fe lv lw lx ly b">users</code>应用程序，在那里我们为我们的<code class="fe lv lw lx ly b">users</code>部分编写了序列化程序和视图</p><p id="4d66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您还没有阅读这些部分，我强烈建议您先阅读前两部分，然后再回到本文。</p><div class="lz ma gp gr mb mc"><a rel="noopener follow" target="_blank" href="/build-a-blog-website-using-django-rest-framework-overview-part-1-1f847d53753f"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd iu gy z fp mh fr fs mi fu fw is bi translated">使用 Django Rest 框架构建博客网站——概述(第 1 部分)</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">让我们使用 Django Rest 框架构建一个简单的博客网站，了解 DRF 和 REST APIs 如何工作，以及我们如何添加…</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">towardsdatascience.com</p></div></div><div class="ml l"><div class="mm l mn mo mp ml mq ks mc"/></div></div></a></div><div class="lz ma gp gr mb mc"><a rel="noopener follow" target="_blank" href="/build-a-blog-website-using-django-rest-framework-part-2-be9bc353abf3"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd iu gy z fp mh fr fs mi fu fw is bi translated">使用 Django Rest 框架——用户应用程序构建一个博客网站(第 2 部分)</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">在第二部分中，我们将处理构建用户相关的模型和视图，并将测试用户相关的 API。</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">towardsdatascience.com</p></div></div><div class="ml l"><div class="mr l mn mo mp ml mq ks mc"/></div></div></a></div><p id="2e01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本系列的第三部分，我们将处理 Django 应用程序的完整的<code class="fe lv lw lx ly b">posts</code>应用程序，从而完成我们应用程序的完整后端。我们还将使用可浏览 API 接口测试 API，就像我们测试<code class="fe lv lw lx ly b">users</code>应用程序一样。所以，让我们直接进入<code class="fe lv lw lx ly b">posts</code>应用程序，并开始构建它。</p><p id="513e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，当我们移动到<code class="fe lv lw lx ly b">posts</code>文件夹时，我们会看到我们拥有的文件与我们移动到该文件夹时为<code class="fe lv lw lx ly b">users</code>应用程序所拥有的文件相同。首先，我们将进入<code class="fe lv lw lx ly b">models.py</code>文件来构建我们的模型。</p><h2 id="eb47" class="ms mt it bd mu mv mw dn mx my mz dp na li nb nc nd lm ne nf ng lq nh ni nj nk bi translated">models.py</h2><p id="c95b" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">先从<code class="fe lv lw lx ly b">models.py</code>文件开始吧。我们将在这里定义我们的数据库模型。因此，对于<code class="fe lv lw lx ly b">posts</code>部分，我们将有三种不同的模型— <code class="fe lv lw lx ly b">Post</code>、<code class="fe lv lw lx ly b">Upvote</code>和<code class="fe lv lw lx ly b">Comment</code>。</p><p id="5864" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先将所需的依赖项导入到我们的文件中，如下所示:</p><pre class="kj kk kl km gt nq ly nr bn ns nt bi"><span id="8734" class="nu mt it ly b be nv nw l nx ny">from django.db import models<br/>from django.contrib.auth.models import User<br/>from django.urls import reverse</span></pre><p id="46d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，我们已经导入了默认的<code class="fe lv lw lx ly b">User</code>模型，还从 Django 导入了<code class="fe lv lw lx ly b">models</code>和<code class="fe lv lw lx ly b">reverse</code>。这些将有助于我们建立模型。</p><p id="5cac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们将从<code class="fe lv lw lx ly b">Posts</code>型号开始。让我们先看看代码，然后我们会明白这些行的意义。</p><pre class="kj kk kl km gt nq ly nr bn ns nt bi"><span id="4e98" class="nu mt it ly b be nv nw l nx ny">class Post(models.Model):<br/>    user = models.ForeignKey(User, on_delete = models.CASCADE)<br/>    title = models.CharField(max_length = 100)<br/>    body = models.TextField()<br/>    created = models.DateTimeField(auto_now_add = True)<br/>    updated = models.DateTimeField(auto_now = True)<br/>    upvote_count = models.IntegerField(default = 0)<br/><br/>    def __str__(self):<br/>        return self.title<br/>    <br/>    def get_absolute_url(self):<br/>        return reverse('post-detail', kwargs = {'pk': self.pk})</span></pre><p id="7655" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码定义了一个从 Django 的<code class="fe lv lw lx ly b">models.Model</code>类继承而来的<code class="fe lv lw lx ly b">Post</code>类。这使得<code class="fe lv lw lx ly b">Post</code>类成为一个 Django 模型，允许它保存在数据库中并从数据库中检索。</p><p id="ec95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Post</code>类有几个字段，包括<code class="fe lv lw lx ly b">user</code>、<code class="fe lv lw lx ly b">title</code>、<code class="fe lv lw lx ly b">body</code>、<code class="fe lv lw lx ly b">created</code>、<code class="fe lv lw lx ly b">updated</code>和<code class="fe lv lw lx ly b">upvote_count</code>。每个字段都使用 Django 的<code class="fe lv lw lx ly b">models</code>模块中的一个类来定义，该类指定了每个字段将存储的数据类型。例如，<code class="fe lv lw lx ly b">title</code>字段是一个<code class="fe lv lw lx ly b">CharField</code>，它将存储博客文章的标题，<code class="fe lv lw lx ly b">created</code>字段是一个<code class="fe lv lw lx ly b">DateTimeField</code>，它存储文章创建的时间。</p><p id="cd17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">user</code>字段被定义为<code class="fe lv lw lx ly b">ForeignKey</code>字段，这意味着它是对默认 Django <code class="fe lv lw lx ly b">User</code>模型的引用。<code class="fe lv lw lx ly b">on_delete</code>参数指定如果删除了引用的<code class="fe lv lw lx ly b">User</code>对象，那么<code class="fe lv lw lx ly b">Post</code>对象会发生什么。这里，<code class="fe lv lw lx ly b">on_delete</code>参数被设置为<code class="fe lv lw lx ly b">models.CASCADE</code>，这意味着如果删除了<code class="fe lv lw lx ly b">User</code>对象，那么<code class="fe lv lw lx ly b">Post</code>对象也将被删除。</p><p id="9a99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">ForeignKey</code>字段允许将<code class="fe lv lw lx ly b">Post</code>链接到特定的<code class="fe lv lw lx ly b">User</code>对象，可以使用<code class="fe lv lw lx ly b">post.user</code>属性访问该对象。这可用于获取创建<code class="fe lv lw lx ly b">Post</code>的用户的用户名，或仅允许创建<code class="fe lv lw lx ly b">Post</code>的用户编辑或删除它。</p><p id="103e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">upvote_count</code>字段将存储博客文章从用户那里获得的支持票数。默认值已经被设置为零，这意味着当一个新的<code class="fe lv lw lx ly b">Post</code>对象被创建时，<code class="fe lv lw lx ly b">upvote_count</code>被设置为零。当用户点击博文上的 upvote 按钮时，<code class="fe lv lw lx ly b">upvote_count</code>将会增加。</p><p id="8ff1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">__str__</code>方法是一个特殊的方法，它定义了一个<code class="fe lv lw lx ly b">Post</code>对象应该如何被表示为一个字符串。在这种情况下，该方法返回<code class="fe lv lw lx ly b">Post</code>的<code class="fe lv lw lx ly b">title</code>。</p><p id="0c96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">get_absolute_url</code>方法返回<code class="fe lv lw lx ly b">Post</code>对象的详细页面的 URL。Django 用这个来确定对象保存到数据库时的 URL。</p><p id="9761" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将研究将在我们的应用程序中存储所有 upvotes 的<code class="fe lv lw lx ly b">Upvote</code>模型。让我们看看这个模型，然后我会解释这个代码的意义。</p><pre class="kj kk kl km gt nq ly nr bn ns nt bi"><span id="b006" class="nu mt it ly b be nv nw l nx ny">class Upvote(models.Model):<br/>    user = models.ForeignKey(User, related_name = 'upvotes', on_delete = models.CASCADE)<br/>    post = models.ForeignKey(Post, related_name = 'upvotes', on_delete = models.CASCADE)</span></pre><p id="3a94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码定义了一个继承自 Django 的<code class="fe lv lw lx ly b">models.Model</code>类的<code class="fe lv lw lx ly b">Upvote</code>类，就像我们之前讨论的<code class="fe lv lw lx ly b">Post</code>类一样。</p><p id="b7b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Upvote</code>类有两个字段:<code class="fe lv lw lx ly b">user</code>和<code class="fe lv lw lx ly b">post</code>。两个字段都被定义为<code class="fe lv lw lx ly b">ForeignKey</code>字段，这表明它们分别是对<code class="fe lv lw lx ly b">User</code>和<code class="fe lv lw lx ly b">Post</code>对象的引用。<code class="fe lv lw lx ly b">related_name</code>参数指定了用于访问反向关系的名称。例如，如果一个<code class="fe lv lw lx ly b">User</code>对象<code class="fe lv lw lx ly b">user</code>投了几个<code class="fe lv lw lx ly b">Post</code>对象的赞成票，那么<code class="fe lv lw lx ly b">user.upvotes</code>属性将返回一个<code class="fe lv lw lx ly b">user</code>投了赞成票的<code class="fe lv lw lx ly b">Post</code>对象的 queryset。</p><p id="53d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个字段的<code class="fe lv lw lx ly b">on_delete</code>参数被设置为<code class="fe lv lw lx ly b">models.CASCADE</code>，这意味着如果删除了<code class="fe lv lw lx ly b">Upvote</code>对象引用的<code class="fe lv lw lx ly b">User</code>或<code class="fe lv lw lx ly b">Post</code>对象，则<code class="fe lv lw lx ly b">Upvote</code>对象也将被删除。</p><p id="f81a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个类用于跟踪哪些用户对哪些帖子投了赞成票。我们将使用它来防止一个用户不止一次地向上投票一个<code class="fe lv lw lx ly b">Post</code>，或者我们也可以使用它来检索已经向上投票给一个给定的<code class="fe lv lw lx ly b">Post</code>的用户列表，尽管我们不会在我们的应用程序中实现后者。但是，正如我们所看到的，这很容易做到，您肯定可以尝试实现它来改进应用程序。</p><p id="dde5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们移动到最后一个模型类<code class="fe lv lw lx ly b">Comment</code>，它将在我们的应用程序中存储博客帖子上的所有评论。相同的代码如下。</p><pre class="kj kk kl km gt nq ly nr bn ns nt bi"><span id="8e26" class="nu mt it ly b be nv nw l nx ny">class Comment(models.Model):<br/>    user = models.ForeignKey(User, related_name = 'comments', on_delete = models.CASCADE)<br/>    post = models.ForeignKey(Post, related_name = 'comments', on_delete = models.CASCADE)<br/>    body = models.TextField()<br/>    created = models.DateTimeField(auto_now_add = True)<br/><br/>    def __str__(self):<br/>        return self.body</span></pre><p id="f65f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码定义了一个继承自 Django 的<code class="fe lv lw lx ly b">models.Model</code>类的<code class="fe lv lw lx ly b">Comment</code>类，就像<code class="fe lv lw lx ly b">Post</code>和<code class="fe lv lw lx ly b">Upvote</code>类一样。</p><p id="5833" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Comment</code>类有四个字段:<code class="fe lv lw lx ly b">user</code>、<code class="fe lv lw lx ly b">post</code>、<code class="fe lv lw lx ly b">body</code>和<code class="fe lv lw lx ly b">created</code>。<code class="fe lv lw lx ly b">user</code>和<code class="fe lv lw lx ly b">post</code>字段被定义为<code class="fe lv lw lx ly b">ForeignKey</code>字段，这意味着它们分别是对<code class="fe lv lw lx ly b">User</code>和<code class="fe lv lw lx ly b">Post</code>对象的引用。两个字段的<code class="fe lv lw lx ly b">related_name</code>参数指定了用于访问反向关系的名称。例如，如果一个<code class="fe lv lw lx ly b">User</code>对象<code class="fe lv lw lx ly b">user</code>写了几个<code class="fe lv lw lx ly b">Comment</code>对象，<code class="fe lv lw lx ly b">user.comments</code>属性将返回一个<code class="fe lv lw lx ly b">user</code>写的<code class="fe lv lw lx ly b">Comment</code>对象的 queryset。</p><p id="a594" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">body</code>字段是一个<code class="fe lv lw lx ly b">TextField</code>，它存储了评论的主要内容。</p><p id="ebf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">created</code>字段是一个<code class="fe lv lw lx ly b">DateTimeField</code>字段，存储<code class="fe lv lw lx ly b">Comment</code>对象创建的日期和时间。<code class="fe lv lw lx ly b">auto_now_add</code>参数设置为<code class="fe lv lw lx ly b">True</code>，这意味着<code class="fe lv lw lx ly b">Comment</code>对象的<code class="fe lv lw lx ly b">created</code>字段将自动设置为对象首次创建时的当前日期和时间。</p><p id="4482" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">__str__</code>方法是一个特殊的方法，它定义了一个<code class="fe lv lw lx ly b">Comment</code>对象应该如何被表示为一个字符串。在这种情况下，该方法返回<code class="fe lv lw lx ly b">Comment</code>的<code class="fe lv lw lx ly b">body</code>，这是注释的主要内容。</p><p id="d6dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Comment</code>类用于确定哪些用户评论了一个特定的<code class="fe lv lw lx ly b">Post</code>对象。我们将使用它来显示博客帖子上的评论以及用户的姓名。此外，这可以用于仅允许创建评论的用户编辑或删除评论，尽管我们还没有在当前应用程序中实现这一部分。</p><p id="91bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">models.py</code>部分的完整代码如下:</p><pre class="kj kk kl km gt nq ly nr bn ns nt bi"><span id="8c33" class="nu mt it ly b be nv nw l nx ny">from django.db import models<br/>from django.contrib.auth.models import User<br/>from django.urls import reverse<br/><br/>class Post(models.Model):<br/>    user = models.ForeignKey(User, on_delete = models.CASCADE)<br/>    title = models.CharField(max_length = 100)<br/>    body = models.TextField()<br/>    created = models.DateTimeField(auto_now_add = True)<br/>    updated = models.DateTimeField(auto_now = True)<br/>    upvote_count = models.IntegerField(default = 0)<br/><br/>    def __str__(self):<br/>        return self.title<br/>    <br/>    def get_absolute_url(self):<br/>        return reverse('post-detail', kwargs = {'pk': self.pk})<br/><br/>class Upvote(models.Model):<br/>    user = models.ForeignKey(User, related_name = 'upvotes', on_delete = models.CASCADE)<br/>    post = models.ForeignKey(Post, related_name = 'upvotes', on_delete = models.CASCADE)<br/><br/>class Comment(models.Model):<br/>    user = models.ForeignKey(User, related_name = 'comments', on_delete = models.CASCADE)<br/>    post = models.ForeignKey(Post, related_name = 'comments', on_delete = models.CASCADE)<br/>    body = models.TextField()<br/>    created = models.DateTimeField(auto_now_add = True)<br/><br/>    def __str__(self):<br/>        return self.body</span></pre><p id="6f2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将移动到<code class="fe lv lw lx ly b">serializers.py</code>文件。因为这个文件在默认情况下是不存在的，所以我们需要像创建<code class="fe lv lw lx ly b">users</code>应用程序一样创建它。</p><h2 id="3f34" class="ms mt it bd mu mv mw dn mx my mz dp na li nb nc nd lm ne nf ng lq nh ni nj nk bi translated">serializers.py</h2><p id="ce5d" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">在这个文件中，我们将序列化我们的模型，使它们的格式可以在 web 上共享，并且可以被任何前端框架访问。</p><p id="8a59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将把所需的依赖项导入到我们的文件中。我们将从<code class="fe lv lw lx ly b">rest_framework</code>包中导入<code class="fe lv lw lx ly b">serializers</code>，并且导入我们创建的三个模型——<code class="fe lv lw lx ly b">Post</code>、<code class="fe lv lw lx ly b">Upvote</code>和<code class="fe lv lw lx ly b">Comment</code>。</p><p id="46fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将编写三个序列化器——三个模型各一个。下面给出了序列化程序类的代码。让我们先看看代码，然后我们可以稍后讨论它。</p><pre class="kj kk kl km gt nq ly nr bn ns nt bi"><span id="77f3" class="nu mt it ly b be nv nw l nx ny">from rest_framework import serializers<br/>from .models import Post, Upvote, Comment<br/><br/>class PostSerializer(serializers.ModelSerializer):<br/>    user = serializers.ReadOnlyField(source = 'user.username')<br/>    class Meta:<br/>        model = Post<br/>        fields = ('id', 'title', 'body', 'created', 'updated', 'user', 'upvote_count')<br/><br/>class UpvoteSerializer(serializers.ModelSerializer):<br/>    class Meta:<br/>        model = Upvote<br/>        fields = ('id', 'user', 'post')<br/><br/>class CommentSerializer(serializers.ModelSerializer):<br/>    user = serializers.ReadOnlyField(source = 'user.username')<br/>    class Meta:<br/>        model = Comment<br/>        fields = ('id', 'user', 'post', 'body', 'created')</span></pre><p id="a4b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该结构非常类似于我们在前一篇文章中为<code class="fe lv lw lx ly b">Users</code>模型编写的序列化程序。</p><p id="b862" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面写的三个类中的每一个都为特定的模型定义了一个序列化器:<code class="fe lv lw lx ly b">Post</code>、<code class="fe lv lw lx ly b">Upvote</code>和<code class="fe lv lw lx ly b">Comment</code>。每个序列化程序类的<code class="fe lv lw lx ly b">Meta</code>内部类指定了序列化程序应该使用的模型，以及模型的哪些字段应该包含在序列化数据中。</p><p id="300f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，<code class="fe lv lw lx ly b">PostSerializer</code>将序列化<code class="fe lv lw lx ly b">Post</code>模型的实例，并将在序列化的数据中包含<code class="fe lv lw lx ly b">id</code>、<code class="fe lv lw lx ly b">title</code>、<code class="fe lv lw lx ly b">body</code>、<code class="fe lv lw lx ly b">created</code>、<code class="fe lv lw lx ly b">updated</code>、<code class="fe lv lw lx ly b">user</code>和<code class="fe lv lw lx ly b">upvote_count</code>字段。</p><p id="1ac0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，<code class="fe lv lw lx ly b">UpvoteSerializer</code>和<code class="fe lv lw lx ly b">CommentSerializer</code>会序列化自己的字段。</p><p id="e25b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们转移到最重要的部分——视图，在这里我们将定义应用程序的所有逻辑，我们将处理文件中的<code class="fe lv lw lx ly b">get</code>、<code class="fe lv lw lx ly b">post</code>、<code class="fe lv lw lx ly b">put</code>和<code class="fe lv lw lx ly b">delete</code>请求。</p><h2 id="1d98" class="ms mt it bd mu mv mw dn mx my mz dp na li nb nc nd lm ne nf ng lq nh ni nj nk bi translated">views.py</h2><p id="a881" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">在本节中，我们将定义各种<code class="fe lv lw lx ly b">views</code>来处理与我们已经创建的三个模型相关的不同请求。</p><p id="0981" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在应用程序中添加以下功能:</p><ol class=""><li id="e7d9" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">看到所有的博客帖子</li><li id="3994" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">创建新的博客文章</li><li id="6e8a" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">编辑该特定用户撰写的博客文章</li><li id="2ab7" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">删除该特定用户撰写的博客文章</li><li id="68f2" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">查看特定用户撰写的博客文章</li><li id="032b" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">投票支持该职位</li><li id="8a7e" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">在帖子上添加评论</li></ol><p id="f2eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，让我们从所需的导入开始。</p><pre class="kj kk kl km gt nq ly nr bn ns nt bi"><span id="26d3" class="nu mt it ly b be nv nw l nx ny">from rest_framework.views import APIView<br/>from rest_framework.response import Response<br/>from rest_framework import status<br/>from rest_framework import permissions<br/>from .models import Post, Upvote, Comment<br/>from .serializers import PostSerializer, UpvoteSerializer, CommentSerializer<br/>from django.contrib.auth.models import User</span></pre><p id="62d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在<code class="fe lv lw lx ly b">views.py</code>文件中，我们导入了各种类和函数——有些来自<code class="fe lv lw lx ly b">rest_framework</code>包，有些是<code class="fe lv lw lx ly b">serilializers</code>和<code class="fe lv lw lx ly b">models</code>。</p><p id="9ae5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">APIView</code>是一个类，它提供了一种定义视图的方法，这些视图以 RESTful 方式处理传入的 HTTP 请求。视图是一个可调用的对象，它接受一个 HTTP 请求作为它的参数，并返回一个 HTTP 响应。</p><p id="2159" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Response</code>是一个提供创建 HTTP 响应对象的方法的类。HTTP 响应通常包括状态代码、标头和包含响应数据的正文。</p><p id="fd15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">status</code>是一个将多个 HTTP 状态码定义为常量的模块。这些代码表示 HTTP 请求的成功或失败。</p><p id="774f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">permissions</code>是一个模块，提供了在视图中实现权限检查的类。权限是确定用户是否有权访问特定视图的规则。</p><p id="3cae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码还从<code class="fe lv lw lx ly b">.models</code>模块导入了几个模型类，以及从<code class="fe lv lw lx ly b">.serializers</code>模块导入了序列化器类。最后，它从<code class="fe lv lw lx ly b">django.contrib.auth.models</code>模块导入<code class="fe lv lw lx ly b">User</code>类，该类代表 Django web 框架的用户，即默认的 Django <code class="fe lv lw lx ly b">User</code>模型类。</p><p id="ec71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，<code class="fe lv lw lx ly b">views.py</code>文件中的所有类，我们将要求用户登录，所以我们将使用<code class="fe lv lw lx ly b">permissions</code>模块在所有类中强制这样做。</p><p id="0f03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将定义<code class="fe lv lw lx ly b">PostListAPIView</code>类，它将提供获取所有可用博客文章的能力，并且还将具有创建新博客文章的能力。下面是相同的代码:</p><pre class="kj kk kl km gt nq ly nr bn ns nt bi"><span id="3c72" class="nu mt it ly b be nv nw l nx ny">class PostListAPIView(APIView):<br/>    permission_classes = [permissions.IsAuthenticated]<br/><br/>    def get(self, request, *args, **kwargs):<br/>        posts = Post.objects.all()<br/>        serializer = PostSerializer(posts, many = True)<br/>        return Response(serializer.data, status = status.HTTP_200_OK)<br/><br/>    def post(self, request, *args, **kwargs):<br/>        data = {<br/>            'user': request.user.id,<br/>            'title': request.data.get('title'),<br/>            'body': request.data.get('body')<br/>        }<br/>        serializer = PostSerializer(data = data)<br/>        if serializer.is_valid():<br/>            serializer.save()<br/>            return Response(serializer.data, status = status.HTTP_201_CREATED)<br/>        return Response(serializer.errors, status = status.HTTP_400_BAD_REQUEST)</span></pre><p id="401e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是<code class="fe lv lw lx ly b">APIView</code>的一个子类，提供了几种处理不同 HTTP 请求方法的方法，比如<code class="fe lv lw lx ly b">GET</code>、<code class="fe lv lw lx ly b">POST</code>、<code class="fe lv lw lx ly b">PUT</code>、<code class="fe lv lw lx ly b">DELETE</code>。</p><p id="cb89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">PostListAPIView</code>类的<code class="fe lv lw lx ly b">permission_classes</code>属性指定只允许经过身份验证的用户访问这个视图。这是通过使用<code class="fe lv lw lx ly b">isAuthenticated</code>方法实现的。这意味着只有已经登录的用户才能看到帖子列表或创建新帖子。我们也将在所有其他课程中使用相同的内容。</p><p id="0a8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个<code class="fe lv lw lx ly b">GET</code>请求被发送到视图时，调用<code class="fe lv lw lx ly b">PostListAPIView</code>类的<code class="fe lv lw lx ly b">get</code>方法。该方法检索网站上的所有博客文章，并使用<code class="fe lv lw lx ly b">PostSerializer</code>类创建数据的序列化表示。然后，它在 HTTP 响应中返回该数据，状态代码为 200 OK。</p><p id="f4fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个<code class="fe lv lw lx ly b">POST</code>请求被发送到视图时，调用<code class="fe lv lw lx ly b">PostListAPIView</code>类的<code class="fe lv lw lx ly b">post</code>方法。这个方法使用来自请求的数据创建一个新的<code class="fe lv lw lx ly b">Post</code>对象，使用<code class="fe lv lw lx ly b">PostSerializer</code>类序列化数据，并在 HTTP 响应中返回序列化的数据，创建状态代码 201。如果来自请求的数据无效，它将返回一条错误消息，状态代码为 400 BAD REQUEST。</p><p id="d246" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们定义了<code class="fe lv lw lx ly b">PostDetailAPIView</code>,它将处理博客中的单个帖子的操作。它将处理获取特定的文章，编辑或删除它。它还拥有我们在上一课中拥有的相同权限。下面是它的代码:</p><pre class="kj kk kl km gt nq ly nr bn ns nt bi"><span id="572d" class="nu mt it ly b be nv nw l nx ny">class PostDetailAPIView(APIView):<br/>    permission_classes = [permissions.IsAuthenticated]<br/><br/>    def get_object(self, pk):<br/>        try:<br/>            return Post.objects.get(pk = pk)<br/>        except Post.DoesNotExist:<br/>            return None<br/><br/>    def get(self, request, pk, *args, **kwargs):<br/>        post = self.get_object(pk)<br/>        if post is None:<br/>            return Response({'error': 'Post not found'}, status = status.HTTP_404_NOT_FOUND)<br/>        serializer = PostSerializer(post)<br/>        return Response(serializer.data, status = status.HTTP_200_OK)<br/><br/>    def put(self, request, pk, *args, **kwargs):<br/>        post = self.get_object(pk)<br/>        if post is None:<br/>            return Response({'error': 'Post not found'}, status = status.HTTP_404_NOT_FOUND)<br/>        data = {<br/>            'user': request.user.id,<br/>            'title': request.data.get('title'),<br/>            'body': request.data.get('body'),<br/>            'upvote_count': post.upvote_count<br/>        }<br/>        serializer = PostSerializer(post, data = data, partial = True)<br/>        if serializer.is_valid():<br/>            if post.user.id == request.user.id:<br/>                serializer.save()<br/>                return Response(serializer.data, status = status.HTTP_200_OK)<br/>            return Response({"error": "You are not authorized to edit this post"}, status = status.HTTP_401_UNAUTHORIZED)<br/>        return Response(serializer.errors, status = status.HTTP_400_BAD_REQUEST)<br/><br/>    def delete(self, request, pk, *args, **kwargs):<br/>        post = self.get_object(pk)<br/>        if post is None:<br/>            return Response({'error': 'Post not found'}, status = status.HTTP_404_NOT_FOUND)<br/>        if post.user.id == request.user.id:<br/>            post.delete()<br/>            return Response({"res": "Object deleted!"}, status = status.HTTP_200_OK)<br/>        return Response({"error": "You are not authorized to delete this post"}, status = status.HTTP_401_UNAUTHORIZED)</span></pre><p id="c50c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">get_object</code>方法是一个助手方法，用指定的主键(<code class="fe lv lw lx ly b">pk</code>)检索文章。如果帖子不存在，则返回<code class="fe lv lw lx ly b">None</code>。</p><p id="f826" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个<code class="fe lv lw lx ly b">GET</code>请求被发送到视图时，调用<code class="fe lv lw lx ly b">PostDetailAPIView</code>类的<code class="fe lv lw lx ly b">get</code>方法。它使用<code class="fe lv lw lx ly b">get_object</code>方法检索具有指定<code class="fe lv lw lx ly b">pk</code>的帖子，使用<code class="fe lv lw lx ly b">PostSerializer</code>类序列化帖子，并在 HTTP 响应中返回序列化的数据，状态代码为 200 OK。如果具有指定的<code class="fe lv lw lx ly b">pk</code>的 post 不存在，它返回一个错误消息，状态代码为 404 NOT FOUND。</p><p id="5356" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个<code class="fe lv lw lx ly b">PUT</code>请求被发送到视图时，调用<code class="fe lv lw lx ly b">PostDetailAPIView</code>类的<code class="fe lv lw lx ly b">put</code>方法。它使用<code class="fe lv lw lx ly b">get_object</code>方法用指定的<code class="fe lv lw lx ly b">pk</code>检索帖子，用来自请求的数据更新帖子，并保存更新后的帖子。如果当前用户不是帖子的所有者，它将返回一条错误消息，状态代码为 401 未授权。如果来自请求的数据无效，它将返回一条错误消息，状态代码为 400 BAD REQUEST。</p><p id="e651" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个<code class="fe lv lw lx ly b">DELETE</code>请求被发送到视图时，调用<code class="fe lv lw lx ly b">PostDetailAPIView</code>类的<code class="fe lv lw lx ly b">delete</code>方法。它使用<code class="fe lv lw lx ly b">get_object</code>方法检索带有指定<code class="fe lv lw lx ly b">pk</code>的帖子，然后如果当前用户是帖子的所有者，则删除它。如果当前用户不是帖子的所有者，它将返回一条错误消息，状态代码为 401 未授权。如果指定<code class="fe lv lw lx ly b">pk</code>的帖子不存在，则返回一条错误消息，状态代码为 404 未找到。</p><p id="ac14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将拥有处理查看来自特定用户的帖子的<code class="fe lv lw lx ly b">UserPostAPIView</code>类。</p><pre class="kj kk kl km gt nq ly nr bn ns nt bi"><span id="cc5d" class="nu mt it ly b be nv nw l nx ny">class UserPostAPIView(APIView):<br/>    permission_classes = [permissions.IsAuthenticated]<br/><br/>    def get(self, request, username, *args, **kwargs):<br/>        user = User.objects.filter(username = username).first()<br/>        if user is None:<br/>            return Response({'error': 'User not found'}, status = status.HTTP_404_NOT_FOUND)<br/>        posts = Post.objects.filter(user = user)<br/>        serializer = PostSerializer(posts, many = True)<br/>        return Response(serializer.data, status = status.HTTP_200_OK)</span></pre><p id="a14b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">UserPostAPIView</code>类的<code class="fe lv lw lx ly b">get</code>方法检索具有指定<code class="fe lv lw lx ly b">username</code>的用户，检索该用户创建的所有帖子，然后使用<code class="fe lv lw lx ly b">PostSerializer</code>类创建数据的序列化表示。然后，它在 HTTP 响应中返回该数据，状态代码为 200 OK。如果指定的用户<code class="fe lv lw lx ly b">username</code>不存在，则返回错误信息，状态代码为 404 未找到。</p><p id="8fa8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将拥有<code class="fe lv lw lx ly b">UpvoteAPIView</code>类，它将处理与 upvotes 部分相关的所有功能。</p><pre class="kj kk kl km gt nq ly nr bn ns nt bi"><span id="a571" class="nu mt it ly b be nv nw l nx ny">class UpvoteAPIView(APIView):<br/>    permission_classes = [permissions.IsAuthenticated]<br/><br/>    def get_object(self, pk):<br/>        try:<br/>            return Post.objects.get(pk = pk)<br/>        except Post.DoesNotExist:<br/>            return None<br/><br/>    def post(self, request, pk, *args, **kwargs):<br/>        post = self.get_object(pk)<br/>        if post is None:<br/>            return Response({'error': 'Post not found'}, status = status.HTTP_404_NOT_FOUND)<br/>        <br/>        upvoters = post.upvotes.all().values_list('user', flat = True)<br/>        if request.user.id in upvoters:<br/>            post.upvote_count -= 1<br/>            post.upvotes.filter(user = request.user).delete()<br/>        else:<br/>            post.upvote_count += 1<br/>            upvote = Upvote(user = request.user, post = post)<br/>            upvote.save()<br/>        post.save()<br/>        serializer = PostSerializer(post)<br/>        return Response(serializer.data, status = status.HTTP_200_OK)</span></pre><p id="2dc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">get_object</code>方法是一个助手方法，用指定的主键(<code class="fe lv lw lx ly b">pk</code>)检索文章。如果帖子不存在，则返回<code class="fe lv lw lx ly b">None</code>。和我们给<code class="fe lv lw lx ly b">PostDetailAPIView</code>类写的差不多。</p><p id="316e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">UpvoteAPIView</code>类的<code class="fe lv lw lx ly b">post</code>方法使用<code class="fe lv lw lx ly b">get_object</code>方法检索带有指定<code class="fe lv lw lx ly b">pk</code>的帖子，然后添加或删除当前用户对该帖子的投票。然后更新帖子的<code class="fe lv lw lx ly b">upvote_count</code>并保存更新后的帖子。最后，它使用<code class="fe lv lw lx ly b">PostSerializer</code>类创建帖子的序列化表示，并在 HTTP 响应中返回序列化数据，状态代码为 200 OK。如果具有指定的<code class="fe lv lw lx ly b">pk</code>的 post 不存在，它返回一个错误消息，状态代码为 404 NOT FOUND。</p><p id="99c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们有<code class="fe lv lw lx ly b">CommentAPIView</code>,它将处理特定帖子上的评论。它将具有获取特定帖子的所有评论并发布新评论的功能。</p><pre class="kj kk kl km gt nq ly nr bn ns nt bi"><span id="2881" class="nu mt it ly b be nv nw l nx ny">class CommentAPIView(APIView):<br/>    permission_classes = [permissions.IsAuthenticated]<br/><br/>    def get_object(self, pk):<br/>        try:<br/>            return Post.objects.get(pk = pk)<br/>        except Post.DoesNotExist:<br/>            return None<br/>    <br/>    def get(self, request, pk, *args, **kwargs):<br/>        post = self.get_object(pk)<br/>        if post is None:<br/>            return Response({'error': 'Post not found'}, status = status.HTTP_404_NOT_FOUND)<br/>        comments = Comment.objects.filter(post = post)<br/>        serializer = CommentSerializer(comments, many = True)<br/>        return Response(serializer.data, status = status.HTTP_200_OK)<br/><br/>    def post(self, request, pk, *args, **kwargs):<br/>        post = self.get_object(pk)<br/>        if post is None:<br/>            return Response({'error': 'Post not found'}, status = status.HTTP_404_NOT_FOUND)<br/>        data = {<br/>            'user': request.user.id,<br/>            'post': post.id,<br/>            'body': request.data.get('body')<br/>        }<br/>        serializer = CommentSerializer(data = data)<br/>        if serializer.is_valid():<br/>            serializer.save()<br/>            return Response(serializer.data, status = status.HTTP_201_CREATED)<br/>        return Response(serializer.errors, status = status.HTTP_400_BAD_REQUEST)</span></pre><p id="6a6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，它有同样的<code class="fe lv lw lx ly b">get_object</code> helper 函数，它接受主键<code class="fe lv lw lx ly b">pk</code>并返回与之对应的帖子。</p><p id="ea3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个<code class="fe lv lw lx ly b">GET</code>请求被发送到视图时，调用<code class="fe lv lw lx ly b">CommentAPIView</code>类的<code class="fe lv lw lx ly b">get</code>方法。它使用<code class="fe lv lw lx ly b">get_object</code>方法检索带有指定<code class="fe lv lw lx ly b">pk</code>的帖子，检索该帖子的所有评论，然后使用<code class="fe lv lw lx ly b">CommentSerializer</code>类创建数据的序列化表示。然后，它在 HTTP 响应中返回该数据，状态代码为 200 OK。如果带有指定<code class="fe lv lw lx ly b">pk</code>的 post 不存在，它返回一个错误消息，状态代码为 404 NOT FOUND。</p><p id="2eef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个<code class="fe lv lw lx ly b">POST</code>请求被发送到视图时，调用<code class="fe lv lw lx ly b">CommentAPIView</code>类的<code class="fe lv lw lx ly b">post</code>方法。它使用<code class="fe lv lw lx ly b">get_object</code>方法检索具有指定<code class="fe lv lw lx ly b">pk</code>的帖子，使用来自请求的数据创建一个新的<code class="fe lv lw lx ly b">Comment</code>对象，使用<code class="fe lv lw lx ly b">CommentSerializer</code>类序列化数据，并在 HTTP 响应中返回序列化数据，创建状态代码 201。如果来自请求的数据无效，它将返回一条错误消息，状态代码为 400 BAD REQUEST。如果具有指定的<code class="fe lv lw lx ly b">pk</code>的帖子不存在，它将返回一个错误消息，状态代码为 404 NOT FOUND。</p><p id="1b2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面可以找到<code class="fe lv lw lx ly b">views.py</code>文件的完整代码。</p><pre class="kj kk kl km gt nq ly nr bn ns nt bi"><span id="6ecc" class="nu mt it ly b be nv nw l nx ny">from rest_framework.views import APIView<br/>from rest_framework.response import Response<br/>from rest_framework import status<br/>from rest_framework import permissions<br/>from .models import Post, Upvote, Comment<br/>from .serializers import PostSerializer, UpvoteSerializer, CommentSerializer<br/>from django.contrib.auth.models import User<br/><br/><br/>class PostListAPIView(APIView):<br/>    permission_classes = [permissions.IsAuthenticated]<br/><br/>    def get(self, request, *args, **kwargs):<br/>        posts = Post.objects.all()<br/>        serializer = PostSerializer(posts, many = True)<br/>        return Response(serializer.data, status = status.HTTP_200_OK)<br/><br/>    def post(self, request, *args, **kwargs):<br/>        data = {<br/>            'user': request.user.id,<br/>            'title': request.data.get('title'),<br/>            'body': request.data.get('body')<br/>        }<br/>        serializer = PostSerializer(data = data)<br/>        if serializer.is_valid():<br/>            serializer.save()<br/>            return Response(serializer.data, status = status.HTTP_201_CREATED)<br/>        return Response(serializer.errors, status = status.HTTP_400_BAD_REQUEST)<br/><br/><br/>class PostDetailAPIView(APIView):<br/>    permission_classes = [permissions.IsAuthenticated]<br/><br/>    def get_object(self, pk):<br/>        try:<br/>            return Post.objects.get(pk = pk)<br/>        except Post.DoesNotExist:<br/>            return None<br/><br/>    def get(self, request, pk, *args, **kwargs):<br/>        post = self.get_object(pk)<br/>        if post is None:<br/>            return Response({'error': 'Post not found'}, status = status.HTTP_404_NOT_FOUND)<br/>        serializer = PostSerializer(post)<br/>        return Response(serializer.data, status = status.HTTP_200_OK)<br/><br/>    def put(self, request, pk, *args, **kwargs):<br/>        post = self.get_object(pk)<br/>        if post is None:<br/>            return Response({'error': 'Post not found'}, status = status.HTTP_404_NOT_FOUND)<br/>        data = {<br/>            'user': request.user.id,<br/>            'title': request.data.get('title'),<br/>            'body': request.data.get('body'),<br/>            'upvote_count': post.upvote_count<br/>        }<br/>        serializer = PostSerializer(post, data = data, partial = True)<br/>        if serializer.is_valid():<br/>            if post.user.id == request.user.id:<br/>                serializer.save()<br/>                return Response(serializer.data, status = status.HTTP_200_OK)<br/>            return Response({"error": "You are not authorized to edit this post"}, status = status.HTTP_401_UNAUTHORIZED)<br/>        return Response(serializer.errors, status = status.HTTP_400_BAD_REQUEST)<br/><br/>    def delete(self, request, pk, *args, **kwargs):<br/>        post = self.get_object(pk)<br/>        if post is None:<br/>            return Response({'error': 'Post not found'}, status = status.HTTP_404_NOT_FOUND)<br/>        if post.user.id == request.user.id:<br/>            post.delete()<br/>            return Response({"res": "Object deleted!"}, status = status.HTTP_200_OK)<br/>        return Response({"error": "You are not authorized to delete this post"}, status = status.HTTP_401_UNAUTHORIZED)<br/><br/><br/>class UserPostAPIView(APIView):<br/>    permission_classes = [permissions.IsAuthenticated]<br/><br/>    def get(self, request, username, *args, **kwargs):<br/>        user = User.objects.filter(username = username).first()<br/>        if user is None:<br/>            return Response({'error': 'User not found'}, status = status.HTTP_404_NOT_FOUND)<br/>        posts = Post.objects.filter(user = user)<br/>        serializer = PostSerializer(posts, many = True)<br/>        return Response(serializer.data, status = status.HTTP_200_OK)<br/><br/><br/>class UpvoteAPIView(APIView):<br/>    permission_classes = [permissions.IsAuthenticated]<br/><br/>    def get_object(self, pk):<br/>        try:<br/>            return Post.objects.get(pk = pk)<br/>        except Post.DoesNotExist:<br/>            return None<br/><br/>    def post(self, request, pk, *args, **kwargs):<br/>        post = self.get_object(pk)<br/>        if post is None:<br/>            return Response({'error': 'Post not found'}, status = status.HTTP_404_NOT_FOUND)<br/>        <br/>        upvoters = post.upvotes.all().values_list('user', flat = True)<br/>        if request.user.id in upvoters:<br/>            post.upvote_count -= 1<br/>            post.upvotes.filter(user = request.user).delete()<br/>        else:<br/>            post.upvote_count += 1<br/>            upvote = Upvote(user = request.user, post = post)<br/>            upvote.save()<br/>        post.save()<br/>        serializer = PostSerializer(post)<br/>        return Response(serializer.data, status = status.HTTP_200_OK)<br/><br/><br/>class CommentAPIView(APIView):<br/>    permission_classes = [permissions.IsAuthenticated]<br/><br/>    def get_object(self, pk):<br/>        try:<br/>            return Post.objects.get(pk = pk)<br/>        except Post.DoesNotExist:<br/>            return None<br/>    <br/>    def get(self, request, pk, *args, **kwargs):<br/>        post = self.get_object(pk)<br/>        if post is None:<br/>            return Response({'error': 'Post not found'}, status = status.HTTP_404_NOT_FOUND)<br/>        comments = Comment.objects.filter(post = post)<br/>        serializer = CommentSerializer(comments, many = True)<br/>        return Response(serializer.data, status = status.HTTP_200_OK)<br/><br/>    def post(self, request, pk, *args, **kwargs):<br/>        post = self.get_object(pk)<br/>        if post is None:<br/>            return Response({'error': 'Post not found'}, status = status.HTTP_404_NOT_FOUND)<br/>        data = {<br/>            'user': request.user.id,<br/>            'post': post.id,<br/>            'body': request.data.get('body')<br/>        }<br/>        serializer = CommentSerializer(data = data)<br/>        if serializer.is_valid():<br/>            serializer.save()<br/>            return Response(serializer.data, status = status.HTTP_201_CREATED)<br/>        return Response(serializer.errors, status = status.HTTP_400_BAD_REQUEST)</span></pre><p id="e215" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们移动到<code class="fe lv lw lx ly b">admin.py</code>文件来注册我们创建的模型，以便管理面板可以访问这些模型。</p><h2 id="a4d3" class="ms mt it bd mu mv mw dn mx my mz dp na li nb nc nd lm ne nf ng lq nh ni nj nk bi translated">管理. py</h2><pre class="kj kk kl km gt nq ly nr bn ns nt bi"><span id="71d4" class="nu mt it ly b be nv nw l nx ny">from django.contrib import admin<br/>from .models import Post, Upvote, Comment<br/><br/>admin.site.register(Post)<br/>admin.site.register(Upvote)<br/>admin.site.register(Comment)</span></pre><p id="602d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上图所示，我们注册了三个模型— <code class="fe lv lw lx ly b">Post</code>、<code class="fe lv lw lx ly b">Upvote</code>和<code class="fe lv lw lx ly b">Comment</code>。</p><p id="34a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将在我们的<code class="fe lv lw lx ly b">posts</code>文件夹中创建一个名为<code class="fe lv lw lx ly b">urls.py</code>的文件，我们将为我们为<code class="fe lv lw lx ly b">posts</code>应用编写的所有视图编写 URL。</p><h2 id="9fbb" class="ms mt it bd mu mv mw dn mx my mz dp na li nb nc nd lm ne nf ng lq nh ni nj nk bi translated">urls.py</h2><p id="80bf" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">在<code class="fe lv lw lx ly b">urls.py</code>文件中，我们将为我们的<code class="fe lv lw lx ly b">posts</code>应用程序定义 URL 模式，然后我们必须将它们包含在<code class="fe lv lw lx ly b">blog</code>应用程序中的<code class="fe lv lw lx ly b">urls.py</code>文件中。</p><pre class="kj kk kl km gt nq ly nr bn ns nt bi"><span id="bf05" class="nu mt it ly b be nv nw l nx ny">from django.urls import path<br/>from .views import PostListAPIView, PostDetailAPIView, UserPostAPIView, UpvoteAPIView, CommentAPIView<br/><br/><br/>urlpatterns = [<br/>    path('', PostListAPIView.as_view()),<br/>    path('&lt;int:pk&gt;/', PostDetailAPIView.as_view()),<br/>    path('&lt;int:pk&gt;/upvote/', UpvoteAPIView.as_view()),<br/>    path('&lt;int:pk&gt;/comment/', CommentAPIView.as_view()),<br/>    path('&lt;username&gt;/', UserPostAPIView.as_view())<br/>]</span></pre><p id="3927" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，<code class="fe lv lw lx ly b">urlpatterns</code>是博客应用的 URL 模式列表。列表中的每个元素都是一个将 URL 路径映射到视图的<code class="fe lv lw lx ly b">path</code>对象。</p><p id="b0e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列表中的第一个元素将根 URL ( <code class="fe lv lw lx ly b">/</code>)映射到<code class="fe lv lw lx ly b">PostListAPIView</code>视图，因此当用户访问根 URL 时，<code class="fe lv lw lx ly b">PostListAPIView</code>视图将被调用并处理请求。列表中的其他元素将表单<code class="fe lv lw lx ly b">/&lt;int:pk&gt;/</code>、<code class="fe lv lw lx ly b">/&lt;int:pk&gt;/upvote/</code>、<code class="fe lv lw lx ly b">/&lt;int:pk&gt;/comment/</code>和<code class="fe lv lw lx ly b">/&lt;username&gt;/</code>的 URL 映射到相应的视图。这些 URL 用于访问单个帖子、投票赞成/投票反对帖子、创建帖子评论以及查看特定用户的帖子。</p><p id="400a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">&lt;int:pk&gt;</code>是一个 URL path 参数，指定 URL 路径应该在那个位置包含一个整数值(post 的主键)。当访问 URL 时，这个整数值作为参数<code class="fe lv lw lx ly b">pk</code>传递给视图，视图可以用它来检索带有指定主键的文章。这允许视图处理特定帖子而不是所有帖子的请求。</p><p id="bfdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，<code class="fe lv lw lx ly b">/&lt;username&gt;/</code>用于访问特定用户的帖子。当 URL 被访问时，<code class="fe lv lw lx ly b">username</code>被传递给视图。</p><p id="0a2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在<code class="fe lv lw lx ly b">blog</code>应用程序的<code class="fe lv lw lx ly b">urls.py</code>文件中，我们将像对待<code class="fe lv lw lx ly b">users</code>应用程序一样包含<code class="fe lv lw lx ly b">posts</code>应用程序的 URL。</p><pre class="kj kk kl km gt nq ly nr bn ns nt bi"><span id="a93d" class="nu mt it ly b be nv nw l nx ny">from django.contrib import admin<br/>from django.urls import path, include<br/>from posts import urls as posts_urls<br/>from users import urls as users_urls<br/><br/>urlpatterns = [<br/>    path("admin/", admin.site.urls),<br/>    path("api-auth/", include("rest_framework.urls", namespace="rest_framework")),<br/>    path("api/posts/", include(posts_urls)),<br/>    path("api/users/", include(users_urls)),<br/>]</span></pre><p id="5e67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在测试 API 之前，我们需要执行迁移，因为我们已经创建了新的模型。</p><p id="92f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们将运行以下命令来实现这一点:</p><pre class="kj kk kl km gt nq ly nr bn ns nt bi"><span id="29db" class="nu mt it ly b be nv nw l nx ny">python manage.py makemigrations<br/>python manage.py migrate</span></pre><p id="d6f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们在 Django 中创建新模型时，我们需要运行一个迁移，因为数据库模式需要匹配将要存储在其中的数据的结构。如果不运行迁移，数据库将没有正确的表和字段来存储新模型中的数据，并且当我们试图从模型中保存或检索数据时将会出现错误。</p><p id="b9cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">python manage.py makemigrations</code>命令分析我们对模型所做的更改，并创建一个新的迁移文件，其中包含更新数据库模式的指令。</p><p id="9784" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">python manage.py migrate</code>命令将迁移文件中的更改应用到数据库。这将更新数据库模式，并确保它与我们的模型同步。</p><p id="f5b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以像测试<code class="fe lv lw lx ly b">users</code>应用程序一样测试<code class="fe lv lw lx ly b">posts</code>应用程序的 API。由于这篇文章已经太大了，所以我将把测试部分留给<code class="fe lv lw lx ly b">posts</code> app 让你自己做。这与您为<code class="fe lv lw lx ly b">users</code>应用程序所做的非常相似，首先运行服务器，然后转到<code class="fe lv lw lx ly b">urls.py</code>文件中定义的各个 URL。</p><p id="0665" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，这就把我们带到了本系列文章后端部分的结尾。我希望你们都喜欢后端部分，并了解了 DRF 是如何工作的，现在你应该尝试自己构建它，并添加功能来进一步增强应用程序。</p><p id="9b18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将很快开始我们网站的前端工作，并将很快在前端部分添加文章。当他们准备好的时候，我将在这儿把他们连接起来。在那之前，继续学习！</p><p id="9f71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里还有一些你想读的文章系列:</p><div class="lz ma gp gr mb mc"><a rel="noopener follow" target="_blank" href="/build-a-social-media-website-using-django-setup-the-project-part-1-6e1932c9f221"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd iu gy z fp mh fr fs mi fu fw is bi translated">使用 Django 构建一个社交媒体网站——设置项目(第 1 部分)</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">在第一部分中，我们通过设置密码来集中设置我们的项目和安装所需的组件…</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">towardsdatascience.com</p></div></div><div class="ml l"><div class="on l mn mo mp ml mq ks mc"/></div></div></a></div><div class="lz ma gp gr mb mc"><a href="https://javascript.plainenglish.io/build-an-e-commerce-website-with-mern-stack-part-1-setting-up-the-project-eecd710e2696" rel="noopener  ugc nofollow" target="_blank"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd iu gy z fp mh fr fs mi fu fw is bi translated">让我们建立一个 MERN 堆栈电子商务网络应用程序</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">第 1 部分:设置项目</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ml l"><div class="oo l mn mo mp ml mq ks mc"/></div></div></a></div></div></div>    
</body>
</html>