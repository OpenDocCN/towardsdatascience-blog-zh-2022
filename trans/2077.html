<html>
<head>
<title>Quadratic Optimization with Constraints in Python using CVXOPT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用CVXOPT在Python中实现带约束的二次优化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/quadratic-optimization-with-constraints-in-python-using-cvxopt-fc924054a9fc#2022-05-10">https://towardsdatascience.com/quadratic-optimization-with-constraints-in-python-using-cvxopt-fc924054a9fc#2022-05-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/99f66ac0abb32934eb6b7da426a761c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S1UopJtACvWKrNEc"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">弗洛里安·施梅兹在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="e452" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">二次优化是很多领域都会遇到的问题，从最小二乘回归[1]到投资组合优化[2]以及路过模型预测控制[3]。在所有这些问题中，必须优化对不同资产或代理的资源分配(这通常对应于线性项)，知道在这些资产或代理之间可能存在有益或无益的交互(这对应于二次项)，同时满足一些特定的约束(不将所有资源分配给同一代理或资产，确保所有分配的资源的总和不超过总的可用资源，等等。).当约束不能用线性公式表示时，可能会出现困难。在本文中，我们将看到如何使用一个非常强大的python库CVXOPT [4，5]来解决这些优化问题，该库依赖于LAPACK和BLAS例程(这些是用Fortran 90编写的高效线性代数库)[6]。</p><p id="ab6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从数学上来说，目标是找到最小化多元二次函数的自变量，同时满足一些等式和不等式约束。要优化的函数具有以下一般形式:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/213b1fcf04561c0a580d430123f6ec7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*QvJbUChYDoxSBESGIBtQNw.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">二次函数</p></figure><p id="6c2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<strong class="kf ir"> x </strong>是大小为n的未知向量，<strong class="kf ir"> r </strong>是与<strong class="kf ir"> x </strong>大小相同的向量，并且<strong class="kf ir"> Q </strong>是n乘n维的对称方阵。约束可以被公式化为一组等式和不等式，使得:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/cdfe8a9d15e395277c834e1075ac0054.png" data-original-src="https://miro.medium.com/v2/resize:fit:194/format:webp/1*lWoiPYcwkef_1VW9SGQLPw.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">限制</p></figure><p id="2395" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<strong class="kf ir"> A </strong>是一个n乘m的矩阵(其中m是等式约束的数量)，<strong class="kf ir"> b </strong>是一个大小为m的向量，<strong class="kf ir"> G </strong>是一个n乘m’的矩阵(其中m’是不等式约束的数量)，而<strong class="kf ir"> h </strong>是一个大小为m’的向量。卷曲的不等式符号意味着不等式适用于向量的每个元素。</p><p id="a687" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在CVXOPT形式中，我们如何写这个？考虑下面的代码:</p><pre class="lc ld le lf gt lh li lj lk aw ll bi"><span id="aa0c" class="lm ln iq li b gy lo lp l lq lr"># Import Libraries</span><span id="02c1" class="lm ln iq li b gy ls lp l lq lr"><strong class="li ir">import</strong> numpy <strong class="li ir">as</strong> np<br/><strong class="li ir">import</strong> cvxopt <strong class="li ir">as</strong> opt<br/><strong class="li ir">from</strong> cvxopt <strong class="li ir">import</strong> matrix, spmatrix, sparse<br/><strong class="li ir">from</strong> cvxopt.solvers <strong class="li ir">import</strong> qp, options<br/><strong class="li ir">from</strong> cvxopt <strong class="li ir">import</strong> blas</span><span id="e4db" class="lm ln iq li b gy ls lp l lq lr"><br/># Generate random vector r and symmetric definite positive matrix Q</span><span id="9ed3" class="lm ln iq li b gy ls lp l lq lr">n = 50<br/>r = matrix(np.random.sample(n))<br/>Q = np.random.randn(n,n)<br/>Q = 0.5 * (Q + Q.T)<br/>Q = Q + n * np.eye(n)<br/>Q = matrix(Q)</span><span id="f57e" class="lm ln iq li b gy ls lp l lq lr"># Solve</span><span id="d590" class="lm ln iq li b gy ls lp l lq lr">sol = qp(Q, -r)</span></pre><p id="1db4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解决方案“sol”是一个字典，其中包含在关键字“x”下最小化损失函数的向量，以及在关键字“status”下是否找到最佳解决方案的信息。</p><p id="66dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如何在这种形式主义中实现约束？所有需要做的就是提供矩阵<strong class="kf ir"> A </strong>和<strong class="kf ir"> G </strong>以及之前定义的向量<strong class="kf ir"> b </strong>和<strong class="kf ir"> h </strong>。假设我们希望<strong class="kf ir"> x </strong>的元素之和等于1，并且<strong class="kf ir"> x </strong>的所有元素都是正的。数学上，这些条件是:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/418003940f341a8db67dbaddec805d19.png" data-original-src="https://miro.medium.com/v2/resize:fit:238/format:webp/1*da8oUm6ymalkAicfkjnIag.png"/></div></figure><p id="714e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且可以用矩阵格式写成:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/fb64aebd63d88e81e0bcb33469fdff33.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*WyUL9HauKWhQJzBLOO8HOw.png"/></div></figure><p id="edd2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以将矩阵A、G、b和h定义为:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/5469671ee59f4a198083dffe798da9c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/1*9Km6l06Y7wGgYybGbSa49A.png"/></div></figure><p id="2208" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在CVXOPT形式中，这些变成:</p><pre class="lc ld le lf gt lh li lj lk aw ll bi"><span id="dc1c" class="lm ln iq li b gy lo lp l lq lr"># Add constraint matrices and vectors</span><span id="44b9" class="lm ln iq li b gy ls lp l lq lr">A = matrix(np.ones(n)).T<br/>b = matrix(1.0)<br/>G = matrix(- np.eye(n))<br/>h = matrix(np.zeros(n))</span><span id="00a5" class="lm ln iq li b gy ls lp l lq lr"># Solve and retrieve solution</span><span id="77f6" class="lm ln iq li b gy ls lp l lq lr">sol = qp(Q, -r, G, h, A, b)['x']</span></pre><p id="6869" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在找到的解决方案遵循强加的约束。</p><h1 id="595e" class="lw ln iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">摩擦效应</h1><p id="7d14" class="pw-post-body-paragraph kd ke iq kf b kg mt ki kj kk mu km kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">现在让我们添加一种不同类型的非线性约束。假设在某一时刻找到了最优解。稍后，矩阵<strong class="kf ir"> Q </strong>和向量<strong class="kf ir"> r </strong>已经用新值更新。然而，改变资源或资产的分配是有成本的。因此，改变旧向量<strong class="kf ir"> x </strong>中的一个值必须是值得的，以便证明这个成本是合理的。这个问题现在可以表述为:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/ef91185483e65c75d52578eecbf2846f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*_bngq5bYkCLEryIxDnkkaw.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">有周转费用的二次函数</p></figure><p id="0c0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用<strong class="kf ir"> c </strong>表示从一个解决方案到另一个解决方案的摩擦效应的向量，或者分配和取消分配资源的成本。这个新的损失不再是二次的，因为有一项包含绝对值，这是有问题的，因为它是不可微的。如何解决这个问题？解决方案是添加额外的变量，这些变量将对应于从一个状态到下一个状态的变化，然后线性化损失函数。上述等式的线性部分变为:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/5cdfe4c7f294dffb4a38c779c1163c9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*zbK7ZqQWxa8__4cLc12b-A.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">线性化周转成本</p></figure><p id="d07b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的等式中，我们已经考虑了对于不同的代理/资产分配和不分配资源，摩擦效应或成本可能是不同的。然后，我们必须添加额外的约束，以确保这些额外的变量很好地对应于从一个解决方案到下一个解决方案的变化:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi na"><img src="../Images/337a913fba13d707a4a110e05cca7770.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*CEUejbKYElKExFm07HCFGg.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">额外周转限制</p></figure><p id="a779" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过将<strong class="kf ir"> x </strong>与<strong class="kf ir"> x的变量</strong>连接起来获得新的未知向量<strong class="kf ir"> X </strong>，我们对新的<strong class="kf ir"> Q </strong>和<strong class="kf ir"> r </strong>矩阵和向量做同样的事情:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/a772803b065d194042e8bb9758124bd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*i3ne3VCKEyBTBnouyMxK4A.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">串接<strong class="bd nc"> X </strong>、<strong class="bd nc"> Q </strong>和<strong class="bd nc"> r </strong></p></figure><p id="599c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们实施约束条件:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/c829fb44baa4035115ca4a1f78bbeb48.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*SmBCrcj7CsTpf5qa16Y9yQ.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">具有摩擦效应的约束</p></figure><p id="9f06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后以下列方式修改代码:</p><pre class="lc ld le lf gt lh li lj lk aw ll bi"><span id="31d3" class="lm ln iq li b gy lo lp l lq lr"># Modify Loss Function</span><span id="91b0" class="lm ln iq li b gy ls lp l lq lr">n = 200<br/>c = 0.001<br/>max_weight = 0.05</span><span id="6175" class="lm ln iq li b gy ls lp l lq lr">r = matrix(np.block([np.random.sample(n), -c * np.ones(2*n)]))<br/>Q = np.random.randn(n,n)<br/>Q = 0.5 * (Q + Q.T)<br/>Q = Q + n * np.eye(n)<br/>Q = matrix(np.block([[Q, np.zeros((n,n)), np.zeros((n,n))], [np.zeros((n,n)), np.zeros((n,n)), np.zeros((n,n))], [np.zeros((n,n)), np.zeros((n,n)), np.zeros((n,n))]]))</span><span id="2c72" class="lm ln iq li b gy ls lp l lq lr"># Modify constraint matrices and vectors</span><span id="ceed" class="lm ln iq li b gy ls lp l lq lr">A = matrix(np.block([[np.ones(n), c * np.ones(n), -c * np.ones(n)], [np.eye(n), np.eye(n), -np.eye(n)]]))<br/>old_x = np.zeros(n)<br/>old_x[np.random.choice(n, n_assets_r, replace=False)] = max_weight<br/>b = matrix(np.block([1.0, old_x]))<br/>G = matrix(- np.eye(3*n))<br/>h = matrix(np.zeros(3*n))</span><span id="82b5" class="lm ln iq li b gy ls lp l lq lr"># Solve and retrieve solution</span><span id="204f" class="lm ln iq li b gy ls lp l lq lr">sol = qp(Q, -r, G, h, A, b)['x']</span></pre><p id="8d63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们已经了解了如何考虑从一种解决方案过渡到另一种解决方案时的摩擦效应。</p><h1 id="c7a6" class="lw ln iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">实际例子:投资组合优化</h1><p id="67ad" class="pw-post-body-paragraph kd ke iq kf b kg mt ki kj kk mu km kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">让我们考虑一个实际的例子来充分理解这种技术的使用:投资组合优化。在Markowitz的投资组合优化理论[2]中，<strong class="kf ir"> r </strong>向量对应的是对不同资产收益的预测。这种预测是由我们在这里不考虑的任何预测模型给出的。Q矩阵对应于这些相同资产收益的协方差矩阵。在这种情况下，可以采用历史协方差矩阵。我们将稍微改变一下这里的符号，使用ω作为未知向量。ω值对应于投资组合中不同资产的权重。损失函数现在可以写成:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/274360b6e66d0d5ff27bc2ba6b4e4da5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*OR5wo8ZJEPPBgqz-aEqbFw.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">投资组合优化的二次函数</p></figure><p id="7f38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们还引入了λ，它代表了用户的风险厌恶。等式的第一项代表这个投资组合的预期收益。第二项代表投资组合的风险。λ值越低，意味着可以承受的风险越大。最后一项代表从一个投资组合到另一个投资组合的交易成本。</p><p id="4105" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们想增加一些投资组合优化中常见的约束条件。我们希望我们的投资组合在某种程度上多样化，这可以通过增加权重的上限来确保。我们还可能希望进一步减少从一个投资组合到另一个投资组合的变动，这种变动转化为周转限制。数学上，这些可以写成:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/de328d4397b1beb5b6e300ef224856ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*D5wPDBlmuUW5LhniXX0eRw.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">投资组合优化的约束</p></figure><p id="2846" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中T对应于允许的最大营业额，可以取0(不允许修改)和2(没有营业额限制)之间的值。下面列出的约束中的最后一项是前一个约束的修改，其中权重之和应该等于1。这种修改反映了这样一个事实，即当资产被买卖时，交易费用被支付，因此投资组合的资本减少[6]。在矩阵形式中，这些约束变成:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/4798b5458d12e2669b82b5b28f18b081.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*c-fJB4odRhVVsaTKVcckLA.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">投资组合优化的约束</p></figure><p id="526a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且以下面的方式修改代码:</p><pre class="lc ld le lf gt lh li lj lk aw ll bi"><span id="43a4" class="lm ln iq li b gy lo lp l lq lr">max_weight = 0.05<br/>turnover = 2.0</span><span id="ee40" class="lm ln iq li b gy ls lp l lq lr"># Modify the Q matrix so that it resembles <br/># the covariance matrix of returns</span><span id="7d7d" class="lm ln iq li b gy ls lp l lq lr">T = np.random.randn(n,100)<br/>Q = np.cov(T)<br/>Q = matrix(np.block([[Q, np.zeros((n,n)), np.zeros((n,n))], [np.zeros((n,n)), np.zeros((n,n)), np.zeros((n,n))], [np.zeros((n,n)), np.zeros((n,n)), np.zeros((n,n))]]))</span><span id="28e2" class="lm ln iq li b gy ls lp l lq lr"># Create constraint matrices</span><span id="5271" class="lm ln iq li b gy ls lp l lq lr">G = matrix(0.0, (6 * n + 1, 3 * n))<br/>h = opt.matrix(0.0, (6 * n + 1, 1))<br/>for k in range(3 * n):<br/>    # wi &gt; 0 constraint<br/>    G[k, k] = -1</span><span id="4887" class="lm ln iq li b gy ls lp l lq lr"># wi &gt; max_weight<br/>    G[k + 3 * n, k] = 1<br/>    h[k + 3 * n] = max_weight</span><span id="299d" class="lm ln iq li b gy ls lp l lq lr">for k in range(2 * n):<br/>    # sum dwi+ + dwi- &lt; turnover<br/>    G[6 * n, k + n] = 1<br/>    <br/>h[6 * n] = turnover</span></pre><p id="1bf0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们计算有效边界，这是给定风险厌恶的最佳投资组合的集合</p><pre class="lc ld le lf gt lh li lj lk aw ll bi"><span id="6028" class="lm ln iq li b gy lo lp l lq lr"># Compute random portfolios in order to have a baseline</span><span id="f703" class="lm ln iq li b gy ls lp l lq lr">n_random = 10000<br/>random_returns = np.zeros(n_random)<br/>random_risks = np.zeros(n_random)<br/>n_assets_r = 20</span><span id="276b" class="lm ln iq li b gy ls lp l lq lr">for i in range(n_random):<br/>    w0 = np.zeros(n)<br/>    w0[np.random.choice(n, n_assets_r, replace=False)] = 1 / n_assets_r<br/>    random_returns[i] = np.dot(w0, r[:n])<br/>    random_risks[i] = np.dot(w0, np.dot(Q[:n,:n], w0))</span><span id="fc0e" class="lm ln iq li b gy ls lp l lq lr"># Compute the optimal portfolio for different values<br/># of lambda, the risk aversion</span><span id="44b8" class="lm ln iq li b gy ls lp l lq lr">lmbdas = [10 ** (5.0 * t / N - 1.0) for t in range(N)]</span><span id="d92a" class="lm ln iq li b gy ls lp l lq lr">sol = [qp(lmbda / 2 * Q, -r, G, h, A, b)['x'] for lmbda in lmbdas]</span><span id="f330" class="lm ln iq li b gy ls lp l lq lr">optimal_returns = np.array([blas.dot(x, r) for x in sol])<br/>optimal_risks = np.array([blas.dot(x, Q * x) for x in sol])</span></pre><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/9e14725b4400d91d2d62ca61eee0003b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y9MYSUDT_7DmEUHwOTz7HA.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">有效边界(图片来自作者)</p></figure><p id="fb5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个图中，我们绘制了一组随机投资组合的风险和回报，以此作为基线。我们看到，对于给定的风险，最佳计算的投资组合总是比任何随机投资组合有更大的回报。还描述了初始投资组合的风险和回报。</p><p id="853e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了形象化最大周转率的重要性，我们可以重复计算有效边界的不同值(25%、50%、100%和200%)。完全改变投资组合意味着出售所有资产(周转100%的资产)，然后购买一套全新的资产(再次周转100%)，相当于200%的周转率。因此，投资组合的最大周转率是200%。我们预计有效边界会随着更小的最大换手率而收缩，因为该算法改变初始投资组合权重的选项更少。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/328537cb27cc3814c59411b20fa763f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9i6_OodOUsI_Cwz1eBZ8wg.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">有效边界(图片来自作者)</p></figure><p id="d097" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一假设在一定程度上得到了验证:对于这一特定的初始投资组合，将最大周转率从100%增加到200%似乎不会过多地阻碍优化过程。这可能是由于预测的性质，在我们的情况下，从一个时间步到另一个时间步变化不大。因此，稍微优化的投资组合不需要太多的改变就可以完全优化。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h2 id="7628" class="lm ln iq bd lx np nq dn mb nr ns dp mf ko nt nu mj ks nv nw mn kw nx ny mr nz bi translated">结束语</h2><p id="ce69" class="pw-post-body-paragraph kd ke iq kf b kg mt ki kj kk mu km kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">在本文中，我们已经看到了如何使用CVXOPT，这是一个强大而快速的求解器，以解决带约束的二次优化问题。我们已经看到了如何调整一些既不是线性的也不是二次的约束和损失类型(例如交易成本损失和周转约束),以便求解器可以处理它们。然而，尽管规划求解非常高效且非常灵活，但它无法处理所有类型的约束。事实上，如果我们希望添加稀疏性约束(我们希望最多有N个非零权重)，这不能以线性或二次方式重新表述。在这种情况下，可能值得研究更灵活且能处理任何类型损失函数的其他方法，例如模拟退火。</p><p id="9d75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">参考文献</strong></p><p id="6b61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[1]https://mathworld.wolfram.com/LeastSquaresFitting.html<a class="ae kc" href="https://mathworld.wolfram.com/LeastSquaresFitting.html" rel="noopener ugc nofollow" target="_blank"/></p><p id="0cd2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[2]<a class="ae kc" href="https://onlinelibrary.wiley.com/doi/abs/10.1111/j.1540-6261.1952.tb01525.x" rel="noopener ugc nofollow" target="_blank">https://online library . Wiley . com/doi/ABS/10.1111/j . 1540-6261.1952 . TB 01525 . x</a></p><p id="7c46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[3]<a class="ae kc" href="https://arxiv.org/abs/2002.06835" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/abs/2002.06835</a></p><p id="06db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://cvxopt.org/" rel="noopener ugc nofollow" target="_blank">https://cvxopt.org/</a></p><p id="ef09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[5] <a class="ae kc" href="https://mitpress.mit.edu/books/optimization-machine-learning" rel="noopener ugc nofollow" target="_blank">机器学习的优化，Suvrit Sra，Sebastian Nowozin和Stephen J. Wright </a></p><p id="6b55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[6]<a class="ae kc" href="https://www.netlib.org/lapack/" rel="noopener ugc nofollow" target="_blank">https://www.netlib.org/lapack/</a></p><p id="3d63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[7] <a class="ae kc" href="http://www.thierry-roncalli.com/RiskParityBook.html" rel="noopener ugc nofollow" target="_blank">风险平价和预算简介，Thierry Roncalli </a></p><h2 id="6d2f" class="lm ln iq bd lx np nq dn mb nr ns dp mf ko nt nu mj ks nv nw mn kw nx ny mr nz bi translated">关于我们</h2><p id="7068" class="pw-post-body-paragraph kd ke iq kf b kg mt ki kj kk mu km kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated"><a class="ae kc" href="https://www.advestis.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Advestis </strong> </a>是一家欧洲合同研究组织(CRO)，对统计学和可解释机器学习技术有着深刻的理解和实践。Advestis的专长包括复杂系统的建模和时间现象的预测分析。<br/> <em class="oa">领英</em>:<a class="ae kc" href="https://www.linkedin.com/company/advestis/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/company/advestis/</a></p></div></div>    
</body>
</html>