<html>
<head>
<title>How Can Pandas Cope With Big Datasets?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫如何应对大数据集？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-can-pandas-cope-with-big-datasets-c5a08446230#2022-05-31">https://towardsdatascience.com/how-can-pandas-cope-with-big-datasets-c5a08446230#2022-05-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9ccb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">管理大量数据的策略</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0237073bd9cfb9a402f506bb89716d61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NPp3_ebqVNXvmq_rgxuNng.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由Kayla S:<a class="ae ky" href="https://www.pexels.com/photo/a-panda-bear-in-the-cage-4444036/" rel="noopener ugc nofollow" target="_blank">https://www . pexels . com/photo/a-熊猫-笼子里的熊-4444036/ </a></p></figure><p id="8a3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谈到用Python进行数据操作，Pandas可以说是最受欢迎的模块。它有巨大的效用，包含了大量的特性，并拥有强大的社区支持。</p><p id="4780" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，Pandas有一个明显的缺点:它的性能水平随着数据集的增大而下降。</p><p id="51b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Pandas处理较大数据集的计算需求会导致长时间运行，甚至可能由于内存不足而导致错误。</p><p id="50b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然追求更擅长处理大型数据集的其他工具可能很诱人，但首先探索可以用来处理Pandas大量数据的措施是值得的。</p><p id="0ab0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们涵盖了用户可以使用Pandas来节省内存和处理大量数据的策略。</p><p id="8375" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注:每个策略都将通过由<a class="ae ky" href="https://www.mockaroo.com/" rel="noopener ugc nofollow" target="_blank"> Mockaroo </a>生成的假数据集进行演示。</p><h2 id="76bc" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">1.加载较少的数据</h2><p id="8e98" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">从数据框中移除列是数据预处理中的一个常见步骤。</p><p id="48d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，在加载数据后，这些列会被忽略。</p><p id="ef1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，下面的代码加载模拟数据集，然后省略除5列之外的所有列。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="7f65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然在大多数情况下这是一种可行的方法，但这是一种浪费，因为您要使用大量内存来加载甚至不需要的数据。我们可以用<code class="fe mv mw mx my b">memory_usage</code>函数测量模拟数据集的内存使用情况。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/31e56254f5d9eb417586bfe6dacf627f.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*F_k8iJ6F_KFCabzgPtIyrg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><p id="4a2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个更好的解决方案是在数据加载过程中省略掉不需要的列。这将确保内存仅用于相关信息。</p><p id="5416" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以通过<code class="fe mv mw mx my b">usecols</code>参数来实现，该参数允许用户在加载数据集时选择包含<em class="na">的列。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/947dbd23d811494b744fa37f380f7b41.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*InsPGpljFdXTBixobEDiDQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><p id="acc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单独包含该参数会显著降低内存消耗。</p><h2 id="ba39" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">2.使用节省内存的数据类型</h2><p id="6e76" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">只要为相关变量选择适当的数据类型，就可以节省大量内存。</p><p id="2245" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果用户没有为每个变量显式选择数据类型，Pandas模块将默认为其赋值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/f4ca0296273eb9811ef5be74d32310f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*p96zArFp8S2iZ6tMhrkeLg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><p id="c788" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这是一个很方便的特性，但是就内存效率而言，分配给每一列的数据类型可能并不理想。</p><p id="5fe0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">减少内存使用的一个关键步骤是手动为变量分配最节省内存的数据类型。</p><p id="9abc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">数值变量的数据类型</strong></p><p id="56bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas模块对数值变量使用int64和float64数据类型。</p><p id="d65e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">int64和float64数据类型提供最大数量和精度的值。但是，反过来，这些数据类型需要最多的内存。</p><p id="8069" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是模拟数据集的总内存消耗。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/d099e36a9fd910c7e3314b1358aaa14d.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/format:webp/1*zJN1n26w9qaI4lOjQenj-w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><p id="6b6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，处理较小数值或精度的变量不需要这种消耗内存的数据类型。</p><p id="f0e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在模拟数据集中，较小的数据类型将满足像<code class="fe mv mw mx my b">age</code>、<code class="fe mv mw mx my b">weight</code>、<code class="fe mv mw mx my b">income</code>和<code class="fe mv mw mx my b">height</code>这样的变量。让我们看看在为这些变量分配新的数据类型时，数值数据的内存是如何变化的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/1bbf13dfb12c4789594ae990965c3bee.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/1*sIdM-qM3ZpEBYmmMUBsh6Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><p id="818b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转换数据类型的简单操作可以大大减少内存的使用。</p><p id="a2bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:使用不适应变量值的数据类型会导致信息丢失。手动分配数据类型时要小心。</p><p id="3ac7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，<code class="fe mv mw mx my b">income</code>列被赋予int32数据类型，而不是int8数据类型，因为该变量包含更大的值。</p><p id="8239" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了强调选择正确数据类型的重要性，让我们将数据集中的原始收入值与int32和int8数据类型的收入值进行比较。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/7221ea4813271c893ea1e1517740997f.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*OXrbPGsa_CnskUmYxKK_Xw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><p id="fee2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如输出所示，选择错误的数据类型(在本例中为int8)会改变值，并妨碍任何后续数据操作的结果。</p><p id="31db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">清楚地了解您的数据以及可用数据类型(例如int8、int16、int32等)提供的值的范围。)在为感兴趣的变量分配数据类型时是必不可少的。</p><p id="7d2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了提高内存效率，一个好的做法是在用参数<code class="fe mv mw mx my b">dtype</code>加载数据集的同时指定数据类型<em class="na">。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="59e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">类别变量的数据类型</strong></p><p id="36ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过将分类变量指定为“category”数据类型，也可以节省内存。</p><p id="6e08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一个例子，让我们看看在将“category”数据类型分配给<code class="fe mv mw mx my b">gender</code>列之后，内存消耗是如何变化的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/32d317896fdd5aa1f1b7e0adc5e377f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*9WJs4ovsFGFxcYgk_C7rYQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><p id="e242" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，这种转换大大减少了内存的使用。</p><p id="092f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这种方法有一个警告。当“category”数据类型的列包含大量的唯一值时，它会消耗更多的内存。因此，这种转换不是对每个变量都可行的。</p><p id="9102" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了突出这一点，我们可以检查这种转换对数据框中所有分类变量的影响。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/a291e39fe8dcdbc1f13e9b27d3b5e805.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*6lU0cZDJy6P3Uz-6a27DUA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><p id="c74e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如输出所示，虽然转换后<code class="fe mv mw mx my b">gender</code>和<code class="fe mv mw mx my b">job</code>列的内存使用较少，但是<code class="fe mv mw mx my b">first_name</code>和<code class="fe mv mw mx my b">last_name</code>列的内存使用较多。这可能是因为数据集中存在大量唯一的名字和姓氏。</p><p id="92cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于这个原因，在为列分配“category”数据类型以节省内存时要小心。</p><h2 id="a754" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">3.分块加载数据</h2><p id="5e53" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">对于太大而不适合内存的数据集，Pandas提供了<code class="fe mv mw mx my b">chunk_size</code>参数，允许用户决定每次迭代应该导入多少行。</p><p id="b9b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当给这个参数赋值时，<code class="fe mv mw mx my b">read_csv</code>函数将返回一个迭代器对象，而不是一个实际的数据帧。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/01317be2143125799bc4de72c08fcaab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*KZfdtp1dxotHGI_dlIS2-Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><p id="0e73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">获取数据需要遍历这个对象。通过将大型数据集分割成较小的部分，可以在不超出内存限制的情况下执行数据操作。</p><p id="3afd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们遍历数据集的每个子集，过滤数据，然后将其追加到一个列表中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f918" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们使用<code class="fe mv mw mx my b">concat</code>函数将列表中的所有元素合并在一起，以获得一个完整的数据集。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/0b7d2c989408364cda10c689703e007c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w1ecBMiTe6bz0vCm-J0j_g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><h2 id="5a45" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">熊猫的局限性</h2><p id="65a1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">熊猫可能具有处理大量数据的功能，但在“大数据”面前它们是不够的，这些数据可能包含许多千兆字节或兆兆字节的数据。</p><p id="0f61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该模块在CPU的一个核心中执行其操作。不幸的是，一旦内存使用和计算需求达到一定的水平，用一个处理器执行任务是不可行的。</p><p id="d648" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这种情况，有必要实现类似并行处理的技术，这需要在一台机器的多个内核上运行一个任务。</p><p id="6990" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python提供了像<a class="ae ky" href="https://dask.org/" rel="noopener ugc nofollow" target="_blank"> Dask </a>和<a class="ae ky" href="https://spark.apache.org/docs/latest/api/python/" rel="noopener ugc nofollow" target="_blank"> PySpark </a>这样的库，它们整合了并行处理，使用户能够以更快的速度执行操作。</p><p id="56d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，这些工具主要专注于处理数据密集型任务，可能不会提供与熊猫相同的功能。所以，除非必要，否则最好不要依赖它们。</p><h2 id="a048" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">结论</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/11a2e5e4a59cbf705f9f4ec48918abce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ehgb05NV7YBvYzHB"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@prateekkatyal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Prateek Katyal </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="fc75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然Pandas主要用于中小规模的数据，但对于使用稍微大一点的数据集的任务，不应该避开它。该模块具有帮助容纳更大量数据的特征，尽管程度有限。</p><p id="1a8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas库经受了时间的考验，仍然是数据操作的首选库，所以除非万不得已，否则不要急于跳到其他解决方案。</p><p id="6963" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我祝你在数据科学的努力中好运！</p></div></div>    
</body>
</html>