<html>
<head>
<title>Understand Machine Learning through More Design Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过更多的设计模式理解机器学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understand-machine-learning-through-more-design-patterns-9c8430fd2ae8#2022-04-19">https://towardsdatascience.com/understand-machine-learning-through-more-design-patterns-9c8430fd2ae8#2022-04-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a358" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">四人帮关于设计模式的书似乎是一切开始的地方。他们提出了一个描述设计模式的框架。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1914842ec76418f8d27e51e730879592.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8XogyKeU3Ww1emaF2yeFKw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://unsplash.com/photos/43YBWkixcvk" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>的<a class="ae ky" href="https://unsplash.com/@oscartothekeys" rel="noopener ugc nofollow" target="_blank">奥斯卡金钥匙</a>的照片</p></figure><p id="0e4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/understand-machine-learning-through-7-software-design-patterns-a03572f4e695">在之前的故事</a>中，我们展示了软件工程领域中一些最常见的模式，并试图在开发机器学习过程的简单用例中实现它们。</p><p id="abf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们处理了四种附加的设计模式，它们被转化成几种场景，并在软件设计的许多领域中使用。</p><p id="7ade" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，第一篇文章使用了相同的数据集。我们在每个演示开始时加载的小python脚本中写下一些依赖关系，包括<code class="fe lv lw lx ly b">The Boston housing prices dataset</code>。</p><p id="86b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它可以在python <code class="fe lv lw lx ly b">scikit-learn</code>包中获得，并在文献中被广泛用于基准算法。它最初也是从<code class="fe lv lw lx ly b"><a class="ae ky" href="http://lib.stat.cmu.edu/datasets/boston" rel="noopener ugc nofollow" target="_blank">StatLib archive</a></code>获得的。</p><h1 id="98cd" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">实验:</h1><h2 id="70f2" class="mr ma it bd mb ms mt dn mf mu mv dp mj li mw mx ml lm my mz mn lq na nb mp nc bi translated">1.单身:</h2><blockquote class="nd ne nf"><p id="5ae6" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated">确保一个类只有一个实例，并提供对它的全局访问点。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/b3ce8d5ae0f656fe186a54b1721b9dbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9bKaafcgzY8agwX0UyqYnw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="edd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您希望将对象创建过程的全部控制权从自定义类的任何用户手中拿走。通过控制创建对象的过程，这是可行的。</p><p id="a0e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的自定义类实现如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="b9d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建基础学习者需要模型、训练数据和足够的参数。我们将<code class="fe lv lw lx ly b">Learner</code>封装在一个负责实例化它的全局类中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="49f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前导下划线告诉其他程序我们正在处理一个私有类，它们不应该在原始类定义之外使用它。私有类<code class="fe lv lw lx ly b">__Learner</code>是我们定义学习材料(模型、参数和训练数据)的地方。</p><p id="156b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在定义了私有类之后，有一个名为instance的东西作为私有属性。这是初始化过程的基础(稍后检查<code class="fe lv lw lx ly b">__new__</code>方法)；每当<code class="fe lv lw lx ly b">instance</code>为None时，我们的全局类允许我们创建一个且只有一个实例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="3cb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">id函数通知您内存中存放实例的位置:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/6cc9c0993b23259560cc6c4376367b7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*J2bcA60KDnUH6fecTFBZ5A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="bbe8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们的单例实现将确保每次都给出相同的实例。<br/>如果你希望改变它的一些属性，可以参考<code class="fe lv lw lx ly b">__setattr__</code> <strong class="lb iu"> </strong>的方法。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h2 id="540a" class="mr ma it bd mb ms mt dn mf mu mv dp mj li mw mx ml lm my mz mn lq na nb mp nc bi translated">2.模板:</h2><blockquote class="nd ne nf"><p id="c506" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated">在操作中定义算法的框架，将一些步骤推迟到子类。模板方法允许子类在不改变算法结构的情况下重新定义算法的某些步骤。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/8567b8ce4f1e4edcc73fa65006bb8ae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4fw6W6kYMG_h2ednze3iPw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="c1d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模板模式描述了流程的不同步骤，将它们分解成功能。然后，通过在每个步骤的级别进行干预并更改一两个细节，该过程将被推广到不同的场景。</p><p id="f8de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们提供了一个名为<code class="fe lv lw lx ly b">AlgoSkeleton</code>的抽象类，包含两个抽象方法(fit和predict):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9ff6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们创建两个具体的子类，其中我们强制两个分类算法的不同实现。(实现摘自Erik Linder-norén<strong class="lb iu"><em class="ng"/></strong>编写的巨大repo<strong class="lb iu"><em class="ng">NapkinML</em></strong>)。<br/>我们将每个子类与作为属性的适当参数相关联。这样，我们坚持由我们的<code class="fe lv lw lx ly b">AlgoSkeleton</code>界面决定的抽象结构。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="4ae1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们实例化了两个类，并使它们适合我们的数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="ceb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">瞧！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/800bbba2942e15206cb65bf1eb59c20c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KARoBiV0lBoh8RH5FYW74w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="be4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Template</code>方法让你将一个单一的算法变成一系列单独的步骤，这些步骤可以很容易地被子类扩展，同时保持超类中定义的结构不变。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h2 id="0713" class="mr ma it bd mb ms mt dn mf mu mv dp mj li mw mx ml lm my mz mn lq na nb mp nc bi translated">3.观察者:</h2><blockquote class="nd ne nf"><p id="d100" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated">定义对象之间的一对多依赖关系，这样当一个对象改变状态时，它的所有依赖对象都会得到通知并自动更新。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/9bc446413fe3627ca95f1a4cc0f832de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kwHG--wI0_TZE8r6DBxD5w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="1119" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您有一个或多个依赖于某种度量标准的模型。该指标是根据在一天/一周/一个月结束时收集和汇总的一批数据计算得出的。</p><p id="198d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">驱动模型以某种方式执行的事件可能已经发生；要么进行预测，要么决定某些漂移是否会导致模型表现不同(根据新数据重新拟合模型，参与一些基于规则的系统，..)</p><p id="e044" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该模式包括定义对象间的<code class="fe lv lw lx ly b">one-to-many</code>依赖关系，这样当一个对象改变状态时，它的所有依赖对象都会得到通知并自动更新。因此，每当在所谓的主体或可观察对象上注意到变化时，这种影响就会通过观察者传播开来。</p><p id="3b68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先定义一个<code class="fe lv lw lx ly b">Observable</code>类，它用来跟踪<code class="fe lv lw lx ly b">model_list</code>中的相关模型，并通过一个通知函数更新它们中的每一个。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="5f63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们写下一个继承了<code class="fe lv lw lx ly b">Observable</code>属性的<code class="fe lv lw lx ly b">Data</code>类，并在<code class="fe lv lw lx ly b">set_data</code>函数中添加了一个漂移标志。漂移将作为布尔值插入，但可以指真实场景中的真实计算:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="0297" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通过抽象类写下<code class="fe lv lw lx ly b">ModelObserver</code>的细节:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="273c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Modelobserver</code>的子类将被提供一个更新功能，如果<code class="fe lv lw lx ly b">Observer</code>在数据中声明一个概念漂移，将参与一个重新拟合过程。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="fc4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们演示一下我们刚刚构建的系统:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="3a4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们继续向<code class="fe lv lw lx ly b">data_before_drift</code>的model_list属性添加观察者:</p><pre class="kj kk kl km gt ny ly nz oa aw ob bi"><span id="85cc" class="mr ma it ly b gy oc od l oe of">data_before_drift.add_model(dt)<br/>data_before_drift.add_model(knr)</span></pre><p id="04de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，我们有一些影响我们的<code class="fe lv lw lx ly b">data_before_drift</code>实例的漂移数据。这将导致以前的模型参与有关新数据的更新过程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/bc17908c5826a40c4806d9012c965d4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AmdlGNGFjIhipBrvhEgktA.png"/></div></div></figure><p id="0a04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当您对一个对象进行的更改意味着更改其他对象时，该模式非常实用。这非常类似于发布者-订阅者系统，其中有一组订阅者在等待来自至少一个发布者的信息。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h2 id="181e" class="mr ma it bd mb ms mt dn mf mu mv dp mj li mw mx ml lm my mz mn lq na nb mp nc bi translated">4.访客:</h2><blockquote class="nd ne nf"><p id="2fea" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated">访问者模式表示要在对象结构的元素上执行的操作。Visitor允许您定义一个新的操作，而不改变它所操作的元素的类。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/8c98afbf8b99434e98cb06e50b129405.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0xLz4siAd2TZvnkTeCvksw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="0cbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您有一个由类模型持有的ML模型的定制网络，这些模型由一个对象结构编排，或者更具体地说，是一个包含这些模型列表的裸对象。</p><p id="49e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于示例的目的，对象结构提供了单个分类和单个回归模型。当一个ML模型被一个<code class="fe lv lw lx ly b">visitor</code>访问时，它从那个<code class="fe lv lw lx ly b">visitor</code>中调用对应于它的类的适当的度量操作。让我们深入细节。</p><p id="b490" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们构建了<code class="fe lv lw lx ly b">Visitor</code>和<code class="fe lv lw lx ly b">ComponentLearner</code> <strong class="lb iu"> <em class="ng">的抽象形式。我们使用与原作者相同的命名法来指代图案的不同砖块。</em></strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="a226" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Visitor</code>类将包含一个计算回归度量的<code class="fe lv lw lx ly b">visit_regressor</code>方法和一个同样用于分类的<code class="fe lv lw lx ly b">visit_classifier</code>方法。<br/>至于<code class="fe lv lw lx ly b">ComponentLearner</code>，接受方法将帮助我们区分要应用的合适访问方法。</p><p id="52e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Visitor</code>的一个子类将包含这两个方法的具体实现。<code class="fe lv lw lx ly b">ConcreteVisitor</code> <strong class="lb iu"> <em class="ng"> </em> </strong>将成为任何<code class="fe lv lw lx ly b">ComponentLearner</code> <strong class="lb iu"> <em class="ng"> </em> </strong>子类<strong class="lb iu"> <em class="ng">的具体访客。</em> </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="3a35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建两个组件类，一个回归器和一个分类器。两者在游客接受方式上有所不同。回归器将调用<code class="fe lv lw lx ly b">visit_regressor</code>方法，分类器将调用<code class="fe lv lw lx ly b">visit_classifier</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9ecc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的类将存储遇到的模型的列表，并显示每个模型的度量。<br/>不用说，我们不需要进一步说明哪种类型的访问方法对应于哪个组件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="5fd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们实例化一个访问者和三个组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="5f0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将三个组件连接到我们的<code class="fe lv lw lx ly b">listOfComponents</code>:</p><pre class="kj kk kl km gt ny ly nz oa aw ob bi"><span id="5f89" class="mr ma it ly b gy oc od l oe of">listOfComponents.attach(component1)<br/>listOfComponents.attach(component2)<br/>listOfComponents.attach(component3)</span></pre><p id="a5fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是从我们的显示方法中顺畅流出的指标:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/5f384f599462799812b21bda9c84d997.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D8uL_Atv_Y5uPlfYIPBJBg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="5447" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经注意到，在<code class="fe lv lw lx ly b">Visitor</code>的子类主体中添加补充操作很容易，同时收集它们和组件之间的相关操作，并分离不相关的操作。比方说，你想添加具有无人监管功能的组件，有一些工作要做，以提出这样的组件，但少了很多访问者。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="39e5" class="lz ma it bd mb mc oj me mf mg ok mi mj jz ol ka ml kc om kd mn kf on kg mp mq bi translated">结论:</h1><p id="d1b4" class="pw-post-body-paragraph kz la it lb b lc oo ju le lf op jx lh li oq lk ll lm or lo lp lq os ls lt lu im bi translated">你可以做很多事情来使你的代码优雅和整洁。设计模式帮助我们将重复性的东西和非重复性的东西分开。在我看来，一旦你的实例和类岌岌可危，能够恰当地使用它们将是一生的旅程。</p><p id="7003" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">玩得开心:)！</p></div></div>    
</body>
</html>