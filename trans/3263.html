<html>
<head>
<title>Advanced SQL: Going Beyond the Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级SQL:超越基础</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/advanced-sql-going-beyond-the-basics-bbcae047fe7e#2022-07-20">https://towardsdatascience.com/advanced-sql-going-beyond-the-basics-bbcae047fe7e#2022-07-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c085a9b8623f1cc94a2fb4ae80c65515.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sQEqGPAwPIS7HAEAHDbZow.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">卡斯帕·卡米尔·鲁宾在<a class="ae kf" href="https://unsplash.com/s/photos/sql?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="3144" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结构化查询语言(SQL)为您的工具箱增添了一大亮点。它可能不像Python或JavaScript那样受欢迎，但了解SQL，尤其是高级SQL，会带来很多好处。</p><p id="6823" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一方面，了解高级SQL技术可以帮助您从数据中获得更好的洞察力，从而可以更有效地交流您的想法。由于SQL和其他语言一样存在性能瓶颈和性能问题，因此更深入的了解将有助于您优化查询。</p><p id="9c6c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，额外的知识将帮助您从其他开发人员中脱颖而出，这些开发人员可能知道CRUD操作，但不知道高级SQL概念。这给了你一个职业优势。</p><p id="f9d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文将向您介绍一些高级SQL概念，包括子查询、运行总计和公共表表达式(cte)。接下来，您可以使用任何支持SQL的数据库和您选择的编辑器。你也可以使用一个在线SQL编辑器。</p><p id="5370" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下示例使用在线SQL编辑器和SQLite数据库。如果您正在使用PostgreSQL之类的数据库，您可能需要更改语法；然而，基本概念是相同的。</p><h1 id="2852" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">并集、交集和例外运算符</h1><p id="6f14" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">您可以使用本资源中<a class="ae kf" href="https://www.w3resource.com/sql/sql-table.php" rel="noopener ugc nofollow" target="_blank">的样本数据。在这个例子中，所有的命令都被合并到这个库</a>中的一个脚本中。运行该脚本，它将创建三个包含示例数据的表。以下是表格的模式:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/ab2a68ab112a53f2810d90fbf0c099a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/0*Rvve8EtDqvFPXCYX.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://www.w3resource.com/sql/sql-table.php" rel="noopener ugc nofollow" target="_blank"> <em class="mm">图片由w3 resource</em></a><em class="mm">(CC BY 4.0)</em></p></figure><p id="4108" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个表格的前五行如下所示:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/4a7625a4686e3bcb09bed6e76b3ac267.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gxg6HSh5IPl0mdTF.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">作者截图</p></figure><p id="d7c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mo mp mq mr b">UNION</code>、<code class="fe mo mp mq mr b">INTERSECT</code>和<code class="fe mo mp mq mr b">EXCEPT</code>运算符帮助您组合两个查询的结果。在处理集合时，SQL中的运算符类似于数学运算符。你必须记住以下规则:</p><blockquote class="ms mt mu"><p id="68bc" class="kg kh mv ki b kj kk kl km kn ko kp kq mw ks kt ku mx kw kx ky my la lb lc ld im bi translated"><em class="it">第一个查询返回的表中的列数和列顺序必须等于第二个查询返回的表中的列数和列顺序。此外，相应列的数据类型必须兼容。</em></p></blockquote><p id="c2e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是在SQL中使用运算符的一般语法:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="280f" class="nd lf it mr b gy ne nf l ng nh">SELECT * FROM TABLE1<br/>OPERATOR<br/>SELECT * FROM TABLE2</span></pre><h1 id="5e76" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">联合运算符</h1><p id="2dd2" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mo mp mq mr b">UNION</code>操作符返回来自两个查询的表的组合。默认情况下，结果不会有重复值。但是，如果您想保留副本，可以使用<code class="fe mo mp mq mr b">UNION ALL</code>操作符。</p><p id="6000" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下命令将返回所有不同城市的列表:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="4cc3" class="nd lf it mr b gy ne nf l ng nh">SELECT working_area FROM AGENTS<br/>UNION<br/>SELECT cust_city FROM CUSTOMER</span></pre><p id="6f25" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下命令将返回所有城市的列表，包括重复的城市:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="bb3c" class="nd lf it mr b gy ne nf l ng nh">SELECT <br/>  working_area <br/>FROM <br/>  AGENTS <br/>UNION ALL<br/>SELECT <br/>  cust_city <br/>FROM <br/>  CUSTOMER</span></pre><p id="1025" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下图比较了<code class="fe mo mp mq mr b">UNION</code>和<code class="fe mo mp mq mr b">UNION ALL</code>的输出:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/2d131bdf9176b9b95144fd65c730f065.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bkOy9JFMKtHQckV-.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">作者截图</p></figure><p id="4266" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如你所见，在右边的表格中，伦敦和班加罗尔被重复。</p><h1 id="9107" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">交集运算符</h1><p id="c9cb" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mo mp mq mr b">INTERSECT</code>操作符返回第一个和第二个查询返回的表中的公共元素。</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="3c88" class="nd lf it mr b gy ne nf l ng nh">-- Returns a list of common cities in both columns<br/>SELECT <br/>  working_area <br/>FROM <br/>  AGENTS <br/>INTERSECT <br/>SELECT <br/>  cust_city <br/>FROM <br/>  CUSTOMER</span></pre><p id="91e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结果如下所示:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/9f5f8d23881e392f6c8e347b073d3f5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0MXS_i-NZFq8m2mk.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">作者截图</p></figure><h1 id="1852" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">操作员除外</h1><p id="4a94" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mo mp mq mr b">EXCEPT</code>操作符返回第一个查询返回的表中所有不在第二个查询返回的表中的元素。</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="8b19" class="nd lf it mr b gy ne nf l ng nh">SELECT <br/>  working_area <br/>FROM <br/>  AGENTS <br/>EXCEPT <br/>SELECT <br/>  cust_city <br/>FROM <br/>  CUSTOMER</span></pre><p id="9837" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的命令将返回一个包含温哥华的单行表。你会注意到温哥华是唯一一个在<code class="fe mo mp mq mr b">CUSTOMER.cust_city</code>而不在<code class="fe mo mp mq mr b">AGENTS.working_area</code>的城市。</p><h1 id="c021" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">子查询</h1><p id="b0ab" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在SQL中，可以在查询中包含一个查询，也称为子查询。子查询中也可以包含查询。子查询有三种主要形式:</p><ul class=""><li id="0854" class="ni nj it ki b kj kk kn ko kr nk kv nl kz nm ld nn no np nq bi translated">作为<code class="fe mo mp mq mr b">SELECT</code>语句的一部分</li><li id="713d" class="ni nj it ki b kj nr kn ns kr nt kv nu kz nv ld nn no np nq bi translated">在<code class="fe mo mp mq mr b">FROM</code>之后</li><li id="73cd" class="ni nj it ki b kj nr kn ns kr nt kv nu kz nv ld nn no np nq bi translated">在<code class="fe mo mp mq mr b">WHERE</code>之后</li></ul><p id="17e3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">子查询帮助您将复杂的连接和联合分解成更小的部分，使您的查询更具可读性和可维护性，特别是因为您可以使用现有查询的结果。子查询还使调试更容易，因为您可以独立地调试每个查询。理解子查询也有助于您编写递归SQL。</p><h1 id="301a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">带SELECT的子查询</h1><p id="7944" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">查看名为<code class="fe mo mp mq mr b">AGENTS</code>和<code class="fe mo mp mq mr b">ORDERS</code>的表格。您的任务是返回一个包含两列的表。第一列应该包含来自<code class="fe mo mp mq mr b">AGENTS</code>表的<code class="fe mo mp mq mr b">agent_code</code>，第二列应该包含<code class="fe mo mp mq mr b">ORDERS.ord_amount</code>列的总和。第二列应该有相同的值，或者重复多次的总和。</p><p id="6c1c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，返回所有订单金额的总和:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="5384" class="nd lf it mr b gy ne nf l ng nh">SELECT <br/>  SUM(ord_amount) <br/>FROM <br/>  ORDERS</span></pre><p id="69d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的命令将是您的子查询。您可以如下所示使用它来获得所需的结果:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="2d8d" class="nd lf it mr b gy ne nf l ng nh">SELECT <br/>  agent_code, <br/>  (<br/>    SELECT <br/>      SUM(ord_amount) <br/>    FROM <br/>      ORDERS<br/>  ) total <br/>FROM <br/>  AGENTS</span></pre><p id="7140" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二行中的命令是子查询。它返回<code class="fe mo mp mq mr b">ORDERS.ord_amount</code>列的总和。您还可以命名第二列，方法是使用<code class="fe mo mp mq mr b">AS</code>或在子查询后包含您喜欢的名称。下面是部分结果的截图:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/faa179f7f49890d00dad272840f1e674.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OEP8_usLTmhJ3F6C.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">作者截图</p></figure><h1 id="a05d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">带有FROM的子查询</h1><p id="75f5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">以下SQL命令返回一个表，其中包含订单总额、平均订单额以及代理销售给客户的订单数:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="9489" class="nd lf it mr b gy ne nf l ng nh">SELECT <br/>  agent_code, <br/>  cust_code, <br/>  sum(ord_amount) total_amnt, <br/>  avg(ord_amount) avg_amount, <br/>  count(*) AS num <br/>FROM <br/>  ORDERS <br/>GROUP BY <br/>  agent_code, <br/>  cust_code</span></pre><p id="d59b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您必须使用结果来查找每个代理销售的订单总数。您可以将上面的命令和<code class="fe mo mp mq mr b">FROM</code>一起用作子查询:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="c810" class="nd lf it mr b gy ne nf l ng nh">SELECT <br/>  agent_code, <br/>  count(agent_code) AS count <br/>FROM <br/>  (<br/>    SELECT <br/>      agent_code, <br/>      cust_code, <br/>      sum(ord_amount) total_amnt, <br/>      avg(ord_amount) avg_amount, <br/>      count(*) AS num <br/>    FROM <br/>      ORDERS <br/>    GROUP BY <br/>      agent_code, <br/>      cust_code<br/>  ) <br/>GROUP BY <br/>  agent_code</span></pre><p id="f331" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的命令返回每个代理销售给的客户总数。您可以从子查询返回的表中进行选择，而不是从现有表中进行选择。以下是部分结果:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/226450504cce3ff879bc2fe58580ab8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cM9niYChueOoxtQx.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">作者截图</p></figure><h1 id="6f16" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">带有WHEN的子查询</h1><p id="57d1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">现在使用<code class="fe mo mp mq mr b">AGENTS</code>和<code class="fe mo mp mq mr b">CUSTOMER</code>表返回一个只包含代理和客户共享的通用名称的表。</p><p id="e605" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，使用以下命令返回一个包含每个客户姓名的表:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="1abe" class="nd lf it mr b gy ne nf l ng nh">SELECT <br/>  cust_name <br/>FROM <br/>  CUSTOMER</span></pre><p id="80b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在使用<code class="fe mo mp mq mr b">IN</code>操作符和上面查询返回的表来查找常用名称。下面是命令，使用前面的命令作为子查询:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="1600" class="nd lf it mr b gy ne nf l ng nh">SELECT <br/>  agent_name <br/>FROM <br/>  AGENTS <br/>WHERE <br/>  agent_name IN (<br/>    SELECT <br/>      cust_name <br/>    FROM <br/>      CUSTOMER<br/>  )</span></pre><p id="b79a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mo mp mq mr b">WHERE</code>子句检查子查询返回的表中是否存在<code class="fe mo mp mq mr b">AGENTS.agent_name</code>。它将返回一个有两行的表:Benjamin和Charles。</p><h1 id="950d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">公共表表达式(cte)</h1><p id="4149" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在SQL中，创建临时变量来存储子查询的结果。这些变量只能在外部查询中访问。在前面的示例中，您返回了一个包含每个代理销售的订单数量的表，您可以将该结果存储为CTE，以使您的查询更具可读性。</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="82f7" class="nd lf it mr b gy ne nf l ng nh">WITH CTE_AGENT_CUSTOMER AS (<br/>  SELECT <br/>    agent_code, <br/>    cust_code, <br/>    sum(ord_amount) total_amnt, <br/>    avg(ord_amount) avg_amount, <br/>    count(*) AS num <br/>  FROM <br/>    ORDERS <br/>  GROUP BY <br/>    agent_code, <br/>    cust_code<br/>) <br/>SELECT <br/>  agent_code, <br/>  count(agent_code) AS count, <br/>  AVG(total_amnt) AS AVG, <br/>  SUM(total_amnt) AS SUM <br/>FROM <br/>  CTE_AGENT_CUSTOMER <br/>GROUP BY <br/>  agent_code</span></pre><p id="d449" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用递归SQL时需要cte。</p><h1 id="b9d8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">SQL中的递归cte</h1><p id="9e4b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">SQL中的递归类似于任何其他语言中的递归。你把一个更大的问题分成一个更小的问题，继续解决这个更小的问题，直到你达到终止条件。如果您不提供终止条件，它会将您的SQL命令发送到一个无限循环中。</p><p id="3e7c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是两个可以用递归解决的常见问题。</p><h1 id="e474" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">前N个数字</h1><p id="122a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">你的任务是使用递归打印一个从1到20的表格。下面是递归代码:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="3eaa" class="nd lf it mr b gy ne nf l ng nh">WITH NUMBER_CTE AS (<br/>  SELECT <br/>    1 AS num -- Starting Table<br/>  UNION <br/>    -- Combine Starting Table with Table from Below Query<br/>  SELECT <br/>    num + 1 as num -- Update Rule<br/>  FROM <br/>    NUMBER_CTE -- CTE calling itself, ie recursion<br/>  WHERE <br/>    num &lt; 20 -- Terminating Condition<br/>    ) <br/>SELECT <br/>  * <br/>from <br/>  NUMBER_CTE -- Displaying the recursive CTE</span></pre><p id="e9de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">分别考虑<code class="fe mo mp mq mr b">UNION</code>操作符的第一个和第二个查询。</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="ccfe" class="nd lf it mr b gy ne nf l ng nh">SELECT <br/>  1 AS num -- Starting Table</span></pre><p id="cc2a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面是一个简单的查询，返回一个名为<code class="fe mo mp mq mr b">num</code>的列，其中包含值<code class="fe mo mp mq mr b">1</code>。</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="e468" class="nd lf it mr b gy ne nf l ng nh">SELECT <br/>  num + 1 as num -- Update Rule<br/>FROM <br/>  NUMBER_CTE -- CTE calling itself, ie recursion<br/>WHERE <br/>  num &lt; 20 -- Terminating Condition</span></pre><p id="805b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只要原始值小于<code class="fe mo mp mq mr b">20</code>，上面的查询就会将列<code class="fe mo mp mq mr b">num</code>的值递增1。</p><p id="1f40" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第一次运行中，第一个子查询的结果将是:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="c252" class="nd lf it mr b gy ne nf l ng nh">num<br/>------<br/>1<br/>------</span></pre><p id="7c78" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二次查询的结果将是:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="1a5f" class="nd lf it mr b gy ne nf l ng nh">num<br/>------<br/>2<br/>------</span></pre><p id="7828" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mo mp mq mr b">UNION</code>操作符将合并两个表，并将您的CTE更新到下表:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="aacd" class="nd lf it mr b gy ne nf l ng nh">num<br/>------<br/>1<br/>------<br/>2<br/>------</span></pre><p id="6b38" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第二个查询中，由于您从您的CTE中进行选择，这两个查询以及<code class="fe mo mp mq mr b">UNION</code>操作符将被再次执行。第一个查询将再次返回:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="5ab1" class="nd lf it mr b gy ne nf l ng nh">num<br/>------<br/>1<br/>------</span></pre><p id="7de5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个查询将使用上一次运行的CTE，并将每行递增1，返回以下内容:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="de31" class="nd lf it mr b gy ne nf l ng nh">num<br/>------<br/>2<br/>------<br/>3<br/>------</span></pre><p id="84fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mo mp mq mr b">UNION</code>操作符再次组合来自两个查询的表。更新后的CTE将是:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="0e92" class="nd lf it mr b gy ne nf l ng nh">num<br/>------<br/>1<br/>------<br/>2<br/>------<br/>3<br/>------</span></pre><p id="b49b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个过程将一直进行，直到该列包含一个值为<code class="fe mo mp mq mr b">20</code>的行。在这种情况下，不会满足<code class="fe mo mp mq mr b">WHEN</code>条件，您将停止递归过程。</p><h1 id="2597" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">阶乘</h1><p id="fb3a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">现在尝试一个SQL命令，创建一个包含阶乘值的表。试求<code class="fe mo mp mq mr b">5</code>的阶乘。</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="10c2" class="nd lf it mr b gy ne nf l ng nh">WITH FACTORIAL AS (<br/>  SELECT <br/>    5 AS NUM, <br/>    1 AS PRODUCT -- Starting Table<br/>  UNION <br/>    -- Combine Starting Table with Table from Below Query<br/>  SELECT <br/>    NUM - 1 AS NUM, <br/>    PRODUCT * NUM AS PRODUCT -- Update Rule<br/>  FROM <br/>    FACTORIAL -- CTE calling itself, i.e recursion<br/>  WHERE <br/>    NUM &gt; 1 -- Terminating Condition<br/>    ) <br/>SELECT <br/>  * <br/>FROM <br/>  FACTORIAL</span></pre><p id="04ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">初始表应该有两列——一列存储当前乘数，一列存储当前乘积。乘积将是<code class="fe mo mp mq mr b">1</code>，而第一个乘数将是<code class="fe mo mp mq mr b">5</code>。</p><p id="8d00" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个查询的结果将是:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="7036" class="nd lf it mr b gy ne nf l ng nh">num    product</span><span id="22c9" class="nd lf it mr b gy nw nf l ng nh">------ ---------<br/>5        1<br/>------ ---------</span></pre><p id="f346" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个查询的结果将是:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="0634" class="nd lf it mr b gy ne nf l ng nh">num        product<br/>--------   --------------<br/>5-1 = 4     5*1 = 5<br/>--------   --------------</span></pre><p id="afed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">新的CTE将是:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="cb9a" class="nd lf it mr b gy ne nf l ng nh">num    product<br/>------ ---------<br/>5         1<br/>------ ---------<br/>4         5<br/>------ ---------</span></pre><p id="1416" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下一次运行中，第一次查询的结果将是相同的:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="774a" class="nd lf it mr b gy ne nf l ng nh">num    product<br/>------ ---------<br/>5        1<br/>------ ---------</span></pre><p id="1583" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二次查询的结果将根据上次运行的CTE进行计算:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="7471" class="nd lf it mr b gy ne nf l ng nh">num         product<br/>---------   ---------<br/>5 - 1 = 4   1 * 5 = 5<br/>---------   ---------<br/>4 - 1 = 3   5 * 4 = 20<br/>---------   ---------</span></pre><p id="ee9a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mo mp mq mr b">UNION</code>操作符将合并两个表。更新后的CTE将是:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="8ee6" class="nd lf it mr b gy ne nf l ng nh">num     product<br/>------  ---------<br/>5         1<br/>------  ---------<br/>4         5<br/>------  ---------<br/>3        20<br/>------  ---------</span></pre><p id="bd67" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个过程将继续下去，直到你达到终止条件。</p><h1 id="bd7d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">递归cte的一般语法</h1><p id="1328" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">基于上述问题，您可以看到SQL中递归cte的一般语法:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="4780" class="nd lf it mr b gy ne nf l ng nh">WITH CTE AS<br/>(<br/>    -- Starting Table<br/>    UNION -- Combine Starting Table with Table from Below Query<br/>    -- Updated Table with Update conditions if any<br/>    FROM CTE-- CTE calling itself, i.e recursion<br/>    -- Terminating Condition<br/>)</span><span id="8006" class="nd lf it mr b gy nw nf l ng nh">SELECT * FROM CTE</span></pre><p id="80d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">终止条件不一定必须是<code class="fe mo mp mq mr b">WHERE</code>条件；也可以是<code class="fe mo mp mq mr b">JOIN</code>条件。您将在以下情况下查看使用<code class="fe mo mp mq mr b">JOIN</code>的终止条件。</p><h1 id="c230" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">添加示例数据</h1><p id="7b68" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">递归通常用于寻找公司中的层次结构，或者在处理家谱时使用。您需要在数据库中创建一个新表。第一列是代理的代码，第二列是他们经理的代理代码。如果代理没有经理，第二列中的值将是<code class="fe mo mp mq mr b">NULL</code>。下面是您将添加到数据库中的层次结构:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/d9c1e18c830fb97291f1a3bc6603c9b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GY58r72uYO5KSWgN.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">作者截图</p></figure><p id="40ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以找到在这个报告中添加数据<a class="ae kf" href="https://github.com/rahulbanerjee26/CloudQuery-Sql-data/blob/main/hierarchy.sql" rel="noopener ugc nofollow" target="_blank">的脚本。</a></p><h1 id="b5cc" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">任务一</h1><p id="bd97" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">假设您获得了一个代理的ID，并被要求返回一个包含代理的经理、跳过经理、跳过经理等的表。，一路到顶。下面是完成此任务的命令:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="2564" class="nd lf it mr b gy ne nf l ng nh">with HIERARCHY_CTE AS (<br/>  SELECT <br/>    h1.agent_code, <br/>    h1.manager_code <br/>  from <br/>    HIERARCHY h1 <br/>  WHERE <br/>    h1.agent_code == 'A006' <br/>  UNION <br/>  SELECT <br/>    h2.agent_code, <br/>    h2.manager_code <br/>  FROM <br/>    HIERARCHY h2 <br/>    JOIN HIERARCHY_CTE ON h2.AGENT_CODE = HIERARCHY_CTE.manager_code<br/>) <br/>SELECT <br/>  * <br/>FROM <br/>  HIERARCHY_CTE</span></pre><p id="56c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，单独考虑每个查询。</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="7fe3" class="nd lf it mr b gy ne nf l ng nh">SELECT <br/>  h1.agent_code, <br/>  h1.manager_code <br/>FROM <br/>  HIERARCHY h1 <br/>WHERE <br/>  h1.agent_code == 'A006'</span></pre><p id="ca99" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的查询返回代理的代码和他们经理的代理代码。以下是输出:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="5a46" class="nd lf it mr b gy ne nf l ng nh">agent_code   manager_code<br/>---------   ------------<br/>A006         A005</span></pre><p id="8a17" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在看看第二个查询:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="4178" class="nd lf it mr b gy ne nf l ng nh">SELECT <br/>  h2.agent_code, <br/>  h2.manager_code <br/>FROM <br/>  HIERARCHY h2 <br/>  JOIN HIERARCHY_CTE ON h2.AGENT_CODE = HIERARCHY_CTE.manager_code</span></pre><p id="f5be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将在<code class="fe mo mp mq mr b">HIERARCHY</code>表和您创建的CTE之间执行一个<code class="fe mo mp mq mr b">JOIN</code>。它试图找到来自<code class="fe mo mp mq mr b">HIERARCHY</code>的<code class="fe mo mp mq mr b">agent_code</code>与CTE的<code class="fe mo mp mq mr b">manager_code</code>相匹配的行。然后它返回代理的代码和他们经理的代码，或者是<code class="fe mo mp mq mr b">A006</code>的经理和<code class="fe mo mp mq mr b">A006</code>的跳过经理。</p><p id="4e7e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是输出:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="893a" class="nd lf it mr b gy ne nf l ng nh">agent_code  manager_code<br/>---------   ------------<br/>A005        A003</span></pre><p id="5bdf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该联合返回下表:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="a1b4" class="nd lf it mr b gy ne nf l ng nh">agent_code  manager_code<br/>---------   ------------<br/>A006        A005<br/>---------   ------------<br/>A005        A003</span></pre><p id="d6db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第二次运行时，第一个查询将再次返回:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="8b76" class="nd lf it mr b gy ne nf l ng nh">agent_code   manager_code<br/>---------    ------------<br/>A006           A005</span></pre><p id="957c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，第二个查询也将包括<code class="fe mo mp mq mr b">A003</code>的经理。以下是输出:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="2906" class="nd lf it mr b gy ne nf l ng nh">agent_code manager_code<br/>--------- ------------<br/>A005        A003<br/>--------- ------------<br/>A003        A001</span></pre><p id="f6f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mo mp mq mr b">UNION</code>运算符组合这些表。您更新后的CTE将是:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="249e" class="nd lf it mr b gy ne nf l ng nh">agent_code    manager_code<br/>---------    ------------<br/>A006           A005<br/>---------    ------------<br/>A005           A003<br/>---------    ------------<br/>A003           A001</span></pre><p id="5112" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mo mp mq mr b">A001</code>没有经理。在下一次运行中，您将遇到终止条件。</p><h1 id="4eab" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">任务二</h1><p id="a256" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在此任务中，您将为每个代理分配一个级别。没有老板的代理是一级，向他们汇报的代理是二级，以此类推。下面是返回该表的命令:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="7b3d" class="nd lf it mr b gy ne nf l ng nh">with HIERARCHY_CTE AS (<br/>  SELECT <br/>    h1.agent_code, <br/>    h1.manager_code, <br/>    1 AS level <br/>  from <br/>    HIERARCHY h1 <br/>  WHERE <br/>    h1.manager_code IS NULL <br/>  UNION <br/>  SELECT <br/>    h2.agent_code, <br/>    h2.manager_code, <br/>    level + 1 AS level <br/>  from <br/>    HIERARCHY h2 <br/>    JOIN HIERARCHY_CTE on h2.manager_code == HIERARCHY_CTE.agent_code<br/>) <br/>SELECT <br/>  * <br/>FROM <br/>  HIERARCHY_CTE</span></pre><p id="d5b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这类似于上一个任务中的命令。最主要的区别是，你是从顶层代理开始，而不是底层。</p><h1 id="e653" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">累计总数</h1><p id="3e91" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">累计也称为累积和。考虑数据库中的<code class="fe mo mp mq mr b">ORDERS</code>表。它有称为<code class="fe mo mp mq mr b">ord_amount</code>和<code class="fe mo mp mq mr b">ord_date</code>的列。尝试计算<code class="fe mo mp mq mr b">ord_date</code>列中每个日期记录的累计和。下面是命令:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="09c8" class="nd lf it mr b gy ne nf l ng nh">SELECT <br/>  ord_date, <br/>  SUM(ord_amount) OVER (<br/>    ORDER BY <br/>      ord_date<br/>  ) AS Running_Total <br/>FROM <br/>  ORDERS</span></pre><p id="de56" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mo mp mq mr b">OVER</code>命令告诉SQL，您想要查找整个数据集上<code class="fe mo mp mq mr b">ord_amount</code>列的累积和。<code class="fe mo mp mq mr b">ORDER BY</code>子句中的列用于按日期对结果进行排序。</p><h1 id="2ec0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">CASE WHEN语句</h1><p id="9553" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mo mp mq mr b">CASE WHEN</code>SQL中的语句类似于其他语言中的if-else或switch-case语句。以下是<code class="fe mo mp mq mr b">CASE WHEN</code>语句的一般语法:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="d730" class="nd lf it mr b gy ne nf l ng nh">CASE<br/>WHEN CONDITION THEN RESULT<br/>WHEN CONDITION THEN RESULT<br/>WHEN CONDITION THEN RESULT<br/>ELSE RESULT<br/>END Column_Name</span></pre><p id="b12b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果没有一个条件返回true，则返回<code class="fe mo mp mq mr b">ELSE</code>中的结果。</p><p id="752c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mo mp mq mr b">CUSTOMER</code>表有一个名为<code class="fe mo mp mq mr b">grade</code>的列，包含来自<code class="fe mo mp mq mr b">0-4</code>的值。您的任务是创建一个名为<code class="fe mo mp mq mr b">grade_letter</code>的新列，它将<code class="fe mo mp mq mr b">1</code>映射到<code class="fe mo mp mq mr b">A</code>，将<code class="fe mo mp mq mr b">2</code>映射到<code class="fe mo mp mq mr b">B</code>，并将所有其他内容映射到<code class="fe mo mp mq mr b">F</code>。您可以使用<code class="fe mo mp mq mr b">CASE WHEN</code>语句来完成这项任务。下面是命令:</p><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="91ad" class="nd lf it mr b gy ne nf l ng nh">SELECT <br/>  *, <br/>  CASE WHEN grade == 1 THEN 'A' WHEN grade == 2 THEN 'B' ELSE 'F' END grade_letter <br/>FROM <br/>  CUSTOMER</span></pre><h1 id="8248" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="b74c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">本指南为您提供了一些使用更高级SQL主题的实践经验。实现这些工具将帮助您从数据中获得更多的洞察力，以便您可以用SQL编写更好的查询。</p><p id="2b1d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您正在使用SQL，您可能会对<a class="ae kf" href="https://www.cloudquery.io/" rel="noopener ugc nofollow" target="_blank"> CloudQuery </a>感兴趣。基于SQL的开源云资产清单集成了主要的云提供商，包括Azure、AWS和GCP。您可以使用它从当前和历史的角度审计和评估您的云资产。</p><p id="a2cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于CloudQuery能为你做什么的更多信息，<a class="ae kf" href="https://docs.cloudquery.io/docs/intro" rel="noopener ugc nofollow" target="_blank">查看它的文档</a>。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><pre class="mi mj mk ml gt mz mr na nb aw nc bi"><span id="0f18" class="nd lf it mr b gy ne nf l ng nh">This article was originally posted on <br/>https://www.realpythonproject.com/advanced-sql-going-beyond-the-basics/</span><span id="479b" class="nd lf it mr b gy nw nf l ng nh">Connect with me on LinkedIn: <br/>https://www.linkedin.com/in/rahulbanerj</span></pre></div></div>    
</body>
</html>