<html>
<head>
<title>rounder: Rounding Numbers in Complex Python Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">舍入器:对复杂Python对象中的数字进行舍入</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/rounder-rounding-numbers-in-complex-python-objects-e4b6f3b563f8#2022-10-31">https://towardsdatascience.com/rounder-rounding-numbers-in-complex-python-objects-e4b6f3b563f8#2022-10-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f54e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">rounder包使您能够对任何对象中的所有数字进行舍入，只需一个命令</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dac1239c194211ee8da4a5be2cf38ba8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ws4sOHAaIMJkwz66"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">rounder:在Python中舍入数字从未如此简单。照片由<a class="ae ky" href="https://unsplash.com/@mbaumi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米卡·鲍梅斯特</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="8fc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">舍入数字很少引起问题。在标准库中，我们有函数<code class="fe lv lw lx ly b">round()</code>、<code class="fe lv lw lx ly b">math.ceil()</code>和<code class="fe lv lw lx ly b">math.floor()</code>，通过它们我们可以使用三种标准类型的舍入。这应该够了，不是吗？</p><p id="3b95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，并不总是这样。假设您有以下对象，您希望将其舍入到两位十进制数字:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="9cb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mb">注意</em>:在本例中，对象及其特定字段的含义并不重要。它只是一个可能的复杂嵌套对象的表示。然而，为了简单起见，我没有把它弄得太复杂。然而，当使用它时，想象一个复杂的嵌套字典，它的字段是其他嵌套字典、列表和其他类型的对象。</p><p id="0ae4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会怎么做？你如何处理这样一个对象中的所有数字？您可能认为这相对容易，因为只需编写一个专用函数来处理这种特定类型的嵌套对象就足够了。这是可行的，但是如果对象发生了一点点变化呢？你必须更新这个函数，以使它反映对象的新结构。或者，您可以编写一个递归函数来实现这一点，但是该函数不必那么容易编写，因为它需要处理Python提供的如此多的不同类型。</p><p id="df7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，从<code class="fe lv lw lx ly b">round(1.122, 1)</code>的简单性，我们转移到一个硬编码舍入一个特定类型和结构的对象的函数，或者转移到一个相当困难的递归函数。这不再简单…</p><p id="c363" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是唯一的方法吗？没有更简单的方法吗？Python不是承诺简单吗？</p><h1 id="74ab" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">简单的方法:<code class="fe lv lw lx ly b">rounder</code></h1><p id="95c7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">幸运的是，有一个简单的方法:T5包。它提供了一些函数，允许对许多不同类型的复杂和嵌套对象中的数字进行舍入。</p><p id="dbe9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回到我们的例子。我们希望将来自<code class="fe lv lw lx ly b">obj</code>对象的数字四舍五入为两位十进制数字。这就是你如何使用<code class="fe lv lw lx ly b">rounder</code>来做这件事:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="25a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不是很简单吗？</p><p id="b4f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，假设您已经决定将<code class="fe lv lw lx ly b">obj</code>中的数字四舍五入到五位有效数字。Python没有为此提供内置函数，但是<code class="fe lv lw lx ly b">rounder</code>提供了。您可以使用<code class="fe lv lw lx ly b">rounder.signif()</code>表示数字，使用<code class="fe lv lw lx ly b">rounder.signif_object()</code>表示嵌套对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="316b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mb">注意</em> : <code class="fe lv lw lx ly b">obj</code>是一个可变对象，因为我们之前对它进行了舍入，所以它发生了变化。因此，要再次使用它的原始版本，您需要重新创建它，就像我们在上面创建它一样。</p><p id="0f71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同理，也可以使用<code class="fe lv lw lx ly b">rounder.ceil_object()</code>和<code class="fe lv lw lx ly b">rounder.floor_object()</code>，分别对应<code class="fe lv lw lx ly b">math.ceil()</code>和<code class="fe lv lw lx ly b">math.floor()</code>功能。</p><h1 id="1bbe" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">更多关于<code class="fe lv lw lx ly b">rounder</code></h1><h2 id="58ba" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">可变对象与不可变对象</h2><p id="d929" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们必须记住，不像不可变的对象，可变的对象在适当的位置被改变<em class="mb"/>。这意味着当您使用或不使用新名称对其进行更新时，原始对象将被更改。同样的，如果你改变它的(浅层)拷贝，原始对象也会被更新。</p><p id="998e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样的规则也适用于<code class="fe lv lw lx ly b">rounder</code>操作。记住这不是典型的<code class="fe lv lw lx ly b">rounder</code>而是Python。换句话说，<code class="fe lv lw lx ly b">rounder</code>实现了Python处理可变和不可变对象的典型方式。</p><p id="cc40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rounder</code>然而，函数使得处理可变对象更加简单。为了简单起见，这次我们将使用更简单、更小的对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="7323" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们确实预料到了这一点，但是由于列表是可变的，<code class="fe lv lw lx ly b">x</code>也被改变了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="1ebc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不希望这种情况发生，<code class="fe lv lw lx ly b">rounder</code>可以帮助你。可以使用参数<code class="fe lv lw lx ly b">use_copy</code>，默认为<code class="fe lv lw lx ly b">False</code>；这就是为什么默认情况下，<code class="fe lv lw lx ly b">rounder</code>会改变原来的对象。这是Python的默认行为:如果你想创建一个对象的副本，你必须手动完成。</p><p id="8608" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mb">注</em>:提浅抄和深抄的好地方。你可以在<a class="ae ky" href="https://docs.python.org/3/library/copy.html" rel="noopener ugc nofollow" target="_blank">标准库</a> <code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.python.org/3/library/copy.html" rel="noopener ugc nofollow" target="_blank">copy</a></code> <a class="ae ky" href="https://docs.python.org/3/library/copy.html" rel="noopener ugc nofollow" target="_blank">模块</a>或者<a class="ae ky" href="https://realpython.com/copying-python-objects/" rel="noopener ugc nofollow" target="_blank">这里</a>阅读这个主题。如果你需要或想要加深或更新你的知识，你可以休息一下，现在就做。</p><p id="7495" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是<code class="fe lv lw lx ly b">use_copy</code>如何改变<code class="fe lv lw lx ly b">rounder</code>函数的行为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="d007" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以使用<code class="fe lv lw lx ly b">use_copy</code>的其他<code class="fe lv lw lx ly b">rounder</code>功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="4fe1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于四舍五入到有效数字，记住这个操作也影响整数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h2 id="d1fc" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">自定义舍入</h2><p id="e6d0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe lv lw lx ly b">rounder</code>包还提供了一个通用函数<code class="fe lv lw lx ly b">rounder.map_object()</code>，它使您能够应用任何接受一个数字并返回一个数字的可调用函数(所以，<code class="fe lv lw lx ly b">Callable[numbers.Number, numbers.Number]</code>)。您可以使用它来应用自定义舍入。</p><p id="e870" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设您想要对一个浮点数应用以下舍入，比如说<code class="fe lv lw lx ly b">x</code>:</p><ul class=""><li id="ca48" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">如果<code class="fe lv lw lx ly b">x</code>是一个整数，原封不动地返回</li><li id="6eeb" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><code class="fe lv lw lx ly b">abs(x) &gt; 100</code>时四舍五入为整数</li><li id="4980" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><code class="fe lv lw lx ly b">100 &gt; abs(x) &gt; 10</code>时四舍五入到1位小数</li><li id="ebf1" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><code class="fe lv lw lx ly b">10 &gt; abs(x) &gt; 1</code>时四舍五入到2位小数</li><li id="e1a0" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">否则，四舍五入到3位小数</li></ul><p id="b931" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，当您用不同单位或不同比例的数字对对象进行舍入时，可以使用这种舍入方法。下面的函数可以做到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="d066" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数的名字<code class="fe lv lw lx ly b">round_float</code>意味着它将只对浮点进行舍入。它可以被命名为<code class="fe lv lw lx ly b">round_only_floats</code>，但是这个名字不能完全代表它的功能；这是因为它不舍入非数字。所以，我把它命名为<code class="fe lv lw lx ly b">round_float</code>，以区别于<code class="fe lv lw lx ly b">round</code>。</p><p id="e586" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看实际情况:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="c86f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们对上面使用的<code class="fe lv lw lx ly b">obj</code>对象使用这个函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="43ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，该函数的签名类似于<a class="ae ky" rel="noopener" target="_blank" href="/does-python-still-need-the-map-function-96787ea1fb05"/><code class="fe lv lw lx ly b"><a class="ae ky" rel="noopener" target="_blank" href="/does-python-still-need-the-map-function-96787ea1fb05">map()</a></code><a class="ae ky" rel="noopener" target="_blank" href="/does-python-still-need-the-map-function-96787ea1fb05">函数</a>的签名，第一个参数是一个可调用的，用于作为第二个参数提供的对象。这可以帮助你记住如何使用<code class="fe lv lw lx ly b">rounder.map_object()</code>。</p><p id="8105" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，你可以使用这个函数将<em class="mb">任何</em>可调用的<code class="fe lv lw lx ly b">Callable[numbers.Number, numbers.Number]</code>应用于对象中的所有数字，甚至是那些与舍入无关的数字。考虑这个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h2 id="58b9" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">类型</h2><p id="544b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">值得一提的是，<code class="fe lv lw lx ly b">rounder</code>的函数支持许多不同的类型，比如所有内置的容器类型(如<code class="fe lv lw lx ly b">dict</code>、<code class="fe lv lw lx ly b">list</code>、<code class="fe lv lw lx ly b">tuple</code>和<code class="fe lv lw lx ly b">set</code>)，还有生成器、<code class="fe lv lw lx ly b">map</code>和<code class="fe lv lw lx ly b">filter</code>对象、队列、命名元组、<code class="fe lv lw lx ly b">array.array</code>等等。你会在<a class="ae ky" href="https://github.com/nyggus/rounder#types-that-rounder-works-with" rel="noopener ugc nofollow" target="_blank">包的仓库</a>中找到他们的列表。注意，当您将一个<code class="fe lv lw lx ly b">generator</code>类型输入到一个<code class="fe lv lw lx ly b">rounder</code>函数中时，您也会收到一个生成器。</p><h2 id="c2e7" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">异常处理</h2><p id="8faf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">典型的舍入函数在用于非数字时会抛出<code class="fe lv lw lx ly b">TypeError</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="51d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rounder.signif()</code>功能的运行方式类似:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="207b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">名称以<code class="fe lv lw lx ly b">_object</code>结尾的<code class="fe lv lw lx ly b">rounder</code>函数则不然:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="3837" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些函数的行为是这样的，因为当对象是对象的容器时，函数递归地在它们上面运行，舍入(如果不是数字，则不舍入)对象的每个最低级别的元素。</p><h2 id="8ef9" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">履行</h2><p id="f63a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">高级开发人员可能会欣赏<code class="fe lv lw lx ly b">rounder</code>的开发方式。这一想法来自该计划的合著者路德·范·德·哈姆。这个包的本质是使用闭包实现的，这是一种优雅的方法——比包的第一个版本(未发布)中使用的最初的基于类的方法优雅得多。</p><p id="70ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以从<a class="ae ky" href="https://github.com/nyggus/rounder/" rel="noopener ugc nofollow" target="_blank">包库</a>中，特别是从它的<a class="ae ky" href="https://github.com/nyggus/rounder/blob/main/rounder/rounder.py" rel="noopener ugc nofollow" target="_blank">主模块</a> <code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/nyggus/rounder/blob/main/rounder/rounder.py" rel="noopener ugc nofollow" target="_blank">rounder</a></code>中，了解更多关于包的实现。</p><h1 id="90f8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="9f86" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe lv lw lx ly b">rounder</code>封装使舍入变得容易。有了它，您可以使用最常见的舍入方法:</p><ul class=""><li id="085e" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">将一个数字四舍五入到特定的小数位数(<code class="fe lv lw lx ly b">round_object()</code>)；</li><li id="13b5" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">将一个数字向下(<code class="fe lv lw lx ly b">floor_object()</code>)或向上(<code class="fe lv lw lx ly b">ceil_object()</code>)舍入到最接近的整数；</li><li id="2147" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">将数字舍入到特定的有效数字(<code class="fe lv lw lx ly b">signif()</code>和<code class="fe lv lw lx ly b">signif_object()</code>)；</li></ul><p id="7fed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且是一种定制的舍入方法，这要归功于</p><ul class=""><li id="e242" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">使用自定义函数(<code class="fe lv lw lx ly b">map_object()</code>)对数字进行舍入。</li></ul><p id="5637" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但这并不是<code class="fe lv lw lx ly b">rounder</code>如此有用的原因。它非常有用，因为您可以对任何复杂和/或嵌套的对象类型使用名称以<code class="fe lv lw lx ly b">_object</code>结尾的<code class="fe lv lw lx ly b">rounder</code>函数，该函数将对对象中的所有数字进行舍入。</p><p id="7ab4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个包还简化了可变对象的操作。通常，当您想要创建一个可变对象的副本时，您需要调用<code class="fe lv lw lx ly b">copy.deepcopy()</code>，这将创建该对象的深层副本。有了rounder，你就不必这样做了；使用<code class="fe lv lw lx ly b">use_copy=True</code>参数就够了，函数会帮你做。</p><p id="9bd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，每当你需要在比一个数字更复杂的对象中舍入数字时(比如一个遵循<code class="fe lv lw lx ly b">numbers.Number</code>抽象基类的对象)，你会发现<code class="fe lv lw lx ly b">rounder</code>特别有用。它的功能也适用于常规数字。随着<code class="fe lv lw lx ly b">rounder</code>包的出现，我们想要舍入所有数字的对象的复杂性不再是问题。</p><h1 id="246a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">资源</h1><div class="nz oa gp gr ob oc"><a href="https://github.com/nyggus/rounder" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">GitHub - nyggus/rounder:在复杂的Python中舍入浮点数和复数的Python包…</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">rounder是一个轻量级的包，用于在复杂的Python对象中舍入数字，例如字典、列表、元组…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">github.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq ks oc"/></div></div></a></div><div class="nz oa gp gr ob oc"><a href="https://docs.python.org/3/library/copy.html" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">复制-浅层和深层复制操作- Python 3.11.0文档</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">Python中的赋值语句不复制对象，它们在目标和对象之间创建绑定。对于…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">docs.python.org</p></div></div></div></a></div><div class="nz oa gp gr ob oc"><a href="https://realpython.com/copying-python-objects/" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">Python对象的浅层与深层复制——真正的Python</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">注意:本教程是在考虑Python 3的情况下编写的，但是Python 2和Python 3之间的区别很小，当它…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">realpython.com</p></div></div><div class="ol l"><div class="or l on oo op ol oq ks oc"/></div></div></a></div><div class="nz oa gp gr ob oc"><a rel="noopener follow" target="_blank" href="/does-python-still-need-the-map-function-96787ea1fb05"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">Python还需要map()函数吗？</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">有了各种备选方案，Python的map()似乎就显得多余了。那么，Python到底需不需要呢？</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">towardsdatascience.com</p></div></div><div class="ol l"><div class="os l on oo op ol oq ks oc"/></div></div></a></div></div></div>    
</body>
</html>