<html>
<head>
<title>4 Sampling Techniques for Efficient Stream Processing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">4高效流处理的采样技术</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/reservoir-sampling-for-efficient-stream-processing-97f47f85c11b#2022-02-28">https://towardsdatascience.com/reservoir-sampling-for-efficient-stream-processing-97f47f85c11b#2022-02-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="97cf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">了解如何使用不同的随机采样技术采集数据流。</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/23b4f18ab35ad0a4d5710ca716a59b09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q1hBCBolX-A28csCeRzDwQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@jogaway?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">乔纳森·格林纳韦</a>在<a class="ae ky" href="https://unsplash.com/s/photos/dice?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e564" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">物联网设备会产生持续的测量和日志数据流，难以进行及时分析。尤其是在嵌入式系统或边缘设备中，内存和CPU能力对于这种流的即时分析来说太有限了。即使是强大的系统也(迟早)会在观察到达数据的完整历史方面存在问题。</p><p id="61be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">油藏取样</strong>的基本思想是<strong class="lb iu">保持一个有代表性的有限空间油藏</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl lv"><img src="../Images/5d88f67b8d0ed31c998665a2ded68e1d.png" data-original-src="https://miro.medium.com/v2/0*tX-L3DL7wrqQQaeY"/></div></figure><p id="c9d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过对溪流取样。分析(例如，发现异常值，进行统计，如均值、方差、统计测试等。)在储层<em class="lw"> R </em>上执行，无需观察所有数据点。续集中总结了一些维护<em class="lw"> R </em>的策略。</p><p id="373e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lw">代表</em>的含义显然取决于应用。如果您对过去一小时的平均温度感兴趣，一个简单的滑动窗口可能会很好。如果您需要更长的历史记录来比较当前系统状态，则(有偏差的)油藏取样可能更好。</p><p id="0ce0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们假设数据点流<em class="lw"> x(t) </em>在时间<em class="lw"> t=1，2，…到达。</em></p><p id="b873" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据应用的不同，<em class="lw"> t </em>可能是不规则事件的逻辑时间，也可能是固定采样率下的样本索引。</p><h2 id="012b" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">1.推拉窗</h2><p id="dd3a" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">这是最简单直接的方法。保持大小为<em class="lw"> n </em>和跳跃/子采样因子<em class="lw"> k ≥1 </em>的先进先出(FIFO)队列。除此之外，步长因子s ≥ 1描述了在分析之前窗口移动了多少时间步长。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl lv"><img src="../Images/e8e5aac4e6c8f0e0345ae634038afbf6.png" data-original-src="https://miro.medium.com/v2/format:webp/1*GdIFl_ZxuSbA8hdEi0u1JA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">滑动窗口(图片由作者提供)。</p></figure><p id="0318" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">优势</strong></p><ul class=""><li id="ed35" class="mv mw it lb b lc ld lf lg li mx lm my lq mz lu na nb nc nd bi translated">易于实施</li><li id="19ea" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">确定性—储层可以从一开始就非常快地充满</li></ul><p id="3cad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">弊端</strong></p><ul class=""><li id="bd1e" class="mv mw it lb b lc ld lf lg li mx lm my lq mz lu na nb nc nd bi translated">油藏<em class="lw"> R </em>代表的时间历程较短；长期的概念漂移不容易被发现——异常值会产生嘈杂的分析</li></ul><h2 id="8428" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">2.无偏油藏取样</h2><p id="80ea" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">保持一个容器<em class="lw"> R </em>，使得在时间<em class="lw"> t &gt; n </em>时，容器中接受点<em class="lw"> x(t) </em>的概率等于<em class="lw"> n/t </em>。</p><p id="b966" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">算法[1]如下:</p><ul class=""><li id="cc4d" class="mv mw it lb b lc ld lf lg li mx lm my lq mz lu na nb nc nd bi translated">用水流的第一个<em class="lw"> n个</em>点填充储槽<em class="lw"> R </em>。</li><li id="5e65" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">在时间<em class="lw"> t &gt; n </em>用接受概率<em class="lw"> n/t </em>替换储库中随机选择的(等概率)条目<em class="lw"> R </em>。</li></ul><p id="84db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这导致了一个库<em class="lw"> R(t) </em>使得每个点<em class="lw"> x(1)…x(t) </em>包含在具有相等属性<em class="lw"> n/t </em>的<em class="lw"> R(t) </em>中。</p><p id="5f38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">优点</strong></p><ul class=""><li id="da6a" class="mv mw it lb b lc ld lf lg li mx lm my lq mz lu na nb nc nd bi translated">水库以相等的概率包含来自河流所有历史的数据点。</li><li id="ba4a" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">实现非常简单；添加一个点只需要O(1)</li></ul><p id="d88e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">弊端</strong></p><ul class=""><li id="8890" class="mv mw it lb b lc ld lf lg li mx lm my lq mz lu na nb nc nd bi translated">一个观念的漂移是无法弥补的；在这种采样技术中，最老的数据点x(1)与最新的数据点x(t)同等重要。</li></ul><h2 id="e2bd" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">3.有偏油藏取样</h2><p id="f39a" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">有偏油藏采样算法。3.1，[2]数据点x(t)在储层中的概率是其在R内停留时间的减函数。因此，在R中找到较早历史点的概率很高。非常老的数据点将以非常低的概率出现在R中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl lv"><img src="../Images/297065a7a9b4738c4ffec57494a78dd9.png" data-original-src="https://miro.medium.com/v2/format:webp/1*7A4ERfxNieNS6H3YY8inpQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">有偏差的油藏取样图解(图片由作者提供)</p></figure><p id="5075" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点x(r)包含在R(t)中的概率等于</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl lv"><img src="../Images/1a294890bdde912b3bc09fc825a8f87d.png" data-original-src="https://miro.medium.com/v2/0*UXYTjor2OC5CDooz"/></div></figure><p id="c7f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以这是一个指数遗忘。有关算法的详细信息，请参见[2]和<a class="ae ky" href="https://github.com/andremueller/goreservoir" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> goreservoir </strong> </a>包。</p><p id="5176" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl nm b">github.com\andremueller\goservoir</code>包中的例子显示了一组无偏油藏取样器的滞留时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl lv"><img src="../Images/c8d5d7d6e55565e6aa12399628101c70.png" data-original-src="https://miro.medium.com/v2/format:webp/1*IPLo0GwkRQw6v1G6Rt_GjA.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">油藏取样链输出(图片由作者提供)</p></figure><p id="c3ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">优点:</strong></p><ul class=""><li id="7548" class="mv mw it lb b lc ld lf lg li mx lm my lq mz lu na nb nc nd bi translated">添加新数据点的O(1)算法。</li><li id="0124" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">缓慢移动的概念漂移可以得到补偿。</li><li id="3ceb" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">可调遗忘因子可以针对感兴趣的应用进行调整。</li></ul><p id="4af4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">弊端:</strong></p><ul class=""><li id="d0c3" class="mv mw it lb b lc ld lf lg li mx lm my lq mz lu na nb nc nd bi translated">这是一种随机技术。所以算法是非确定性的。然而，可以通过运行独立储层的集合来估计方差[3]</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl lv"><img src="../Images/de14e483629125a6ad9603d9347af353.png" data-original-src="https://miro.medium.com/v2/0*rzrabltAkICcbzfx"/></div></figure><h2 id="206b" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">4.直方图</h2><p id="1034" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">在观察数据流的同时维护直方图。至此，数据点被分类到区间/桶中</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl lv"><img src="../Images/9d8c0b2c8d279386eb2743513399a388.png" data-original-src="https://miro.medium.com/v2/0*VxHEcBMD8VsvCTKr"/></div></figure><p id="7107" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果预先知道观察值的有用范围，一个简单的带有计数和断点的向量就可以完成这项工作。</p><p id="6a30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">v-最优直方图试图最小化每个直方图桶内的方差。[4]提出了一种算法，用于有效地维护来自数据流的近似V-最优直方图。这与区间数据相关，例如温度值的时间序列；即绝对值和数值之间的距离有意义。</p><h2 id="0cd1" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">履行</h2><p id="8ba4" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">我将方法1和3实现为Go [5]库。参见<a class="ae ky" href="https://github.com/andremueller/goreservoir" rel="noopener ugc nofollow" target="_blank">https://github.com/andremueller/goreservoir</a></p><p id="8482" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用库调用</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="2b8b" class="lx ly it nm b gy nr ns l nt nu">go get github.com/andremueller/goreservoir`</span></pre><p id="ac71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一个清晰的界面来使用和实现新的采样器。<code class="fe nj nk nl nm b">Add</code>功能将多个样本放入容器，并返回丢弃的样本。</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="b1b9" class="lx ly it nm b gy nr ns l nt nu">// Sample is a single sample data point. As Go currently has no generics the common<br/>// pointer to all types interface{} was used.<br/>type Sample interface{}<br/><br/>type Sampler interface {<br/>    // Add adds one or multiple samples to the Sampler.<br/>    // Returns a set of dropped samples in this step.<br/>    Add(samples []Sample) []Sample<br/><br/>    // Data returns a slice of the current samples within the Sampler.<br/>    Data() []Sample<br/><br/>    // Reset resets the state of the sampler<br/>    Reset()<br/>}</span></pre><p id="b898" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下算法在<strong class="lb iu"> goreservoir </strong>库中实现:</p><ul class=""><li id="aba1" class="mv mw it lb b lc ld lf lg li mx lm my lq mz lu na nb nc nd bi translated"><code class="fe nj nk nl nm b">Sliding</code>实现了一个<strong class="lb iu">滑动窗口</strong>&lt;github.com/andremueller/goreservoir/pkg/window&gt;。</li><li id="fca7" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated"><code class="fe nj nk nl nm b">DynamicSampler</code>实现了Alg。[1]之3.1-<strong class="lb iu">有偏油藏取样</strong>&lt;github.com/andremueller/goreservoir/pkg/reservoir&gt;。</li><li id="a023" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated"><code class="fe nj nk nl nm b">EnsembleSampler</code>将相同的数据点分配给多个采样器——因此您可以进行某种引导/集合处理。</li><li id="191f" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated"><code class="fe nj nk nl nm b">ChainSampler</code>可用于将一个采样器的输出(丢弃点)堆叠到下一个采样器中。</li></ul><p id="5c44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://github.com/andremueller/goreservoir/blob/master/cmd/reservoir/main.go" rel="noopener ugc nofollow" target="_blank">github.com/andremueller/goreservoir/cmd/reservoir/main.go</a>中可以找到与<code class="fe nj nk nl nm b">DynamicSampler</code>一起使用的<code class="fe nj nk nl nm b">ChainSampler</code>的简单示例。该示例的输出是一个数据点在油藏中停留的时间(单位为步)。</p><p id="b0f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[1] J. S. Vitter，“储层随机取样”，<em class="lw">美国计算机学会会刊。数学。Softw。</em>，第11卷，第1号，第37–57页，1985年3月，doi: <a class="ae ky" href="https://doi.org/10.1145/3147.3165" rel="noopener ugc nofollow" target="_blank"> 10.1145/3147.3165 </a>。</p><p id="577a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2] C. C. Aggarwal，“河流演变中的有偏油藏取样”，载于第32届超大型数据库国际会议会议记录<em class="lw">，2006年，第607-618页。</em></p><p id="9d44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[3] B .埃夫龙和R. J .蒂布拉尼，<a class="ae ky" href="https://books.google.com?id=gLlpIUxRntoC" rel="noopener ugc nofollow" target="_blank"> <em class="lw">自举简介</em> </a>。CRC出版社，1994年。</p><p id="c28c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[4] S. Guha、N. Koudas和K. Shim，“数据流和直方图”，载于第33届ACM计算理论年度研讨会的会议记录——STOC，2001年，第471-475页，doi:<a class="ae ky" href="https://doi.org/10.1145/380752.380841" rel="noopener ugc nofollow" target="_blank">10.1145/380752.380841</a>。</p><p id="0f91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[5]“Go编程语言。”https://go.dev/(2021年12月27日访问)。</p></div></div>    
</body>
</html>