<html>
<head>
<title>Prime Time for Julia and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">朱莉娅和Python的黄金时间</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/prime-time-for-julia-and-python-96da5963d995#2022-04-26">https://towardsdatascience.com/prime-time-for-julia-and-python-96da5963d995#2022-04-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="733a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过生成素数和计算素数的倒数来比较Julia和Python的性能</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/14a174b7d5a733433abe90695c8a2f17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OzCuyNC25q7K-kJto6AlpQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@aronvisuals?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">阿伦视觉</a>在<a class="ae kv" href="https://unsplash.com/s/photos/prime-time?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="bda9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi ls translated">基于我在Python中遇到的一个非常聪明的素数生成器，我为Python和Julia设置了一些性能基准。不仅用于生成素数，还用于计算素数的<a class="ae kv" href="https://www.youtube.com/watch?v=DmfxIhmGPP4" rel="noopener ugc nofollow" target="_blank">倒数。而且结果挺有意思的…</a></p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="9dc3" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">质数</h1><p id="d5b3" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">这是我开始写的Python代码。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="b57d" class="nk mj iq ng b gy nl nm l nn no">def python_primes(n):<br/>    D = {}<br/>    q = 2<br/>    r = []<br/>    counter = 0</span><span id="a43f" class="nk mj iq ng b gy np nm l nn no">    while counter &lt; n:<br/>        if q not in D:<br/>            r.append(q)<br/>            D[q * q] = [q]<br/>            counter += 1<br/>        else:<br/>            for p in D[q]:<br/>                D.setdefault(p + q, []).append(p)<br/>            del D[q]<br/>        q += 1</span><span id="b666" class="nk mj iq ng b gy np nm l nn no">    return r</span></pre><p id="4b7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，运行<code class="fe nq nr ns ng b">python_primes(10)</code>返回前10个素数的列表。</p><p id="ea98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于Julia，我做了两个函数:一个没有类型声明，一个有类型声明。</p><p id="638e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是带有类型声明的。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="aad8" class="nk mj iq ng b gy nl nm l nn no"># Julia with Type Declaration</span><span id="cdf0" class="nk mj iq ng b gy np nm l nn no">function jlPrimesTypes(n::Int64)::Vector{Int64}<br/>    D = Dict{Int64, Vector{Int64}}()<br/>    P = Vector{Int64}()<br/>    q = 2<br/>    counter = 0</span><span id="9d0f" class="nk mj iq ng b gy np nm l nn no">    while counter &lt; n<br/>        if !(q in keys(D))<br/>            D[q * q] = Int64[q] # Vector{Int64}([q])<br/>            push!(P, q)<br/>            counter += 1<br/>        else<br/>            for p in D[q]<br/>                get!(D, p + q, Int64[]) # Vector{Int64}()<br/>                push!(D[p + q], p)<br/>            end<br/>            delete!(D, q)<br/>        end<br/>        q += 1<br/>    end<br/>    <br/>    return P</span><span id="c861" class="nk mj iq ng b gy np nm l nn no">end</span></pre><p id="72cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">MacBook Air 2020 (M1处理器，8Gb，256GB固态硬盘)用于进行性能基准测试。所有代码都是使用Visual Studio代码在Jupyter笔记本上运行的。</p><p id="98b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python代码是使用Julia包<code class="fe nq nr ns ng b">PyCall</code>调用的，基准测试使用了Julia包<code class="fe nq nr ns ng b">BenchmarkTools</code>。在所有基准测试中，产生了1，000，000个素数。</p><p id="d151" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://www.julialang.org/downloads/" rel="noopener ugc nofollow" target="_blank"> Julia </a> 1.7.2 (MacOS ARM)和Python 3 . 9 . 12(<a class="ae kv" href="https://github.com/conda-forge/miniforge" rel="noopener ugc nofollow" target="_blank">MiniConda</a>ARM 64/Apple Silicon)用于运行基准测试。</p><p id="20ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整的<a class="ae kv" href="https://nbviewer.org/github/Brinkhuis/PrimeTime/blob/main/primes.ipynb" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本</a>可以在<a class="ae kv" href="https://github.com/Brinkhuis/PrimeTime" rel="noopener ugc nofollow" target="_blank"> Github </a>上获得。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/200e44025b0e32b662b02aaa2eab22f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*luCHo9Sl4tE3k_MtYoEjwA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="328c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我期望Julia比Python快得多，但是没有类型声明它会慢得多。有了类型声明，Julia速度更快。然而，这种差异并不显著。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="eaa1" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">互易素数</h1><p id="935b" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">当1除以一个质数时，会出现一个重复的数字模式。1/7 = 0.142857142857142857…重复的模式是142857。这对于所有的质数都是成立的，除了拐角情况2和5。</p><p id="33b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个很好的性能测试是计算重复模式和该模式的长度。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="f9e4" class="nk mj iq ng b gy nl nm l nn no">def python_reciprocals(prime: int) -&gt; dict:</span><span id="d2d7" class="nk mj iq ng b gy np nm l nn no">    # corner cases<br/>    if prime in [2, 5]:<br/>        raise ValueError('Corner cases are not valid')</span><span id="da6f" class="nk mj iq ng b gy np nm l nn no">    # valid primes<br/>    start = 10<br/>    reciprocals = ''<br/>    while True:<br/>        reciprocals += str(start // prime)<br/>        start = (start % prime) * 10<br/>        if start == 10:<br/>            break</span><span id="8924" class="nk mj iq ng b gy np nm l nn no">    return {'length': len(reciprocals), 'reciprocals': reciprocals}</span></pre><p id="d0ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">比如:<code class="fe nq nr ns ng b">python_reciprocals(17)</code>返回字典<code class="fe nq nr ns ng b">{'length': 16, 'reciprocals': '0588235294117647'</code>。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="bb27" class="nk mj iq ng b gy nl nm l nn no">function jlReciprocalsTypes(prime::Int64)::NamedTuple<br/>    # corner cases<br/>    if prime in [2, 5]<br/>        throw(DomainError(prime, "Corner cases are not valid"))<br/>    end</span><span id="4c2c" class="nk mj iq ng b gy np nm l nn no">    # valid primes<br/>    start = 10<br/>    group = ""<br/>    while true<br/>        group *= string(start ÷ prime)<br/>        start = (start % prime) * 10<br/>        if start == 10<br/>            break<br/>        end<br/>    end<br/>    return (lenght=length(group), group=group)<br/>end</span></pre><p id="9efa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于上面的Julia版本(带有类型声明)，我还测试了一个没有类型声明的版本。所有测试都使用质数1212121。下图显示了结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/a66768c3740b98084c6ce72f6d6ce212.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*p7mNkZDaBVo5--uyvCq6rQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="9b87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整的<a class="ae kv" href="https://nbviewer.org/github/Brinkhuis/PrimeTime/blob/main/primes.ipynb" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本</a>可以在<a class="ae kv" href="https://github.com/Brinkhuis/PrimeTime/blob/main/primes.ipynb" rel="noopener ugc nofollow" target="_blank"> Github </a>上获得。</p><p id="8e98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">再次不完全是我所期待的。Python胜过了Julia，甚至在类型声明上也胜过了Julia。</p><p id="88e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我怀疑Python处理字符串对象的速度更快。让我们再次做同样的测试，将重复的模式存储在一个列表(Python)或向量(Julia)中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/552291f42c162a47e29a49e893fbf460.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*hszuOlqlRVfZGyEgQb3UhQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="6028" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的结果超出了我的预期。即使不使用类型声明，Julia的表现也比Python出色得多。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="4a58" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">最后的想法</h1><p id="1bc1" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">我喜欢朱莉娅语言。然而，它并不是在所有情况下都像我想象的那样有性能。当处理数字数据和向量/数组时，Julia速度很快！但是当处理字符串对象时，Python似乎是更快的选择。</p><p id="c0de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你对什么时候用Julia，什么时候用Python有什么想法？有没有可以加快速度的代码优化？</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><div class="kg kh ki kj gt nu"><a rel="noopener follow" target="_blank" href="/how-to-setup-project-environments-in-julia-ec8ae73afe9c"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">如何在Julia中设置项目环境</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">介绍Julia的内置包管理器，用于生成项目环境和管理包…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">towardsdatascience.com</p></div></div><div class="od l"><div class="oe l of og oh od oi kp nu"/></div></div></a></div><div class="oj ok gp gr ol nu"><a rel="noopener follow" target="_blank" href="/getting-started-with-data-analysis-in-julia-421ce0032916"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">Julia中的数据分析入门</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">关于Julia中数据分析入门的温和介绍性指南。</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">towardsdatascience.com</p></div></div><div class="od l"><div class="om l of og oh od oi kp nu"/></div></div></a></div></div></div>    
</body>
</html>