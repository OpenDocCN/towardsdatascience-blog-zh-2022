<html>
<head>
<title>Replicate a Logistic Regression Model as an Artificial Neural Network in Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Keras中将逻辑回归模型复制为人工神经网络</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/replicate-a-logistic-regression-model-as-an-artificial-neural-network-in-keras-cd6f49cf4b2c#2022-05-19">https://towardsdatascience.com/replicate-a-logistic-regression-model-as-an-artificial-neural-network-in-keras-cd6f49cf4b2c#2022-05-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="49c9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">神经网络和深度学习课程:第11部分</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/79b55e976817c79de9c7729e94a1ff6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CrlOcNbJC9hYTBcswwYqoA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=475664" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/geralt-9301/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=475664" rel="noopener ugc nofollow" target="_blank"> Gerd Altmann </a></p></figure><p id="9eb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">逻辑回归是一个非常简单的神经网络模型，没有隐藏层，正如我在我的<a class="ae ky" href="https://rukshanpramoditha.medium.com/list/neural-networks-and-deep-learning-course-a2779b9c3f75" rel="noopener">神经网络和深度学习课程</a>的<a class="ae ky" href="https://rukshanpramoditha.medium.com/logistic-regression-as-a-very-simple-neural-network-model-923d366d5a94" rel="noopener">第7部分</a>中解释的那样。</p><p id="5617" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们将使用Scikit-learn和Keras包构建相同的逻辑回归模型。Scikit-learn <code class="fe lv lw lx ly b">LogisticRegression()</code>类是构建逻辑回归模型的最佳选择。然而，我们可以用神经网络思维在Keras中构建相同的模型，因为逻辑回归模型在技术上可以被视为ANN。</p><p id="e827" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编写本教程的主要目标是:</p><ol class=""><li id="5bd3" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">比较使用两个不同库构建的相同逻辑回归模型的性能。</li><li id="3b2e" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">建立一个Keras序列模型。</li><li id="308f" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">熟悉Keras类中的一些<code class="fe lv lw lx ly b">import</code>约定。</li><li id="fabd" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">使用Keras顺序模型实例的<code class="fe lv lw lx ly b">summary()</code>、<code class="fe lv lw lx ly b">compile()</code>、<code class="fe lv lw lx ly b">fit()</code>和<code class="fe lv lw lx ly b">evaluate()</code>方法。</li><li id="ace0" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">在模型训练和评估中，绘制每个时期的损失和准确性分数。</li></ol><p id="6b38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文的结尾，你将能够用神经网络的思维方式建立一个逻辑回归模型，并使用数值和可视化技术评估它的性能。</p><h2 id="eef0" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">关于我们使用的数据</h2><p id="205e" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">这里，我们使用1995年11月创建的<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.load_breast_cancer.html" rel="noopener ugc nofollow" target="_blank"> Scikit-learn乳腺癌威斯康星州数据集</a>。</p><ul class=""><li id="c4fe" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu nl mf mg mh bi translated"><strong class="lb iu">数据集来源:</strong>你可以在这里下载原始数据集<a class="ae ky" href="https://archive.ics.uci.edu/ml/datasets/Breast+Cancer+Wisconsin+(Diagnostic)" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="e534" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nl mf mg mh bi translated"><strong class="lb iu">数据集许可:</strong>这个数据集是捐赠给公众的。它属于<strong class="lb iu"> CC0:公共领域</strong>许可。你可以在这里找到关于那种许可证<a class="ae ky" href="https://creativecommons.org/publicdomain/zero/1.0/" rel="noopener ugc nofollow" target="_blank">的更多信息。</a></li><li id="7273" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nl mf mg mh bi translated">创作者:威廉·h·沃尔伯格博士，w·尼克街，奥尔维·l·曼加萨里安</li><li id="9a54" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nl mf mg mh bi translated"><strong class="lb iu">捐赠者:</strong>尼克街</li><li id="be7f" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nl mf mg mh bi translated"><strong class="lb iu">数据集描述</strong>:该数据集包含目标列在内共31个变量。你可以在这里找到每个变量<a class="ae ky" href="https://scikit-learn.org/stable/datasets/toy_dataset.html#breast-cancer-dataset" rel="noopener ugc nofollow" target="_blank">的描述。</a></li></ul><p id="bfe5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看整个数据集的概况。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">加载乳腺癌数据集</strong>(作者代码)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/139e831bfc198f828a04ba1ab1a71434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GwFnDb0HGnR1sTi5BOiq7g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd np">乳腺癌数据集</strong>的一部分(图片<strong class="bd np"> </strong>作者提供)</p></figure><pre class="kj kk kl km gt nq ly nr ns aw nt bi"><span id="2c46" class="mn mo it ly b gy nu nv l nw nx">df.shape</span></pre><p id="b97e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将返回(569，30)。数据集有569个观察值(行)和30个变量。这里不包括目标列。它有0和1，代表两个类。</p><pre class="kj kk kl km gt nq ly nr ns aw nt bi"><span id="9533" class="mn mo it ly b gy nu nv l nw nx">df.isnull().sum().sum()</span></pre><p id="bde4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将返回0。这意味着数据集中没有缺失值。</p><h2 id="f26b" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">制作X、y、训练和测试集</h2><p id="898d" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">让我们创建X和y，特征矩阵和目标向量。</p><pre class="kj kk kl km gt nq ly nr ns aw nt bi"><span id="ce45" class="mn mo it ly b gy nu nv l nw nx">X = df<br/>y = pd.Series(cancer.target)</span></pre><p id="2e16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们创建训练集和测试集。我们将总数据的20%分配给测试集。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">制作列车和试验部件</strong>(作者代码)</p></figure><h2 id="1bcf" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">用Scikit-learn建立逻辑回归模型</h2><p id="4c00" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">现在，我们使用Scikit-learn <code class="fe lv lw lx ly b">LogisticRegression()</code>类在乳腺癌数据集上构建逻辑回归模型。我们通过使用多种度量标准来评估我们的模型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">在Scikit-learn中构建逻辑回归模型</strong>(作者代码)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/b8a81bdfd2df3bb932bd35122260c11d.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*td1aUc8bEbzjSW3BlE5eiQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd np">上述模型的输出</strong>(图片<strong class="bd np"> </strong>作者)</p></figure><h1 id="f5ea" class="nz mo it bd mp oa ob oc ms od oe of mv jz og ka my kc oh kd nb kf oi kg ne oj bi translated">用Keras中的神经网络思维模式构建相同的逻辑回归模型</h1><p id="47fd" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">这是我们今天要强调的主要话题。这里，我们将构建一个可以复制上述逻辑回归模型的人工神经网络。整个过程分为如下8个步骤。</p><h2 id="8153" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">步骤1:定义神经网络架构</h2><p id="b460" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在这里，我们建立一个序列模型。顺序模型只不过是一层层的堆叠。输入层、隐藏层和输出层按顺序堆叠在模型中。这是一种人工神经网络。更多详情，请阅读<a class="ae ky" href="https://rukshanpramoditha.medium.com/implicit-and-explicit-input-layers-in-keras-sequential-models-733049f83a32#:~:text=What%20is%20a%20sequential%20model%3F" rel="noopener">本</a>。</p><p id="0639" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的模型没有隐藏层！它只有输入层和输出层。输入层有30个节点(神经元),与数据集中的要素数量相等。输入层不需要激活。输出层只有一个节点，这里使用了sigmoid激活函数，因为我们正在执行二元分类(逻辑回归)任务。</p><h2 id="dce8" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">步骤2:实例化Keras Sequential()类的模型</h2><pre class="kj kk kl km gt nq ly nr ns aw nt bi"><span id="d43c" class="mn mo it ly b gy nu nv l nw nx">from keras.models import Sequential<br/>ANN_model = Sequential()</span></pre><h2 id="476f" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">步骤3:向顺序模型添加层</h2><p id="d002" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">一旦实例化，就可以使用<code class="fe lv lw lx ly b">add()</code>方法将层添加到现有模型中。这里，我们<a class="ae ky" href="https://rukshanpramoditha.medium.com/implicit-and-explicit-input-layers-in-keras-sequential-models-733049f83a32#:~:text=We%20can%20use%20the%20InputLayer()%20class%20to%20explicitly%20define%20the%20input%20layer%20of%20a%20Keras%20sequential%20model." rel="noopener">通过使用Keras <code class="fe lv lw lx ly b">InputLayer()</code>类显式添加输入层</a>。使用Keras <code class="fe lv lw lx ly b">Dense()</code>类添加输出层。两者都是<strong class="lb iu"> <em class="ok">全连通</em> </strong>(也叫<strong class="lb iu"><em class="ok"/></strong>)层。在输出层中使用sigmoid激活。</p><pre class="kj kk kl km gt nq ly nr ns aw nt bi"><span id="0fd3" class="mn mo it ly b gy nu nv l nw nx">from tensorflow.keras.layers import InputLayer<br/>from tensorflow.keras.layers import Dense</span><span id="e734" class="mn mo it ly b gy ol nv l nw nx">ANN_model.add(InputLayer(input_shape=(30, )))<br/># No hidden layers<br/>ANN_model.add(Dense(1, activation='sigmoid'))</span></pre><h2 id="b5b5" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">第四步:获取模型的概要</h2><pre class="kj kk kl km gt nq ly nr ns aw nt bi"><span id="727d" class="mn mo it ly b gy nu nv l nw nx">ANN_model.summary()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/09721f419c16b1348e2d3b4e5859c8ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*h8ZaMgWave63zPusVcO2Yg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片<strong class="bd np"> </strong>作者)</p></figure><p id="acf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的模型中有31个可训练参数。在训练期间，这些参数的值被更新，直到损失函数被最小化。请注意，这里没有显示输入层。</p><h2 id="14c5" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">步骤5:编译模型</h2><p id="17b8" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在此步骤中，我们将配置培训步骤中所需的学习参数。这里，我们指定在训练过程中使用的优化器、损失函数和模型评估度量的类型。</p><pre class="kj kk kl km gt nq ly nr ns aw nt bi"><span id="4645" class="mn mo it ly b gy nu nv l nw nx">optimizer=tf.keras.optimizers.Adam(learning_rate=0.05)</span><span id="a39d" class="mn mo it ly b gy ol nv l nw nx">ANN_model.compile(optimizer=optimizer,<br/>                  loss='binary_crossentropy',<br/>                  metrics=['accuracy'])</span></pre><p id="3df8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们使用学习率为0.05的<strong class="lb iu"> Adam </strong>优化器。学习率显著影响我们模型的输出。所以，你可以随意改变这个值，观察不同的结果。随着课程的进行，你将学会如何选择最佳的学习速度。</p><p id="d059" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">二元交叉熵</strong>(也称为<strong class="lb iu"> <em class="ok">对数损失</em> </strong>)是默认的损失函数，用于在训练期间测量二元(两类)分类问题的性能。</p><p id="bb2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">准确性</strong>度量用于评估二进制分类问题对测试数据的性能。</p><h2 id="511c" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">第六步:拟合模型</h2><p id="5273" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">现在，模型已经为使用<code class="fe lv lw lx ly b">fit()</code>方法进行训练做好了准备。这里，我们需要为<code class="fe lv lw lx ly b">fit()</code>方法提供训练数据。</p><p id="0470" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用<code class="fe lv lw lx ly b">fit()</code>方法的输出包含一些在训练过程中收集的有用信息，并保存在<strong class="lb iu"> <em class="ok">历史</em> </strong>变量中。该信息包括在每次迭代(时期)之后计算的损失和任何其他度量分数。我们可以使用它们来绘制模型性能与历元数的关系图。</p><pre class="kj kk kl km gt nq ly nr ns aw nt bi"><span id="3f6a" class="mn mo it ly b gy nu nv l nw nx">history = ANN_model.fit(X_train, y_train, <br/>                        epochs=10, batch_size=32,<br/>                        validation_split=0.2, <br/>                        shuffle=False)</span></pre><p id="542e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们为训练数据提供<code class="fe lv lw lx ly b">X_train</code>、<code class="fe lv lw lx ly b">y_train</code>。我们定义了10个时期，以便优化器遍历整个训练数据集10次。一个<strong class="lb iu">时期</strong>是对整个训练数据集的迭代。每批训练数据包含32个训练样本，因为我们定义<code class="fe lv lw lx ly b">batch_size</code>为32。大约有(569/32)个批次。要了解更多关于批次大小和时期的信息，请阅读<a class="ae ky" href="https://rukshanpramoditha.medium.com/overview-of-a-neural-networks-learning-process-61690a502fa#:~:text=The%20batch%20size%20and%20epochs" rel="noopener">此</a>。</p><p id="8524" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">validation_split</code>是可选参数。如果包括的话，一部分训练数据被保留在一边以在每个时期之后验证模型。将分别计算培训和验证部分的损失和任何其他指标分数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/b26b648557549dd2ebed8cd8d7aa5f6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FPJVDna7aPYUj4Ua83h57Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd np">神经网络模型的输出</strong>(图片由作者提供)</p></figure><p id="3705" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们想要根据时期的数量来评估模型性能时,<code class="fe lv lw lx ly b">validation_split</code>参数非常有用。我们可以忽略这个论点，或者在使用<code class="fe lv lw lx ly b">evaluate()</code>方法和训练数据进行训练后评估我们的模型。</p><h2 id="0346" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">步骤7:绘制模型在训练过程中的表现</h2><p id="6a92" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">现在，我们绘制模型性能与历元数的关系图。我们使用在训练期间计算的训练和验证部分的损失和准确性分数。所有这些都存储在<strong class="lb iu"> <em class="ok">历史</em> </strong>变量中作为字典的值。你通过调用<code class="fe lv lw lx ly b">history.history</code>得到全部。</p><pre class="kj kk kl km gt nq ly nr ns aw nt bi"><span id="52c8" class="mn mo it ly b gy nu nv l nw nx"># Plot training and validation accuracy scores<br/># against the number of epochs.<br/>plt.plot(history.history['accuracy'], label='Train')<br/>plt.plot(history.history['val_accuracy'], label='Validation')<br/>plt.ylabel('Accuracy')<br/>plt.xlabel('Epoch')<br/>plt.title('Model Accuracy')<br/>plt.legend(loc='upper left')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/25192abe2e0cbf1eaf51b33da4a94f8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*a4a6KZ1k1ZKsjtUWQ_AanA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><pre class="kj kk kl km gt nq ly nr ns aw nt bi"><span id="5f5a" class="mn mo it ly b gy nu nv l nw nx"># Plot training and validation loss scores<br/># against the number of epochs.<br/>plt.plot(history.history['loss'], label='Train')<br/>plt.plot(history.history['val_loss'], label='Validation')<br/>plt.ylabel('Loss')<br/>plt.xlabel('Epoch')<br/>plt.title('Model Loss')<br/>plt.legend(loc='upper right')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/af0df151aa1467fcc41576e49e797ce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*uTthXKlUGrlp4_uEPRidYw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="1058" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">步骤8:根据测试数据评估模型</h2><p id="5b24" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">请注意，我们还没有根据测试数据评估我们的模型。在我们的例子中，我们可以通过使用返回<strong class="lb iu"> <em class="ok"> test_loss </em> </strong>和<strong class="lb iu"> <em class="ok"> test_acc </em> </strong>分数的<code class="fe lv lw lx ly b">evaluate()</code>方法来轻松实现。</p><pre class="kj kk kl km gt nq ly nr ns aw nt bi"><span id="e3ae" class="mn mo it ly b gy nu nv l nw nx">test_loss, test_acc = ANN_model.evaluate(X_test, y_test)<br/>print("Test loss:", test_loss)<br/>print("Test accuracy:", test_acc)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/5e83e8aa31d5b21d8c470fee2283f5a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*gm6NZ1F9qhh4h3UU3wJKMw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="10d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由该ANN模型返回的准确度分数更接近于先前由逻辑回归模型返回的准确度分数。</p><h1 id="f234" class="nz mo it bd mp oa ob oc ms od oe of mv jz og ka my kc oh kd nb kf oi kg ne oj bi translated">摘要</h1><p id="0307" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我们也可以对训练数据使用<code class="fe lv lw lx ly b">evaluate()</code>方法。这是在<code class="fe lv lw lx ly b">fit()</code>方法中指定<code class="fe lv lw lx ly b">validation_split</code>参数的替代方法。</p><p id="571a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使对于一个简单的ANN模型，我们也需要为下面的<a class="ae ky" href="https://rukshanpramoditha.medium.com/parameters-vs-hyperparameters-what-is-the-difference-5f40e16e2e82" rel="noopener">超参数</a>指定最佳值，这些超参数控制可训练参数的值(<strong class="lb iu"> W </strong> s和<strong class="lb iu"> b </strong> s)。</p><ul class=""><li id="d61f" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu nl mf mg mh bi translated">网络中的层数</li><li id="abd6" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nl mf mg mh bi translated">每层中的节点数量(也称为层大小)</li><li id="e184" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nl mf mg mh bi translated">损失函数的类型</li><li id="d267" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nl mf mg mh bi translated">优化器的类型</li><li id="4582" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nl mf mg mh bi translated">评估指标的类型</li><li id="729b" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nl mf mg mh bi translated">激活功能的类型</li><li id="d21e" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nl mf mg mh bi translated">批量</li><li id="c028" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nl mf mg mh bi translated">纪元</li><li id="0a1f" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nl mf mg mh bi translated">学习率</li></ul><p id="4a10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当执行我在这里包含的代码时，不同的执行会得到不同的结果。这是因为算法中包含的随机性。您可以通过如下设置随机种子来获得静态结果。</p><pre class="kj kk kl km gt nq ly nr ns aw nt bi"><span id="ede9" class="mn mo it ly b gy nu nv l nw nx">import numpy as np<br/>import tensorflow as tf</span><span id="29c3" class="mn mo it ly b gy ol nv l nw nx">np.random.seed(42)<br/>tf.random.set_seed(42)</span></pre></div><div class="ab cl oq or hx os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="im in io ip iq"><p id="1a1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天的帖子到此结束。</p><p id="4a0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有任何问题或反馈，请告诉我。</p><p id="3db9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢阅读这篇文章。如果你愿意支持我成为一名作家，请考虑 <a class="ae ky" href="https://rukshanpramoditha.medium.com/membership" rel="noopener"> <strong class="lb iu"> <em class="ok">注册会员</em> </strong> </a> <em class="ok">以获得无限制的媒体访问权限。它只需要每月5美元，我会收到你的会员费的一部分。</em></p><div class="ox oy gp gr oz pa"><a href="https://rukshanpramoditha.medium.com/membership" rel="noopener follow" target="_blank"><div class="pb ab fo"><div class="pc ab pd cl cj pe"><h2 class="bd iu gy z fp pf fr fs pg fu fw is bi translated">通过我的推荐链接加入Medium</h2><div class="ph l"><h3 class="bd b gy z fp pf fr fs pg fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pi l"><p class="bd b dl z fp pf fr fs pg fu fw dk translated">rukshanpramoditha.medium.com</p></div></div><div class="pj l"><div class="pk l pl pm pn pj po ks pa"/></div></div></a></div><p id="8991" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常感谢你一直以来的支持！下一篇文章再见。祝大家学习愉快！</p></div><div class="ab cl oq or hx os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="im in io ip iq"><p id="6e19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="pp pq ep" href="https://medium.com/u/f90a3bb1d400?source=post_page-----cd6f49cf4b2c--------------------------------" rel="noopener" target="_blank">鲁克山普拉莫迪塔</a><br/><strong class="lb iu">2022–05–19</strong></p></div></div>    
</body>
</html>