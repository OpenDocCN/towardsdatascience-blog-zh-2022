<html>
<head>
<title>Hands-On Introduction to Github Actions for Data Scientists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向数据科学家的Github操作实践介绍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/hands-on-introduction-to-github-actions-for-data-scientists-f422631c9ea7#2022-06-30">https://towardsdatascience.com/hands-on-introduction-to-github-actions-for-data-scientists-f422631c9ea7#2022-06-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="ddf9" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">Github操作</h2><div class=""/><div class=""><h2 id="400e" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">了解如何通过权重和偏差、单元测试、工件创建等实现自动化实验跟踪…</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/d8e8333499e538957d6b20e567cdd4bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LZvWQHq9zl7Rn0iocKRyvw.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">安迪·赫尔曼万在<a class="ae lh" href="https://unsplash.com/s/photos/rocket?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="c7a6" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">为什么选择Github Actions？</h1><p id="e3b7" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">通俗地说，Github Actions可以让您自动执行一些例行的和重复的任务——无论是在每次将代码部署到生产分支时测试代码，检查PRs上的良好编码实践，跨浏览器代码测试，单元测试，从<a class="ae lh" href="https://mlflow.org/" rel="noopener ugc nofollow" target="_blank"> MLFlow </a> / <a class="ae lh" href="https://wandb.ai/site" rel="noopener ugc nofollow" target="_blank"> WandB </a>跟踪中检索运行，自动关闭陈旧问题，等等。这个清单真的是无穷无尽的。</p><p id="89f1" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">虽然你当然可以自己从头开始编写所有这些Github动作，但我建议不要重新发明轮子。相反，为您的特定用例搜索可用操作的好地方是<a class="ae lh" href="https://github.com/marketplace?type=actions" rel="noopener ugc nofollow" target="_blank">市场</a>。让我们看看如何在行动中使用它们。</p><div class="nb nc gp gr nd ne"><a href="https://github.com/V-Sher/Github-Actions-PlayGround" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jd gy z fp nj fr fs nk fu fw jc bi translated">GitHub-V-Sher/GitHub-Actions-PlayGround:理解对数据科学家有用的GitHub操作</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">github.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns lb ne"/></div></div></a></div><p id="2db4" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><em class="nt">注意:尽管运行随心所欲的操作可能很诱人，但私人回购每月只有有限的免费分钟数(约2000分钟)和存储空间(约500MB)(分钟数每月重置，但存储空间不会)。然而，公开回购对Github操作的使用没有这样的限制。更多关于计费的细节可以在</em> <a class="ae lh" href="https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions" rel="noopener ugc nofollow" target="_blank"> <em class="nt">这里找到</em> </a> <em class="nt">。</em></p><h1 id="6c92" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">让我们开始吧…</h1><p id="09b3" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">首先，我们需要在repo中创建<code class="fe nu nv nw nx b">.github/workflows</code>目录，并在其中创建一个新的<code class="fe nu nv nw nx b">.yml</code>文件。一个典型的<code class="fe nu nv nw nx b">.yml</code>文件如下所示:</p><pre class="ks kt ku kv gt ny nx nz oa aw ob bi"><span id="06d2" class="oc lj it nx b gy od oe l of og">name: Github Actions Demo<br/>on:<br/>  issues:<br/>    types: [opened, edited, deleted] <br/>jobs:<br/>  Job1:<br/>    runs-on: ubuntu-latest     <br/>    steps:<br/>      - name: "This is Step 1 with bash command."<br/>        run: <!-- -->echo "hello World"<br/>        shell: bash<br/>      - name: "This is step 2 using marketplace action."<br/>        uses: <!-- -->actions/checkout@v3<br/>  Job2:<br/>    .....</span><span id="b28c" class="oc lj it nx b gy oh oe l of og">  Job3:<br/>    .....</span></pre><p id="eb73" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">需要考虑的事情很少:</p><ul class=""><li id="4045" class="oi oj it mc b md mw mg mx mj ok mn ol mr om mv on oo op oq bi translated">我们需要为工作流定义一个<code class="fe nu nv nw nx b">name</code>以及<em class="nt">何时</em>该工作流应该运行。前者可以是您喜欢的任何东西，后者需要使用<code class="fe nu nv nw nx b">on</code>来指定。例如，我们可能希望仅在打开问题、关闭问题、评论PR、创建和编辑标签时运行工作流。查看可以触发工作流的事件的完整<a class="ae lh" href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows" rel="noopener ugc nofollow" target="_blank">列表。在我们的示例中，每当有人打开、编辑和/或删除问题时，就会触发该事件。</a></li><li id="1bb4" class="oi oj it mc b md or mg os mj ot mn ou mr ov mv on oo op oq bi translated">这里我们定义了三个作业(<code class="fe nu nv nw nx b">job1</code>、<code class="fe nu nv nw nx b">job2</code>、<code class="fe nu nv nw nx b">job3</code>)，但实际上，您可以在单个<code class="fe nu nv nw nx b">.yml</code>文件中定义任意数量的作业，当<code class="fe nu nv nw nx b">on</code>中定义的事件被触发时，它们将同时运行(对此有变通办法，可以延迟运行<code class="fe nu nv nw nx b">job2</code>，直到<code class="fe nu nv nw nx b">job1</code>完成)。</li><li id="b704" class="oi oj it mc b md or mg os mj ot mn ou mr ov mv on oo op oq bi translated">我们可以选择使用<code class="fe nu nv nw nx b">runs-on</code>定义一个服务器来运行您的工作流。稳定的<a class="ae lh" href="https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#choosing-github-hosted-runners" rel="noopener ugc nofollow" target="_blank">选择</a>包括<code class="fe nu nv nw nx b">ubuntu-latest</code>、<code class="fe nu nv nw nx b">macos-latest</code>和<code class="fe nu nv nw nx b">windows-latest</code>。<br/> <em class="nt">注意:注意选择，因为一些Github托管的跑步者比其他人消耗更多的时间。从文档来看，运行在Windows和macOS上的</em> <a class="ae lh" href="https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions#included-storage-and-minutes" rel="noopener ugc nofollow" target="_blank"> <em class="nt">作业消耗的时间是运行在Linux上的</em> </a> <em class="nt">作业的2到10倍。</em></li><li id="4c8a" class="oi oj it mc b md or mg os mj ot mn ou mr ov mv on oo op oq bi translated">作业中的步骤是按顺序运行的。一定要给一个步骤起一个有意义的名字，因为这有助于以后的调试。</li><li id="42f8" class="oi oj it mc b md or mg os mj ot mn ou mr ov mv on oo op oq bi translated">作业中的步骤可以做两件事之一——(a)使用<code class="fe nu nv nw nx b">run</code>(例如，<code class="fe nu nv nw nx b">echo "hello World"</code>)运行bash命令，或者(b)使用<code class="fe nu nv nw nx b">uses</code>使用marketplace或第三方Github动作(例如，<code class="fe nu nv nw nx b"><a class="ae lh" href="https://github.com/actions/checkout" rel="noopener ugc nofollow" target="_blank">actions/checkout@v3</a></code>——这是一个流行的动作，可以帮助您签出一个repo并使用其中的任何文件作为工作流的一部分——我们将在本教程的后面介绍它)。</li></ul><h1 id="2234" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">动手示例</h1><p id="9740" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我们有一个名为<code class="fe nu nv nw nx b">Dump event payload</code>的工作流，其中包含一个名为<code class="fe nu nv nw nx b">Comment</code>的作业，每次打开、编辑或删除一个问题时都会触发这个作业。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="52c4" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在解释发生了什么之前，让我们通过创建一个新问题来看看它是如何工作的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oy"><img src="../Images/154b56771f4fdc55058400ad146b9437.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W2yEubrLxAccem_MedABjA.png"/></div></div></figure><p id="e051" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">接下来，转到<strong class="mc jd">动作</strong>选项卡，您会看到一个黄色圆点，表示工作流程正在运行。一旦完成，它将变成绿色。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oz"><img src="../Images/558702d9211e826a5c95dd35d5e5c246.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HscyJkq2UyjOjxrJhbiTSw.png"/></div></div></figure><p id="9d4e" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">完成后，点击它来查看状态、总持续时间和创建的工件(我们将在教程的后面介绍工件)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pa"><img src="../Images/851ddc663a4a78b35c42ea114fbadfaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3-zJykx-isBxB6zL73Yz9g.png"/></div></div></figure><p id="bd3a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">最后，进入<code class="fe nu nv nw nx b">Comment</code>作业，我们应该能够看到我们在工作流中定义的所有步骤的输出。</p><div class="ks kt ku kv gt ab cb"><figure class="pb kw pc pd pe pf pg paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/84aa5c98be3620f93e499eed1e3f80a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*usP4OAxborqfcowHYpCrYg.png"/></div></figure><figure class="pb kw ph pd pe pf pg paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/b985d4a1bd96d0060506c2ccaca097ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*xypS-P5YGAQZNKlzqfRbQA.png"/></div></figure></div><p id="46f5" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">让我们来分解一下工作流程中发生了什么。</p><p id="06a2" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">它包含一个将转储整个Github事件有效负载的步骤。我总是发现将<code class="fe nu nv nw nx b">github.event</code>上下文中所有可用的内容转储到终端以查看触发工作流运行的事件的信息非常有用。这通常会返回一个嵌套的字典，我们将使用<code class="fe nu nv nw nx b">toJSON()</code>打印出来。</p><p id="f4c6" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><em class="nt">注意:您还可以检查其他上下文，如触发工作流运行的分支名称的</em> <code class="fe nu nv nw nx b"><em class="nt">github.ref</em></code> <em class="nt">，回购名称的</em> <code class="fe nu nv nw nx b"><em class="nt">github.repository</em></code> <em class="nt">等。完整的名单可以在</em> <a class="ae lh" href="https://docs.github.com/en/actions/learn-github-actions/contexts#github-context" rel="noopener ugc nofollow" target="_blank"> <em class="nt">这里找到</em> </a> <em class="nt">。</em></p><p id="895f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如上图所示，返回的上下文包含关于操作的信息(即<code class="fe nu nv nw nx b">opened</code>)、关于问题本身的信息，例如，创建时间、问题正文、评论数量等。</p><p id="5b50" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><em class="nt">注意:</em> <code class="fe nu nv nw nx b"><em class="nt">github.event</em></code> <em class="nt">中的信息将取决于触发工作流的事件类型。例如，</em> <code class="fe nu nv nw nx b"><em class="nt">github.event</em></code> <em class="nt">的内容会根据问题是否打开而变化，而不是推送到</em> <code class="fe nu nv nw nx b"><em class="nt">main</em></code> <em class="nt">分支。</em></p><p id="ba82" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">现在我们已经知道了所有的上下文信息，我们可以在工作流中添加一个新的步骤2，这个步骤将把这些信息的一部分<code class="fe nu nv nw nx b">echo</code>到标准输出中。特别是，我们将比较由<code class="fe nu nv nw nx b">github.event</code>记录的动作是否是一个<em class="nt">问题-编辑</em>事件，而不是一个<em class="nt">问题-打开</em>事件。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="d63b" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">为了查看实际效果，我们将创建一个新问题，转到Actions选项卡，并检查输出。正如所料，它输出一个布尔值0，表示为<code class="fe nu nv nw nx b">False</code>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pi"><img src="../Images/51809dc0517d26d57430f769b59fb162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R0UtBrIYhlb3ZzOnHiJ2bw.png"/></div></div></figure><p id="1191" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">到目前为止，我们只添加了运行bash命令来打印标准输出的步骤。如前所述，通过使用<code class="fe nu nv nw nx b">uses</code>而不是<code class="fe nu nv nw nx b">run</code>，我们还可以在一个步骤中使用来自Github marketplace的动作。为了演示这一点，我们将使用Peter Evan的<a class="ae lh" href="https://github.com/peter-evans/create-or-update-comment" rel="noopener ugc nofollow" target="_blank">Create-or-Update-Comment</a>操作来创建一个自动感谢新问题创建者的评论。Readme中解释了它的<a class="ae lh" href="https://github.com/peter-evans/create-or-update-comment#add-a-comment-to-an-issue-or-pull-request" rel="noopener ugc nofollow" target="_blank">用法</a>,并且非常简单——我们必须提供需要进行评论的问题编号，以及消息的实际正文。幸运的是，我们可以将前者作为<code class="fe nu nv nw nx b">github.event.issue</code>上下文的一部分，后者可以是您想要的任何内容。</p><p id="dcdd" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">让我们添加步骤3来实现这一点。我们将添加一个<code class="fe nu nv nw nx b">if</code>子句，以确保只有当问题是<code class="fe nu nv nw nx b">opened</code>(而不是<code class="fe nu nv nw nx b">edited</code>或<code class="fe nu nv nw nx b">deleted</code>)时才运行该步骤。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="bc89" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">为了测试这一点，创建一个新的问题，您应该会看到下面的bot消息。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pj"><img src="../Images/519ffd31c7115c4734caaad116b26f98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D4B7TVw7reS7lb6RJPA-wQ.png"/></div></div></figure><p id="bd73" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><em class="nt">注意:在下面的完整示例中，我还添加了一些额外的步骤，用于根据问题是已编辑还是已打开来定制消息。</em></p><h1 id="95e8" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">完整示例:</h1><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="bd32" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">这是我日常使用的三个主要Github操作的入门知识。</p><h1 id="4a0d" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">用例1:在一个分支上运行测试<code class="fe nu nv nw nx b">push</code></h1><p id="c74a" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">每当我们将提交推送到一个分支时，我们倾向于使用<code class="fe nu nv nw nx b">pytest</code>运行一些单元测试，以确保过程中没有任何中断。</p><p id="9c44" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">为了模拟这个过程，让我们假设我们现在正在处理一个<a class="ae lh" href="https://github.com/V-Sher/Github-Actions-PlayGround/tree/hello-world" rel="noopener ugc nofollow" target="_blank">新的</a> <code class="fe nu nv nw nx b"><a class="ae lh" href="https://github.com/V-Sher/Github-Actions-PlayGround/tree/hello-world" rel="noopener ugc nofollow" target="_blank">hello-world</a></code> <a class="ae lh" href="https://github.com/V-Sher/Github-Actions-PlayGround/tree/hello-world" rel="noopener ugc nofollow" target="_blank">分支</a>，它增加了三个新的内容——两个目录(<code class="fe nu nv nw nx b">src</code>和<code class="fe nu nv nw nx b">tests</code>以及一个<code class="fe nu nv nw nx b">requirements.txt</code>文件)。目录结构如下所示:</p><pre class="ks kt ku kv gt ny nx nz oa aw ob bi"><span id="3da1" class="oc lj it nx b gy od oe l of og"><a class="ae lh" href="https://github.com/V-Sher/Github-Actions-PlayGround" rel="noopener ugc nofollow" target="_blank">Github-Actions-PlayGround</a><br/>│   README.md<br/>│   requirements.txt    <br/>└───src<br/>│   │   utils.py<br/>└───tests<br/>    │   test_example.py</span></pre><p id="f329" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><code class="fe nu nv nw nx b">utils.py</code>(左侧)和<code class="fe nu nv nw nx b">test_example.py</code>(右侧)的内容如下:</p><div class="ks kt ku kv gt ab cb"><figure class="pb kw pk pd pe pf pg paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/8c32e384dabdb99ef9ed441f6417311b.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*MNyrfyl5JnG1wtXEfU1O_A.png"/></div></figure><figure class="pb kw pl pd pe pf pg paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/532e39880c350056168427d21792f26b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*jrlefwzPIpBKBAeB1y8duQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk pm di pn po translated">左边:<code class="fe nu nv nw nx b">utils.py; On right test_example.py</code></p></figure></div><p id="93a3" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">最后，我们准备在<code class="fe nu nv nw nx b">hello-world</code>分支上的<code class="fe nu nv nw nx b">.github/worklfows/unit_test.yml</code>中创建一个工作流，该工作流将在提交到分支的任何时候运行<code class="fe nu nv nw nx b">tests</code>目录中的测试(目前，我们在<code class="fe nu nv nw nx b">tests/test_example.py</code>中只定义了一个测试，但您已经明白了)。</p><p id="aabd" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">为了让工作流成功运行，我们需要确保在运行测试之前，我们应该定义在运行环境中安装<code class="fe nu nv nw nx b">requirements.txt</code>文件的步骤(参见下面的步骤2)并将目录添加到<code class="fe nu nv nw nx b">PYTHONPATH</code>，如果有的话(参见下面的步骤3)。<br/> <em class="nt">(附:如果你还在疑惑我是否/如何/为什么需要一个</em> <code class="fe nu nv nw nx b"><em class="nt">pythonpath</em></code> <em class="nt">，看看</em> <a class="ae lh" rel="noopener" target="_blank" href="/understanding-python-imports-init-py-and-pythonpath-once-and-for-all-4c5249ab6355"> <em class="nt">这篇</em> </a> <em class="nt">的文章吧。)</em></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="859c" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">需要考虑的事情很少:</p><ul class=""><li id="1a2f" class="oi oj it mc b md mw mg mx mj ok mn ol mr om mv on oo op oq bi translated">如果我们在一个步骤中运行多个bash命令，我们使用管道符号(<code class="fe nu nv nw nx b">|</code>)。例如，请参见步骤2。<br/> <em class="nt"> P.S .其他步骤我加了</em> <code class="fe nu nv nw nx b"><em class="nt">|</em></code> <em class="nt">只是为了简洁。</em></li><li id="d305" class="oi oj it mc b md or mg os mj ot mn ou mr ov mv on oo op oq bi translated">在步骤3中，我们可以简单地执行以下操作来设置正确的<code class="fe nu nv nw nx b">PYTHONPATH</code>。</li></ul><pre class="ks kt ku kv gt ny nx nz oa aw ob bi"><span id="4ca5" class="oc lj it nx b gy od oe l of og">- name: "Step3: Add ./src to PYTHONPATH"<br/>  id: first_update_step<br/>  run: PYTHONPATH=$GITHUB_WORKSPACE/src</span></pre><p id="12cb" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因为我想证明我们确实正确地设置了pythonpath，所以在步骤3中我们将输出<code class="fe nu nv nw nx b">echo</code>到<code class="fe nu nv nw nx b">$GITHUB_ENV</code>——稍后在步骤4中使用<code class="fe nu nv nw nx b">env.PYTHONPATH</code>检索。</p><ul class=""><li id="60ba" class="oi oj it mc b md mw mg mx mj ok mn ol mr om mv on oo op oq bi translated">如前所述，一个步骤可以是您通常可以在终端中运行的任何bash命令，在最后一步，即步骤5中，我们使用<code class="fe nu nv nw nx b">pytest</code>命令运行单元测试。</li></ul><p id="b4f9" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">现在有趣的部分来了——看到我们的工作流程在运行。用这个新的分支<code class="fe nu nv nw nx b">hello-world</code>创建一个公共关系，并尝试向它提交一个新的承诺。在每次推送时，您会看到检查自动开始，由一个黄色标记表示(见左图)。一旦完成，它们将变成绿色(见右图)。</p><div class="ks kt ku kv gt ab cb"><figure class="pb kw pp pd pe pf pg paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/2f45fe04dbe88a34e5547d00a70c754c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*D9Q1zqF06vHUubH9uDeVog.png"/></div></figure><figure class="pb kw pq pd pe pf pg paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/2d516cef4e5f2fd286f6edacf73bb89f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*7lYe5xCtHROmi8hJZtbtcQ.png"/></div></figure></div><h1 id="2a47" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">用例#2:在一个拉取请求下，显示从WandB运行的注释</h1><p id="c186" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">对任何数据科学家来说，修改超参数都是模型训练的一部分。通常实施某种实验跟踪(如MLFlow或Weights &amp; Biases(或<code class="fe nu nv nw nx b">wandb</code>))来跟踪每个不同超参数组合的结果。</p><p id="7694" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因为重要的决策(比如是否合并分支并在生产中使用模型)必须基于这些来制定，所以我们获取这些运行并将其作为拉请求的一部分进行文档化是很重要的。这有助于提高代码审查过程中的透明度和责任性，因为每个人都可以看到模型的性能。</p><p id="d75d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">为此，<code class="fe nu nv nw nx b"><a class="ae lh" href="https://github.com/marketplace/actions/get-runs-from-weights-biases" rel="noopener ugc nofollow" target="_blank">machine-learning-apps/wandb-action</a></code> marketplace action提供了一个简单易用的解决方案。让我们看看如何通过在<code class="fe nu nv nw nx b">main</code>分支中创建一个新的工作流<code class="fe nu nv nw nx b">.github/workflows/wandb_runs.yml</code>来获取一个虚拟运行(从所有记录的<code class="fe nu nv nw nx b">wandb</code>运行中获取<a class="ae lh" href="https://wandb.ai/vsher/GithubActionsDemo/table?workspace=user-vsher" rel="noopener ugc nofollow" target="_blank">，这里是</a>)。我们将一步一步地构建它。</p><p id="5ce6" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><em class="nt">注意:我记录的模拟运行是一个涉及拥抱脸变形金刚项目的一部分。如果您想了解如何使用Wandb和</em>记录跑步，请查看 <a class="ae lh" href="https://docs.wandb.ai/guides/integrations/huggingface" rel="noopener ugc nofollow" target="_blank"> <em class="nt">这个</em> </a> <em class="nt">快速演示🤗<em class="nt">变形金刚</em>与<em class="nt">只是多了2行代码。即使您没有使用Huggingface，</em> <code class="fe nu nv nw nx b"><em class="nt">wandb</em></code> <em class="nt">也将为您工作，因为它是框架不可知的——这意味着它可以记录使用Pytorch、Tensorflow、Scikit Learn、Keras等训练的模型。具体框架查看他们的教程</em> <a class="ae lh" href="https://docs.wandb.ai/guides/integrations" rel="noopener ugc nofollow" target="_blank"> <em class="nt">这里</em> </a> <em class="nt">。</em></em></p><h2 id="7b50" class="oc lj it bd lk pr ps dn lo pt pu dp ls mj pv pw lu mn px py lw mr pz qa ly iz bi translated">检测触发短语</h2><p id="a1f5" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">首先，我们需要一个触发词/短语，当它出现在PR注释的主体中时，指示工作流获取一个<code class="fe nu nv nw nx b">wandb</code>运行。除了这个触发字，我们还必须传递我们想要获取的运行的id。我们将使用名为<code class="fe nu nv nw nx b"><a class="ae lh" href="https://github.com/machine-learning-apps/actions-chatops" rel="noopener ugc nofollow" target="_blank">machine-learning-apps/actions-chatops</a></code>的市场行动来达到同样的目的。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="a65e" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">要使用这个动作，我们只需要使用<code class="fe nu nv nw nx b">with</code>定义一个<code class="fe nu nv nw nx b">TRIGGER_PHRASE</code>。它可以是任何字符串，但在我们的例子中是<code class="fe nu nv nw nx b">/get-runs</code>。</p><p id="dec6" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><em class="nt">注意:您会注意到该操作还需要使用</em> <code class="fe nu nv nw nx b"><em class="nt">env</em></code> <em class="nt">设置一个名为</em> <code class="fe nu nv nw nx b"><em class="nt">GITHUB_TOKEN</em></code> <em class="nt">的环境变量，但是，GitHub会自动创建一个唯一的</em> <code class="fe nu nv nw nx b"><em class="nt">GITHUB_TOKEN</em></code> <em class="nt">秘密以在您的工作流中使用——这意味着您不需要做任何事情！你可以在这里阅读更多关于</em><a class="ae lh" href="https://docs.github.com/en/actions/security-guides/automatic-token-authentication#about-the-github_token-secret" rel="noopener ugc nofollow" target="_blank"><em class="nt"/></a><em class="nt">。</em></p><p id="ebd1" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因为我想检查该步骤返回的所有内容，所以我将用它指定一个<code class="fe nu nv nw nx b">id</code>。现在，我们可以使用这个带点符号的<code class="fe nu nv nw nx b">id</code>(例如，<code class="fe nu nv nw nx b">steps.chatops</code>)将所有内容转储到第3步中使用的<code class="fe nu nv nw nx b">toJSON()</code>的标准输出中。</p><p id="14ee" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">要查看工作流，创建一个新的PR，希望将推送到<code class="fe nu nv nw nx b">hello-world</code>分支的提交与<code class="fe nu nv nw nx b">main</code>分支合并。接下来，用触发词和运行id在PR下添加新注释(见下图):</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qb"><img src="../Images/6efcbd7a685d750b3244f84774b41d2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*91vz_WK3q6HztnpXdoALZA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">用Github动作检测触发字</p></figure><p id="d31c" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><em class="nt">注:您可以在</em> <code class="fe nu nv nw nx b"><em class="nt">wandb</em></code> <em class="nt">工作区的</em> <code class="fe nu nv nw nx b"><em class="nt">run.id</em></code> <em class="nt">栏中找到运行id。</em></p><p id="c7fb" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">现在，让我们转到Actions选项卡，看看步骤3返回了什么。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qc"><img src="../Images/1e9c4c9eb480cf141f6ced22da248dd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RHeVffjeNXu-P2Q-iDbSFQ.png"/></div></div></figure><p id="740c" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">不出所料，我们得到了一些有用的信息，比如分支机构名称和评论者姓名。此外，与触发字一起传递的运行id存储在<code class="fe nu nv nw nx b">TRAILING_TOKEN</code>下。至此，我们已经准备好进入步骤4，该步骤将使用<code class="fe nu nv nw nx b">machine-learning-apps/wandb-action</code>获取运行结果。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="4974" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在步骤4中，我们遵循官方文档中的<a class="ae lh" href="https://github.com/marketplace/actions/get-runs-from-weights-biases#inputs" rel="noopener ugc nofollow" target="_blank">指南</a>，并使用<code class="fe nu nv nw nx b">with</code>条款提供一些强制输入。</p><ul class=""><li id="4663" class="oi oj it mc b md mw mg mx mj ok mn ol mr om mv on oo op oq bi translated"><code class="fe nu nv nw nx b">PROJECT_NAME</code>是与您的<code class="fe nu nv nw nx b">wandb</code>项目相关联的实体/项目名称。在上面的代码片段中，<code class="fe nu nv nw nx b">entity</code>是<em class="nt"> vsher </em>而<code class="fe nu nv nw nx b">project</code>是<em class="nt"> GithubActionsDemo </em>。</li><li id="1ea3" class="oi oj it mc b md or mg os mj ot mn ou mr ov mv on oo op oq bi translated">从上一步转储的数据中，我们知道可以使用<code class="fe nu nv nw nx b">steps.chatops.outputs.TRAILING_TOKEN</code>提取<code class="fe nu nv nw nx b">RUN_ID</code>。</li><li id="6a1d" class="oi oj it mc b md or mg os mj ot mn ou mr ov mv on oo op oq bi translated">除了由<code class="fe nu nv nw nx b">RUN_ID</code>指定的运行，我还想获取我在重量和偏差<a class="ae lh" href="https://wandb.ai/vsher/GithubActionsDemo/table?workspace=user-vsher" rel="noopener ugc nofollow" target="_blank">工作区</a>中手动标记为<code class="fe nu nv nw nx b">baseline</code>和<code class="fe nu nv nw nx b">reference</code>的运行。这可以使用<code class="fe nu nv nw nx b">BASELINE_TAGS</code>来完成。</li><li id="7578" class="oi oj it mc b md or mg os mj ot mn ou mr ov mv on oo op oq bi translated">还定义了一些指标(<code class="fe nu nv nw nx b">DISPLAY_METRICS</code>)和配置变量(<code class="fe nu nv nw nx b">DISPLAY_CONFIG_VARS</code>)。确保您在这里传递的列名也作为<code class="fe nu nv nw nx b">wandb</code>日志记录的一部分被记录，并且没有任何打字错误。</li><li id="ea62" class="oi oj it mc b md or mg os mj ot mn ou mr ov mv on oo op oq bi translated">我们需要提供的最后一个输入是<code class="fe nu nv nw nx b">WANDB_API_KEY</code>。一旦你登录到你的<code class="fe nu nv nw nx b">wandb</code>账户，你会在这里找到你的API密匙:<a class="ae lh" href="https://wandb.ai/authorize" rel="noopener ugc nofollow" target="_blank"><strong class="mc jd">https://wandb.ai/authorize</strong></a><strong class="mc jd">。</strong>复制它，然后前往Github Settings - &gt; Secrets(在左侧窗格)- &gt; Actions，创建一个<strong class="mc jd">新的库秘密</strong>，名称为<code class="fe nu nv nw nx b">WANDB_API_KEY</code>，值为您刚刚复制的密钥！</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qd"><img src="../Images/444c4f7783f2f88753344817cd8ccecc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fs6jKva6QoKEB7eF3S6H5w.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">创建Github操作秘密</p></figure><p id="491f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">最后，我们将使用<code class="fe nu nv nw nx b">toJSON(steps.wandb)</code>转储该步骤的全部输出。要查看实际情况，请向PR提交一个commit，然后前往Actions选项卡进行检查。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qe"><img src="../Images/0da795f219d0612ada6b35a05a16e0e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UjJQSZUEgM_AeqJtsLIrrg.png"/></div></div></figure><p id="33b2" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">输出是不言自明的，但是，您可以在这里检查每个字典键<a class="ae lh" href="https://github.com/marketplace/actions/get-runs-from-weights-biases#outputs" rel="noopener ugc nofollow" target="_blank">的含义。更重要的是，我们可以使用点符号引用这些输出，例如<code class="fe nu nv nw nx b">steps.wandb.outputs.BOOL_COMPLETE</code>或<code class="fe nu nv nw nx b">steps.wandb.outputs.outcome</code>。</a></p><h2 id="b5bd" class="oc lj it bd lk pr ps dn lo pt pu dp ls mj pv pw lu mn px py lw mr pz qa ly iz bi translated">创建工件</h2><p id="c223" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">现在你可能会想，所有这些步骤都很好，但是实际的运行应该在哪里被获取并显示在PR评论中！</p><p id="de12" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">通读<a class="ae lh" href="https://github.com/marketplace/actions/get-runs-from-weights-biases#saving--displaying-model-run-data" rel="noopener ugc nofollow" target="_blank">文档</a>，要记住的一件事是<code class="fe nu nv nw nx b">machine-learning-apps/wandb-action</code>不在PR注释中显示运行，而是将一个名为<code class="fe nu nv nw nx b">wandb_report.csv</code>的csv文件(包含提取的运行)保存到默认工作目录指定的路径中。由于我们已经在工作流的步骤1中使用<code class="fe nu nv nw nx b">actions/checkout@v3</code>检查了回购，我们的csv文件将在<code class="fe nu nv nw nx b">home/runner/work/Github-Actions-PlayGround/Github-Actions-PlayGround</code>中创建。</p><p id="d1ab" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">为了验证这一点，我们将添加一个新步骤，使用<a class="ae lh" href="https://github.com/actions/upload-artifact" rel="noopener ugc nofollow" target="_blank"> <strong class="mc jd">操作/upload-artifact </strong> </a>操作从我们的工作流中上传这个csv工件。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="9507" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">要看到这一点，将一个新的commit推送到PR分支，然后转到Actions选项卡。您将在屏幕底部的<strong class="mc jd">工件</strong>选项卡下看到一个新创建的<strong class="mc jd"> wandb_report </strong>。请随意下载并检查它的内容。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qf"><img src="../Images/69b6cd0b4490da018cbde4bb311b1294.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j0ySJs7jb5DRNZjGRXky7g.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">通过Github操作创建的工件</p></figure><h2 id="eb4a" class="oc lj it bd lk pr ps dn lo pt pu dp ls mj pv pw lu mn px py lw mr pz qa ly iz bi translated">在公共关系评论中显示wandb运行</h2><p id="6be6" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">现在进入工作流中最激动人心的一步——在拉请求中将这个csv显示为markdown格式的注释。我们将使用标准的Github REST <a class="ae lh" href="https://docs.github.com/en/rest/issues/comments#create-an-issue-comment" rel="noopener ugc nofollow" target="_blank"> API来创建注释</a>。</p><p id="a8a7" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><em class="nt">注意:简单介绍一下API的工作原理。利用python的</em> <code class="fe nu nv nw nx b"><em class="nt">requests</em></code> <em class="nt">模块，我们制作一个</em><strong class="mc jd"><em class="nt"/></strong><em class="nt">的API调用到URL : </em> <code class="fe nu nv nw nx b"><em class="nt">https://api.github.com/repos/{repo-name}/issues/{pr_num}/comments</em></code> <em class="nt">，其中</em> <code class="fe nu nv nw nx b"><em class="nt">repo-name</em></code> <em class="nt">和</em> <code class="fe nu nv nw nx b"><em class="nt">pr_num</em></code> <em class="nt">需要显式传递。post请求的</em> <strong class="mc jd"> <em class="nt">主体</em> </strong> <em class="nt">是反映评论内容的简单字符串。</em></p><pre class="ks kt ku kv gt ny nx nz oa aw ob bi"><span id="a1c0" class="oc lj it nx b gy od oe l of og"><em class="nt"># REST API Example: Add a simple comment to PR</em></span><span id="0d60" class="oc lj it nx b gy oh oe l of og">import requests</span><span id="42c9" class="oc lj it nx b gy oh oe l of og">url = f"https://api.github.com/repos/{repo-name}/issues/{pr_num}/comments"<br/>data = {"body": "Making a new comment using API"}<br/>result = requests.post(url=url, headers=headers, json=data)</span></pre><p id="cf00" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">API示例排序后，我们将在一个名为<code class="fe nu nv nw nx b"><a class="ae lh" href="https://github.com/V-Sher/Github-Actions-PlayGround/blob/main/action_files/wandb_results.py" rel="noopener ugc nofollow" target="_blank">wandb_results.py</a></code>的新文件中实现类似的功能，我们将在工作流中运行该文件。python脚本包含上述的<code class="fe nu nv nw nx b">requests.post()</code>方法，以及应用于csv文件的一些数据帧重新格式化(在作为消息体传递之前)。</p><p id="a907" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><em class="nt">注:我要承认</em> <code class="fe nu nv nw nx b"><em class="nt">wandb_results.py</em></code> <em class="nt">很大程度上是基于代码可用</em> <a class="ae lh" href="https://github.com/machine-learning-apps/actions-ml-cicd/blob/c10862b2765f7dfee78cef1c72e0223db46dc0a1/.github/workflows/repo-dispatch.yaml" rel="noopener ugc nofollow" target="_blank"> <em class="nt">这里</em> </a> <em class="nt">。</em></p><p id="8261" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">您会注意到，在<code class="fe nu nv nw nx b"><a class="ae lh" href="https://github.com/V-Sher/Github-Actions-PlayGround/blob/main/action_files/wandb_results.py" rel="noopener ugc nofollow" target="_blank">wandb_results.py</a></code>的最开始，我们使用了三个环境变量。前者，即<code class="fe nu nv nw nx b">GITHUB_REPOSITORY</code>对运行工作流的服务器自动可用。后两个— <code class="fe nu nv nw nx b">GITHUB_TOKEN</code>和<code class="fe nu nv nw nx b">PR_NUM</code> —需要在工作流步骤中设置(参见下面的第42–43行)。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ow ox l"/></div></figure><h2 id="19e6" class="oc lj it bd lk pr ps dn lo pt pu dp ls mj pv pw lu mn px py lw mr pz qa ly iz bi translated">最终揭示</h2><p id="d573" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">要查看我们的完整工作流程，请前往公关部门，做一个类似于<code class="fe nu nv nw nx b">/get-runs &lt;run-id&gt;</code>的新评论。几分钟后，您应该会看到机器人显示提取的运行。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qg"><img src="../Images/dea2a9f0a603b4f433d84e707052e528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*90ImwLIkYmmcUmWTkjUKcA.png"/></div></div></figure><h1 id="f1e4" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">用例3:在多个python版本上测试脚本</h1><p id="5017" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在不涉及太多细节的情况下，我将快速介绍Github动作的另一个用例。<a class="ae lh" href="https://github.com/actions/setup-python" rel="noopener ugc nofollow" target="_blank">动作/设置——python</a>允许你在多个版本上测试你的python脚本。参见下面的示例用法。</p><pre class="ks kt ku kv gt ny nx nz oa aw ob bi"><span id="b4f7" class="oc lj it nx b gy od oe l of og">jobs:<br/>  build:<br/>    runs-on: ubuntu-latest<br/>    strategy:<br/>      matrix:<br/>        python-version: ['2.x', '3.x']<br/>    name: Python ${{ matrix.python-version }} sample<br/>    steps:<br/>      - uses: actions/checkout@v3<br/>      - name: Set up Python<br/>        uses: actions/setup-python@v4<br/>        with:<br/>          python-version: ${{ matrix.python-version }}<br/>          architecture: x64<br/>      - run: python my_script.py</span></pre><h1 id="c824" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">结论</h1><p id="60b7" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">到现在为止，您已经对GitHub Actions的许多奇迹有了更深的理解和深刻的欣赏。希望到现在为止，您也应该能够使用相关文档自己实现它们。作为一名数据科学家，如果您在日常工作中遇到其他有用的节省时间的行动，请告诉我！</p><p id="56d4" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">一如既往，如果有更简单的方法来做/解释本文中提到的一些事情，一定要让我知道。一般来说，避免不请自来的破坏性/垃圾/敌意评论！</p><p id="3010" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">直到下一次✨</p><p id="d0be" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><em class="nt">注:除特别注明外，所有图片均为作者所有。</em></p></div><div class="ab cl qh qi hx qj" role="separator"><span class="qk bw bk ql qm qn"/><span class="qk bw bk ql qm qn"/><span class="qk bw bk ql qm"/></div><div class="im in io ip iq"><p id="84ed" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我喜欢写循序渐进的初学者指南、操作指南、面试问题、ML/AI中使用的解码术语等。如果你想完全访问我的所有文章(和其他媒体上的文章)，那么你可以注册使用 <a class="ae lh" href="https://varshitasher.medium.com/membership" rel="noopener"> <strong class="mc jd"> <em class="nt">我的链接</em></strong></a><strong class="mc jd"><em class="nt"/></strong><em class="nt">这里</em> <strong class="mc jd"> <em class="nt">。</em>T24】</strong></p><div class="nb nc gp gr nd ne"><a rel="noopener follow" target="_blank" href="/understanding-python-imports-init-py-and-pythonpath-once-and-for-all-4c5249ab6355"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jd gy z fp nj fr fs nk fu fw jc bi translated">了解Python导入，__init__。py和pythonpath —一劳永逸</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">了解如何导入包和模块(以及两者之间的区别)</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="qo l np nq nr nn ns lb ne"/></div></div></a></div><div class="nb nc gp gr nd ne"><a rel="noopener follow" target="_blank" href="/how-to-make-most-of-your-python-debugger-in-vscode-9e05dfce533f"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jd gy z fp nj fr fs nk fu fw jc bi translated">如何在VSCode中充分利用你的python调试器？</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">观察变量，使用条件断点，调用堆栈，异常断点等——当在大型项目中工作时</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="qp l np nq nr nn ns lb ne"/></div></div></a></div><div class="nb nc gp gr nd ne"><a rel="noopener follow" target="_blank" href="/step-by-step-guide-to-explaining-your-ml-project-during-a-data-science-interview-81dfaaa408bf"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jd gy z fp nj fr fs nk fu fw jc bi translated">在数据科学面试中解释你的ML项目的逐步指南。</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">在结尾有一个额外的样本脚本，让你谨慎地展示你的技术技能！</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="qq l np nq nr nn ns lb ne"/></div></div></a></div></div></div>    
</body>
</html>