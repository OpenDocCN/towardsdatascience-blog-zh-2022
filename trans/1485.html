<html>
<head>
<title>Importing Python Functions from Other Scripts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从其他脚本导入Python函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/importing-python-functions-from-other-scripts-8769ca65a3da#2022-04-12">https://towardsdatascience.com/importing-python-functions-from-other-scripts-8769ca65a3da#2022-04-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="40ac" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">停止将函数复制和粘贴到新脚本中</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9fe40fa11ce2e6b478e8192d373847d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4sQLj8DkSD-dbprY"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@mvdheuvel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马腾·范登·霍维尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="8074" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，一个新项目需要现有的代码。更聪明地工作(而不是更努力地工作)意味着利用现有的工作。目前，从一个脚本复制粘贴到另一个脚本似乎是一个快速、无害的解决方案。然而，在一个文件中定义函数并导入它简化了过程并消除了潜在的错误。</p><p id="c1cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并非所有函数都需要单独的脚本文件。但是，如果您希望在多个项目中重用该函数，请单独保存它。</p><h1 id="7c50" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">在外部脚本中存储函数的好处</h1><ol class=""><li id="aba0" class="mn mo it lb b lc mp lf mq li mr lm ms lq mt lu mu mv mw mx bi translated">组织<br/>用描述性名称将相关功能存储在脚本中更容易找到。例如，在<code class="fe my mz na nb b">conversions.py</code>中寻找转换函数比在<code class="fe my mz na nb b">lab_report_1.py</code>、<code class="fe my mz na nb b">lab_report_2.py</code>等中搜索更直观。</li><li id="3e95" class="mn mo it lb b lc nc lf nd li ne lm nf lq ng lu mu mv mw mx bi translated">版本控制<br/>在多个地方重新创建一个函数意味着一个脚本中的编辑和更新不会转移到其他脚本。在一个地方定义函数并导入它，允许所有调用该函数的脚本都有最新的定义。</li><li id="9493" class="mn mo it lb b lc nc lf nd li ne lm nf lq ng lu mu mv mw mx bi translated">可读性<br/>将函数存储在外部可以更容易地看到脚本的总体目标。同行评审者不需要看到每个函数的定义，尤其是那些简单的函数。一个描述性的函数名通常就足够了。</li><li id="73ff" class="mn mo it lb b lc nc lf nd li ne lm nf lq ng lu mu mv mw mx bi translated">简单性<br/>与复制粘贴方法相比，导入方法使得重用函数更加容易。代码行不会被意外删除。不需要打开额外的脚本。简化的流程消除了可能的错误。</li></ol><h1 id="70c3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">条款</h1><p id="346e" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">为清晰起见，以下是描述<code class="fe my mz na nb b">import</code>语句时常用的一些术语:</p><ul class=""><li id="fb81" class="mn mo it lb b lc ld lf lg li nk lm nl lq nm lu nn mv mw mx bi translated"><strong class="lb iu">库</strong>:NumPy、Pandas等相关模块的集合。</li><li id="628e" class="mn mo it lb b lc nc lf nd li ne lm nf lq ng lu nn mv mw mx bi translated"><strong class="lb iu">模块</strong>:带有“.py”扩展名；与脚本互换使用</li><li id="cb8f" class="mn mo it lb b lc nc lf nd li ne lm nf lq ng lu nn mv mw mx bi translated"><strong class="lb iu">模块名</strong>:不带“，”的文件名。py "扩展</li><li id="8fc6" class="mn mo it lb b lc nc lf nd li ne lm nf lq ng lu nn mv mw mx bi translated"><strong class="lb iu">子模块</strong>:一个带有“的文件。子目录中的py "扩展名</li></ul><pre class="kj kk kl km gt no nb np nq aw nr bi"><span id="20e8" class="ns lw it nb b gy nt nu l nv nw">directory<br/>|-- module.py<br/>|-- subdirectory<br/>        |-- sub_module.py</span></pre><h1 id="5d87" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">从目录中的脚本导入特定函数</h1><p id="9950" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">要从当前工作目录中的脚本导入函数，请添加以下内容:</p><pre class="kj kk kl km gt no nb np nq aw nr bi"><span id="373d" class="ns lw it nb b gy nt nu l nv nw">from script_in_cwd.py import specific_function</span></pre><p id="b77a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了给<code class="fe my mz na nb b">specific_function</code>一个不同的名字，在<code class="fe my mz na nb b">import</code>语句中添加<code class="fe my mz na nb b">as</code>。</p><pre class="kj kk kl km gt no nb np nq aw nr bi"><span id="158c" class="ns lw it nb b gy nt nu l nv nw">from script_in_cwd.py import specific_function as new_name</span></pre><p id="ef4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">脚本不能处理同名的两个函数。使用<code class="fe my mz na nb b">as</code>避免导入错误。</p><h1 id="b583" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">从脚本导入所有函数和模块</h1><p id="24a7" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">要导入脚本中的所有函数，请使用<code class="fe my mz na nb b">*</code>。</p><pre class="kj kk kl km gt no nb np nq aw nr bi"><span id="0f09" class="ns lw it nb b gy nt nu l nv nw">from script_in_cwd.py import *</span></pre><p id="64ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将导入在<code class="fe my mz na nb b">script_in_cwd.py</code>中定义的所有函数。如果<code class="fe my mz na nb b">script_in_cwd.py</code>有<code class="fe my mz na nb b">import</code>语句，那么<code class="fe my mz na nb b">*</code>也会导入那些库、模块和函数。例如，如果<code class="fe my mz na nb b">script_in_cwd.py</code>有<code class="fe my mz na nb b">import numpy</code>，那么上面的语句也会导入<code class="fe my mz na nb b">numpy</code>。<strong class="lb iu">导入对象的名称将被绑定在本地名称空间</strong>中，这意味着脚本将独立识别这些名称。换句话说，导入的对象可以在不引用父模块名称的情况下被调用(<code class="fe my mz na nb b">script_in_cwd</code>)。</p><p id="f044" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">导入所有函数的另一种方法是:</p><pre class="kj kk kl km gt no nb np nq aw nr bi"><span id="3fd9" class="ns lw it nb b gy nt nu l nv nw">import script_in_cwd.py</span></pre><p id="d6b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像以前一样，这个方法导入所有定义的函数和任何用<code class="fe my mz na nb b">import</code>语句调用的东西。模块名称(<code class="fe my mz na nb b">script_in_cwd</code>)将被本地绑定，但其他导入对象的名称不会被本地绑定。那些对象必须在父模块的名字之后被调用。例如:</p><pre class="kj kk kl km gt no nb np nq aw nr bi"><span id="ef7c" class="ns lw it nb b gy nt nu l nv nw"># To call function after import</span><span id="e70c" class="ns lw it nb b gy nx nu l nv nw">script_in_cwd.specific_function()</span></pre><p id="24b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果两个导入的对象使用相同的名称，使用<code class="fe my mz na nb b">import {module}</code>方法代替<code class="fe my mz na nb b">from {module} import *</code>，因为<strong class="lb iu"> Python不能导入两个同名的对象</strong>。然而，使用<code class="fe my mz na nb b">import {module}</code>，这些对象的名称被绑定到它们唯一的父模块名称上。</p><h1 id="daef" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">从子目录中的脚本导入</h1><p id="3f42" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">要从子目录导入:</p><pre class="kj kk kl km gt no nb np nq aw nr bi"><span id="8783" class="ns lw it nb b gy nt nu l nv nw">from subdirectory.submodule import *</span></pre><p id="f7c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像以前一样，导入对象的名称被绑定到本地名称空间。</p><p id="7b77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种选择是:</p><pre class="kj kk kl km gt no nb np nq aw nr bi"><span id="3a33" class="ns lw it nb b gy nt nu l nv nw">import subdirectory.submodule</span></pre><p id="5d95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，导入的对象名称将<strong class="lb iu">而不是</strong>被本地绑定，但是<code class="fe my mz na nb b">subdirectory.submodule</code>将被本地绑定。要调用导入的对象，首先引用父模块的名称(<code class="fe my mz na nb b">subdirectory.submodule</code>)。</p><h1 id="4714" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">从目录外的脚本导入</h1><p id="3919" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">从当前工作目录之外导入需要<code class="fe my mz na nb b">sys.path</code>，这是Python搜索的所有目录的列表。要添加新的搜索路径:</p><pre class="kj kk kl km gt no nb np nq aw nr bi"><span id="b2dc" class="ns lw it nb b gy nt nu l nv nw">import sys<br/>sys.path.append('/User/NewDirectory')</span></pre><p id="8979" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这会将新路径附加到<code class="fe my mz na nb b">sys.path</code>的末尾。Python按顺序搜索这些路径。使用<code class="fe my mz na nb b">sys.path.insert</code>强制Python更快地搜索路径。例如:</p><pre class="kj kk kl km gt no nb np nq aw nr bi"><span id="190d" class="ns lw it nb b gy nt nu l nv nw">import sys<br/>sys.path.insert(1, '/User/NewDirectory')</span></pre><p id="1e1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些附加内容不仅适用于当前脚本。Python还会在这些路径中搜索未来的项目，除非它们被删除。要删除不需要的搜索路径:</p><pre class="kj kk kl km gt no nb np nq aw nr bi"><span id="28dc" class="ns lw it nb b gy nt nu l nv nw">import sys<br/>sys.path.remove('/User/NewDirectory')</span></pre><h1 id="bf58" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="5113" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">感谢您阅读我的文章。如果您喜欢我的内容，<em class="ny">请考虑关注我</em>。此外，欢迎所有反馈。我总是渴望学习新的或更好的做事方法。请随时留下您的评论或联系我katyhagerty19@gmail.com。</p><div class="nz oa gp gr ob oc"><a href="https://medium.com/@katyhagerty19/membership" rel="noopener follow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">加入我的介绍链接媒体-凯蒂哈格蒂</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">medium.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq ks oc"/></div></div></a></div></div></div>    
</body>
</html>