<html>
<head>
<title>Build Complex Time Series Regression Pipelines with sktime</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用sktime构建复杂的时间序列回归管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-complex-time-series-regression-pipelines-with-sktime-910bc25c96b6#2022-07-13">https://towardsdatascience.com/build-complex-time-series-regression-pipelines-with-sktime-910bc25c96b6#2022-07-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3459" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何通过sktime使用scikit-learn和XGBoost模型预测</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5a40787678295f2d4bc88bf949b1a049.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SWU0R_Xl2Uxj_2Zb"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马库斯·温克勒在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="b33a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">停止使用<em class="ls"> scikit-learn </em>进行预测。您可以使用现有的回归管道并不意味着您应该这样做。或者，你不厌倦使用同样的老技术，如指数平滑和ARIMA预测吗？用更高级的算法比如梯度提升树不是更好玩吗？</p><p id="c6b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<em class="ls"> sktime </em>，你可以做到这一点(以及更多)。<em class="ls"> Sktime </em>是一个库，可以让你安全地使用任何<em class="ls"> scikit-learn </em>兼容的回归模型进行时间序列预测。本教程将讨论如何使用<em class="ls"> sktime </em>将时间序列预测问题转化为回归问题。我还将向您展示如何用流行的库<em class="ls"> XGBoost </em>构建一个复杂的时间序列预测器。</p><h1 id="2394" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">背景和动机</h1><h2 id="6674" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">什么是时间序列预测？</h2><p id="b49b" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">时间序列预测是一种预测一个或多个未来值的技术。像回归建模一样，数据从业者可以基于历史数据拟合模型，并使用该模型预测未来的观察结果。</p><p id="35e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">预测中使用的一些最流行的模型是单变量模型。单变量模型仅使用以前的观测值进行预测。<a class="ae kv" href="https://otexts.com/fpp2/expsmooth.html" rel="noopener ugc nofollow" target="_blank">指数平滑</a>模型使用过去观察值的加权平均值来预测未来值，最近的数据点被赋予更大的权重。<a class="ae kv" href="https://otexts.com/fpp2/arima.html" rel="noopener ugc nofollow" target="_blank"> ARIMA </a> <strong class="ky ir"> </strong>模型基于数据中的<a class="ae kv" href="https://otexts.com/fpp2/autocorrelation.html" rel="noopener ugc nofollow" target="_blank">自相关</a>进行预测。自相关测量时间序列的时移(即滞后)值之间的关系。</p><p id="7d7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果时间序列预测听起来类似于回归建模，那么你是正确的。我们可以使用回归模型进行时间序列预测。</p><h2 id="342f" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">为什么我们要使用回归进行时间序列预测？</h2><p id="9824" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">您应该使用回归模型的原因之一是为了提高模型性能。回归技术是灵活的，你可以超越过去观察的单变量模型。包含时间步长要素(如星期几或节假日)可以丰富您的数据，并有可能发现数据中隐藏的趋势。</p><p id="634c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其次，你可能已经使用了流行的机器学习框架，比如<em class="ls"> scikit-learn </em>和<em class="ls"> XGBoost </em>。如果您已经熟悉这些库，将时间序列预测任务转换为回归问题可以节省您的时间。</p><p id="15ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，现代预测库，如脸书的<a class="ae kv" href="https://facebook.github.io/prophet/" rel="noopener ugc nofollow" target="_blank"> <em class="ls">预言家</em> </a>，也提供了多变量分析的灵活性和简单的API。尽管如此，使用回归技术进行预测应该是您的数据科学工具包中的另一个工具。</p><h2 id="8e03" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">在时间序列回归中，我们需要注意什么？</h2><p id="6946" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">时间序列回归并非没有问题。自相关观测违反了线性回归模型的假设。然而，更复杂的回归模型，如梯度树提升，通常对多重共线性具有鲁棒性。</p><p id="be0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，如果我们盲目地拟合和调整我们的回归模型，我们可能会引入数据泄漏。<a class="ae kv" rel="noopener" target="_blank" href="/avoiding-data-leakage-in-timeseries-101-25ea13fcb15f">数据泄漏</a>是指在模型训练和验证阶段使用的信息，否则这些信息将无法用于预测。例如，使用K-fold交叉验证对数据进行随机洗牌可以让你的模型预测未来。相反，你应该使用<a class="ae kv" rel="noopener" target="_blank" href="/dont-use-k-fold-validation-for-time-series-forecasting-30b724aaea64">时态交叉验证</a>。</p><p id="4f04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用<a class="ae kv" href="https://www.sktime.org/en/stable/" rel="noopener ugc nofollow" target="_blank"> <em class="ls"> sktime </em> </a>框架，而不是从头开始实现时间序列回归模型。</p><h2 id="0375" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">为什么要用sktime？</h2><p id="4f25" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated"><a class="ae kv" href="https://www.sktime.org/en/stable/" rel="noopener ugc nofollow" target="_blank"> <em class="ls"> Sktime </em> </a>是一个开源的框架，用于对时间序列进行建模的各种机器学习任务，包括时间序列回归、分类、聚类和标注。该框架结合了几个库的特性，用户体验类似于<em class="ls"> scikit-learn </em>。</p><p id="9d43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用<em class="ls"> sktime </em>完成预测任务，因为它提供了<a class="ae kv" href="https://www.sktime.org/en/stable/examples/01_forecasting.html#3.-Advanced-composition-patterns---pipelines,-reduction,-autoML,-and-more" rel="noopener ugc nofollow" target="_blank">功能</a>，例如:</p><ul class=""><li id="e84e" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated"><strong class="ky ir">归约</strong>:使用与<em class="ls"> scikit-learn </em> API兼容的估计器构建时间序列预测器</li><li id="9980" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><strong class="ky ir">调整</strong>:使用带有时间交叉验证的网格搜索策略确定超参数的值</li><li id="d83b" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><strong class="ky ir">评估</strong> : <em class="ls"> sktime </em>包括几个性能指标(如MAPE、梅斯)，并为定制评分器和回溯测试提供了一个简单的实现</li><li id="93b0" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><strong class="ky ir">流水线:</strong>是<em class="ls"> scikit-learn </em> <a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html" rel="noopener ugc nofollow" target="_blank"> <em class="ls">流水线</em> </a>的扩展，它是一系列级联的转换器，用来构建一个预测器</li><li id="22bd" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><strong class="ky ir"> AutoML </strong>:自动调整策略，在一系列模型和超参数中确定最佳预测器</li></ul><p id="a46e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls"> Sktime </em>还提供了<a class="ae kv" href="https://www.sktime.org/en/stable/examples/01_forecasting.html#2.-Forecasters-in-sktime---lookup,-properties,-main-families" rel="noopener ugc nofollow" target="_blank">其他几类</a>预测模型，包括指数平滑、ARIMA、BATS和Prophet。我们不会在本教程中讨论这些预测模型，但我鼓励您在模型选择阶段实现这些预测器。</p><h1 id="128c" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">代码示例</h1><h2 id="9134" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">资料组</h2><p id="8a92" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">我们将在本教程中使用的数据集是澳大利亚墨尔本[1]每小时的行人计数。我们将我们的分析限制在2010年1月1日至2019年12月31日。我每周都汇总数据。</p><p id="39a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们可视化我们的数据，我们可以看到大约从2013年年中开始的总体上升趋势。我们还可以在12月份看到更多的行人，可能是因为圣诞购物，在7月份是因为财政年度末的销售。我们的数据看起来是不稳定的，当我们运行一个扩展的Dickey-Fuller测试时得到了证实。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/e0a21c1232f603c98180e39e907380c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NXevGb3JF5m1Ql6CQ7bnIQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h2 id="ef2c" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">线性回归的简单预测器</h2><p id="891a" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">我们将运行的第一个示例是一个使用线性回归的简单预测器。我们先用<em class="ls"> sktime的</em><a class="ae kv" href="http://temporal_train_test_split" rel="noopener ugc nofollow" target="_blank"><em class="ls">temporal _ train _ test _ split</em></a>把最后26周的数据作为我们的测试集。该函数不会打乱数据。因此，它适用于预测。</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="2a15" class="ml lu iq ns b gy nw nx l ny nz">from sktime.forecasting.model_selection import temporal_train_test_split</span><span id="9573" class="ml lu iq ns b gy oa nx l ny nz">y_train, y_test = temporal_train_test_split(y, test_size=26)</span></pre><p id="283b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还指定了我们的预测范围，即我们将预测的26周的测试数据。我们使用<a class="ae kv" href="https://www.sktime.org/en/stable/api_reference/auto_generated/sktime.forecasting.base.ForecastingHorizon.html" rel="noopener ugc nofollow" target="_blank"> <em class="ls">预测地平线</em> </a>对象来实现这一点。</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="59b7" class="ml lu iq ns b gy nw nx l ny nz">from sktime.forecasting.base import ForecastingHorizon</span><span id="b3b1" class="ml lu iq ns b gy oa nx l ny nz">fh = ForecastingHorizon(y_test.index, is_relative=False)</span></pre><p id="4588" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">准备工作完成后，我们可以继续实例化我们的<em class="ls">scikit-learn</em><a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LinearRegression.html" rel="noopener ugc nofollow" target="_blank"><em class="ls">linear regression</em></a>对象，它将成为我们预测器的估计器。或者，您可以使用其他<em class="ls"> scikit-learn </em>估算器或<em class="ls"> scikit-learn </em> API兼容估算器，例如<em class="ls"> XGBoost </em>。我将在下面的例子中演示这一点。</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="83c0" class="ml lu iq ns b gy nw nx l ny nz">from sklearn.linear_model import LinearRegression</span><span id="5404" class="ml lu iq ns b gy oa nx l ny nz">regressor = LinearRegression()</span></pre><p id="c230" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls"> Sktime的</em><a class="ae kv" href="https://www.sktime.org/en/stable/api_reference/auto_generated/sktime.forecasting.compose.make_reduction.html?highlight=make_reduction" rel="noopener ugc nofollow" target="_blank"><em class="ls">make _ reduction</em></a>函数将时间序列转换成与我们的<em class="ls"> scikit-learn </em>估计器兼容的表格数据。参数“window_length”控制滑动窗口变换中的滞后数。</p><p id="4def" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑下面这个简单的时间序列，用<em class="ls">【y】</em>表示。如果我们应用我们的<em class="ls"> make_reduction </em>函数，在窗口长度等于3的情况下，我们生成一个具有三个输入变量的表格数据集，分别表示为<em class="ls">‘lag _ 1</em>’、<em class="ls">‘lag _ 2</em>’和<em class="ls">‘lag _ 3</em>。该函数将一维时间序列数据集转换为与回归估计器兼容的格式。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/4e4c8cde443d9b5b24fe724ef3be539b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YseywQTxmFzxsc1GEO8OIA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="bb7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，<em class="ls"> make_reduction </em>函数有一个输入“策略”，它控制预测器如何生成其预测。当我们进行不止一步的预测时，该参数是相关的。在我们的例子中，我们预测未来26周的行人数量(多步)，而不仅仅是下一周(一步)。</p><p id="73d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的多步预测策略有三个选项可供选择:</p><ul class=""><li id="4c1d" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated"><strong class="ky ir">直接</strong>:我们为我们预测的每个时期创建一个单独的模型。在我们的例子中，我们拟合了26个模型，每个模型进行一次预测。</li><li id="4f49" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><strong class="ky ir">递归</strong>:我们拟合单个一步先行模型。然而，我们使用前一个时间步的输出作为后面的输入。例如，我们使用下周的预测作为两周后预测的输入，等等。</li><li id="5653" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><strong class="ky ir">多输出</strong>:一个模型用于在一次预测中预测整个时间序列范围。此选项的使用取决于是否有一个能够预测序列的模型。</li></ul><p id="6703" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，我们将使用递归策略。</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="0717" class="ml lu iq ns b gy nw nx l ny nz">from sktime.forecasting.compose import make_reduction</span><span id="5693" class="ml lu iq ns b gy oa nx l ny nz">forecaster = make_reduction(regressor, window_length=52, strategy="recursive")</span></pre><p id="c2c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以拟合我们的线性回归预测器，并根据我们的测试数据预测26周的行人数量。</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="a10b" class="ml lu iq ns b gy nw nx l ny nz">forecaster.fit(y_train)<br/>y_pred = forecaster.predict(fh)</span></pre><p id="9898" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们相对于训练和测试数据绘制我们的预测，以确定模型的适用性。<em class="ls"> Sktime </em>使用<a class="ae kv" href="https://www.sktime.org/en/stable/api_reference/auto_generated/sktime.utils.plotting.plot_series.html?highlight=plot_series" rel="noopener ugc nofollow" target="_blank"> <em class="ls"> plot_series </em> </a>实用函数使这变得简单。</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="28fc" class="ml lu iq ns b gy nw nx l ny nz">from sktime.utils.plotting import plot_series</span><span id="e309" class="ml lu iq ns b gy oa nx l ny nz">plot_series(y_train['2018-07-01':], y_test, y_pred, labels=["y_train", "y_test", "y_pred"], x_label='Date', y_label='Count pedestrians');</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/158e8babd29a73df736c9cbeea6d5c29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ISHNNYlyC8E-kBpfOyprjQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="d5de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的线性回归预测器似乎给了我们一个合理的拟合。然而，这是一个保守的预测，错过了测试数据的波峰和波谷。</p><p id="e21a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用<a class="ae kv" href="https://www.sktime.org/en/stable/api_reference/auto_generated/sktime.performance_metrics.forecasting.mean_absolute_percentage_error.html" rel="noopener ugc nofollow" target="_blank"><em class="ls">mean _ absolute _ percentage _ error</em></a><em class="ls"/>(MAPE)<em class="ls"/>来评估我们的模型，结果为4.8%。</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="1b91" class="ml lu iq ns b gy nw nx l ny nz">from sktime.performance_metrics.forecasting import mean_absolute_percentage_error</span><span id="db64" class="ml lu iq ns b gy oa nx l ny nz">print('MAPE: %.4f' % mean_absolute_percentage_error(y_test, y_pred, symmetric=False))</span></pre><p id="216b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们把所有这些放在一起，我们的代码看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="658d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看是否可以使用更复杂的算法，比如<em class="ls"> XGBoost </em>，来解决这个问题。</p><h2 id="42a6" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">使用XGBoost <em class="of">和外部输入</em>进行时间序列预测</h2><p id="7630" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated"><a class="ae kv" href="https://xgboost.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> <em class="ls"> XGBoost </em> </a>是一个梯度推进机器的实现，因其速度和性能而流行于表格机器学习任务。我们可以使用<em class="ls"> XGBoost </em>进行时间序列预测，因为它有一个与<em class="ls"> sktime的</em> <em class="ls"> make_reduction </em>函数兼容的<a class="ae kv" href="https://xgboost.readthedocs.io/en/stable/python/python_api.html#module-xgboost.sklearn" rel="noopener ugc nofollow" target="_blank"> <em class="ls"> scikit-learn </em>包装器</a>。</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="5f28" class="ml lu iq ns b gy nw nx l ny nz">from xgboost import XGBRegressor</span><span id="d2b0" class="ml lu iq ns b gy oa nx l ny nz">regressor = XGBRegressor(objective='reg:squarederror', random_state=42)<br/>forecaster = make_reduction(regressor, window_length=52, strategy="recursive")</span></pre><p id="ae48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还将包括外生数据，这是另一个有助于预测的时间序列。让我们包括几个虚拟变量来表示一年中的月份，分成我们的训练集和测试集。</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="28a0" class="ml lu iq ns b gy nw nx l ny nz"># Create an exogenous dataframe indicating the month<br/>X = pd.DataFrame({'month': y.index.month}, index=y.index)<br/>X = pd.get_dummies(X.astype(str), drop_first=True)</span><span id="e6de" class="ml lu iq ns b gy oa nx l ny nz"># Split into train and test<br/>X_train, X_test = temporal_train_test_split(X, test_size=26)</span></pre><p id="d3b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们调用fit和predict方法时，我们包括了外部数据。您可以在<a class="ae kv" href="https://www.sktime.org/en/stable/api_reference/auto_generated/sktime.forecasting.compose.RecursiveTabularRegressionForecaster.html#sktime.forecasting.compose.RecursiveTabularRegressionForecaster.fit" rel="noopener ugc nofollow" target="_blank"><em class="ls">recursivetabularregressionpredictor</em></a>文档中找到更多信息。</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="6bfb" class="ml lu iq ns b gy nw nx l ny nz">forecaster.fit(y=y_train, X=X_train)<br/>y_pred = forecaster.predict(fh=fh, X=X_test)</span></pre><p id="a131" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从视觉上看，我们的预测似乎比我们的线性回归预测更差。当我们看看MAPE时，我们的预期得到了证实，该国经济增长率已升至7.1%。因为我们使用了默认的超参数值，所以<em class="ls"> XGBoost </em>预测器可能是欠拟合的。</p><p id="ca02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的例子将演示我们如何为我们的<em class="ls"> XGBoost </em>预测器调整超参数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/0ea2eeafa1cca6afc06d279adcdb29ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ETrKYUgooWd3snptbqTIAQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="84d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在下面找到这个例子的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="80c9" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">调整我们预测器的超参数</h2><p id="50b6" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">我们的<a class="ae kv" href="https://xgboost.readthedocs.io/en/stable/python/python_api.html#module-xgboost.sklearn" rel="noopener ugc nofollow" target="_blank"> <em class="ls"> XGBRegressor </em> </a>有几个我们可以调优的超参数，如这篇<a class="ae kv" rel="noopener" target="_blank" href="/xgboost-fine-tune-and-optimize-your-model-23d996fab663">文章</a>中所述。我们希望调整预测器的超参数，看看是否可以改善性能。</p><p id="459a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在调整超参数之前，我们必须向数据中添加一个验证集。我们有几个由<em class="ls"> sktime </em>实现的策略，包括一个<a class="ae kv" href="https://www.sktime.org/en/stable/api_reference/auto_generated/sktime.forecasting.model_selection.SingleWindowSplitter.html" rel="noopener ugc nofollow" target="_blank"><em class="ls">single window splitter</em></a>、<a class="ae kv" href="https://www.sktime.org/en/stable/api_reference/auto_generated/sktime.forecasting.model_selection.SlidingWindowSplitter.html" rel="noopener ugc nofollow" target="_blank"><em class="ls">sliding window splitter</em></a>和<a class="ae kv" href="https://www.sktime.org/en/stable/api_reference/auto_generated/sktime.forecasting.model_selection.ExpandingWindowSplitter.html" rel="noopener ugc nofollow" target="_blank"><em class="ls">expanding window splitter</em></a>。为了简单起见，我们将创建一个单一的验证集，其大小与我们的测试集相同。然而，这篇<a class="ae kv" rel="noopener" target="_blank" href="/dont-use-k-fold-validation-for-time-series-forecasting-30b724aaea64">文章</a>解释了各种策略之间的差异。</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="2f08" class="ml lu iq ns b gy nw nx l ny nz">from sktime.forecasting.model_selection import SingleWindowSplitter</span><span id="d2cf" class="ml lu iq ns b gy oa nx l ny nz">validation_size = 26<br/>cv = SingleWindowSplitter(window_length=len(y)-validation_size, fh=validation_size)</span></pre><p id="22e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls"> Sktime </em>实现了两种超参数调优策略:<a class="ae kv" href="https://www.sktime.org/en/stable/api_reference/auto_generated/sktime.forecasting.model_selection.ForecastingRandomizedSearchCV.html" rel="noopener ugc nofollow" target="_blank">随机搜索</a>和<a class="ae kv" href="https://www.sktime.org/en/stable/api_reference/auto_generated/sktime.forecasting.model_selection.ForecastingGridSearchCV.html" rel="noopener ugc nofollow" target="_blank">网格搜索</a>。我们将使用100次迭代的随机搜索。</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="123c" class="ml lu iq ns b gy nw nx l ny nz">from sktime.forecasting.model_selection import ForecastingRandomizedSearchCV</span><span id="6d58" class="ml lu iq ns b gy oa nx l ny nz">param_grid = {<br/>    'estimator__max_depth': [3, 5, 6, 10, 15, 20],<br/>    'estimator__learning_rate': [0.01, 0.1, 0.2, 0.3],<br/>    'estimator__subsample': np.arange(0.5, 1.0, 0.1),<br/>    'estimator__colsample_bytree': np.arange(0.4, 1.0, 0.1),<br/>    'estimator__colsample_bylevel': np.arange(0.4, 1.0, 0.1),<br/>    'estimator__n_estimators': [100, 500, 1000]<br/>}</span><span id="152b" class="ml lu iq ns b gy oa nx l ny nz">regressor = XGBRegressor(objective='reg:squarederror', random_state=42)<br/>forecaster = make_reduction(regressor, window_length=52, strategy="recursive")</span><span id="73b6" class="ml lu iq ns b gy oa nx l ny nz">gscv = ForecastingRandomizedSearchCV(forecaster, cv=cv, param_distributions=param_grid, n_iter=100, random_state=42)</span></pre><p id="f51e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，我们适应并预测。</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="d002" class="ml lu iq ns b gy nw nx l ny nz">gscv.fit(y=y_train, X=X_train)<br/>y_pred = gscv.predict(fh=fh, X=X_test)</span></pre><p id="0424" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这一次，我们可以检查我们的随机搜索对象，看看预测器如何使用超参数的不同组合来执行。</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="3778" class="ml lu iq ns b gy nw nx l ny nz">gscv.cv_results_</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/548d5f447d2d60d06f66995fa9aaadb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t2DV1XWXLbT9j5C3tJW8rA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="0e24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有趣的是，我们的预测者在我们的测试数据上表现更差，正如我们的可视化和MAPE增加到7.8%所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/9aaa4ccb64f6ab71528813e2a32db776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GeD6sF1bg0piF2Y6MkuOjA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="e9fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在下面的示例中找到完整的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="c06b" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">向我们的预测渠道添加组件</h2><p id="a69c" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">我们以前在非平稳数据上训练我们的模型，导致预测不佳。使用<a class="ae kv" href="https://www.statsmodels.org/dev/generated/statsmodels.tsa.seasonal.seasonal_decompose.html" rel="noopener ugc nofollow" target="_blank"> <em class="ls"> statsmodels </em> </a>，我们可以分解我们的行人时间序列来观察趋势和季节性。</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="d095" class="ml lu iq ns b gy nw nx l ny nz">from statsmodels.tsa.seasonal import seasonal_decompose</span><span id="ee4d" class="ml lu iq ns b gy oa nx l ny nz">result = seasonal_decompose(y_train, model='multiplicative')<br/>result.plot()<br/>plt.show()</span></pre><p id="6168" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们假设我们的时间序列是乘法的，而不是加法的，因为我们的时间序列的振荡幅度似乎随着时间的推移而增加。查看下面的分解图，我们看到我们的趋势(第二个子曲线)自2013年年中以来有所增加，并且有一个季节性模式，圣诞节和年中行人流量增加，而1月的第一周流量减少。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/7b2ed802e0cb2ef1971eaf650b9cbee7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*toTsYEpTLWLWwFm8JY8gPg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="e54d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们的预测者的表现可以通过去除时间序列的季节性和趋势性，产生一个更接近平稳的时间序列来提高。<em class="ls"> Sktime </em>包括两个类，<a class="ae kv" href="https://www.sktime.org/en/stable/api_reference/auto_generated/sktime.transformations.series.detrend.Deseasonalizer.html?highlight=deseasonalizer" rel="noopener ugc nofollow" target="_blank"> <em class="ls">去季节器</em> </a>和<a class="ae kv" href="https://www.sktime.org/en/stable/api_reference/auto_generated/sktime.transformations.series.detrend.Detrender.html" rel="noopener ugc nofollow" target="_blank"> <em class="ls">去渲染</em> </a> <em class="ls">，</em>，我们可以将它们纳入我们的预测管道。</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="995c" class="ml lu iq ns b gy nw nx l ny nz">from sktime.forecasting.compose import TransformedTargetForecaster<br/>from sktime.transformations.series.detrend import Deseasonalizer, Detrender<br/>from sktime.forecasting.trend import PolynomialTrendForecaster</span><span id="d882" class="ml lu iq ns b gy oa nx l ny nz">regressor = XGBRegressor(objective='reg:squarederror', random_state=42)</span><span id="4d39" class="ml lu iq ns b gy oa nx l ny nz">forecaster = TransformedTargetForecaster(<br/>    [<br/>        ("deseasonalize", Deseasonalizer(model="multiplicative", sp=52)),<br/>        ("detrend", Detrender(forecaster=PolynomialTrendForecaster(degree=1))),<br/>        ("forecast", make_reduction(regressor, window_length=52, strategy="recursive"),<br/>        ),<br/>    ]<br/>)</span></pre><p id="b93b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用随机网格搜索来调整<em class="ls">去季节化器</em>和<em class="ls">去渲染</em>的参数。例如，我们可以看到加法或乘法模型是否是最好的，或者我们希望使用什么次数的多项式来模拟趋势。</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="f9d9" class="ml lu iq ns b gy nw nx l ny nz">param_grid = {<br/>    'deseasonalize__model': ['multiplicative', 'additive'],<br/>    'detrend__forecaster__degree': [1, 2, 3],<br/>    'forecast__estimator__max_depth': [3, 5, 6, 10, 15, 20],<br/>    'forecast__estimator__learning_rate': [0.01, 0.1, 0.2, 0.3],<br/>    'forecast__estimator__subsample': np.arange(0.5, 1.0, 0.1),<br/>    'forecast__estimator__colsample_bytree': np.arange(0.4, 1.0, 0.1),<br/>    'forecast__estimator__colsample_bylevel': np.arange(0.4, 1.0, 0.1),<br/>    'forecast__estimator__n_estimators': [100, 500, 1000]<br/>}</span><span id="24aa" class="ml lu iq ns b gy oa nx l ny nz">gscv = ForecastingRandomizedSearchCV(forecaster, cv=cv, param_distributions=param_grid, n_iter=100, random_state=42)</span><span id="c678" class="ml lu iq ns b gy oa nx l ny nz"><br/>gscv.fit(y=y_train, X=X_train)<br/>y_pred = gscv.predict(fh=fh, X=X_test)</span></pre><p id="64e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">调整我们的预测管道后，我们可以可视化我们的预测。我们观察到我们的预测更接近我们的趋势数据，这表明从我们的时间序列中去除季节性和趋势提高了我们模型的性能。MAPE降至4.7%，是我们测试的所有车型中表现最好的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/b8bfefdae189c64f0dd46de587fea25a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PNpIuiBBjj29C5sYOqg0fw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="ac28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是这个例子的完整代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure></div><div class="ab cl ok ol hu om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="ij ik il im in"><p id="7b34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Sktime 是一个多功能的库，可以让你使用与scikit-learn兼容的回归模型进行时间序列预测。您可以构建复杂的多步管道，甚至可以与最先进的预测算法相媲美。下次你做预测项目时，不要只使用ARIMA。试一试。</p><p id="9404" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">喜欢你读的书吗？跟着我上<a class="ae kv" href="https://medium.com/@rtkilian" rel="noopener">媒</a>。否则，<a class="ae kv" href="https://twitter.com/rtkilian" rel="noopener ugc nofollow" target="_blank">发微博给我</a>或者在<a class="ae kv" href="https://www.linkedin.com/in/rtkilian/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上加我。</p><p id="e42b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在<a class="ae kv" href="https://github.com/rtkilian/data-science-blogging/blob/main/sktime_regression_forecasting.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到这篇文章中用到的所有代码。</p></div><div class="ab cl ok ol hu om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="ij ik il im in"><p id="5e56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[1]墨尔本市，<a class="ae kv" href="https://data.melbourne.vic.gov.au/Transport/Pedestrian-Counting-System-Monthly-counts-per-hour/b2ak-trbp" rel="noopener ugc nofollow" target="_blank">行人计数系统—每月(每小时计数)</a> (2022)，墨尔本市公开数据，根据知识共享署名3.0澳大利亚发布(CC BY 3.0 AU)</p></div></div>    
</body>
</html>