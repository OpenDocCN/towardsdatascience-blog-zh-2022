<html>
<head>
<title>Report Automation Tips with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python的报告自动化技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/report-automation-tips-with-python-783a9cd58e23#2022-04-26">https://towardsdatascience.com/report-automation-tips-with-python-783a9cd58e23#2022-04-26</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="b6b4" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/automation-with-pywin32" rel="noopener" target="_blank">使用PYWIN32实现自动化</a></h2><div class=""/><div class=""><h2 id="19f1" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">分享一些技巧，让你的自动化脚本更干净，更容易调试。我从一年前写的新秀剧本中了解到</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/b1533758fed2e371cb4413384a56c89e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JCwmaf7NqCjJwsUvOhvarw.jpeg"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">照片由<a class="ae li" href="https://unsplash.com/@amanpreetdeol1?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Amanpreet Deol </a>在<a class="ae li" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="9f57" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">嗯，最近，我正在调试我一年前写的自动化脚本，因为它们不能在新电脑上正常运行。我只是不能停止思考我当时在想什么。总的来说，调试我的脚本是一次有趣而痛苦的经历。哈哈！</p></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><p id="9e97" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我从痛苦的调试经历中学到的第一个教训是:</p><h1 id="287b" class="mm mn iu bd mo mp mq mr ms mt mu mv mw kj mx kk my km mz kn na kp nb kq nc nd bi translated">不要硬编码日期计算变量</h1><p id="91d1" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">通常，自动化脚本被编写为在从ERP系统生成输入报告的当天或第二天填充每周报告。生成的输入报告将总是具有相同的报告名称，并且总是具有报告生成日期的文件名。</p><p id="5a0d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">例如<em class="nj">材料使用报告15042022.xlsx </em>和<em class="nj">材料使用报告22042022.xlsx </em>。报告名称“材料使用报告”应该始终一致，日期格式也应该一致。</p><p id="5581" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在我的例子中，生成的报告通过保存在网络驱动器中或通过电子邮件发送出去来共享。然后，自动化脚本将读取它们并执行所需的转换，比如合并表或旋转。</p><p id="9811" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">所以，我使用<code class="fe nk nl nm nn b">datetime.date.today()</code>函数来获取日期，然后结合需要下载的报告的名称。如果脚本被安排在报告生成的同一天，我将直接使用函数的输出，否则我将使用<code class="fe nk nl nm nn b">timedelta</code>函数来计算实际日期。</p><pre class="kt ku kv kw gu no nn np nq aw nr bi"><span id="e45d" class="ns mn iu nn b gz nt nu l nv nw"># the file is processed on the next day of the file received<br/>file_received_date = datetime.date.today() - timedelta(<em class="nj">days</em> = 1)</span></pre><p id="dc7e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这在开发阶段看起来非常好，但是到了测试阶段，我总是不得不手动调整<code class="fe nk nl nm nn b">timedelta</code>函数的参数来获得正确的日期。经过无数次的测试，我终于意识到，我不应该这样编码。因为脚本每周运行一次，所以我应该能够在一周的任何一天运行脚本来获得输出。例如下面，脚本被安排在每周一。</p><pre class="kt ku kv kw gu no nn np nq aw nr bi"><span id="948e" class="ns mn iu nn b gz nt nu l nv nw"># add 1 day for everyday delayed<br/>day_delay = datetime.date.today().weekday()</span><span id="b121" class="ns mn iu nn b gz nx nu l nv nw"># the process file dated the next day of the file received<br/>date_process_file = datetime.date.today() - timedelta(<em class="nj">days</em> = day_delay)</span></pre><p id="917b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">weekday()函数将以数字形式返回日期的星期几。因为Python索引从零开始，所以一周的第一天，即星期一，用0表示，如下所示。</p><pre class="kt ku kv kw gu no nn np nq aw nr bi"><span id="a5d8" class="ns mn iu nn b gz nt nu l nv nw">Monday: 0<br/>Tuesday: 1<br/>Wednesday: 2<br/>Thursday: 3<br/>Friday: 4<br/>Saturday: 5<br/>Sunday: 6</span></pre><p id="08db" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">因此，如果我在星期二运行脚本，也就是第二天，则date_process_file需要减去一天。</p><p id="68bd" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果我的脚本被安排在周一以外的任何一天，我只需要从day_delay中减去当天的索引，计算如下。day_delay以数字形式返回日期的星期几。</p><pre class="kt ku kv kw gu no nn np nq aw nr bi"><span id="41ce" class="ns mn iu nn b gz nt nu l nv nw"># Scheduling on Wednesday<br/>date_process_file = datetime.date.today() - timedelta(<em class="nj">days</em> = day_delay - 2)</span></pre><p id="cc8c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这背后的逻辑如下图所示。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ny"><img src="../Images/120007d23392bd1b832bfaecadd3a7d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sC_oIwoIPw3tArYObJJWDw.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">图片作者。用Excalidraw创建。</p></figure><p id="5165" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">对于计划在星期一运行的报告，如果我们在星期日运行脚本，我们必须将日期减去6天才能得到星期一的日期，而6是星期日的索引，星期一的索引是0。</p><p id="8933" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">对于计划在周三运行的报告，如果我们在周日运行脚本，我们必须减去4天才能得到周三的日期，而4等于周日的索引减去周三的索引。</p><p id="0af0" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果我们推导出一个公式，它应该是这样的。</p><pre class="kt ku kv kw gu no nn np nq aw nr bi"><span id="49ed" class="ns mn iu nn b gz nt nu l nv nw">actual_date = datetime.date.today() - timedelta(<em class="nj">days</em> = weekday_script_run - weekday_report_scheduled)</span></pre></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><h1 id="e6b3" class="mm mn iu bd mo mp nz mr ms mt oa mv mw kj ob kk my km oc kn na kp od kq nc nd bi translated">明智地使用复制方法</h1><p id="8cd6" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">我的一个痛点是我当时太懒了。我滥用了PyWin32复制方法。当我被指派自动执行每周报告时，已经有旧的报告设置了格式。因此，我只是将上周报告的格式复制并粘贴到由我的自动化脚本生成的新工作簿中。</p><pre class="kt ku kv kw gu no nn np nq aw nr bi"><span id="27ac" class="ns mn iu nn b gz nt nu l nv nw"># copy paste FORMAT only, which includes font colour, fill colour, and border<br/>wb2.Sheets(sheetname).Range("A:D").Copy()<br/>wb.Sheets(sheetname).Range("A1").PasteSpecial(Paste=win32c.xlPasteFormats)</span></pre><p id="4cfc" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">一切都很好，直到用户希望在新报告中添加一个新列。这意味着我的复制粘贴技巧不能再用了，否则格式将会完全不匹配🤣。</p><p id="5ac8" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这是我学到的第二课:</p><blockquote class="oe"><p id="d0ce" class="of og iu bd oh oi oj ok ol om on me dk translated">明智地使用复制方法</p></blockquote><p id="adfb" class="pw-post-body-paragraph lj lk iu ll b lm oo ke lo lp op kh lr ls oq lu lv lw or ly lz ma os mc md me in bi translated">在您编写脚本将任何内容复制粘贴到新报告之前，请三思！复制-粘贴就像硬编码任何Python变量一样。总是回顾你试图复制粘贴的部分，并彻底思考如果将来有新的需求，这是否会受到影响。</p><p id="3af8" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果您想知道我是如何解决这个问题的，我会显式地对格式进行编码🤣。</p><pre class="kt ku kv kw gu no nn np nq aw nr bi"><span id="c971" class="ns mn iu nn b gz nt nu l nv nw">wb.Sheets(sheetname).Columns("A:A").AutoFit()<br/>wb.Sheets(sheetname).Columns("B:B").ColumnWidth = 19.71<br/>wb.Sheets(sheetname).Columns("C:C").ColumnWidth = 43<br/>wb.Sheets(sheetname).Columns("D:I").AutoFit()<br/>wb.Sheets(sheetname).Columns("J:N").ColumnWidth = 23</span></pre><p id="6d9e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在解决这个问题的过程中，我还学习了一些可以用Python实现的Excel格式。</p><h2 id="f1dc" class="ns mn iu bd mo ot ou dn ms ov ow dp mw ls ox oy my lw oz pa na ma pb pc nc ja bi translated">文字换行</h2><pre class="kt ku kv kw gu no nn np nq aw nr bi"><span id="a31f" class="ns mn iu nn b gz nt nu l nv nw">wb.Sheets(sheetname).Range("B1").WrapText = True</span></pre><h2 id="487c" class="ns mn iu bd mo ot ou dn ms ov ow dp mw ls ox oy my lw oz pa na ma pb pc nc ja bi translated">设置边框线条样式</h2><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pd pe l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">作者要点</p></figure><p id="f62a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在第12行，<code class="fe nk nl nm nn b">Range(select_table, select_table.End(win32c.xlDown))</code>将选择Excel文件中的整个表格，因此我们不需要指定最后一行。第一个参数<code class="fe nk nl nm nn b">select_table </code>是指表格的第一行，第二个参数<code class="fe nk nl nm nn b">select_table.End(win32c.xlDown)</code>将根据第一列选择行，当第一列为空时停止。</p></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><h1 id="2565" class="mm mn iu bd mo mp nz mr ms mt oa mv mw kj ob kk my km oc kn na kp od kq nc nd bi translated">修复系统生成的Excel文件，该文件不能被使用PyWin32的熊猫读取</h1><p id="df6e" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">这是指如下的类型错误。</p><pre class="kt ku kv kw gu no nn np nq aw nr bi"><span id="be75" class="ns mn iu nn b gz nt nu l nv nw">TypeError: expected &lt;class 'openpyxl.styles.fills.Fill'&gt;</span></pre><p id="99c4" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">因此，Excel文件可以直接在我的笔记本电脑上打开，但无论我如何尝试，熊猫都无法读取。然后，最终，我解决了这个问题，我想是以一种不太聪明的方式🤣。这是StackOverFlow平台上存在的一个问题，人们建议恢复到旧版本的OpenPyXL或将文件重新保存为XLS文件类型。</p><p id="530b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我确实尝试过恢复到旧版本的OpenPyXL，但是没有解决错误。我还试着安装了与我在旧PC上安装的版本相同的所有软件包，在旧PC上脚本仍然可以工作，但在新PC上仍然出现相同的错误。</p><p id="30e5" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">然后，我尝试建议的第二种解决方案，即将文件重新保存为XLS文件。不幸的是，它导致了另一个错误如下。</p><pre class="kt ku kv kw gu no nn np nq aw nr bi"><span id="2245" class="ns mn iu nn b gz nt nu l nv nw">XLRDError: Workbook is encrypted</span></pre><p id="bc85" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我试着通读微软的文档，但是仍然不能保存未加密的文件。当我几乎要放弃的时候，我试着将文件重新保存为CSV文件，它运行得非常好！</p><pre class="kt ku kv kw gu no nn np nq aw nr bi"><span id="05e5" class="ns mn iu nn b gz nt nu l nv nw">import win32com.client as win32<br/>import pandas as pd<br/>win32c = win32.constants<br/>import pandas as pd</span><span id="a609" class="ns mn iu nn b gz nx nu l nv nw">file_xlsx = r"the original file<em class="nj">.</em>xlsx"<br/>file_csv = r"the new file<em class="nj">.</em>csv"</span><span id="5c82" class="ns mn iu nn b gz nx nu l nv nw"># create excel object<br/>excel = win32.gencache.EnsureDispatch('Excel.Application')</span><span id="a175" class="ns mn iu nn b gz nx nu l nv nw"># excel can be visible or not<br/>excel.Visible = True  # False<br/>wb = excel.Workbooks.Open(file_xlsx_local)</span><span id="76e7" class="ns mn iu nn b gz nx nu l nv nw">wb.SaveAs(file_csv, win32c.xlCSV, win32c.xlLocalSessionChanges, win32c.xlExclusive)</span><span id="5583" class="ns mn iu nn b gz nx nu l nv nw">wb.Close()<br/>excel.Quit()</span><span id="be2c" class="ns mn iu nn b gz nx nu l nv nw"># read the resaved file<br/>df_csv = pd.read_csv(file_csv, <em class="nj">encoding</em>='windows-1252', <em class="nj">low_memory</em>=False)</span></pre><p id="aacc" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">该文件需要一个特殊的编码来读取，但现在一切都解决了😉。</p><p id="8490" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我把这个问题添加到我的课程中的原因是，我的学长建议我把它保存为一个新文件，但我一开始并没有认真对待。如果我直接在我的笔记本电脑上打开文件，并将其保存为不同的文件，它可以工作。但是，我觉得我甚至不能用熊猫来阅读它，我怎么能把它保存为另一个文件。</p><p id="3e3d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在挣扎了几个小时后，我意识到我所需要的就是使用PyWin32打开文件并将其保存为另一个文件。这是因为PyWin32通过访问Window的组件对象模型(COM)[1][2]来访问Excel文件。</p><p id="5271" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">所以，这里学到的一课是认真对待学长的建议，他们是学长是有原因的。此外，我应该在写剧本的时候保持创造性。</p></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><p id="6f5d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">以上是我在调试脚本时学到的三点经验。</p><blockquote class="oe"><p id="2959" class="of og iu bd oh oi oj ok ol om on me dk translated">你经历过类似的事情吗？</p></blockquote><p id="81d5" class="pw-post-body-paragraph lj lk iu ll b lm oo ke lo lp op kh lr ls oq lu lv lw or ly lz ma os mc md me in bi translated">让我知道我并不孤单！🤣</p><h1 id="2c59" class="mm mn iu bd mo mp mq mr ms mt mu mv mw kj mx kk my km mz kn na kp nb kq nc nd bi translated">写一个干净的Python代码</h1><p id="271a" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">最后，我很感激我在写这个脚本之前阅读了干净代码的概念。我稍微干净的代码允许我在我第一次写代码1年后很快赶上我的代码(仍然有很大的改进空间😁).</p><p id="458a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我忘了我是在哪里读到的，但是我相信你在学习编程的时候，在某个地方看到过关于编写干净代码的文章或视频。比如<a class="ae li" href="https://dev.to/alexomeyer/10-must-know-patterns-for-writing-clean-code-with-python-56bf" rel="noopener ugc nofollow" target="_blank">这是我最近看的</a>的一篇。</p><p id="9058" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">对于编写干净的代码，有各种版本的建议。对我来说，最重要的概念是保持变量和函数名的可解释性。名称应该是描述性的，易于阅读。因此，应该避免含糊的缩写形式。</p></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><h1 id="3a5c" class="mm mn iu bd mo mp nz mr ms mt oa mv mw kj ob kk my km oc kn na kp od kq nc nd bi translated">保持联系</h1><p id="6f21" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">订阅<a class="ae li" href="https://www.youtube.com/channel/UCiMtx0qbILP41Ot-pkk6eJw" rel="noopener ugc nofollow" target="_blank"> YouTube </a></p><h1 id="216a" class="mm mn iu bd mo mp mq mr ms mt mu mv mw kj mx kk my km mz kn na kp nb kq nc nd bi translated">边注</h1><p id="c5d3" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">在<a class="ae li" rel="noopener" target="_blank" href="/automate-excel-with-python-7c0e8c7c6256">用Python自动化Excel</a>中，我解释了Excel VBA的<strong class="ll je">对象、方法和属性</strong>。这是使用<code class="fe nk nl nm nn b">pywin32</code>时你必须知道的3个主要概念。</p><p id="5a68" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果您有兴趣<strong class="ll je">自动化数据透视表，并从数据透视表中提取过滤后的数据到pandas DataFrame </strong>，那么您可以使用<a class="ae li" href="https://kahemchu.medium.com/automate-excel-with-python-pivot-table-899eab993966" rel="noopener">用Python自动化数据透视表(创建、过滤和提取)</a>。</p><p id="3738" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果你的工作使用Google Sheets而不是Microsoft Excel，你可以参考这篇文章，“<a class="ae li" rel="noopener" target="_blank" href="/automate-google-sheet-reporting-in-5-minutes-8bbdc1f8e293">自动化Google Sheet Report </a>”来了解可能的自动化。</p><h2 id="4c56" class="ns mn iu bd mo ot ou dn ms ov ow dp mw ls ox oy my lw oz pa na ma pb pc nc ja bi translated">参考</h2><ol class=""><li id="bcb9" class="pf pg iu ll b lm ne lp nf ls ph lw pi ma pj me pk pl pm pn bi translated"><a class="ae li" href="https://support.microsoft.com/en-us/topic/excel-com-add-ins-and-automation-add-ins-91f5ff06-0c9c-b98e-06e9-3657964eec72" rel="noopener ugc nofollow" target="_blank"> Excel COM加载项和自动化加载项</a></li><li id="02f8" class="pf pg iu ll b lm po lp pp ls pq lw pr ma ps me pk pl pm pn bi translated"><a class="ae li" href="https://pbpython.com/windows-com.html" rel="noopener ugc nofollow" target="_blank">Chris moff ITT著</a></li></ol></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><p id="429d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><em class="nj">祝贺并感谢你阅读到最后。希望你喜欢这篇文章。</em>😊</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pt"><img src="../Images/5637b5a3d0628324461a7c0065ef8c14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kr03plGZSjAX4SRnXJbygg.jpeg"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">照片由<a class="ae li" href="https://unsplash.com/@cmhedger?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Courtney hedge</a>在<a class="ae li" href="https://unsplash.com/s/photos/thank-you?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div></div>    
</body>
</html>