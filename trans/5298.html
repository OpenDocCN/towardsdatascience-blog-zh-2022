<html>
<head>
<title>What are CTEs in SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL 中的 cte 是什么</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/cte-sql-945e4b461de3#2022-11-28">https://towardsdatascience.com/cte-sql-945e4b461de3#2022-11-28</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="a3c1" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">了解 SQL 中的公用表表达式(CTE)</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/bf48c9bc557477057a30bf2d02fde831.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YpFLpJaxkfSiCi57JAB8FQ.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@sunder_2k25?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Sunder Muthukumaran </a>在<a class="ae kz" href="https://unsplash.com/s/photos/sql?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="ee11" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">编写清晰、易读和高效的 SQL 查询是团队中任何工程或分析过程的一个重要方面。这种查询可以有效地维护，并且在适当的时候可以很好地扩展。</p><p id="93fc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了实现这一点，开发人员和分析人员都可以轻松采用的一个 SQL 结构是通用表表达式(CTE)。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h2 id="bf0d" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">常用表表达式</h2><p id="36e9" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">公用表表达式(CTE)是一种构造，用于临时存储指定查询的结果集，以便后续查询可以引用它。CTE 的结果<strong class="lc iv">不是持久存储在磁盘</strong>上，而是其生命周期持续到引用它的查询的执行。</p><p id="6e6b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">用户可以利用 cte，将复杂的查询分解成更容易维护和阅读的子查询。此外，公共表表达式可以在一个查询中被多次引用，这意味着您不必重复。假定 cte 是命名的，这也意味着用户可以让读者清楚地知道一个特定的表达式应该返回什么结果。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h2 id="76f0" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">构造公共表表达式</h2><p id="c3fc" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">每个 CTE 都可以使用<code class="fe nb nc nd ne b">WITH &lt;cte-name&gt; AS</code>子句来构造</p><pre class="kk kl km kn gu nf ne ng bn nh ni bi"><span id="147c" class="nj me iu ne b be nk nl l nm nn">WITH sessions_per_user_per_month AS (<br/>    SELECT<br/>      user_id,<br/>      COUNT(*) AS no_of_sessions,<br/>      EXTRACT (MONTH FROM session_datetime) AS session_month,<br/>      EXTRACT (YEAR FROM session_datetime) AS session_year<br/>    FROM user_sessions<br/>    GROUP BY user_id<br/>)</span></pre><p id="da97" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在一个查询中可以指定多个 cte，每个 cte 之间用逗号分隔。cte 也可以引用其他 cte:</p><pre class="kk kl km kn gu nf ne ng bn nh ni bi"><span id="5dea" class="nj me iu ne b be nk nl l nm nn">WITH sessions_per_user_per_month AS (<br/>    SELECT<br/>      user_id,<br/>      COUNT(*) AS no_of_sessions,<br/>      EXTRACT (MONTH FROM session_datetime) AS session_month,<br/>      EXTRACT (YEAR FROM session_datetime) AS session_year<br/>    FROM user_sessions<br/>    GROUP BY user_id<br/>),<br/>running_sessions_per_user_per_month AS (<br/>    SELECT<br/>      user_id, <br/>      SUM(no_of_sessions) OVER (<br/>        PARTITION BY <br/>          user_id, <br/>          session_month, <br/>          session_year<br/>      ) AS running_sessions<br/>    FROM sessions_per_user_per_month<br/>)</span></pre><p id="6c10" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后，后续查询可以像任何表或视图一样引用 cte:</p><pre class="kk kl km kn gu nf ne ng bn nh ni bi"><span id="dc3a" class="nj me iu ne b be nk nl l nm nn">WITH sessions_per_user_per_month AS (<br/>    SELECT<br/>      user_id,<br/>      COUNT(*) AS no_of_sessions,<br/>      EXTRACT (MONTH FROM session_datetime) AS session_month,<br/>      EXTRACT (YEAR FROM session_datetime) AS session_year<br/>    FROM user_sessions<br/>    GROUP BY user_id<br/>),<br/>running_sessions_per_user_per_month AS (<br/>    SELECT<br/>      user_id, <br/>      SUM(no_of_sessions) OVER (<br/>        PARTITION BY <br/>          user_id, <br/>          session_month, <br/>          session_year<br/>      ) AS running_sessions<br/>    FROM sessions_per_user_per_month<br/>)<br/><br/>SELECT <br/>  u.username,<br/>  u.email<br/>  u.country,<br/>  s.running_sessions<br/>FROM users u<br/>LEFT JOIN sessions_per_user_per_month s<br/>  ON u.user_id = s.user_id<br/>WHERE country = 'US';</span></pre></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h2 id="324f" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">cte 与子查询</h2><p id="98b0" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">通常，使用子查询可以获得相同的结果。顾名思义，子查询是在另一个查询中定义的查询(也称为嵌套查询)。</p><p id="fcf1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有一种误解，认为 cte 往往比子查询执行得更好，但这不是真的。实际上，<strong class="lc iv"> CTE </strong>是一个<strong class="lc iv">语法糖</strong>，这意味着在后台，子查询仍然会被执行，但是在决定是否要编写一个公共表表达式或子查询时，您需要记住一些事情。</p><p id="fcd7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">cte 比嵌套查询更具可读性</strong>。您需要做的不是在一个查询中包含两个或多个查询，而是定义一个 CTE 并在后续查询中引用它的名称。</p><p id="9fb2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这意味着<strong class="lc iv">cte 还可以被后续查询多次</strong>重用和引用。对于子查询，您必须一遍又一遍地重写相同的查询。</p><p id="d397" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，<strong class="lc iv"> CTE 可以是递归的</strong>，这意味着它<strong class="lc iv">可以引用自身</strong>。递归 cte 的语法与用于指定非递归 cte 的语法有些不同。您将需要使用<code class="fe nb nc nd ne b">WITH RECURSIVE</code>来指定它，并使用<code class="fe nb nc nd ne b">UNION ALL</code>来组合递归调用和基础用例(也称为锚)的结果:</p><pre class="kk kl km kn gu nf ne ng bn nh ni bi"><span id="1c16" class="nj me iu ne b be nk nl l nm nn">-- Syntax used for recursive CTEs<br/>WITH RECURSIVE &lt;cte-name&gt; AS (<br/>  &lt;anchor case&gt;<br/>  UNION ALL<br/>  &lt;recursive case&gt;<br/>)</span></pre><p id="a5b8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我现在不打算谈论更多关于递归 cte 的细节，但是我计划在接下来的几天里专门为此写一篇文章，所以一定要订阅下面的内容，并且在它发布的时候得到通知！</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h2 id="78f3" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">最后的想法</h2><p id="f311" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">公共表表达式提供了一种简单而强大的方式来编写干净、可读和可维护的 SQL 查询。用户可以利用这种结构来增强跨查询的可重用性，在某些情况下甚至可以提高性能，因为 CTE(临时结果集)可以被多次引用。</p><p id="14a1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">只要有可能，cte 应该优先于嵌套连接，因为后者会使您的代码混乱，如果需要多次，会使您的代码可读性更差。此外，cte 还可以是递归的，如果需要的话，这是一大优势。</p><p id="4a67" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">尽管存在子查询可以提供比 cte 更大灵活性的用例，但是本文并不打算让您相信子查询是完全无用的！例如，因为 cte 必须在<code class="fe nb nc nd ne b">SELECT</code>子句之前指定，这意味着它们不能在<code class="fe nb nc nd ne b">WHERE</code>子句中使用。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><p id="1b77" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><a class="ae kz" href="https://gmyrianthous.medium.com/membership" rel="noopener"> <strong class="lc iv">成为会员</strong> </a> <strong class="lc iv">阅读介质上的每一个故事。你的会员费直接支持我和你看的其他作家。你也可以在媒体上看到所有的故事。</strong></p><div class="no np gq gs nq nr"><a href="https://gmyrianthous.medium.com/membership" rel="noopener follow" target="_blank"><div class="ns ab fp"><div class="nt ab nu cl cj nv"><h2 class="bd iv gz z fq nw fs ft nx fv fx it bi translated">通过我的推荐链接加入 Medium-Giorgos Myrianthous</h2><div class="ny l"><h3 class="bd b gz z fq nw fs ft nx fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="nz l"><p class="bd b dl z fq nw fs ft nx fv fx dk translated">gmyrianthous.medium.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of kt nr"/></div></div></a></div></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><p id="676e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">相关文章你可能也喜欢</strong></p><div class="no np gq gs nq nr"><a rel="noopener follow" target="_blank" href="/visual-sql-joins-4e3899d9d46c"><div class="ns ab fp"><div class="nt ab nu cl cj nv"><h2 class="bd iv gz z fq nw fs ft nx fv fx it bi translated">SQL 连接的直观解释</h2><div class="ny l"><h3 class="bd b gz z fq nw fs ft nx fv fx dk translated">用维恩图和实际例子理解 SQL 连接</h3></div><div class="nz l"><p class="bd b dl z fq nw fs ft nx fv fx dk translated">towardsdatascience.com</p></div></div><div class="oa l"><div class="og l oc od oe oa of kt nr"/></div></div></a></div></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu nr"><a rel="noopener follow" target="_blank" href="/dbt-models-structure-c31c8977b5fc"><div class="ns ab fp"><div class="nt ab nu cl cj nv"><h2 class="bd iv gz z fq nw fs ft nx fv fx it bi translated">如何构建您的 dbt 项目和数据模型</h2><div class="ny l"><h3 class="bd b gz z fq nw fs ft nx fv fx dk translated">对 dbt 数据模型实施有意义的结构</h3></div><div class="nz l"><p class="bd b dl z fq nw fs ft nx fv fx dk translated">towardsdatascience.com</p></div></div><div class="oa l"><div class="oh l oc od oe oa of kt nr"/></div></div></a></div></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu nr"><a rel="noopener follow" target="_blank" href="/sql-select-distinct-277c61012800"><div class="ns ab fp"><div class="nt ab nu cl cj nv"><h2 class="bd iv gz z fq nw fs ft nx fv fx it bi translated">DISTINCT 不是 SQL 函数</h2><div class="ny l"><h3 class="bd b gz z fq nw fs ft nx fv fx dk translated">在 SQL 中使用 DISTINCT 关键字时，括号的使用如何会导致混淆</h3></div><div class="nz l"><p class="bd b dl z fq nw fs ft nx fv fx dk translated">towardsdatascience.com</p></div></div><div class="oa l"><div class="oi l oc od oe oa of kt nr"/></div></div></a></div></div></div>    
</body>
</html>