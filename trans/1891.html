<html>
<head>
<title>DT plot: Finding the Optimal Discrimination Threshold for Binary Classifier</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DT图:寻找二元分类器的最佳区分阈值</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dt-plot-finding-the-optimal-discrimination-threshold-for-binary-classifier-c3f326d6326f#2022-05-02">https://towardsdatascience.com/dt-plot-finding-the-optimal-discrimination-threshold-for-binary-classifier-c3f326d6326f#2022-05-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6b49" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">学习如何使用一个鲜为人知但非常重要的诊断图</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a2cf5e37522f2de92ec4da8d0220bdce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lCFu3YCO_PooDpcP"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Alex Padurariu 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d1f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">典型的机器学习任务的实质部分与训练算法相关，该算法将输入数据分配给两个预定义标签中的一个。这种算法通常被称为<strong class="ky ir">二元分类器</strong>。有多种方法可以直观显示这种分类器的性能，可以说最常用的工具是<strong class="ky ir">接收器操作特性(ROC) </strong>和<strong class="ky ir">精确召回(PR) </strong>曲线。</p><p id="1748" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">来自这两个图的洞察力几乎是相同的，但是有时一个比另一个更受青睐。根据经验，当具有真正阳性标记的观察值很少时，那么PR曲线是优选的。另一方面，ROC曲线似乎在商业演示中更受欢迎，这可能是由于仅用一个度量来表达模型性能的直观吸引力:曲线下面积(<strong class="ky ir"> AUC </strong>)。在任何情况下，这两个图，无论在选择最佳性能模型时多么有用，都不能决定性地回答随后的问题:<em class="ls">我们应该将否定预测与肯定预测的分界点放在哪里</em>？这种分界点的默认值是0.5，这通常不是最佳值，尤其是在处理不平衡的数据集时。我们将在这里描述的可视化工具，称为<strong class="ky ir">辨别阈值</strong> <strong class="ky ir"> (DT)图</strong>，有助于找到该截止点的最佳值。</p><p id="8c27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本帖中，我们将:</p><ul class=""><li id="8e59" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">了解如何使用DT图找到二元分类器的最佳区分阈值(只是上述临界值的另一个名称)</li><li id="0f84" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">展示一个简单的交互式DT绘图版本，您可以下载并将其用作项目的模板。</li></ul><p id="44ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们将只检查关键的代码片段，但是你可以在Github 上找到整个项目。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h2 id="cd84" class="mo mp iq bd mq mr ms dn mt mu mv dp mw lf mx my mz lj na nb nc ln nd ne nf ng bi translated"><strong class="ak">数据集和模型</strong></h2><p id="6bee" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">在跳到情节和它的解释之前，让我们首先在UCI的信用卡客户数据集的<a class="ae kv" href="http://archive.ics.uci.edu/ml/datasets/default+of+credit+card+clients" rel="noopener ugc nofollow" target="_blank">违约上训练一个分类模型。由于相同的数据集也位于</a><a class="ae kv" href="https://www.openml.org/search?type=data&amp;status=active&amp;id=42477" rel="noopener ugc nofollow" target="_blank"> OpenML的存储库</a>中，我们可以通过scikit-learn的OpenML接口轻松加载这些数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="50c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">构建性能最佳的预测模型不是这篇文章的目标，所以我们将保持简单，坚持使用基本的随机森林分类器，对分类预测器进行顺序编码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="371f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，我们必须记住，DT图的静态和动态版本都是这样设计的，它们以模型本身而不是预测作为参数。此外，该模型将在数据集的不同子样本上进行多次训练和测试。这意味着我们必须以这样一种方式转换数据，即在每次拆分之后，训练集中的每个分类列都已经知道它可以在看不见的测试集中取的所有值。实现这一点的一种方法是应用分层随机分裂，但我们的数据集包含几个分类列，对所有这些列进行分层会很复杂(也可能不那么随机)。另一个策略是显式地将名义列转换成具有预定义无序值的<a class="ae kv" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.CategoricalDtype.html" rel="noopener ugc nofollow" target="_blank"> pandas的categorical type</a>，这样，每当某个列的某个值在训练集中不存在时，在测试集中接收这样的值不会导致错误地分配标签或任何其他逻辑错误。下面的函数<em class="ls"> transform_data() </em>就是这样做的。然而，要用第二种方法对数据进行编码，在继续建模之前，我们必须知道每个分类列可能取的所有值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h2 id="b191" class="mo mp iq bd mq mr ms dn mt mu mv dp mw lf mx my mz lj na nb nc ln nd ne nf ng bi translated"><strong class="ak">主要术语和定义</strong></h2><p id="1dec" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">在深入研究之前，有必要用我们将使用的主要术语的非正式定义来刷新我们的记忆。</p><ul class=""><li id="75a6" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated"><strong class="ky ir">精度:</strong>具有预测阳性标签的真阳性观察值的比例。在我们的例子中，它是那些预测会违约的客户中实际违约的客户的比例。</li><li id="e83d" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><strong class="ky ir">回忆:</strong>也称敏感度，这是预测阳性病例在所有阳性病例中所占的比例。因此，在我们的数据环境中，召回率是预测违约的客户占实际违约客户的比例。</li><li id="c19e" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><strong class="ky ir"> F1得分:</strong>这是精确度和召回率的调和平均值，当我们有一个不平衡的数据集时，这变得特别方便。我向你推荐<a class="ae kv" rel="noopener" target="_blank" href="/an-intuitive-guide-to-the-f1-score-55fe8233c79e">这篇简洁而写得很好的文章</a>，让你了解更多F1分数背后的属性和直觉。下面的公式表明F1分数是精确度和召回率的单调递增函数(也是假阳性和假阴性的单调递减函数)。在其标准形式中，F1分数假设精确度和召回率具有相同的权重(即从业务角度来看同等重要)，但正如下一节所讨论的，它可以扩展为权重不同的形式。</li><li id="83cf" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><strong class="ky ir">排队率:</strong>这是样本中预测阳性标签的比例，即得分大于区分阈值的观察值的份额。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/528b7fa6c7bc92f5203c08bbf9b1d803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U8BusyaKMO11LganLVlv2A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">主要定义(图片由作者提供)</p></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h2 id="ca90" class="mo mp iq bd mq mr ms dn mt mu mv dp mw lf mx my mz lj na nb nc ln nd ne nf ng bi translated">现有实施</h2><p id="e3be" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">在写这篇文章的时候，用Python绘制DT图最常见的方法似乎是一个名为<a class="ae kv" href="https://www.scikit-yb.org/en/latest/api/classifier/threshold.html" rel="noopener ugc nofollow" target="_blank"> Yellowbrick </a>的包中的函数，它包含了一组非常有用(并且通常不常见和被低估)的可视化工具。如果您不熟悉这个包，我强烈建议您阅读它的文档。</p><p id="809e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的代码片段显示了如何绘制该图。如上所述，预测是在函数内部生成的，因此作为一个参数，它采用模型或以模型结尾的管道。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="0dd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，什么是DT剧情呢？它是一个图表，显示了每个阈值和四个性能指标之间的关系:精确度、召回率、F1值和排队率。从下面的图中，我们可以观察到<a class="ae kv" href="https://developers.google.com/machine-learning/crash-course/classification/precision-and-recall" rel="noopener ugc nofollow" target="_blank">提高精度会降低召回率，反之亦然</a>(嗯，当阈值接近1时，精度有时会变得不稳定，但其总体趋势保持上升)。此外，我们可以看到对应于F1分数最大值的垂直虚线，即它是精确度的边际增加(F1分数的导数w.r.t .精确度)等于召回的边际减少(导数w.r.t .召回)的点。</p><blockquote class="np nq nr"><p id="75e7" class="kw kx ls ky b kz la jr lb lc ld ju le ns lg lh li nt lk ll lm nu lo lp lq lr ij bi translated">DT图中最大化F1分数的垂直虚线是最佳辨别阈值。</p></blockquote><p id="ac3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在图中，低于最佳阈值的是0.32，这将分数在前25个百分点中的标签标记为正(即，排队率是0.25)。该阈值的精度和召回值大约为0.47和0.53。DT图还描述了曲线的可变性，即它们的下限和上限，这是多次运行模型的结果。相应地，边界的默认值是第10和第90个百分点，但是这些值可以用函数的<em class="ls">分位数</em>参数来修改。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/f0dc18457e27b3c00ef535fc23269aa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*g9B1ncKij1jQwHQJpC8YiQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用默认值的yellobrick DT图(图片由作者提供)</p></figure><p id="6a6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然在上面的设置中，我们认为精度和召回同等重要(即同等重要)，但我们可以想象一种方法优先于另一种方法的情况。一个典型的例子是脑肿瘤的分类，在某种程度上，尽管导致较低的精度，但具有大的召回率(即低假阴性)被认为优于任何其他配置。如果我们能够量化召回相对于精确度的重要性，我们可以相应地修改F1分数，这将导致不同的最佳阈值。举个例子，假设我们认为召回比精确重要1.5倍。我们要做的就是用参数<em class="ls"> fbeta </em> =1.5调用函数discrimination_threshold()</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="366d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过比较下面的DT图和原始图，我们立即注意到这里的最佳阈值更低了(现在是0.16，而前面的图是0.32)，这也提高了队列速率(大约。现在是50%,而不是之前图中的25%。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/8097e17abb5cd3b3b482241b5307ed5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*qdUT4r8rGiLbkiY86zex-Q.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">当F1分数加权时，Yellobrick的DT图(图片由作者提供)</p></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h2 id="568a" class="mo mp iq bd mq mr ms dn mt mu mv dp mw lf mx my mz lj na nb nc ln nd ne nf ng bi translated"><strong class="ak">仪表盘版</strong></h2><p id="bd13" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">Yellowbrick对DT情节的实现无疑是有用的，但也有几个小缺点，比如缺乏交互性和没有悬停注释。这就是为什么我们构建了一个带有输入部件的交互式仪表盘，它既可以在Jupyter环境中运行，也可以作为一个独立的应用程序运行。此外，仪表板可以在两种模式下获得最佳阈值:<strong class="ky ir">基本模式</strong>(即与Yellowbricks版本中最大F1分数对应的阈值)和<strong class="ky ir">约束模式</strong>，我们将在后面几段描述。</p><p id="c89b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该应用程序是使用Plotly Dash构建的，因为我们希望它既可以在Jupyter笔记本上运行，也可以作为独立的应用程序运行。或者，我们可以使用<a class="ae kv" href="https://panel.holoviz.org" rel="noopener ugc nofollow" target="_blank"> Panel </a>，但是Plotly的生态系统被认为更成熟，也更有据可查。<a class="ae kv" href="https://streamlit.io" rel="noopener ugc nofollow" target="_blank"> Streamlit </a>是另一个吸引人的选择，但不幸的是，在写这篇文章的时候，它不支持Jupyter笔记本。你可以在这里找到主要仪表板框架<a class="ae kv" href="https://medium.datadriveninvestor.com/streamlit-vs-dash-vs-voil%C3%A0-vs-panel-battle-of-the-python-dashboarding-giants-177c40b9ea57#1447" rel="noopener ugc nofollow" target="_blank">的详细对比。</a></p><p id="4d01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的gif图示了仪表板的界面。如果您希望在本地计算机上运行它，可以从上面提到的Github库下载。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/4fdd2fe1cf178e30c3754f4bbbfe52fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0EJdXgvu6C6DLH9zYc7yuA.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">DT绘图的仪表板界面(图片由作者提供)</p></figure><p id="076b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然应用程序的默认基本模式很大程度上模仿了Yellowbricks实现的行为，但受约束模式的逻辑主要是受本文<a class="ae kv" href="https://blog.insightdatascience.com/visualizing-machine-learning-thresholds-to-make-better-business-decisions-4ab07f823415" rel="noopener ugc nofollow" target="_blank">的启发。您可以通过勾选仪表板中的相应复选框来启用约束模式。简而言之，约束模式下的最优阈值取决于三个估计:<br/> 1。<em class="ls">审查能力</em>，即我们有能力审查以确定其是否为真正阳性的预测阳性标签的比例(即我们有能力审核并确定符合贷款条件的贷款申请人的比例)；<br/> 2。<em class="ls">审查一个案例(即一个贷款申请人)的成本</em>；<br/> 3。<em class="ls">回报</em>我们从每一次成功中获得的回报(即从识别通过门槛但不应获得贷款的申请人中获得的收益)。</a></p><p id="cde6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在基本模式中，我们最大化F1分数，而在约束模式中，我们最大化<em class="ls">支付函数</em>(定义如下)，假定最大化该函数的阈值低于审查能力。从形式上看，这种关系是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/c46fa29d7cebfa85a6b0dec9e0e3aa15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*vSxUtKZDg6PcRKWFU4bpSw.png"/></div></figure><p id="b21e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个等式计算每个阈值t的支出函数。参数<em class="ls"> s </em>和<em class="ls"> c </em>通过输入小部件输入，而<em class="ls"> n </em>是数据集的大小，因此这些可以被视为常数。在等式的右边，乘积<em class="ls"> P(t) * s </em>表示每次成功的回报(即默认客户)，经过精度调整(即所有预测阳性中真实阳性的比例)，这使得术语<em class="ls"> (P(t) * s - c) </em>成为每次成功的净回报。此外，由于我们没有将所有的情况都标记为正，我们还通过排队率<em class="ls"> Q(t) </em>来调整净收益，并将乘积乘以观察次数<em class="ls"> n. </em></p><p id="54a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个等式计算使支付函数<em class="ls">PF(t；n，s，c) </em>鉴于其低于审查能力<em class="ls">r</em>；否则，<em class="ls"> r </em>成为最佳判别阈值。</p><p id="ab58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">调用交互剧情的脚本几乎和静态版一样短。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="3d4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在附带的Github资源库中，<a class="ae kv" href="https://github.com/poghostick/discrimination-threshold/blob/main/interactive_discrimination_threshold.py" rel="noopener ugc nofollow" target="_blank"> <em class="ls">模块中定义了准备数据和调用绘图函数的专用方法的类，interactive _ discrimina tion _ threshold . py</em></a><em class="ls">。</em>仪表盘的代码在<a class="ae kv" href="https://github.com/poghostick/discrimination-threshold/blob/main/app.py" rel="noopener ugc nofollow" target="_blank"> <em class="ls"> app.py </em> </a> <em class="ls">中。我试图用每个类属性和方法的详细描述来填充模块内部的文档字符串，所以在这里重复相同的文本会使这篇文章过长。简单地说，类<em class="ls">InteractiveDiscriminationThreshold</em>包含方法<em class="ls"> prepare_data()、_append_metrics()、_get_metrics() </em>和<em class="ls"> plot()、</em>其中:</em></p><ul class=""><li id="f8f8" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated"><em class="ls"> prepare_data() </em>迭代地抽取子样本(带替换)，在其上训练模型，获得测试集预测，然后为每次迭代调用方法<em class="ls">_ append _ metrics()</em>；</li><li id="091e" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><em class="ls"> _append_metrics() </em>创建一个数组，包含所有可能的阈值以及每个阈值的真实标签和预测分数，调用方法<em class="ls">_ get _ metrics()；</em></li><li id="9581" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><em class="ls"> _get_metrics() </em>给定阈值、真实标签和预测分数，计算并返回精度、召回率、F1分数和排队率；</li><li id="c612" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><em class="ls"> plot() </em>在我们用输入值准备好表格后，从app.py调用函数<em class="ls"> build_plot() </em>。</li></ul><p id="7991" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数<em class="ls"> build_plot() </em>大约有350行长，理解它需要一些使用Plotly Dash框架的经验。幸运的是，Plotly是一个文档丰富的库，有一个非常活跃的社区。也就是说，掌握Plotly生态系统需要一定的耐心、承诺和修改代码。</p><h2 id="075c" class="mo mp iq bd mq mr ms dn mt mu mv dp mw lf mx my mz lj na nb nc ln nd ne nf ng bi translated">结论</h2><p id="4fce" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">总而言之，这篇文章有三个要点:</p><ul class=""><li id="84ae" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">在二元分类中，为模型性能选择最佳鉴别阈值与选择和微调最佳候选模型一样重要；</li><li id="c2ed" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">如果你正在寻找一个快速和肮脏的方法来计算和绘制最佳的辨别阈值，那么Yellowbrick的专用功能是你的首选工具；</li><li id="4be2" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">作为一个更好看、功能更丰富、交互性更强的选择，您可以使用来自<a class="ae kv" href="https://github.com/poghostick/discrimination-threshold" rel="noopener ugc nofollow" target="_blank">这个库</a>的仪表盘，并根据您的需求进行定制。</li></ul><p id="5459" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>