<html>
<head>
<title>MLOps: How to Operationalise E-Commerce Product Recommendation System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MLOps:如何运营电子商务产品推荐系统</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/mlops-how-to-operationalise-e-commerce-product-recommendation-system-c755477bde5f#2022-05-25">https://towardsdatascience.com/mlops-how-to-operationalise-e-commerce-product-recommendation-system-c755477bde5f#2022-05-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/498a7d44040a4979bd203d6acdbfb614.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ORAYmV3TXiLougtm"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">照片由<a class="ae jd" href="https://unsplash.com/@jjying?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> JJ英</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><div class=""/><div class=""><h2 id="b340" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">介绍</h2></div><p id="65a7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">电子商务业务中最常见的挑战之一是建立一个性能良好的产品推荐和分类模型。产品推荐器用于向用户推荐相似的产品，从而增加每个用户在平台上花费的时间和金钱。还需要有一个模型来对产品进行正确分类，因为在这些平台上可能会有一些错误分类的产品，特别是在大多数内容是由用户生成的情况下，如分类网站。产品分类模型用于捕捉这些产品，并将它们放回正确的类别，以改善平台上的整体用户体验。</p><p id="6389" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文有两个主要部分。在第一部分中，我们将讨论如何建立一个电子商务产品推荐系统，并将通过一些动手编码练习进行产品分类。在第二部分，我们将讨论如何在一个名为<a class="ae jd" href="http://layer.ai" rel="noopener ugc nofollow" target="_blank">层</a>的MLOps平台的帮助下，通过几个步骤来操作这个项目。</p><h2 id="33ef" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">简要方法</h2><figure class="ml mm mn mo gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mk"><img src="../Images/96bbb657de542af0cec4a087f178c2d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ftsdfx8jbf7bzarexXIy-g.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated"><strong class="bd mp">方法简单明了</strong>(图片由作者提供)</p></figure><p id="8c35" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我相信大多数电子商务平台收集用户的点击流数据，这基本上是一个简单的表格，由3列组成:会话id、产品id和时间戳。实际上，这个表是为您的企业创建本文中描述的产品推荐模型所需的唯一数据。在整个教程中，我们将使用<a class="ae jd" href="https://www.kaggle.com/datasets/tunguz/clickstream-data-for-online-shopping" rel="noopener ugc nofollow" target="_blank">一个公共Kaggle数据集</a> ( <a class="ae jd" href="https://creativecommons.org/publicdomain/zero/1.0/" rel="noopener ugc nofollow" target="_blank"> CC0:公共域</a>)，这是一个电子商务商店的点击流数据，您可以在下面找到链接。[1]</p><div class="ip iq gp gr ir mq"><a href="https://www.kaggle.com/datasets/tunguz/clickstream-data-for-online-shopping" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd jh gy z fp mv fr fs mw fu fw jf bi translated">在线购物的点击流数据</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">在线购物数据集的点击流数据</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">www.kaggle.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne ix mq"/></div></div></a></div><p id="723d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Word2Vec算法是这种方法的核心，用于生成产品嵌入。单词2Vec主要在NLP和文本上下文中使用。在这个上下文中使用单词2Vec有一个类比。产品将被视为一个单词，一系列产品视图(会话)将被视为一个句子。Word2Vec算法的输出将是乘积的数字表示向量。</p><p id="024e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" href="https://app.layer.ai/layer/Ecommerce_Recommendation_System/models/clustering_model" rel="noopener ugc nofollow" target="_blank">在下一步中，这些产品向量被输入K-Means算法，以创建任意数量的产品聚类。</a>这些聚类代表相似产品的分组(分类)。</p><p id="a2b4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在最后一步，我们将从给定产品所属的集群中随机选择一些产品推荐。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="9719" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文更像是一个包含一些编码示例的教程。要了解更多关于这个方法的信息和了解这个项目的故事，我们强烈建议你也阅读这篇文章。</p><div class="ip iq gp gr ir mq"><a rel="noopener follow" target="_blank" href="/ad2vec-similar-listings-recommender-for-marketplaces-d98f7b6e8f03"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd jh gy z fp mv fr fs mw fu fw jf bi translated">Ad2Vec:市场的相似列表推荐器</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">如何在推荐系统领域使用Word2Vec？</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">towardsdatascience.com</p></div></div><div class="mz l"><div class="nm l nb nc nd mz ne ix mq"/></div></div></a></div><h1 id="406c" class="nn ls jg bd lt no np nq lw nr ns nt lz km nu kn mc kp nv kq mf ks nw kt mi nx bi translated">目录</h1><h2 id="abdc" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">第一部分:实践示例</h2><blockquote class="ny nz oa"><p id="7592" class="kv kw ob kx b ky kz kh la lb lc kk ld oc lf lg lh od lj lk ll oe ln lo lp lq ij bi translated">第一步:将csv文件加载到熊猫数据框中</p><p id="b6d0" class="kv kw ob kx b ky kz kh la lb lc kk ld oc lf lg lh od lj lk ll oe ln lo lp lq ij bi translated">第二步:将点击流数据转换成产品视图序列</p><p id="7447" class="kv kw ob kx b ky kz kh la lb lc kk ld oc lf lg lh od lj lk ll oe ln lo lp lq ij bi translated">第三步:使用Word2Vec算法生成产品向量(嵌入)</p><p id="3f29" class="kv kw ob kx b ky kz kh la lb lc kk ld oc lf lg lh od lj lk ll oe ln lo lp lq ij bi translated">步骤四:在产品向量上拟合K-均值模型(嵌入)</p><p id="fb5a" class="kv kw ob kx b ky kz kh la lb lc kk ld oc lf lg lh od lj lk ll oe ln lo lp lq ij bi translated">步骤五:将聚类保存为数据框</p><p id="5cdf" class="kv kw ob kx b ky kz kh la lb lc kk ld oc lf lg lh od lj lk ll oe ln lo lp lq ij bi translated">第六步:获取给定产品的类似产品推荐</p></blockquote><h2 id="2736" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">第二部分:MLOPS</h2><blockquote class="ny nz oa"><p id="c951" class="kv kw ob kx b ky kz kh la lb lc kk ld oc lf lg lh od lj lk ll oe ln lo lp lq ij bi translated">层安装和登录</p><p id="14ea" class="kv kw ob kx b ky kz kh la lb lc kk ld oc lf lg lh od lj lk ll oe ln lo lp lq ij bi translated">图层数据集装饰器</p><p id="98e3" class="kv kw ob kx b ky kz kh la lb lc kk ld oc lf lg lh od lj lk ll oe ln lo lp lq ij bi translated">层模型装饰器</p><p id="e774" class="kv kw ob kx b ky kz kh la lb lc kk ld oc lf lg lh od lj lk ll oe ln lo lp lq ij bi translated">层运行环境模式</p><p id="c204" class="kv kw ob kx b ky kz kh la lb lc kk ld oc lf lg lh od lj lk ll oe ln lo lp lq ij bi translated">集成了层的全笔记本</p></blockquote></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="81b3" class="nn ls jg bd lt no of nq lw nr og nt lz km oh kn mc kp oi kq mf ks oj kt mi nx bi translated">第一部分:实践示例</h1><h2 id="ddf4" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><strong class="ak">第一步:将csv文件加载到熊猫数据框架中</strong></h2><p id="53ba" class="pw-post-body-paragraph kv kw jg kx b ky ok kh la lb ol kk ld le om lg lh li on lk ll lm oo lo lp lq ij bi translated">定义一个名为<em class="ob">的简单函数raw _ session _ based _ click stream _ data</em>，该函数从csv文件所在的位置读取该文件并返回一个Pandas DataFrame <em class="ob">。</em></p><figure class="ml mm mn mo gt is"><div class="bz fp l di"><div class="op oq l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">功能#1:基于原始会话的点击流数据()</p></figure></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><pre class="ml mm mn mo gt or os ot ou aw ov bi"><span id="3183" class="lr ls jg os b gy ow ox l oy oz">raw_clickstream = raw_session_based_clickstream_data()</span><span id="d730" class="lr ls jg os b gy pa ox l oy oz">raw_clickstream.head(5)</span></pre><figure class="ml mm mn mo gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pb"><img src="../Images/360811a23a04a2187d491f4ca06fca24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DxIl8XMuU5Jthy8zVAyNqw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated"><strong class="bd mp">样本数据记录</strong>(图片由作者提供)</p></figure><h2 id="9648" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><strong class="ak">第二步:将点击流数据转换成产品视图序列</strong></h2><p id="eae5" class="pw-post-body-paragraph kv kw jg kx b ky ok kh la lb ol kk ld le om lg lh li on lk ll lm oo lo lp lq ij bi translated">定义一个名为<em class="ob">generate _ sequential _ products</em>的函数，该函数从前一个函数的输出中提取数据帧<em class="ob"> raw_clickstream </em>，并应用一些数据清理，例如重命名一些列并删除只有一个产品视图的会话。之后，它按照<em class="ob"> session_id </em>列对数据进行分组，并为每个会话创建产品列表。在按会话对产品视图进行分组时，使用数据中的<em class="ob"> order </em>列很重要，因为产品视图的序列必须按时间顺序排列。如果您的数据中只有产品视图的时间戳，您应该首先使用时间戳列创建这样一个单独的<em class="ob">订单</em>列。</p><p id="ca12" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">还有一个名为<em class="ob"> remove_consec_duplicates </em>的帮助函数，它从产品视图序列中删除任何连续的重复产品。这尤其重要，因为我们将在下一部分使用Word2Vec算法来生成产品嵌入。您的数据中很可能会有许多连续的重复产品视图，这可能会扭曲算法。</p><figure class="ml mm mn mo gt is"><div class="bz fp l di"><div class="op oq l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">函数# 2:generate _ sequential _ products()</p></figure></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><pre class="ml mm mn mo gt or os ot ou aw ov bi"><span id="927a" class="lr ls jg os b gy ow ox l oy oz">session_based_product_sequences = generate_sequential_products()</span><span id="a5e0" class="lr ls jg os b gy pa ox l oy oz">session_based_product_sequences.head(5)</span></pre><figure class="ml mm mn mo gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pc"><img src="../Images/6579c347d70450c404fd3a394da47e08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4eXmZZtISiWbRXL4C8vDUw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated"><strong class="bd mp">样本数据记录</strong>(图片由作者提供)</p></figure><h2 id="21ed" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">第三步:使用Word2Vec算法生成产品向量(嵌入)</h2><p id="0d79" class="pw-post-body-paragraph kv kw jg kx b ky ok kh la lb ol kk ld le om lg lh li on lk ll lm oo lo lp lq ij bi translated">定义一个名为<em class="ob">create _ product _ embeddings</em>的函数，该函数从先前函数的输出中获取数据帧<em class="ob">session _ based _ product _ sequences</em>，并通过将参数窗口大小设置为5并将嵌入大小设置为10来训练Gensim的Word2vec模型。此函数返回一个两列数据集，其中第一列是产品id，另一列是从Word2Vec模型返回的10维数值向量。</p><figure class="ml mm mn mo gt is"><div class="bz fp l di"><div class="op oq l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">函数#3:创建产品嵌入()</p></figure></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><pre class="ml mm mn mo gt or os ot ou aw ov bi"><span id="4108" class="lr ls jg os b gy ow ox l oy oz">product_ids_and_vectors = create_product_embeddings()</span><span id="5ab2" class="lr ls jg os b gy pa ox l oy oz">product_ids_and_vectors.head(5)</span></pre><figure class="ml mm mn mo gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pd"><img src="../Images/19a239099fdc3232984d873127920da6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qn2uzbiGbPKP-ESSu-kd0g.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated"><strong class="bd mp">样本数据记录</strong>(图片由作者提供)</p></figure><h2 id="90ee" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">步骤四:在产品向量上拟合K-均值模型(嵌入)</h2><p id="cf07" class="pw-post-body-paragraph kv kw jg kx b ky ok kh la lb ol kk ld le om lg lh li on lk ll lm oo lo lp lq ij bi translated">定义一个名为<em class="ob"> fit_kmeans </em>的函数，该函数使用上一步生成的产品向量数据帧<em class="ob"> product_id_and_vectors </em>来训练k均值模型。在下面的代码片段中，我们将聚类数设置为任意数字10。但是，您可以根据平台上应该存在的类别总数来决定集群的数量。</p><p id="06dc" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还创建了两个不同的图，作为另外两个辅助函数的结果:<em class="ob">plot _ cluster _ distribution</em>和<em class="ob"> plot_cluster_scatter。</em>第一个创建了一个可视化图，以条形图的形式显示了集群成员数量的分布，第二个创建了一个散点图，显示了集群在2D空间中是如何形成的，并用黑点标记了它们的质心。</p><figure class="ml mm mn mo gt is"><div class="bz fp l di"><div class="op oq l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">函数#4: fit_kmeans()</p></figure></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><pre class="ml mm mn mo gt or os ot ou aw ov bi"><span id="ce2f" class="lr ls jg os b gy ow ox l oy oz">model = fit_kmeans()</span></pre><figure class="ml mm mn mo gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pe"><img src="../Images/45a4978da4458073fed743268b5bcce9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WiXzuI8N7noMXZMO1GuA6g.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated"><strong class="bd mp">看看这些图在图层上的样子:</strong><a class="ae jd" href="https://app.layer.ai/layer/Ecommerce_Recommendation_System/models/clustering_model#Product-Distribution-over-Clusters" rel="noopener ugc nofollow" target="_blank"><strong class="bd mp">https://app . Layer . ai/Layer/Ecommerce _ Recommendation _ System/models/clustering _ model # Product-Distribution-over-Clusters</strong></a>(图片由作者提供)</p></figure><h2 id="ca88" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">步骤五:将聚类保存为数据框</h2><p id="0f4c" class="pw-post-body-paragraph kv kw jg kx b ky ok kh la lb ol kk ld le om lg lh li on lk ll lm oo lo lp lq ij bi translated">定义一个名为<em class="ob">save _ final _ product _ clusters</em>的函数，该函数创建一个数据帧来存储每个集群的成员列表。该函数使用前一函数的<em class="ob">模型</em>和create_product_embeddings函数输出的<em class="ob"> product_ids_and_vectors </em>数据帧。因为我们之前将聚类数设置为10，所以在我们的例子中，数据集中总共有10行。我们已经知道，在这种情况下，一个集群成员就是一个产品id。</p><figure class="ml mm mn mo gt is"><div class="bz fp l di"><div class="op oq l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">函数#5:保存最终产品群集()</p></figure></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><pre class="ml mm mn mo gt or os ot ou aw ov bi"><span id="e4e7" class="lr ls jg os b gy ow ox l oy oz">cluster_members_df = save_final_product_clusters()</span><span id="e9ba" class="lr ls jg os b gy pa ox l oy oz">cluster_members_df.head(10)</span></pre><figure class="ml mm mn mo gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pf"><img src="../Images/2951e134c4585299a3a35e4ce0a5aa83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4rhQLnLCuAZsda1K1asUjQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated"><strong class="bd mp">样本数据记录</strong>(图片由作者提供)</p></figure><h2 id="dbfa" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">第六步:获取给定产品的类似产品推荐</h2><p id="312f" class="pw-post-body-paragraph kv kw jg kx b ky ok kh la lb ol kk ld le om lg lh li on lk ll lm oo lo lp lq ij bi translated">现在，让我们编写一个代码块，为特定的产品id“A13”获取一些类似的产品推荐。</p><p id="90ab" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为此，首先我们需要从<em class="ob"> product_ids_and_vectors </em>数据帧中获取该产品的代表性数值向量，并将其提供给<em class="ob">模型</em>以获得其分配的集群编号。然后，我们将获取产品“A13”所属的集群的成员列表。最后一步，我们将从该集群中随机选择5个相似的产品，瞧，我们完成了！</p><figure class="ml mm mn mo gt is"><div class="bz fp l di"><div class="op oq l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">演示的代码片段</p></figure><p id="2133" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">输出将类似于:</p><pre class="ml mm mn mo gt or os ot ou aw ov bi"><span id="60ad" class="lr ls jg os b gy ow ox l oy oz">5 Similar Product Recommendations for A13:  ['C17', 'P60', 'C44', 'P56', 'A6']</span></pre><h1 id="d061" class="nn ls jg bd lt no np nq lw nr ns nt lz km nu kn mc kp nv kq mf ks nw kt mi nx bi translated">第二部分:MLOPS</h1><p id="6237" class="pw-post-body-paragraph kv kw jg kx b ky ok kh la lb ol kk ld le om lg lh li on lk ll lm oo lo lp lq ij bi translated"><a class="ae jd" href="http://layer.ai/" rel="noopener ugc nofollow" target="_blank">层</a>是一个协作的机器学习平台，自带一些预定义的功能装饰器。作为用户，你所要做的就是根据你的函数的返回数据类型，用一个层装饰器(<a class="ae jd" href="https://docs.app.layer.ai/docs/sdk-library/dataset-decorator" rel="noopener ugc nofollow" target="_blank">数据集</a> &amp; <a class="ae jd" href="https://docs.app.layer.ai/docs/sdk-library/model-decorator" rel="noopener ugc nofollow" target="_blank">模型</a>装饰器)包装你的Python函数。例如，如果您的函数返回一个数据集，并且您希望Layer跟踪它，那么用Layer <a class="ae jd" href="https://docs.app.layer.ai/docs/sdk-library/dataset-decorator" rel="noopener ugc nofollow" target="_blank"> dataset decorator </a>包装它，Layer将自动开始对您的数据集进行版本控制。模型的步骤也是一样的。如果你的函数返回一个ML模型，那么用层模型装饰器包装它，层将在你每次运行同一个笔记本时自动开始对你的模型进行版本控制。</p><h2 id="d00f" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">层安装和登录</h2><p id="3cd1" class="pw-post-body-paragraph kv kw jg kx b ky ok kh la lb ol kk ld le om lg lh li on lk ll lm oo lo lp lq ij bi translated">让我们从用几行代码安装并登录到层开始。然后，使用<strong class="kx jh"><em class="ob">‘Layer . init(your _ project _ name)’</em></strong>在图层上初始化你的项目。</p><pre class="ml mm mn mo gt or os ot ou aw ov bi"><span id="58b2" class="lr ls jg os b gy ow ox l oy oz">!pip install layer<br/>import layer<br/>from layer.decorators import dataset, model</span><span id="b11e" class="lr ls jg os b gy pa ox l oy oz">layer.login()<br/>layer.init("Ecommerce_Recommendation_System")</span></pre><h2 id="d7cf" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><a class="ae jd" href="https://docs.app.layer.ai/docs/sdk-library/dataset-decorator" rel="noopener ugc nofollow" target="_blank">图层数据集装饰器</a></h2><p id="5310" class="pw-post-body-paragraph kv kw jg kx b ky ok kh la lb ol kk ld le om lg lh li on lk ll lm oo lo lp lq ij bi translated">让我们将本教程中的第一个函数<em class="ob">raw _ session _ based _ click stream _ data</em>用图层数据集装饰器<strong class="kx jh"><em class="ob">' @ dataset(dataset _ name)]'</em></strong>包装起来，并为您的图层数据集命名为:“raw _ session _ based _ click stream _ data”。您还可以使用'<strong class="kx jh"> <em class="ob"> layer.log()' </em> </strong>记录其他类型的数据和数据集，如下面的代码片段所示。</p><figure class="ml mm mn mo gt is"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="da9d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从现在开始，Layer将跟踪从函数返回的数据集，记录其他数据类型以及数据集，并自动对其进行版本控制。这意味着每次运行这个函数，它都会创建一个新版本的数据集。这样，Layer将使您能够在Layer Web UI上看到相同数据集的整个旅程，如下图所示。</p><figure class="ml mm mn mo gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pg"><img src="../Images/ab881d7c764841fe3443495a712fa1a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g8sGDw2gM6cI9TVqb9lJ0Q.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated"><strong class="bd mp">图层数据集页面</strong>截图(图片由作者提供)</p></figure><p id="c207" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以在页面的左侧看到数据集版本的列表，在右侧看到一些数据配置文件信息。在名为“Logged data”的选项卡下，您将看到与数据集一起记录的所有其他数据。</p><h2 id="7781" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><a class="ae jd" href="https://docs.app.layer.ai/docs/sdk-library/model-decorator" rel="noopener ugc nofollow" target="_blank">图层模型装饰器</a></h2><p id="7de8" class="pw-post-body-paragraph kv kw jg kx b ky ok kh la lb ol kk ld le om lg lh li on lk ll lm oo lo lp lq ij bi translated">现在，让我们为模型做同样的过程。这一次，你要用图层模型装饰器<strong class="kx jh"><em class="ob">' @ model(model _ name)]'</em></strong>包装你的模型函数:<em class="ob"> fit_kmeans() </em>，并给你的图层模型起个名字:<em class="ob"> "clustering_model" </em>。您还可以使用'<strong class="kx jh"><em class="ob">layer . log()'</em>【T25]记录其他类型的数据，如下面的代码片段所示。</strong></p><p id="39ef" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上一节第四步中的代码块和下面的代码块之间唯一的区别就是多了3行特定于层的代码。</p><figure class="ml mm mn mo gt is"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="26bd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从现在开始，层将跟踪和版本化你的模型以及记录所有其他数据。它将使您能够比较模型的不同版本，在失败的情况下转换回任何以前的模型版本，并持续监控您的模型性能。这里有一张截图，取自Layer WebUI上的一个模型页面。</p><figure class="ml mm mn mo gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ph"><img src="../Images/1f08f227ebb842b858c0158a10e72667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S6K8ToGGa1XalxM8R8tmAg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated"><strong class="bd mp">图层模型页面截图</strong>(图片由作者提供)</p></figure><h2 id="7f3a" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">层运行环境模式</h2><p id="c81f" class="pw-post-body-paragraph kv kw jg kx b ky ok kh la lb ol kk ld le om lg lh li on lk ll lm oo lo lp lq ij bi translated">该层有两种运行环境模式:本地和远程。</p><p id="2c5b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">本地模式:</strong>在本地模式下，您将像往常一样按照您希望的顺序调用您的函数，代码将使用您自己的计算能力在您的本地计算机上运行。此模式仍会将所有数据记录到图层的远程主机，例如运行过程中创建的数据集或模型。</p><pre class="ml mm mn mo gt or os ot ou aw ov bi"><span id="5fc7" class="lr ls jg os b gy ow ox l oy oz"># LAYER LOCAL MODE</span><span id="1de9" class="lr ls jg os b gy pa ox l oy oz">raw_session_based_clickstream_data()<br/>generate_sequential_products()<br/>create_product_embeddings()<br/>fit_kmeans()<br/>save_final_product_clusters()</span></pre><p id="fda4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">远程模式:</strong>在远程模式下，你将把你所有的Python函数名放入<strong class="kx jh"><em class="ob">‘Layer . run()’</em></strong>中，这将利用层的资源远程运行你的代码。通过这种方式，您可以轻松地利用层机器和GPU的巨大计算能力来运行您的深度学习项目。</p><pre class="ml mm mn mo gt or os ot ou aw ov bi"><span id="bf63" class="lr ls jg os b gy ow ox l oy oz"># LAYER REMOTE MODE</span><span id="70ee" class="lr ls jg os b gy pa ox l oy oz">layer.run([raw_session_based_clickstream_data,<br/>           generate_sequential_products,<br/>           create_product_embeddings,<br/>           fit_kmeans,<br/>           save_final_product_clusters],debug=True)</span></pre><p id="9044" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果在远程模式下使用Layer，建议在装饰签名中显示数据集或模型之间的依赖关系。例如，在下面的示例代码中，模型“clustering_model”依赖于数据集“product_ids_and_vectors”，而数据集“final_product_clusters”依赖于数据集“product_ids_and_vectors”和模型“clustering_model”。</p><pre class="ml mm mn mo gt or os ot ou aw ov bi"><span id="f6f7" class="lr ls jg os b gy ow ox l oy oz">#MODEL DECORATOR WITH DEPENDENCIES</span><span id="2615" class="lr ls jg os b gy pa ox l oy oz">@model("clustering_model",dependencies=[Dataset("product_ids_and_vectors")])</span><span id="b077" class="lr ls jg os b gy pa ox l oy oz"><br/>#DATASET DECORATOR WITH DEPENDENCIES</span><span id="2040" class="lr ls jg os b gy pa ox l oy oz">@dataset("final_product_clusters", dependencies=[Model("clustering_model"), Dataset("product_ids_and_vectors")])</span></pre><p id="16d1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这只是对层的一个快速介绍。有关Layer SDK和其他功能的更多信息，请访问:</p><div class="ip iq gp gr ir mq"><a href="https://docs.app.layer.ai/docs/" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd jh gy z fp mv fr fs mw fu fw jf bi translated">什么是层？|层文档</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">Layer是一个协作的机器学习平台，在这里你可以建立、训练、跟踪和分享你的ML模型。它有助于…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">docs.app.layer.ai</p></div></div></div></a></div><h2 id="1e42" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">集成了层的全笔记本</h2><p id="735e" class="pw-post-body-paragraph kv kw jg kx b ky ok kh la lb ol kk ld le om lg lh li on lk ll lm oo lo lp lq ij bi translated">让我们将所有代码块放在一个python笔记本中。下面是完整版的电商产品推荐系统笔记本，带层集成:</p><div class="ip iq gp gr ir mq"><a href="https://colab.research.google.com/github/layerai/examples/blob/main/recommendation-system/Ecommerce_Recommendation_System.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd jh gy z fp mv fr fs mw fu fw jf bi translated">谷歌联合实验室</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">用于电子商务推荐系统的笔记本</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">colab.research.google.com</p></div></div><div class="mz l"><div class="pi l nb nc nd mz ne ix mq"/></div></div></a></div><p id="edc7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您也可以通过单击下面的链接查看此项目在图层上的外观:</p><div class="ip iq gp gr ir mq"><a href="https://app.layer.ai/layer/Ecommerce_Recommendation_System/" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd jh gy z fp mv fr fs mw fu fw jf bi translated">层</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">电子商务推荐系统</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">app.layer.ai</p></div></div></div></a></div><p id="cfe1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢阅读！您的反馈很有价值。请在下面的评论区和我们分享你的想法。</p><p id="e643" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ob">参考文献:</em></p><ol class=""><li id="47fd" class="pj pk jg kx b ky kz lb lc le pl li pm lm pn lq po pp pq pr bi translated"><em class="ob">apczy ski m .，Bia ow s……s .(2013)发现用户在电子商店中的行为模式——波兰和其他欧洲国家消费者购买行为的比较,《经济研究》,第151期,《信息社会:欧洲和全球视角:公民和消费者的互联网使用和风险》,第</em></li></ol></div></div>    
</body>
</html>