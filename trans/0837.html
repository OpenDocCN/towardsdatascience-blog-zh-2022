<html>
<head>
<title>How we optimized PostgreSQL queries 100x</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们如何将 PostgreSQL 查询优化 100 倍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-we-optimized-postgresql-queries-100x-ff52555eabe#2022-03-08">https://towardsdatascience.com/how-we-optimized-postgresql-queries-100x-ff52555eabe#2022-03-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6a61" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们在 PostgreSQL 中用来加速 SELECT-s 的一些技巧:带冗余条件的左连接、值、扩展统计、主键类型转换、集群、pg_hint_plan + bonus</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ffd1c962406a27eb531c801bd2139ca7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LziWSko-jzcmjmdi67BIEw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@rj2747?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Richard Jacobs </a>在<a class="ae ky" href="https://unsplash.com/s/photos/elephants?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="afc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于 PostgreSQL 优化的帖子数不胜数:兔子洞很深。当我几年前开始编写分析后端时，我已经有了使用 MySQL 和 SQL Server 等其他数据库的经验。尽管如此，我从未如此关注表演。我之前参与的项目要么对处理时间要求不严格(DS/ML)，要么不涉及一次处理许多行(常规的 web 应用程序)。然而这一次，我的疑问是:</p><ul class=""><li id="b725" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">由 3–10 个<code class="fe me mf mg mh b">JOIN</code>通过相关键组成。</li><li id="2fe8" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">产生 10 到 1，000，000 行。</li><li id="a479" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">必须在 UX 规定的时限内执行。</li><li id="a49f" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">无法提示——直到 2021 年底 Cloud SQL——Google Cloud 中托管的 PostgreSQL 支持 pg_hint_plan。</li><li id="bd60" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">不允许直接访问服务器进程，例如，<a class="ae ky" href="https://ardentperf.com/2022/02/10/a-hairy-postgresql-incident/" rel="noopener ugc nofollow" target="_blank">黑掉一些</a> <code class="fe me mf mg mh b"><a class="ae ky" href="https://ardentperf.com/2022/02/10/a-hairy-postgresql-incident/" rel="noopener ugc nofollow" target="_blank">perf</a></code>。因为 PostgreSQL 是托管的。</li></ul><p id="6d41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个 API 端点获取一百万行听起来不是一个好主意，这表明算法或架构存在问题。当然，一切都可以重写和重新设计，但总要付出代价。不幸的是，现在对我们来说太高了。</p><p id="7580" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像对 API 服务器的 Python 代码的优化一样，没有一个神奇的咒语可以解决我们所有的 SQL 性能问题。尽管如此，我还是要提几个对雅典人产生影响的好主意。希望其中一些能对读者有所帮助。当然，我不会在这里泄露神圣的秘密；我希望当我们开始的时候，我已经读了像下面这样的东西。</p><h2 id="7679" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">左连接的隐藏优势</h2><p id="3f6f" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">编写 SQL 的每个人都应该知道<code class="fe me mf mg mh b">INNER JOIN</code>和<code class="fe me mf mg mh b">LEFT JOIN</code>的区别。当公共列相关时，这些书经常忽略连接类型如何影响查询规划器。假设我们有两张表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/44814de1d539cb8ce810e7400bbb2f4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Olun6AR5xJh3aMBd0zy8og.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">pull_requests 通过 merge_commit_id 引用提交。图片作者。</p></figure><p id="15d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">pull_requests</code>包含关于 GitHub 上 pull 请求的记录。<code class="fe me mf mg mh b">commits</code>包含关于 GitHub 上提交的记录。<code class="fe me mf mg mh b">pull_requests</code>中的<code class="fe me mf mg mh b">merge_commit_id</code>引用<code class="fe me mf mg mh b">commits</code>中的{0，1 }–1<code class="fe me mf mg mh b">id</code>。所有的<code class="fe me mf mg mh b">id</code>都有很高的<a class="ae ky" href="https://www.postgresql.org/docs/current/row-estimation-examples.html" rel="noopener ugc nofollow" target="_blank">选择性</a>。给定表之间的内部连接，</p><pre class="kj kk kl km gt nm mh nn no aw np bi"><span id="8649" class="mn mo it mh b gy nq nr l ns nt"><strong class="mh iu">SELECT</strong> pr.*, c.sha <strong class="mh iu">AS</strong> merge_commit_sha<br/><strong class="mh iu">FROM</strong> pull_requests pr<br/>  <strong class="mh iu">INNER JOIN</strong> commits c <strong class="mh iu">ON</strong> pr.merge_commit_id = c.id<br/><strong class="mh iu">WHERE</strong> pr.repository_id <strong class="mh iu">IN</strong> (...)</span></pre><p id="b950" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PostgreSQL 规划器可能会预测少量的结果行，并发出一个<a class="ae ky" href="https://www.postgresql.org/docs/current/planner-optimizer.html#id-1.10.3.8.5" rel="noopener ugc nofollow" target="_blank">嵌套循环连接</a>。发生这种失败是因为 PostgreSQL 不知道我们的 commit <code class="fe me mf mg mh b">id</code> -s 是相关的，并在连接的行计数估计公式中乘以它们的选择性。因此，如果我们处理大约 10k 行，我们的查询性能会严重下降。让我们考虑一个左连接:</p><pre class="kj kk kl km gt nm mh nn no aw np bi"><span id="df2d" class="mn mo it mh b gy nq nr l ns nt"><strong class="mh iu">SELECT</strong> pr.*, c.sha <strong class="mh iu">AS</strong> merge_commit_sha<br/><strong class="mh iu">FROM</strong> pull_requests pr<br/>  <strong class="mh iu">LEFT JOIN</strong> commits c <strong class="mh iu">ON</strong> pr.merge_commit_id = c.id<br/><strong class="mh iu">WHERE</strong> pr.repository_id <strong class="mh iu">IN</strong> (...)</span></pre><p id="6c98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">规划器可能会预测与<code class="fe me mf mg mh b">pull_requests</code>中过滤的行数量相同的结果行，并且会正确地在大约 10k 上调度一个散列左连接。为了避免散列整个<code class="fe me mf mg mh b">commits</code>，我们可以应用我们的领域知识，PRs 和 commits 总是在同一个存储库中。</p><pre class="kj kk kl km gt nm mh nn no aw np bi"><span id="6123" class="mn mo it mh b gy nq nr l ns nt"><strong class="mh iu">SELECT</strong> pr.*, c.sha <strong class="mh iu">AS</strong> merge_commit_sha<br/><strong class="mh iu">FROM</strong> pull_requests pr<br/>  <strong class="mh iu">LEFT JOIN</strong> commits c <strong class="mh iu">ON</strong>     pr.merge_commit_id = c.id<br/>                         <strong class="mh iu">AND</strong> pr.repository_id = c.repository_id<br/><strong class="mh iu">WHERE</strong> pr.repository_id <strong class="mh iu">IN</strong> (...)</span></pre><p id="a6dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个连接条件是人为的，不会改变结果。然而，PostgreSQL 足够聪明，可以散列由与<code class="fe me mf mg mh b">pull_requests</code>相同的<code class="fe me mf mg mh b">repository_id</code> -s 预过滤的<code class="fe me mf mg mh b">commits</code>。我们的查询应该执行得更快，拥有所有必要的索引。</p><p id="95a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的真正优势体现在多层 JOIN-s 上。PostgreSQL 缓存预先过滤的哈希表，合并它们的成本很低，而不可能缓存嵌套循环。结果，当我在生产中从内连接切换到左连接时，性能提高了 10-100 倍。重要提示:如果不能保证不同的连接返回相同的结果，就必须对空值进行后置过滤。</p><h2 id="0c6c" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">散列值</h2><p id="21ac" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">考虑一个典型的“胖入”查询:</p><pre class="kj kk kl km gt nm mh nn no aw np bi"><span id="830c" class="mn mo it mh b gy nq nr l ns nt"><strong class="mh iu">SELECT</strong> *<br/><strong class="mh iu">FROM</strong> pull_requests<br/><strong class="mh iu">WHERE</strong> repository_id <strong class="mh iu">IN</strong> (...over 9000 IDs...)</span></pre><p id="18c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这通常计划为索引或位图扫描。我们可以使用<code class="fe me mf mg mh b">VALUES</code>表达式重写它:</p><pre class="kj kk kl km gt nm mh nn no aw np bi"><span id="296a" class="mn mo it mh b gy nq nr l ns nt"><strong class="mh iu">SELECT</strong> *<br/><strong class="mh iu">FROM</strong> pull_requests<br/><strong class="mh iu">WHERE</strong> repository_id = <strong class="mh iu">ANY</strong>(<strong class="mh iu">VALUES</strong> (101), (102), ...)</span></pre><p id="c515" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PostgreSQL 产生了一个不同的计划，带有值扫描的 HashAggregate 和可能的 Hash Join(如果预测的行数足够大)。这对性能有影响吗？有时确实如此。我发现它在多连接查询中很有用，但只是在计划器没有在所有连接之后安排它的时候。尽管可以使用提示来提升它。我稍后会介绍它们。在我们的产品中，当“它工作”时，典型的加速是 10-100 倍，但同时，当计划者感到困惑时，速度会慢 10-100 倍。</p><p id="dd78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">附注:你不应该直接在 SQL 主体中插入超过 9000 个 id。</p><pre class="kj kk kl km gt nm mh nn no aw np bi"><span id="1c23" class="mn mo it mh b gy nq nr l ns nt"><strong class="mh iu">WHERE</strong> repository_id = <strong class="mh iu">ANY</strong>($1::text::bigint[])</span><span id="b0d4" class="mn mo it mh b gy nu nr l ns nt"><strong class="mh iu">WHERE</strong> repository_id = <strong class="mh iu">ANY</strong>(<strong class="mh iu">SELECT</strong> * <strong class="mh iu">FROM</strong> unnest($1::text::bigint[]))</span><span id="2ad4" class="mn mo it mh b gy nu nr l ns nt">-- where $1 is an argument passed via the binary protocol</span><span id="3069" class="mn mo it mh b gy nu nr l ns nt">$1 = '{...over 9000 IDs...}'</span></pre><p id="972d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意双重造型<code class="fe me mf mg mh b">$1::text::bigint[]</code>。由于推断出<a class="ae ky" href="https://github.com/MagicStack/asyncpg/issues/449#issuecomment-498278718" rel="noopener ugc nofollow" target="_blank"> asyncpg </a> ( <code class="fe me mf mg mh b">a sized iterable container expected (got type 'str')</code>)中的参数类型不正确，直接转换为<code class="fe me mf mg mh b">bigint[]</code>可能会失败。此外，如果用<code class="fe me mf mg mh b">= ANY(ARRAY)</code>替换<code class="fe me mf mg mh b">IN (...)</code>，规划器应该会得到行数的提示，因为后一个构造目前还不清楚。</p><h2 id="8b7e" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">扩展统计</h2><p id="f5bc" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">继续前面的 SQL，让我们在<code class="fe me mf mg mh b">WHERE</code>中添加另一个条件:</p><pre class="kj kk kl km gt nm mh nn no aw np bi"><span id="66d3" class="mn mo it mh b gy nq nr l ns nt"><strong class="mh iu">SELECT</strong> *<br/><strong class="mh iu">FROM</strong> pull_requests<br/><strong class="mh iu">WHERE</strong> repository_id <strong class="mh iu">IN</strong> (...) <strong class="mh iu">AND</strong> merge_commit_id <strong class="mh iu">IN</strong> (...)</span></pre><p id="567c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">repository_id</code>和<code class="fe me mf mg mh b">merge_commit_id</code>都具有高选择性。对于 PostgreSQL 来说，这两列是黑盒，因此它可能会大大低估最终的行数。悲观的行计数预测会导致糟糕的下游计划决策，比如嵌套循环而不是<code class="fe me mf mg mh b">LEFT JOIN commits</code>的散列连接，我们的性能会下降。</p><p id="6b86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题有一个貌似合理的解决方案:<a class="ae ky" href="https://www.postgresql.org/docs/14/planner-stats.html#PLANNER-STATS-EXTENDED" rel="noopener ugc nofollow" target="_blank">扩展统计</a>。</p><pre class="kj kk kl km gt nm mh nn no aw np bi"><span id="7525" class="mn mo it mh b gy nq nr l ns nt"><strong class="mh iu">CREATE STATISTICS</strong> ids_correlation <strong class="mh iu">ON</strong> repository_id, merge_commit_id <strong class="mh iu">FROM</strong> pull_requests;</span></pre><p id="80ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以<code class="fe me mf mg mh b">ids_correlation</code>为动力，PostgreSQL ≥13 会意识到<code class="fe me mf mg mh b">repository_id</code>和<code class="fe me mf mg mh b">merge_commit_id</code>相关，会调整行数估算。</p><p id="9cbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实证明，扩展的统计数据对于纠正规划者的预测特别有用，在这种情况下，我们通过客户账户 ID 进行软分段。同样，我们得到了散列连接而不是嵌套循环和 10-100 倍的加速。</p><h2 id="4fba" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">主键类型很重要</h2><p id="25aa" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我们曾经有一个稍微不同的模式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/a02890995b1b0296115eadc410f90265.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*h9hWaFf-AliuTMuQ19MefQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">具有 varchar 类型的拉请求 id 的旧数据库模式。图片作者。</p></figure><p id="9549" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GitHub 将所谓的节点标识符分配给每个 API 对象，例如 pull 请求。这是一个不透明的字符串:例如，<a class="ae ky" href="https://github.com/athenianco/api-spec/pull/66" rel="noopener ugc nofollow" target="_blank">雅典人/api-spec#66 </a>是<code class="fe me mf mg mh b"><a class="ae ky" href="https://api.github.com/repos/athenianco/api-spec/pulls/66" rel="noopener ugc nofollow" target="_blank">PR_kwDOFlTa5c4zPMUj</a></code>。所以我们很自然地决定使用节点 id 作为主键。一切都很好，直到…</p><p id="590d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直到<a class="ae ky" href="https://github.blog/2021-02-10-new-global-id-format-coming-to-graphql/" rel="noopener ugc nofollow" target="_blank"> GitHub 改变了节点 ID 格式</a>。迁移对我们来说压力很大，我们最终切换到映射到节点 id 的全局整数 id。从我们的错误中吸取教训:不要依赖外部 id，因为你无法控制它们。</p><p id="19c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们的主键变成整数而不是字符串时，我们很高兴这些列的连接速度提高了 2-5 倍。整数消耗的内存更少，比较和哈希的速度更快。毫无疑问，性能提高了这么多。</p><h2 id="929d" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">串</h2><p id="ba24" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">让我们继续拷问<code class="fe me mf mg mh b">pull_requests</code>。</p><pre class="kj kk kl km gt nm mh nn no aw np bi"><span id="a216" class="mn mo it mh b gy nq nr l ns nt"><strong class="mh iu">SELECT</strong> *<br/><strong class="mh iu">FROM</strong> pull_requests<br/><strong class="mh iu">WHERE</strong> repository_id <strong class="mh iu">IN</strong> (...) <strong class="mh iu">AND</strong> number &gt; 1000</span></pre><p id="c408" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们已经有了一个合适的索引:</p><pre class="kj kk kl km gt nm mh nn no aw np bi"><span id="65d1" class="mn mo it mh b gy nq nr l ns nt"><strong class="mh iu">CREATE INDEX</strong> pull_requests_repository_id <strong class="mh iu">ON</strong> pull_requests (repository_id, number)</span></pre><p id="17b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还能做些什么来加快查询速度吗？我知道两个选择:</p><ol class=""><li id="5457" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nw mb mc md bi translated">将<code class="fe me mf mg mh b">SELECT *</code>中提到的列放入<a class="ae ky" href="https://www.postgresql.org/docs/14/indexes-index-only-scans.html" rel="noopener ugc nofollow" target="_blank">覆盖指标</a>的<code class="fe me mf mg mh b">INCLUDE</code>部分。我们会进行索引扫描。</li><li id="1eb6" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu nw mb mc md bi translated"><a class="ae ky" href="https://www.postgresql.org/docs/current/sql-cluster.html" rel="noopener ugc nofollow" target="_blank">通过<code class="fe me mf mg mh b">pull_requests_repository_id</code>对</a>表进行聚类。</li></ol><p id="c74e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果额外列的数量适中，第一个选项是可以的。第二个选项更高级。它利用了通常如何访问表的领域知识。值得注意的是，我们可能对存储库存储的 PRs 感兴趣，并且可能只获取最新的 PRs(由<code class="fe me mf mg mh b">number &gt; 1000</code>建模)。因此我们将索引声明为<code class="fe me mf mg mh b">CLUSTER</code>:</p><pre class="kj kk kl km gt nm mh nn no aw np bi"><span id="920e" class="mn mo it mh b gy nq nr l ns nt"><strong class="mh iu">CLUSTER</strong> pull_requests <strong class="mh iu">USING</strong> pull_requests_repository_id</span></pre><p id="badd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该命令完成后，表记录将根据索引列的顺序在磁盘上重新排列。我们的查询返回的行越多，由于加载的相关数据页面越少，我们节省的 IOPS 就越多。</p><p id="38a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像许多其他人一样，我们在将<code class="fe me mf mg mh b">CLUSTER ... USING</code>集成到产品中时遇到了障碍。必须定期执行该命令，因为 PostgreSQL 无法自动维护集群状态。不幸的是，<code class="fe me mf mg mh b">CLUSTER</code>获得了一个独占的表锁和挂起的读写块。我们的救星是<a class="ae ky" href="https://github.com/reorg/pg_repack" rel="noopener ugc nofollow" target="_blank">pg _ re pack</a>——一个没有锁的轻量级替代品。云 SQL 支持它，我们已经在周末推出了它，并取得了巨大的成功。</p><p id="1676" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe me mf mg mh b">CLUSTER</code>之后，我们的生产速度提高了 2-5 倍；特别是，它有助于必须从磁盘读取缓冲区的冷查询。</p><h2 id="3405" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">pg _ 提示 _ 计划</h2><p id="997b" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated"><a class="ae ky" href="https://wiki.postgresql.org/wiki/OptimizerHintsDiscussion" rel="noopener ugc nofollow" target="_blank"> PostgreSQL 权威一直反对 SQL 提示。</a>情况类似于 Go 中禁止泛型，只不过 13 年后 Go 终于加入了泛型，PostgreSQL 超过 36 还没有加入提示。幸运的是，可以通过 GitHub 上的日本项目<a class="ae ky" href="https://github.com/ossc-db/pg_hint_plan" rel="noopener ugc nofollow" target="_blank"> pg_hint_plan </a>插入提示。云 SQL 从 2021 年末开始支持 pg_hint_plan。</p><p id="1ffc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我确信他们的警告与我的背景无关时，我总是发现做一些作者强烈阻止我做的事情非常令人满意。这种感觉类似于在接受保修损失时越狱你的手机。或者遇到 web 服务的问题时，直接与技术人员交谈，而不是与第一支持热线联系。像政治家一样，软件开发人员喜欢无条件地限制事情，部分原因是他们会发现迫在眉睫的混乱。</p><p id="3c53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">pg_hint_plan 允许很多很酷的技巧。以下是我的荣誉提名。</p><h2 id="0bbf" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">多余的条件在哪里</h2><p id="5b26" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">如果我们给查询添加额外的约束，我们可以加快散列连接的速度。它们不会改变结果，但会减少索引读取。</p><p id="d966" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑关于<strong class="lb iu">左连接</strong>部分的查询。</p><pre class="kj kk kl km gt nm mh nn no aw np bi"><span id="4618" class="mn mo it mh b gy nq nr l ns nt"><strong class="mh iu">SELECT</strong> pr.*, c.sha <strong class="mh iu">AS</strong> merge_commit_sha<br/><strong class="mh iu">FROM</strong> pull_requests pr<br/>  <strong class="mh iu">LEFT JOIN</strong> commits c <strong class="mh iu">ON</strong>     pr.merge_commit_id = c.id<br/>                         <strong class="mh iu">AND</strong> pr.repository_id = c.repository_id<br/><strong class="mh iu">WHERE</strong> pr.repository_id <strong class="mh iu">IN</strong> (...)</span></pre><p id="893a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以这样重写:</p><pre class="kj kk kl km gt nm mh nn no aw np bi"><span id="b6b9" class="mn mo it mh b gy nq nr l ns nt"><strong class="mh iu">SELECT</strong> pr.*, c.sha <strong class="mh iu">AS</strong> merge_commit_sha<br/><strong class="mh iu">FROM</strong> pull_requests pr<br/>  <strong class="mh iu">JOIN</strong> commits c <strong class="mh iu">ON</strong> pr.merge_commit_id = c.id<br/><strong class="mh iu">WHERE</strong> pr.repository_id <strong class="mh iu">IN</strong> (...) <strong class="mh iu">AND</strong> c.repository_id <strong class="mh iu">IN</strong> (...)</span></pre><p id="e274" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我之前提到的，规划器很可能会错误地预测行数，因为它不知道<code class="fe me mf mg mh b">repository_id</code> -s 是相关的。然而，我们有一个超级武器，可以纠正这个预测。</p><pre class="kj kk kl km gt nm mh nn no aw np bi"><span id="bc41" class="mn mo it mh b gy nq nr l ns nt">/*+<br/>  Rows(pr c *100)<br/> */<br/><strong class="mh iu">SELECT</strong> pr.*, c.sha <strong class="mh iu">AS</strong> merge_commit_sha<br/><strong class="mh iu">FROM</strong> pull_requests pr<br/>  <strong class="mh iu">JOIN</strong> commits c <strong class="mh iu">ON</strong> pr.merge_commit_id = c.id<br/><strong class="mh iu">WHERE</strong> pr.repository_id <strong class="mh iu">IN</strong> (...) <strong class="mh iu">AND</strong> c.repository_id <strong class="mh iu">IN</strong> (...)</span></pre><p id="35fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际的乘法因子应该是几个典型查询的平均值。所描述的方法有利也有弊。</p><p id="89c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">👍明确的<code class="fe me mf mg mh b">INNER JOIN</code>更好地表达了意图。</p><p id="3a87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">👍当我们不得不编码<code class="fe me mf mg mh b">INNER JOIN</code>时起作用。</p><p id="2cb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">👎当表中的统计数据发生变化时，我们应该检查乘法因子。实际上，安全总比事后后悔好，所以当行数较低时，过大的值不会降低性能。</p><h2 id="19ab" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">甲骨文预测</h2><p id="2201" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">如果我们使用给定的合并提交散列来搜索 PRs，我们将会遇到常见的错误的行计数估计。</p><pre class="kj kk kl km gt nm mh nn no aw np bi"><span id="2365" class="mn mo it mh b gy nq nr l ns nt"><strong class="mh iu">SELECT</strong> pr.*, c.sha <strong class="mh iu">AS</strong> merge_commit_sha<br/><strong class="mh iu">FROM</strong> pull_requests pr<br/>  <strong class="mh iu">JOIN</strong> commits c <strong class="mh iu">ON</strong> pr.merge_commit_id = c.id<br/><strong class="mh iu">WHERE</strong> c.sha <strong class="mh iu">IN</strong> (...100 items...)</span></pre><p id="8e2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以利用我们的领域知识</p><ol class=""><li id="2da2" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nw mb mc md bi translated"><code class="fe me mf mg mh b">IN</code>仅包含合并提交。</li><li id="30ff" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu nw mb mc md bi translated">每次合并提交映射到一个拉请求。</li></ol><p id="8fa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们将行数设置为<code class="fe me mf mg mh b">IN</code>的大小:</p><pre class="kj kk kl km gt nm mh nn no aw np bi"><span id="abb9" class="mn mo it mh b gy nq nr l ns nt">/*+<br/>  Rows(pr c #100)<br/> */<br/><strong class="mh iu">SELECT</strong> pr.*, c.sha <strong class="mh iu">AS</strong> merge_commit_sha<br/><strong class="mh iu">FROM</strong> pull_requests pr<br/>  <strong class="mh iu">JOIN</strong> commits c <strong class="mh iu">ON</strong> pr.merge_commit_id = c.id<br/><strong class="mh iu">WHERE</strong> c.sha <strong class="mh iu">IN</strong> (...100 items...)</span></pre><h2 id="9ba3" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">超越 set join_collapse_limit=1</h2><p id="678d" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">联接几个表的顺序可能很关键。官方文档提供将连接级参数<code class="fe me mf mg mh b">join_collapse_limit</code>设置为 1，除非你通过 pgbouncer 连接并且物理连接是共享的，否则有效。或者，您不希望锁定整个连接序列，而只锁定几个种子表。或者嵌套顺序不是线性的。继续前面的查询，假设我们通过许多合并提交进行搜索，并决定强制哈希表查找:</p><pre class="kj kk kl km gt nm mh nn no aw np bi"><span id="3338" class="mn mo it mh b gy nq nr l ns nt"><strong class="mh iu">SELECT</strong> pr.*, c.sha <strong class="mh iu">AS</strong> merge_commit_sha<br/><strong class="mh iu">FROM</strong> pull_requests pr<br/>  <strong class="mh iu">JOIN</strong> commits c <strong class="mh iu">ON</strong> pr.merge_commit_id = c.id<br/><strong class="mh iu">WHERE</strong> c.sha = <strong class="mh iu">ANY</strong>(<strong class="mh iu">VALUES</strong> ...) <strong class="mh iu">AND</strong> ...other clauses...</span></pre><p id="122b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">other clauses</code>可能会混淆 PostgreSQL 规划器，所以它在联接两个表后调度 HashAggregate。届时，性能影响将是灾难性的。让我们解决这个问题。</p><pre class="kj kk kl km gt nm mh nn no aw np bi"><span id="1a06" class="mn mo it mh b gy nq nr l ns nt">/*+<br/>  Leading(*VALUES* c pr)<br/> */<strong class="mh iu"><br/>SELECT</strong> pr.*, c.sha <strong class="mh iu">AS</strong> merge_commit_sha<br/><strong class="mh iu">FROM</strong> pull_requests pr<br/>  <strong class="mh iu">JOIN</strong> commits c <strong class="mh iu">ON</strong> pr.merge_commit_id = c.id<br/><strong class="mh iu">WHERE</strong> c.sha = <strong class="mh iu">ANY</strong>(<strong class="mh iu">VALUES</strong> ...) <strong class="mh iu">AND</strong> ...other clauses...</span></pre><p id="8397" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，如果<code class="fe me mf mg mh b">other clauses</code>对<code class="fe me mf mg mh b">pull_requests</code>非常严格，并且我们期望 PRs 少于合并提交散列的数量，我们可以在使用过滤的<code class="fe me mf mg mh b">commits</code>连接之前独立地应用<code class="fe me mf mg mh b">other clauses</code>:</p><pre class="kj kk kl km gt nm mh nn no aw np bi"><span id="0ed9" class="mn mo it mh b gy nq nr l ns nt">/*+<br/>  Leading(pr (*VALUES* c))<br/> */<strong class="mh iu"><br/>...</strong></span></pre><p id="9223" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">Leading</code> hint 是 dope，至今一直是我们的超级英雄。</p><h2 id="fb48" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">无情的指数覆盖</h2><p id="24d9" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">pg_hint_plan 给了我们一把大枪:<code class="fe me mf mg mh b">IndexScan</code>和<code class="fe me mf mg mh b">IndexOnlyScan</code>。这两个因素推翻了计划者使用指数的决定。不幸的是，如果 SQL 或统计数据发生变化，规划器就会偏离正轨，并显示“未定义的行为”示例:</p><pre class="kj kk kl km gt nm mh nn no aw np bi"><span id="664a" class="mn mo it mh b gy nq nr l ns nt"><strong class="mh iu">CREATE INDEX</strong> impossible <strong class="mh iu">ON</strong> pull_requests (merge_commit_id);</span><span id="c8da" class="mn mo it mh b gy nu nr l ns nt">/*+<br/>  IndexScan(pr impossible)<br/> */<br/><strong class="mh iu">SELECT</strong> *<br/><strong class="mh iu">FROM</strong> pull_requests pr<br/><strong class="mh iu">WHERE</strong> repository_id <strong class="mh iu">IN</strong> (...) <strong class="mh iu">AND</strong> number &gt; 1000;</span></pre><p id="7405" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">计划者将发布顺序扫描。如果 autovacuum 跟不上表的写入，那么计划可能看起来完全不可思议，例如，使用正确的索引但忽略索引列并从头开始过滤。无论如何，自动真空滞后是有害的。</p><h2 id="6e45" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">额外奖励:视觉解释</h2><p id="07d7" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">当我需要优化另一个查询时，这是我的谋生之道。我试过几个 web apps，最喜欢的是<a class="ae ky" href="https://explain.tensor.ru" rel="noopener ugc nofollow" target="_blank"> explain.tensor.ru </a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/6e890965b58c68e8d8e8b2e8708692fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V8BI89mMWtM73UY8iLye0Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">explain.tensor.ru 的推荐。图片作者。</p></figure><p id="d93b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">优势:</p><ul class=""><li id="9df7" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">关于修复或调整什么的建议。他们不是微不足道的，并证明对初学者非常有帮助。</li><li id="11ed" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">其他视图，如瓶颈饼图。</li><li id="81b9" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">非常健壮的计划解析器。</li><li id="91ac" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">链接可以存活很多年——对于延期研究非常有用。</li></ul><p id="68a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请在回复中建议其他酷的解释者！</p><h2 id="39bc" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">额外收获:云 SQL 洞察</h2><p id="dde8" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">Google Cloud 推出嵌入云 SQL 的新工具:<a class="ae ky" href="https://cloud.google.com/blog/products/databases/get-ahead-of-database-performance-issues-with-cloud-sql-insights" rel="noopener ugc nofollow" target="_blank">云 SQL Insights </a>。我数不清这个工具救了我们多少次:</p><ul class=""><li id="9db5" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">当我们的后端 DDoS-ed 数据库查询缓慢时，我们不得不在恐慌中尽快修复它。云 SQL 洞察立即指出了杀手级 SQL。</li><li id="f28d" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">当我们的数据检索子系统(镜像来自 GitHub、JIRA 等的数据的子系统。)写得太快，autovacuum 失败，一些表“腐烂”同样，云 SQL Insights 很快指出了什么需要紧急处理<code class="fe me mf mg mh b">VACUUM ANALYZE</code>。</li><li id="a21b" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><a class="ae ky" href="https://betterprogramming.pub/continuous-performance-improvement-of-http-api-86290433aa54" rel="noopener ugc nofollow" target="_blank">增强</a> <a class="ae ky" href="https://sentry.io" rel="noopener ugc nofollow" target="_blank">哨兵</a>的常规性能监控。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/79ee12140d02c6af4c41d552a85bd157.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RdQyTNW-HM3CibEkZVO0MA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">云 SQL Insights —我们生产中过去一小时内最具影响力的查询。我们应该回顾一下我们如何获取释放，该死的。图片作者。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6c8d846211c9d24ada26cab296ee95d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qnPecZJCwFvRYoK0Uu_sFQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">云 SQL 洞察—查询详细信息。应该有人添加一个 Rows 提示来消除嵌套循环。图片作者。</p></figure><h2 id="13b5" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">摘要</h2><p id="55fb" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我介绍了一些 PostgreSQL 查询性能技巧，它们将我们的查询速度提高了 100 倍:</p><ul class=""><li id="a074" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">LEFT JOIN</code>代替了<code class="fe me mf mg mh b">INNER JOIN</code>，帮助规划者做出更准确的行数预测。添加冗余的<code class="fe me mf mg mh b">ON</code>子句改进了散列连接。</li><li id="2c2c" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">= ANY(VALUES ...)</code>而不是<code class="fe me mf mg mh b">IN</code>可以强制一个有很多元素的哈希聚合。</li><li id="8530" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">扩展的统计信息通知规划者有关列的相关性。</li><li id="6c27" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">把表主键做成<code class="fe me mf mg mh b">varchar</code>是个馊主意。</li><li id="d946" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">CLUSTER</code>当查询返回许多相关行时，会出现异常。</li><li id="b713" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">pg_hint_plan 提供了强大的提示，包括估计行数修正<code class="fe me mf mg mh b">Rows</code>，连接序列实施器<code class="fe me mf mg mh b">Leading</code>，以及索引覆盖<code class="fe me mf mg mh b">IndexScan</code>。尽管后者可能会反击。</li><li id="b765" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">我喜欢<a class="ae ky" href="https://explain.tensor.ru" rel="noopener ugc nofollow" target="_blank"> explain.tensor.ru </a>来可视化<code class="fe me mf mg mh b">EXPLAIN</code> -s。</li><li id="045a" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">如果你是云 SQL 用户，云 SQL 洞察是必须的。</li></ul><p id="3b41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将感谢任何反馈和更正。请在媒体上关注我，以获得我下一篇帖子的通知。我写的是应用于软件开发工件的 ML/DS，Python，PostgreSQL。</p><p id="998e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另见:<a class="ae ky" rel="noopener" target="_blank" href="/how-we-optimized-python-api-server-code-100x-9da94aa883c5">我们如何优化 Python API 服务器代码 100x </a>。</p><p id="685d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你是一个渴望建立持续改进软件开发文化的工程领导者，请查看我们的<a class="ae ky" href="https://athenian.co" rel="noopener ugc nofollow" target="_blank"> SaaS 产品网站</a>。</p></div></div>    
</body>
</html>