<html>
<head>
<title>Sign Language Recognition with Advanced Computer Vision</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级计算机视觉手语识别</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sign-language-recognition-with-advanced-computer-vision-7b74f20f3442#2022-08-23">https://towardsdatascience.com/sign-language-recognition-with-advanced-computer-vision-7b74f20f3442#2022-08-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a5ac" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用MediaPipe和Keras实时检测手语字符</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/266bf09afdcac1c1652bfb44c595c47a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Iv-GIxB6KwJpZPaQ"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自Pexels的手语“F”的图像</p></figure><p id="95d0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">手语是一种主要由重听人或聋人使用的交流方式。这种基于手势的语言使人们能够轻松地传达想法和思想，克服听力问题带来的障碍。</p><p id="6412" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种便捷交流方式的一个主要问题是，全球绝大多数人缺乏这种语言的知识。正如任何其他语言一样，学习手语需要花费大量的时间和精力，不利于更多的人学习。</p><p id="2444" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，在机器学习和图像检测领域，这个问题有一个显而易见的解决方案。实现预测模型技术来自动分类手语符号可以用于为虚拟会议(如缩放会议等)创建一种实时字幕形式。这将大大增加有听力障碍的人获得这些服务的机会，因为它将与语音字幕齐头并进，为有听力问题的人创造一个双向在线交流系统。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><p id="fe57" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Kaggle上有许多大型手语训练数据集，这是一个流行的数据科学资源。在这个模型中使用的一个被称为<strong class="kx ir"> <em class="ly"> " </em> </strong> <a class="ae lz" href="https://www.kaggle.com/datasets/datamunge/sign-language-mnist" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="ly">手语MNIST</em></strong></a><strong class="kx ir"><em class="ly">"</em></strong>并且是公共领域免费使用的数据集，具有24个美国手语字母中的每一个的大约1000个图像的像素信息，不包括J和Z，因为它们是基于手势的符号。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/226d95fa91041bacdbc296a456bc8908.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/0*EC2QFI9soQV-qMlY"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">“美国手语字母的各种用户和背景的裁剪图像蒙太奇”来自MNIST手语</p></figure><p id="a9e7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为训练准备数据的第一步是将数据集中的所有像素数据转换并成形为图像，以便算法可以读取这些图像。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="bb1b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的代码从重塑所有MNIST训练图像文件开始，以便模型理解输入文件。与此同时，LabelBinarizer()变量获取数据集中的类并将它们转换为二进制，这一过程大大加快了模型的定型速度。</p><p id="ab32" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下一步是创建数据生成器来随机实现对数据的更改，增加训练示例的数量，并通过向不同的实例添加噪声和变换来使图像更加真实。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="9d98" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">处理完图像后，必须编译CNN模型，以识别数据中使用的所有信息类别，即24组不同的图像。数据的规范化也必须添加到数据中，用较少的图像来平衡类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="ff41" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，算法初始化时添加了变量，如Conv2D模型，并浓缩为24个特性。我们还使用批处理技术让CNN更有效地处理数据。</p><p id="8e06" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，定义损失函数和度量以及将模型拟合到数据将创建我们的手语识别系统。由于构建模型所需的时间长度，在语句末尾识别出<strong class="kx ir"> <em class="ly"> model.save() </em> </strong>命令是很重要的。为每次使用重新训练模型可能需要几个小时的时间。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="6f2a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这段代码有很多东西需要解开。让我们分段来看。</p><p id="0b19" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">第一行:</strong></p><p id="de06" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> <em class="ly"> model.compile() </em> </strong>函数接受许多参数，其中三个显示在代码中。优化器和损失参数与下一行中的epoch语句一起工作，通过递增地改变数据的计算方法来有效地减少模型中的错误量。</p><p id="57b5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">除此之外，选择要优化的度量是精度函数，它确保模型在设定的历元数之后具有可实现的最大精度。</p><p id="6506" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">第4行:</strong></p><p id="73ff" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此处运行的函数使设计的模型符合在第一位代码中开发的图像数据。它还定义了模型为提高图像检测的准确性而必须进行的<strong class="kx ir"> <em class="ly">历元</em> </strong>或迭代次数。这里也称为验证集，向模型引入一个测试方面。该模型使用这些数据计算精确度。</p><p id="09c4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">第5行:</strong></p><p id="89aa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在代码位的所有语句中，<strong class="kx ir"> <em class="ly"> model.save() </em> </strong>函数可能是这段代码中最重要的部分，因为它可能会在实现模型时节省几个小时的时间。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8a7a8d779bb2b3123445cdbeb896e0eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yu75uOn-N8EFoXBd"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自Pexels的手语“X”的图像</p></figure><p id="572f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所开发的模型以大约95%的训练准确度准确地检测和分类手语符号。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><p id="4f45" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，使用两个流行的实时视频处理库Mediapipe和Open-CV，我们可以获取网络摄像头输入，并在实时视频流上运行我们之前开发的模型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/870622da667bc134a627876efb27d7bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HN0e1ezZ5R5ifqpF"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">展示Pexels手语的女性图像</p></figure><p id="6720" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们需要导入程序所需的包。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="e7d3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">开始时运行的OS命令只是阻止来自Mediapipe使用的Tensorflow库的不必要的警告。这使得程序提供的未来输出更加清晰易懂。</p><p id="62e6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在启动代码的主while循环之前，我们需要首先定义一些变量，比如Open-CV的保存模型和相机信息。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="bc1f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里设置的每个变量都被分成四类。开头的类别与我们在本文第一部分中训练的模型直接相关。代码的第二和第三部分定义了运行和启动Mediapipe和Open-CV所需的变量。最后一类主要用于分析检测到的帧，并创建用于图像模型提供的数据的交叉引用的字典。</p><p id="b796" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个程序的下一部分是主while True循环，大部分程序都在这个循环中运行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="d049" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该程序的这一部分从您的相机获取输入，并使用我们导入的图像处理库将输入从设备显示到计算机。这部分代码着重于从你的相机中获取一般信息，并简单地在一个新窗口中显示出来。然而，使用Mediapipe库，我们可以检测手的主要标志，如手指和手掌，并在手周围创建一个边界框。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi md"><img src="../Images/9e039927eb5d2df9975720fc963c827c.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/0*6aEBXcTf3YxIOund.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自Mediapipe的手绘注释图像，作者</p></figure><p id="9599" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">包围盒的概念是所有形式的图像分类和分析的重要组成部分。该框允许模型直接聚焦于功能所需的图像部分。否则，算法会在错误的位置找到模式，并可能导致不正确的结果。</p><p id="1d45" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，在训练过程中，缺少边界框会导致模型将诸如时钟或椅子等图像的特征与标签相关联。这可能导致程序注意到位于图像中的时钟，并且仅基于时钟存在的事实来决定正在显示什么手语字符。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi me"><img src="../Images/09451e2de2f14d74f0d484285a0e97a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*ngWT2fByrbzrHpkG.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">上一个带有高亮显示的时钟的图像，作者</p></figure><p id="3ccf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">快好了！该程序的倒数第二部分是根据提示捕捉单个帧，将其裁剪到边界框的尺寸。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="0b5b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这段代码看起来与程序的最后一部分非常相似。这主要是因为涉及边界框的生产的过程在两个部分中是相同的。然而，在代码的这个分析部分，我们利用Open-CV的图像整形特性将图像调整到边界框的尺寸，而不是在它周围创建一个可视对象。除此之外，我们还使用NumPy和Open-CV来修改图像，使其具有与模型训练图像相同的特征。我们还使用pandas创建一个dataframe，其中包含来自保存的图像的像素数据，因此我们可以像创建模型一样对数据进行规范化。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mf"><img src="../Images/39c8fc25c9db962a5029d053c44a1d89.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/0*S0zOudPJ2C6-GMny.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者修改的手的图像</p></figure><p id="6528" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在代码的顶部，您可能会注意到正在定义的变量的奇数序列。这是由于相机库语法的性质。当Open-CV处理和更改图像时，更改是在所用帧的顶部进行的，本质上是保存对图像所做的更改。多个等值变量的定义使得函数中显示的框架与运行模型的画面分离。</p><p id="733c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我们需要在经过处理的图像上运行经过训练的模型，并处理信息输出。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="2eca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">代码的这一部分包含大量信息。我们将逐一剖析这部分代码。</p><p id="e050" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">前两行绘制了手部图像属于Keras不同类别的预测概率。数据以两个张量的形式呈现，其中第一个张量包含概率信息。张量本质上是特征向量的集合，非常类似于数组。该模型产生的张量是一维的，允许它与线性代数库NumPy一起使用，以将信息解析为更具pythonic式的形式。</p><p id="e8af" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这里，我们利用之前在变量letterpred下创建的类列表来创建一个字典，将张量中的值与键进行匹配。这允许我们将每个字符的概率与其对应的类别相匹配。</p><p id="dfb5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这一步之后，我们使用列表理解从最高到最低对值进行排序。然后，这允许我们获取列表中的前几个项目，并将它们指定为与所示手语图像最接近的3个字符。</p><p id="d25c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我们使用一个for循环遍历字典中的所有key:value对，创建字典是为了将最大值与其对应的键匹配，并打印出每个字符概率的输出。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi me"><img src="../Images/a740a520f814676da33d903335bbb897.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*IdEh9O6q4QpYi9va.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">手语' A '，作者</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/00e21d8e68725200567d7009281995ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*0yoN0UZXpkeukPIC3_rXlQ.png"/></div></figure><p id="940b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如图所示，该模型准确地预测了从摄像机中显示的角色。除了预测字符，该程序还显示了CNN Keras模型的分类置信度。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><p id="ef69" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">开发的模型可以以多种方式实现，主要用途是为涉及视频通信的呼叫提供字幕设备，如Facetime。要创建这样一个应用程序，模型必须一帧一帧地运行，随时预测显示的是什么符号。使用其他系统，我们也可以识别一个人什么时候没有显示任何手势，或者在手势之间转换，从而更准确地判断通过美国手语显示的单词。这种实现可以用来将显示的字母串在一起，最终识别单词甚至句子，从而创建一个全功能的手语文本翻译器。这种设备将极大地方便那些听力障碍者享受虚拟交流的好处。</p><p id="052c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该程序允许通过使用Keras图像分析模型，从手语到英语进行简单方便的交流。该项目的代码可以在我的GitHub个人资料中找到，链接如下:</p><p id="61bf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lz" href="https://github.com/mg343/Sign-Language-Detection" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="ly">mg 343/手语-检测(github.com)</em></strong></a></p></div></div>    
</body>
</html>