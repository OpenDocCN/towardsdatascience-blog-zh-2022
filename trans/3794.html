<html>
<head>
<title>Parse, Don’t Validate | Python Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解析，不验证| Python模式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/parse-dont-validate-f559372cca45#2022-08-23">https://towardsdatascience.com/parse-dont-validate-f559372cca45#2022-08-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="46b7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">验证数据就像看门人一样，将数据解析成有意义的数据类型，为原始数据增加了有价值的信息</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/69f64df8ef7583032df90d24382f51fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*54oeU6qjRt2rvhyC"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@will0629?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">威尔·波拉达</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="5ef6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用处理外部数据的应用程序时，我们通常会设置几层验证和数据转换来保护我们的业务逻辑不会崩溃……或者更糟，成为攻击的受害者。</p><p id="b3a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一层保护包括验证输入数据的一致性及其实际有效性。我们不想让我们的系统受到SQL注入攻击，甚至是无法正确处理的不完整字段。保护信息系统的一种广泛而经典的方法是使用数据验证:我们执行有效性检查，如果它们没有全部通过，那么我们就丢弃传入的数据。</p><p id="0e1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，在本文中，我们将假设已经执行了安全检查，并且我们对数据模型的数据一致性感兴趣。所以就从它开始吧。</p><h1 id="a698" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">简单的例子</h1><p id="3eb5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">假设一家商店要求我们构建一个组件来联系他们的客户。客户可以将她或他的数据插入到表单中，然后收到回复。这些数据包括姓名、电子邮件和电话号码。此外，还有根据所提供的联系类型联系用户的功能。</p><p id="8cd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用Python建模数据最直接的方法是使用字典:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="93a1" class="mx lw it mt b gy my mz l na nb">customer1 = {<br/>    "name": "John", <br/>    "surname": "Smith",<br/>    "email": "john.smith@mymail.com",<br/>}<br/>customer2 = {<br/>    "name": "Jessica",<br/>    "surname": "Allyson",<br/>    "telephone": "0123456789",<br/>}</span></pre><p id="7f74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法遵循了Rich Hickey在他著名的演讲“也许不是”中强调的观点。在那次演讲中，Clojure的发明者捍卫了只使用实际存在的字段的字典，而不是使用可选字段(在他提到的语言中称为Maybe)的想法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="a03b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">里奇·希基(Rich Hickey)是一位魅力非凡、技术高超的工程师和社区领袖，人们很容易被他的谈话所说服。然而，这种数据建模有一个主要的缺点:在验证了字典的结构之后，验证之后的代码将没有关于数据内部结构的更多信息。</p><p id="9673" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用一个例子来说明:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="7e8f" class="mx lw it mt b gy my mz l na nb">def validate_customer_data(customer: Dict[str, str]) -&gt; None:<br/>    if "name" not in customer or "surname" not in customer:<br/>        raise ValueError("Customer data must contain keys name and surname")<br/>    if "email" not in customer and "telephone" not in custormer):<br/>        raise ValueError("At least one field among email and telephone must be present in customer data")</span><span id="96dc" class="mx lw it mt b gy ne mz l na nb">def contact_customer(customer: Dict[str, str]) -&gt; None:    <br/>    if "telephone" in customer:<br/>        open_call(customer["telephone"])<br/>    elif "email" in customer:<br/>        open_email_client(customer["email"])</span><span id="427e" class="mx lw it mt b gy ne mz l na nb"><br/>customer = receive_customer_data()<br/>validate_customer_data()<br/>contact_customer(customer)</span></pre><p id="d244" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面这段代码中，我们首先以某种方式接收客户数据<em class="nf"/>，然后验证该数据，最后用它联系客户。然而，经过验证，我们只知道客户向我们提供了至少一个来自电子邮件或电话号码，而不是这两个中的哪一个。我们从验证函数中得到的服务是，如果两个字段都不存在，就抛出一个错误。contact_customer函数需要控制这两个字段中的哪一个出现，并相应地采取行动。</p><p id="79f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，基于(数据)类的建模方法只会迫使我们处理无对象，在这里没有多大帮助:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="e360" class="mx lw it mt b gy my mz l na nb">from dataclasses import dataclass</span><span id="7dfd" class="mx lw it mt b gy ne mz l na nb">@dataclass<br/>class Customer:<br/>    name: str<br/>    surname: str<br/>    email: Optional[str]<br/>    telephone: Optional[str]</span><span id="8c89" class="mx lw it mt b gy ne mz l na nb">    def contact(self) -&gt; None:<br/>       if self.telephone is not None:<br/>           open_call(self.telephone)<br/>       elif self.email is not None:<br/>           open_email_client(self.email)</span></pre><p id="f128" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，在做出决策之前控制数据结构的代码看起来微不足道，不值得进行更复杂的设计选择。然而，当数据结构变得比一个玩具示例更大时，控制代码将相应地增加(在某些情况下以超线性的方式)。这可能导致性能成本，并且容易出错。</p><p id="c0c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一节要带回家的要点是，在验证函数时会学到一些额外的知识，而这些知识在函数返回的那一刻就会丢失。</p><p id="aa0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想在本文中讨论的解决方案是将数据解析成一种类型，这种类型包含了我们作为验证的一部分而生成的信息。这种方法受益于Python类型的静态部分，我在上一篇文章中已经提到过。</p><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/strong-static-typing-to-prevent-illegal-code-states-7a13e122cbab"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">防止非法代码状态的强大静态类型| Python模式</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">使用Python静态类型将重点放在业务逻辑上，而不是用“制造非法状态…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx ks nj"/></div></div></a></div><h1 id="fe5c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">解析，不验证</h1><p id="8a94" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">解析，不验证是Alexis King在她的同名文章中引入的一个概念，该文章关注Haskell语言。然而，Haskell和Python之间的巨大差异不应该让你认为相同的思想不能移植到Python中。事实上，解析是<a class="ae ky" href="https://pydantic-docs.helpmanual.io/" rel="noopener ugc nofollow" target="_blank"> Pydantic library </a>的基本思想，我建议您在阅读完本文后查阅一下。一旦想法得到澄清，即使没有Haskell知识，King的文章也应该非常容易理解。</p><p id="641a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主要思想是验证防止坏数据进入我们的应用程序。然而，一些信息是在验证过程中创建的，然后立即被丢弃。另一方面，解析允许我们拒绝格式错误的数据，但也允许我们将有效数据映射到保留这些信息的数据类型。应用程序的其余部分将使用这些类型来阻止已经执行的控件。</p><p id="95f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在上面的例子中，字典可以被映射到新的类型:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="33f9" class="mx lw it mt b gy my mz l na nb">@dataclass<br/>class CustomerWithPhone:<br/>  name: str<br/>  surname: str<br/>  phone: str</span><span id="87f2" class="mx lw it mt b gy ne mz l na nb">@dataclass<br/>class CustomerWithEmail:<br/>  class CustomerWithPhone:<br/>  name: str<br/>  surname: str<br/>  email: str</span><span id="661f" class="mx lw it mt b gy ne mz l na nb">@dataclass<br/>class CustomerWithPhoneAndEmail:<br/>  class CustomerWithPhone:<br/>  name: str<br/>  surname: str<br/>  phone: str<br/>  email: str</span></pre><p id="22d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的类也可以有自己的方法来联系客户，现在不再需要检查有效字段。此外，Python为通用函数提供了<a class="ae ky" href="https://docs.python.org/3/library/functools.html#functools.singledispatch" rel="noopener ugc nofollow" target="_blank">单一分派</a>:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="2282" class="mx lw it mt b gy my mz l na nb">from functools import singledispatch</span><span id="951b" class="mx lw it mt b gy ne mz l na nb"><br/>@singledispatch<br/>def contact_customer(customer):<br/>  raise NotImplementedError("Cannot contact a customer of unknown type")</span><span id="6737" class="mx lw it mt b gy ne mz l na nb">@contact_customer.register(CustomerWithPhone)<br/>def _contact_customer_by_phone(customer):  # this name is irrelevant <br/>  .<br/>  .<br/>  call_number(customer.phone)<br/>  .<br/>  .</span><span id="2a5d" class="mx lw it mt b gy ne mz l na nb">@contact_customer.register(CustomerWithEmail)<br/>def _contact_customer_by_email(customer):  # this name is irrelevant <br/>  .<br/>  .<br/>  send_email(customer.email)<br/>  .<br/>  .</span></pre><p id="abc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码声明了一个名为contact_customer的通用函数，并为它定义了两个不同的实现，分别用于两个输入类型CustomerWithPhone和CustomerWithEmail。Python解释器在运行时根据对象的运行时类型决定调用哪个函数。您不需要编写任何代码来决定要调用的正确函数。</p><p id="868b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了从我们定义的类型中获得最大利益，使用静态类型检查变得很重要，例如使用<a class="ae ky" href="https://pypi.org/project/mypy/" rel="noopener ugc nofollow" target="_blank"> mypy </a>，这样您就可以自动控制静态和动态的代码正确性。这里重要的是，它们不是手动控制，也不是由您(或您的团队)必须维护的代码组成的。</p><p id="1088" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用静态类型处理解析的数据是确保代码正确性的一种方式。你永远不会调用错误的函数或读取错误的属性。Mypy将为您检查并突出显示此类错误。在自动完成和可变建议方面，我们还免费获得IDE支持。</p><h1 id="5a5d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="b04a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">静态类型不是Python语言最初设计的一部分，但随着时间的推移，它正成为一个越来越强大的功能。大型项目可以从可以静态检查的深思熟虑的数据类型中受益匪浅。</p><p id="6dcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用数据类型的第一步是将应用程序的输入数据转换成这种类型。解析就是这个过程，它检查数据的正确性，然后将它们分配到应用程序中正确的位置。静态检查和动态多态可以帮助开发人员通过为数据本身的控件编写尽可能少的代码来减少错误的数量。</p><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/python-polymorphism-with-class-discovery-28908ac6456f"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">带寄存器的Python多态性| Python模式</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">学习一种模式来隔离包，同时扩展Python代码的功能。</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="ny l nu nv nw ns nx ks nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/machine-translation-evaluation-with-cometinho-c89880731409"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">使用Cometinho进行机器翻译评估</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">着眼于性能，减少模型大小、节省计算时间和金钱的实用建议</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="nz l nu nv nw ns nx ks nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/tips-for-reading-and-writing-an-ml-research-paper-a505863055cf"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">阅读和撰写ML研究论文的技巧</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">从几十次同行评审中获得的经验教训</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="oa l nu nv nw ns nx ks nj"/></div></div></a></div><h1 id="8071" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">中等会员</h1><p id="3090" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">你喜欢我的文章吗？你是否正在考虑申请一个中级会员来无限制地阅读我的文章？</p><p id="22dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您通过此链接订阅，您将通过您的订阅支持我，无需为您支付额外费用【https://medium.com/@mattiadigangi/membership<a class="ae ky" href="https://medium.com/@mattiadigangi/membership" rel="noopener"/></p></div></div>    
</body>
</html>