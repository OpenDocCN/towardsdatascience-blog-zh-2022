<html>
<head>
<title>Easily parallelize your calculations in pandas with parallel-pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 pandas 和 parallel-pandas 中轻松并行计算</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/easily-parallelize-your-calculations-in-pandas-with-parallel-pandas-dc194b82d82f#2022-11-21">https://towardsdatascience.com/easily-parallelize-your-calculations-in-pandas-with-parallel-pandas-dc194b82d82f#2022-11-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4f8cf0d6d8d920ae605a64a8a9e2111e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vIZ6bWxXq1dPEHJV"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@philipsfuture?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">菲利普·奥罗尼</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h2 id="cfd5" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">介绍</h2><p id="53d0" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">Pandas 是最受欢迎的数据科学图书馆之一。来自官方<a class="ae kc" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank">文档</a>:</p><blockquote class="lu lv lw"><p id="d47b" class="kz la lx lb b lc ly le lf lg lz li lj ma mb ll lm mc md lo lp me mf lr ls lt ij bi translated"><strong class="lb ir"> pandas </strong>是一个快速、强大、灵活且易于使用的开源数据分析和操作工具，构建于<a class="ae kc" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank"> Python </a>编程语言之上</p></blockquote><p id="9936" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km mb ll lm kq md lo lp ku mf lr ls lt ij bi translated">而每一个熟悉熊猫的人都会很有信心地证实这些话。与此同时，他们管道中的许多人面临着这样一个事实，即 pandas 没有充分利用 CPU 的能力。换句话说，pandas 方法不支持并发。</p><p id="3758" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km mb ll lm kq md lo lp ku mf lr ls lt ij bi translated">考虑一个简单的例子:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><pre class="mg mh mi mj gt mm mn mo bn mp mq bi"><span id="c128" class="mr ke iq mn b be ms mt l mu mv">synchronous describe time took: 37.6 s.</span></pre><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/31b743d262806ec119181e96aaae22c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_wYwgOhevBp94FShW-mc_Q.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">(图片由作者提供)</p></figure><p id="2c63" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km mb ll lm kq md lo lp ku mf lr ls lt ij bi translated">从上图中可以看出，100%时只使用了一个内核。其余的无所事事。但是如果你使用所有的处理器内核呢？你能多快得到同样的结果，最重要的是——如何实现？</p><p id="ef45" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km mb ll lm kq md lo lp ku mf lr ls lt ij bi translated">所以我们先想想 describe()是怎么工作的？它处理这些列，并为每个列计算一些统计数据。我们有一个包含 1000 列的数据框架。沿着第一个轴(沿着列)将我们的数据帧分成几个更小的部分，分别计算每个部分的 describe，然后将结果组合回一个公共数据帧，怎么样？让我们看看如何沿着指定的轴将数据帧分割成多个部分。这可以通过<code class="fe mx my mz mn b"><strong class="lb ir">numpy</strong></code>模块的<code class="fe mx my mz mn b">array_split</code>功能轻松完成。让我们看一个简单的例子:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><pre class="mg mh mi mj gt mm mn mo bn mp mq bi"><span id="b5a2" class="mr ke iq mn b be ms mt l mu mv">[   cat  dog<br/> 0    0    0<br/> 1    1    1<br/> 2    2    2,<br/>    cat  dog<br/> 3    3    3<br/> 4    4    4<br/> 5    5    5,<br/>    cat  dog<br/> 6    6    6<br/> 7    7    7,<br/>    cat  dog<br/> 8    8    8<br/> 9    9    9]</span></pre><p id="8ef8" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km mb ll lm kq md lo lp ku mf lr ls lt ij bi translated">并按列拆分</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><pre class="mg mh mi mj gt mm mn mo bn mp mq bi"><span id="52ef" class="mr ke iq mn b be ms mt l mu mv">[   cat<br/> 0    0<br/> 1    1<br/> 2    2<br/> 3    3<br/> 4    4<br/> 5    5<br/> 6    6<br/> 7    7<br/> 8    8<br/> 9    9,<br/>    dog<br/> 0    0<br/> 1    1<br/> 2    2<br/> 3    3<br/> 4    4<br/> 5    5<br/> 6    6<br/> 7    7<br/> 8    8<br/> 9    9]</span></pre><p id="f061" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km mb ll lm kq md lo lp ku mf lr ls lt ij bi translated">因此，我们有了一个算法，可以将一个大的数据帧沿着我们需要的轴分割成更小的部分。下一步是什么？如何让我们 CPU 的所有核心都工作起来？众所周知，pandas under the hood 使用<code class="fe mx my mz mn b"><a class="ae kc" href="https://numpy.org/doc/stable/user/whatisnumpy.html" rel="noopener ugc nofollow" target="_blank"><strong class="lb ir">numpy</strong></a></code>数组和方法来处理它们，这通常会移除全局解释器锁(GIL)。因此，我们可以使用线程池来并行计算。让我们转向<code class="fe mx my mz mn b"><a class="ae kc" href="https://docs.python.org/3/library/concurrent.futures.html#module-concurrent.futures" rel="noopener ugc nofollow" target="_blank"><strong class="lb ir">concurrent.futures</strong></a></code>模块的<code class="fe mx my mz mn b">ThreadPoolExecutor</code>类的<code class="fe mx my mz mn b">map</code>方法:</p><blockquote class="lu lv lw"><p id="d349" class="kz la lx lb b lc ly le lf lg lz li lj ma mb ll lm mc md lo lp me mf lr ls lt ij bi translated"><strong class="lb ir"> map </strong> ( <em class="iq"> func </em>，<em class="iq"> *iterables </em>，<em class="iq"> timeout=None </em>，<em class="iq"> chunksize=1 </em> ) <br/>类似于<code class="fe mx my mz mn b"><a class="ae kc" href="https://docs.python.org/3/library/functions.html#map" rel="noopener ugc nofollow" target="_blank">map(func, *iterables)</a></code>除了:<br/> 1。立即收集<em class="iq">可重复项</em>而不是延迟收集；<br/> 2。<em class="iq"> func </em>异步执行，可以并发调用几次<em class="iq"> func </em>。</p></blockquote><p id="3093" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km mb ll lm kq md lo lp ku mf lr ls lt ij bi translated">在我们的例子中，<code class="fe mx my mz mn b">describe()</code>方法是函数，iterable 对象是数据帧列表。下面给出了实现管道的完整代码。</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><pre class="mg mh mi mj gt mm mn mo bn mp mq bi"><span id="615b" class="mr ke iq mn b be ms mt l mu mv">parallel desribe time took: 15.0 s.</span></pre><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/f33b2902b43789087d1846faf6e8fbd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*QXO9eRaKm3-81p7zA44W3w.gif"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">(图片由作者提供)</p></figure><p id="bc52" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km mb ll lm kq md lo lp ku mf lr ls lt ij bi translated">所以我们将<code class="fe mx my mz mn b">pandas.DataFrame.describe()</code>方法的速度提高了两倍！类似地，您可以并行化其他的<code class="fe mx my mz mn b">pandas</code>方法。</p><h2 id="bbb4" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">平行熊猫简介</h2><p id="b900" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated"><code class="fe mx my mz mn b"><a class="ae kc" href="https://pypi.org/project/parallel-pandas/" rel="noopener ugc nofollow" target="_blank"><strong class="lb ir">parallel-pandas</strong></a></code>库在本地实现了上述<code class="fe mx my mz mn b">pandas</code>方法的并行化。首先，使用<code class="fe mx my mz mn b">pip</code>软件包管理器安装<code class="fe mx my mz mn b">parallel-pandas</code>:</p><pre class="mg mh mi mj gt mm mn mo bn mp mq bi"><span id="675e" class="mr ke iq mn b be ms mt l mu mv">pip install --upgrade parallel-pandas</span></pre><p id="3a18" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km mb ll lm kq md lo lp ku mf lr ls lt ij bi translated">只要两行就够入门了！</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><pre class="mg mh mi mj gt mm mn mo bn mp mq bi"><span id="51d9" class="mr ke iq mn b be ms mt l mu mv">synchronous time took: 3.7 s.<br/>parallel time took: 0.688 s. </span></pre><p id="6a32" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km mb ll lm kq md lo lp ku mf lr ls lt ij bi translated">如你所见，<code class="fe mx my mz mn b">p_quantile</code>方法比<strong class="lb ir">快 5 倍</strong>！</p><p id="92db" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km mb ll lm kq md lo lp ku mf lr ls lt ij bi translated">一旦<code class="fe mx my mz mn b">parallel-pandas</code>被初始化，你继续照常使用熊猫。<code class="fe mx my mz mn b">pandas</code>方法的并行模拟以来自单词<strong class="lb ir"> parallel </strong>的<code class="fe mx my mz mn b">p_</code>为前缀。此外，<code class="fe mx my mz mn b">parallel-pandas</code>允许您查看并行计算的进度。为此，在初始化期间指定<code class="fe mx my mz mn b">disable_pr_bar=False</code>就足够了。</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/a207f52a592bac15b187f012cc78e1f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/1*ugp1y1V7ZFnvlL7xgKPh-w.gif"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">带有进度条并行描述方法</p></figure><p id="6d7c" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km mb ll lm kq md lo lp ku mf lr ls lt ij bi translated">如您所见，<code class="fe mx my mz mn b">parallel-pandas</code>负责将原始数据帧分割成块，并行化并为您聚合最终结果。</p><p id="7cc0" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km mb ll lm kq md lo lp ku mf lr ls lt ij bi translated">更复杂的计算可以以类似的方式并行化。例如，让我们对数据帧的列进行 z 规范化。同样，为了比较，我们用<a class="ae kc" href="https://docs.dask.org/en/stable/dataframe.html" rel="noopener ugc nofollow" target="_blank"><strong class="lb ir">dask</strong></a>data frame 实现 z 归一化:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><pre class="mg mh mi mj gt mm mn mo bn mp mq bi"><span id="0615" class="mr ke iq mn b be ms mt l mu mv">synchronous z-score normalization time took: 21.7 s.<br/>parallel z-score normalization time took: 11.7 s.<br/>dask parallel z-score normalization time took: 12.5 s.</span></pre><p id="66f6" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km mb ll lm kq md lo lp ku mf lr ls lt ij bi translated">注意内存消耗。<code class="fe mx my mz mn b">parallel-pandas</code>和<code class="fe mx my mz mn b">dask</code>使用的 RAM 几乎是<code class="fe mx my mz mn b">pandas</code>的一半</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/818f4f6ed51713936958ec44a8b85b94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sW8Lg_vigjqoONVpzIbvQA.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">RAM 使用</p></figure><p id="353e" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km mb ll lm kq md lo lp ku mf lr ls lt ij bi translated">对于某些方法，parallel-pandas 比 dask DataFrame 更快:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><pre class="mg mh mi mj gt mm mn mo bn mp mq bi"><span id="965b" class="mr ke iq mn b be ms mt l mu mv">dask nunique time took:42.5 s.<br/>dask rolling window mean time took: 19.8 s.<br/>paralle-pandas nunique time took:12.5 s.<br/>parallel-pandas rolling window mean time took: 11.8 s.</span></pre><p id="2798" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km mb ll lm kq md lo lp ku mf lr ls lt ij bi translated"><code class="fe mx my mz mn b">parallel-pandas</code>实现了许多熊猫方法。完整列表可在<a class="ae kc" href="https://pypi.org/project/parallel-pandas/" rel="noopener ugc nofollow" target="_blank">文档</a>中找到。</p><p id="7fe7" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km mb ll lm kq md lo lp ku mf lr ls lt ij bi translated"><strong class="lb ir">总结一下:</strong></p><ul class=""><li id="009d" class="nd ne iq lb b lc ly lg lz km nf kq ng ku nh lt ni nj nk nl bi translated">在本文中，我们简要回顾了并行化<code class="fe mx my mz mn b">pandas</code>方法的思想，并以<code class="fe mx my mz mn b">describe</code>方法为例实现了它</li><li id="e129" class="nd ne iq lb b lc nm lg nn km no kq np ku nq lt ni nj nk nl bi translated">我们还熟悉了<code class="fe mx my mz mn b">parallel-pandas</code>库，它使得基本<code class="fe mx my mz mn b">pandas</code>方法的并行化变得容易。</li><li id="6d25" class="nd ne iq lb b lc nm lg nn km no kq np ku nq lt ni nj nk nl bi translated">我们还使用几个例子将<code class="fe mx my mz mn b">parallel-pandas</code>的工作与另一个著名的分布式计算库<code class="fe mx my mz mn b">dask</code>进行了比较。</li></ul><p id="72bf" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km mb ll lm kq md lo lp ku mf lr ls lt ij bi translated">希望这篇文章对你有帮助，祝你好运！</p></div></div>    
</body>
</html>