<html>
<head>
<title>How to Take Your SQL from Zero to Data Scientist Level — Part 2/3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将您的 SQL 从零提高到数据科学家级别—第 2/3 部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-take-your-sql-from-zero-to-data-scientist-level-part-2-3-bc1cbb48299e#2022-12-20">https://towardsdatascience.com/how-to-take-your-sql-from-zero-to-data-scientist-level-part-2-3-bc1cbb48299e#2022-12-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7731" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">SQL 列表的终极指南:了解数据科学家经常使用的基本和高级 SQL 查询</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b6cba53a86be868f29bc7c387ed9ef12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l9gkfOPPHz2qtisTi_e3fQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@samule?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Samule 孙</a>在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h2 id="96d5" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">简介</strong></h2><p id="cebb" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">您是否希望按照优秀数据科学团队的标准学习 SQL？如果是这样，那你来对地方了！在<a class="ae kv" href="https://medium.com/@alex.vamvakaris.ds/how-to-take-your-sql-from-zero-to-data-scientist-level-part-1-3-d7225d2d89ad" rel="noopener"> <strong class="lu ir">第 1 部分</strong> </a>中，我们设置了 SQL，并在 AdventureWorks2019 演示数据库上执行了一个简单的 SELECT 查询(涉及到 SQL 和关系数据库的理论)。在本系列的这一部分中，我们将更深入地研究 SQL，从一个简单的两行 SELECT 语句开始，一直到更复杂的查询。</p><h2 id="7cf0" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">第二部分</strong></h2><ul class=""><li id="1966" class="ml mm iq lu b lv lw ly lz lf mn lj mo ln mp mk mq mr ms mt bi translated">用 SELECT 语句提取数据</li><li id="3df0" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk mq mr ms mt bi translated">如何连接数据库中的不同表</li><li id="461b" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk mq mr ms mt bi translated">高级 SQL 语句:CASE 表达式，处理日期、cte、子查询和排名函数</li></ul><h2 id="3fba" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/how-to-take-your-sql-from-zero-to-data-scientist-level-part-3-3-fe3996059577">第三部分</a></h2><ul class=""><li id="45fd" class="ml mm iq lu b lv lw ly lz lf mn lj mo ln mp mk mq mr ms mt bi translated">查询优化、测试代码、数据科学编码最佳实践和培训计划</li></ul><h2 id="1f9f" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">开始之前</h2><p id="31f0" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated"><em class="mz">*这些步骤不是遵循指南的强制要求，但是它们将允许您自己执行查询和练习 SQL</em></p><ul class=""><li id="d26a" class="ml mm iq lu b lv na ly nb lf nc lj nd ln ne mk mq mr ms mt bi translated">打开 SSMS 并连接到 SQL server</li><li id="d0df" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk mq mr ms mt bi translated">从工具栏中选择<strong class="lu ir"> </strong>“新建查询”，查询窗口将在右侧面板打开</li><li id="0519" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk mq mr ms mt bi translated">最后，将数据库从 master 更改为 AdventureWorks2019，以将查询窗口连接到演示数据库，这样就可以开始了</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/bd9f977ef65ccdecff110e8ad1b53bb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zrMlfTkm8lcjtm4d"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">连接 SSMS 的一个数据库，打开一个新的查询窗口[图片由作者提供]</p></figure><p id="d496" class="pw-post-body-paragraph ls lt iq lu b lv na jr lx ly nb ju ma lf ng mc md lj nh mf mg ln ni mi mj mk ij bi translated"><em class="mz">👉如果你需要以上任何方面的帮助，在</em> <a class="ae kv" href="https://medium.com/@alex.vamvakaris.ds/how-to-take-your-sql-from-zero-to-data-scientist-level-part-1-3-d7225d2d89ad" rel="noopener"> <strong class="lu ir"> <em class="mz">第一部分</em> </strong> </a>中有一个分步指南</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="8a00" class="nq kx iq bd ky nr ns nt lb nu nv nw le jw nx jx li jz ny ka lm kc nz kd lq oa bi translated"><strong class="ak"> 1。在 SQL 领域，SELECT 语句是王道</strong></h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/e826bd3b6a9fac6a01ad57c9a4caabbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K5HIX4_I0kX2luNM"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Rafael Rex Felisilda 在<a class="ae kv" href="https://unsplash.com/s/photos/king-chess?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e7c5" class="pw-post-body-paragraph ls lt iq lu b lv na jr lx ly nb ju ma lf ng mc md lj nh mf mg ln ni mi mj mk ij bi translated">作为一名数据科学家，您使用 SQL 的主要目的是从数据库表中提取数据。对于每个这样的查询，将使用 SELECT 语句。SELECT 语句的语法由以下六个子句组成，每个子句都旨在优化查询，以便只返回所需的数据。</p><blockquote class="oc od oe"><p id="8b6c" class="ls lt mz lu b lv na jr lx ly nb ju ma of ng mc md og nh mf mg oh ni mi mj mk ij bi translated"><strong class="lu ir">选择</strong> ( <em class="iq">列列表)</em></p><p id="a4ae" class="ls lt mz lu b lv na jr lx ly nb ju ma of ng mc md og nh mf mg oh ni mi mj mk ij bi translated"><strong class="lu ir">出自</strong> ( <em class="iq">表参考)</em></p><p id="b185" class="ls lt mz lu b lv na jr lx ly nb ju ma of ng mc md og nh mf mg oh ni mi mj mk ij bi translated"><strong class="lu ir">其中</strong> ( <em class="iq">过滤条件)</em></p><p id="72f0" class="ls lt mz lu b lv na jr lx ly nb ju ma of ng mc md og nh mf mg oh ni mi mj mk ij bi translated"><strong class="lu ir">分组依据</strong> ( <em class="iq">分组规范)</em></p><p id="f30c" class="ls lt mz lu b lv na jr lx ly nb ju ma of ng mc md og nh mf mg oh ni mi mj mk ij bi translated"><strong class="lu ir">有</strong>(后分组<em class="iq">过滤条件)</em></p><p id="22c8" class="ls lt mz lu b lv na jr lx ly nb ju ma of ng mc md og nh mf mg oh ni mi mj mk ij bi translated"><strong class="lu ir">订单由</strong> ( <em class="iq">订单条件)</em></p></blockquote><h1 id="a093" class="nq kx iq bd ky nr oi nt lb nu oj nw le jw ok jx li jz ol ka lm kc om kd lq oa bi translated">1.1 评估顺序</h1><p id="23c1" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">当执行 SELECT 语句时，每个子句都按特定的顺序进行计算。这与 SQL 的编写顺序不同(语法如上所示)。评估的顺序是引擎盖下发生的事情。您可以把它想象成一个虚拟表，随着我们从一个子句前进到下一个子句，它会不断变化，直到返回结果。对求值顺序的良好理解不仅有助于您编写更高效的查询，还能帮助初学者更快地进步。</p><ol class=""><li id="22bc" class="ml mm iq lu b lv na ly nb lf nc lj nd ln ne mk on mr ms mt bi translated">条款中的<strong class="lu ir">是强制性的，首先执行。它用于在数据库中选择我们想要从中提取数据的表</strong></li><li id="87c4" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk on mr ms mt bi translated">然后在<strong class="lu ir"> WHERE </strong>子句(如果指定了)中使用这些结果，根据某些条件过滤表中的行</li><li id="5616" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk on mr ms mt bi translated">然后在<strong class="lu ir"> GROUP BY </strong>子句(如果指定了一个)中使用结果对表进行分组</li><li id="269f" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk on mr ms mt bi translated">然后，分组的结果<strong class="lu ir"> </strong>在<strong class="lu ir"> HAVING </strong>子句中使用(如果指定了一个子句，它也需要 GROUP BY)来过滤分组的行</li><li id="9711" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk on mr ms mt bi translated">执行完上面的最后一个子句后，结果被传递到(强制的)<strong class="lu ir"> SELECT </strong>子句，在那里选择列</li><li id="204a" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk on mr ms mt bi translated">最后，对<strong class="lu ir"> ORDER BY </strong>子句进行求值(如果指定了一个子句)以对结果中的列进行排序</li></ol><p id="74e8" class="pw-post-body-paragraph ls lt iq lu b lv na jr lx ly nb ju ma lf ng mc md lj nh mf mg ln ni mi mj mk ij bi translated">还值得一提的是，在 SQL 访谈中最常见的两个问题是解释 GROUP BY 和 HAVING(稍后将详细介绍)之间的区别，以及遍历 SELECT 语句的求值顺序。</p><h1 id="1881" class="nq kx iq bd ky nr oi nt lb nu oj nw le jw ok jx li jz ol ka lm kc om kd lq oa bi translated"><strong class="ak"> 1.2 从</strong>中选择&amp;</h1><p id="a408" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">让我们从最简单的 SELECT 语句开始，只使用两个强制子句 SELECT 和 FROM:</p><ul class=""><li id="0f16" class="ml mm iq lu b lv na ly nb lf nc lj nd ln ne mk mq mr ms mt bi translated">FROM 子句中的表引用采用[database]的形式。[模式]。[表格]。我们可以省略[database]部分，因为我们将在示例中仅使用 AdventureWorks2019 数据库，并且我们已经连接(您可以将模式视为“相似”表的容器)</li><li id="1983" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk mq mr ms mt bi translated">DISTINCT 和 TOP 关键字的开销很大(就内存而言)，所以要小心有选择地使用它们</li></ul><pre class="kg kh ki kj gt oo op oq bn or os bi"><span id="3e85" class="ot kx iq op b be ou ov l ow ox">---=================================<br/>--- Select all columns and rows<br/>---=================================<br/>SELECT *<br/>FROM [AdventureWorks2019].[Sales].[SalesOrderHeader]<br/><br/>---=================================<br/>--- Return the top 10 rows and all columns<br/>---=================================<br/>SELECT TOP 10 *<br/>FROM [Sales].[SalesOrderHeader]<br/><br/>---=================================<br/>--- Select all rows for specified columns<br/>---=================================<br/>SELECT<br/>  [SalesOrderID],<br/>  [OrderDate],<br/>  [TotalDue]<br/>FROM [Sales].[SalesOrderHeader]<br/><br/>---=================================<br/>--- Select distinct rows for specified columns<br/>---=================================<br/>SELECT DISTINCT<br/>  [SalesOrderID],<br/>  [OrderDate],<br/>  [TotalDue]<br/>FROM [Sales].[SalesOrderHeader]</span></pre><h2 id="4ba7" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">计算列</h2><p id="4cd8" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">您可以使用算术运算符或函数<strong class="lu ir">创建计算列</strong>。我们可以使用<strong class="lu ir">作为</strong>关键字来命名一个计算列或重命名结果中的现有列。</p><pre class="kg kh ki kj gt oo op oq bn or os bi"><span id="777b" class="ot kx iq op b be ou ov l ow ox">---=================================<br/>--- Create calculated columns<br/>---=================================<br/>SELECT TOP 10<br/>  [SalesOrderID],<br/>  [TotalDue],<br/>  [TotalDue] AS Total_Amount_Due,<br/>  [TotalDue] * 0.8 AS Gross_Due,<br/>  ROUND([TotalDue] * 0.8 , 1) AS Gross_Due_Round<br/>FROM [Sales].[SalesOrderHeader]</span></pre><h2 id="7266" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">空值</h2><p id="c43f" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">SQL 中的一个关键概念是空值。空值用于标记缺少的数据(没有对该单元格进行任何输入)。这不同于包含空格或零值的单元格。把它们想象成 SQL 的 NA。</p><h2 id="20fd" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">聚集</h2><p id="aefa" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">您也可以使用函数创建聚合结果，如下例所示:</p><ul class=""><li id="e178" class="ml mm iq lu b lv na ly nb lf nc lj nd ln ne mk mq mr ms mt bi translated"><strong class="lu ir"> COUNT(*): </strong>返回表格中所有行的计数</li><li id="91cd" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk mq mr ms mt bi translated"><strong class="lu ir"> COUNT( <em class="mz">列</em> ): </strong>返回该列所有非空记录的计数</li><li id="8b3f" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk mq mr ms mt bi translated"><strong class="lu ir"> COUNT(DISTINCT <em class="mz">列</em> ): </strong>返回该列的非重复值的计数。NULL 也将被计为值之一</li><li id="f355" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk mq mr ms mt bi translated"><strong class="lu ir">COUNT(*)= COUNT(<em class="mz">SalesOrderID</em>)=</strong><strong class="lu ir">COUNT(DISTINCT<em class="mz">SalesOrderID</em>):</strong>SalesOrderID 列是表的主键，因此对于行是唯一的</li><li id="e613" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk mq mr ms mt bi translated"><strong class="lu ir">COUNT(DISTINCT<em class="mz">CustomerID</em>)</strong>&lt;<strong class="lu ir">COUNT(<em class="mz">CustomerID</em>):</strong>CustomerID 列有重复值(一个客户可以有多个订单)</li><li id="c454" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk mq mr ms mt bi translated">您可以在此 处找到 SQL Server <a class="ae kv" href="https://learn.microsoft.com/en-us/sql/t-sql/functions/aggregate-functions-transact-sql?view=sql-server-ver16" rel="noopener ugc nofollow" target="_blank"> <strong class="lu ir">聚合函数的完整列表</strong></a></li></ul><pre class="kg kh ki kj gt oo op oq bn or os bi"><span id="a425" class="ot kx iq op b be ou ov l ow ox">---=================================<br/>--- Group results using aggr. functions<br/>---=================================<br/>SELECT<br/>  AVG([TotalDue]) AS Sum_Total_Due,<br/>  COUNT(*) AS Count_All_Records,<br/>  COUNT(DISTINCT [SalesOrderID]) AS Count_Sales,<br/>  COUNT([CustomerID]) AS Count_Cust,<br/>  COUNT(DISTINCT [CustomerID]) AS Count_Cust_Dist<br/>FROM [Sales].[SalesOrderHeader]</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/b1571d8a7aae15e4fb648691a3620784.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BEz16pgUXr8dwaTlNtAaKg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自示例选择查询的 SSMS 结果[图片由作者提供]</p></figure><p id="4a46" class="pw-post-body-paragraph ls lt iq lu b lv na jr lx ly nb ju ma lf ng mc md lj nh mf mg ln ni mi mj mk ij bi translated">我建议您练习对不同的列(有和没有 NULL)使用 COUNT 和其他聚合函数，以便更好地理解 SQL 的行为。还值得一提的是，SQL 中的语法不区分大小写。所以我们可以写 SeLeCt 或者 SELECT，coUnt 或者 COUNT，查询还是会执行。当需要提高代码可读性时，我们将使用 capital(我们将在本系列的第 3 部分中介绍编码最佳实践)。</p><h1 id="c41f" class="nq kx iq bd ky nr oi nt lb nu oj nw le jw ok jx li jz ol ka lm kc om kd lq oa bi translated">1.3 哪里</h1><p id="5682" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">WHERE 子句获取 FROM 子句选择的数据，并根据某种筛选条件对每一行进行评估:</p><ul class=""><li id="e648" class="ml mm iq lu b lv na ly nb lf nc lj nd ln ne mk mq mr ms mt bi translated">评估为 TRUE 的那些行将作为查询结果的一部分返回</li><li id="e1e2" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk mq mr ms mt bi translated">评估为未知或假的那些不包括在结果中(对于空值返回未知)</li></ul><p id="9901" class="pw-post-body-paragraph ls lt iq lu b lv na jr lx ly nb ju ma lf ng mc md lj nh mf mg ln ni mi mj mk ij bi translated">为了评估过滤条件，我们将使用<strong class="lu ir">谓词</strong>。还有很多，就一个一个来说吧。</p><h2 id="f8a9" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">比较谓词</strong></h2><p id="269d" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">这些是你在数学中用来比较的常用符号。</p><pre class="kg kh ki kj gt oo op oq bn or os bi"><span id="ccb3" class="ot kx iq op b be ou ov l ow ox">---=================================<br/>--- Equal <br/>---=================================<br/>SELECT *<br/>FROM [Sales].[SalesOrderHeader]<br/>WHERE [TerritoryID] = 6<br/><br/>---=================================<br/>--- Not Equal<br/>---=================================<br/>SELECT<br/>  [SalesOrderID],<br/>  [TerritoryID]<br/>FROM [Sales].[SalesOrderHeader]<br/>WHERE [TerritoryID] &lt;&gt; 6<br/><br/>---=================================<br/>--- Greater or equal<br/>---=================================<br/>SELECT<br/>  [SalesOrderID],<br/>  [TerritoryID]<br/>FROM [Sales].[SalesOrderHeader]<br/>WHERE [TerritoryID] &gt;= 6</span></pre><h2 id="1148" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">BETWEEN 谓词</h2><p id="c12e" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">BETWEEN 谓词与 AND 关键字结合使用，用于标识可作为搜索条件包含的值范围。</p><pre class="kg kh ki kj gt oo op oq bn or os bi"><span id="91fb" class="ot kx iq op b be ou ov l ow ox">---=================================<br/>--- Filter by numerical range<br/>---=================================<br/>SELECT<br/>  [SalesOrderID],<br/>  [TerritoryID]<br/>FROM [Sales].[SalesOrderHeader]<br/>WHERE [TerritoryID] BETWEEN 2 AND 6<br/><br/>---=================================<br/>--- Filter by date range<br/>---=================================<br/>SELECT COUNT(*)<br/>FROM [Sales].[SalesOrderHeader]<br/>WHERE [OrderDate] BETWEEN '2013-06-01' AND '2013-06-30'</span></pre><h2 id="fcff" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">在谓词中</h2><p id="c1f6" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">确定列值是否与列表中的任何值匹配。</p><pre class="kg kh ki kj gt oo op oq bn or os bi"><span id="1cda" class="ot kx iq op b be ou ov l ow ox">---=================================<br/>--- Filter by values in a list<br/>---=================================<br/>SELECT<br/>  [SalesOrderID],<br/>  [TerritoryID]<br/>FROM [Sales].[SalesOrderHeader]<br/>WHERE [TerritoryID] IN (2, 3, 6)</span></pre><h2 id="86b5" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">LIKE 谓词</h2><p id="7f0c" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">如果说有哪个谓词可以好玩，那就是 LIKE 谓词。使用 LIKE 谓词，您可以指定仅与存储在数据库中的值相似的值(以下示例中使用的通配符%，因供应商而异)。</p><pre class="kg kh ki kj gt oo op oq bn or os bi"><span id="e14c" class="ot kx iq op b be ou ov l ow ox">---=================================<br/>--- Values that start with 43<br/>---=================================<br/>SELECT TOP 5<br/>  [SalesOrderID]<br/>FROM [Sales].[SalesOrderHeader]<br/>WHERE [SalesOrderID] LIKE '43%'<br/><br/>---=================================<br/>--- Values that contain 43<br/>---=================================<br/>SELECT <br/>  COUNT(DISTINCT [CustomerID])<br/>FROM [Sales].[SalesOrderHeader]<br/>WHERE [SalesOrderID] LIKE '%43%'</span></pre><h2 id="b0e8" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">为空</h2><p id="852b" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">正如我们之前所讨论的，使用普通谓词，空值将总是被评估为未知，因此不会返回任何内容。所以我们需要另一个返回 true 或 false 的谓词。因此，SQL 提供了 IS NULL 条件。</p><pre class="kg kh ki kj gt oo op oq bn or os bi"><span id="c07f" class="ot kx iq op b be ou ov l ow ox">---=================================<br/>--- Select only values with NULL<br/>---=================================<br/>SELECT <br/>  [SalesOrderID],<br/>  [CurrencyRateID]<br/>FROM [Sales].[SalesOrderHeader]<br/>WHERE [CurrencyRateID] IS NULL</span></pre><h2 id="b491" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">多重比较</h2><p id="e6f6" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">如果存在多个搜索条件，则使用逻辑运算符(OR、AND、NOT)将它们组合起来。执行优先级的规则是，括号&gt; NOT &gt; AND &gt; OR。注意抽查多重比较的结果(在下面的例子中，版本 1 将通过改变括号给出与版本 2 不同的结果)。</p><pre class="kg kh ki kj gt oo op oq bn or os bi"><span id="de6c" class="ot kx iq op b be ou ov l ow ox">---=================================<br/>--- Version 1<br/>---=================================<br/>SELECT *<br/>FROM   [Sales].[SalesOrderHeader]<br/>WHERE <br/>[totaldue] &lt; 3000 AND ([TerritoryID] &lt; 2 OR [TerritoryID] &gt; 7) <br/><br/>---=================================<br/>--- Version 2<br/>---=================================<br/>SELECT *<br/>FROM   [Sales].[SalesOrderHeader]<br/>WHERE <br/>([totaldue] &lt; 3000 AND [TerritoryID] &lt; 2) OR [TerritoryID] &gt; 7</span></pre><h1 id="1e50" class="nq kx iq bd ky nr oi nt lb nu oj nw le jw ok jx li jz ol ka lm kc om kd lq oa bi translated">1.4 分组依据</h1><p id="27d7" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">GROUP BY 子句用于对数据(从 from 或 WHERE 传递)进行分组，其方式与您在 excel 中使用透视表或在 r 中使用 dplyr 中的 group_by()的方式相同，使用不带聚合的 GROUP BY 将返回所选列的值的不同组合(与使用 distinct 的结果相同)。</p><pre class="kg kh ki kj gt oo op oq bn or os bi"><span id="1b0b" class="ot kx iq op b be ou ov l ow ox">---=================================<br/>--- Return distinct values in TerritoryID<br/>---=================================<br/>SELECT<br/>  [TerritoryID]<br/>FROM [AdventureWorks2019].[Sales].[SalesOrderHeader]<br/>GROUP BY [TerritoryID]<br/><br/>---=================================<br/>--- Return sum of TotalDue by TerritoryID<br/>---=================================<br/>SELECT<br/>  [TerritoryID],<br/>  SUM([TotalDue]) AS Sum_Total_Due<br/>FROM [AdventureWorks2019].[Sales].[SalesOrderHeader]<br/>GROUP BY [TerritoryID]</span></pre><h2 id="b85f" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">总计和小计</h2><p id="fab5" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">我们还可以使用<strong class="lu ir"> ROLLUP </strong>操作符获得总计或小计(占用大量内存)。正如您在下面的示例(左图)中所看到的，总数表示为 NULL。我们可以通过使用<strong class="lu ir"> ISNULL </strong>函数将它替换为一个新值来解决这个问题。</p><pre class="kg kh ki kj gt oo op oq bn or os bi"><span id="b280" class="ot kx iq op b be ou ov l ow ox">---=================================<br/>--- Return sum of TotalDue by TerritoryID with total<br/>---=================================<br/>SELECT<br/>  [TerritoryID],<br/>  SUM([TotalDue]) AS Sum_Total_Due<br/>FROM [AdventureWorks2019].[Sales].[SalesOrderHeader]<br/>GROUP BY ROLLUP([TerritoryID])<br/><br/>---=================================<br/>--- Return sum of TotalDue by TerritoryID with total (labeled as 99)<br/>---=================================<br/>SELECT<br/>  ISNULL([TerritoryID], 99) AS TerritoryID,<br/>  SUM([TotalDue]) AS Sum_Total_Due<br/>FROM [Sales].[SalesOrderHeader]<br/>GROUP BY ROLLUP([TerritoryID])</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/5a9327c574c414f2e28cec5362579e2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HNpu_L4G6OjwBnlSmVqJ1A.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在 SSMS 使用 GROUP BY with ROLLUP 得到的结果[图片由作者提供]</p></figure><h1 id="dc49" class="nq kx iq bd ky nr oi nt lb nu oj nw le jw ok jx li jz ol ka lm kc om kd lq oa bi translated">1.5 拥有</h1><p id="fefa" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">HAVING 子句与 WHERE 完全相同，但只能应用于 GROUP BY 之后。换句话说，WHERE 用于筛选 FROM 的结果，而 HAVING 用于筛选 GROUP BY 的结果。记住虚拟表从一个子句传递到下一个子句的类比。</p><pre class="kg kh ki kj gt oo op oq bn or os bi"><span id="9b81" class="ot kx iq op b be ou ov l ow ox">---=================================<br/>--- Filter using column<br/>---=================================<br/>SELECT<br/>  [TerritoryID],<br/>  SUM([TotalDue]) AS Sum_Total_Due<br/>FROM [Sales].[SalesOrderHeader]<br/>GROUP BY [TerritoryID]<br/>HAVING [TerritoryID] = 1<br/><br/>---=================================<br/>--- Filter using aggregate<br/>---=================================<br/>SELECT<br/>  [TerritoryID],<br/>  SUM([TotalDue]) AS Sum_Total_Due<br/>FROM [Sales].[SalesOrderHeader]<br/>GROUP BY [TerritoryID]<br/>HAVING SUM([TotalDue]) &gt;= 15000000</span></pre><h1 id="47da" class="nq kx iq bd ky nr oi nt lb nu oj nw le jw ok jx li jz ol ka lm kc om kd lq oa bi translated">1.6 订购依据</h1><p id="4316" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">好了，还有最后一个条款，幸运的是这是最简单的。我们可以使用 ORDER by 子句按升序(大多数供应商的默认设置)或降序对 SELECT 结果进行排序。</p><pre class="kg kh ki kj gt oo op oq bn or os bi"><span id="44c9" class="ot kx iq op b be ou ov l ow ox">---=================================<br/>--- Sort by ascending order<br/>---=================================<br/>SELECT<br/>  [TerritoryID],<br/>  SUM([TotalDue]) AS Sum_Total_Due<br/>FROM [Sales].[SalesOrderHeader]<br/>GROUP BY [TerritoryID]<br/>ORDER BY SUM([TotalDue])<br/><br/>---=================================<br/>--- Combine all clauses and sort by descending order<br/>---=================================<br/>SELECT<br/>  [TerritoryID],<br/>  SUM([TotalDue]) AS Sum_Total_Due<br/>FROM [Sales].[SalesOrderHeader]<br/>WHERE [TerritoryID] &gt;= 3<br/>GROUP BY [TerritoryID]<br/>HAVING SUM([TotalDue])  &gt;= 15000000<br/>ORDER BY [TerritoryID] DESC<br/></span></pre></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="a1a7" class="nq kx iq bd ky nr ns nt lb nu nv nw le jw nx jx li jz ny ka lm kc nz kd lq oa bi translated">2.<strong class="ak">如何连接不同的表</strong></h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/87539eb80dfc11ef9eba4f05f0cd52f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G4h0hQq_oO_yihsfYHfpOg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马特·科菲尔在<a class="ae kv" href="https://unsplash.com/s/photos/bridge?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="b7be" class="pw-post-body-paragraph ls lt iq lu b lv na jr lx ly nb ju ma lf ng mc md lj nh mf mg ln ni mi mj mk ij bi translated">通常，您需要在查询中从多个表中检索信息。有四种主要类型的连接子句(尽管实际上只有 INNER 和 LEFT 连接经常使用):</p><ul class=""><li id="65c5" class="ml mm iq lu b lv na ly nb lf nc lj nd ln ne mk mq mr ms mt bi translated"><strong class="lu ir">内部连接:</strong>只返回两个表中都存在的记录</li><li id="0b82" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk mq mr ms mt bi translated"><strong class="lu ir">左连接:</strong>只返回左表中存在的记录</li><li id="1add" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk mq mr ms mt bi translated"><strong class="lu ir">右连接:</strong>只返回右表中存在的记录</li><li id="d45b" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk mq mr ms mt bi translated"><strong class="lu ir">完全外部连接:</strong>返回两个表中的所有记录</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/6ff70625ce9ecd87d44db9e571e42b42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hzr8AktuWlNLg4VWCdc6_A.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用维恩图可视化连接[图片由作者提供]</p></figure><p id="2889" class="pw-post-body-paragraph ls lt iq lu b lv na jr lx ly nb ju ma lf ng mc md lj nh mf mg ln ni mi mj mk ij bi translated">好的，所以连接的类型决定了从表中保留哪些记录(行)。然后，我们可以使用一个或多个共享列将表链接在一起:</p><ul class=""><li id="9676" class="ml mm iq lu b lv na ly nb lf nc lj nd ln ne mk mq mr ms mt bi translated">选择连接的类型</li><li id="0013" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk mq mr ms mt bi translated">给表取别名(在我们的例子中是 S 和 T)</li><li id="8612" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk mq mr ms mt bi translated">使用 ON 关键字指定用于连接表的共享列</li></ul><pre class="kg kh ki kj gt oo op oq bn or os bi"><span id="ded8" class="ot kx iq op b be ou ov l ow ox">---=================================<br/>--- Inner join the sales and territory tables<br/>---=================================<br/>SELECT<br/>  S.[TerritoryID],<br/>  T.[Name]<br/>FROM [Sales].[SalesOrderHeader] S<br/>INNER JOIN [Sales].[SalesTerritory] T <br/>  ON S.TerritoryID = T.TerritoryID<br/><br/>---=================================<br/>--- Left join the sales and customer tables (more complex)<br/>---=================================<br/>SELECT<br/>  S.[TerritoryID],<br/>  T.[Name],<br/>  SUM([TotalDue]) AS Sum_Total_Due<br/>FROM [Sales].[SalesOrderHeader] S<br/>LEFT JOIN [Sales].[SalesTerritory] T<br/>  ON S.TerritoryID = T.TerritoryID<br/>GROUP BY <br/>  S.[TerritoryID],<br/>  T.[Name]<br/>HAVING T.[Name] IN ('Australia','United Kingdom')</span></pre><h2 id="5d7a" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">处理重复</h2><p id="32c6" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">连接表时有一个主要考虑事项。当两个表之间的关系是一对多时，联接的结果将有重复项。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/2e58f41aef04be6ed47b382dfa46aca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qoRSqEGAoJRpOj0mRDO2-g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用一对多关系连接表[图片由作者提供]</p></figure><p id="faa6" class="pw-post-body-paragraph ls lt iq lu b lv na jr lx ly nb ju ma lf ng mc md lj nh mf mg ln ni mi mj mk ij bi translated">这可能具有挑战性，并会导致错误，尤其是在涉及聚合时。我建议始终如一地验证柱子所处的水平。在上面的例子中，OrderAmount 值在订单级别(OrderID)是唯一的，但是连接的表将有重复的，并且不应该在聚合中使用(我们将在第 3 部分中讨论重复和如何对代码进行 QA 测试)。</p><pre class="kg kh ki kj gt oo op oq bn or os bi"><span id="1231" class="ot kx iq op b be ou ov l ow ox">---=================================<br/>--- Total sales value from order table<br/>---=================================<br/>SELECT<br/> SUM(S.SubTotal) AS Order_Total --- correct<br/>FROM [Sales].[SalesOrderHeader] S<br/><br/>---=================================<br/>--- Total sales value from order table<br/>--- after joining with orderline table<br/>---=================================<br/>SELECT<br/>  SUM(S.SubTotal) AS Order_Total_Dup, --- duplicates<br/>  SUM(SL.LineTotal) AS Order_Line_Total --- correct<br/>FROM [Sales].[SalesOrderHeader] S<br/>INNER JOIN [Sales].[SalesOrderDetail] SL<br/>  ON S.SalesOrderID = SL.SalesOrderID</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pb"><img src="../Images/84328eec2c6c1e43aa27433eed39d2bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k8XhTjOc6BKOveYl35DdnA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">SSMS 一对多关系中的重复示例[图片由作者提供]</p></figure></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="593d" class="nq kx iq bd ky nr ns nt lb nu nv nw le jw nx jx li jz ny ka lm kc nz kd lq oa bi translated">3.高级 SQL 查询(我的英雄)</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pc"><img src="../Images/01b53071397305c3265505b653cd90b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-dwERlDNre40lskU18JvNw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Erik Mclean 在<a class="ae kv" href="https://unsplash.com/s/photos/COMIC-BOOKS?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="edee" class="pw-post-body-paragraph ls lt iq lu b lv na jr lx ly nb ju ma lf ng mc md lj nh mf mg ln ni mi mj mk ij bi translated">最后，我还想向您展示一些作为数据科学家需要的更高级的工具。在过去的六年里，我用 SQL 编写了 1500 多个小时的代码，这些工具是我的英雄！</p><h1 id="8792" class="nq kx iq bd ky nr oi nt lb nu oj nw le jw ok jx li jz ol ka lm kc om kd lq oa bi translated">3.1 案例</h1><p id="beaa" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">CASE 语句允许您基于多个条件创建计算字段:</p><ul class=""><li id="e6bd" class="ml mm iq lu b lv na ly nb lf nc lj nd ln ne mk mq mr ms mt bi translated">语法以关键字<strong class="lu ir"> CASE </strong>开始，后跟一系列<strong class="lu ir"> WHEN </strong>子句，并以<strong class="lu ir"> END </strong>关键字结束</li><li id="391f" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk mq mr ms mt bi translated">每个<strong class="lu ir"> WHEN </strong>子句由一个条件和一个结果(如果该条件评估为真)组成(子句按照它们出现的顺序进行评估)</li><li id="fcd7" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk mq mr ms mt bi translated">如果这些条件都不满足，将执行<strong class="lu ir"> ELSE </strong>子句(如果不使用，不匹配的值将为空)</li><li id="fac6" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk mq mr ms mt bi translated"><strong class="lu ir"> ELSE </strong>子句是可选的，但是我强烈建议您使用它来确保您的代码按预期工作</li></ul><pre class="kg kh ki kj gt oo op oq bn or os bi"><span id="f1b1" class="ot kx iq op b be ou ov l ow ox">---=================================<br/>--- CASE simple example<br/>---=================================<br/>SELECT<br/>  [TerritoryID],<br/>  CASE <br/>    WHEN [TerritoryID] &lt;= 2 THEN 'Low'<br/>    WHEN [TerritoryID] BETWEEN 3 AND 5 THEN 'Mid'<br/>    WHEN [TerritoryID] BETWEEN 6 AND 10 THEN 'High'<br/>    ELSE 'Unknown'<br/>  END AS Territory_Grouped<br/>FROM [Sales].[SalesTerritory]<br/>ORDER BY [TerritoryID]<br/><br/>---=================================<br/>--- CASE advanced<br/>---=================================<br/>SELECT<br/>  [TerritoryID],<br/>  CASE <br/>    WHEN [TerritoryID] &lt;= 2 THEN 'Low'<br/>    WHEN [TerritoryID] BETWEEN 3 AND 10 THEN 'High'<br/>    ELSE 'Unknown'<br/>  END AS Territory_Grouped,<br/> COUNT(*) AS count_records<br/>FROM [Sales].[SalesTerritory]<br/>GROUP BY<br/>  [TerritoryID],<br/>  CASE <br/>    WHEN [TerritoryID] &lt;= 2 THEN 'Low'<br/>    WHEN [TerritoryID] BETWEEN 3 AND 10 THEN 'High'<br/>    ELSE 'Unknown'<br/>  END<br/>ORDER BY [TerritoryID]</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pd"><img src="../Images/d75ae3de8f78b6d9910733f04d491f5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EGjt8saTg2fb5HUUoMjoaQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用案例陈述[图片由作者提供]</p></figure><h1 id="28d0" class="nq kx iq bd ky nr oi nt lb nu oj nw le jw ok jx li jz ol ka lm kc om kd lq oa bi translated">3.2 日期</h1><p id="0d70" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">作为一名数据科学家，您需要经常处理数据中的日期。这通常包括使用以下两个函数。</p><h2 id="f712" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">日期部分()</h2><p id="0538" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">用于提取日期的特定部分，如年、周、小时等。它接受两个参数作为输入；用于提取日期部分和日期本身的度量单位。我们还可以使用<strong class="lu ir"> CAST </strong>函数来更改日期列的数据类型(在下面的示例中，我们将其从 datetime 更改为 date)。</p><pre class="kg kh ki kj gt oo op oq bn or os bi"><span id="2550" class="ot kx iq op b be ou ov l ow ox">---=================================<br/>--- Extracting parts from dates<br/>---=================================<br/>SELECT<br/>  CAST(OrderDate AS DATE) AS OrderDate,<br/>  DATEPART(YEAR, OrderDate) AS year_from_date,<br/>  DATEPART(QUARTER, OrderDate) AS quarter_from_date,<br/>  DATEPART(MONTH, OrderDate) AS month_from_date<br/>FROM [Sales].[SalesOrderHeader]</span></pre><h2 id="141c" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">DATEDIFF()</h2><p id="9b4a" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">用于计算两个日期之间的差异。它接受三个参数作为输入；度量单位、开始日期和结束日期(从左到右)。</p><pre class="kg kh ki kj gt oo op oq bn or os bi"><span id="ac4e" class="ot kx iq op b be ou ov l ow ox">---=================================<br/>--- Calculating difference between dates<br/>---=================================<br/>SELECT<br/>  CAST(OrderDate AS DATE) AS OrderDate,<br/>  CAST(ShipDate AS DATE) AS ShipDate,<br/>  DATEDIFF(DAY, OrderDate, ShipDate) AS date_diff_days<br/>FROM [Sales].[SalesOrderHeader]<br/>ORDER BY date_diff_days DESC</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pe"><img src="../Images/fd42fe0836047451faebd84b02e46fe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*akgJctbFCZriiL37kKCwJg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在 SSMS 处理日期[图片由作者提供]</p></figure><h1 id="040d" class="nq kx iq bd ky nr oi nt lb nu oj nw le jw ok jx li jz ol ka lm kc om kd lq oa bi translated">3.3 CTE 和子查询</h1><p id="6b94" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">您会在大多数讲授 SQL 的教科书中找到子查询，但这不是我在本节中添加它们的原因。我的理由是，我想展示它们的缺点，以及使用 cte(公共表表达式)如何会更好。</p><h2 id="d1fd" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">子查询</h2><p id="b3c1" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">子查询是嵌套在另一个 SELECT 语句中的 SELECT 语句。它们也可以用在 SELECT 语句的 FROM 子句中。无论哪种方式，子查询的结果都将在主 SELECT 语句中使用。让我们来看一些例子。</p><pre class="kg kh ki kj gt oo op oq bn or os bi"><span id="4d9f" class="ot kx iq op b be ou ov l ow ox">---=================================<br/>--- Using nested subqueries<br/>---=================================<br/>SELECT <br/>  COUNT([CustomerID])<br/>FROM [Sales].[SalesOrderHeader]<br/>WHERE [CustomerID] IN ( --- nested subquery starts here<br/> SELECT [CustomerID]<br/> FROM [Sales].[Customer]<br/> WHERE [TerritoryID] = 4<br/>)<br/><br/>---=================================<br/>--- Using subqueries in the FROM<br/>---=================================<br/>SELECT <br/>  COUNT(a.[CustomerID]) AS Count_Cust<br/>FROM ( --- subquery starts here<br/> SELECT *<br/> FROM [Sales].[SalesOrderHeader]<br/> WHERE [TerritoryID] = 4<br/>) a -- you need to add an alias at the end</span></pre><h2 id="f5ec" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak"> CTEs </strong></h2><p id="6e1d" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">尽管 cte 具有与子查询相同的功能(创建一个临时结果，然后可以在主选择中使用)，但它们还有三个主要优点:</p><ul class=""><li id="2d5c" class="ml mm iq lu b lv na ly nb lf nc lj nd ln ne mk mq mr ms mt bi translated">可在查询的不同部分重用</li><li id="6fe2" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk mq mr ms mt bi translated">易于验证和理解(可读性更强)</li><li id="31fa" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk mq mr ms mt bi translated">cte 通常比子查询更有效</li></ul><pre class="kg kh ki kj gt oo op oq bn or os bi"><span id="634c" class="ot kx iq op b be ou ov l ow ox">---======================<br/>--- Using a single CTE<br/>---======================<br/>WITH <br/>select_customers AS (<br/>  SELECT *<br/>  FROM [Sales].[SalesOrderHeader]<br/>  WHERE [TerritoryID] = 4<br/>)<br/>SELECT <br/>  COUNT([CustomerID])<br/>FROM select_customers<br/><br/>---======================<br/>--- Using multiple CTEs<br/>---======================<br/>WITH <br/>select_customers AS (<br/>  SELECT <br/>    [CustomerID]<br/>  FROM [Sales].[Customer]<br/>  WHERE [TerritoryID] = 4<br/>),<br/>select_orders AS (<br/>  SELECT <br/>    CAST(OrderDate AS DATE) AS OrderDate,<br/>    [SalesOrderID],<br/>    [CustomerID],<br/>    [SubTotal]<br/>  FROM [Sales].[SalesOrderHeader]<br/>  WHERE [SubTotal] &gt;= 2000<br/>)<br/>SELECT<br/>  c.[CustomerID],<br/>  SUM([SubTotal]) AS Sum_Total_Due<br/>FROM select_customers c<br/>INNER JOIN select_orders o<br/>  ON c.[CustomerID] = o.[CustomerID]<br/>GROUP BY c.[CustomerID]<br/>ORDER BY Sum_Total_Due</span></pre><p id="3a65" class="pw-post-body-paragraph ls lt iq lu b lv na jr lx ly nb ju ma lf ng mc md lj nh mf mg ln ni mi mj mk ij bi translated">在决定是使用 CTE 还是子查询时，考虑查询的复杂性、性能要求和查询的可读性非常重要。通常，cte 是多次使用的复杂查询的好选择，而子查询是只使用一次的简单查询的好选择。</p><h1 id="fb27" class="nq kx iq bd ky nr oi nt lb nu oj nw le jw ok jx li jz ol ka lm kc om kd lq oa bi translated">3.4 排名功能</h1><p id="76cb" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">排名(窗口)函数是文章中最复杂的部分。然而，你将需要在你的数据科学查询中使用它们，另外，这些经常在面试中被问到。</p><p id="6734" class="pw-post-body-paragraph ls lt iq lu b lv na jr lx ly nb ju ma lf ng mc md lj nh mf mg ln ni mi mj mk ij bi translated">顾名思义，它们是用来对行进行排序的，但是每种方法都略有不同。但是我想得太多了。让我们首先用下面的例子来检查语法:</p><ul class=""><li id="3735" class="ml mm iq lu b lv na ly nb lf nc lj nd ln ne mk mq mr ms mt bi translated">我们将使用<strong class="lu ir"> RANK() </strong>作为 SalesOrderHeader 表中的排名函数</li><li id="846d" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk mq mr ms mt bi translated">我们希望对数据进行分区，这样 RANK()每次都不会应用于整个数据集，而是应用于行的子集。在我们的例子中，我们使用了由 CustomerID 划分的<strong class="lu ir">分区，因此排名被分别应用于每个客户</strong></li><li id="ed7e" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk mq mr ms mt bi translated">最后，我们希望根据 SubTotal 列(即订单的价值)对每个客户的订单进行排序，从 1 开始表示最高支出，依此类推。这就是人们熟悉的的<strong class="lu ir">命令发挥作用的地方</strong></li></ul><pre class="kg kh ki kj gt oo op oq bn or os bi"><span id="472f" class="ot kx iq op b be ou ov l ow ox">---=================================<br/>--- Using the rank function<br/>---=================================<br/>SELECT <br/>  [CustomerID],<br/>  [SalesOrderID],<br/>  [SubTotal],<br/>  RANK() OVER(PARTITION BY [CustomerID] ORDER BY [SubTotal] DESC) AS Ranking<br/>FROM [Sales].[SalesOrderHeader]<br/>ORDER BY [CustomerID], [SubTotal] DESC</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pf"><img src="../Images/34148f2152a4ebbe86005362308190ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FwFrBQrKvwpJtHo_HnPOlw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">SQL 中 RANK()如何工作的示例[图片由作者提供]</p></figure><p id="5eae" class="pw-post-body-paragraph ls lt iq lu b lv na jr lx ly nb ju ma lf ng mc md lj nh mf mg ln ni mi mj mk ij bi translated">作为一名数据科学家，您将经常使用 SQL 中的四个排名函数。让我们使用来自<strong class="lu ir"> SalesOrderHeader </strong>表的数据来看看它们之间的区别。</p><pre class="kg kh ki kj gt oo op oq bn or os bi"><span id="d333" class="ot kx iq op b be ou ov l ow ox">---=================================<br/>--- Example using all ranking functions<br/>---=================================<br/>SELECT <br/>  [CustomerID],<br/>  [SalesOrderID],<br/>  CAST(OrderDate AS DATE) AS OrderDate,<br/>  RANK() OVER(PARTITION BY [CustomerID] ORDER BY [OrderDate] DESC) AS [RΑΝΚ],<br/>  DENSE_RANK() OVER(PARTITION BY [CustomerID] ORDER BY [OrderDate] DESC) AS [DENSE_RANK],<br/>  ROW_NUMBER() OVER(PARTITION BY [CustomerID] ORDER BY [OrderDate] DESC) AS [ROW_NUMBER],<br/>  NTILE(2) OVER(PARTITION BY [CustomerID] ORDER BY [OrderDate] DESC) AS [NTILE]<br/>FROM [Sales].[SalesOrderHeader]<br/>WHERE [CustomerID] = 11078<br/>ORDER BY [CustomerID], [OrderDate] DESC</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pg"><img src="../Images/1b68951438d3af16549e1cf7579d3ef2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DSN-RdkHaGTQBzT6eR73Cw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">排名函数如何不同的示例[图片由作者提供]</p></figure><ul class=""><li id="f1be" class="ml mm iq lu b lv na ly nb lf nc lj nd ln ne mk mq mr ms mt bi translated"><strong class="lu ir"> ROW_NUMBER() </strong>:为结果集中的每一行分配一个唯一的序列号</li><li id="f486" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk mq mr ms mt bi translated"><strong class="lu ir"> RANK(): </strong>返回结果集分区中每行的排名。在平局的情况下，特定行的等级是 1 加上它前面的等级值的数量</li><li id="65a5" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk mq mr ms mt bi translated"><strong class="lu ir"> DENSE_RANK() </strong>:返回结果集分区中每行的排名。在出现平局的情况下，特定行的排名是 1 加上在它之前的不同排名值的数量</li><li id="4f9c" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk mq mr ms mt bi translated"><strong class="lu ir"> NTILE(n): </strong>将结果集中的行分成 n 个相等的组(或平铺块)，并根据每一行所属的组为每一行指定一个等级。该函数可用于计算中位数和其他百分位数</li></ul><p id="00a0" class="pw-post-body-paragraph ls lt iq lu b lv na jr lx ly nb ju ma lf ng mc md lj nh mf mg ln ni mi mj mk ij bi translated">就这样，我们结束了。我们已经谈了很多，所以我相信<strong class="lu ir">祝贺</strong>已经准备好了！🚀🚀🚀</p><p id="1219" class="pw-post-body-paragraph ls lt iq lu b lv na jr lx ly nb ju ma lf ng mc md lj nh mf mg ln ni mi mj mk ij bi translated"><strong class="lu ir">我还提供了一些练习来帮助你提高 SQL 技能。</strong></p><ol class=""><li id="0b2c" class="ml mm iq lu b lv na ly nb lf nc lj nd ln ne mk on mr ms mt bi translated">查找到期总金额(SalesOrderHeader。TotalDue)，按月份和年份分组(SalesOrderHeader。订单日期)。然后过滤行，只保留一月到三月。最后，重命名列，并按年份和月份对结果进行排序(降序)</li><li id="aeba" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk on mr ms mt bi translated">求平均金额(SalesOrderDetail <strong class="lu ir">)。</strong> LineTotal)，按年份分组(SalesOrderHeader。订单日期)和产品名称(产品。姓名)</li><li id="53a8" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk on mr ms mt bi translated">尝试练习 2，使用 cte</li><li id="7caf" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk on mr ms mt bi translated">在练习 2 中，使用 ROW_NUMBER()只保留每月表现最好的前 5 个产品(LineTotal aggregate)。使用 cte</li><li id="4743" class="ml mm iq lu b lv mu ly mv lf mw lj mx ln my mk on mr ms mt bi translated">使用 CASE 语句创建一个新的计算字段，该字段拆分到期总金额(SalesOrderHeader。TotalDue)分成五个桶(低、中等。)，然后对于每个桶，求平均运费成本(SalesOrderHeader。运费)</li></ol><p id="35bf" class="pw-post-body-paragraph ls lt iq lu b lv na jr lx ly nb ju ma lf ng mc md lj nh mf mg ln ni mi mj mk ij bi translated">我希望这篇文章对你有所帮助，并祝你在查询中愉快！</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="aa39" class="nq kx iq bd ky nr ns nt lb nu nv nw le jw nx jx li jz ny ka lm kc nz kd lq oa bi translated">请继续关注第 3 部分！</h1><p id="9a7a" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">如果你喜欢阅读这篇文章，并想了解更多，别忘了订阅<a class="ae kv" href="https://medium.com/@alex.vamvakaris.ds/subscribe" rel="noopener"><strong class="lu ir"/></a>，让我的故事直接发送到你的收件箱。</p><p id="cb2d" class="pw-post-body-paragraph ls lt iq lu b lv na jr lx ly nb ju ma lf ng mc md lj nh mf mg ln ni mi mj mk ij bi translated">在下面的链接中，您还可以找到一个免费的 PDF 演示，介绍如何使用 r。</p><div class="ph pi gp gr pj pk"><a href="https://www.aspiringdatascientist.net/community" rel="noopener  ugc nofollow" target="_blank"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd ir gy z fp pp fr fs pq fu fw ip bi translated">数据科学项目清单-有抱负的数据科学家</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">我是一名拥有 7 年以上分析经验的数据科学家，目前在英国伦敦的一家游戏公司工作。我的…</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">www.aspiringdatascientist.net</p></div></div><div class="pt l"><div class="pu l pv pw px pt py kp pk"/></div></div></a></div></div></div>    
</body>
</html>