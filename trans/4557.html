<html>
<head>
<title>Estimating Event-specific Counts in Streaming Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">估计流数据中特定于事件的计数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/estimating-event-specific-counts-in-streaming-data-c237f51ead4f#2022-10-10">https://towardsdatascience.com/estimating-event-specific-counts-in-streaming-data-c237f51ead4f#2022-10-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6fa7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">简单而引人注目的CountMin草图</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/05c11fb4a8acdf77a7e626d7e0531a73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2nul1-k8tcU4wvB9t81NmA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@luism_arias?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">路易斯·阿里亚斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/counting?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="7d75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一串输入符号<em class="lv"> a </em>，<em class="lv"> b </em>，<em class="lv"> a </em>，<em class="lv"> c </em>，<em class="lv"> a </em>，…。我们想知道某个符号到达了多少次。</p><p id="c760" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题有很多用途。计算向谷歌进行某项查询、在YouTube上观看某个视频或从iTunes购买某首歌曲的次数。和许多其他人。</p><p id="1c5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用散列表来解决这个问题，散列表的键是目前为止在流中看到的不同符号，值是它们的频率。然后可以从这个散列表中查找任何符号的计数。</p><p id="58e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当有数十亿个不同的符号时，这种方法会消耗大量内存。</p><p id="c9bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们愿意牺牲一些计数的准确性，我们可以使用一个非常紧凑的数据结构来解决这个问题。此外，数据结构将以流式方式更新。</p><p id="3c42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，我们开始吧。首先，目录详细地揭示了我们将涉及的内容。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="5a53" class="mb mc it lx b gy md me l mf mg"><strong class="lx iu">Single Hash Function<br/>   </strong>Randomizing the Hash Function<br/>   Example 3<br/><strong class="lx iu">Multiple Hash Functions <br/>   </strong>Example <br/>   Estimated Symbol’s Count <br/>   Example <br/>   Very High-Dimensional Universes <br/>   Sparse Representations <br/>   Why Use Multiple Hash Functions? <br/>   Choosing The Hash Functions <br/>   Running Time <br/>   Mergability <br/>   Design Choices And Tradeoffs: A Thought Experiment <br/><strong class="lx iu">Very High-Dimensional Use Cases</strong> <br/>   Text Documents As Symbols <br/>   Configuring The CountMinSketch On Text Documents <br/>   Count Estimation Example <br/>   The Expected Effects Of Our Configuration Choices <br/><strong class="lx iu">Summary <br/>Further Reading </strong></span></pre><p id="cafb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">单哈希函数</strong></p><p id="ecc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从散列表方法开始,“进化我们的方式”到CountMinSketch。为了便于说明，我们将使用一个运行场景，其中的符号是32位二进制向量。</p><p id="707a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">hashmap方法使用计数器的映射<em class="lv"> C </em>。最初，地图是空的。就好像宇宙中所有的符号都是0计数。当一个新的符号<em class="lv"> v </em>到达流中时，我们将<em class="lv"> C </em> [ <em class="lv"> v </em> ]加1。我们查任意符号<em class="lv"> v </em>在任意时刻的频率为<em class="lv"> C </em> [ <em class="lv"> v </em> ]。</p><p id="6847" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的内存需求是流中不同符号的数量，在最坏的情况下是2。如果流已经有许多不同的到达，这可能是一个问题。比如几十亿。即使到目前为止这个流只接收到少量的不同符号，我们也不能保证<em class="lv"> C </em>的大小最终不会爆炸。</p><p id="e440" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们开始概括，试图防止<em class="lv"> C </em>爆炸。</p><p id="f4cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让<em class="lv"> h </em> ( <em class="lv"> v </em>)表示我们应用于符号<em class="lv"> v </em>的特定散列函数。在上一段的描述中，我们把每一次出现的<em class="lv"> C </em> [ <em class="lv"> v </em> ]都换成<em class="lv">C</em>[<strong class="lb iu"><em class="lv">h</em></strong>(<em class="lv">v</em>)】。hashmap方法对应于使用哈希函数<em class="lv"> h </em> ( <em class="lv"> v </em>)等于<em class="lv"> v </em>。</p><p id="f3f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是事情开始变得有趣的地方。现在让我们使用一个散列函数，它的范围比宇宙的大小小得多。例如，<em class="lv"> h </em> ( <em class="lv"> v </em>)返回<em class="lv"> v </em>的前16位。<em class="lv"> h </em> ( <em class="lv"> v </em>)的范围在65K左右。所以<em class="lv"> C </em>永远不需要超过65K的计数器，远远少于2。</p><p id="1374" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们必须付出代价。我们是。我们现在可以有碰撞。假设两个符号<em class="lv"> u </em>和<em class="lv"> v </em>具有相同的hash值，即<em class="lv"> h </em> ( <em class="lv"> u </em>)等于<em class="lv"> h </em> ( <em class="lv"> v </em>)。<em class="lv"> u </em>和<em class="lv"> v </em>的计数混合到同一个计数器<em class="lv">C</em>[<em class="lv">h</em>(<em class="lv">u</em>)】。也就是说，虽然我们无法辨别<em class="lv"> u </em>或<em class="lv"> v </em>的真实计数，但我们可以肯定地说<em class="lv">C</em>[<em class="lv">h</em>(<em class="lv">u</em>)]是两者的上限。例如，如果[ <em class="lv"> h </em> ( <em class="lv"> u </em> )]为0，我们可以确定地知道，无论是<em class="lv"> u </em>还是<em class="lv"> v </em>都没有到达流中。</p><p id="b170" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总结</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="a3fc" class="mb mc it lx b gy md me l mf mg">To better bound the number of counters, we use a hash function whose range is <strong class="lx iu">constricted</strong>. While this potentially sacrifices accuracy, our estimated counts remain <strong class="lx iu">upper bounds</strong>.</span></pre><p id="5af4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">随机化散列函数</strong></p><p id="eef3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哈希函数“提取前16位”偏向于前16位。一个简单的随机化方法使其无偏。</p><p id="c4d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先在初始化阶段，产生一个随机的32位二进制数，其中正好有16位为1值。(随机性在于这些1值的位置。)记录这个数字，并在计算任何符号的哈希值时将其用作掩码。</p><p id="2fc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在下面的例子中说明这一点。</p><p id="7db9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">例子</strong></p><p id="51b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们将宇宙限制为8位数字。请注意，哈希值是一个4位数。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="12be" class="mb mc it lx b gy md me l mf mg">mask  0 <strong class="lx iu">1</strong> <strong class="lx iu">1</strong> 0 0 <strong class="lx iu">1</strong> 0 <strong class="lx iu">1</strong><br/>value 1 <strong class="lx iu">1</strong> <strong class="lx iu">1</strong> 0 0 <strong class="lx iu">0</strong> 0 <strong class="lx iu">1</strong><br/>hash    <strong class="lx iu">1</strong> <strong class="lx iu">1</strong>     <strong class="lx iu">0</strong>   <strong class="lx iu">1</strong></span></pre><p id="f60b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">非常高维度的宇宙</strong></p><p id="c66a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们运行的例子中，二进制向量是32位长。有些情况下，位向量要长得多，有数百万或数十亿位。我们将在后面的章节中讨论它们。CountMinSketch在那里特别有吸引力。</p><p id="27cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">稀疏表示</strong></p><p id="71b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至此，我们已经隐含地假设<em class="lv"> C </em>是由所选散列函数的范围索引的数组。在许多用例中，我们想要使用的散列函数可能有很大的范围。也就是说，<em class="lv"> m </em>非常大，可能几十亿。</p><p id="8087" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使在低维宇宙中，选择的哈希函数也可能有非常大的范围。我们之前见过一个例子，<em class="lv"> h </em> ( <em class="lv"> v </em> ) = v其中<em class="lv"> m </em>在32位二进制向量的论域上是2。显然，对于一个更高维度的宇宙，这变得更加可能。</p><p id="230a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，<em class="lv"> C </em>的一种自然表示就是散列表。<em class="lv"> C </em>的键是目前为止在流中观察到的<em class="lv"> h </em> ( <em class="lv"> v </em>)的值。<em class="lv">C</em>[<em class="lv">h</em>(<em class="lv">v</em>)]照例是<em class="lv"> h </em> ( <em class="lv"> v </em> ) <em class="lv">的</em>数。</p><p id="4dc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当在流中观察到的<em class="lv"> h </em> ( <em class="lv"> v </em>)的不同值的数量远小于<em class="lv"> m </em>时，这种表示非常紧凑。实际情况往往如此。</p><p id="e2d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">多个哈希函数</strong></p><p id="7312" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用多个散列函数<em class="lv"> h </em> 1、…、<em class="lv"> hn </em>，都在相同的范围1、2、…、<em class="lv"> m </em>上。我们将把我们的计数器映射归纳为一个计数器矩阵。行索引散列函数。这些列索引散列值，都在范围1、2、…、<em class="lv"> m </em>内。<em class="lv"> C </em> [ <em class="lv"> i </em>，<em class="lv"> hi </em> ( <em class="lv"> v </em> )]将存储对符号<em class="lv"> v </em>应用<em class="lv"> i </em> th哈希函数的计数。</p><p id="b702" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当符号<em class="lv"> v </em>到达流中时，从1到<em class="lv"> n </em>，每增加一个<em class="lv">I</em>C[<em class="lv">I</em>][<em class="lv">hi</em>(<em class="lv">v</em>)】就增加1。如下图所示。</p><p id="4f71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">示例</strong></p><p id="93eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了方便起见，我们将使用一个比我们运行的宇宙基数更高的宇宙。</p><p id="4310" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的符号将是以4为基数的3位数。即<em class="lv">v</em>=<em class="lv">v</em>1<em class="lv">v</em>2<em class="lv">v</em>3其中每个<em class="lv"> vi </em>为0、1、2或3。我们将使用三个哈希函数<em class="lv"> h </em> 1( <em class="lv"> v </em>)、<em class="lv"> h </em> 2( <em class="lv"> v </em>)和<em class="lv"> h </em> 3( <em class="lv"> v </em>)。一位数一个。<em class="lv"> hi </em> ( <em class="lv"> v </em>)将等于<em class="lv"> vi，</em>v<em class="lv">v</em>的第<em class="lv"> i </em>位的值。例如，<em class="lv"> h </em> 2(1 <strong class="lb iu"> 3 </strong> 2)等于3，如粗体所示。</p><p id="60bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv"> C </em>是一个3×4矩阵，因为我们有三个散列函数，每个散列函数都有四个相同的值。</p><p id="9312" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设符号011和232分别到达流中四次和七次。最后，不管它们到达的顺序如何，<em class="lv"> C </em>是</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="46c7" class="mb mc it lx b gy md me l mf mg">  <strong class="lx iu">0 1 2 3</strong><br/><strong class="lx iu">1</strong> 4 0 7 0<br/><strong class="lx iu">2</strong> 0 4 0 7<br/><strong class="lx iu">3</strong> 0 4 7 0</span></pre><p id="56dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv"> C </em>的行和列，用粗体显示，分别索引数字位置和数字值。</p><p id="fc60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来解释一下<em class="lv">C</em>【2】【1】。它至少是4，因为0 <strong class="lb iu"> 1 </strong> 1在流中出现了四次，并且它的第二个数字是1。It <em class="lv"> </em>不大于4，因为没有冲突，因为在流中出现的唯一的另一个符号232在第二位置具有不同的值。</p><p id="9d1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">估计符号数</strong></p><p id="0993" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回想一下，对于任何符号<em class="lv"> v </em>，我们想要估计它到目前为止到达流中的次数。</p><p id="6c43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用单个散列函数时，符号的估计计数只是简单的<em class="lv">C</em>[<em class="lv">h</em>(<em class="lv">v</em>)】。当我们使用多个哈希函数时，<em class="lv"> v </em>的出现影响<em class="lv"> n </em>计数器<em class="lv"> C </em> [ <em class="lv"> i </em>，<em class="lv">hi</em>(<em class="lv">v</em>)】for<em class="lv">I</em>范围从1到<em class="lv"> n </em>。我们如何从n次计数得到一个估计值呢？</p><p id="be2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回想一下，在上一节中我们注意到，对于任何固定的哈希函数<em class="lv"> h </em>，<em class="lv">C</em>[<em class="lv">h</em>(<em class="lv">v</em>)]是<em class="lv"> v </em>的真实计数的上限。在<em class="lv"> n </em>哈希函数的设置中，这意味着对于范围从1到n 的<em class="lv"> i </em>，每个<em class="lv">C</em><em class="lv">I</em>，<em class="lv"> hi </em> ( <em class="lv"> v </em>)】都是<em class="lv"> v </em>的真实计数的一个上界。因此，这些上限中最小的一个作为这个真实计数的最佳估计。也就是说，我们有</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="ddc6" class="mb mc it lx b gy md me l mf mg">CountUB(v): The minimum of C[i][hi(v)] for i from 1 to n</span></pre><p id="b49e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">例子</strong></p><p id="543a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们来计算宇宙中几个数字的估计数。一个将被证明是精确的计数，另一个是明显的高估。</p><p id="431c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑232。CountUB(232)是下面粗体显示的三个单元格<em class="lv">C</em>【1】【2】、<em class="lv">C</em>【2】【3】和<em class="lv">C</em>【3】【2】中的最小计数。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="0ebf" class="mb mc it lx b gy md me l mf mg"><strong class="lx iu">  0 1 2 3</strong><br/><strong class="lx iu">1</strong> 4 0 <strong class="lx iu">7</strong> 0<br/><strong class="lx iu">2</strong> 0 4 0 <strong class="lx iu">7</strong><br/><strong class="lx iu">3</strong> 0 4 <strong class="lx iu">7</strong> 0</span></pre><p id="ce6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，注意这些单元中的每一个都是无冲突的。它只记录流中232的出现次数。011是该流接收到的唯一的另一个符号，它不影响任何这些单元。这是因为两个符号{2，3}和{0，1}中的值集是不相交的。因此，这三个单元格中的最小值7正好是232的真实计数。</p><p id="2079" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来考虑212。CountUB(212)是下面以粗体显示的三个单元格中的最小计数。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="d5a5" class="mb mc it lx b gy md me l mf mg"><strong class="lx iu">  0 1 2 3</strong><br/><strong class="lx iu">1</strong> 4 0 <strong class="lx iu">7</strong> 0<br/><strong class="lx iu">2</strong> 0 <strong class="lx iu">4</strong> 0 <strong class="lx iu">7</strong><br/><strong class="lx iu">3</strong> 0 4 <strong class="lx iu">7</strong> 0</span></pre><p id="ceaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">CountUB(212)是4，而212的真实计数是零。这是因为所有三个单元都有相对于212的冲突。这是因为<strong class="lb iu">2</strong>T2 1T4 2在第一和第三位置与<strong class="lb iu"> 2 </strong> 3 <strong class="lb iu"> 2 </strong>碰撞，在第二位置与0 <em class="lv"> 1 </em> 1碰撞。</p><p id="ad52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">为什么要使用多个哈希函数？</strong></p><p id="9832" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与其使用多个散列函数，为什么不适当地扩大单个散列函数的范围呢？考虑我们运行的universe示例中的散列函数“提取前16位”。它使用大约65K的计数器。假设我们添加了第二个哈希函数“提取接下来的16位”。现在这两个加起来用了~130K计数器。我们可以使用单个散列函数“提取第一个<strong class="lb iu"> 17 </strong>位”并获得相同数量的计数器。</p><p id="a7c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用多个散列函数的直觉围绕着在估计符号计数中使用最小<em class="lv">运算。例如，为了精确估计符号的计数，最小操作中涉及的仅仅一个单元是无冲突的就足够了。</em></p><p id="54a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用多个散列函数的好处，尤其是使用最小操作的好处，将在后面关于非常高维用例的章节中更清楚地展现出来。</p><p id="fa01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">选择哈希函数</strong></p><p id="2ae7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哈希函数应该是独立的。这个想法是为了减少碰撞。也就是多元化。</p><p id="bced" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为相反类型的极端例子，考虑当所有散列函数都相同时。使用多个并没有给我们带来任何好处。在额外的内存和计算需求中，我们确实承担了使用多个的所有成本。</p><p id="9f09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个具体的例子，在我们的32位独立数的宇宙中，有4个合理的散列函数可供选择。<em class="lv"> h </em> 1、<em class="lv"> h </em> 2、<em class="lv"> h </em> 3、<em class="lv"> h </em> 4将分别提取第一、第二、第三和第四个8位的块。</p><p id="9cc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">运行时间</strong></p><p id="f787" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设散列函数可以在恒定时间内被评估，在计数器矩阵<em class="lv"> C </em>中寻找和增加适当的计数器的运行时间与散列函数的数量<em class="lv"> n </em>成比例。计算任何符号的估计计数也在与<em class="lv"> n </em>成比例的时间内运行，因为它涉及查找<em class="lv"> n </em>个单元并计算它们的最小值。</p><p id="94ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">可制造性</strong></p><p id="5f4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个概念，将两个流分别创建的草图合并，会产生与从两个流合并的单个流中获得的草图相同的草图。</p><p id="dc49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可合并性在分布式设置中是非常有用的操作。它允许以分布式的方式从不同的流中构建草图。然后根据需要进行合并，以估计全局计数，即，好像来自所有流的合并。</p><p id="4401" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只要所有草图使用相同的散列函数，CountMinSketch就是可合并的。</p><p id="1cd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以表示如下:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="3a8d" class="mb mc it lx b gy md me l mf mg">C(S1) + C(S2) = C(S1 + S2)</span></pre><p id="88c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里<em class="lv"> C </em> ( <em class="lv"> S </em>)表示由流<em class="lv"> S </em>构建的草图，LHS中的“+”表示草图合并操作，RHS中的“+”表示流合并操作。</p><p id="ef35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">合并两个CountMinSketches很简单:只需按组件将它们的矩阵相加。这在下面描述。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="9336" class="mb mc it lx b gy md me l mf mg">C[i,j] = C1[i,j] + C2[i,j] for all i, j</span></pre><p id="957a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv"> C </em>是<em class="lv"> C </em> 1和<em class="lv"> C </em> 2的合并。</p><p id="d2ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">设计选择和权衡:一个思维实验</strong></p><p id="2438" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">散列函数的数量及其范围的大小如何影响各种权衡？</p><p id="94b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的思维实验将帮助我们思考这些问题。</p><p id="034c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的宇宙将是32位数字。我们将考察<em class="lv"> n </em> = 1，2，4，8，…，32的各种配置。</p><p id="e1f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">配置<em class="lv"> n </em>会使用<em class="lv"> n </em>哈希函数<em class="lv"> h </em> 1( <em class="lv"> n </em>)，…，<em class="lv"> h </em> 2( <em class="lv"> n </em>)。<em class="lv"> hi </em> ( <em class="lv"> n </em>)将从一个32位数字中提取32/ <em class="lv"> n </em>位的第<em class="lv"> i </em>块。</p><p id="9dce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">配置<em class="lv"> n </em> =1使用单一哈希函数<em class="lv">h</em>(<em class="lv">v</em>)=<em class="lv">v</em>。在另一个极端，配置<em class="lv"> n </em> =32使用32个哈希函数<em class="lv">hi</em>(<em class="lv">v</em>)=<em class="lv">VI</em>，其中<em class="lv"> i </em>范围从1到<em class="lv"> n </em>。</p><p id="265c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv"> n </em> =1配置提供完全精确的计数。然而，在最坏的情况下，它可能需要2个计数器。在另一个极端，<em class="lv"> n </em> =32，我们只需要32*2=64个计数器。显然，估计的符号计数可能相当不准确。</p><p id="6572" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很明显，随着<em class="lv"> n </em>的增加，内存限制会成倍增加。这是因为<em class="lv"> C </em>中的行数随着<em class="lv"> n </em>线性增加，而列数呈指数减少。</p><p id="83db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">精确度如何下降尚不清楚。</p><p id="38f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个极端之间的某个地方可能是用户认为可以接受的特定折衷的最佳点。内存需求与准确性的对比。到达数据流的数据的性质也明显影响这种权衡。</p><p id="36b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">非常高维的用例</strong></p><p id="8b85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">文本文件作为符号</strong></p><p id="ec2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们的“符号”是到达流中的文本文档。例如，到达Twitter流的推文。比方说，对于每个文档，我们想要估计它在流中被观察到的次数。</p><p id="a203" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按照惯例，让我们在向量空间模型中用一个合适的向量来表示一个文档。向量的维数是词典中术语的数量，通常以百万计。第<em class="lv"> i </em>个成分表示词典中的第<em class="lv"> i </em>个术语。</p><p id="5730" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以将文档向量的第<em class="lv"> i </em>个分量的值设置为文档中第I个词典项的频率。或者该频率的二进制版本。或者更高级的变体，其利用术语的IDF来调整该频率。</p><p id="3194" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，现在我们已经将文档编码为相同固定维度的向量。我们现在试图估计在水流中观察到的不同矢量的数量。</p><p id="9c12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，不同的向量计数不一定是不同的文档计数。这是因为多个文档可能具有相同的矢量编码。</p><p id="8920" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能是一件好事。通过适当地选择文档的矢量编码，我们可以忽略我们可能不关心的细微差别。</p><p id="00d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">在文本文档上配置count minsketch</strong></p><p id="0c16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种设置中，什么是合理的哈希函数？这里有一个。所谓的比特采样哈希函数，hi(v) = vi，我们在本帖前面遇到过。它只是提取v的第I个分量。在我们的设置中，这对应于词典中的特定术语。</p><p id="6c67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值<em class="lv"> vi </em>取决于我们的矢量编码。我们可以将它作为术语在文档中的出现指示符(布尔型)，或者它的频率。或者更复杂的东西。我们的选择隐含地定义了我们正在计数的内容。例如，当<em class="lv"> v </em>为布尔向量编码时，哈希函数<em class="lv">h</em>_<em class="lv">data</em>(<em class="lv">v</em>)根据<em class="lv"> v </em>编码的文档中是否出现<em class="lv"> data </em>一词，返回<em class="lv"> true </em>或<em class="lv"> false </em>。</p><p id="bbcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本节的其余部分，我们将仅限于布尔型的位采样散列函数。</p><p id="6997" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个问题:我们应该使用多个哈希函数吗？如果我们能够负担得起使用词典中有多少术语就有多少哈希函数(可能有数百万)，是的，那就好了。如果没有，我们可能首先选择一个我们能负担得起的词典的随机子集，并使用与之对应的散列函数。</p><p id="f8f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">计数估计示例</strong></p><p id="25f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于特定的<em class="lv"> v </em>，CountUB( <em class="lv"> v </em>)会是什么？让我们用一个玩具的例子来说明。这个例子将引发一场有趣的讨论。</p><p id="bbb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，为了便于阅读，我们将“估计文档的频率”简称为“估计文档的矢量编码的频率”。</p><p id="77a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们的词典正好由五个词组成:<em class="lv">数据</em>、<em class="lv">数据</em>、数据<em class="lv">、<em class="lv">挖掘</em>数据<em class="lv">计算机</em>。比方说我们要估计文档{ <em class="lv">数据</em>，<em class="lv"> of </em> }在流中出现的频率。</em></p><p id="edf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们确定在这个估计中我们需要的特定计数器。分别是<em class="lv">C</em><em class="lv">数据【T17，1】，<em class="lv">C</em><em class="lv">【T21，1】，<em class="lv">C</em><em class="lv">【T25，0】，<em class="lv">C</em><em class="lv">采矿【T29，0】，<em class="lv">C</em><em class="lv">计算机【T33，0】。前两个分别计算流中包含单词<em class="lv"> data </em>和<em class="lv"> mining </em>的文档的数量。接下来的三个分别计算流中不包含单词<em class="lv">、</em>、</em>的<em class="lv">和<em class="lv">计算机</em>的文档的数量。接下来，我们取其中的最小值，并将其作为估计值返回。</em></em></em></em></em></p><p id="2b54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在进行非正式讨论。这将有助于想象词典是维基百科中所有不同的文章。并且该流的文档是从该语料库中提取的。</p><p id="db48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们期望<em class="lv"> C </em> [ <em class="lv">数据【T47，1】比<em class="lv">C</em>[【T51，1】的<em class="lv">小得多，因为</em>的<em class="lv">比<em class="lv">数据</em>更常见。我们预计<em class="lv"> C </em> [ <em class="lv"> the 【T61，0】比C[ <em class="lv"> mining 【T63，0】或<em class="lv"> C </em> [ <em class="lv"> computer 【T67，0】要小得多，因为大多数维基百科文章中都有单词<em class="lv"> the </em>。对于<em class="lv">采矿</em>或<em class="lv">电脑</em>来说并非如此。</em></em></em></em></em></p><p id="4293" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们预计我们的文档在流中的估计频率将是<em class="lv"> C </em> [ <em class="lv">数据【T77，1】和<em class="lv"> C </em> [ <em class="lv"> the </em>，0]中的最小值。换句话说，是“包含单词<em class="lv">数据</em>的维基百科文章数量”和“不包含单词<em class="lv">数据</em>的维基百科文章数量”中较小的一个。</em></p><p id="8638" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">我们的配置选择的预期效果</strong></p><p id="7c0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很明显，随着我们增加哈希函数的数量，即增加我们跟踪的<em class="lv">存在</em>和<em class="lv">不存在</em>计数的词典项的数量，估计精度应该会提高。我们跟踪的词典单词数量越多，我们就越能期望它们在特定文档中的存在和不存在计数的最小值接近真实计数。</p><p id="a18a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">总结</strong></p><p id="9062" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章讨论了在一个可能无界的流中估计某个符号出现次数的问题。它专注于CountMinSketch，这是一种带有伴随算法的数据结构，在流设置中特别有吸引力。它只对数据进行一次操作，并且可以根据我们的需要配置使用更少或更多的内存。(后者是为了提高精度或用于非常高维的用例)。</p><p id="8d50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">延伸阅读</strong></p><ol class=""><li id="b0cd" class="mh mi it lb b lc ld lf lg li mj lm mk lq ml lu mm mn mo mp bi translated">https://en.wikipedia.org/wiki/Count%E2%80%93min_sketch<a class="ae ky" href="https://en.wikipedia.org/wiki/Count%E2%80%93min_sketch" rel="noopener ugc nofollow" target="_blank"/></li><li id="1191" class="mh mi it lb b lc mq lf mr li ms lm mt lq mu lu mm mn mo mp bi translated">【https://web.stanford.edu/class/cs168/l/l2.pdf T4】</li></ol></div></div>    
</body>
</html>