<html>
<head>
<title>Scikit-learn 1.1 Comes with an Improved OneHotEncoder</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scikit-learn 1.1附带了一个改进的OneHotEncoder</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/scikit-learn-1-1-comes-with-an-improved-onehotencoder-5a1f939da190#2022-10-22">https://towardsdatascience.com/scikit-learn-1-1-comes-with-an-improved-onehotencoder-5a1f939da190#2022-10-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d553" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个简单但非常实用的功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/72d238b9101d0d379caddf41341e7402.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IOsfVznrbKSvM3xw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/s/photos/new?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@jannerboy62?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">尼克·费因斯</a>拍摄</p></figure><p id="3296" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Scikit-learn是数据科学生态系统中最常用的Python库之一。它作为一个完整的工具，用于从数据预处理到模型评估的机器学习任务。</p><p id="456f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">表格数据集中的要素很少使用，因为它们出现在原始数据中。在用作机器学习模型的输入之前，它们通常需要额外的数据预处理步骤。</p><p id="53d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html" rel="noopener ugc nofollow" target="_blank"> OneHotEncoder </a>就是这些转变的一个例子。它对分类特征进行编码。下图说明了一键编码在分类要素上的工作方式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/57bb2731456df5d47f20b2c826117f76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x_DYdNVsPiRoDpSoRGJo3Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="96bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一些机器学习算法的必需操作，因为它们期望所有的特征都是数字的。除非我们使用基于树的算法，比如随机森林，否则分类特征需要转换成数字特征。</p><p id="9ef7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上图所示，一键编码为每个类别创建了一列。在分类变量有很多不同值的情况下，我们将有一个非常高维的特征空间。</p><p id="51e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有些类别与其他类别相比出现的次数很少，那么最好将它们分组。为这些类别创建单独的列可能会增加模型的计算和内存负担，而不会提供显著的价值。</p><p id="9f66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Scikit-learn 1.1附带的新OneHotEncoder允许对不常用的类别进行分组。让我们做一个例子来演示它是如何使用的。</p><p id="6c9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始之前，让我们确保您有正确的版本。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="00d7" class="mb mc it lx b gy md me l mf mg">import sklearn<br/>sklearn.__version__<br/><strong class="lx iu"># output</strong><br/>'1.1.2'</span></pre><p id="5a52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有1.1之前的版本，可以使用pip更新它。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="b9c6" class="mb mc it lx b gy md me l mf mg">pip install --upgrade scikit-learn</span></pre></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><p id="8bba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个具有两个分类特征的样本数据框架。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="bce9" class="mb mc it lx b gy md me l mf mg">import pandas as pd</span><span id="3e6d" class="mb mc it lx b gy mo me l mf mg">df = pd.DataFrame({</span><span id="2bb7" class="mb mc it lx b gy mo me l mf mg">  "City": ["Houston"] * 25 + ["Rome"] * 30 + ["Madrid"] * 3 + <br/>          ["London"] * 2,<br/>    <br/>  "Division": ["A"] * 30 + ["B"] * 25 + ["C"] * 1 + ["D"] * 4</span><span id="785b" class="mb mc it lx b gy mo me l mf mg">})</span><span id="6af9" class="mb mc it lx b gy mo me l mf mg">df["City"].value_counts()<br/><strong class="lx iu"># output</strong><br/>Rome       30<br/>Houston    25<br/>Madrid      3<br/>London      2<br/>Name: City, dtype: int64</span><span id="ad02" class="mb mc it lx b gy mo me l mf mg">--------------------------------------<br/>df["Division"].value_counts()<br/><strong class="lx iu"># output<br/></strong>A    30<br/>B    25<br/>C     1<br/>D     4<br/>Name: Division, dtype: int64</span></pre><p id="a48b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在城市列中，有3个马德里和2个伦敦值，比其他两个城市少得多。除法列中值的分布也类似。</p><p id="a27b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是对这两个特征进行编码。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="3986" class="mb mc it lx b gy md me l mf mg">from sklearn.preprocessing import OneHotEncoder</span><span id="9fd7" class="mb mc it lx b gy mo me l mf mg"><strong class="lx iu"># create an encoder and fit the dataframe</strong><br/>enc = OneHotEncoder(sparse=False).fit(df)<br/>encoded = enc.transform(df)</span><span id="fff4" class="mb mc it lx b gy mo me l mf mg"><strong class="lx iu"># convert it to a dataframe</strong><br/>encoded_df = pd.DataFrame(<br/>     encoded, <br/>     columns=enc.get_feature_names_out()<br/>)</span><span id="b8c3" class="mb mc it lx b gy mo me l mf mg">encoded_df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/cb197a865cbbabb11fb63782fca97f6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3p4DD8pqEVCPOIMdVF7z-w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="1881" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们没有对不经常出现的值进行分组，所以编码数据中有8列。让我们用分组来尝试一下，这可以使用<strong class="lb iu"> min_frequency </strong>参数来完成。出现次数少于指定最小频率的类别将被分组。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="6729" class="mb mc it lx b gy md me l mf mg"><strong class="lx iu"># create an encoder and fit the dataframe</strong><br/>enc = OneHotEncoder(min_frequency=5, sparse=False).fit(df)<br/>encoded = enc.transform(df)</span><span id="f5f0" class="mb mc it lx b gy mo me l mf mg"><strong class="lx iu"># convert it to a dataframe</strong><br/>encoded_df = pd.DataFrame(<br/>     encoded, <br/>     columns=enc.get_feature_names_out()<br/>)</span><span id="1f4f" class="mb mc it lx b gy mo me l mf mg">encoded_df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/1f03fa1c76bca195be5f57513c9e5cd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rOp6JbmIVMelvnQ5xaH6_g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="b5e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在有一个包含6个特征的数据框架。当处理具有大量不同值的类别时，这种差异会更加明显。</p><p id="2360" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设一个特性有20个不同的值，95%的值属于4个不同的值。剩下的5%属于16个不同值的组合。在这种情况下，有效的策略是将这16个值分组到一个组中。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><p id="5e8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mq">你可以成为</em> <a class="ae ky" href="https://sonery.medium.com/membership" rel="noopener"> <em class="mq">媒介会员</em> </a> <em class="mq">解锁我的全部写作权限，外加其余媒介。如果你已经是了，别忘了订阅</em><a class="ae ky" href="https://sonery.medium.com/subscribe" rel="noopener"><em class="mq"/></a><em class="mq">如果你想在我发表新文章时收到电子邮件。</em></p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><p id="28ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。如果您有任何反馈，请告诉我。</p></div></div>    
</body>
</html>