<html>
<head>
<title>How to Represent a Directed Graph as an Adjacency Matrix</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将有向图表示为邻接矩阵</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-represent-a-directed-graph-as-an-adjacency-matrix-d4e8135c2fe4#2022-02-16">https://towardsdatascience.com/how-to-represent-a-directed-graph-as-an-adjacency-matrix-d4e8135c2fe4#2022-02-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8199" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">R 中的示例</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/592e71c1824da33ea9f1ed5d698dff81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WtNeACwIRxJeCBAg1tEBVQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由艾丽西娅鲍威尔，Pixistock。</p></figure><p id="8f62" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">图表是以直观的方式展示高维数据的绝佳方式。但是当涉及到用矩阵来表示图形时，可能就不那么直观了。在前面的中，我们看到了如何将一个<em class="ls">无向图表示为一个邻接矩阵。在本教程中，我们将着眼于把<em class="ls">有向图</em>表示为邻接矩阵。</em></p><p id="efee" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">与无向图不同，有向图具有方向性。这通常由从一个节点到另一个节点的箭头表示，表示关系的方向。Twitter 和 Instagram 是有向图的极好例子，因为你可以跟踪一个人，而他们不会跟踪你。现在，让我们开始看看<em class="ls">如何用邻接矩阵来表示有向图。对于本教程，我们将使用<strong class="kx ir"> visNetwork </strong>包，我们将从查看一个没有回路或自边的有向图开始。</em></p><h1 id="3f16" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">示例 1:没有回路的小型有向图</h1><p id="45e6" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">首先，我们将为<strong class="kx ir"> visNetwork </strong>创建一个<em class="ls">节点</em>数据帧来初始化我们的网络节点。我们的网络将由 6 个节点组成，标记为 1 到 6。然后，我们将创建一个<em class="ls"> edges </em>数据框来添加节点之间的关系。为了确保网络是定向的，<em class="ls">边</em>数据帧将有一个<em class="ls">箭头</em>列表示关系的方向。在本例中，所有关系都将从<em class="ls">的</em>列流向<em class="ls">的</em>列。最后，我们将使用<strong class="kx ir"> visNetwork() </strong>绘制我们的网络。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="6fbd" class="mv lu iq mr b gy mw mx l my mz">library(visNetwork) </span><span id="96c8" class="mv lu iq mr b gy na mx l my mz"># Create nodes dataframe for visNetwork. <br/>nodes &lt;- data.frame (id = 1:6, label = 1:6, <br/>                     color = rep('#8BB1AB', 6)) </span><span id="d0f2" class="mv lu iq mr b gy na mx l my mz"># Create edges dataframe for visNetwork. <br/>edges &lt;- data.frame(from = c(1, 2, 3, 3, 4, 5), <br/>                    to = c(2, 3, 4, 5, 5, 6), arrows = 'to') </span><span id="d74b" class="mv lu iq mr b gy na mx l my mz"># Plot network using visNetwork. <br/>visNetwork(nodes, edges) %&gt;% visOptions(highlightNearest = TRUE, <br/>           nodesIdSelection = TRUE)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/c7cb78327ebcb197ca0824f0eca596a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Dt38Ph5tHL-ujzTO.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图。</p></figure><p id="3d34" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">类似于我们对无向图所做的，我们让邻接矩阵的行和列代表节点或顶点。这将产生一个正方形矩阵。然而，与无向图不同的是，1 表示从列 j <em class="ls">到</em>行 I 的箭头。注意:你可以反过来看，箭头从列 I 到行 j。确保你知道使用的是哪个版本。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/2c867509e09bbdada4f81625209f1e83.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/0*WlqOM0M_RGUpaw46"/></div></figure><p id="b7b9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于上图，邻接矩阵如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/d6bb17a89cac5355b4f03c11b0e74028.png" data-original-src="https://miro.medium.com/v2/resize:fit:338/0*YMChIUN44Y15uXFn"/></div></figure><p id="c0d6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于从节点 1 到节点 2 有一条边，我们在中看到 1</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/36153fb2243ec280a4ec544d9420186d.png" data-original-src="https://miro.medium.com/v2/resize:fit:46/0*m_ZI6JDEMhIPUY9P"/></div></figure><p id="e7ec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">(第 2 行，第 1 列)。这种方向性经常导致不对称矩阵。此外，我们可以看到对角线完全由零组成，因为从任何节点到其自身都没有边。现在，让我们看一个例子，我们有循环和多边。</p><h1 id="af1e" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">示例 2:带有回路和多边的小型有向图</h1><p id="7ca3" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">在本例中，我们将保留上面的<em class="ls">节点</em>数据框，但指定一个新的边数据框。因为我们想要循环，我们将有一个从 2 到 3 的关系<em class="ls">和从 3 到 2 的关系</em>，给我们一个循环。我们将创建的第二种循环是自我边缘，其中关系循环回到自身。我们将通过使关系从 1 <em class="ls">到</em>1<em class="ls">来建立与节点 1 的自边。最后，我们将把所有新的关系存储在一个名为<em class="ls"> edgesMessy </em>的数据帧中。</em></p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="1b4d" class="mv lu iq mr b gy mw mx l my mz"># Create new edges dataframe for visNetwork. <br/>edgesMessy &lt;- data.frame(from = c(1, 2, 3, 3, 4, 5, 1, 3, 5, 5), <br/>                         to = c(2, 3, 4, 5, 5, 6, 1, 2, 6, 6),<br/>                         arrows = 'to') </span><span id="1bfc" class="mv lu iq mr b gy na mx l my mz"># Plot network using visNetwork. <br/>visNetwork(nodes, edgesMessy) %&gt;% <br/>      visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/dc3c08eeeae96ef7dd025d19b04f4554.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wNcpHS0us0lNJ1VK.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图。</p></figure><p id="b128" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里，邻接矩阵如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/b19224a45a33dbce08075067729a6afe.png" data-original-src="https://miro.medium.com/v2/resize:fit:338/0*I2zK56WMhHSTePYB"/></div></figure><p id="91de" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，循环表示为 1。对于有向图来说，每一个有向关系都是计数的，并且回路只有一个有向关系。(如果节点 1 有两个环路，条目将是 2。)我们还可以看到，节点 5 和 6 之间有三条边。因此，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/dc84d93662b0b774b07fa4350462fcbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:48/0*g3cZBgYETRKJhk9g"/></div></figure><p id="16c7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在用 3 表示。</p><p id="69b5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">概括一下:</p><ul class=""><li id="9a05" class="nh ni iq kx b ky kz lb lc le nj li nk lm nl lq nm nn no np bi translated">邻接矩阵总是正方形的</li><li id="4363" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nm nn no np bi translated">有向图的邻接矩阵并不总是对称的</li><li id="e9b5" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nm nn no np bi translated">没有回路的有向图在对角线上会有零点</li><li id="38c7" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nm nn no np bi translated">无向图中的每个循环都用 1 表示</li><li id="d9ed" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nm nn no np bi translated">邻接矩阵可以解释多条边</li></ul></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><p id="dd3f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ls">原载于 2022 年 2 月 16 日 https://thatdarndata.com</em><a class="ae lr" href="https://thatdarndata.com/how-to-represent-a-directed-graph-as-an-adjacency-matrix/" rel="noopener ugc nofollow" target="_blank"><em class="ls"/></a><em class="ls">。</em></p></div></div>    
</body>
</html>