<html>
<head>
<title>How to Fine-Tune YOLOv5 on Multiple GPUs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在多个GPU上微调YOLOv5</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-finetune-yolov5-in-a-multi-gpu-environment-ada1935193d3#2022-02-15">https://towardsdatascience.com/how-to-finetune-yolov5-in-a-multi-gpu-environment-ada1935193d3#2022-02-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/ac81155952eab92aa621777b4812d916.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8WUGLZOUF_vfX48QGcgVNw.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">插图照片由<a class="ae jd" href="https://www.pexels.com/@babydov?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">伊万·巴比多夫</a>从<a class="ae jd" href="https://www.pexels.com/photo/magnifying-glass-placed-on-yellow-background-7788351/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">派克斯</a>拍摄</p></figure><div class=""/><div class=""><h2 id="dab5" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">众所周知，深度学习模型往往对适当的超参数选择敏感。同时，当您搜索最佳配置时，您希望使用最大的资源…</h2></div><p id="b45c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对象检测是任何ML/AI尚未完全掌握的高级计算机视觉(CV)任务之一。简而言之，该任务由图像中给定对象的定位和识别/分类组成。</p><div class="ip iq gp gr ir lr"><a href="https://machinelearningmastery.com/object-recognition-with-deep-learning/" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd jh gy z fp lw fr fs lx fu fw jf bi translated">对具有深度学习的物体识别的温和介绍-机器学习掌握</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">对于初学者来说，区分不同的相关计算机视觉任务可能具有挑战性。例如，图像…</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">machinelearningmastery.com</p></div></div><div class="ma l"><div class="mb l mc md me ma mf ix lr"/></div></div></a></div><p id="e913" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">目标检测仍然是研究领域的一个热门话题。此外，在许多实际应用的生产中，例如场景中的人物检测或商店货架上物品的识别，使用这种人工智能模型的需求相对较高。这自然会产生一个更大的模型架构集合，甚至更多的实现作为开源项目公开共享。其中之一是<a class="ae jd" href="https://github.com/ultralytics/yolov5" rel="noopener ugc nofollow" target="_blank"> YOLO v5 </a>，它声称在性能(准确度/精确度)和推理时间之间有最好的比例。</p><p id="5871" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">除了训练和推理，该项目还提供了基于进化算法调整的运行<a class="ae jd" href="https://docs.ultralytics.com/tutorials/hyperparameter-evolution/" rel="noopener ugc nofollow" target="_blank">超参数搜索。简而言之，该算法分代进行，因此它运行一些短期训练，并根据它们的性能选择最佳的。然后这些最好的混合一些微小的随机变化，再次训练。</a></p><h1 id="b41f" class="mg mh jg bd mi mj mk ml mm mn mo mp mq km mr kn ms kp mt kq mu ks mv kt mw mx bi translated">简单的屏幕微调</h1><p id="608c" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">搜索超参数的最简单方法是使用启用的evolution <code class="fe nd ne nf ng b">--evolve &lt;number&gt;</code>参数运行训练。但这最多只使用了一个GPU，那么我们拥有的其余部分呢？</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="5159" class="np mh jg ng b gy nq nr l ns nt">python train.py \<br/>    --weights yolov5s6.pt \<br/>    --data /home/user/Data/gbr-yolov5-train-0.1/dataset.yaml \<br/>    --hyp data/hyps/hyp.finetune.yaml \<br/>    --epochs 10 \<br/>    --batch-size 4 \<br/>    --imgsz 3000 \<br/>    --device 0 \<br/>    --workers 8 \<br/>    --single-cls \<br/>    --optimizer AdamW \<br/>    --evolve 60</span></pre><p id="d0b5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最终，我们可以进行多种培训，但是我们如何推动他们进行合作呢？幸运的是，他们可以共享一个包含转储训练结果的文件，并从中抽取新的群体。由于下一代的随机性，这看起来像是在探索一个更大的群体，正如<a class="ae jd" href="https://github.com/ultralytics/yolov5/issues/918#issuecomment-1034818168" rel="noopener ugc nofollow" target="_blank">作者所说</a>。</p><div class="ip iq gp gr ir lr"><a href="https://github.com/ultralytics/yolov5/issues/918" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd jh gy z fp lw fr fs lx fu fw jf bi translated">COCO微调进化问题#918 ultralytics/yolov5</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">🚀功能可可微调进化将试图演变hyps更好地调整到微调可可从官方…</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">github.com</p></div></div><div class="ma l"><div class="nu l mc md me ma mf ix lr"/></div></div></a></div><figure class="nh ni nj nk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nv"><img src="../Images/810815469ec4efa1119fb90c5126a061.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2kWvUWDMYZ8cWetm.jpg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">插图来自<a class="ae jd" href="https://colab.research.google.com/github/ultralytics/yolov5/blob/master/tutorial.ipynb" rel="noopener ugc nofollow" target="_blank"> Ultralytics教程</a>经<a class="ae jd" href="https://github.com/glenn-jocher" rel="noopener ugc nofollow" target="_blank"> <strong class="bd nw">许可格伦·约彻</strong> </a> <strong class="bd nw">。</strong></p></figure><h1 id="f21c" class="mg mh jg bd mi mj mk ml mm mn mo mp mq km mr kn ms kp mt kq mu ks mv kt mw mx bi translated">有哪些选择？</h1><p id="3003" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">使用不同的GPU运行多个训练过程可以通过在<code class="fe nd ne nf ng b">--device &lt;gpu-index&gt;</code>参数中指定来设置。但是如何维护众多的进程，并且在你注销或意外断开互联网连接时不丢失它们。</p><h2 id="2af4" class="np mh jg bd mi nx ny dn mm nz oa dp mq le ob oc ms li od oe mu lm of og mw oh bi translated"><a class="ae jd" href="https://linuxhint.com/how_to_use_nohup_linux/" rel="noopener ugc nofollow" target="_blank"> nohup </a></h2><p id="df83" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">这是保持流程运行的第一个也是最简单的方法。</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="d8d3" class="np mh jg ng b gy nq nr l ns nt">nohup python train.py ... &gt; training.log</span></pre><p id="5870" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不幸的是，<a class="ae jd" href="https://serverfault.com/questions/367634/reattaching-a-process-started-with-nohup/367642#367642" rel="noopener ugc nofollow" target="_blank">没有简单的方法将</a>连接回<a class="ae jd" href="https://askubuntu.com/questions/57477/bring-nohup-job-to-foreground/57480#57480" rel="noopener ugc nofollow" target="_blank">曾经调度过的进程</a>，所以它主要与重定向流到一个文件结合使用。然后，您可以不断刷新文件，但它仍然不总是能很好地播放进度条，因为进度条可能会延伸到许多行。</p><h2 id="c0ec" class="np mh jg bd mi nx ny dn mm nz oa dp mq le ob oc ms li od oe mu lm of og mw oh bi translated"><a class="ae jd" href="https://linuxize.com/post/how-to-use-linux-screen/" rel="noopener ugc nofollow" target="_blank">屏幕</a></h2><p id="b56d" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">这个Unix应用程序在许多情况下都很方便，在这里，它可以在屏幕上旋转每个进程，以后您可以在所有进程之间进行遍历。在每个屏幕中，您都可以完全控制或终止特定的进程。</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="2083" class="np mh jg ng b gy nq nr l ns nt">screen -S training<br/>python train.py ...</span></pre><h2 id="b98e" class="np mh jg bd mi nx ny dn mm nz oa dp mq le ob oc ms li od oe mu lm of og mw oh bi translated"><a class="ae jd" href="https://docs.docker.com/engine/" rel="noopener ugc nofollow" target="_blank">码头工人</a></h2><p id="1819" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">另一种方法是使用具有共享卷的docker容器。其优势在于，您可以在固定的环境中准备客户docker映像，最终可以在任何地方运行，甚至在另一个服务器/集群上运行…</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="d320" class="np mh jg ng b gy nq nr l ns nt">docker build -t yolov5 .<br/>docker run --detach --ipc=host --gpus all -v ~:$(pwd) yolov5 \<br/>  python train.py ...<br/>docker ps</span></pre><p id="626c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的命令首先从项目文件夹构建一个docker映像。稍后，它旋转一个容器，并立即分离它，对GPU完全可见，并将容器中的用户home映射到您的本地项目文件夹。最后一个命令是列出所有正在运行的容器。</p><h1 id="4173" class="mg mh jg bd mi mj mk ml mm mn mo mp mq km mr kn ms kp mt kq mu ks mv kt mw mx bi translated">旋转多个协作码头</h1><p id="f81d" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">您需要单独创建每个屏幕，并在屏幕中启动特定的培训过程。这些额外的工作很容易因为选择了错误的或者已经在使用的设备而被破坏。</p><p id="e768" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">docker的一个优点是，我们可以快速编写一个循环，在旋转任何docker容器时启动与GPU一样多的容器。唯一的限制可能是足够的RAM，这也可以在docker端用<code class="fe nd ne nf ng b">--memory 20g</code>参数来限制。要正确利用实验的共享数据，需要修复<code class="fe nd ne nf ng b">project/name</code>，设置<code class="fe nd ne nf ng b">exist-ok</code>和<code class="fe nd ne nf ng b">resume</code>参数。</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="a6b3" class="np mh jg ng b gy nq nr l ns nt">for i in 1 2 3 4 5; do<br/>  sudo docker run -d --ipc=host --gpus all \<br/>    -v ~:/home/jirka \<br/>    -v ~/gbr-yolov5/runs:/usr/src/app/runs \<br/>    yolov5 \<br/>  python /usr/src/app/train.py \<br/>    --weights yolov5s6.pt \<br/>    --data /home/jirka/gbr-yolov5-train-0.1-only_annotations/dataset.yaml \<br/>    --hyp /usr/src/app/data/hyps/hyp.finetune.yaml \<br/>    --epochs 10 \<br/>    --batch-size 4 \<br/>    --imgsz 3000 \<br/>    --workers 8 \<br/>    --device $i \<br/>    --project gbr \<br/>    --name search \<br/>    --exist-ok \<br/>    --resume \<br/>    --evolve 60<br/>done</span></pre><p id="f231" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">稍后，为了重新连接到正在运行的容器，例如，为了监视进程，您可以通过将<a class="ae jd" href="https://www.baeldung.com/ops/docker-attach-detach-container#3-background-mode" rel="noopener ugc nofollow" target="_blank">输入容器:</a></p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="6927" class="np mh jg ng b gy nq nr l ns nt">sudo docker ps<br/>sudo docker attach --sig-proxy=false &lt;container-id&gt;</span></pre><p id="e1c9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后使用CTRL+c分离回您的用户终端。</p><p id="3e07" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后一种情况是，您不想让培训结束，或者您需要终止您调用的所有正在运行的容器:</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="a7c8" class="np mh jg ng b gy nq nr l ns nt">sudo docker kill $(sudo docker ps -q)</span></pre><p id="8758" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">敬请关注，关注我了解更多！</strong></p><div class="ip iq gp gr ir lr"><a href="https://www.kaggle.com/jirkaborovec/starfish-detection-flash-efficientdet" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd jh gy z fp lw fr fs lx fu fw jf bi translated">🐡海星探测:Flash⚡EfficientDet</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">使用Kaggle笔记本探索和运行机器学习代码|使用来自TensorFlow的数据-帮助保护伟大的…</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">www.kaggle.com</p></div></div><div class="ma l"><div class="oi l mc md me ma mf ix lr"/></div></div></a></div></div><div class="ab cl oj ok hu ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ij ik il im in"><h1 id="f242" class="mg mh jg bd mi mj oq ml mm mn or mp mq km os kn ms kp ot kq mu ks ou kt mw mx bi translated">关于作者</h1><p id="2ee8" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated"><a class="ae jd" href="https://medium.com/@jborovec" rel="noopener"> <strong class="kx jh"> Jirka Borovec </strong> </a>拥有CTU的计算机视觉博士学位。他已经在几家IT创业公司和公司从事机器学习和数据科学工作几年了。他喜欢探索有趣的世界问题，用最先进的技术解决它们，并开发开源项目。</p></div></div>    
</body>
</html>