<html>
<head>
<title>How to Define Nonpublic Methods in a Python Class</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python类中定义非公共方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-define-nonpublic-methods-in-a-python-class-f477a1ddf3c0#2022-07-28">https://towardsdatascience.com/how-to-define-nonpublic-methods-in-a-python-class-f477a1ddf3c0#2022-07-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="57af" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python作为OOP的惯用方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5dbf3238fd98b254b34b44ee4691ce12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iC9gCX7-OXo3uSpc"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">妮娜·梅尔卡多在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="6910" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从本质上讲，Python是一种面向对象的编程(OOP)语言，它围绕对象构建自己的特性。字符串是对象，自定义类的实例是对象，类、模块甚至包也是对象。OOP编码中的一个长期原则是<strong class="lb iu">封装</strong>——在这种设计模式中，您公开用户需要的功能，同时隐藏用户不需要访问的实现细节。</p><p id="5bae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于任何项目，我们都定义了一系列定制类作为建模各种数据的基础。因此，一个好的项目意味着你定义了结构良好的定制类。当我们处理这些类时，我们应该应用封装技术。虽然我不认为我们应该把封装当作教条，但是您可以考虑两个特殊的封装特性来增加您项目的可维护性— <strong class="lb iu"> protected </strong> <strong class="lb iu">和</strong> <strong class="lb iu"> private </strong>方法，它们旨在供内部使用。本文将向您展示如何做到这一点。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="431e" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">介绍</h2><p id="08ad" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">你们中的一些人可能知道，在一些OOP语言中，我们为封装保留了关键字，例如protected、private和public，它们定义了如何在类外访问属性(或方法)。然而，Python没有这些关键字，这是因为<strong class="lb iu">严格来说，Python类中定义的一切都是公共的。也就是说，如果你愿意，你可以访问一个类中的任何东西。</strong></p><p id="b30a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管如此，Python中仍然有一些封装约定。为了便于讨论，我们将使用通用OOP领域的术语。在访问级别控制方面，属性和方法没有区别。所以，我们只是用方法来演示相关的技术。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="5f7e" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">定义受保护的方法</h2><p id="22a9" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们可以在Python中定义受保护的属性。惯例是在方法名前使用下划线。让我们考虑下面的例子:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="2cdd" class="mc md it nb b gy nf ng l nh ni">class User:<br/>    def __init__(self,username) -&gt; None:<br/>        self.username = username</span><span id="7153" class="mc md it nb b gy nj ng l nh ni">    def login(self):<br/>        print(f"{self.username} just logged in.")</span><span id="3d5a" class="mc md it nb b gy nj ng l nh ni">    def signup(self):<br/>        self._check_account_existence()<br/>        print(f"{self.username} just signed up an account.")</span><span id="52b9" class="mc md it nb b gy nj ng l nh ni">    def _check_account_existence(self):<br/>        print(f"Checking if {self.username} has signed up already.")</span></pre><p id="44da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个<code class="fe nk nl nm nb b">User</code>类中，<code class="fe nk nl nm nb b">signup</code>方法是公共的，而<code class="fe nk nl nm nb b">_check_account_existence</code>方法是受保护的。因为这个方法不是公共的，所以当我们使用<code class="fe nk nl nm nb b">User</code>类的实例时，它不包含在自动完成提示中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/01d623af40f12f5d76008a3d48b970e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*-FS1n93OVyRlLkmcX40tVw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自动完成提示不包括受保护的方法(作者截图)</p></figure><p id="4541" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，该列表只包括<code class="fe nk nl nm nb b">signup</code>，而不包括<code class="fe nk nl nm nb b">_check_account_existence</code>方法。值得注意的是，如果您确实调用了这个受保护的方法，您仍然可以这样做:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="4b23" class="mc md it nb b gy nf ng l nh ni">&gt;&gt;&gt; user = User("cowboy")<br/>&gt;&gt;&gt; user._check_account_existence()<br/>Checking if cowboy has signed up already.</span></pre><p id="3486" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原因是，正如我前面所说的，Python对类的方法没有严格的访问控制，它只是一个约定，在方法名前面加上前缀以表明(不是<strong class="lb iu"> enforce </strong>)它是一个受保护的方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="65e5" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">定义私有方法</h2><p id="64b4" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">另一种封装技术是关于定义私有方法的。您可以使用两个下划线作为方法名的前缀，而不是使用一个下划线，以表明它是一个私有方法。观察下面的例子:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="6822" class="mc md it nb b gy nf ng l nh ni">class User:<br/>    def __init__(self,username) -&gt; None:<br/>        self.username = username<br/><br/>    def signup(self):<br/>        self._check_account_existence()<br/>        print(f"{self.username} just signed up an account.")<br/><br/>    def _check_account_existence(self):<br/>        print(f"Checking if {self.username} has signed up already.")<br/><br/>    def login(self):<br/>        print(f"{self.username} just logged in.")<br/>        self.__pull_data_after_login()<br/><br/>    def __pull_data_after_login(self):<br/>        print(f"Pull additional data for the user: {self.username}")</span></pre><p id="7add" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nk nl nm nb b">User</code>类中，<code class="fe nk nl nm nb b">__pull_data_after_login</code>是一个私有方法。同样，这个私有方法也不会进入自动完成提示列表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/6cfbdb52b9ea699f01b79a518d086c57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YQSiwALjglF-v72NC0Firg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自动完成提示不包括私有方法(作者截图)</p></figure><p id="2e05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我之前提到过，如果我们愿意，我们可以访问类外的非公共方法，并且我们看到我们可以使用受保护的方法。它也适用于私有方法吗？</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="4f05" class="mc md it nb b gy nf ng l nh ni">&gt;&gt;&gt; user = User("cowboy")<br/>&gt;&gt;&gt; user.__pull_data_after_login()<br/># AttributeError: 'User' object has no attribute '__pull_data_after_login'</span></pre><p id="1924" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">错误是否意味着我们不能访问类外的私有方法？不完全是。访问类外的私有方法需要了解名称篡改的概念，如果从外部访问，私有方法会有一个被篡改的名称。具体来说，它有这个规律:<code class="fe nk nl nm nb b">__private_method</code>-&gt;-T5。因此，我们可以这样访问<code class="fe nk nl nm nb b">__pull_data_after_login</code>:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="26ba" class="mc md it nb b gy nf ng l nh ni">&gt;&gt;&gt; user = User("cowboy")<br/>&gt;&gt;&gt; user._User__pull_data_after_login()<br/>Pull additional data for the user: cowboy</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="8f42" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated"><strong class="ak">使用非公开方法的好处</strong></h2><p id="7125" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">从这些截图中，您可以看到，通过隐藏非公共(受保护的和私有的)方法，您正在帮助代码的用户提高编码效率，因为他们不需要担心选择一个他们无论如何都不应该使用的非公共方法。</p><p id="6105" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，这些方法在类内部仍然可用。下图显示了自动完成提示理解这些非公共方法的可访问性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/feef4df9f71cbf72b1bf2ccce96a3f79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vMOU4Ass3Rz6w6HKe1bz6A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对非公共方法的内部访问(作者截图)</p></figure><p id="6013" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">封装只适用于类外的代码。当您在类内部工作时，如上图所示，我们仍然可以从自动完成提示列表中选择非公共方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="dcb6" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">受保护方法和私有方法之间的其他区别</h2><p id="9f57" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当我们在它们各自的部分中介绍受保护的和私有的方法时，我们隐含地展示了受保护的和私有的方法之间的两个区别。</p><ul class=""><li id="7def" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">受保护的方法使用一个下划线作为前缀，而私有方法使用两个下划线作为前缀。</li><li id="459f" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">我们可以通过使用方法名直接在类外调用受保护的方法。然而，调用私有方法需要名字混淆。</li></ul><p id="40d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了protected和private方法之间的这两个明显区别之外，这两种方法之间的主要区别在于它们在子类中的可访问性。也就是说，<strong class="lb iu"> protected方法在子类内是可访问的，而private方法在子类</strong>内是不可访问的(虽然原因也是因为名字mangling)。考虑下面的例子。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="12da" class="mc md it nb b gy nf ng l nh ni">class Administrator(User):<br/>    def admin_signup(self):<br/>        super()._check_account_existence()<br/><br/>    def admin_login(self):<br/>        super().__pull_data_after_login()<br/></span><span id="c02a" class="mc md it nb b gy nj ng l nh ni">&gt;&gt;&gt; admin = Administrator("rodeo")</span><span id="ade2" class="mc md it nb b gy nj ng l nh ni">&gt;&gt;&gt; admin.admin_signup()<br/>Checking if rodeo has signed up already.</span><span id="2054" class="mc md it nb b gy nj ng l nh ni">&gt;&gt;&gt; admin.admin_login()<br/><strong class="nb iu"># AttributeError</strong>: 'super' object has no attribute '_Administrator__pull_data_after_login'</span></pre><p id="2f8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，在<code class="fe nk nl nm nb b">Administrator</code>类中，我们使用超类的protected和private方法来定义<code class="fe nk nl nm nb b">admin_signup</code>和<code class="fe nk nl nm nb b">admin_login</code>。当我们使用这两种方法时，只有<code class="fe nk nl nm nb b">admin_signup</code>有效，而<code class="fe nk nl nm nb b">admin_login</code>无效。原因是私有方法使用当前类的名称自动触发名称篡改。尽管我们的目的是使用超类的私有方法，但它们在子类中并不容易获得。</p><p id="4d3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果你想定义非公共方法，并且不想让它们在子类中被访问，你应该使用私有方法。否则，您应该使用受保护的方法，使它们可以在子类中访问。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="273d" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">结论</h2><p id="7233" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在本文中，我们回顾了在Python类中定义受保护方法和私有方法的技术。这些技术属于一个重要的OOP概念——封装。虽然Python不使用protected或private作为关键字，但是您应该遵守我们使用下划线作为这些非公共方法前缀的惯例。</p><p id="350c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解更多关于Python的知识，可以考虑注册我的时事通讯邮件。如果你想系统地提高你的Python技能，请阅读我的新书<a class="ae ky" href="https://www.manning.com/books/python-how-to" rel="noopener ugc nofollow" target="_blank">Python How-To</a>Manning。</p></div></div>    
</body>
</html>