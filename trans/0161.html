<html>
<head>
<title>Hands-On Unsupervised Outlier Detection Using Machine Learning, with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用机器学习和Python进行实际操作的无监督离群点检测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/hands-on-unsupervised-outlier-detection-using-machine-learning-with-python-ec599fe5a6b5#2022-02-07">https://towardsdatascience.com/hands-on-unsupervised-outlier-detection-using-machine-learning-with-python-ec599fe5a6b5#2022-02-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/6defefdae91b83e6768dbd5d54f56e76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CwSPNdUUlqanplBTpSPu3w.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">威尔·梅尔斯在<a class="ae jd" href="https://unsplash.com/s/photos/outlier?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><div class=""/><div class=""><h2 id="f723" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">以下是如何使用简单的机器学习算法来检测未标记数据集的异常值</h2></div><p id="17eb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">数据科学中最丰富和最强大的技术之一是<strong class="kx jh">异常检测</strong>。</p><p id="5c5b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这项技术如此吸引人的地方在于“离群值”的定义非常普遍。换句话说，我们可以将数据集的任意集合定义为“离群集合”，并尝试通过使用我们拥有的其他特征来识别它。</p><p id="ad8e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当然，检测异常值的一个非常简单的方法是绘制分布图，并提取远离分布中值的值。这种方法的问题是，它意味着您的数据具有类似于高斯分布的分布，但这并不总是正确的。</p><p id="36ed" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一种方法是使用分类方法，并对您的数据应用二元分类算法(异常值/非异常值)。尽管如此，这种方法需要<strong class="kx jh">标记的数据。</strong></p><p id="76c9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那么我们能用什么呢？我们可以用<strong class="kx jh">高斯过程回归</strong>。该模型为您提供了一种回归技术，可输出一个<strong class="kx jh">均值</strong>和一些与某个概率不确定性相关的预测性<strong class="kx jh">边界</strong>。</p><p id="c360" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们开始吧:</p><h1 id="6458" class="lr ls jg bd lt lu lv lw lx ly lz ma mb km mc kn md kp me kq mf ks mg kt mh mi bi translated">1.高斯过程回归</h1><p id="1278" class="pw-post-body-paragraph kv kw jg kx b ky mj kh la lb mk kk ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">正如我所说，高斯过程回归的假设是，你的数据只不过是一个高斯过程的随机实现，其中这个高斯过程的均值和方差是某个<strong class="kx jh">均值函数</strong>，方差是某个<strong class="kx jh">方差函数。</strong></p><figure class="mp mq mr ms gt is gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/c88542950a5c167e6acc301237085d37.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*1nWtqmY7rTnY7Nuj3iW6MA.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">使用<a class="ae jd" href="https://latex2png.com/" rel="noopener ugc nofollow" target="_blank">这个</a>制作的图像</p></figure><p id="955f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个均值和方差函数都依赖于所使用的<strong class="kx jh">内核</strong>函数。</p><p id="bd92" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用最多的只是径向基函数(RBF)核:</p><figure class="mp mq mr ms gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mt"><img src="../Images/6606ba4b3473ed785fca3780a6a71bb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kMrueP39pLdZQC1hlwP6rg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">我制作的图像</p></figure><p id="89f4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<strong class="kx jh"> l </strong>值给出协方差<br/>的地方，我们添加了一个<strong class="kx jh">白噪声内核</strong>，它考虑到了您的测量也可能有噪声的事实。</p><h1 id="e818" class="lr ls jg bd lt lu lv lw lx ly lz ma mb km mc kn md kp me kq mf ks mg kt mh mi bi translated">2.代码</h1><h2 id="6925" class="mu ls jg bd lt mv mw dn lx mx my dp mb le mz na md li nb nc mf lm nd ne mh nf bi translated">2.1图书馆</h2><p id="65ac" class="pw-post-body-paragraph kv kw jg kx b ky mj kh la lb mk kk ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">这是一篇实践文章，所以让我们开始写代码吧。这就是你需要的:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="ea52" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">基本就是GPR部分有<strong class="kx jh"> Sklearn，matplotlib，numpy和pandas </strong></p><h2 id="7a86" class="mu ls jg bd lt mv mw dn lx mx my dp mb le mz na md li nb nc mf lm nd ne mh nf bi translated">2.2数据集</h2><p id="0149" class="pw-post-body-paragraph kv kw jg kx b ky mj kh la lb mk kk ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">我使用的数据集是一个时间序列，我在这里找到了<a class="ae jd" href="https://www.kaggle.com/arashnic/learn-time-series-forecasting-from-gold-price" rel="noopener ugc nofollow" target="_blank"><strong class="kx jh"/></a><strong class="kx jh">。<br/> </strong>数据集将主要用于回归任务，但该方法的实际用途来自我们能够预测的边界。</p><p id="8f76" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们来导入一下:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="a669" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">并显示一些行:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="22c6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为我们的目的只是展示该方法的工作原理，所以让我们使用稍微小一些的数字，并将我们自己限制在数据集的80%上:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="bbf8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们想应用GPR方法，我们有“日期时间对象”的事实是令人不安的。让我们把第0天和第0天之间的距离看作我们的时间:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="6b3e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们绘制日期和新的时间轴(X):</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="0c65" class="mu ls jg bd lt mv mw dn lx mx my dp mb le mz na md li nb nc mf lm nd ne mh nf bi translated">2.3模型</h2><p id="1f39" class="pw-post-body-paragraph kv kw jg kx b ky mj kh la lb mk kk ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">让我们使用下面的代码来拟合GPR模型(可能需要一段时间):</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="8198" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们得到<strong class="kx jh">的平均值</strong>和<strong class="kx jh">的标准界限:</strong></p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="57f6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们将它们转换成两个dataframe对象:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="812c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们画出结果:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="ng nh l"/></div></figure><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="c178" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们之前已经表明，原始时间采样是不均匀的，并且它也反映在我们的较小部分数据中。这就是为什么在最低的图中，GPR方法不太能够识别方差并且很可能高估它(<strong class="kx jh"> <em class="ni">说到底，如果你的数据点很少，你怎么能说一个新的是异常值呢？</em> </strong>)</p><h2 id="76fa" class="mu ls jg bd lt mv mw dn lx mx my dp mb le mz na md li nb nc mf lm nd ne mh nf bi translated">2.4异常值检测</h2><p id="8af8" class="pw-post-body-paragraph kv kw jg kx b ky mj kh la lb mk kk ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">我们在前面两个图中设置的阈值相当大(99.7%置信区间)。<strong class="kx jh">由于这个原因，我们可以说，在这个边界之外的一切可能是我们过程的异常(或异常值)</strong>。</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="ng nh l"/></div></figure><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="a7f6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们创建一个新列，说明“值”是否超出了每行的边界。</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="ng nh l"/></div></figure><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="ffa9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们画出如此定义的<strong class="kx jh">异常值</strong>:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="ng nh l"/></div></figure><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="2b6f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有趣的是，我们能够检测出异常值是大于上边界还是小于下边界的异常值。<strong class="kx jh">换句话说，我们能够检测出黄金价格是高于我们的预期还是低于我们的预期</strong>:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="ng nh l"/></div></figure><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="3d33" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">给你:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="6ee9" class="lr ls jg bd lt lu lv lw lx ly lz ma mb km mc kn md kp me kq mf ks mg kt mh mi bi translated">3.结论</h1><p id="512a" class="pw-post-body-paragraph kv kw jg kx b ky mj kh la lb mk kk ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">这个想法看起来简单而天真，但是当定制<strong class="kx jh">内核函数</strong>时，它实际上会变得非常复杂和有趣(假设对我们正在考虑的系统有更精确的理解)。</p><p id="596a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">强有力的想法是，您可以在没有任何标签的情况下分析系统的行为，并通过这样做来检测异常值。</p><p id="fac0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我希望这篇文章是有趣和鼓舞人心的。如果是这样，你想讨论一下，或者你有什么问题，请给我发邮件:<strong class="kx jh"><em class="ni"/></strong>或者在<a class="ae jd" href="https://www.linkedin.com/in/pieropaialunga/" rel="noopener ugc nofollow" target="_blank"><strong class="kx jh">LinkedIn</strong></a><strong class="kx jh">上加我。</strong></p><p id="f9dd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">再见:)</p></div></div>    
</body>
</html>