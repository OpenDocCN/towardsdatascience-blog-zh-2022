<html>
<head>
<title>Kedro as a Data Pipeline in 10 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">10分钟后Kedro成为数据管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/kedro-as-a-data-pipeline-in-10-minutes-21c1a7c6bbb#2022-09-02">https://towardsdatascience.com/kedro-as-a-data-pipeline-in-10-minutes-21c1a7c6bbb#2022-09-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2807" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">开发工作流框架变得简单——用Python示例解释</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9e2acc1966b0b2bc6f87b20f5f2b1ad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8iEOjsrg6nf2ksc-"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">罗曼·达维德科在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d52c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在数据科学项目中，各种编码组件可以被认为是一个数据流——从源到特征工程、建模、评估等的数据流。训练、评估和评分管道使这一流程变得更加复杂，因为每个管道的流程可能有很大的不同。</p><p id="7e33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kedro是一个Python框架，它帮助将代码组织成模块化的数据管道。Kedro允许可复制的和容易的(一行命令！)运行不同的流水线，甚至临时重新运行一小部分流水线。本文将涉及Kedro和Python示例中使用的组件和术语，以及如何设置、配置和运行Kedro管道。</p><p id="c942" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">更新</em> </strong> <em class="lv">:本文是系列文章的一部分。查看其他“10分钟内”话题</em> <a class="ae ky" href="https://medium.com/@kayjanwong/list/in-10-minutes-eeaa9aa67055" rel="noopener"> <em class="lv">此处</em> </a> <em class="lv">！</em></p><h1 id="8beb" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">目录</h1><ul class=""><li id="5c7e" class="mo mp it lb b lc mq lf mr li ms lm mt lq mu lu mv mw mx my bi translated"><a class="ae ky" href="https://medium.com/p/21c1a7c6bbb/#eca7" rel="noopener"> Kedro概述</a></li><li id="e246" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><a class="ae ky" href="https://medium.com/p/21c1a7c6bbb/#09aa" rel="noopener"> Kedro设置</a></li><li id="367a" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><a class="ae ky" href="https://medium.com/p/21c1a7c6bbb/#9d4c" rel="noopener"> Kedro文件夹结构</a></li><li id="965e" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><a class="ae ky" href="https://medium.com/p/21c1a7c6bbb/#2d6e" rel="noopener">与Kedro合作</a></li><li id="ffb9" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><a class="ae ky" href="https://medium.com/p/21c1a7c6bbb/#8189" rel="noopener">将Kedro与编码最佳实践相结合</a></li><li id="602d" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><a class="ae ky" href="https://medium.com/p/21c1a7c6bbb/#1b64" rel="noopener">高级:使用外部数据库</a></li></ul></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="eca7" class="lw lx it bd ly lz nl mb mc md nm mf mg jz nn ka mi kc no kd mk kf np kg mm mn bi translated">Kedro概述</h1><p id="649b" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">Kedro是麦肯锡开发的第一个开源软件工具，最近捐赠给了Linux基金会。它是一个Python框架，用于创建可复制、可维护和模块化的代码。</p><blockquote class="nt"><p id="9324" class="nu nv it bd nw nx ny nz oa ob oc lu dk translated">Kedro将软件工程的最佳实践与数据科学世界结合起来</p></blockquote><p id="9e49" class="pw-post-body-paragraph kz la it lb b lc od ju le lf oe jx lh li of lk ll lm og lo lp lq oh ls lt lu im bi translated">该组织有几个组成部分，即</p><ul class=""><li id="d50c" class="mo mp it lb b lc ld lf lg li oi lm oj lq ok lu mv mw mx my bi translated"><strong class="lb iu">节点</strong>:函数包装器；将函数的输入、函数本身和函数输出包装在一起(定义<strong class="lb iu"> <em class="lv">应该运行什么</em> </strong>代码)</li><li id="b10a" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><strong class="lb iu">管道</strong>:将节点连接在一起；解析依赖关系并确定函数的执行顺序(定义代码应该运行的<strong class="lb iu"><em class="lv"/></strong>顺序)</li><li id="3a5e" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><strong class="lb iu"> DataCatalog </strong>:数据的包装器；将节点中指定的输入和输出名称链接到文件路径</li><li id="e898" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><strong class="lb iu"> Runner </strong>:决定管道如何运行的对象，例如顺序或并行(定义<strong class="lb iu"> <em class="lv">代码应该如何运行</em> </strong></li></ul></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="09aa" class="lw lx it bd ly lz nl mb mc md nm mf mg jz nn ka mi kc no kd mk kf np kg mm mn bi translated">Kedro设置</h1><p id="f954" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">Kedro可以作为Python包安装，并用以下命令进行实例化，</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="37ce" class="oq lx it om b gy or os l ot ou">pip install kedro<br/>kedro new</span></pre><p id="d6e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，此设置只需运行一次。该程序将提示您输入项目名称，并在您的存储库中创建一个文件夹结构。</p><p id="f0e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要从现有的Kedro项目实例化，我们可以使用命令<code class="fe ov ow ox om b">kedro new --starter=https://github.com/your-repo.git</code>来代替。</p><p id="3dd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们编写一些管道代码！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/87592dde46de4fee2ab2c490643a1d33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*agfMsXxEFAEnrzQ_"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Jesse Echevarria 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="9d4c" class="lw lx it bd ly lz nl mb mc md nm mf mg jz nn ka mi kc no kd mk kf np kg mm mn bi translated">Kedro文件夹结构</h1><p id="900d" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">实例化Kedro后，几个文件夹和文件被添加到项目中。该项目应该具有以下文件夹结构，</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="3906" class="oq lx it om b gy or os l ot ou">project-name<br/>├── conf                 (configuration files)<br/>│   ├── base<br/>│   └── local<br/>├── data                 (project data)<br/>│   ├── 01_raw<br/>│   ├── 02_intermediate<br/>│   ├── 03_primary<br/>│   ├── 04_feature<br/>│   ├── 05_model_input<br/>│   ├── 06_models<br/>│   ├── 07_model_output<br/>│   └── 08_reporting<br/>├── docs                 (project documentation)<br/>│   └── source<br/>├── logs                 (project output logs)<br/>├── notebooks            (project jupyter notebooks)<br/>└── src                  (project source code)<br/>    ├── project_name<br/>    │   └── pipelines<br/>    └── tests<br/>        └── pipelines</span></pre><h2 id="1f81" class="oq lx it bd ly oz pa dn mc pb pc dp mg li pd pe mi lm pf pg mk lq ph pi mm pj bi translated">会议</h2><p id="1f5b" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated"><code class="fe ov ow ox om b">conf</code>文件夹用于存储配置文件。<code class="fe ov ow ox om b">base</code>子文件夹存储共享的项目相关配置，而<code class="fe ov ow ox om b">local</code>子文件夹存储用户相关或机密的配置。在<code class="fe ov ow ox om b">local</code>子文件夹中的配置不应该被提交到代码库中，这个设置在<code class="fe ov ow ox om b">.gitignore</code>文件中处理。</p><p id="b8d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe ov ow ox om b">base</code>子文件夹中为<strong class="lb iu"> <em class="lv">数据目录</em> </strong>、日志记录和参数创建示例配置文件，而<code class="fe ov ow ox om b">local</code>子文件夹中的示例配置文件用于存储凭证。</p><h2 id="a985" class="oq lx it bd ly oz pa dn mc pb pc dp mg li pd pe mi lm pf pg mk lq ph pi mm pj bi translated">数据</h2><p id="023e" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated"><code class="fe ov ow ox om b">data</code>文件夹存储在不同数据管道阶段创建的输入、中间和输出数据。与本地配置类似，<code class="fe ov ow ox om b">data</code>文件夹中的文件不应该提交给代码库。</p><p id="98f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于Kedro是作为数据科学框架创建的，默认的文件夹结构对应于数据科学项目的各个阶段，如果需要，您可以进一步定制。</p><h2 id="609c" class="oq lx it bd ly oz pa dn mc pb pc dp mg li pd pe mi lm pf pg mk lq ph pi mm pj bi translated">科学研究委员会</h2><p id="eb98" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">文件夹是存储大量代码的地方。它包含项目代码、<strong class="lb iu"> <em class="lv">节点</em> </strong>和<strong class="lb iu"> <em class="lv">管道</em> </strong>代码、<strong class="lb iu"> <em class="lv">流道</em> </strong>代码等等。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="2d6e" class="lw lx it bd ly lz nl mb mc md nm mf mg jz nn ka mi kc no kd mk kf np kg mm mn bi translated">与Kedro合作</h1><p id="9938" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">高级Kedro工作流遵循以下顺序，</p><ol class=""><li id="72a7" class="mo mp it lb b lc ld lf lg li oi lm oj lq ok lu pk mw mx my bi translated"><strong class="lb iu">定义配置</strong>:指定<strong class="lb iu"> <em class="lv">数据目录</em> </strong>和参数</li><li id="97d0" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu pk mw mx my bi translated"><strong class="lb iu">编写函数</strong>:将项目代码包装到函数中</li><li id="9cf6" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu pk mw mx my bi translated"><strong class="lb iu">定义节点</strong>:将函数包装成节点</li><li id="a521" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu pk mw mx my bi translated"><strong class="lb iu">定义管道</strong>:将节点链接在一起</li><li id="884b" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu pk mw mx my bi translated"><strong class="lb iu">定义管道</strong>:指定管道应该如何运行</li><li id="4b87" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu pk mw mx my bi translated"><strong class="lb iu">运行管道</strong>:读取conf，使用runner，运行管道！</li></ol><p id="ce30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将更详细地介绍每个步骤，以分解工作流程。</p><h2 id="5a82" class="oq lx it bd ly oz pa dn mc pb pc dp mg li pd pe mi lm pf pg mk lq ph pi mm pj bi translated">№1: <strong class="ak">定义形态</strong></h2><p id="8fa9" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">数据目录</em> </strong>将文件名与其对应的文件类型和位置联系起来，并在<code class="fe ov ow ox om b">conf/base/catalog.yml</code>文件中定义。它可以这样定义，</p><pre class="kj kk kl km gt ol om pl bn pm pn bi"><span id="0062" class="po lx it om b be pp pq l pr ou">input_data:<br/>  type: pandas.CSVDataSet<br/>  filepath: data/01_raw/iris.csv<br/><br/>intermediate_data:<br/>  type: pandas.CSVDataSet<br/>  filepath: data/02_intermediate/iris_small.csv<br/><br/>processed_data:<br/>  type: pandas.CSVDataSet<br/>  filepath: data/03_primary/iris_processed.csv</span></pre><p id="1dec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们不需要在<code class="fe ov ow ox om b">data</code>文件夹中存在所有的文件路径，只需要输入数据，因为在管道运行时会创建中间数据。</p><p id="438d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">参数被输入到函数中，并在<code class="fe ov ow ox om b">conf/base/parameters.yml</code>文件中被定义为嵌套字典。</p><pre class="kj kk kl km gt ol om pl bn pm pn bi"><span id="c768" class="po lx it om b be pp pq l pr ou">input_param:<br/>  n_rows: 100</span></pre><h2 id="4b6a" class="oq lx it bd ly oz pa dn mc pb pc dp mg li pd pe mi lm pf pg mk lq ph pi mm pj bi translated">№2:编写函数</h2><p id="c937" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">功能是在<code class="fe ov ow ox om b">src</code>文件夹中定义的项目特定代码。自动处理前面步骤中定义的<strong class="lb iu"> <em class="lv"> DataConfig </em> </strong>和参数，使得函数的输入分别为pandas数据帧和dictionary类型，输出为pandas数据帧。我们不需要执行任何文件读取或保存操作——这抽象出了文件I/O代码！</p><p id="f6c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在高级部分，我们将编写自定义I/O代码来指定自定义读取和保存方法，以帮助连接到外部数据库。</p><p id="12e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个演示，让我们假设我已经用签名编写了两个函数</p><ul class=""><li id="d0bb" class="mo mp it lb b lc ld lf lg li oi lm oj lq ok lu mv mw mx my bi translated"><code class="fe ov ow ox om b">load_and_truncate_data(data: pd.DataFrame, input_param: Dict[str, Any]) -&gt; pd.DataFrame</code></li><li id="d216" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><code class="fe ov ow ox om b">drop_null_data(data: pd.DataFrame) -&gt; pd.DataFrame</code></li></ul><h2 id="681b" class="oq lx it bd ly oz pa dn mc pb pc dp mg li pd pe mi lm pf pg mk lq ph pi mm pj bi translated">№3:定义节点</h2><p id="a589" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">Node对象将函数的输入和输出(在步骤1中)包装到函数本身(在步骤2中)。指定节点名称是可选的，但是节点名称有助于运行特定节点的功能，而不是运行整个管道。为了最小化导入的数量，我更喜欢在同一个文件中定义节点和管道。</p><h2 id="478e" class="oq lx it bd ly oz pa dn mc pb pc dp mg li pd pe mi lm pf pg mk lq ph pi mm pj bi translated">第4项:定义管道</h2><p id="9075" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">管道对象将几个节点链接在一起，这是在<code class="fe ov ow ox om b">src/project_name/pipelines</code>文件夹中定义的。流水线和节点可以这样定义，</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ps pt l"/></div></figure><p id="3278" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ov ow ox om b">kedro.pipeline.Pipeline</code>(第10行)将多个<code class="fe ov ow ox om b">kedro.pipeline.node</code>对象链接在一起，每个节点将函数包装为<code class="fe ov ow ox om b">func</code>，输入数据和参数为<code class="fe ov ow ox om b">inputs</code>，输出为<code class="fe ov ow ox om b">outputs</code>，节点名为<code class="fe ov ow ox om b">name</code>。</p><p id="62d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，管道必须在<code class="fe ov ow ox om b">pipeline_registry.py</code>文件中注册。大部分代码已经给出，我们可以在return语句中将管道添加到字典中，</p><pre class="kj kk kl km gt ol om pl bn pm pn bi"><span id="5897" class="po lx it om b be pp pq l pr ou">def register_pipelines() -&gt; Dict[str, Pipeline]:<br/>    return {<br/>        "pipeline1": pipeline([processing_pipeline()]),<br/>        "__default__": pipeline([processing_pipeline()])<br/>    }</span></pre><p id="bbf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从管道定义中，我们观察到代码是可扩展的——我们可以很容易地定义一个训练、验证和评分管道，它调用运行不同节点序列的不同管道！</p><h2 id="5633" class="oq lx it bd ly oz pa dn mc pb pc dp mg li pd pe mi lm pf pg mk lq ph pi mm pj bi translated">№5:定义流道</h2><p id="23c0" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">Runner对象指定管道如何运行。默认情况下，选择<code class="fe ov ow ox om b">SequentialRunner</code>按顺序运行节点。还有<code class="fe ov ow ox om b">ParallelRunner</code>(多处理)<code class="fe ov ow ox om b">ThreadRunner</code>(多线程)。</p><p id="0700" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，还可以使用自定义运行器，通过跳过节点或允许重试来处理节点故障。</p><h2 id="a531" class="oq lx it bd ly oz pa dn mc pb pc dp mg li pd pe mi lm pf pg mk lq ph pi mm pj bi translated">№6:运行管道</h2><p id="1c25" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">可以使用代码或命令行界面(CLI)运行管道。建议使用CLI运行kedro，因为它确保没有变量泄漏，而且也很简单；可以用命令<code class="fe ov ow ox om b">kedro run</code>运行管道！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pu"><img src="../Images/d01e625ff7c4cf5164cdf6c050443d1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FMEWZHP1E4zBNZ30GstEqg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1:运行管道的终端输出——作者提供的图片</p></figure><p id="f2c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面运行的示例中，我们观察了Kedro如何运行管道的序列；它在运行节点之前加载数据和参数，之后保存数据，然后报告它已经完成了任务。日志还允许我们轻松地识别数据名称、数据类型、节点名称、函数名称和函数签名。</p><p id="dcb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于运行管道的更多变化，我们可以添加选项，</p><pre class="kj kk kl km gt ol om pl bn pm pn bi"><span id="f4cd" class="po lx it om b be pp pq l pr ou">$ kedro run --pipeline=pipeline1<br/>$ kedro run --node=load_and_truncate_data<br/>$ kedro run --from-nodes=node1 --to_node=node2<br/>$ kedro run --runner=ParallelRunner</span></pre></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="8189" class="lw lx it bd ly lz nl mb mc md nm mf mg jz nn ka mi kc no kd mk kf np kg mm mn bi translated">将Kedro与编码最佳实践相结合</h1><blockquote class="pv pw px"><p id="f8a3" class="kz la lv lb b lc ld ju le lf lg jx lh py lj lk ll pz ln lo lp qa lr ls lt lu im bi translated">添加文档组件、单元测试和林挺功能</p></blockquote><p id="502a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如在概述中提到的，Kedro使得从软件工程中实现编码最佳实践变得容易。</p><p id="f648" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">命令<code class="fe ov ow ox om b">kedro test</code>运行项目中的所有单元测试，遵循Python <code class="fe ov ow ox om b">unittest</code>或<code class="fe ov ow ox om b">pytest</code>框架。而命令<code class="fe ov ow ox om b">kedro lint</code>使用<code class="fe ov ow ox om b">flake8</code>、<code class="fe ov ow ox om b">isort</code>和<code class="fe ov ow ox om b">black</code> Python包执行林挺。这些CLI命令无缝地工作，除了编写测试用例之外，用户不需要额外的工作。</p><div class="qb qc gp gr qd qe"><a rel="noopener follow" target="_blank" href="/unit-testing-with-mocking-in-10-minutes-e28feb7e530"><div class="qf ab fo"><div class="qg ab qh cl cj qi"><h2 class="bd iu gy z fp qj fr fs qk fu fw is bi translated">10分钟后模拟单元测试</h2><div class="ql l"><h3 class="bd b gy z fp qj fr fs qk fu fw dk translated">使用内置的unittest Python包有效地测试您的代码库</h3></div><div class="qm l"><p class="bd b dl z fp qj fr fs qk fu fw dk translated">towardsdatascience.com</p></div></div><div class="qn l"><div class="qo l qp qq qr qn qs ks qe"/></div></div></a></div><div class="qb qc gp gr qd qe"><a rel="noopener follow" target="_blank" href="/pytest-with-marking-mocking-and-fixtures-in-10-minutes-678d7ccd2f70"><div class="qf ab fo"><div class="qg ab qh cl cj qi"><h2 class="bd iu gy z fp qj fr fs qk fu fw is bi translated">10分钟内完成标记、模仿和固定装置的Pytest</h2><div class="ql l"><h3 class="bd b gy z fp qj fr fs qk fu fw dk translated">用Python pytest编写健壮的单元测试</h3></div><div class="qm l"><p class="bd b dl z fp qj fr fs qk fu fw dk translated">towardsdatascience.com</p></div></div><div class="qn l"><div class="qt l qp qq qr qn qs ks qe"/></div></div></a></div><p id="cceb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为您的源代码编写文档字符串和文档也是一个很好的实践，这样技术和非技术受众都可以理解这个存储库。命令<code class="fe ov ow ox om b">kedro build-docs</code>自动为您的项目生成文档。这是建立在Sphinx框架之上的，它可以用漂亮的HTML格式显示文档。</p><div class="qb qc gp gr qd qe"><a rel="noopener follow" target="_blank" href="/advanced-code-documentation-beyond-comments-and-docstrings-2cc5b2ace28a"><div class="qf ab fo"><div class="qg ab qh cl cj qi"><h2 class="bd iu gy z fp qj fr fs qk fu fw is bi translated">注释和文档字符串之外的高级代码文档</h2><div class="ql l"><h3 class="bd b gy z fp qj fr fs qk fu fw dk translated">使用Sphinx并阅读文档以获得用户友好的界面来理解代码库——即使对于非技术用户也是如此</h3></div><div class="qm l"><p class="bd b dl z fp qj fr fs qk fu fw dk translated">towardsdatascience.com</p></div></div><div class="qn l"><div class="qu l qp qq qr qn qs ks qe"/></div></div></a></div></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="1b64" class="lw lx it bd ly lz nl mb mc md nm mf mg jz nn ka mi kc no kd mk kf np kg mm mn bi translated">高级:使用外部数据库</h1><p id="e17b" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">kedro<a class="ae ky" href="https://kedro.readthedocs.io/en/stable/data/data_catalog.html" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"><em class="lv">data catalog</em></strong></a>支持读取和保存本地或网络文件系统、Hadoop文件系统(HDFS)、亚马逊S3、谷歌云、Azure和HTTP(s)上的数据集。诸如<code class="fe ov ow ox om b">fs_args</code>、<code class="fe ov ow ox om b">load_args</code>和<code class="fe ov ow ox om b">save_args</code>之类的附加参数可以作为键传递给<strong class="lb iu"> <em class="lv"> DataCatalog </em> </strong>以指定与文件系统交互时的参数。</p><p id="fd44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果用户需要更多的读/写操作，可以在<code class="fe ov ow ox om b">project_name/io</code>文件夹中编写自定义的I/O类。这些定制类使用Kedro抽象类，比如<code class="fe ov ow ox om b">AbstractDataSet</code>和<code class="fe ov ow ox om b">AbstractVersionedDataSet</code>作为基类。实现从CSV文件中读写pandas DataFrame的示例自定义I/O类可以这样编写，</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ps pt l"/></div></figure><p id="b548" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相应的数据目录可以这样定义，</p><pre class="kj kk kl km gt ol om pl bn pm pn bi"><span id="5aa1" class="po lx it om b be pp pq l pr ou">intermediate_data:<br/>  type: project_name.io.python_csv.PythonCSV<br/>  filepath: data/02_intermediate/iris_small.csv<br/>  save_args:<br/>    index: false</span></pre><p id="ae5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种使用Kedro的抽象类作为基类来编写定制I/O类的方式是扩展Kedro功能以提供定制选项的一种简洁方式——如果您想要定制runner函数，也可以用同样的方式完成！</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><p id="0b9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望您对Kedro作为一个开发工作流框架有了更好的理解。Kedro提供了更多的功能，比如数据版本控制、数据代码转换、编写钩子、编写CLI来调用自定义命令，比如<code class="fe ov ow ox om b">kedro &lt;command&gt;</code>，等等。</p><blockquote class="nt"><p id="aaca" class="nu nv it bd nw nx ny nz oa ob oc lu dk translated">我发现Kedro的美妙之处在于它在严格性和允许定制化之间的平衡</p></blockquote><p id="63d3" class="pw-post-body-paragraph kz la it lb b lc od ju le lf oe jx lh li of lk ll lm og lo lp lq oh ls lt lu im bi translated">例如，Kedro实施了一个文件夹结构，但是给用户在<code class="fe ov ow ox om b">src</code>文件夹中构建代码的自由。Kedro抽象出了处理I/O操作的复杂性，还允许用户在需要时轻松扩展和编写定制的I/O类。</p><blockquote class="pv pw px"><p id="43c5" class="kz la lv lb b lc ld ju le lf lg jx lh py lj lk ll pz ln lo lp qa lr ls lt lu im bi translated">Kedro如何在引擎盖下工作的复杂性也令人惊讶</p></blockquote><p id="a632" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">处理流道、管道和配置的方式无需明确说明它们应该如何相互交互，从而改善了编码体验。然而，这种抽象不可避免地导致对组件如何运行的控制和可见性降低。</p><blockquote class="pv pw px"><p id="02c9" class="kz la lv lb b lc ld ju le lf lg jx lh py lj lk ll pz ln lo lp qa lr ls lt lu im bi translated">就可用性而言，Kedro强制源代码模块化</p></blockquote><p id="7712" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为节点对象引用直接起作用，所以在代码库中不会有松散的代码。这使得代码库更容易维护，并以可重现的方式运行完整、部分或不同的管道。但是，由于每个节点都要加载和保存一个数据集，这可能会占用大量空间和时间，与编写几个函数并将一个函数的输出直接传递给下一个函数而不必每次都保存和加载相比，这会导致大量I/O操作。这将是对检查点和可再现性的需求与对效率的需求之间的权衡。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><p id="184a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是演示中使用的<a class="ae ky" href="https://github.com/kayjan/test-kedro" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>的链接。</p><p id="d0ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">感谢您的阅读！</strong>如果你喜欢这篇文章，请随意分享。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="8992" class="lw lx it bd ly lz nl mb mc md nm mf mg jz nn ka mi kc no kd mk kf np kg mm mn bi translated">相关链接</h1><p id="9dc5" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">Kedro文档:<a class="ae ky" href="https://kedro.readthedocs.io" rel="noopener ugc nofollow" target="_blank">https://kedro . readthedocs . io</a></p><p id="8f41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kedro官方GitHub:<a class="ae ky" href="https://github.com/kedro-org/kedro" rel="noopener ugc nofollow" target="_blank">https://github.com/kedro-org/kedro</a></p></div></div>    
</body>
</html>