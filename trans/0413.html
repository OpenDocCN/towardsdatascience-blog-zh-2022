<html>
<head>
<title>Understanding The Derivative Of The Sigmoid Function</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Sigmoid函数的导数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-the-derivative-of-the-sigmoid-function-cbfd46fb3716#2022-02-16">https://towardsdatascience.com/understanding-the-derivative-of-the-sigmoid-function-cbfd46fb3716#2022-02-16</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="d621" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">如何找到神经网络的Sigmoid函数的导数—简单的逐步演练</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/4fc419d8a222d8826b57818270624965.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*izNTgVGbmtyHjgnk"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@matthewhume?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马修·休姆</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="83f6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我最近在Medium上读到了一篇很棒的帖子，向我展示了如何从头开始实现自己的神经网络。这对我理解机器学习，尤其是神经网络的内部工作是有价值的。</p><p id="5867" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我学习实现的网络使用了Sigmoid函数。然而，那篇文章并没有详细讨论Sigmoid函数的数学原理。这让我挠头，作为一个想了解我所使用的工具的一切的人，我不得不钻研数学，找出发生了什么。</p><p id="fe7f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你也对Sigmoid函数及其在神经网络中的应用感到好奇，那么请继续阅读。在这篇文章中，我将带你一步一步地了解它，并试图让它尽可能容易理解。</p><p id="91df" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这篇文章的主要内容是如何找到Sigmoid函数的导数，到最后你也能理解它了！</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h2 id="4992" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">如何在神经网络中使用Sigmoid函数</h2><p id="03ce" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">首先，Sigmoid函数接受一个数字作为输入，并返回一个介于0和1之间的新值。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nb"><img src="../Images/1dd99825700053db04d53864b6edb525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hujcGZSNkmQWCv-s.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Wikipedia.com的Sigmoid函数图</p></figure><p id="07ec" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">正如您在上面的图表中看到的，x值为0将返回y值为0.5，更大的正x值将y值向1移动，最终更大的负x值将导致y值更接近0。</p><p id="04ab" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Sigmoid函数通常用作神经网络各层中的激活函数。简而言之，这意味着它决定一个节点是否应该被激活，从而决定该节点是否应该对网络的计算做出贡献。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h2 id="b927" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">为什么Sigmoid函数在神经网络中如此重要</h2><p id="f3b5" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">神经网络的训练阶段由两部分组成。</p><ol class=""><li id="8fbd" class="nc nd iu lc b ld le lg lh lj ne ln nf lr ng lv nh ni nj nk bi translated">前馈</li><li id="d67f" class="nc nd iu lc b ld nl lg nm lj nn ln no lr np lv nh ni nj nk bi translated">反向传播</li></ol><p id="7466" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">前馈</strong>是数据通过神经网络从输入节点流向输出节点的过程。换句话说，这就是网络试图做出预测的地方。</p><p id="247c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后，将这些预测值与实际值进行比较，对其进行评估。误差可以通过两个值之间的差值来确定。</p><p id="4aae" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe nq nr ns nt b">error = actual_value - predicted_value</code></p><p id="a0e7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">反向传播</strong>接着发生，这是神经网络中“学习”或“调整”发生的地方。现在，误差值以与之前相反的方向流回网络，然后与Sigmoid函数的<strong class="lc iv">导数结合使用，以调整网络各层中所有节点的权重。</strong></p><p id="fe1a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用Sigmoid函数的导数是因为它允许我们通过梯度下降进行调整。函数的导数会给我们函数描述的图形的角度/斜率。这个值将让网络知道是否要增加或减少网络各层中各个权重的值。在反向传播过程中，激活函数的导数要计算很多次，这就是Sigmoid函数真正的亮点。</p><p id="ea20" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Sigmoid函数看起来像这样</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nu"><img src="../Images/89bb5e2006c26df86234f7d87955cf77.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*28sVGz2NNcyIxfmzObkU7w.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Sigmoid函数</p></figure><p id="b2a6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Sigmoid函数的导数就是</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nv"><img src="../Images/6d4b567500bfab0beef6d76f116c64f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*o1cbVrxHTrPAKITb5Bq8cw.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Sigmoid函数的导数</p></figure><p id="a77d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">换句话说，Sigmoid函数的导数是Sigmoid函数本身乘以1减去Sigmoid函数。</p><p id="1d16" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">酷的事情是，在<strong class="lc iv">反向传播</strong>期间，我们已经计算了在<strong class="lc iv">前馈</strong>步骤期间Sigmoid函数的导数的所有部分，因此没有什么新的要计算。相反，我们可以简单地将Sigmoid函数的结果应用于导数方程的两个点。</p><p id="fc7f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这使得神经网络不必进行大量的计算，否则在使用其他激活函数时就需要进行大量的计算。能够避免如此多的额外计算是Sigmoid函数对神经网络非常有用的原因之一。</p><p id="2950" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在到了我很难理解的部分，为什么Sigmoid函数的导数是Sigmoid函数本身乘以1减去Sigmoid函数。</p><p id="05bf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">正如介绍中所解释的，我发现要准确理解Sigmoid函数的导数是如何找到的有点困难，因此在下一节中，我将尝试遍历所有的数学步骤，以便您也可以学习它！</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h2 id="8583" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">Sigmoid函数导数背后的数学</h2><p id="8838" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">为了获得Sigmoid函数的导数，我们需要两条规则，<a class="ae kz" href="https://en.wikipedia.org/wiki/Chain_rule" rel="noopener ugc nofollow" target="_blank">链式规则</a>，以及<a class="ae kz" href="https://en.wikipedia.org/wiki/Quotient_rule" rel="noopener ugc nofollow" target="_blank">商规则</a>。</p><p id="2618" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们将一步一步地进行计算，我会指出何时应用规则。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nu"><img src="../Images/89bb5e2006c26df86234f7d87955cf77.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*28sVGz2NNcyIxfmzObkU7w.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Sigmoid函数</p></figure><p id="1295" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因为Sigmoid函数是一个分数，分子和分母都是可微的，所以我们可以使用商法则来计算整个函数的导数。</p><p id="9f1d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">商法则说，我们可以用下面的方法得到一个函数的导数:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nw"><img src="../Images/f60ab09bec0012b8a6e6636cebb232f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*6UEEXva9uc-pEtfiWDSHCg.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">商数法则</p></figure><blockquote class="nx ny nz"><p id="8dab" class="la lb oa lc b ld le jv lf lg lh jy li ob lk ll lm oc lo lp lq od ls lt lu lv in bi translated">den是分母的简称，num是分子的简称。</p></blockquote><p id="a45e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">取Sigmoid函数的分子和分母，以及分子的导数和分母的导数，并将它们放入上述函数中，我们得到:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oe"><img src="../Images/a5bc7840dd4f883ec8dfac9dcd3a756d.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*KzSb6LqiphInCnINyTV0Ag.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Sigmoid函数的商规则</p></figure><p id="7e25" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">分子的导数变成0，因为分子是常数。</p><p id="81e3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">分母的导数变成:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj of"><img src="../Images/18cfc07f7a53c5d580a3ba1b4ce3833a.png" data-original-src="https://miro.medium.com/v2/resize:fit:464/format:webp/1*dM4TiCn0NstkSueGsc2psA.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Sigmoid函数分母的导数</p></figure><p id="9439" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这就是使用链式规则的地方，我认为这一步可能需要更多的解释和详细的演练。</p><p id="5b98" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">链式法则告诉我们，复合函数(内部包含另一个函数的函数)的导数按以下方式计算:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj og"><img src="../Images/5817ae4e3dccfcff65df8f1b993442a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:326/format:webp/1*JwKk35dJ3uTrzF3CBL5FdQ.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">合成函数的一个例子</p></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oh"><img src="../Images/b517d36ef4d7f0d81c1de2f31c4746b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*bqAPBeqodMSH1d8nR9FUKg.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用链式法则的合成函数的导数</p></figure><p id="e656" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">换句话说，这可以理解为:合成函数的导数是包含内部函数<em class="oa"> g </em>的外部函数<em class="oa"> f </em>的导数乘以内部函数的导数。</p><p id="9acb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">既然这样</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oi"><img src="../Images/16840ce8b1b227f574b6eb4653df1a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:164/format:webp/1*O8PX4XM7sufdQbbKRgRgHA.png"/></div></figure><p id="07aa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">被认为是外部函数(y代表内部函数)。那么内部函数是-x。当对Sigmoid函数的分母应用链式法则时，我们得到以下等式:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oj"><img src="../Images/3616a73eb4c01b128bac7e6504a37192.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*SDuCAYPBoD3EU7Dx6RQO4g.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">应用于Sigmoid函数分母的链式法则</p></figure><p id="e0ec" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果我们从寻找外部函数的导数开始，那么1变成0，并且<em class="oa"> e </em>对某物的幂的导数保持不变，如下式所示。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ok"><img src="../Images/4b2f175db7011190e30d8c3b590b7b6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:246/format:webp/1*eTvtYd9Nn4viRDiCKIPiJA.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">e对某物的幂的导数也是一样的</p></figure><p id="601c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此时我们有了外函数的导数，下一步是求内函数的导数。内部函数就是-x，它的导数变成了-1。<br/>将所有这些放在一起，我们得到:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ol"><img src="../Images/d933d7447cc736d08df554c81a29ea48.png" data-original-src="https://miro.medium.com/v2/resize:fit:318/format:webp/1*AuDm3lfE1dNnM0f1n6-qHA.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">应用于Sigmoid函数分母的链式法则</p></figure><p id="0fbe" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个表达式可以简化为:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj om"><img src="../Images/25d4903fff5d2ed3c4b9545f1c881275.png" data-original-src="https://miro.medium.com/v2/resize:fit:178/format:webp/1*j-dAKmNl4tlvcKiPrkmvKQ.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Sigmoid函数分母的导数</p></figure><p id="7331" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是第一个困难的部分，现在我们可以回到商法则，理解我们如何得到分母的导数。</p><p id="1052" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">请记住，这是我们停止的地方:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nw"><img src="../Images/f60ab09bec0012b8a6e6636cebb232f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*6UEEXva9uc-pEtfiWDSHCg.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">商数法则</p></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oe"><img src="../Images/a5bc7840dd4f883ec8dfac9dcd3a756d.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*KzSb6LqiphInCnINyTV0Ag.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Sigmoid函数的商规则</p></figure><p id="ece2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们现在可以通过去掉乘以0的部分来简化上面的表达式。这给了我们以下内容:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj on"><img src="../Images/0fd541e218683ac2b1206ea843eafaa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*MmOklP21t8JephMnDrrxYQ.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Sigmoid函数第一次约化后的商规则</p></figure><p id="2d76" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来，我们可以将分子中的两个括号相乘，得到:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oo"><img src="../Images/e18dbb958e4490d7f308f6b011a1310a.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*lF8aTcaqjmf79owJMxfTuQ.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Sigmoid函数第二次约化后的商规则</p></figure><p id="db3f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们现在已经非常接近了，但是函数还没有达到预期的形式。为了达到这个目的，我们首先需要使用一个小技巧，在分子中加减1。这样做对等式的结果没有实际影响，但是它使下面的步骤成为可能。像这样:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj op"><img src="../Images/6cf8e41d7246084940fa6b03e685225c.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/1*p8L2kYhUty9SzPcp1Nj1_w.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">从分子中加减1</p></figure><p id="1cf7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这样，我们可以将函数分成两个独立的部分，如下所示:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oq"><img src="../Images/0713ef855d887ea6e7f639b870ba68c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*PCoZdJI90vbw8qUlHsOwIQ.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">将函数分成两部分</p></figure><p id="29b2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通过这样表示函数，我们能够在第一个分数中抵消<code class="fe nq nr ns nt b">e^-x</code>。从而给我们提供了以下内容:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj or"><img src="../Images/21ed654cfdc6359b8805bed0cec8d40b.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*_z48Tj9Fzb9SWbdJtq1lUw.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">抵消了左分数中的e^-x</p></figure><p id="d4cb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在可以将它重写为</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj os"><img src="../Images/5d08193e5e9e9d906eabc5f470a8d5b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*JXiV94YLu7nh3cAy_vEMLw.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">重写了上一步</p></figure><p id="d165" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我认为这是很难立即理解的步骤之一，但是如果你试图通过将这两个分数相乘来逆向计算，你应该会得到上一步的结果。如果您首先将最左边的分数与右边括号中的值1相乘，您将得到左边的分数本身(对应于前面等式中的第一个分数)。接下来，将左分数乘以圆括号中的负分数<strong class="lc iv">，从而得到分母为平方的结果(上一个等式的第二个分数)。</strong></p><p id="d167" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在到了最后一步。如果你看看我们刚刚得出的方程，你可能会发现它实际上包括了Sigmoid函数本身。提醒一下，看起来像这样:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nu"><img src="../Images/89bb5e2006c26df86234f7d87955cf77.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*28sVGz2NNcyIxfmzObkU7w.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Sigmoid函数</p></figure><p id="6cf7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，我们可以将Sigmoid函数换成上面的等式，这使我们得到所需的形式:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nv"><img src="../Images/6d4b567500bfab0beef6d76f116c64f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*o1cbVrxHTrPAKITb5Bq8cw.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Sigmoid函数的导数</p></figure><p id="b5c5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">就是这样！这就是为什么Sigmoid函数的导数就是Sigmoid函数本身乘以1减去Sigmoid函数背后的数学原理。</p><p id="5a3a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">恭喜你完成了所有这些方程。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ot"><img src="../Images/5b61f5df421ed3418d7f1cd3941aeca3.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/0*0NpMIqfzRTAYb2B4.gif"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">莱昂纳多和我祝贺你——GIF</p></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h2 id="504e" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">摘要</h2><p id="fd6c" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">你现在已经学会了如何求Sigmoid函数的导数。这样做的全部原因是因为它在神经网络的<strong class="lc iv">反向传播</strong>步骤中使用，以便向上或向下调整权重。由于在<strong class="lc iv">前馈</strong>步骤中已经找到了Sigmoid函数的导数所需的所有方程，这为我们节省了大量计算，并且这是使用Sigmoid函数作为神经网络层中的激活函数的好处之一。</p><p id="038b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我希望这篇文章对你有所帮助，并且现在已经很清楚为什么Sigmoid函数的导数是这样的了。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><p id="660c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您喜欢您所阅读的内容，那么如果您能支持我，使用我下面的推荐链接注册Medium，我将不胜感激:</p><div class="ou ov gq gs ow ox"><a href="https://jacobtoftgaardrasmussen.medium.com/membership" rel="noopener follow" target="_blank"><div class="oy ab fp"><div class="oz ab pa cl cj pb"><h2 class="bd iv gz z fq pc fs ft pd fv fx it bi translated">通过我的推荐链接加入Medium雅各布·托弗加德·拉斯姆森</h2><div class="pe l"><h3 class="bd b gz z fq pc fs ft pd fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pf l"><p class="bd b dl z fq pc fs ft pd fv fx dk translated">jacobtoftgaardrasmussen.medium.com</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl kt ox"/></div></div></a></div><p id="e2b7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你对我在介绍中提到的展示如何从零开始制作神经网络的帖子感到好奇，那么你可以使用下面的下一个链接来查看:</p><div class="ou ov gq gs ow ox"><a rel="noopener follow" target="_blank" href="/how-to-build-your-own-neural-network-from-scratch-in-python-68998a08e4f6"><div class="oy ab fp"><div class="oz ab pa cl cj pb"><h2 class="bd iv gz z fq pc fs ft pd fv fx it bi translated">如何用Python从零开始构建自己的神经网络</h2><div class="pe l"><h3 class="bd b gz z fq pc fs ft pd fv fx dk translated">理解深度学习内部运作的初学者指南</h3></div><div class="pf l"><p class="bd b dl z fq pc fs ft pd fv fx dk translated">towardsdatascience.com</p></div></div><div class="pg l"><div class="pm l pi pj pk pg pl kt ox"/></div></div></a></div></div></div>    
</body>
</html>