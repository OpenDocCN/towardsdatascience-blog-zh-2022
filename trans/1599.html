<html>
<head>
<title>How to Validate Your JSON Using JSON Schema</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用JSON模式验证您的JSON</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-validate-your-json-using-json-schema-f55f4b162dce#2022-04-18">https://towardsdatascience.com/how-to-validate-your-json-using-json-schema-f55f4b162dce#2022-04-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ecad" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Python中JSON模式的简明介绍</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/03ab3f89e08bbecfb76dcc0335bbd7f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LPwau8bIdlbA9SVO"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">费伦茨·阿尔马西在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="77cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想象以下场景:你和你的队友正在开发一个新功能。你的任务是创建一个包含一些结果的JSON并发送给你的队友。她的任务是获取这个JSON，解析它并保存在数据库中。你们口头上同意了键和类型应该是什么，并且你们每个人都实现了他们的部分。听起来很合理，如果JSON结构简单，它确实可以工作。但是有一天你出了个bug，把钥匙送错了。您吸取了教训，决定创建一个API，并将其记录在您团队最喜欢的文档平台中。现在，你们都可以看看这个API，以确保正确地实现了它。</p><p id="bea8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但这就足够了吗？假设您确实正确地实现了它。假设另一个队友做了一个改变，现在它返回一个数字数组而不是单个数字。你的队友不知道你的API，所有东西都坏了。</p><p id="9b0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果在发送和解析JSON之前，可以直接在代码中验证JSON，会怎么样？这就是我们拥有JSON模式的目的！</p><p id="3a42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将介绍JSON Schema，为什么它如此强大，以及我们如何在不同的场景中使用它。</p><h1 id="86dd" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是JSON模式？</h1><p id="7278" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">JSON模式是一种基于JSON的格式，用于定义JSON数据的结构。它为给定的应用程序需要什么样的JSON数据以及如何与之交互提供了一个契约。它可以用于JSON数据的验证、文档、超链接导航和交互控制。</p><p id="4d50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该模式可以在JSON文件中定义，并加载到您的代码中，也可以直接在代码中创建。</p><h2 id="9ed0" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">如何验证我们的JSON？</h2><p id="1942" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">轻松点。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="12de" class="mp lt iq nc b gy ng nh l ni nj">validate(instance=your_json, schema=schema)</span></pre><p id="9e6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://python-jsonschema.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank">例如</a>:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="ed54" class="mp lt iq nc b gy ng nh l ni nj"><strong class="nc ir">from</strong> <strong class="nc ir">jsonschema</strong> <strong class="nc ir">import</strong> validate<br/><br/><strong class="nc ir">&gt;&gt;&gt; </strong><em class="nk"># A sample schema, like what we'd get from json.load()</em><br/><strong class="nc ir">&gt;&gt;&gt; </strong>schema = {<br/><strong class="nc ir">... </strong>    "type" : "object",<br/><strong class="nc ir">... </strong>    "properties" : {<br/><strong class="nc ir">... </strong>        "price" : {"type" : "number"},<br/><strong class="nc ir">... </strong>        "name" : {"type" : "string"},<br/><strong class="nc ir">... </strong>    },<br/><strong class="nc ir">... </strong>}<br/><br/><strong class="nc ir">&gt;&gt;&gt; </strong><em class="nk"># If no exception is raised by validate(), the instance is valid.</em><br/><strong class="nc ir">&gt;&gt;&gt; </strong>validate(instance={"name" : "Eggs", "price" : 34.99}, schema=schema)<br/><br/><strong class="nc ir">&gt;&gt;&gt; </strong>validate(<br/><strong class="nc ir">... </strong>    instance={"name" : "Eggs", "price" : "Invalid"}, schema=schema,<br/><strong class="nc ir">... </strong>)                                   <br/>Traceback (most recent call last):<br/>    ...<br/>ValidationError: 'Invalid' is not of type 'number'</span></pre><h1 id="2c32" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">我为什么要使用JSON模式？</h1><p id="e4e3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">每个JSON对象都有一个基本的键值结构。键是一个字符串，值可以是任何<a class="ae kv" href="http://json-schema.org/understanding-json-schema/reference/type.html" rel="noopener ugc nofollow" target="_blank">类型</a> — <a class="ae kv" href="https://json-schema.org/understanding-json-schema/reference/numeric.html" rel="noopener ugc nofollow" target="_blank">数字</a>、字符串、数组、JSON等。</p><p id="08f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在某些情况下，该值只能是特定的类型，而在其他情况下，该值更加灵活。我们的JSON中有些键是必需的，有些是可选的。还有更复杂的场景。例如，如果我们得到了某个密钥，那么第二个密钥必须出现。一个键值可以依赖于第二个键值。</p><p id="a8af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有这些场景以及更多场景都可以使用JSON Schema进行本地测试和验证。通过使用它，您可以验证自己的JSON，并确保它在与其他服务集成之前满足API要求。</p><h1 id="8944" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">简单JSON模式</h1><p id="6988" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在这个例子中，我们的JSON包含了关于狗的信息。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="24b3" class="mp lt iq nc b gy ng nh l ni nj">{<br/> "breed": "golden retriever",<br/> "age": 5,<br/> "weight": 13.5,<br/> "name": "Luke"<br/>}</span></pre><p id="1436" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们更仔细地看看这个JSON的属性，以及我们希望对每个属性实施的要求:</p><ul class=""><li id="a928" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr nq nr ns nt bi translated">品种——我们只想代表三个品种:金毛寻回犬、比利时马利诺犬和边境牧羊犬。我们想证实这一点。</li><li id="572a" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated">年龄—我们希望将年龄四舍五入到年，因此我们的值将表示为整数。在本例中，我们还希望将最大年龄限制为15岁。</li><li id="6fe0" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated">权重—可以是任何正数、整数或浮点数。</li><li id="a17c" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated">名称—始终是字符串。可以是任何字符串。</li></ul><p id="ae16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的计划是-</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="c9c8" class="mp lt iq nc b gy ng nh l ni nj">{<br/> "type": "object",<br/> "properties":<br/>     {<br/>        "breed": {"type":"string", <!-- -->"enum":[<br/>                                            "<!-- -->golden retrievers", <br/>                                            "Belgian Malinois", <br/>                                            "Border Collie"<br/>                                         ]<br/>                 },<br/>        "age": {"type": "int", "maximum":15, "minimum":0},<br/>        "weight": {"type":"number", "minimum":0},<br/>        "name": {"type":"string"}<br/>     }<br/>}</span></pre><p id="494d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，只能添加0到15之间的年龄值，没有负体重，并且只有三个特定的品种。</p><h1 id="4f76" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">简单数组模式</h1><p id="c3a7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们还可以验证数组值。</p><p id="04af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，我们想要一个具有以下属性的数组:2到5项，唯一值，仅字符串。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="aafb" class="mp lt iq nc b gy ng nh l ni nj">['a','b','c']</span><span id="d8fd" class="mp lt iq nc b gy nz nh l ni nj">{<br/> "type": "array",<br/> "items": {"type": "string"},<br/> "minItems": 2,<br/> "maxItems": 5,<br/> "uniqueItems": true<br/>}</span></pre><h1 id="9eea" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">更复杂的功能</h1><h2 id="0806" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">必需的属性</h2><p id="6653" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">有些属性是必需的，如果它们缺失，我们会提出一个错误。</p><p id="df5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以添加<code class="fe oa ob oc nc b"><strong class="ky ir">required</strong></code>关键字。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="3176" class="mp lt iq nc b gy ng nh l ni nj">{<br/> "type": "object",<br/> "properties":<br/>     {<br/>        "breed": {"type":"string"},<br/>        "age": {"type": "int", "maximum":15, "minimum":0}<br/>     }<br/> "required":["breed"]<br/>}</span></pre><p id="8ced" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，如果缺少“品种”属性，将会引发错误。其他属性如“年龄”仍然是可选的。</p><h2 id="8ddc" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">需要家属</h2><p id="0bbc" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果给定的属性存在于对象中，关键字<code class="fe oa ob oc nc b"><strong class="ky ir">dependentRequired</strong></code>有条件地要求某些属性存在。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="2716" class="mp lt iq nc b gy ng nh l ni nj">{<br/>  "type": "object",<br/><br/>  "properties": {<br/>    "name": { "type": "string" },<br/>    "credit_card": { "type": "number" },<br/>    "billing_address": { "type": "string" }<br/>  },<br/><br/>  "required": ["name"],<br/><br/>  "dependentRequired": {<br/>    "credit_card": ["billing_address"]<br/>  }<br/>}</span></pre><p id="f529" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，如果出现“信用卡”属性，则需要“帐单地址”。</p><h2 id="b2fa" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">一个/任何一个</h2><p id="cce0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">到目前为止，每个属性只有一种类型。如果我们的财产可以有几种不同的类型呢？</p><p id="1715" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例1 — <code class="fe oa ob oc nc b"><strong class="ky ir">anyOf</strong></code> —要根据<code class="fe oa ob oc nc b">anyOf</code>进行验证，给定的数据必须对任何(一个或多个)给定的子模式有效。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="1d91" class="mp lt iq nc b gy ng nh l ni nj">{<br/>  "anyOf": [<br/>    { "type": "string"},<br/>    { "type": "number", "minimum": 0 }<br/>  ]<br/>}</span></pre><p id="50ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，我们的数据可以是字符串，也可以是大于或等于0的数字。</p><p id="be10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例2 — <code class="fe oa ob oc nc b"><strong class="ky ir">oneOf</strong></code> —为了对<code class="fe oa ob oc nc b">oneOf</code>进行验证，给定的数据必须对其中一个给定的子模式有效。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="72ff" class="mp lt iq nc b gy ng nh l ni nj">{<br/>  "oneOf": [<br/>    { "type": "number", "multipleOf": 5 },<br/>    { "type": "number", "multipleOf": 3 }<br/>  ]<br/>}</span></pre><p id="9b04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，数据只能是数字，可以是5的倍数，也可以是3的倍数，但不能两者都是！</p><h1 id="a114" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">摘要</h1><p id="8b28" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">JSON模式是一个强大的工具。它使您能够验证您的JSON结构，并确保它满足所需的API。您可以根据需要创建任意复杂和嵌套的模式，您所需要的只是需求。您可以将它作为附加测试或在运行时添加到您的代码中。</p><p id="6cc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我介绍了基本结构，并提到了一些更复杂的选项。有很多可以探索和利用的东西，你可以阅读。</p><p id="94e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我认为任何将JSONs作为工作一部分的人都应该熟悉这个包及其选项。仅仅通过简单地验证您的JSON结构，它就有可能节省您大量的时间并简化您的集成过程。我知道自从我开始使用它以来，它节省了我很多时间。</p><div class="od oe gp gr of og"><a href="https://json-schema.org/" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">JSON模式</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">JSON Schema是一个词汇表，允许您注释和验证JSON文档。描述您现有的数据…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">json-schema.org</p></div></div></div></a></div></div></div>    
</body>
</html>