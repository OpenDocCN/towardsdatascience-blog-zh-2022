<html>
<head>
<title>Adaptive Parameters Methods for Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习的自适应参数方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/adaptive-parameters-methods-for-machine-learning-6f7101a9a71#2022-06-10">https://towardsdatascience.com/adaptive-parameters-methods-for-machine-learning-6f7101a9a71#2022-06-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="99fc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们探索一些方法来适应您的参数随着时间的推移。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bd124b93c239f7d53bce4f871491cce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DeZYSLcMdF58BeqemGhUhg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">罗斯·芬登在<a class="ae kv" href="https://unsplash.com/es/fotos/mG28olYFgHI" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="37bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将讨论机器学习的自适应参数方法背后的思想，以及为什么和什么时候使用python作为一些实际例子来实现它们。</p><h1 id="82e7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak"> 1。简介</strong></h1><p id="7bd6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">自适应方法(也称为参数调度)是指使用调度在训练时更新一些模型参数的策略。</p><p id="5789" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种变化将取决于模型在时间<em class="mp"> t的状态；</em>例如，您可以根据损失值、迭代次数/时期数、经过的训练时间等来更新它们。</p><p id="693c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，一般来说，对于神经网络，学习速率的选择有几个结果；如果学习率过大，可能会超调最小值；如果它太小，可能需要很长时间才能收敛，或者可能陷入局部最小值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/5f09caec3bdd1116228842f8cad214ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H5OnW1jHfgEFcQ4SM0z7BQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">适应性学习率。图片由作者提供。</p></figure><p id="1b1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，我们选择改变学习率作为历元的函数；这样，你可以在训练开始时设定一个较大的速率，并顺应时代的增长；您可以减小该值，直到达到较低的阈值。</p><p id="7972" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你也可以把它看作是一种探索的方式与剥削的策略，所以在开始的时候，你允许更多的探索，在结束的时候，你选择剥削。</p><h1 id="a273" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.适配器</h1><p id="24c1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">有几种方法可以选择来控制参数从初始值到最终阈值的形式和速度；在本文中，我将它们称为“适配器”，并且我将把重点放在将参数值改变为迭代次数的函数的方法上(在神经网络的情况下，是迭代次数)。</p><p id="8186" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将介绍一些定义和符号:</p><p id="8826" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">初始值表示参数的起点，结束值是经过多次迭代后得到的值，自适应速率控制从初始值到结束值的速度。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/66c7abce1b1718f9a7e36bd5fc4d9f6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/format:webp/1*O5s18wX3WUvWwYEmnnP6lg.png"/></div></figure><p id="acc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，每个适配器应该具有以下属性:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/98702025449d2fa4a78bd0e12bd4dc29.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*P7RFNrp4j5mJRdQUIxQdwg.png"/></div></figure><p id="535e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将解释三种类型的适配器:</p><ul class=""><li id="d67a" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated">指数的</li><li id="1a08" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">相反的</li><li id="cd6d" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">潜在的</li></ul><h1 id="433d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.1指数适配器</h1><p id="9d73" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">指数适配器使用以下形式来更改初始值:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/6b88387e8613b8f83a1edc1b6a64ce45.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*Foz8MLQZLzH5PVfT95zkOw.png"/></div></figure><p id="f249" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据这个公式，alpha应该是一个正值，以获得所需的属性。</p><p id="ea7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们为不同的alpha值绘制这个适配器，我们可以看到参数值如何随着不同的形状而减少，但是它们都遵循指数衰减；这显示了alpha的选择如何影响衰减速度。</p><p id="3e52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本例中，initial_value为0.8，end值为0.2。可以看到，alpha值越大，收敛到接近0.2的值所需的步数/迭代次数就越少。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/d4937d3286a0a06d3a762a5b46bac7b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*56F5mq3KpsAafm2C0u1G8A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">指数衰减。图片由作者提供。</p></figure><p id="e6b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您选择的初始值小于结束值，您将执行指数上升，这在某些情况下很有帮助；例如，在遗传算法中，你可能在第一代开始时有一个低的交叉概率，并随着代的发展而增加。</p><p id="249f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果起点是0.2，一直到0.8，上面的图看起来是这样的:你可以看到衰变的对称性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/d0f1dd81008e37f740e50417ffff4b8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*-dtQE9zK3eNhVSsnYvMQ2Q.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">指数上升。图片由作者提供。</p></figure><h1 id="adaa" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.2反向适配器</h1><p id="405d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">反向适配器使用以下形式来更改初始值:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/bae8760f97e13855fe75cd271654e164.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*YsfcyJYPcHyy9AHXkQWIfg.png"/></div></figure><p id="16a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据这个公式，alpha应该是一个正值，以获得所需的属性。这是适配器的外观:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/7c24c91be15cb481bd86a1997b72e3ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*mCOKm9FUTrS1Vpc5mGhcZA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">逆衰变。图片由作者提供。</p></figure><h1 id="2191" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.3潜在适配器</h1><p id="7580" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">反向适配器使用以下形式来更改初始值:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/bbeb23a3dbdaa8cb2c96b733a49816e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*bo9BM1lrtPdSlIm7zhFs4w.png"/></div></figure><p id="b576" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该公式要求alpha在(0，1)范围内，以获得所需的属性。这是适配器的外观:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/3336e57d9f96b038e8d0ac5632cce25f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*5zQ2Lu_n55vzzr086fxKfw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">潜在衰变。图片由作者提供。</p></figure><h1 id="9e4b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.4比较适配器</h1><p id="bad9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">正如我们所看到的，所有的适配器以不同的速率改变初始参数(这取决于alpha)，所以比较一下它们的行为是有帮助的；这是固定alpha值为0.15时的结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/53749db9779029729a9558806ffaa661.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*jTRD-dDhBT91jnTmoANHqg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">适配器比较。图片由作者提供。</p></figure><p id="1fa6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以看到，潜在的适配器是一个下降更快，紧随其后的是指数；反向适配器可能需要更长次数的迭代才能收敛。</p><p id="da19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是用于这种比较的代码，以防您想使用参数来查看其效果；首先，确保安装软件包[2]:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="464f" class="nu lt iq nq b gy nv nw l nx ny">pip install sklearn-genetic-opt</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h1 id="428b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3.Python示例</h1><p id="fa52" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在本节中，我们希望使用一种算法来自动调整超参数；这种算法通常带有控制优化过程的选项；例如，我将使用遗传算法，通过指数适配器来控制变异和交叉概率；这些与算法的探索与探索策略相关。</p><p id="2b1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以查看<a class="ae kv" rel="noopener" target="_blank" href="/hyperparameters-tuning-from-grid-search-to-optimization-a09853e4e9b8?gi=df7242c6437c">我写的另一篇文章</a>来了解更多关于超参数调整的遗传算法。</p><p id="20ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们导入我们需要的包。我将使用digits数据集[1]并微调一个随机森林模型。</p><p id="00dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>我是示例中使用的包的作者；如果你想进一步了解，投稿或者提出一些建议，可以查看本文末尾的文档和GitHub资源库。</p><p id="b30e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">para_grid参数界定了模型的超参数搜索空间，并定义了数据类型；我们将使用交叉验证准确性来评估模型的超参数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="59ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们定义了优化算法，并创建了自适应交叉和变异概率。我们将从高变异概率和低交叉概率开始；随着代数的增加，交叉和变异概率将分别增加和减少。</p><p id="87e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还将打印和绘制一些统计数据来理解结果。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="e932" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个特定的例子中，我得到了0.941的准确度分数(在测试数据上)，并找到了这些参数:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="e224" class="nu lt iq nq b gy nv nw l nx ny">{‘min_weight_fraction_leaf’: 0.01079845233781555, ‘bootstrap’: True, ‘max_depth’: 10, ‘max_leaf_nodes’: 27, ‘n_estimators’: 108}</span></pre><p id="e054" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以检查搜索空间，它显示了该算法研究了哪些超参数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/f1ad7ff93c53c56479bd9f1e32c26a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UbEALIlfx0ifRQWRLcb-Zw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">带适配器的示例空间。图片由作者提供。</p></figure><p id="f593" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为参考，这是没有自适应学习的采样空间的样子；该算法探索了具有固定低变异概率(0.2)和高交叉概率(0.8)的较少区域。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/5635dcea26c94b14f27ffc171fa0fe1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*77Gw7rUbe4fxdaUWkNeOaQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">没有适配器的采样空间。图片由作者提供。</p></figure><h1 id="3443" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="de2e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当训练机器学习算法时，调整或调度参数可能非常有用；它可以让你更快地收敛算法，或者用动态策略探索复杂的空间区域，即使文献主要将它们用于深度学习，正如我们已经展示的那样，你也可以将它用于传统的机器学习，并调整其思想，将其扩展到任何其他可能适合变化参数策略的问题集。</p><p id="f4d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想了解更多关于sklearn-genetic-opt的信息，你可以查看这里的文档:</p><div class="od oe gp gr of og"><a href="https://sklearn-genetic-opt.readthedocs.io/en/stable/index.html" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">sklearn genetic opt文档</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">Sklearn-genetic-opt使用deap包中的进化算法来选择一组超参数…</h3></div></div><div class="oo l"><div class="op l oq or os oo ot kp og"/></div></div></a></div><h1 id="f9b2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">参考</h1><p id="fd20" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><a class="ae kv" href="https://creativecommons.org/licenses/by/4.0/legalcode" rel="noopener ugc nofollow" target="_blank">知识共享署名4.0国际</a> (CC BY 4.0)许可下的[1]数字数据集:<a class="ae kv" href="https://archive-beta.ics.uci.edu/ml/datasets/optical+recognition+of+handwritten+digits" rel="noopener ugc nofollow" target="_blank">https://archive-beta . ics . UCI . edu/ml/datasets/optical+recognition+of+手写+数字</a></p><p id="60fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[2] sklearn-genetic-opt回购:【https://github.com/rodrigo-arenas/Sklearn-genetic-opt T4】</p></div></div>    
</body>
</html>