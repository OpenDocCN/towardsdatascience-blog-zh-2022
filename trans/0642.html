<html>
<head>
<title>Everything You Need to Know About Ranking with Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于熊猫排名你需要知道的一切</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/everything-you-need-to-know-about-ranking-with-pandas-aa2ab5921c01#2022-02-26">https://towardsdatascience.com/everything-you-need-to-know-about-ranking-with-pandas-aa2ab5921c01#2022-02-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="31c9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">实用指南。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4a7e3695cccb8d9b9c2678f815172993.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lX0acnhsU7D3t-UKlTVH-g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">约书亚·戈尔德在<a class="ae ky" href="https://unsplash.com/s/photos/ranking?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><ul class=""><li id="ba89" class="kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">前 10 个最高分</li><li id="000a" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">基于点击数的前 10 项观察</li><li id="0a8e" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">每个类别中最便宜的 3 件商品</li><li id="b2de" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">每月的前 3 次测量</li><li id="6d1e" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">销售量最高和最低的日子</li></ul><p id="6044" class="pw-post-body-paragraph lw lx it lb b lc ld ju ly le lf jx lz lg ma mb mc li md me mf lk mg mh mi lm im bi translated">以上所有内容都可以通过给数据点(即行)分配一个等级来找到。幸运的是，Pandas 为我们提供了一个执行这些任务的单一函数:rank 函数。</p><p id="9bdd" class="pw-post-body-paragraph lw lx it lb b lc ld ju ly le lf jx lz lg ma mb mc li md me mf lk mg mh mi lm im bi translated">虽然分配等级似乎是一个简单的任务，但在某些情况下，你需要稍微超出默认设置来得到你真正需要的。</p><p id="0643" class="pw-post-body-paragraph lw lx it lb b lc ld ju ly le lf jx lz lg ma mb mc li md me mf lk mg mh mi lm im bi translated">在本文中，我们将通过几个例子来演示您需要了解的关于 rank 函数的所有内容以及如何正确使用它。</p><p id="516e" class="pw-post-body-paragraph lw lx it lb b lc ld ju ly le lf jx lz lg ma mb mc li md me mf lk mg mh mi lm im bi translated">让我们从导入 Pandas 和创建一个示例数据框架开始。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="5099" class="mo mp it mk b gy mq mr l ms mt">import pandas as pd</span><span id="83a1" class="mo mp it mk b gy mu mr l ms mt">df = pd.DataFrame({<br/>    "name": ["John","Jane","Emily","Lisa","Matt","Jenny","Adam"],<br/>    "current": [92,94,87,82,90,78,84],<br/>    "overall": [184,173,184,201,208,182,185],<br/>    "group":["A","B","C","A","A","C","B"]<br/>})</span><span id="696a" class="mo mp it mk b gy mu mr l ms mt">df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/e6b3a11c8aa77fdda347a4e01615c8a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*zvSmBxQy7xBm6nt-hv7Y7Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">df(作者图片)</p></figure><p id="5a15" class="pw-post-body-paragraph lw lx it lb b lc ld ju ly le lf jx lz lg ma mb mc li md me mf lk mg mh mi lm im bi translated">我们创建了一个 7 行 4 列的数据帧。让我们从默认设置开始，根据整个列为行分配一个等级。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="f90f" class="mo mp it mk b gy mq mr l ms mt">df["rank_default"] = df["overall"].rank()</span><span id="a8ed" class="mo mp it mk b gy mu mr l ms mt">df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/9985c8e3e4268c36a187a1e35b52b665.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*2buL0OcdhHr9B7TCpJFYvw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">df(作者图片)</p></figure><p id="f752" class="pw-post-body-paragraph lw lx it lb b lc ld ju ly le lf jx lz lg ma mb mc li md me mf lk mg mh mi lm im bi translated">等级默认列包含等级值。关于默认设置，有两点很重要:</p><ul class=""><li id="a286" class="kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">顺序是升序的，因此最低的值被指定为第一个等级。在我们的例子中，Jane 的总分最低，因此排名第一。</li><li id="a9fe" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">在相等的情况下，通过取平均值来确定排名。例如，John 和 Emily 的总分都是倒数第三。因为两个人得分相同，所以他们被分配的等级为 3.5，这是 3 和 4 的平均值。下一个最低分是 185，排名第 5。</li></ul><p id="d3ed" class="pw-post-body-paragraph lw lx it lb b lc ld ju ly le lf jx lz lg ma mb mc li md me mf lk mg mh mi lm im bi translated">这些是默认设置。让我们改变顺序，按降序排列，这样分数最高的人排在第一位。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="4625" class="mo mp it mk b gy mq mr l ms mt">df["rank_default_desc"] = df["overall"].rank(ascending=False)<br/>df = df.sort_values(by="rank_default_desc", ignore_index=True)</span><span id="4a10" class="mo mp it mk b gy mu mr l ms mt">df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/97230e1084ba6189858ff24035421e94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7jiZQGOccsBvuzl6oLZ2gA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">df(作者图片)</p></figure><p id="e3b8" class="pw-post-body-paragraph lw lx it lb b lc ld ju ly le lf jx lz lg ma mb mc li md me mf lk mg mh mi lm im bi translated">我们还使用 sort_values 函数根据“rank_default_desc”列对行进行了排序。这样更容易跟踪和比较这些值。</p><p id="50ee" class="pw-post-body-paragraph lw lx it lb b lc ld ju ly le lf jx lz lg ma mb mc li md me mf lk mg mh mi lm im bi translated">Matt 的总得分最高，因此按降序排列时，他排名第一。John 和 Emily 现在是第 4 和第 5 个人，所以他们被指定为 4.5 级，因为我们仍然在平等的情况下使用平均方法。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="24cf" class="nf mp it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">不同的排名方法</h1><p id="bf67" class="pw-post-body-paragraph lw lx it lb b lc nw ju ly le nx jx lz lg ny mb mc li nz me mf lk oa mh mi lm im bi translated">在相等的情况下，rank 函数有 5 个不同的选项。这个选项是用 method 参数选择的，默认值是“average ”,正如我们在前面的例子中看到的。</p><p id="5777" class="pw-post-body-paragraph lw lx it lb b lc ld ju ly le lf jx lz lg ma mb mc li md me mf lk mg mh mi lm im bi translated">其他选项包括“最小”、“最大”、“第一”和“密集”。让我们首先将最小值和最大值与平均值进行比较。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="e00f" class="mo mp it mk b gy mq mr l ms mt"># create DataFrame<br/>df = pd.DataFrame({<br/>    "name": ["John","Jane","Emily","Lisa","Matt","Jenny","Adam"],<br/>    "current": [92,94,87,82,90,78,84],<br/>    "overall": [184,173,184,201,208,182,185],<br/>    "group":["A","B","C","A","A","C","B"]<br/>})</span><span id="cedd" class="mo mp it mk b gy mu mr l ms mt"># create rank columns<br/>df["rank_default"] = df["overall"].rank(ascending=False)<br/>df["rank_min"] = df["overall"].rank(method="min", ascending=False)<br/>df["rank_max"] = df["overall"].rank(method="max", ascending=False)</span><span id="0369" class="mo mp it mk b gy mu mr l ms mt"># sort rows<br/>df = df.sort_values(by="rank_default", ignore_index=True)</span><span id="91ef" class="mo mp it mk b gy mu mr l ms mt">df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/7949f4239052414500404092065cd2e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p6TJjL1J0AwagRNa3hPAjA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">df(作者图片)</p></figure><p id="67a7" class="pw-post-body-paragraph lw lx it lb b lc ld ju ly le lf jx lz lg ma mb mc li md me mf lk mg mh mi lm im bi translated">当两行或更多行具有相同的值时，可以观察到差异。约翰和艾米丽是第四和第五个人。</p><ul class=""><li id="e894" class="kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">method = "average "给出的平均值为 4.5</li><li id="e5d3" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">method = "min "给出的最低值是 4。</li><li id="3dd9" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">method = "max "给出的最高值为 5。</li></ul><p id="ffd5" class="pw-post-body-paragraph lw lx it lb b lc ld ju ly le lf jx lz lg ma mb mc li md me mf lk mg mh mi lm im bi translated">您可能已经注意到，在创建“rank_default”列时，我们没有编写方法参数。因为它是默认值，所以我们不需要指定它，但是如果您按如下方式编写它，它也是有效的:</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="d3e7" class="mo mp it mk b gy mq mr l ms mt">df["rank_default"] = df["overall"].rank(method="average", ascending=False)</span></pre></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><p id="6ddd" class="pw-post-body-paragraph lw lx it lb b lc ld ju ly le lf jx lz lg ma mb mc li md me mf lk mg mh mi lm im bi translated">方法参数的另外两个选项是“第一”和“密集”。让我们将它们添加到当前的数据框架中，然后解释它们的作用。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="3d77" class="mo mp it mk b gy mq mr l ms mt">df["rank_first"] = df["overall"].rank(method="first", ascending=False)</span><span id="e183" class="mo mp it mk b gy mu mr l ms mt">df["rank_dense"] = df["overall"].rank(method="dense", ascending=False)</span><span id="9c3f" class="mo mp it mk b gy mu mr l ms mt">df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/bdb9707ff3185c1478f121b2e74a9d99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cu94VwKcefODY-uzNPsLZA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">df(作者图片)</p></figure><ul class=""><li id="0465" class="kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">“第一”方法根据等级出现的顺序来分配等级。在相等的情况下，数据帧中的第一个观察值取下一个值，第二个观察值取下一个值，依此类推。在我们的例子中，John 和 Emily 是第 4 和第 5 个人，所以 John 的等级是 4，Emily 的等级是 5。</li><li id="f3ae" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">“dense”方法类似于“min ”,但它不会在具有相同值的行和下一行之间留下任何间隙。John 和 Emily 的等级为 4，因为他们使用“min ”,但是下一个人的等级不同。Jenny 在“最小”方法中排名第 6，但在“密集”方法中排名第 5。</li></ul></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="7092" class="nf mp it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">基于多列的排名</h1><p id="2e24" class="pw-post-body-paragraph lw lx it lb b lc nw ju ly le nx jx lz lg ny mb mc li nz me mf lk oa mh mi lm im bi translated">在某些情况下，我们基于多个列创建一个等级。例如，在我们的 DataFrame 中，我们可能希望同时使用 total 和 current 列中的值来分配等级。</p><p id="89ad" class="pw-post-body-paragraph lw lx it lb b lc ld ju ly le lf jx lz lg ma mb mc li md me mf lk mg mh mi lm im bi translated">我们可以通过从这两列创建一个元组并使用它进行排序来做到这一点。</p><p id="7cab" class="pw-post-body-paragraph lw lx it lb b lc ld ju ly le lf jx lz lg ma mb mc li md me mf lk mg mh mi lm im bi translated">我们可以通过对每行应用元组函数来创建元组，如下所示:</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="7280" class="mo mp it mk b gy mq mr l ms mt">df[["overall","current"]].apply(tuple, axis=1)</span><span id="0cab" class="mo mp it mk b gy mu mr l ms mt"><strong class="mk iu"># Output</strong><br/>0    (208, 90)<br/>1    (201, 82)<br/>2    (185, 84)<br/>3    (184, 92)<br/>4    (184, 87)<br/>5    (182, 78)<br/>6    (173, 94)<br/>dtype: object</span></pre><p id="6431" class="pw-post-body-paragraph lw lx it lb b lc ld ju ly le lf jx lz lg ma mb mc li md me mf lk mg mh mi lm im bi translated">我们用它来排名吧。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="4102" class="mo mp it mk b gy mq mr l ms mt"># create DataFrame<br/>df = pd.DataFrame({<br/>    "name": ["John","Jane","Emily","Lisa","Matt","Jenny","Adam"],<br/>    "current": [92,94,87,82,90,78,84],<br/>    "overall": [184,173,184,201,208,182,185],<br/>    "group":["A","B","C","A","A","C","B"]<br/>})</span><span id="ba24" class="mo mp it mk b gy mu mr l ms mt"># create rank column<br/>df["rank_overall_current"] = df[["overall","current"]].apply(<br/>    tuple, axis=1<br/>).rank(ascending=False)</span><span id="8bee" class="mo mp it mk b gy mu mr l ms mt"># sort values<br/>df = df.sort_values(by="rank_overall_current", ignore_index=True)</span><span id="30ef" class="mo mp it mk b gy mu mr l ms mt">df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/955b87ca80feda82d8e1d7bb40895953.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5y5KnTaHVpPK4R5m8q6SSQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">df(作者图片)</p></figure><p id="b2f8" class="pw-post-body-paragraph lw lx it lb b lc ld ju ly le lf jx lz lg ma mb mc li md me mf lk mg mh mi lm im bi translated">等级是基于总体和等级的组合创建的。因为总列中的值最先出现，所以首先检查它们。如果总值相等，则考虑当前值。</p><p id="77a4" class="pw-post-body-paragraph lw lx it lb b lc ld ju ly le lf jx lz lg ma mb mc li md me mf lk mg mh mi lm im bi translated">例如，John 和 Emily 具有相同的总价值，但 John 的当前价值更高，因此他的排名在 Emily 之前。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="6293" class="nf mp it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">组内排名</h1><p id="f133" class="pw-post-body-paragraph lw lx it lb b lc nw ju ly le nx jx lz lg ny mb mc li nz me mf lk oa mh mi lm im bi translated">我们可能还需要为不同的组分配不同的等级。我创建了 group 列来演示这个案例。</p><p id="5fef" class="pw-post-body-paragraph lw lx it lb b lc ld ju ly le lf jx lz lg ma mb mc li md me mf lk mg mh mi lm im bi translated">我们只是需要“groupby”函数的一些帮助，该函数用于根据给定列中的不同值对行进行分组。</p><p id="4f09" class="pw-post-body-paragraph lw lx it lb b lc ld ju ly le lf jx lz lg ma mb mc li md me mf lk mg mh mi lm im bi translated">如果我们按组列对数据帧中的行进行分组，我们最终会将列中的不同值分为不同的组，即 A、B 和 c。然后，我们选择用于排名的列，然后应用 rank 函数。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="e2c9" class="mo mp it mk b gy mq mr l ms mt"># create DataFrame<br/>df = pd.DataFrame({<br/>    "name": ["John","Jane","Emily","Lisa","Matt","Jenny","Adam"],<br/>    "current": [92,94,87,82,90,78,84],<br/>    "overall": [184,173,184,201,208,182,185],<br/>    "group":["A","B","C","A","A","C","B"]<br/>})</span><span id="bbda" class="mo mp it mk b gy mu mr l ms mt"># create rank column<br/>df["group_rank"] = df.groupby("group")["overall"].rank(<br/>ascending=False)</span><span id="d21b" class="mo mp it mk b gy mu mr l ms mt"># sort values<br/>df = df.sort_values(by=["group","group_rank"], ignore_index=True)</span><span id="0140" class="mo mp it mk b gy mu mr l ms mt">df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/9853b9f6cb071e2e467ac09f4738cc91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*-I9WI8m3QBaRaixxEFC_2A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">df(作者图片)</p></figure><p id="f041" class="pw-post-body-paragraph lw lx it lb b lc ld ju ly le lf jx lz lg ma mb mc li md me mf lk mg mh mi lm im bi translated">我们现在在每个组中都有一个单独的等级。我们可以改变秩函数的方法。它将像我们迄今为止所做的例子一样工作。唯一不同的是，每一组都将单独完成。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><p id="44eb" class="pw-post-body-paragraph lw lx it lb b lc ld ju ly le lf jx lz lg ma mb mc li md me mf lk mg mh mi lm im bi translated">我们已经做了几个例子来演示 rank 函数是如何使用的以及它的参数是什么意思。</p><p id="e69b" class="pw-post-body-paragraph lw lx it lb b lc ld ju ly le lf jx lz lg ma mb mc li md me mf lk mg mh mi lm im bi translated"><em class="of">你可以成为</em> <a class="ae ky" href="https://sonery.medium.com/membership" rel="noopener"> <em class="of">媒介会员</em> </a> <em class="of">解锁我的全部写作权限，外加其余媒介。如果你已经是了，别忘了订阅</em><a class="ae ky" href="https://sonery.medium.com/subscribe" rel="noopener"><em class="of"/></a><em class="of">如果你想在我发表新文章时收到电子邮件。</em></p><div class="og oh gp gr oi oj"><a href="https://sonery.medium.com/membership" rel="noopener follow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">通过我的推荐链接加入 Medium-Soner yl DRM</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">sonery.medium.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox ks oj"/></div></div></a></div><p id="5ab7" class="pw-post-body-paragraph lw lx it lb b lc ld ju ly le lf jx lz lg ma mb mc li md me mf lk mg mh mi lm im bi translated">感谢您的阅读。如果您有任何反馈，请告诉我。</p></div></div>    
</body>
</html>