<html>
<head>
<title>Are you still making these Python mistakes in 2022?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2022年你还在犯这些Python错误吗？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/are-you-still-making-these-python-mistakes-in-2022-2414af2375b0#2022-08-10">https://towardsdatascience.com/are-you-still-making-these-python-mistakes-in-2022-2414af2375b0#2022-08-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/a571d33174972c96883b694ba19d86be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pei0SsO547CtxnNWtQozOQ.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">照片由<a class="ae jd" href="https://unsplash.com/@nadineshaabana?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">纳丁·沙巴纳</a>在<a class="ae jd" href="https://unsplash.com/s/photos/stop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><div class=""/><div class=""><h2 id="c99e" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">成为更好的程序员需要改正的6个Python错误</h2></div></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><p id="98ac" class="pw-post-body-paragraph lc ld jg le b lf lg kh lh li lj kk lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">不可否认，Python可能是最容易学习和使用的语言之一。它是一种高级的、多用途的编程语言。这使得它非常受欢迎，并且在最近几年有了很大的发展，尤其是随着数据科学的出现。</p><p id="34b8" class="pw-post-body-paragraph lc ld jg le b lf lg kh lh li lj kk lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">然而，不管一门语言多么容易使用，要写出好的代码仍然需要时间和练习。编写可工作的代码和优秀的代码是有区别的，我想强调几个可能让你成为更好的程序员的实践。</p><p id="06cc" class="pw-post-body-paragraph lc ld jg le b lf lg kh lh li lj kk lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在我写Python代码的5年多时间里，我不断学习新的东西和实践，随着时间的推移，这使我成为一名更好的程序员。我从很多错误中吸取了教训，我想在这里分享其中的一些，我希望我能早点改正。这些错误不会导致语法错误，但最终会导致逻辑错误或糟糕的代码。我不回避承认我对过去的每一个错误都是有罪的，我的旧代码就是一个证明，但是一个人必须尽快了解这些事情。那么，开始吧！</p></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h2 id="27b7" class="ly lz jg bd ma mb mc dn md me mf dp mg ll mh mi mj lp mk ml mm lt mn mo mp mq bi translated">1.使用导入*</h2><p id="27b8" class="pw-post-body-paragraph lc ld jg le b lf mr kh lh li ms kk lk ll mt ln lo lp mu lr ls lt mv lv lw lx ij bi translated">您刚刚开始了一个数据科学项目，并且非常希望在项目中应用所有新的Python技巧和工具。对于您的模型准确性，您编写<strong class="le jh"> </strong> <code class="fe mw mx my mz b"><strong class="le jh">from sklearn.metrics import *</strong></code>来表示该库提供的所有很酷的评估指标。你刚刚犯了第一个错误！</p><p id="0140" class="pw-post-body-paragraph lc ld jg le b lf lg kh lh li lj kk lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">这可能是我看到的Python程序员犯的最常见的错误，它可以告诉我是一个编写代码的新手还是有经验的人。虽然这看起来很方便，但是这样做是一种非常糟糕的做法，原因是:</p><ul class=""><li id="5a82" class="na nb jg le b lf lg li lj ll nc lp nd lt ne lx nf ng nh ni bi translated">您正在污染您的名称空间，因为它将所有内容从模块导入到名称空间。这会占用内存，并可能导致您没有意识到的覆盖。因此，您自己的命名空间中的函数和类可能会与您定义的或来自其他库中的函数和类冲突，从而导致不可预见的逻辑错误。</li><li id="9dc7" class="na nb jg le b lf nj li nk ll nl lp nm lt nn lx nf ng nh ni bi translated">这会影响代码的可读性，因为现在代码中的某些函数和变量无法追溯到它们的来源。这意味着你代码中的随机<code class="fe mw mx my mz b">sqrt()</code>函数可能来自<code class="fe mw mx my mz b">numpy</code>、<code class="fe mw mx my mz b">math</code>，甚至是你不知道的自定义函数。这也增加了调试的难度。</li></ul><p id="aec2" class="pw-post-body-paragraph lc ld jg le b lf lg kh lh li lj kk lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><strong class="le jh">解决方案— </strong>确保您总是指定从哪里导入什么。下面是一个例子。</p><pre class="no np nq nr gt ns mz nt nu aw nv bi"><span id="0cc1" class="ly lz jg mz b gy nw nx l ny nz"><strong class="mz jh">import secrets<br/>import string<br/>import re<br/>from wsgiref.util import request_uri <br/>from http.client import responses<br/>from rest_framework import viewsets, status<br/>from rest_framework.response import Response<br/>from rest_framework.permissions import AllowAny, IsAuthenticated<br/>from rest_framework.decorators import permission_classes</strong></span></pre><p id="1b2a" class="pw-post-body-paragraph lc ld jg le b lf lg kh lh li lj kk lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><strong class="le jh"> 2。使用pip冻结存储需求</strong></p><p id="6f16" class="pw-post-body-paragraph lc ld jg le b lf lg kh lh li lj kk lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><code class="fe mw mx my mz b">pip freeze</code>是python中最流行的需求管理命令之一。它通常用于将项目的需求存储到文本文件中。许多初级Python程序员使用它来管理他们的虚拟环境。然而，它带来了一系列的问题，包括循环依赖和版本控制。</p><p id="ebb4" class="pw-post-body-paragraph lc ld jg le b lf lg kh lh li lj kk lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">我写了一篇关于使用<code class="fe mw mx my mz b">pip freeze</code>的问题和你可以使用的可能解决方案的非常详细的文章。</p><div class="ip iq gp gr ir oa"><a rel="noopener follow" target="_blank" href="/stop-using-pip-freeze-for-your-python-projects-9c37181730f9"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd jh gy z fp of fr fs og fu fw jf bi translated">停止对你的Python项目使用“pip冻结”</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">讨论为什么“pip冻结”在管理Python依赖项时不那么酷</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">towardsdatascience.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo ix oa"/></div></div></a></div><p id="2e40" class="pw-post-body-paragraph lc ld jg le b lf lg kh lh li lj kk lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">我个人的建议是这一期改用<code class="fe mw mx my mz b"><a class="ae jd" href="https://pypi.org/project/pipreqs/" rel="noopener ugc nofollow" target="_blank">pipreqs</a></code>。</p><h2 id="30aa" class="ly lz jg bd ma mb mc dn md me mf dp mg ll mh mi mj lp mk ml mm lt mn mo mp mq bi translated">3.不使用Main编写Python脚本</h2><p id="61bb" class="pw-post-body-paragraph lc ld jg le b lf mr kh lh li ms kk lk ll mt ln lo lp mu lr ls lt mv lv lw lx ij bi translated">由于Python是一种脚本语言，你可以在<em class="op">读取-评估-打印循环(REPL) </em>模式下编写和执行它。例如:</p><pre class="no np nq nr gt ns mz nt nu aw nv bi"><span id="6c10" class="ly lz jg mz b gy nw nx l ny nz"><strong class="mz jh"># test_function.py</strong></span><span id="fa74" class="ly lz jg mz b gy oq nx l ny nz"><strong class="mz jh">def function1(): <br/>    print("Hello world") <br/>function1()</strong></span></pre><p id="a85e" class="pw-post-body-paragraph lc ld jg le b lf lg kh lh li lj kk lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">这段代码将在使用<code class="fe mw mx my mz b">python test_function.py</code>命令从CLI调用时执行该函数。然而，现在如果你想在一个不同的文件中导入相同的函数作为一个模块，比如说一个<code class="fe mw mx my mz b">jupyter notebook</code>，这就是将要发生的事情。</p><figure class="no np nq nr gt is gh gi paragraph-image"><div class="gh gi or"><img src="../Images/fe8a0d81a8cf79d8607d88eee0f1db42.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*JokYH7yAP66OmmXu5KbF9Q.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">导入没有主函数的模块(图片由作者提供)</p></figure><p id="bcf2" class="pw-post-body-paragraph lc ld jg le b lf lg kh lh li lj kk lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">基本上，函数内部的代码是在函数导入时自动运行的。在上面描述的简单函数的情况下，这可能是可以的，但是如果代码包含计算开销很大的任务，那么代码甚至会在导入时继续运行。这就是为什么编写<code class="fe mw mx my mz b">__main__</code>对Python脚本很重要。</p><pre class="no np nq nr gt ns mz nt nu aw nv bi"><span id="a6ee" class="ly lz jg mz b gy nw nx l ny nz"><strong class="mz jh"># test_function.py</strong></span><span id="68e8" class="ly lz jg mz b gy oq nx l ny nz"><strong class="mz jh">def function1(): <br/>    print("Hello world") <br/>function1()</strong></span><span id="a1d5" class="ly lz jg mz b gy oq nx l ny nz"><br/><strong class="mz jh"># Define the __main__ script<br/>if __name__ == '__main__': <br/>    <br/>    # execute only if run as a script<br/>    function1()</strong></span></pre><p id="a2ac" class="pw-post-body-paragraph lc ld jg le b lf lg kh lh li lj kk lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">上面的代码确保了与CLI相同的功能，但不会作为模块在导入时运行，除非专门运行。(如下图所示)</p><figure class="no np nq nr gt is gh gi paragraph-image"><div class="gh gi os"><img src="../Images/d84b344c074e58ff535d2482fda90d01.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*nMCLE645qz1tJ2AOYhdPtQ.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">函数作为脚本运行(图片由作者提供)</p></figure><h2 id="97be" class="ly lz jg bd ma mb mc dn md me mf dp mg ll mh mi mj lp mk ml mm lt mn mo mp mq bi translated">4.使用<code class="fe mw mx my mz b">assert</code>语句作为保护条件</h2><p id="7563" class="pw-post-body-paragraph lc ld jg le b lf mr kh lh li ms kk lk ll mt ln lo lp mu lr ls lt mv lv lw lx ij bi translated"><code class="fe mw mx my mz b">assert</code>关键字是检查条件和失败执行最流行的方法之一。它对于调试代码非常有用，因为它允许您测试代码中的条件是否返回True，如果不是，程序将引发AssertionError。</p><p id="087c" class="pw-post-body-paragraph lc ld jg le b lf lg kh lh li lj kk lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">然而，有一个很大的警告——当使用<code class="fe mw mx my mz b">-O</code> (optimize)标志调用Python解释器时，会从字节码中删除<code class="fe mw mx my mz b">assert</code>语句。因此，如果<code class="fe mw mx my mz b">assert</code>语句用于产品代码中的验证，那么它们根本不会被执行。这可能导致很大范围的逻辑错误和安全漏洞。因此，我们应该只在测试中使用<code class="fe mw mx my mz b">assert </code>语句。在生产中，我们可以改用<code class="fe mw mx my mz b">AssertionError.</code></p><pre class="no np nq nr gt ns mz nt nu aw nv bi"><span id="3117" class="ly lz jg mz b gy nw nx l ny nz"><strong class="mz jh">Incorrect: </strong>assert <em class="op">condition, message</em> </span><span id="6ba0" class="ly lz jg mz b gy oq nx l ny nz"><strong class="mz jh">Correct method: </strong><br/>if not <em class="op">condition</em>: <br/>    raise AssertionError</span></pre><h2 id="7d57" class="ly lz jg bd ma mb mc dn md me mf dp mg ll mh mi mj lp mk ml mm lt mn mo mp mq bi translated">5.使用<code class="fe mw mx my mz b"><em class="ot">isinstance()</em></code>和<code class="fe mw mx my mz b">type() correctly</code></h2><p id="3d8c" class="pw-post-body-paragraph lc ld jg le b lf mr kh lh li ms kk lk ll mt ln lo lp mu lr ls lt mv lv lw lx ij bi translated">在我们的Python代码中，有很多地方需要检查数据类型或对象的类。这方面的常用方法是<code class="fe mw mx my mz b">type()</code>和<code class="fe mw mx my mz b">isinstance()</code>。这两者都被广泛使用，确保我们理解在哪里使用什么以及注意事项是很重要的。</p><p id="e599" class="pw-post-body-paragraph lc ld jg le b lf lg kh lh li lj kk lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">这两种方法都可以用来检查Python中对象的类型。然而，他们检查的内容有很大的不同。<code class="fe mw mx my mz b">isinstance</code>也检查继承，而<code class="fe mw mx my mz b">type</code>不检查。这在您检查派生类时变得很重要。看看下面的例子:</p><figure class="no np nq nr gt is gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/75aa4a2ee8ed38198562ceadcdae1e26.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*w3fZnEtwgj3WOSDwvWwwzg.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">类型与实例(图片由作者提供)</p></figure><p id="071a" class="pw-post-body-paragraph lc ld jg le b lf lg kh lh li lj kk lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在上面的例子中，当我们使用<code class="fe mw mx my mz b">type</code>时，<code class="fe mw mx my mz b">int</code>和<code class="fe mw mx my mz b">bool</code>被视为不同的数据类型，但当我们使用<code class="fe mw mx my mz b">isinstance</code>时，它们被视为相同，因为<code class="fe mw mx my mz b">bool</code>实际上是从Python中的<code class="fe mw mx my mz b">int</code>继承而来的。</p><p id="2433" class="pw-post-body-paragraph lc ld jg le b lf lg kh lh li lj kk lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">因此，理解您正在测试/检查什么并相应地使用正确的类型检查器是很重要的。你可以在这里阅读更多关于这两种方法的区别<a class="ae jd" href="https://switowski.com/blog/type-vs-isinstance" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="8d90" class="ly lz jg bd ma mb mc dn md me mf dp mg ll mh mi mj lp mk ml mm lt mn mo mp mq bi translated">6.<strong class="ak">错误地使用函数默认参数</strong></h2><p id="fde6" class="pw-post-body-paragraph lc ld jg le b lf mr kh lh li ms kk lk ll mt ln lo lp mu lr ls lt mv lv lw lx ij bi translated">一个常见的误解(最近我也消除了)是，每次调用函数时，传递给函数的默认参数将被重置为指定的默认值。看看这个例子。</p><pre class="no np nq nr gt ns mz nt nu aw nv bi"><span id="4cd0" class="ly lz jg mz b gy nw nx l ny nz"><strong class="mz jh">def func(list1=[]):      # here l1 is a default argument set to []<br/>    list1.append("Temp") <br/>    return list1</strong></span></pre><p id="e4d2" class="pw-post-body-paragraph lc ld jg le b lf lg kh lh li lj kk lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">让我们看看多次调用<code class="fe mw mx my mz b">func</code>会发生什么。</p><figure class="no np nq nr gt is gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/04832adfb31c960e9e83d3ee0394109f.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*QRnBnpzaODvWV5Vw_MvpkA.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">多次调用该函数时的输出。(图片由作者提供)</p></figure><p id="d092" class="pw-post-body-paragraph lc ld jg le b lf lg kh lh li lj kk lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">上述结果可能会让你感到震惊，但这是一个非常合乎逻辑的结果。<strong class="le jh">在python中，一个函数的默认值只在函数被定义时评估一次</strong>。函数调用的每个其他实例将使用默认参数的原始定义。因此，<code class="fe mw mx my mz b">list1</code>首先被评估为<code class="fe mw mx my mz b">[]</code>,然后每次对原始列表进行追加操作。</p><p id="ded6" class="pw-post-body-paragraph lc ld jg le b lf lg kh lh li lj kk lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">可变数据类型会遇到这个问题，解决这个问题的方法是使用<code class="fe mw mx my mz b">none </code>语句，并对函数中的列表求值，如下所示。</p><pre class="no np nq nr gt ns mz nt nu aw nv bi"><span id="63d4" class="ly lz jg mz b gy nw nx l ny nz"><strong class="mz jh">def func(l1=None):      <br/>    if l1 is None: <br/>        l1 = []<br/>    l1.append("Temp") <br/>    return l1</strong></span></pre><figure class="no np nq nr gt is gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/653e2886fbc2d5d6707e4b16ac7d9b56.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*5uxa0lnLIPo1RnQyMtB6ww.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">带有新函数定义的输出(图片由作者提供)</p></figure></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="28ad" class="ox lz jg bd ma oy oz pa md pb pc pd mg km pe kn mj kp pf kq mm ks pg kt mp ph bi translated">结论</h1><p id="e679" class="pw-post-body-paragraph lc ld jg le b lf mr kh lh li ms kk lk ll mt ln lo lp mu lr ls lt mv lv lw lx ij bi translated">这些是我遇到的一些错误，我想与你分享。希望其中一些对你来说是有见地的和新的。如果你认为我错过了一些重要的东西，请随意分享，这样我和我的读者可以从中学习。</p><p id="3a3c" class="pw-post-body-paragraph lc ld jg le b lf lg kh lh li lj kk lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">你也可以看看我写的其他东西。</p><div class="ip iq gp gr ir oa"><a rel="noopener follow" target="_blank" href="/7-must-read-books-for-data-scientists-in-2022-aa87c0f9bffb"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd jh gy z fp of fr fs og fu fw jf bi translated">2022年数据科学家必读的7本书</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">帮助你成为更好的数据科学家的技术和非技术书籍</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">towardsdatascience.com</p></div></div><div class="oj l"><div class="pi l ol om on oj oo ix oa"/></div></div></a></div><div class="ip iq gp gr ir oa"><a href="https://levelup.gitconnected.com/5-new-features-in-python-3-11-that-makes-it-the-coolest-new-release-in-2022-c9df658ef813" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd jh gy z fp of fr fs og fu fw jf bi translated">Python 3.11中的5个新特性使其成为2022年最酷的新版本</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">讨论Python 3.11中的新特性和更新，以及如何安装3.11 Alpha版本</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oj l"><div class="pj l ol om on oj oo ix oa"/></div></div></a></div><div class="ip iq gp gr ir oa"><a rel="noopener follow" target="_blank" href="/a-novel-approach-to-feature-importance-shapley-additive-explanations-d18af30fc21b"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd jh gy z fp of fr fs og fu fw jf bi translated">特征重要性的一种新方法——Shapley附加解释</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">最先进的功能重要性</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">towardsdatascience.com</p></div></div><div class="oj l"><div class="pk l ol om on oj oo ix oa"/></div></div></a></div></div></div>    
</body>
</html>