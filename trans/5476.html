<html>
<head>
<title>What If .apply() Is Too Slow?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如果……apply()太慢？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/what-if-apply-is-too-slow-a9f89b4d73e8#2022-12-08">https://towardsdatascience.com/what-if-apply-is-too-slow-a9f89b4d73e8#2022-12-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0350" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有时我们需要在 Python 中通过使用 Pandas 数据帧的列作为函数的输入，对 Pandas 数据帧应用一些函数。不过，用的最多的方法<strong class="ak"> <em class="ki">。对整个数据帧应用()</em> </strong>可能会比预期花费更长的时间。我们做什么呢</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/c68229af88974a66cebbcd5892ed6bbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e23wecncwhEADkr7"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@chrisliverani?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯·利维拉尼</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="06d2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi lw translated">如果您正在使用 Python 处理数据，Pandas 一定是您使用最多的库之一，因为它具有方便和强大的数据处理特性。</p><p id="7fcf" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果我们想对 Pandas 数据框中一整列的值应用相同的函数，我们可以简单地使用。应用()。Pandas 数据框和 Pandas 系列(数据框中的一列)都可以与一起使用。应用()。</p><p id="b843" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">但是你有没有注意到？当我们有一个超级大的数据集时，apply()会非常慢？</p><p id="15a3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在本文中，我将讨论当您想要对列应用一些函数时，加速数据操作的技巧。</p><h2 id="c041" class="mf mg it bd mh mi mj dn mk ml mm dp mn lj mo mp mq ln mr ms mt lr mu mv mw mx bi translated">对单个列应用函数</h2><p id="045d" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">例如，这是我们的玩具数据集。</p><pre class="kk kl km kn gt nd ne nf bn ng nh bi"><span id="08a4" class="ni mg it ne b be nj nk l nl nm">import pandas as pd<br/>import numpy as np<br/>import timeit<br/><br/>d = {'category': ['apple', 'pear', 'peach'], 'radius': [3, 4, 2], 'sweetness': [1, 2, 3]}<br/>df = pd.DataFrame(data=d)<br/>df</span></pre><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="43df" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果我们希望根据半径列中的值向数据框中再添加一列“直径”，其中基本上直径=半径* 2，我们可以继续使用。在此应用()。</p><pre class="kk kl km kn gt nd ne nf bn ng nh bi"><span id="1363" class="ni mg it ne b be nj nk l nl nm">df['diameter'] = df['radius'].apply(lambda x: x*2)<br/>df</span></pre><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="7085" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">然后，我们计算执行命令行 10k 次的时间，</p><pre class="kk kl km kn gt nd ne nf bn ng nh bi"><span id="8f42" class="ni mg it ne b be nj nk l nl nm"># Timing<br/>setup_code = """<br/>import pandas as pd<br/>d = {'category': ['apple', 'pear', 'peach'], 'radius': [3, 4, 2], 'sweetness': [1, 2, 3]}<br/>df = pd.DataFrame(data=d)<br/>"""<br/><br/>mycode = '''<br/>df['radius'].apply(lambda x: x*2)<br/>'''<br/> <br/># timeit statement<br/>t1 = timeit.timeit(setup=setup_code,<br/>                     stmt = mycode,<br/>                     number = 10000)<br/>print(f"10000 runs of mycode is {t1}")</span></pre><p id="05e6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">产生 0.55 秒。还不错，嗯..？但请记住，这只是一个 3 行的玩具数据。如果我们有几百万行呢？</p><p id="e1b6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">你可能已经注意到我们不需要使用。apply()在这里，您可以简单地执行以下操作，</p><pre class="kk kl km kn gt nd ne nf bn ng nh bi"><span id="e4a8" class="ni mg it ne b be nj nk l nl nm">df['diameter'] = df['radius']*2<br/>df</span></pre><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="7698" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们可以看到输出与使用。应用()。如果我们计算 10k 运行的执行时间，</p><pre class="kk kl km kn gt nd ne nf bn ng nh bi"><span id="1663" class="ni mg it ne b be nj nk l nl nm"># Timing<br/>setup_code = """<br/>import pandas as pd<br/>d = {'category': ['apple', 'pear', 'peach'], 'radius': [3, 4, 2], 'sweetness': [1, 2, 3]}<br/>df = pd.DataFrame(data=d)<br/>"""<br/><br/>mycode = '''<br/>df['radius']*2<br/>'''<br/> <br/># timeit statement<br/>t1 = timeit.timeit(setup=setup_code,<br/>                     stmt = mycode,<br/>                     number = 10000)<br/>print(f"10000 runs of mycode is {t1}")</span></pre><p id="e454" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">总共给了我们 0.32 秒，比。apply()函数。</p><p id="06f6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">注意，我们可以简单地避免使用。这里只使用 apply()，因为我们使用一个非常简单的函数来计算一个乘以 2 的值。但是在大多数情况下，我们需要对列应用一个更复杂的函数。</p><p id="634b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">例如，我们希望为每个观测值在半径和常数(比如 3)之间添加一个较大值的列。如果你简单地做以下事情，</p><pre class="kk kl km kn gt nd ne nf bn ng nh bi"><span id="18ef" class="ni mg it ne b be nj nk l nl nm">max(df['radius'],3)</span></pre><p id="27cc" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">它将生成下面的错误消息，</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="dfa6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">因此，我们需要在 apply()函数中编写比较代码。</p><pre class="kk kl km kn gt nd ne nf bn ng nh bi"><span id="0fef" class="ni mg it ne b be nj nk l nl nm">df['radius_or_3'] = df['radius'].apply(lambda x: max(x,3))<br/>df</span></pre><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="24cc" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们计算一下执行时间，</p><pre class="kk kl km kn gt nd ne nf bn ng nh bi"><span id="6b05" class="ni mg it ne b be nj nk l nl nm"># Timing<br/>setup_code = """<br/>import pandas as pd<br/>d = {'category': ['apple', 'pear', 'peach'], 'radius': [3, 4, 2], 'sweetness': [1, 2, 3]}<br/>df = pd.DataFrame(data=d)<br/>"""<br/><br/>mycode = '''<br/>df['radius'].apply(lambda x: max(x,3))<br/>'''<br/> <br/># timeit statement<br/>t1 = timeit.timeit(setup=setup_code,<br/>                     stmt = mycode,<br/>                     number = 10000)<br/>print(f"10000 runs of mycode is {t1}")</span></pre><p id="beab" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">给了我们 0.56 秒。但是如果数据有几百万行，需要多长时间呢？这里没展示，不过要几十分钟。这么简单的操纵是不能接受的吧？</p><p id="2aac" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">应该怎么加快速度？</p><p id="839e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">下面是通过使用 NumPy 而不是。apply()函数。</p><pre class="kk kl km kn gt nd ne nf bn ng nh bi"><span id="1ffc" class="ni mg it ne b be nj nk l nl nm">df['radius_or_3'] = np.maximum(df['radius'],3)</span></pre><p id="d7e5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里的 NumPy 函数最大值是一个比。应用()。让我们计算一下时间。</p><pre class="kk kl km kn gt nd ne nf bn ng nh bi"><span id="c976" class="ni mg it ne b be nj nk l nl nm"># Timing<br/>setup_code = """<br/>import pandas as pd<br/>import numpy as np<br/>d = {'category': ['apple', 'pear', 'peach'], 'radius': [3, 4, 2], 'sweetness': [1, 2, 3]}<br/>df = pd.DataFrame(data=d)<br/>"""<br/><br/>mycode = '''<br/>np.maximum(df['radius'],3)<br/>'''<br/> <br/># timeit statement<br/>t1 = timeit.timeit(setup=setup_code,<br/>                     stmt = mycode,<br/>                     number = 10000)<br/>print(f"10000 runs of mycode is {t1}")</span></pre><p id="af02" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">它产生 0.31 秒，比。apply()函数吧？</p><p id="618d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">因此，要点是，在简单地使用。对所有内容应用()函数。</p><h2 id="caa2" class="mf mg it bd mh mi mj dn mk ml mm dp mn lj mo mp mq ln mr ms mt lr mu mv mw mx bi translated">将函数应用于多列</h2><p id="ccf3" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">有时我们需要使用数据中的多个列作为函数的输入。例如，我们希望创建一列列表，记录“半径 _ 或 _3”和“直径”之间的可能大小。</p><p id="dc72" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们可以利用。将()应用于整个数据帧，</p><pre class="kk kl km kn gt nd ne nf bn ng nh bi"><span id="c02b" class="ni mg it ne b be nj nk l nl nm">df['sizes'] = df.apply(lambda x: list(range(x.radius_or_3,x.diameter)), axis=1)<br/>df</span></pre><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="a7b3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这一步实际上非常耗时，因为我们实际上在。apply()函数。执行时间是，</p><pre class="kk kl km kn gt nd ne nf bn ng nh bi"><span id="1d4b" class="ni mg it ne b be nj nk l nl nm"># Timing<br/>setup_code = """<br/>import pandas as pd<br/>import numpy as np<br/>d = {'category': ['apple', 'pear', 'peach'], 'radius': [3, 4, 2], 'sweetness': [1, 2, 3]}<br/>df = pd.DataFrame(data=d)<br/>df['diameter'] = df['radius']*2<br/>df['radius_or_3'] = np.maximum(df['radius'],3)<br/>"""<br/><br/>mycode = '''<br/>df.apply(lambda x: list(range(x.radius_or_3,x.diameter)), axis=1)<br/>'''<br/> <br/># timeit statement<br/>t1 = timeit.timeit(setup=setup_code,<br/>                     stmt = mycode,<br/>                     number = 10000)<br/>print(f"10000 runs of mycode is {t1}")</span></pre><p id="eddf" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">给了我们 1.84 秒。我会告诉你，对于一个数百万行的数据帧来说，这需要 20 多分钟。</p><p id="9b43" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们能找到更有效的方法来完成这项任务吗？</p><p id="6445" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">答案是肯定的。我们唯一需要做的就是创建一个函数，根据需要接受尽可能多的 NumPy 数组(pandas 系列)作为输入。</p><pre class="kk kl km kn gt nd ne nf bn ng nh bi"><span id="7904" class="ni mg it ne b be nj nk l nl nm">def create_range(a,b):<br/>    range_l = np.empty((len(a),1),object)<br/>    for i,val in enumerate(a):<br/>        range_l[i,0] = list(range(val,b[i]))<br/>    return range_l<br/><br/>df['sizes'] = create_range(df['radius_or_3'].values,df['diameter'].values)<br/>df</span></pre><p id="4ac2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这段代码有一个函数，<em class="np"> create_range </em>，它接受两个 Numpy 数组，并通过一个简单的 for 循环返回一个 Numpy 数组。并且返回的 Numpy 数组可以自动转换为 Pandas 系列。</p><p id="5ff3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们检查一下我们节省了多少时间。</p><pre class="kk kl km kn gt nd ne nf bn ng nh bi"><span id="b705" class="ni mg it ne b be nj nk l nl nm"># Timing<br/>setup_code = """<br/>import pandas as pd<br/>import numpy as np<br/>d = {'category': ['apple', 'pear', 'peach'], 'radius': [3, 4, 2], 'sweetness': [1, 2, 3]}<br/>df = pd.DataFrame(data=d)<br/>df['diameter'] = df['radius']*2<br/>df['radius_or_3'] = np.maximum(df['radius'],3)<br/>"""<br/><br/>mycode = '''<br/>def create_range(a,b):<br/>    range_l = np.empty((len(a),1),object)<br/>    for i,val in enumerate(a):<br/>        range_l[i,0] = list(range(val,b[i]))<br/>    return range_l<br/><br/>create_range(df['radius_or_3'].values,df['diameter'].values)<br/>'''<br/> <br/># timeit statement<br/>t1 = timeit.timeit(setup=setup_code,<br/>                     stmt = mycode,<br/>                     number = 10000)<br/>print(f"10000 runs of mycode is {t1}")</span></pre><p id="7aa3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">它给了我们 0.07 秒！！！！</p><p id="cfe9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">看到了吗？它的速度比。对整个数据框应用()函数！！</p><h2 id="90a6" class="mf mg it bd mh mi mj dn mk ml mm dp mn lj mo mp mq ln mr ms mt lr mu mv mw mx bi translated">外卖食品</h2><ol class=""><li id="c921" class="nq nr it lc b ld my lg mz lj ns ln nt lr nu lv nv nw nx ny bi translated">如果你想用。将()应用于 Pandas 数据框中的单个列，尝试找到更简单的执行，例如 df['radius']*2。或者尝试为任务找到现有的 NumPy 函数。</li><li id="a8d6" class="nq nr it lc b ld nz lg oa lj ob ln oc lr od lv nv nw nx ny bi translated">如果你想用。将()应用于 Pandas 数据框中的多个列，尽量避免。应用(，轴=1)格式。并编写一个独立的函数，它可以将 Numpy 数组作为输入，然后直接在。熊猫系列的值(数据框的列)。</li></ol><p id="c54f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了方便起见，这是本文中代码的完整 Jupyter 笔记本。</p><div class="oe of gp gr og oh"><a href="https://github.com/jiananlin/what_if_apply_too_slow/blob/main/apply_too_slow.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">主建安林的 what _ if _ apply _ too _ slow/apply _ too _ slow . ipynb/what _ if _ apply _ too _ slow</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">github.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov kt oh"/></div></div></a></div><p id="c185" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这就是我想分享的全部！干杯！</p><p id="8933" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果你喜欢我的文章，别忘了<a class="ae kz" href="https://medium.com/subscribe/@jianan-lin?source=publishing_settings-------------------------------------" rel="noopener">订阅我的邮件列表</a>或者<a class="ae kz" href="https://medium.com/membership/@jianan-lin?source=publishing_settings-------------------------------------" rel="noopener">成为 Medium 的推荐会员</a>！！</p></div></div>    
</body>
</html>