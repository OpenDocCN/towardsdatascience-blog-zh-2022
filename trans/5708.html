<html>
<head>
<title>Indication and Hide-and-Seek Privacy of Attributes in Python Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 类中属性的指示和捉迷藏隐私</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/indication-and-hide-and-seek-privacy-of-attributes-in-python-classes-3f64f9d6da88#2022-12-27">https://towardsdatascience.com/indication-and-hide-and-seek-privacy-of-attributes-in-python-classes-3f64f9d6da88#2022-12-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="d068" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">PYTHON 编程</h2><div class=""/><div class=""><h2 id="4e46" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">了解“公共”和“私有”在 Python 类及其属性的上下文中的含义。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/65e9ba807a96e63136582dcae40b2078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tSbIYzf6oecMNqp6"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@dtopkin1?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">戴恩·托普金</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="461c" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">公共与私人——说与想</h1><p id="4de7" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">一般在编程中，当某个东西是公共的，你就可以访问它，使用它；当它是私人的时候，你不能。这就像想某事和说某事:当你想某事时，它仍然是你的；但是无论你大声说什么，都不再仅仅是你的，而是公开的。</p><p id="3daf" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">Python 中的工作方式不同。你可能听说过在 Python 中没有什么是真正私有的。这是什么意思？Python 有私有属性和方法吗？</p><p id="0951" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们在 Python 类的方法和属性的上下文中使用这两个术语，<em class="nb">公共</em>和<em class="nb">私有</em>。当一个属性是私有的，你不应该使用它；当一个方法是私有的，你不应该调用它。你可能注意到我用了“应该”这个词。正如我已经提到的，这是因为 Python 中的工作方式不同:当某个东西是公共的时，你可以访问和使用它；当这是私人的事情时，你不应该做，但这并不意味着你不能做。因此，当你用 Python 思考某件事时，它应该属于你——但是任何人都可以通过简单的方法听到它。</p><p id="0cbe" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如你所见，Python 在隐私方面并不严格。它建议你遵守一些规则，而不是让你去遵守它们。它建议一个类的用户<em class="nb">而不是</em>访问私有方法和属性——但是用户无论如何都可以这样做，更重要的是，他们不必为此付出太多努力。</p><p id="c9ab" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在这篇文章中，我将用简单的词语和例子来解释这些事情。</p><blockquote class="nc"><p id="13e3" class="nd ne it bd nf ng nh ni nj nk nl mv dk translated">当你想某事时，它仍然是你的；但是无论你大声说什么，都不再仅仅是你的，而是公开的。</p><p id="9e2a" class="nd ne it bd nf ng nh ni nj nk nl mv dk translated">当你用 Python 思考某件事时，它应该属于你——但是任何人都可以通过简单的方法听到它。</p></blockquote><h1 id="bbb2" class="li lj it bd lk ll lm ln lo lp lq lr ls ki nn kj lu kl no km lw ko np kp ly lz bi translated">“私有”方法和属性</h1><p id="3f4e" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">Python 中没有真正的隐私。Python 提供的是伪隐私，或者准隐私。它有两个层次，我称之为<em class="nb">指示隐私</em>和<em class="nb">捉迷藏隐私</em>。</p><h2 id="962e" class="nq lj it bd lk nr ns dn lo nt nu dp ls mj nv nw lu mn nx ny lw mr nz oa ly iz bi translated">指示隐私</h2><p id="252a" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">您可以指示特定属性是私有的。要做到这一点，只需在其名称中添加一个前导下划线即可。这样做，你<em class="nb">指示</em>，或者<em class="nb">建议</em>，或者<em class="nb">建议</em>，该方法/属性应该被视为私有的，意味着它不应该在类之外使用。</p><p id="92c4" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因此，<code class="fe ob oc od oe b">instance.do_it()</code>是一个常规(公共)方法，而<code class="fe ob oc od oe b">instance._do_it()</code>是一个表示为私有的方法。因此，作为该类的用户，您被要求不要使用它。它在那里是因为它服务于一些实现的目的——而你与它无关。这不是秘密。你可以看一下，没有人对你隐瞒什么。但这不是给你的。接受别人给你的东西，不要碰别人给你的东西。</p><p id="a858" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">让我们考虑一个简单的例子:</p><pre class="ks kt ku kv gt of oe og bn oh oi bi"><span id="e298" class="oj lj it oe b be ok ol l om on"># class_me.py<br/>class Me:<br/>    def __init__(self, name, smile=":-D"):<br/>        self.name = name<br/>        self.smile = smile<br/>        self._thoughts = []<br/>    <br/>    def say(self, what):<br/>        return str(what)<br/>    <br/>    def smile_to(self, whom):<br/>        return f"{self.smile} → {whom}"<br/>    <br/>    def _think(self, what):<br/>        self._thoughts += [what]<br/><br/>    def _smile_to_myself(self):<br/>        return f"{self.smile} → {self.name}"</span></pre><p id="7300" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">(如果你不知道为什么我写的是<code class="fe ob oc od oe b">self._thoughts += [what]</code>而不是<code class="fe ob oc od oe b">self._thoughts += what</code>，请访问附录 1。)</p><p id="e7e1" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">好的，我们有一个类<code class="fe ob oc od oe b">Me</code>，它代表你——至少在你创建它的时候。它具有以下属性:</p><ul class=""><li id="ec93" class="oo op it mc b md mw mg mx mj oq mn or mr os mv ot ou ov ow bi translated"><code class="fe ob oc od oe b">.name</code>，一个公共属性→你的名字肯定是公共的。</li><li id="9781" class="oo op it mc b md ox mg oy mj oz mn pa mr pb mv ot ou ov ow bi translated"><code class="fe ob oc od oe b">.smile</code>，一个公共属性→你的笑容在外面是可见的，所以肯定是公共的。</li><li id="383a" class="oo op it mc b md ox mg oy mj oz mn pa mr pb mv ot ou ov ow bi translated"><code class="fe ob oc od oe b">._thoughts</code>，一个私人属性→你的想法<em class="nb">肯定是</em>私人的，不是吗？</li></ul><p id="9bec" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如您所见，两个公共属性的名称没有前导下划线，唯一的私有属性的名称有。</p><p id="8e5d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">现在让我们来看看可用的方法:</p><ul class=""><li id="b2db" class="oo op it mc b md mw mg mx mj oq mn or mr os mv ot ou ov ow bi translated"><code class="fe ob oc od oe b">.say()</code>，一个公开的方法→当你说一件事的时候，别人能听见，所以你的话是公开的。</li><li id="77bb" class="oo op it mc b md ox mg oy mj oz mn pa mr pb mv ot ou ov ow bi translated"><code class="fe ob oc od oe b">.smile_to()</code>，一个公共方法→当你对某人微笑时，这个人和周围的人都能看到你在微笑。</li><li id="9247" class="oo op it mc b md ox mg oy mj oz mn pa mr pb mv ot ou ov ow bi translated"><code class="fe ob oc od oe b">._smile_to_myself()</code>，一个私密的方法→这是一种别样的微笑；它是为类的作者保留的(在我们的例子中，是为您保留的)，并且是在没有人注意的时候完成的——这就是为什么它是一个私有方法。</li><li id="bd88" class="oo op it mc b md ox mg oy mj oz mn pa mr pb mv ot ou ov ow bi translated"><code class="fe ob oc od oe b">._think()</code>，私法→当你想某件事的时候，那是你的私以为；如果要大声说出来，就要用 public <code class="fe ob oc od oe b">.say()</code>的方法。</li></ul><p id="0337" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">让我们和全班一起玩。我将为自己创建该类的实例，所以我将它命名为<code class="fe ob oc od oe b">marcin</code>。您可以为自己创建一个实例。</p><pre class="ks kt ku kv gt of oe og bn oh oi bi"><span id="d906" class="oj lj it oe b be ok ol l om on">&gt;&gt;&gt; from class_me import Me<br/>&gt;&gt;&gt; marcin = Me(name="Marcin")<br/>&gt;&gt;&gt; marcin # doctest: +ELLIPSIS<br/>&lt;__main__.Me object at 0x...&gt;<br/>&gt;&gt;&gt; marcin.say("What a beautiful day!")<br/>'What a beautiful day!'<br/>&gt;&gt;&gt; marcin.smile_to("Justyna")<br/>':-D → Justyna'</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pc"><img src="../Images/aaf5925c14a2019d9966d47b3f34c388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xH6QGdiZkx0M-UOaXZK5BA.png"/></div></div></figure><p id="b138" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我使用了<code class="fe ob oc od oe b">doctest</code>来格式化上面块中的代码。它帮助我确保代码是正确的。您可以从下面的文章中了解关于这个文档测试框架的更多信息:</p><div class="pd pe gp gr pf pg"><a rel="noopener follow" target="_blank" href="/python-documentation-testing-with-doctest-the-easy-way-c024556313ca"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd jd gy z fp pl fr fs pm fu fw jc bi translated">用 doctest 测试 Python 文档:简单的方法</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">doctest 允许文档、单元和集成测试，以及测试驱动的开发。</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">towardsdatascience.com</p></div></div><div class="pp l"><div class="pq l pr ps pt pp pu lb pg"/></div></div></a></div><p id="7520" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如果您想将代码复制并粘贴为 doctest，并自己以这种方式运行，请访问本文末尾的附录 2，其中包含以这种方式格式化的剩余代码(例如，<code class="fe ob oc od oe b">Me</code>类的代码)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pc"><img src="../Images/b8397a4f4b1c870e04ae5c6a57b955a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Y2kUU4KKM-rvvnaAfLN5g.png"/></div></div></figure><p id="851b" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">好的，一切看起来都很好。然而，到目前为止，我们还算客气，甚至还没有看私有方法和属性；我们只用过公共的。是时候淘气一点了:</p><pre class="ks kt ku kv gt of oe og bn oh oi bi"><span id="cb84" class="oj lj it oe b be ok ol l om on">&gt;&gt;&gt; dir(marcin)  #doctest: +NORMALIZE_WHITESPACE<br/>['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', <br/>'__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', <br/>'__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', <br/>'__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', <br/>'__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', <br/>'__weakref__', '_smile_to_myself', '_think', '_thoughts', 'name', <br/>'say', 'smile', 'smile_to']</span></pre><p id="644c" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们看到了什么？实际上，一切。我们当然会看到公共属性<code class="fe ob oc od oe b">.name</code>和<code class="fe ob oc od oe b">.smile</code>以及公共方法<code class="fe ob oc od oe b">.say()</code>和<code class="fe ob oc od oe b">.smile_to()</code>。但是我们也看到私有属性<code class="fe ob oc od oe b">._thoughts</code>和私有方法<code class="fe ob oc od oe b">._think()</code>和<code class="fe ob oc od oe b">._smile_to_myself()</code>。此外，我们会看到更多不是我们创建的方法和属性。</p><p id="eaa8" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">请记住，使用<code class="fe ob oc od oe b">.__name__()</code>约定命名的方法是 dunder 方法，而不是私有方法。我们改天再谈这个。</p><p id="0936" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">既然我们能够看到私有属性，很可能我们也能够使用它们:</p><pre class="ks kt ku kv gt of oe og bn oh oi bi"><span id="6f29" class="oj lj it oe b be ok ol l om on">&gt;&gt;&gt; marcin._think("My wife is so beautiful!")<br/>&gt;&gt;&gt; marcin._think("But let this be my secret!")</span></pre><p id="888a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">什么都没发生？那也许就没事了？也许我们可以使用私人方法，但无论他们在做什么都瞒着我们？</p><p id="1916" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">当然不是。只是<code class="fe ob oc od oe b">._think()</code>方法不返回任何东西(或者说返回<code class="fe ob oc od oe b">None</code>)，而是将想法保存到<code class="fe ob oc od oe b">._thoughts</code>属性，也是私有的。让我们看看你是否能看到我的私人想法:</p><pre class="ks kt ku kv gt of oe og bn oh oi bi"><span id="7ec1" class="oj lj it oe b be ok ol l om on">&gt;&gt;&gt; marcin._thoughts<br/>['My wife is so beautiful!', 'But let this be my secret!']</span></pre><p id="d2d0" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">是的，你可以。最后一个测试:让我们看看你是否能看到我对自己微笑:</p><pre class="ks kt ku kv gt of oe og bn oh oi bi"><span id="8550" class="oj lj it oe b be ok ol l om on">&gt;&gt;&gt; marcin._smile_to_myself()<br/>':-D → Marcin'</span></pre><p id="b814" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">你也可以。因此，您可以清楚地看到私有属性，并且可以使用私有方法——尽管我通过在这些属性和方法的名称前添加下划线明确指出它们是私有的，所以我不希望您使用它们。使用私有方法或属性有点像在淋浴时偷窥我——你可以看到我想对你隐藏的东西。</p><p id="26b0" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">然而，有时出于这样或那样的原因，您可能想要修改一个现有的类；这可能意味着覆盖私有属性或方法。这就是 Python 方法的亮点。理论上，这些属性是私有的，所以你不应该使用它们；有时，使用它们甚至可以打破一个类。这也是一种保护措施。你知道这些属性是隐私，所以最好不要碰它们。</p><p id="8b27" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">但是当你知道你在做什么，当你的目的要求你使用私有属性时——Python 使这成为可能。这为 Python 开发人员带来了许多额外的机会。</p><blockquote class="nc"><p id="f01f" class="nd ne it bd nf ng nh ni nj nk nl mv dk translated">使用私有方法或属性有点像在淋浴时偷窥我——你可以看到我想对你隐藏的东西。</p><p id="22ee" class="nd ne it bd nf ng nh ni nj nk nl mv dk translated">这为 Python 开发人员带来了许多额外的机会。</p></blockquote><p id="74cb" class="pw-post-body-paragraph ma mb it mc b md pv kd mf mg pw kg mi mj px ml mm mn py mp mq mr pz mt mu mv im bi translated">有点夸张，在 Python 里你可以为所欲为。您可以覆盖内置函数、异常等。(如果你想了解更多关于重写异常的信息，请阅读<a class="ae lh" href="https://medium.com/better-programming/how-to-overwrite-asserterror-in-python-and-use-custom-exceptions-c0b252989977" rel="noopener">这篇<em class="nb">更好编程</em>文章</a>。)并且可以使用私有属性。这很好，假设——就像任何代码的情况一样——您不想对用户的计算机造成任何损害。</p><p id="80aa" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我相信你会同意这种隐私是脆弱的，因为用户可以像使用公共属性和类一样使用私有属性和类。然而，Python 提供了一种更严格的隐私方法，我称之为<em class="nb">捉迷藏隐私</em>。</p><h2 id="eefa" class="nq lj it bd lk nr ns dn lo nt nu dp ls mj nv nw lu mn nx ny lw mr nz oa ly iz bi translated">捉迷藏隐私</h2><p id="bf82" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">隐私的指示级别仅包括指示属性是私有的还是公共的，而捉迷藏级别则更进一步。你马上就会看到，在某种程度上，它帮助你保护私有属性。</p><p id="d96c" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">这是否意味着这一次，私有属性和方法将真正被隐藏，用户将无法使用它们？不完全是。正如我所写的，捉迷藏隐私提供了某种程度的保护——但不是完全的保护。Python 之所以能做到这一点，要归功于一种叫做<a class="ae lh" href="https://en.wikipedia.org/wiki/Name_mangling#Python" rel="noopener ugc nofollow" target="_blank"> name mangling </a>的方法。</p><p id="cac1" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">当您想要使用名称篡改，因此需要隐藏隐私时，您需要向私有属性的名称添加两个前导下划线，而不是一个。在我们的<code class="fe ob oc od oe b">Me</code>类中，比如说，<code class="fe ob oc od oe b">.__thoughts</code>和<code class="fe ob oc od oe b">.__think()</code>。多亏了名称管理，私有属性或方法以一种特殊的方式被修改，使得从类外部访问它们变得更加困难。</p><p id="c544" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">让我们在工作中看到这一点。我们先修改我们的<code class="fe ob oc od oe b">Me</code>类；让我们把它的名字改成<code class="fe ob oc od oe b">PrivateMe</code>(关于<code class="fe ob oc od oe b">doctest</code> ing 格式的代码，见附件 2):</p><pre class="ks kt ku kv gt of oe og bn oh oi bi"><span id="0c01" class="oj lj it oe b be ok ol l om on"># class_me.py<br/>class PrivateMe:<br/>    def __init__(self, name, smile=":-D"):<br/>        self.name = name<br/>        self.smile = smile<br/>        self.__thoughts = []<br/>    <br/>    def say(self, what):<br/>        return str(what)<br/>    <br/>    def smile_to(self, whom):<br/>        return f"{self.smile} → {whom}"<br/>    <br/>    def __think(self, what):<br/>        self.__thoughts += [what]<br/><br/>    def __smile_to_myself(self):<br/>        return f"{self.smile} → {self.name}"</span></pre><p id="b0c3" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">首先，让我们创建一个实例—同样，这将是我的一个实例—并使用公共方法:</p><pre class="ks kt ku kv gt of oe og bn oh oi bi"><span id="08fc" class="oj lj it oe b be ok ol l om on">&gt;&gt;&gt; marcin = PrivateMe(name="Marcin")<br/>&gt;&gt;&gt; marcin.say("What a beautiful day!")<br/>'What a beautiful day!'<br/>&gt;&gt;&gt; marcin.smile_to("Justyna")<br/>':-D → Justyna'</span></pre><p id="b339" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">(如果你在疑惑 Justyna 是我老婆还是我在对另一个女生微笑，你可以放心；她是！)</p><p id="9fb2" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">到目前为止一切顺利，但这并不令人惊讶——毕竟，我们已经使用了公共方法。以前，我们成功地使用了私有方法，比如<code class="fe ob oc od oe b">._smile_to_myself()</code>。让我们试试这次是否能成功。为了验证这一点，我会试着用<code class="fe ob oc od oe b">.__smile_to_myself()</code>方法对自己微笑:</p><pre class="ks kt ku kv gt of oe og bn oh oi bi"><span id="4b24" class="oj lj it oe b be ok ol l om on">&gt;&gt;&gt; marcin.__smile_to_myself()<br/>Traceback (most recent call last):<br/>    ...<br/>AttributeError: 'PrivateMe' object has no attribute '__smile_to_myself'</span></pre><p id="35ca" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">哈！我们知道<code class="fe ob oc od oe b">PrivateMe</code>类有<code class="fe ob oc od oe b">__smile_to_myself()</code>方法，但是我们不能使用它。显然，它是受保护的，任何私有方法都应该如此。</p><p id="5ed9" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">尽管如此……看起来这个方法是完全受保护的，而不久前我还声称在 Python 中，私有属性没有受到完全保护。这是怎么回事？</p><p id="e8af" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们刚刚经历了如何命名 mangling 工程。它隐藏了私有属性——或者说，不管听起来有多奇怪，它隐藏了私有属性的名称。换句话说，它以一种特殊的方式改变了他们的名字；新名称将遵循以下<code class="fe ob oc od oe b">_ClassName__attribute</code>符号:</p><pre class="ks kt ku kv gt of oe og bn oh oi bi"><span id="46a8" class="oj lj it oe b be ok ol l om on">class MyClass:<br/>    __privacy = None     # this becomes ._MyClass__privacy    <br/>    def __hide_me(self): # this becomes ._MyClass__hide_me()<br/>        pass</span></pre><p id="4067" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">这样，不能使用属性的原始名称访问属性，但可以使用通过名称管理更新的名称访问属性。在我们的<code class="fe ob oc od oe b">PrivateMe</code>类中，它是这样工作的:</p><pre class="ks kt ku kv gt of oe og bn oh oi bi"><span id="db78" class="oj lj it oe b be ok ol l om on">&gt;&gt;&gt; marcin._PrivateMe__smile_to_myself()<br/>':-D → Marcin'</span></pre><p id="2c82" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">你可以看到这个属性就在那里，只是被重命名了。我们肯定会在<code class="fe ob oc od oe b">dir()</code>函数的输出中看到这一点:</p><pre class="ks kt ku kv gt of oe og bn oh oi bi"><span id="9a1b" class="oj lj it oe b be ok ol l om on">&gt;&gt;&gt; dir(marcin) # doctest: +NORMALIZE_WHITESPACE<br/>['_PrivateMe__smile_to_myself', '_PrivateMe__think',<br/> '_PrivateMe__thoughts', '__class__', '__delattr__',<br/> '__dict__', '__dir__', '__doc__', '__eq__', '__format__',<br/> '__ge__', '__getattribute__', '__gt__', '__hash__',<br/> '__init__', '__init_subclass__', '__le__', '__lt__',<br/> '__module__', '__ne__', '__new__', '__reduce__',<br/> '__reduce_ex__', '__repr__', '__setattr__',<br/> '__sizeof__', '__str__', '__subclasshook__',<br/> '__weakref__', 'name', 'say', 'smile', 'smile_to']</span></pre><p id="fd27" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们的私有方法和属性可以使用新的名称:</p><ul class=""><li id="63fa" class="oo op it mc b md mw mg mx mj oq mn or mr os mv ot ou ov ow bi translated"><code class="fe ob oc od oe b">.__smile_to_myself()</code> → <code class="fe ob oc od oe b">._PrivateMe__smile_to_myself()</code></li><li id="73a8" class="oo op it mc b md ox mg oy mj oz mn pa mr pb mv ot ou ov ow bi translated"><code class="fe ob oc od oe b">.__think()</code> → <code class="fe ob oc od oe b">._PrivateMe__think()</code></li><li id="5632" class="oo op it mc b md ox mg oy mj oz mn pa mr pb mv ot ou ov ow bi translated"><code class="fe ob oc od oe b">.__thoughts</code> → <code class="fe ob oc od oe b">._PrivateMe__thoughts</code></li></ul><p id="2a00" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">名称篡改使我们能够实现隐私的捉迷藏水平。</p><p id="6fb8" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">还记得一件事。当您想要通过添加两个前导下划线来使属性成为私有属性时，不要在名称末尾添加两个额外的下划线。这样命名的方法就变成了所谓的 dunder(<strong class="mc jd"><em class="nb">d</em></strong>double-<strong class="mc jd"><em class="nb"/></strong>score)方法——而且这些绝对是<em class="nb">不是</em>私有的；实际上，它们是与私有相对的。我们改天再谈。要使用名称管理，记住这条命名规则就足够了:不要对私有方法使用<code class="fe ob oc od oe b">.__name__()</code>约定，因为这不起作用。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qa"><img src="../Images/87840f875600b7bc9d14c9b5950072c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5IG_2Nn2mGvdmPKl"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">克里斯蒂安·沃克在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="18aa" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">结论</h1><p id="7201" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我们已经在 Python 面向对象编程的上下文中讨论了隐私的概念。编写类时，有时可能希望隐藏一些实现细节，通过将类的一些属性和方法设为私有，可以实现这一点。但它们从来都不是真正的隐私。</p><p id="b30c" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">这种方法对我来说听起来不自然。当我想到一个私有属性时，我把它想象成一个不能在类外看到和使用的属性。同样，它是一个公共属性，可以以这种方式看到和使用。</p><p id="ff30" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如果您的想象力以类似的方式工作，您需要使用改变世界的眼镜，以便您可以在 Python 世界中移动，而不会不时摔倒。每次用 Python 都要戴上这种眼镜。迟早，它们会帮助您习惯 Python 的不同世界，在这个世界中，隐私的概念是如此不同。</p><blockquote class="nc"><p id="e5bf" class="nd ne it bd nf ng nh ni nj nk nl mv dk translated">您需要使用改变世界的眼镜，这样您就可以在 Python 世界中移动，而不会不时摔倒。</p><p id="257e" class="nd ne it bd nf ng nh ni nj nk nl mv dk translated">迟早，它们会帮助您习惯 Python 的不同世界，在这个世界中，隐私的概念是如此不同。</p></blockquote><p id="8c73" class="pw-post-body-paragraph ma mb it mc b md pv kd mf mg pw kg mi mj px ml mm mn py mp mq mr pz mt mu mv im bi translated">总之，Python 不能让你完全保护一个类的属性。然而，它提供了两级保护，我称之为<em class="nb">指示</em>和<em class="nb">捉迷藏</em>隐私。</p><p id="b1a9" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><em class="nb">指示隐私</em>。您可以将一个属性指定为私有，并相信没有人会在类之外使用该属性。指示方法是基于信任的:我们相信类的用户不会使用它的私有属性。除此之外，该方法不使用任何保护措施。</p><blockquote class="nc"><p id="7105" class="nd ne it bd nf ng nh ni nj nk nl mv dk translated">指示方法是基于信任的:我们相信类的用户不会使用它的私有属性。除此之外，该方法不使用任何保护措施。</p></blockquote><p id="3c0e" class="pw-post-body-paragraph ma mb it mc b md pv kd mf mg pw kg mi mj px ml mm mn py mp mq mr pz mt mu mv im bi translated"><em class="nb">捉迷藏隐私</em>。这是更高层次的隐私——就类属性的隐私而言，我们可以从 Python 中获得最多的隐私。在指示 privacy 的情况下，你可以像使用 public 属性一样使用 private 属性，但是在这里你不能。你的私人属性得到了一定程度的保护。它仍然不是完全的保护；私有属性由于名字的改变而被隐藏。你仍然可以找到、访问和使用它们——但至少它们受到了某种程度的保护。它们并没有真正被隐藏，因为<code class="fe ob oc od oe b">dir()</code>将向我们展示所有的类属性，包括公共的和私有的，但是后者将会改变名称。</p></div><div class="ab cl qb qc hx qd" role="separator"><span class="qe bw bk qf qg qh"/><span class="qe bw bk qf qg qh"/><span class="qe bw bk qf qg"/></div><div class="im in io ip iq"><p id="ef19" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">感谢阅读这篇文章。我希望 Python 类环境中的隐私不再对您构成问题。虽然乍一看这个主题似乎很难，或者至少很奇怪，但是您会很快习惯 Python 隐私的奇怪世界。请放心，许多 Python 开发人员都很欣赏这些东西在 Python 中的工作方式。如果你不这样做，你迟早会加入他们的行列。</p><p id="3546" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">对我来说，我不仅不反对 Python 对待隐私的方式，我甚至欣赏它。我多次使用过这种方法，知道它就在那里是很好的，以防万一，等待我去窥探类的属性和方法。</p><p id="74b9" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如果你喜欢这篇文章，你也可以喜欢我写的其他文章；你会在这里找到它们。如果你想加入 Medium，请使用我下面的推荐链接:</p><div class="pd pe gp gr pf pg"><a href="https://medium.com/@nyggus/membership" rel="noopener follow" target="_blank"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd jd gy z fp pl fr fs pm fu fw jc bi translated">加入我的介绍链接媒体-马尔钦科萨克</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">阅读马尔钦·科萨克(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">medium.com</p></div></div><div class="pp l"><div class="qi l pr ps pt pp pu lb pg"/></div></div></a></div><h1 id="3d8c" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">脚注</h1><p id="e7c4" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">记住，在 Python 中，方法是类的属性。因此，每当我提到属性的私有性时，我指的是属性的私有性，包括方法。</p><p id="6247" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">命名有两个目的:</p><ul class=""><li id="e71c" class="oo op it mc b md mw mg mx mj oq mn or mr os mv ot ou ov ow bi translated">它增加了对类的私有属性和方法的保护级别。</li><li id="aec0" class="oo op it mc b md ox mg oy mj oz mn pa mr pb mv ot ou ov ow bi translated">它确保父类的私有属性不会被从它继承的类覆盖。因此，当您使用两个前导下划线时，您不必担心类中的这个属性会被继承类覆盖。</li></ul><p id="a39f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">本文讲的是第一点。然而，第二个问题超出了本文的范围；我们改天再讨论它。</p><h1 id="8d53" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">附录 1</h1><p id="864a" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">这个附录解释了为什么在编写<code class="fe ob oc od oe b">Me</code>类时，我写道</p><pre class="ks kt ku kv gt of oe og bn oh oi bi"><span id="9dfb" class="oj lj it oe b be ok ol l om on">self._thoughts += [what]</span></pre><p id="8f55" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">而不是</p><pre class="ks kt ku kv gt of oe og bn oh oi bi"><span id="512c" class="oj lj it oe b be ok ol l om on">self._thoughts += what</span></pre><p id="eedd" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">就地串联<code class="fe ob oc od oe b">+=</code>的工作方式如下:</p><pre class="ks kt ku kv gt of oe og bn oh oi bi"><span id="b9dd" class="oj lj it oe b be ok ol l om on">&gt;&gt;&gt; x = [1, 2, 3]<br/>&gt;&gt;&gt; y = [4, 5, 6]<br/>&gt;&gt;&gt; x += y<br/>&gt;&gt;&gt; y<br/>[4, 5, 6]<br/>&gt;&gt;&gt; x<br/>[1, 2, 3, 4, 5, 6]</span></pre><p id="ab9f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如您所见，该操作添加了两个列表；作为就地操作，它影响第一个，而第二个保持不变。然而，这不适用于不可迭代的对象，比如数字(这里，<code class="fe ob oc od oe b">int</code>):</p><pre class="ks kt ku kv gt of oe og bn oh oi bi"><span id="bd9e" class="oj lj it oe b be ok ol l om on">&gt;&gt;&gt; x += 5<br/>Traceback (most recent call last):<br/>    ...<br/>TypeError: 'int' object is not iterable</span></pre><p id="6ad1" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因此，您可以使用就地串联向列表中添加另一个 iterable，如列表、元组、<code class="fe ob oc od oe b">range</code>对象和生成器:</p><pre class="ks kt ku kv gt of oe og bn oh oi bi"><span id="c981" class="oj lj it oe b be ok ol l om on">&gt;&gt;&gt; x += (10, 20)<br/>&gt;&gt;&gt; x<br/>[1, 2, 3, 4, 5, 6, 10, 20]<br/>&gt;&gt;&gt; x += range(3)<br/>&gt;&gt;&gt; x<br/>[1, 2, 3, 4, 5, 6, 10, 20, 0, 1, 2]<br/>&gt;&gt;&gt; x += (i**2 for i in range(3))<br/>&gt;&gt;&gt; x<br/>[1, 2, 3, 4, 5, 6, 10, 20, 0, 1, 2, 0, 1, 4]</span></pre><p id="bfab" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">字符串也是可迭代的，所以您也可以将它们添加到列表中:</p><pre class="ks kt ku kv gt of oe og bn oh oi bi"><span id="6ff9" class="oj lj it oe b be ok ol l om on">&gt;&gt;&gt; x += "Cuma"<br/>&gt;&gt;&gt; x<br/>[1, 2, 3, 4, 5, 6, 10, 20, 0, 1, 2, 0, 1, 4, 'C', 'u', 'm', 'a']</span></pre><p id="b4d6" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如您所见，<code class="fe ob oc od oe b">"Cuma"</code>字符串被视为其单个字符的可重复项，添加到<code class="fe ob oc od oe b">x</code>的是这些字符，而不是单词本身。</p><p id="2f05" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">这就是为什么<code class="fe ob oc od oe b">self._thoughts += what</code>不起作用的原因。如果我们使用它，我们将会达到以下不良效果:</p><pre class="ks kt ku kv gt of oe og bn oh oi bi"><span id="4314" class="oj lj it oe b be ok ol l om on">&gt;&gt;&gt; marcin._think("I am tired.")<br/>&gt;&gt;&gt; marcin._thoughts<br/>['I', ' ', 'a', 'm', ' ', 't', 'i', 'r', 'e', 'd', '.']</span></pre><p id="719b" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因此，我们需要将思想添加到<code class="fe ob oc od oe b">._thoughts</code>中作为列表的元素，即<code class="fe ob oc od oe b">[what]</code>。这个单元素列表是要添加到<code class="fe ob oc od oe b">._thoughts</code>的 iterable。</p><h1 id="3bf4" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">附录 2</h1><p id="c3c1" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">为<code class="fe ob oc od oe b">doctest</code>格式化的类<code class="fe ob oc od oe b">Me</code>:</p><pre class="ks kt ku kv gt of oe og bn oh oi bi"><span id="7305" class="oj lj it oe b be ok ol l om on">&gt;&gt;&gt; class Me:<br/>...     def __init__(self, name, smile=":-D"):<br/>...         self.name = name<br/>...         self.smile = smile<br/>...         self._thoughts = []<br/>...     def say(self, what):<br/>...         return str(what)<br/>...     def smile_to(self, whom):<br/>...         return f"{self.smile} → {whom}"<br/>...     def _think(self, what):<br/>...         self._thoughts += [what]<br/>...     def _smile_to_myself(self):<br/>...         return f"{self.smile} → {self.name}"</span></pre><p id="8bf1" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">为<code class="fe ob oc od oe b">doctest</code>格式化的类<code class="fe ob oc od oe b">PrivateMe</code>:</p><pre class="ks kt ku kv gt of oe og bn oh oi bi"><span id="df2e" class="oj lj it oe b be ok ol l om on">&gt;&gt;&gt; class PrivateMe:<br/>...     def __init__(self, name, smile=":-D"):<br/>...         self.name = name<br/>...         self.smile = smile<br/>...         self.__thoughts = []<br/>...     def say(self, what):<br/>...         return str(what)<br/>...     def smile_to(self, whom):<br/>...         return f"{self.smile} → {whom}"<br/>...     def __think(self, what):<br/>...         self.__thoughts += [what]<br/>...     def __smile_to_myself(self):<br/>...         return f"{self.smile} → {self.name}"</span></pre></div></div>    
</body>
</html>