<html>
<head>
<title>Python Tree Implementation with BigTree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用BigTree实现Python树</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-tree-implementation-with-bigtree-13cdabd77adc#2022-11-08">https://towardsdatascience.com/python-tree-implementation-with-bigtree-13cdabd77adc#2022-11-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9aac" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将树与Python列表、字典和熊猫数据框架集成在一起</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e676df25785ab37dc61770a89cdfec38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5vcdoBZUIBWo2y85"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@jan_huber?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">简·侯伯</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="8750" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python内置了列表、数组和字典的数据结构，但没有树状数据结构。在LeetCode中，针对树的问题仅限于二分搜索法树，并且其实现不具有许多功能。</p><p id="986f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b"><strong class="ky ir">bigtree</strong></code> <strong class="ky ir"> </strong> Python包可以在Python列表、字典和pandas数据帧之间构建和导出树，与现有的Python工作流无缝集成。</p><blockquote class="lw"><p id="3678" class="lx ly iq bd lz ma mb mc md me mf lr dk translated">树状数据结构可以用来显示层次关系，如家谱和组织结构图。</p></blockquote><p id="d7d4" class="pw-post-body-paragraph kw kx iq ky b kz mg jr lb lc mh ju le lf mi lh li lj mj ll lm ln mk lp lq lr ij bi translated">本文将介绍基本的树概念，如何用<code class="fe ls lt lu lv b"><strong class="ky ir">bigtree</strong></code> <strong class="ky ir"> </strong> Python包构建树，树的遍历、搜索、修改和导出方法。本文以使用树实现待办事项列表的方式结束，并将树实现扩展到<a class="ae kv" href="https://en.wikipedia.org/wiki/Trie" rel="noopener ugc nofollow" target="_blank"> Trie </a>和<a class="ae kv" href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" rel="noopener ugc nofollow" target="_blank">有向无环图</a>数据结构。</p><p id="1275" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你有兴趣为<code class="fe ls lt lu lv b"><strong class="ky ir">bigtree</strong></code> <strong class="ky ir"> </strong> Python包做贡献，那就来合作吧！</p><h1 id="f2ef" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">目录</h1><ul class=""><li id="fd6d" class="nd ne iq ky b kz nf lc ng lf nh lj ni ln nj lr nk nl nm nn bi translated"><a class="ae kv" href="https://medium.com/p/13cdabd77adc/#c220" rel="noopener">树基础和术语</a></li><li id="5df2" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><a class="ae kv" href="https://medium.com/p/13cdabd77adc/#8552" rel="noopener">大树设置</a></li><li id="f071" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><a class="ae kv" href="https://medium.com/p/13cdabd77adc/#3e14" rel="noopener">建造树木</a></li><li id="feac" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><a class="ae kv" href="https://medium.com/p/13cdabd77adc/#509b" rel="noopener">树遍历算法</a></li><li id="0317" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><a class="ae kv" href="https://medium.com/p/13cdabd77adc/#1ada" rel="noopener">树形搜索方法</a></li><li id="51ce" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><a class="ae kv" href="https://medium.com/p/13cdabd77adc/#4bd0" rel="noopener">树形修改方法</a></li><li id="a0e9" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><a class="ae kv" href="https://medium.com/p/13cdabd77adc/#2251" rel="noopener">导出树木</a></li><li id="c3d7" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><a class="ae kv" href="https://medium.com/p/13cdabd77adc/#4d13" rel="noopener">附加:与</a>和<code class="fe ls lt lu lv b"><a class="ae kv" href="https://medium.com/p/13cdabd77adc/#4d13" rel="noopener"><strong class="ky ir">bigtree</strong></a></code>一起使用待办事项</li><li id="8f04" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><a class="ae kv" href="https://medium.com/p/13cdabd77adc/#660e" rel="noopener">附加:延伸至Trie </a></li><li id="6fe8" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><a class="ae kv" href="https://medium.com/p/13cdabd77adc/#185d" rel="noopener">附加:有向无环图(DAG) </a></li></ul></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><h1 id="c220" class="ml mm iq bd mn mo oa mq mr ms ob mu mv jw oc jx mx jz od ka mz kc oe kd nb nc bi translated">树的基础和术语</h1><p id="f5ab" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf of lh li lj og ll lm ln oh lp lq lr ij bi translated">树是分层存储数据的非线性数据结构，由通过<strong class="ky ir">边</strong>连接的<strong class="ky ir">节点</strong>组成。例如，在家谱中，一个节点代表一个人，一条边代表两个节点之间的关系。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/890b4519cb82c8553a08e8ac783d8a86.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/format:webp/1*_2NfB02GfazOSu5m2qQjWA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图1:树的例子——作者的图片</p></figure><p id="f1a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">了解了构成树的组件后，有几个术语可以扩展到这些组件，</p><ul class=""><li id="2c8a" class="nd ne iq ky b kz la lc ld lf oj lj ok ln ol lr nk nl nm nn bi translated"><strong class="ky ir">根</strong>:没有任何父节点，整棵树都源于它的节点。在图1中，根是节点<code class="fe ls lt lu lv b">a</code></li><li id="5a06" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><strong class="ky ir">叶</strong>:没有任何子节点的节点。在图1中，叶节点是节点<code class="fe ls lt lu lv b">c</code>、<code class="fe ls lt lu lv b">d</code>和<code class="fe ls lt lu lv b">e</code></li><li id="060e" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><strong class="ky ir">父节点</strong>:节点的直接前任。在图1中，节点<code class="fe ls lt lu lv b">a</code>是节点<code class="fe ls lt lu lv b">b</code>和<code class="fe ls lt lu lv b">c</code>的父节点</li><li id="2d11" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><strong class="ky ir">子节点</strong>:节点的直接继承者。在图1中，节点<code class="fe ls lt lu lv b">b</code>是节点<code class="fe ls lt lu lv b">a</code>的子节点</li><li id="2ecd" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><strong class="ky ir">祖先</strong>:一个节点的所有前辈。在图1中，节点<code class="fe ls lt lu lv b">a</code>和<code class="fe ls lt lu lv b">b</code>是节点<code class="fe ls lt lu lv b">d</code>的祖先</li><li id="efb1" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><strong class="ky ir">子孙</strong>:一个节点的所有继承者。在图1中，节点<code class="fe ls lt lu lv b">d</code>和<code class="fe ls lt lu lv b">e</code>是节点<code class="fe ls lt lu lv b">b</code>的后代</li><li id="728e" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><strong class="ky ir">兄弟节点</strong>:具有相同父节点的节点。在图1中，节点<code class="fe ls lt lu lv b">d</code>和<code class="fe ls lt lu lv b">e</code>是兄弟节点</li><li id="0919" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><strong class="ky ir">左同级</strong>:节点左侧的同级。在图1中，节点<code class="fe ls lt lu lv b">d</code>是节点<code class="fe ls lt lu lv b">e</code>的左兄弟</li><li id="48b6" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><strong class="ky ir">右同级</strong>:节点右侧的同级。在图1中，节点<code class="fe ls lt lu lv b">e</code>是节点<code class="fe ls lt lu lv b">d</code>的右兄弟</li><li id="df19" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><strong class="ky ir">深度</strong>:从节点到根的路径长度。在图1中，节点<code class="fe ls lt lu lv b">b</code>的深度是2，节点<code class="fe ls lt lu lv b">d</code>的深度是3</li><li id="bfec" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><strong class="ky ir">高度/最大深度</strong>:根到叶节点的最大深度。在图1中，树的高度是3</li></ul></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><h1 id="8552" class="ml mm iq bd mn mo oa mq mr ms ob mu mv jw oc jx mx jz od ka mz kc oe kd nb nc bi translated">大树设置</h1><p id="b9db" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf of lh li lj og ll lm ln oh lp lq lr ij bi translated">大树很容易设置，只需在终端上运行以下命令。</p><pre class="kg kh ki kj gt om lv on bn oo op bi"><span id="afca" class="oq mm iq lv b be or os l ot ou">$ pip install bigtree</span></pre><p id="9f8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想要将树导出到图像，请改为在终端上运行以下命令。</p><pre class="kg kh ki kj gt om lv on bn oo op bi"><span id="184d" class="oq mm iq lv b be or os l ot ou">$ pip install 'bigtree[image]'</span></pre><p id="f962" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事不宜迟，让我们开始实现树吧！</p><h1 id="3e14" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">构建树</h1><p id="6275" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf of lh li lj og ll lm ln oh lp lq lr ij bi translated">要构造树，首先要定义节点，通过指定节点的<code class="fe ls lt lu lv b">parent</code>和<code class="fe ls lt lu lv b">children</code>来链接节点。</p><p id="0de8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，要构建一个家族树，</p><pre class="kg kh ki kj gt om lv on bn oo op bi"><span id="e0cc" class="oq mm iq lv b be or os l ot ou">from bigtree import Node, print_tree<br/><br/>a = Node("a", age=90)<br/>b = Node("b", age=65, parent=a)<br/>c = Node("c", age=60, parent=a)<br/><br/>a.children<br/># (Node(/a/b, age=65), Node(/a/c, age=60))<br/><br/>a.depth, b.depth<br/># (1, 2)<br/><br/>a.max_depth<br/># 2<br/><br/>print_tree(a, attr_list=["age"])<br/>"""<br/>a [age=90]<br/>├── b [age=65]<br/>└── c [age=60]<br/>"""</span></pre><p id="c3e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我们用3行代码将节点<code class="fe ls lt lu lv b">b</code>和<code class="fe ls lt lu lv b">c</code>定义为节点<code class="fe ls lt lu lv b">a</code>的子节点。我们还可以添加属性，比如节点的<code class="fe ls lt lu lv b">age</code>属性。要查看树结构，我们可以使用<code class="fe ls lt lu lv b">print_tree</code>方法。</p><p id="b166" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还可以查询上一节中提到的节点的<code class="fe ls lt lu lv b">root</code>、<code class="fe ls lt lu lv b">leaves</code>、<code class="fe ls lt lu lv b">parent</code>、<code class="fe ls lt lu lv b">children</code>、<code class="fe ls lt lu lv b">ancestors</code>、<code class="fe ls lt lu lv b">descendants</code>、<code class="fe ls lt lu lv b">siblings</code>、<code class="fe ls lt lu lv b">left_sibling</code>、<code class="fe ls lt lu lv b">right_sibling</code>、<code class="fe ls lt lu lv b">depth</code>、<code class="fe ls lt lu lv b">max_depth</code>。</p><blockquote class="lw"><p id="0518" class="lx ly iq bd lz ma mb mc md me mf lr dk translated">上述定义每个节点和边的方法可能是手动的和繁琐的。用列表、字典和熊猫数据框架构建树还有其他方法！</p></blockquote><p id="c4f9" class="pw-post-body-paragraph kw kx iq ky b kz mg jr lb lc mh ju le lf mi lh li lj mj ll lm ln mk lp lq lr ij bi translated">如果没有节点属性，构建树的最简单方法是使用Python列表和<code class="fe ls lt lu lv b">list_to_tree</code>方法。</p><pre class="kg kh ki kj gt om lv on bn oo op bi"><span id="b965" class="oq mm iq lv b be or os l ot ou">from bigtree import list_to_tree, print_tree<br/><br/>path_list = ["a/b/d", "a/b/e", "a/c"]<br/><br/>root = list_to_tree(path_list)<br/><br/>print_tree(root)<br/>"""<br/>a<br/>├── b<br/>│   ├── d<br/>│   └── e<br/>└── c<br/>"""</span></pre><p id="397c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果有节点属性，建议用字典或pandas DataFrame构造一棵树，分别用<code class="fe ls lt lu lv b">dict_to_tree</code>和<code class="fe ls lt lu lv b">dataframe_to_tree</code>方法。</p><pre class="kg kh ki kj gt om lv on bn oo op bi"><span id="a7e4" class="oq mm iq lv b be or os l ot ou">from bigtree import dict_to_tree, print_tree<br/><br/>path_dict = {<br/>    "a": {"age": 90},<br/>    "a/b": {"age": 65},<br/>    "a/c": {"age": 60},<br/>    "a/b/d": {"age": 40},<br/>    "a/b/e": {"age": 35},<br/>}<br/>root = dict_to_tree(path_dict)<br/><br/>print_tree(root, attr_list=["age"])<br/>"""<br/>a [age=90]<br/>├── b [age=65]<br/>│   ├── d [age=40]<br/>│   └── e [age=35]<br/>└── c [age=60]<br/>"""</span></pre><pre class="ov om lv on bn oo op bi"><span id="b3fb" class="oq mm iq lv b be or os l ot ou">from bigtree import dataframe_to_tree, print_tree<br/><br/>path_data = pd.DataFrame(<br/>    [<br/>        ["a", 90],<br/>        ["a/b", 65],<br/>        ["a/c", 60],<br/>        ["a/b/d", 40],<br/>        ["a/b/e", 35],<br/>    ],<br/>    columns=["PATH", "age"],<br/>)<br/>root = dataframe_to_tree(path_data)<br/><br/>print_tree(root, attr_list=["age"])<br/>"""<br/>a [age=90]<br/>├── b [age=65]<br/>│   ├── d [age=40]<br/>│   └── e [age=35]<br/>└── c [age=60]<br/>"""</span></pre><p id="a624" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更多节点属性和方法以及其他数据结构到树的方法，请参考<code class="fe ls lt lu lv b"><a class="ae kv" href="https://bigtree.readthedocs.io" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">bigtree</strong></a></code> <a class="ae kv" href="https://bigtree.readthedocs.io" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> </strong>文档</a>。</p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><h1 id="509b" class="ml mm iq bd mn mo oa mq mr ms ob mu mv jw oc jx mx jz od ka mz kc oe kd nb nc bi translated">树遍历算法</h1><p id="95ee" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf of lh li lj og ll lm ln oh lp lq lr ij bi translated">有两种类型的树遍历，深度优先搜索(DFS)和宽度优先搜索(BFS)，</p><ul class=""><li id="dd2c" class="nd ne iq ky b kz la lc ld lf oj lj ok ln ol lr nk nl nm nn bi translated">深度优先搜索从根开始，在移动到下一个分支之前，探索每个分支到它的叶节点</li><li id="d256" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">广度优先搜索从根节点开始，探索每个子节点，并对每个节点递归地这样做</li></ul><h2 id="3a81" class="ow mm iq bd mn ox oy dn mr oz pa dp mv lf pb pc mx lj pd pe mz ln pf pg nb ph bi translated">前序遍历(DFS，NLR)</h2><p id="380c" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf of lh li lj og ll lm ln oh lp lq lr ij bi translated">前序遍历是一种深度优先搜索(DFS)方法，</p><ol class=""><li id="5270" class="nd ne iq ky b kz la lc ld lf oj lj ok ln ol lr pi nl nm nn bi translated">访问当前节点(N)</li><li id="2f92" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr pi nl nm nn bi translated">递归遍历当前节点的左子树(L)</li><li id="3833" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr pi nl nm nn bi translated">递归遍历当前节点的右子树(R)</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/fca2151f502a928592169b61f67c2f1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*UgvWZDjntuHm2cc4M6Skew.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2:树的例子——作者的图片</p></figure><p id="2ad8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于前序遍历，它将按顺序遍历图2中的树，</p><pre class="kg kh ki kj gt om lv pk pl aw pm bi"><span id="c75d" class="ow mm iq lv b gy pn po l pp ou">['a', 'b', 'd', 'e', 'g', 'h', 'c', 'f']</span></pre><h2 id="2891" class="ow mm iq bd mn ox oy dn mr oz pa dp mv lf pb pc mx lj pd pe mz ln pf pg nb ph bi translated">后序遍历(DFS，LRN)</h2><p id="b8f7" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf of lh li lj og ll lm ln oh lp lq lr ij bi translated">后序遍历是一种深度优先搜索(DFS)方法，</p><ol class=""><li id="7711" class="nd ne iq ky b kz la lc ld lf oj lj ok ln ol lr pi nl nm nn bi translated">递归遍历当前节点的左子树(L)</li><li id="7901" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr pi nl nm nn bi translated">递归遍历当前节点的右子树(R)</li><li id="5cc0" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr pi nl nm nn bi translated">访问当前节点(N)</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/fca2151f502a928592169b61f67c2f1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*UgvWZDjntuHm2cc4M6Skew.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图3:树的例子——作者的图片</p></figure><p id="f137" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于后序遍历，它将按顺序遍历图3中的树，</p><pre class="kg kh ki kj gt om lv pk pl aw pm bi"><span id="e1bb" class="ow mm iq lv b gy pn po l pp ou">['d', 'g', 'h', 'e', 'b', 'f', 'c', 'a']</span></pre><h2 id="ec6b" class="ow mm iq bd mn ox oy dn mr oz pa dp mv lf pb pc mx lj pd pe mz ln pf pg nb ph bi translated">层级顺序遍历(BFS)</h2><p id="e362" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf of lh li lj og ll lm ln oh lp lq lr ij bi translated">层次顺序遍历是一种广度优先的搜索方法。</p><p id="9da4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于级别顺序遍历，它将按照顺序遍历图3中的树，</p><pre class="kg kh ki kj gt om lv pk pl aw pm bi"><span id="8bbc" class="ow mm iq lv b gy pn po l pp ou">['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']</span></pre><h2 id="65c2" class="ow mm iq bd mn ox oy dn mr oz pa dp mv lf pb pc mx lj pd pe mz ln pf pg nb ph bi translated">级别顺序组遍历(BFS)</h2><p id="8841" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf of lh li lj og ll lm ln oh lp lq lr ij bi translated">级别顺序组遍历类似于级别顺序遍历，区别在于每一级都将作为嵌套列表返回；<code class="fe ls lt lu lv b">list[idx]</code>表示深度<code class="fe ls lt lu lv b">idx + 1</code>中的项目。</p><p id="333a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于级别顺序组遍历，它将按照顺序遍历图3中的树，</p><pre class="kg kh ki kj gt om lv pk pl aw pm bi"><span id="4d84" class="ow mm iq lv b gy pn po l pp ou">[['a'], ['b', 'c'], ['d', 'e', 'f'], ['g', 'h']]</span></pre><p id="ab62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意还有<strong class="ky ir">按序遍历(DFS，LNR) </strong>只适用于二叉树，不适用于类属树。</p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><h1 id="1ada" class="ml mm iq bd mn mo oa mq mr ms ob mu mv jw oc jx mx jz od ka mz kc oe kd nb nc bi translated">树搜索方法</h1><p id="f8c0" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf of lh li lj og ll lm ln oh lp lq lr ij bi translated">我们可以使用树搜索方法来获得满足特定标准的一个或多个节点，方法<code class="fe ls lt lu lv b">find</code>用于一个节点，方法<code class="fe ls lt lu lv b">findall</code>用于多个节点。</p><pre class="kg kh ki kj gt om lv on bn oo op bi"><span id="2eca" class="oq mm iq lv b be or os l ot ou">from bigtree import Node, print_tree, find, findall<br/><br/>root = Node("a", age=90)<br/>b = Node("b", age=65, parent=root)<br/>c = Node("c", age=60, parent=root)<br/>d = Node("d", age=40, parent=b)<br/><br/>print_tree(root, attr_list=["age"])<br/>"""<br/>a [age=90]<br/>├── b [age=65]<br/>│   └── d [age=40]<br/>└── c [age=60]<br/>"""<br/><br/>find(root, lambda node: node.age == 65)<br/># Node(/a/b, age=65)<br/><br/>findall(root, lambda node: node.age &gt;= 60)<br/># (Node(/a, age=90), Node(/a/b, age=65), Node(/a/c, age=60))</span></pre><p id="d531" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于没有定义lambda函数的通用搜索方法，有一些内置方法，</p><ul class=""><li id="1052" class="nd ne iq ky b kz la lc ld lf oj lj ok ln ol lr nk nl nm nn bi translated"><code class="fe ls lt lu lv b"><strong class="ky ir">find_attr</strong></code>和<code class="fe ls lt lu lv b"><strong class="ky ir">find_attrs</strong></code>:根据属性查找一个/多个节点</li><li id="de8d" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><code class="fe ls lt lu lv b"><strong class="ky ir">find_name</strong></code>和<code class="fe ls lt lu lv b"><strong class="ky ir">find_names</strong></code>:根据名称查找一个/多个节点</li><li id="ed21" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><code class="fe ls lt lu lv b"><strong class="ky ir">find_path</strong></code>、<code class="fe ls lt lu lv b"><strong class="ky ir">find_paths</strong></code>:通过完整或部分路径查找一个或多个节点</li><li id="a4f6" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><code class="fe ls lt lu lv b"><strong class="ky ir">find_full_path</strong></code>:根据节点的完整路径找到一个节点</li><li id="c242" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><code class="fe ls lt lu lv b"><strong class="ky ir">find_children</strong></code>:通过名称查找节点的子节点，无需搜索整个树</li></ul></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><h1 id="4bd0" class="ml mm iq bd mn mo oa mq mr ms ob mu mv jw oc jx mx jz od ka mz kc oe kd nb nc bi translated">树木改造方法</h1><p id="afab" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf of lh li lj og ll lm ln oh lp lq lr ij bi translated"><code class="fe ls lt lu lv b"><strong class="ky ir">bigtree</strong></code> <strong class="ky ir"> </strong>支持节点必须从一个位置移动或复制到一个目的地的情况。例如，我们可以在待办事项列表实现中移动和重新排序节点。</p><pre class="kg kh ki kj gt om lv on bn oo op bi"><span id="59d1" class="oq mm iq lv b be or os l ot ou">from bigtree import Node, shift_nodes, print_tree<br/><br/>root = Node("List")<br/>groceries = Node("Groceries", parent=root)<br/>urgent = Node("Urgent", parent=root)<br/>groceries_milk = Node("Milk", parent=groceries)<br/><br/>shift_nodes(<br/>    root,<br/>    from_paths=["Groceries/Milk"],<br/>    to_paths=["Urgent/Milk"],<br/>)<br/><br/>print_tree(root)<br/># List<br/># ├── Groceries<br/># └── Urgent<br/>#     └── Milk</span></pre><p id="dd25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有其他树修改方法，</p><ul class=""><li id="3c59" class="nd ne iq ky b kz la lc ld lf oj lj ok ln ol lr nk nl nm nn bi translated"><code class="fe ls lt lu lv b"><strong class="ky ir">copy_nodes</strong></code>:将节点从一个位置复制到目的地，节点将存在于两个位置</li><li id="fe6d" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><code class="fe ls lt lu lv b"><strong class="ky ir">copy_nodes_from_tree_to_tree</strong></code>:将节点从一棵树复制到另一棵树，节点将存在于两棵树中</li></ul></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><h1 id="2251" class="ml mm iq bd mn mo oa mq mr ms ob mu mv jw oc jx mx jz od ka mz kc oe kd nb nc bi translated">导出树</h1><p id="5ca4" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf of lh li lj og ll lm ln oh lp lq lr ij bi translated">正如文章开头提到的，<code class="fe ls lt lu lv b"><strong class="ky ir">bigtree</strong></code> <strong class="ky ir"> </strong>与Python字典和pandas DataFrame无缝集成。可以将树导出到字典、嵌套字典、pandas DataFrame和更多格式。</p><h2 id="36f3" class="ow mm iq bd mn ox oy dn mr oz pa dp mv lf pb pc mx lj pd pe mz ln pf pg nb ph bi translated">将树打印到控制台</h2><p id="b87f" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf of lh li lj og ll lm ln oh lp lq lr ij bi translated">给定一个树，我们可以使用<code class="fe ls lt lu lv b">print_tree</code>将树打印到控制台，并且能够指定要打印的属性和树的样式。更多定制也可在<code class="fe ls lt lu lv b"><a class="ae kv" href="https://bigtree.readthedocs.io" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">bigtree</strong></a></code> <a class="ae kv" href="https://bigtree.readthedocs.io" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> </strong>文档</a>中获得。</p><pre class="kg kh ki kj gt om lv on bn oo op bi"><span id="5c56" class="oq mm iq lv b be or os l ot ou">from bigtree import print_tree<br/><br/>print_tree(root, attr_list=["age"], style="ascii")<br/>"""<br/>a [age=90]<br/>|-- b [age=65]<br/>|   |-- d [age=40]<br/>|   +-- e [age=35]<br/>|       |-- g [age=10]<br/>|       +-- h [age=6]<br/>+-- c [age=60]<br/>    +-- f [age=38]<br/>"""</span></pre><p id="68ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于一个生成器的方法，可以用<code class="fe ls lt lu lv b"><strong class="ky ir">yield_tree</strong></code> <strong class="ky ir"> </strong>的方法代替。</p><h2 id="6000" class="ow mm iq bd mn ox oy dn mr oz pa dp mv lf pb pc mx lj pd pe mz ln pf pg nb ph bi translated">将树导出到字典</h2><p id="3a23" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf of lh li lj og ll lm ln oh lp lq lr ij bi translated">给定一个树，我们可以使用<code class="fe ls lt lu lv b">tree_to_dict</code>将树导出到一个字典中，能够存储所有属性的名称，或者使用字典将树属性映射到自定义属性名称。</p><pre class="kg kh ki kj gt om lv on bn oo op bi"><span id="96a8" class="oq mm iq lv b be or os l ot ou">from bigtree import tree_to_dict<br/><br/>tree_to_dict(root, all_attrs=True)<br/># {<br/>#     '/a': {'name': 'a', 'age': 90},<br/>#     '/a/b': {'name': 'b', 'age': 65},<br/>#     '/a/b/d': {'name': 'd', 'age': 40},<br/>#     '/a/b/e': {'name': 'e', 'age': 35},<br/>#     '/a/b/e/g': {'name': 'g', 'age': 10},<br/>#     '/a/b/e/h': {'name': 'h', 'age': 6},<br/>#     '/a/c': {'name': 'c', 'age': 60},<br/>#     '/a/c/f': {'name': 'f', 'age': 38}<br/># }<br/><br/>tree_to_dict(root, attr_dict={"age": "AGE"})<br/># {<br/>#     '/a': {'name': 'a', 'AGE': 90},<br/>#     '/a/b': {'name': 'b', 'AGE': 65},<br/>#     '/a/b/d': {'name': 'd', 'AGE': 40},<br/>#     '/a/b/e': {'name': 'e', 'AGE': 35},<br/>#     '/a/b/e/g': {'name': 'g', 'AGE': 10},<br/>#     '/a/b/e/h': {'name': 'h', 'AGE': 6},<br/>#     '/a/c': {'name': 'c', 'AGE': 60},<br/>#     '/a/c/f': {'name': 'f', 'AGE': 38}<br/># }</span></pre><p id="c55a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe ls lt lu lv b">dict_to_tree</code>方法可以重新构建原始树！</p><h2 id="c78a" class="ow mm iq bd mn ox oy dn mr oz pa dp mv lf pb pc mx lj pd pe mz ln pf pg nb ph bi translated">将树导出到数据框架</h2><p id="d69e" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf of lh li lj og ll lm ln oh lp lq lr ij bi translated">给定一个树，我们可以使用<code class="fe ls lt lu lv b">tree_to_dataframe</code>将树导出到一个数据帧，能够将所有属性存储为列，名称不变，或者使用字典将树属性映射到定制的列名。</p><pre class="kg kh ki kj gt om lv on bn oo op bi"><span id="5bf9" class="oq mm iq lv b be or os l ot ou">from bigtree import tree_to_dataframe<br/><br/>tree_to_dataframe(root, all_attrs=True)<br/>#        path name  age<br/># 0        /a    a   90<br/># 1      /a/b    b   65<br/># 2    /a/b/d    d   40<br/># 3    /a/b/e    e   35<br/># 4  /a/b/e/g    g   10<br/># 5  /a/b/e/h    h    6<br/># 6      /a/c    c   60<br/># 7    /a/c/f    f   38</span></pre><p id="04ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe ls lt lu lv b">dataframe_to_tree</code>方法可以重新构建原始树！</p><h2 id="7822" class="ow mm iq bd mn ox oy dn mr oz pa dp mv lf pb pc mx lj pd pe mz ln pf pg nb ph bi translated">将树导出为图像(等等)</h2><p id="0536" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf of lh li lj og ll lm ln oh lp lq lr ij bi translated">给定一棵树，我们可以使用<code class="fe ls lt lu lv b">tree_to_dot</code>将树导出到图像或其他图形或文件中。这个用的是引擎盖下的<code class="fe ls lt lu lv b"><a class="ae kv" href="https://pypi.org/project/pydot/" rel="noopener ugc nofollow" target="_blank">pydot</a></code>，用的是点语言，可以和<a class="ae kv" href="https://www.graphviz.org" rel="noopener ugc nofollow" target="_blank"> Graphviz </a>接口。</p><pre class="kg kh ki kj gt om lv on bn oo op bi"><span id="33c4" class="oq mm iq lv b be or os l ot ou">from bigtree import tree_to_dot<br/><br/>graph = tree_to_dot(root)<br/>graph.write_png("tree.png")<br/>graph.write_dot("tree.dot")<br/>graph.to_string()</span></pre><p id="e96b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码片段中，<code class="fe ls lt lu lv b">graph</code>属于<code class="fe ls lt lu lv b">pydot.Dot</code>数据类型，它内置了写入dot、PNG、SVG等文件格式的实现。输出类似于图3。</p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><h1 id="4d13" class="ml mm iq bd mn mo oa mq mr ms ob mu mv jw oc jx mx jz od ka mz kc oe kd nb nc bi translated">附加:通过<code class="fe ls lt lu lv b"><strong class="ak">bigtree</strong></code>使用待办事项列表</h1><p id="be69" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf of lh li lj og ll lm ln oh lp lq lr ij bi translated">如果在这一点上，你仍然想知道你可以用<code class="fe ls lt lu lv b"><strong class="ky ir">bigtree</strong></code>、<code class="fe ls lt lu lv b"><strong class="ky ir">bigtree</strong></code>、<strong class="ky ir">、</strong>做些什么，它们带有一个内置的待办事项工作流，能够从JSON文件导入和导出。</p><p id="1801" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个待办事项列表实现有三个级别——应用名称、列表名称和项目名称。您可以将列表添加到应用程序或将项目添加到列表。举个例子，</p><pre class="kg kh ki kj gt om lv on bn oo op bi"><span id="6489" class="oq mm iq lv b be or os l ot ou">from bigtree import AppToDo<br/><br/>app = AppToDo("To-Do App")<br/>app.add_item(item_name="Homework 1", list_name="School")<br/>app.add_item(item_name=["Milk", "Bread"], list_name="Groceries", description="Urgent")<br/>app.add_item(item_name="Cook")<br/><br/>app.show()<br/># To Do App<br/># ├── School<br/># │   └── Homework 1<br/># ├── Groceries<br/># │   ├── Milk [description=Urgent]<br/># │   └── Bread [description=Urgent]<br/># └── General<br/>#     └── Cook<br/><br/>app.save("list.json")<br/>app2 = AppToDo.load("list.json")</span></pre><p id="b3e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，</p><ul class=""><li id="0065" class="nd ne iq ky b kz la lc ld lf oj lj ok ln ol lr nk nl nm nn bi translated">应用名称指<code class="fe ls lt lu lv b">To-Do App</code></li><li id="bb0c" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">列表名称指<code class="fe ls lt lu lv b">School</code>、<code class="fe ls lt lu lv b">Groceries</code>、<code class="fe ls lt lu lv b">General</code></li><li id="c645" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">项目名称是指<code class="fe ls lt lu lv b">Homework 1</code>、<code class="fe ls lt lu lv b">Milk</code>、<code class="fe ls lt lu lv b">Bread</code>和<code class="fe ls lt lu lv b">Cook</code></li></ul><h1 id="660e" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">附加:延伸至Trie</h1><p id="60ab" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf of lh li lj og ll lm ln oh lp lq lr ij bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Trie" rel="noopener ugc nofollow" target="_blank"> Trie </a>是一种k元搜索树，用于存储和搜索集合中的特定关键字，它源自单词re <strong class="ky ir"> TRIE </strong> val。Trie可用于按字母顺序对字符串集合进行排序，或者搜索某个字符串是否有前缀。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/c4d4df0d6bfac903e5904a2b60e70ccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*gLqY1USLLsDr_7nnykBJcg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图Trie示例—作者提供的图片</p></figure><p id="b0e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了用Trie扩展<code class="fe ls lt lu lv b"><strong class="ky ir">bigtree</strong></code> <strong class="ky ir"> </strong>，我们可以给每个单词加上前导符号<code class="fe ls lt lu lv b"><strong class="ky ir">^</strong></code>和尾随符号<code class="fe ls lt lu lv b"><strong class="ky ir">$</strong></code>，用树搜索的方法找到一个带有<code class="fe ls lt lu lv b"><strong class="ky ir">find_path</strong></code>的特定单词或子单词。Trie可以这样构造，</p><pre class="kg kh ki kj gt om lv on bn oo op bi"><span id="e26a" class="oq mm iq lv b be or os l ot ou">from bigtree import list_to_tree, find_path<br/><br/>bag_of_words = ["ant", "and", "angry", "buoy", "buoyant"]<br/>list_of_paths = ["/".join(["^"] + list(x) + ["$"])  for x in bag_of_words]<br/><br/>list_of_paths<br/># [<br/>#     "^/a/n/t/$",<br/>#     "^/a/n/d/$",<br/>#     "^/a/n/g/r/y/$",<br/>#     "^/b/o/y/$",<br/>#     "^/b/o/y/a/n/t/$"<br/># ]<br/><br/>trie = list_to_tree(list_of_paths)<br/>find_path(trie, "/".join(list("^boy$")))</span></pre><p id="6fdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果使用<code class="fe ls lt lu lv b"><strong class="ky ir">tree_to_dot</strong></code> <strong class="ky ir"> </strong>方法导出，上面的代码片段会产生图4中的图像。</p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><h1 id="185d" class="ml mm iq bd mn mo oa mq mr ms ob mu mv jw oc jx mx jz od ka mz kc oe kd nb nc bi translated">附加:有向无环图(DAG)</h1><p id="6286" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf of lh li lj og ll lm ln oh lp lq lr ij bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" rel="noopener ugc nofollow" target="_blank">有向无环图(DAG) </a>是一种图形数据结构，其中每个节点可以有多个父节点。树被认为是图的限制形式。这种差异导致以下差异，</p><ul class=""><li id="4c64" class="nd ne iq ky b kz la lc ld lf oj lj ok ln ol lr nk nl nm nn bi translated">根:DAG中没有根的概念，因为一个节点可以有多个父节点</li><li id="e93f" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><strong class="ky ir">深度</strong>:DAG中没有深度的概念，因为没有根节点</li><li id="e766" class="nd ne iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><strong class="ky ir">高度/最大深度</strong>:DAG中没有高度的概念，因为没有根节点</li></ul><p id="9eb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Dag最适合用于表示工作流，因为工作流具有一定的顺序(定向)，并且不会无限重复；没有循环(非循环)。</p><p id="ec3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与树类似，<code class="fe ls lt lu lv b"><strong class="ky ir">bigtree</strong></code> <strong class="ky ir"> </strong>中的Dag可以手动构造，分别使用<code class="fe ls lt lu lv b"><strong class="ky ir">list_to_dag</strong></code>、<code class="fe ls lt lu lv b"><strong class="ky ir">dict_to_dag</strong></code>和<code class="fe ls lt lu lv b"><strong class="ky ir">dataframe_to_dag</strong></code> <strong class="ky ir"> </strong>方法从Python列表、字典或pandas数据帧中构造。</p><pre class="kg kh ki kj gt om lv on bn oo op bi"><span id="28ba" class="oq mm iq lv b be or os l ot ou">from bigtree import DAGNode, dag_to_dot<br/><br/>a = DAGNode("Ingest Data from Source A")<br/>b = DAGNode("Ingest Data from Source B")<br/>c = DAGNode("Clean data", parents=[a, b])<br/>d = DAGNode("Feature Engineering", parents=[c])<br/><br/>graph = dag_to_dot(a, node_colour="gold")<br/>graph.write_png("dag.png")</span></pre><p id="bdcd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码片段产生了下图，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/63fb5b36394885317cb2b17e81db4ea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*Xr03IaoXe0vox4__yg-rNw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图5:作者的DAG图像示例</p></figure></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><p id="e6e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望你已经更好地理解了树结构以及如何使用<code class="fe ls lt lu lv b"><strong class="ky ir">bigtree</strong></code> <strong class="ky ir"> </strong> Python包来实现它们。如果有任何建议、反馈、错误或新的用例，请随时联系我们！</p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><h1 id="c870" class="ml mm iq bd mn mo oa mq mr ms ob mu mv jw oc jx mx jz od ka mz kc oe kd nb nc bi translated">相关链接</h1><p id="b025" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf of lh li lj og ll lm ln oh lp lq lr ij bi translated"><code class="fe ls lt lu lv b"><strong class="ky ir">bigtree</strong></code> <strong class="ky ir"> </strong>文档:<a class="ae kv" href="https://bigtree.readthedocs.io" rel="noopener ugc nofollow" target="_blank">https://bigtree . readthedocs . io</a></p><p id="97ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b"><strong class="ky ir">bigtree</strong></code> <strong class="ky ir"> </strong>官方GitHub:<a class="ae kv" href="https://github.com/kayjan/bigtree" rel="noopener ugc nofollow" target="_blank">https://github.com/kayjan/bigtree</a></p></div></div>    
</body>
</html>