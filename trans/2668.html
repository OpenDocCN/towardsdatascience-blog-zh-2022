<html>
<head>
<title>3 Ultimate Ways To Find Unique Records In SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SQL中查找唯一记录的3种终极方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3-ultimate-ways-to-find-unique-records-in-sql-6ddf8ae567b0#2022-06-09">https://towardsdatascience.com/3-ultimate-ways-to-find-unique-records-in-sql-6ddf8ae567b0#2022-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="7089" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">数据科学</h2><div class=""/><div class=""><h2 id="9fb7" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">停止使用DISTINCT！开始使用这些快速的替代方法来避免混淆！</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/20dcc990c2d90f068debf2ef9a9ab0fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NC6dxon1LPoY_aT-AGLjlQ.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@luiscortestamez?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">路易斯·科尔特斯</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="0b82" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">不使用</strong> <code class="fe me mf mg mh b"><strong class="lk jd">DISTINCT</strong></code> <strong class="lk jd">关键字获取唯一记录！</strong>🏆</p><p id="6b83" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在您的数据分析项目中，每当您需要从数据库中提取唯一的记录时，一个简单的答案就是使用<code class="fe me mf mg mh b"><strong class="lk jd">DISTINCT</strong></code>！！</p><p id="cd79" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">毫无疑问，DISTINCT是为返回唯一行而设计的，它做得很好。但是，它不会告诉您所使用的连接和过滤器是正确的还是不正确的，这实际上是重复的原因。</p><p id="d9e1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我总结了3个最好的、安全的和省时的替代方法，它们在不同的doe下返回相同的输出，并且仍然保持代码整洁和易于维护。💯</p><p id="b5b5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以使用下面的索引跳到你最喜欢的部分。</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="82b4" class="mm mn it mh b gy mo mp l mq mr"><strong class="mh jd">· </strong><a class="ae lh" href="#d286" rel="noopener ugc nofollow"><strong class="mh jd">UNION()</strong></a><strong class="mh jd"><br/>· </strong><a class="ae lh" href="#5b09" rel="noopener ugc nofollow"><strong class="mh jd">INTERSECT()</strong></a><strong class="mh jd"><br/>· </strong><a class="ae lh" href="#3f9b" rel="noopener ugc nofollow"><strong class="mh jd">ROW_NUMBER()</strong></a><strong class="mh jd"><br/>· </strong><a class="ae lh" href="#421a" rel="noopener ugc nofollow"><strong class="mh jd">GROUP BY</strong></a></span></pre><blockquote class="ms mt mu"><p id="2b58" class="li lj mv lk b ll lm kd ln lo lp kg lq mw ls lt lu mx lw lx ly my ma mb mc md im bi translated">📍注意:我使用的是SQLite DB浏览器和自己创建的<a class="ae lh" href="https://github.com/17rsuraj/data-curious/blob/master/TowardsDataScience/Dummy_employees.csv" rel="noopener ugc nofollow" target="_blank"> Dummy_Employees </a>，你可以在我的<a class="ae lh" href="https://github.com/17rsuraj/data-curious/blob/master/TowardsDataScience/Dummy_employees.csv" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> Github </strong> </a> repo上免费获得！</p></blockquote><p id="2f78" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好了，我们开始吧…🚀</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="3cec" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，让我向您展示数据是怎样的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/456fd8e8a989d9577c0f40730ae997c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*RhLkC4Lk-Duzr96zN6I3cQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">虚拟员工数据集|作者图片</p></figure><p id="1b28" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是一个简单的10x4数据集，是我在文章<a class="ae lh" rel="noopener" target="_blank" href="/faker-an-amazing-and-insanely-useful-python-library-b313a60bdabf"> <strong class="lk jd"> Faker中创建的:一个惊人且非常有用的Python库</strong> </a> <strong class="lk jd">。</strong>📚</p><p id="f7eb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上图中以蓝色和红色突出显示的行在数据集中是重复的。</p><p id="65f2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">📚您可以使用这个<a class="ae lh" href="https://github.com/17rsuraj/data-curious/blob/master/TowardsDataScience/employees_cost.sqlite3" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> SQLite数据库</strong> </a>来跟踪本文中的查询。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="62c7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我上一篇文章<a class="ae lh" rel="noopener" target="_blank" href="/5-practical-sql-queries-you-should-know-in-2022-11b428560a30"><strong class="lk jd">2022</strong></a>你应该知道的5个实用SQL查询中提到，在寻找唯一记录之前，你必须定义哪一列或者哪几列的组合构成了唯一行。</p><p id="f53e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于在单个列中查找唯一值，DISTINCT总是更方便。但是，对于从数据集中检索唯一的行，这些替代方法可以保持代码的整洁和高效。</p><p id="7edd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，让我们使用DISTINCT从数据集中获得<em class="mv">雇员id、雇员姓名</em>和<em class="mv">部门</em>的唯一组合。</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="88d8" class="mm mn it mh b gy mo mp l mq mr">SELECT <strong class="mh jd">DISTINCT</strong> employee_id,<br/>                employee_name,<br/>                department<br/>FROM Dummy_employees</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/0977fe139780dbf84266d6fb3a22b99e.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*R1d8dnIepSwITtnpo_Wgbw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">使用DISTINCT | Image by Author选择唯一值</p></figure><p id="378f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如预期的那样，它只返回属于<em class="mv">employee _ id</em>T0】和<code class="fe me mf mg mh b">212</code>的重复行的一个实例，最终得到8行。</p><p id="1517" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，让我们看看如何在不专门使用DISTINCT的情况下获得完全相同的结果。</p><h1 id="d286" class="ni mn it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">联合()</h1><p id="c440" class="pw-post-body-paragraph li lj it lk b ll nz kd ln lo oa kg lq lr ob lt lu lv oc lx ly lz od mb mc md im bi translated">在SQL中，<code class="fe me mf mg mh b">UNION</code>是一个运算符，用于组合两个<code class="fe me mf mg mh b">SELECT</code>语句的结果。类似于对器械包的<code class="fe me mf mg mh b">UNION</code>操作。</p><p id="1a14" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，它还会删除结果数据集中多次出现的行，只保留每行的一次出现。✅</p><p id="e7c8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你所需要做的就是写两条完全相同的<code class="fe me mf mg mh b">SELECT</code>语句，并用操作符<code class="fe me mf mg mh b">UNION</code>将它们连接起来，如下所示。</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="7332" class="mm mn it mh b gy mo mp l mq mr">SELECT employee_id,<br/>       employee_name,<br/>       department<br/>FROM Dummy_employees</span><span id="e148" class="mm mn it mh b gy oe mp l mq mr"><strong class="mh jd">UNION</strong></span><span id="4e54" class="mm mn it mh b gy oe mp l mq mr">SELECT employee_id,<br/>       employee_name,<br/>       department<br/>FROM Dummy_employees</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/12d5cac4fc8451dd455c3602ee78bf64.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*wLCljyg805h3AhHwZUFdNg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">不使用DISTINCT | Image by Author选择唯一的行</p></figure><p id="93ae" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这显示了与DISTINCT相同的输出，只是记录的顺序不同。</p><p id="803a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，让我向您展示一下后端刚刚发生了什么。🛠️</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi of"><img src="../Images/a75c5dddb20308b40d9bbb50690eb292.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qfs2ChAA1ald1_MxKozu8w.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">UNION如何在SQL中删除重复|按作者分类的图片</p></figure><p id="4433" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过这种方式，<code class="fe me mf mg mh b">UNION</code>简单地连接两个单独的<code class="fe me mf mg mh b">SELECT</code>语句的输出，并且只保留重复行的一个实例。</p><p id="b031" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">选择唯一记录的另一个有趣的方法是使用另一个操作符— <code class="fe me mf mg mh b">INTERSECT</code>。</p><h1 id="5b09" class="ni mn it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">相交()</h1><p id="42a1" class="pw-post-body-paragraph li lj it lk b ll nz kd ln lo oa kg lq lr ob lt lu lv oc lx ly lz od mb mc md im bi translated">与前面的操作符类似，<code class="fe me mf mg mh b">INTERSECT</code>也用于连接两个<code class="fe me mf mg mh b">SELECT</code>查询的结果，并且只返回那些在两个<code class="fe me mf mg mh b">SELECT</code>查询的输出中相同的记录。它与两个集合的交集相同。</p><p id="8cc3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">INTERSECT</code>还删除结果数据集中多次出现的行，只保留每行的一次出现。✅</p><p id="1cd0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你需要做的就是写两个完全相同的<code class="fe me mf mg mh b">SELECT</code>语句并用<code class="fe me mf mg mh b">INTERSECT</code>将它们连接起来，如下所示。</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="25f9" class="mm mn it mh b gy mo mp l mq mr">SELECT employee_id,<br/>       employee_name,<br/>       department<br/>FROM Dummy_employees</span><span id="76da" class="mm mn it mh b gy oe mp l mq mr"><strong class="mh jd">INTERSECT</strong></span><span id="6a26" class="mm mn it mh b gy oe mp l mq mr">SELECT employee_id,<br/>       employee_name,<br/>       department<br/>FROM Dummy_employees</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi og"><img src="../Images/b8a9069e15757d6a32c92c4244077603.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*WIBgGY8FKF_rZEXDN6DKpg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">不使用DISTINCT | Image by Author选择唯一的行</p></figure><p id="eaa5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于两个<code class="fe me mf mg mh b">SELECT</code>查询产生相同的输出，连接将产生10行数据。然后根据<code class="fe me mf mg mh b">INTERSECT</code>返回唯一行的固有属性，将只返回一次重复行，最终输出8行。</p><blockquote class="ms mt mu"><p id="c529" class="li lj mv lk b ll lm kd ln lo lp kg lq mw ls lt lu mx lw lx ly my ma mb mc md im bi translated">🚩注意:使用<code class="fe me mf mg mh b">UNION</code>和<code class="fe me mf mg mh b">INTERSECT</code>时，两个SELECT语句中的列数和顺序必须相同。</p></blockquote><p id="e308" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">继续下一步，获取唯一的记录..</p><h1 id="3f9b" class="ni mn it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">ROW_NUMBER()</h1><p id="6841" class="pw-post-body-paragraph li lj it lk b ll nz kd ln lo oa kg lq lr ob lt lu lv oc lx ly lz od mb mc md im bi translated">在SQL中，<code class="fe me mf mg mh b">ROW_NUMBER()</code>是一个窗口函数，它将一个连续的整数分配给结果集分区内的每一行。</p><blockquote class="ms mt mu"><p id="5564" class="li lj mv lk b ll lm kd ln lo lp kg lq mw ls lt lu mx lw lx ly my ma mb mc md im bi translated"><strong class="lk jd">窗口函数</strong>:一个SQL函数，输入值取自<code class="fe me mf mg mh b">SELECT</code>语句结果集中的一行或多行的“窗口”。它使用<code class="fe me mf mg mh b">OVER</code>子句后跟<code class="fe me mf mg mh b">PARTITION BY</code>和<code class="fe me mf mg mh b">ORDER BY</code>子句来创建一个包含一行或多行的窗口。</p></blockquote><p id="ba18" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，在每个分区中，第一行的行号为1。✅</p><p id="f149" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是它的工作原理..</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="7367" class="mm mn it mh b gy mo mp l mq mr">SELECT employee_id,<br/>       employee_name,<br/>       department,<br/>       <strong class="mh jd">ROW_NUMBER() OVER(PARTITION BY employee_name,<br/>                                      department,<br/>                                      employee_id) as row_count</strong><br/>FROM Dummy_employees</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/b149ba8a45f62d10cd7cfa6a93da99cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*p9vvNn1TCUWtO0g43btEew.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">ROW_NUMBER()在SQL | Image中的工作方式(按作者)</p></figure><p id="7945" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如你所看到的，当<em class="mv"> employee_name </em>是<em class="mv"> Abdul </em>和<em class="mv"> Stella </em>时，每个分区中有两行。因此行号2被分配给这些重复行中的每一行。</p><p id="ce19" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，要获得唯一记录，您需要选择行号为1的所有行，即上表中<em class="mv"> row_count </em>的值为1。</p><blockquote class="ms mt mu"><p id="8a94" class="li lj mv lk b ll lm kd ln lo lp kg lq mw ls lt lu mx lw lx ly my ma mb mc md im bi translated">❓然而，这里有一个捕捉！！</p></blockquote><p id="c77b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不能在<code class="fe me mf mg mh b">WHERE</code>子句中使用窗口函数，因为在SQL查询执行中，<code class="fe me mf mg mh b">WHERE</code>子句是在计算窗口函数之前处理的。你可以在Agnieszka 的这篇文章中阅读更多关于SQL查询执行顺序的内容。</p><p id="0a29" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最终，您需要创建一个临时表来存储上述查询的输出，并需要另一个<code class="fe me mf mg mh b">SELECT</code>语句来获得不同的记录。您可以使用<code class="fe me mf mg mh b">WITH</code>子句或<code class="fe me mf mg mh b">CTE</code> s(通用表表达式)来创建临时表。💯</p><p id="b21d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们看看如何从数据集中获得<em class="mv">雇员id、雇员姓名</em>和<em class="mv">部门</em>的唯一组合。</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="70e4" class="mm mn it mh b gy mo mp l mq mr"><strong class="mh jd">WITH temporary_employees</strong> as<br/>(<br/>SELECT <br/>  employee_id,<br/>  employee_name,<br/>  department,<br/>  <strong class="mh jd">ROW_NUMBER() OVER(PARTITION BY employee_name,<br/>                                 department,<br/>                                 employee_id) as row_count</strong><br/>FROM Dummy_employees<br/>)</span><span id="dcea" class="mm mn it mh b gy oe mp l mq mr">SELECT *<br/>FROM temporary_employees<br/><strong class="mh jd">WHERE row_count = 1</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/ba3aff57cfe3c19545bd2b1bf2816b5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*Oze97QMKP3kBIQRfypJY8g.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">使用SQL | Image by Author中的ROW_NUMBER()获取不同的记录</p></figure><p id="beb1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这样，您可以看到只有那些记录出现在具有<code class="fe me mf mg mh b"><strong class="lk jd">row_count = 1</strong></code>的输出中</p><p id="b599" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里，生成最后一列— <em class="mv"> row_count </em>只是为了提供信息。即使不包括该列，查询仍然有效。</p><p id="f0f2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">除了操作符和窗口函数，还有一种简单方便的方法来获得唯一的行— <code class="fe me mf mg mh b">GROUP BY</code></p><h1 id="421a" class="ni mn it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">分组依据</h1><p id="b851" class="pw-post-body-paragraph li lj it lk b ll nz kd ln lo oa kg lq lr ob lt lu lv oc lx ly lz od mb mc md im bi translated">在SQL中，<code class="fe me mf mg mh b">GROUP BY</code>子句用于按一列或多列对行进行分组。经常与<code class="fe me mf mg mh b">COUNT()</code>、<code class="fe me mf mg mh b">MAX()</code>、<code class="fe me mf mg mh b">MIN()</code>、<code class="fe me mf mg mh b">SUM()</code>、<code class="fe me mf mg mh b">AVG()</code>等聚合函数一起使用，得到分组行的聚合计算。</p><p id="6d04" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，可以在没有任何聚合函数的情况下使用它来获得不同的或唯一的记录，如下所示，</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="15dc" class="mm mn it mh b gy mo mp l mq mr">SELECT employee_id,<br/>       employee_name,<br/>       department<br/>FROM Dummy_employees<br/><strong class="mh jd">GROUP BY employee_id,<br/>         employee_name,<br/>         department</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/326c92487eb461c71ff80072d3c0aabd.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*dq1IbXYFxJiLCbd3NVmr8Q.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">使用GROUP BY | Image by Author获取SQL中的唯一记录</p></figure><p id="bbe2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">简单地说，您需要在<code class="fe me mf mg mh b">GROUP BY</code>子句中提到所有的列名来获得唯一的记录。</p><p id="ec94" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">几乎90%的时候，我发现<code class="fe me mf mg mh b">GROUP BY</code>更方便，因为我总是想用集合函数做一些其他的计算。</p><p id="1b85" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">仅此而已！</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="efcd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">希望你很快看完这篇文章，觉得耳目一新，很有用。</p><p id="bfee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我在过去的3年里一直使用SQL，我发现这些替代方法非常省时，而且功能强大，尤其是在处理大型数据集的时候。此外，我发现其中一些问题是很好的面试问题。</p><blockquote class="ok"><p id="27cf" class="ol om it bd on oo op oq or os ot md dk translated"><em class="ou">对阅读介质上的无限故事感兴趣？？</em></p></blockquote><p id="ff76" class="pw-post-body-paragraph li lj it lk b ll ov kd ln lo ow kg lq lr ox lt lu lv oy lx ly lz oz mb mc md im bi translated">💡考虑<a class="ae lh" href="https://medium.com/@17.rsuraj/membership" rel="noopener"> <strong class="lk jd">成为媒体会员</strong></a><strong class="lk jd">访问媒体上无限的</strong>故事和每日有趣的媒体文摘。我会得到你的费用的一小部分，没有额外的费用给你。</p><p id="7657" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">💡不要忘记<a class="ae lh" href="https://medium.com/subscribe/@17.rsuraj" rel="noopener"> <strong class="lk jd">注册我的电子邮件列表</strong> </a>来接收我文章的第一份拷贝。</p><p id="8b57" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">感谢您的阅读！</strong></p></div></div>    
</body>
</html>