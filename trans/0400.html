<html>
<head>
<title>How to write better scientific code in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用 Python 写出更好的科学代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-write-better-scientific-code-in-python-9349adc7c7e2#2022-02-15">https://towardsdatascience.com/how-to-write-better-scientific-code-in-python-9349adc7c7e2#2022-02-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="efae" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于如何使用 python 和 numpy 编写更好的数据科学代码的一些技巧。我们用一个定制的案例来展示好的模式。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/869789e0bac268eea440b0c38e4809bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yJFnUr46RRsX9eSubrCwjA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">晚上拍照取乐，波兰 2021。(作者供图)。</p></figure><h1 id="8193" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">介绍</h1><p id="9323" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">任何科学工作的很大一部分在于编写代码。无论是典型的机器学习建模、分析，还是参与数据项目，都有很大一部分时间用于构建新功能的原型。由于是探索性的，预计计划的几个部分将被替换或修改，经常超出最初的计划。</p><p id="876f" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">与“消费者软件”不同，变更通常不是由客户的需求引起的，而是由过程的结果引起的。由于这个原因，如果实验证据表明有不同的路径，那么以不需要“完全重建”的方式来设计它是非常有价值的。</p><p id="26f3" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">编写科学代码伴随着两个(额外的)特殊挑战:第一个与数学错误有关。计算中的错误通常很难追踪，尤其是当代码在语义上是正确的时候。没有发现错误。不会引发任何异常。一切看起来都不错，但(数字)结果是错的。特别是，在实现概率模型时，结果有时可能看起来不错，这取决于一些初始条件或随机因素。</p><p id="5d16" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">第二个来自前面描述的事实。总会有实验部分，而且一直在变。所以关键是要设计好每一个组件，这样大部分工作才能留下来，作为下一阶段开发的坚如磐石的基础。</p><p id="3fa0" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在本文中，我们将重点放在可以使代码更健壮、更容易理解、总体上更容易处理的模式上。您将看到简单的改进是如何导致更多的可重用代码和更少的错误的。</p><h1 id="0cb7" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">玩具任务</h1><p id="ec68" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">为了便于演示，我们的任务是计算随机过程结果的<strong class="ls iu">期望值</strong>。数学上，它归结为这个公式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/b9d4a2d48f29406129c6e3f45bdc87c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*guvHoAAGaW4e4xYnckM9Zg.png"/></div></div></figure><p id="c830" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">其中是概率质量函数(PMC)，或者对于连续变量:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/47a640b6b6ebf198a011088fb6f54c84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8wgaWow8wzPUjlq0Pdq4tQ.png"/></div></div></figure><p id="77a1" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">其中是概率密度函数(PDF)。</p><p id="9cbf" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">正如你可能想知道的，这里的挑战是你想让它与任何<em class="mt">分布一起工作:连续的或离散的。或者如果不合理，您希望至少认识到问题的本质，这样您就可以顺利地修改代码。</em></p><h1 id="ed60" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">错误代码——起点</h1><p id="0585" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">让我们从一个不太好的代码开始。说你想掷六面骰子。由于每个结果的概率相等，这归结为计算采样结果的平均值。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="66d5" class="mz kz it mv b gy na nb l nc nd">import random<br/>import statistics<br/><br/><br/>def die(sides = 6):<br/>    return random.randint(1, sides)<br/><br/>def expected_value(n_samples):<br/>    samples = [die() for _ in range(n_samples)]<br/>    return statistics.mean(samples)</span></pre><p id="330a" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这个代码有什么问题？几件事…</p><p id="9c77" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">首先，<code class="fe ne nf ng mv b">die</code>函数一次返回一个样本。需要调用<code class="fe ne nf ng mv b">N</code>次才能得到<code class="fe ne nf ng mv b">N</code>样本，速度很慢。</p><p id="3c73" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">其次，<code class="fe ne nf ng mv b">expected_value</code>函数强烈依赖于产生样本的<code class="fe ne nf ng mv b">die</code>函数。很明显，一旦你考虑使用不同的模具，比如 12 面的。使用这种设计，您需要“打开”T2 来接受一个额外的参数 T3，只需将它传递给 T4 来扩展它，使其适用于更一般的情况。虽然这可以工作，但它使<code class="fe ne nf ng mv b">expected_value</code>的<em class="mt">接口</em>违反直觉，但解决方案仍然依赖于使用<code class="fe ne nf ng mv b">die</code>作为样本源，因此很难考虑其他分布。</p><h1 id="1074" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">补救措施…</h1><p id="25a4" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">让我们考虑一下您的选择:</p><h2 id="6c5c" class="mz kz it bd la nh ni dn le nj nk dp li lz nl nm lk md nn no lm mh np nq lo nr bi translated">想法一</h2><p id="3dd6" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">您可以使用外部变量来存储样本:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="f89a" class="mz kz it mv b gy na nb l nc nd">def expected_value(samples):<br/>    return statistics.mean(samples)<br/><br/>samples = [die(12) for _ in range(n_samples)]<br/><br/>ev = expected_value(samples)</span></pre><p id="38ac" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这是显而易见的，但是你只是把问题移到了别处…现在，<code class="fe ne nf ng mv b">samples</code>成为了一个新的实体，存储数据(甚至是非常大的数据)，并且它是相当匿名的。<code class="fe ne nf ng mv b">expected_value</code>函数期望接收它，但是准备它是你的责任。</p><h2 id="3367" class="mz kz it bd la nh ni dn le nj nk dp li lz nl nm lk md nn no lm mh np nq lo nr bi translated">想法二</h2><p id="c2a6" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">另一种方法是通过将<code class="fe ne nf ng mv b">die</code>作为对象传递给<code class="fe ne nf ng mv b">expected_value</code>来将它保存在内部。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="a612" class="mz kz it mv b gy na nb l nc nd">from functools import partial<br/><br/>twelve_sided_die = partial(die, 12)<br/><br/>def expected_values(die, n_samples):<br/>    samples = [die() for _ in range(n_samples)]<br/>    return statistics.mean(samples)<br/><br/><br/>ev = expected_values(twelve_sided_die, 10000)</span></pre><p id="3a4c" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">该想法使用准备好的<code class="fe ne nf ng mv b">die</code>的“版本”,并让<code class="fe ne nf ng mv b">expected_value</code>将其用作样本源。然而，一个新的问题出现了:<code class="fe ne nf ng mv b">expected_value</code>只与<code class="fe ne nf ng mv b">die</code>兼容。它不能用任何其他“样本生成器”计算结果，或者至少不能保证它能正确地这样做。</p><h2 id="dc21" class="mz kz it bd la nh ni dn le nj nk dp li lz nl nm lk md nn no lm mh np nq lo nr bi translated">想法三</h2><p id="8a0b" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">第三个想法是在更抽象的层面上认识问题，设计更好的界面。</p><p id="46b8" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在抽象层次上，我们有两个概念:</p><ul class=""><li id="99bb" class="ns nt it ls b lt mm lw mn lz nu md nv mh nw ml nx ny nz oa bi translated">存在一个<strong class="ls iu">概率分布</strong>，我们可以从中取样。(可以是骰子、硬币、正态分布——无所谓)。</li><li id="9f87" class="ns nt it ls b lt ob lw oc lz od md oe mh of ml nx ny nz oa bi translated">有一个<strong class="ls iu">数学运算</strong>消耗和转换数据。(例如，计算平均值、方差等。).</li></ul><p id="6726" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">让我们更加关注如何构建正确的抽象以及如何控制它们的相互兼容性。</p><h1 id="c76f" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">分布(数据)</h1><p id="9151" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">数学上，概率分布可以是函数——连续的或离散的，有限的或无限的，从中我们可以<em class="mt">抽取样本。</em>根据问题的不同，该功能的“处方”可能会有很大不同。我们可以使用“现有”公式，如高斯或泊松分布，但它也可以是从直方图等导出的“自定义”公式。</p><p id="a094" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">考虑到这一点，让我们建立以下抽象:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="445a" class="mz kz it mv b gy na nb l nc nd">from abc import ABC, abstractmethod<br/><br/>class Distribution(ABC):<br/>    <br/>    @abstractmethod<br/>    def sample(self):<br/>        ...</span></pre><h1 id="ba48" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">履行</h1><p id="8f4d" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">由于<code class="fe ne nf ng mv b">@abstractmethod</code>，我们的发行版强制要求我们对从这个抽象派生的任何子类实现<code class="fe ne nf ng mv b">sample</code>方法。对于我们的死亡，这可以是:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="f40a" class="mz kz it mv b gy na nb l nc nd">import numpy as np<br/><br/><br/>class Die(Distribution):<br/>    def __init__(self, sides = 6):<br/>        self.sides = sides<br/><br/>    def sample(self, n_samples):<br/>        return np.random.randint(1, self.sides + 1, size=n_samples)</span></pre><p id="9965" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这里，通过调用特定于掷骰子的方法<code class="fe ne nf ng mv b">sample</code>:<code class="fe ne nf ng mv b">Die(12).sample(10000)</code>来交付样本。此外，由于<code class="fe ne nf ng mv b">numpy</code>，我们可以通过用<code class="fe ne nf ng mv b">np.ndarray</code>替换列表理解来非常快速地创建大量数据。</p><p id="5426" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">事实上，事情可以进一步改善。目前，调用<code class="fe ne nf ng mv b">Die()</code>会返回类似这样的<code class="fe ne nf ng mv b">&lt;__main__.Die at 0x7f43f4448400&gt;</code>的东西，这并不具有信息性。同样<code class="fe ne nf ng mv b">Die() == Die()</code>的值为<code class="fe ne nf ng mv b">False</code>，对于 python 来说，它们是同一个类的两个不同的对象实例。要修复它，我们需要实现另外两个方法:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="d636" class="mz kz it mv b gy na nb l nc nd">def __repr__(self):<br/>        return f"{self.__class__.__name__}(sides={self.sides})"<br/><br/>    def __eq__(self, other):<br/>        if isinstance(other, self.__class__):<br/>            return self.sides == other.sides<br/>        return False</span></pre><p id="5dae" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><code class="fe ne nf ng mv b">__repr__</code>方法使得对象的渲染很好看，只有骰子“等边”的情况下<code class="fe ne nf ng mv b">__eq__</code>才会返回<code class="fe ne nf ng mv b">True</code>。</p><h1 id="5736" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">数据类</h1><p id="62f1" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">每次实现这四种方法可能会很繁琐。此外，<code class="fe ne nf ng mv b">Die</code>的当前实现并不能防止对象的改变，即使是偶然的，通过像<code class="fe ne nf ng mv b">die.sides = 20</code>这样将属性分配给一个已存在的对象。</p><p id="8920" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">因此，我们可以使用 python 的<code class="fe ne nf ng mv b">dataclasses</code>重新定义<code class="fe ne nf ng mv b">Die</code>类。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="9c9c" class="mz kz it mv b gy na nb l nc nd">from dataclasses import dataclass<br/><br/><br/>@dataclass(frozen=True)<br/>class Die(Distribution):<br/>    sides: int = 6<br/><br/>    def sample(self, n):<br/>        return np.random.randint(1, self.sides + 1, size=n)</span></pre><p id="23dd" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这个例子的行为和前面的例子是一样的。此外，设置<code class="fe ne nf ng mv b">frozen=True</code>，给<code class="fe ne nf ng mv b">die.sides</code>分配一个新值将引发一个异常。如果我们想要一个新的骰子，我们应该创建一个新的对象。</p><p id="2f9f" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">现在，我们的<code class="fe ne nf ng mv b">expected_value</code>函数可能会将<code class="fe ne nf ng mv b">die</code>作为一个分布对象，并通过调用它的<code class="fe ne nf ng mv b">sample</code>方法来进行计算。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="061e" class="mz kz it mv b gy na nb l nc nd">def expected_value(distribution, n):<br/>    return distribution.sample(n=n).mean()</span></pre><h1 id="df4e" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">打字</h1><p id="ea34" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">上面的例子很简洁。我们确切地知道<code class="fe ne nf ng mv b">expected_value</code>是做什么的，并且很容易测试。然而，n 面骰子并不是我们想要计算期望值的唯一分布。例如，对于掷硬币来说，结果不是数字的(除非我们建立一个约定并坚持下去)。自然，提供一些关于哪些接口可以一起使用以及如何使用的提示是有意义的。</p><p id="74af" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">对于像 python 这样的<em class="mt">动态类型的</em>语言，你不必坚持变量的类型。然而，使用各种 ide 和工具，如<code class="fe ne nf ng mv b">mypy</code>，键入可以帮助您发现潜在的失败点，并使代码更加透明。</p><p id="0461" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">让我们使用<code class="fe ne nf ng mv b">typing</code>重新定义我们的类，并创建两个更具体的发行版。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="ac33" class="mz kz it mv b gy na nb l nc nd">from typing import Generic, Sequence, TypeVar<br/><br/><br/>D = TypeVar("D")<br/><br/><br/>class Distribution(ABC, Generic[D]):<br/>    <br/>    @abstractmethod<br/>    def sample(self, n: int) -&gt; Sequence[D]:<br/>        ...<br/><br/><br/>@dataclass(frozen=True)<br/>class Die(Distribution[int]):<br/>    sides: int = 6<br/><br/>    def sample(self, n: int) -&gt; Sequence[int]:<br/>        return np.random.randint(1, self.sides + 1, size=n)<br/><br/><br/>@dataclass(frozen=True):<br/>class Coin(Distribution[str]):<br/>    outcomes: tuple = ("H", "T")<br/>    fairness: float = 0.5<br/><br/>    def sample(self, n: int) -&gt; Sequence[str]:<br/>        p = (self.fairness, 1.0 - self.fairness)<br/>        return np.random.choice(self.outcomes, size=n, p=p)<br/><br/><br/>@dataclass(frozen=True):<br/>class Gaussian(Distribution[float]):<br/>    mu: float = 0.0<br/>    sigma: float = 1.0<br/><br/>    def sample(self, n: int) -&gt; Sequence[float]:<br/>        np.random.normal(loc=self.mu, scale=self.sigma, size=n)</span></pre><p id="d54f" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这里发生了几件事。感谢<code class="fe ne nf ng mv b">D = TypeVar("D")</code>，我们现在可以定义一个新的变量类型，通过它我们可以参数化每个分布的类型。你可以注意到<code class="fe ne nf ng mv b">Distribution</code>不仅继承了抽象基类，还继承了<code class="fe ne nf ng mv b">Generic[D]</code>，这也将它变成了一个新的(参数化的)类型。现在，它变成了一种身份，构成了一种新的数据类型。</p><p id="ff00" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">每个版本的<code class="fe ne nf ng mv b">sample</code>都被期望返回一个特定类型的序列，该序列对每个单独的发行版的上下文有意义。这样，我们就有了一个参数化的统一界面。我们可以用这个来确保<code class="fe ne nf ng mv b">expected_value</code>的正确行为:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="d8fc" class="mz kz it mv b gy na nb l nc nd">def expected_value(<br/>    distribution: Distribution[float | int], n: int<br/>) -&gt; float:<br/>    return distribution.sample(n=n).mean()</span></pre><p id="7d03" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">虽然传递例如<code class="fe ne nf ng mv b">die = Die()</code>或<code class="fe ne nf ng mv b">gaussian = Gaussian()</code>到<code class="fe ne nf ng mv b">expected_value</code>将会工作(因为<code class="fe ne nf ng mv b">int</code>和<code class="fe ne nf ng mv b">float</code>都是数字)，但是传递<code class="fe ne nf ng mv b">coin = Coin()</code>将会被例如<code class="fe ne nf ng mv b">mypy</code>标记出来，声明</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="e123" class="mz kz it mv b gy na nb l nc nd">&gt; error: Argument 1 to "expected_value" has incompatible type "Coin";<br/>&gt; expected "Distribution[Union[float, int]]"</span></pre><p id="c16b" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这可以在我们运行代码之前给我们一个早期的警告。</p><h1 id="7308" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">提高纯度</h1><p id="c2bc" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">正如你所看到的，使用<code class="fe ne nf ng mv b">typing</code>设计接口有助于形式化意图并尽早发现错误。你甚至可以通过利用<code class="fe ne nf ng mv b">numpy</code>的<code class="fe ne nf ng mv b">dtype</code>把它带到下一个层次。这样，您不仅可以确保不同的元素相互匹配，还可以更加关注数据的内存占用。</p><p id="5b93" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">例如:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="d650" class="mz kz it mv b gy na nb l nc nd">import numpy.typing as npt<br/><br/><br/>class Distribution(ABC, Generic[D]):<br/>    <br/>    @abstractmethod<br/>    def sample(self, n: int) -&gt; np.NDArray[np.generic]:<br/>        ...<br/><br/><br/>class Die(Distrinution[int]):<br/>    sides: int = 6<br/><br/>    def sample(self, n: int) -&gt; npt.NDArray[np.uint8]:<br/>        return np.random.randint(<br/>            1, self.sides + 1, size=n, dtype=np.uint8<br/>        )</span></pre><p id="ac7f" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这样，如果<code class="fe ne nf ng mv b">die.sample</code>方法返回不同于严格无符号 8 位整数的数字，您甚至会得到通知。问题是你想不想去那么深的地方？这是值得思考的事情。</p><h1 id="80d0" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">计算</h1><p id="782f" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">让我们回到设计计算部分。到目前为止，我们已经准备好使用数字分布。自然，我们可以计算<code class="fe ne nf ng mv b">Die</code>和<code class="fe ne nf ng mv b">Gaussian</code>的期望值，但不能计算<code class="fe ne nf ng mv b">Coin</code>的期望值。目前的设计不会。</p><p id="af08" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">要解决这个问题，有两个选择:</p><ul class=""><li id="5927" class="ns nt it ls b lt mm lw mn lz nu md nv mh nw ml nx ny nz oa bi translated">我们可以通过映射创建一个<em class="mt">代理</em>分布，例如<code class="fe ne nf ng mv b">("H", "T") -&gt; (0, 1)</code>，或者</li><li id="b1a9" class="ns nt it ls b lt ob lw oc lz od md oe mh of ml nx ny nz oa bi translated">我们在<code class="fe ne nf ng mv b">expected_value</code>中加入了一个映射，给出了一个可能的“适配器”。</li></ul><p id="a3c9" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">第一种方法创造了一个人造物体，它的想法依赖于惯例。它不阻止任何人用<code class="fe ne nf ng mv b">("H", "T") -&gt; (1, 0)</code>定义另一个代理，导致一个难以察觉的 bug。</p><p id="6dbf" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">相反，我们可以修改<code class="fe ne nf ng mv b">expected_value</code>，让它有可能使用定制适配器。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="5d13" class="mz kz it mv b gy na nb l nc nd">def expected_value(<br/>    d: Distribution[D],<br/>    f: Callable[[D], Any] = lambda x: x,<br/>    n: int = 1000<br/>) -&gt; float:<br/>    return np.mean(np.apply_along_axis(f, axis=0, arr=d.sample(n)))</span></pre><p id="6b43" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><code class="fe ne nf ng mv b">expected_value</code>的第二个参数是可调用的(一个函数)，我们可以随意使用它来翻译结果，例如<code class="fe ne nf ng mv b">Coin()</code>分布。然而，默认情况下，它将保持结果不变。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="5d70" class="mz kz it mv b gy na nb l nc nd">die = Die(12)<br/>expected_values(die, n=10000)<br/><br/>gaussian = Gaussian(mu=4.0, sigma=2.0)<br/>expected_value(gaussian, n=100000)<br/><br/># but<br/>coin = Coin(fairness=0.75)<br/>expected_value(coin, f=lambda x: np.where(x == "H", 1.0, 0.0))</span></pre><p id="6be2" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在这里，我们不仅避免了创建代理分布，还设法避免将<code class="fe ne nf ng mv b">expected_value</code>与任何特定的数据转换方式联系起来。<code class="fe ne nf ng mv b">expected_value</code>函数只做它承诺要做的事情:计算期望值。如果需要任何调整或转换，则由外部提供。注意，这里我们还有一个选项:我们可以定义一个命名函数(例如<code class="fe ne nf ng mv b">coin_conversion</code>)，以防我们计划重用它，或者当一个单独的定义没有增加价值时坚持使用<code class="fe ne nf ng mv b">lambda</code>。</p><h1 id="298d" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">合成和迭代</h1><p id="fd2c" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">事实证明，抽象出数学计算是非常有用的，尤其是在设计迭代算法时。通常，除了主要的计算，我们还必须关注一些附带的结果，比如收敛、提前停止(最大迭代次数)、度量等等。</p><p id="a2c9" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">让我们以常数为例。从数学上讲，我们可以通过以下限制来获得它的值:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/4414edd27203bb45b81a2a8b321e5a60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SHjilYngFbVrjrd5mm5XiQ.png"/></div></div></figure><p id="b6e0" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">越高，近似值越精确。</p><p id="943a" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">怎样才能充分解决？</p><h2 id="31f7" class="mz kz it bd la nh ni dn le nj nk dp li lz nl nm lk md nn no lm mh np nq lo nr bi translated">不是最好的方式…</h2><p id="bfd9" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">先说一个穷人用循环的方法。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="6d18" class="mz kz it mv b gy na nb l nc nd">def approximate_e(<br/>    initial_guess: float,<br/>    max_iter: int = 10,<br/>    epsilon: float = 0.01<br/>) -&gt; float:<br/>    e_value = initial_guess<br/>    for n in range(1, max_iter + 1):<br/>        new_e_value = (1.0 + 1.0 / n) ** n<br/>        if abs(new_e_value - e_value) &lt; epsilon:<br/>            return new_e_value<br/>        e_value = new_e_value<br/><br/>    return new_e_value</span></pre><p id="a77a" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">同样，这种方法有什么问题？</p><p id="9182" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">首先，该函数做三件事，而不是一件。行<code class="fe ne nf ng mv b">8.</code>是计算的绝对本质。然而，由于早期停止和收敛条件，我们留下了大量的代码开销，这与实际计算紧密相关。虽然这两个条件看起来更一般，但如果我们选择替换近似值的主题(例如，替换为平方根)，我们将不得不复制粘贴这些额外的代码，并确保它不会破坏新的算法。</p><p id="3e3f" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">其次，关于参数化这两个条件，我们唯一的选择是硬编码<code class="fe ne nf ng mv b">max_iter</code>和<code class="fe ne nf ng mv b">epsilon</code>的值，或者允许用户提供它们作为参数。它破坏了界面，使测试更加困难。</p><p id="36e7" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">最后，算法“急切地”生成数据。它不是专注于数学并“在被问及时”提供数值，而是将数据抛给你。对于大量数据，这可能会导致内存问题。</p><h1 id="0de5" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">计算上的抽象</h1><p id="d548" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">现在，让我们通过划分不同部分的责任来同时解决这三个问题。我们有三样东西:</p><ul class=""><li id="7bc7" class="ns nt it ls b lt mm lw mn lz nu md nv mh nw ml nx ny nz oa bi translated">我们期望返回正确的数字(实际的计算)，</li><li id="ad3c" class="ns nt it ls b lt ob lw oc lz od md oe mh of ml nx ny nz oa bi translated">如果通过了足够数量的迭代，就停止该过程(提前停止)，</li><li id="67f9" class="ns nt it ls b lt ob lw oc lz od md oe mh of ml nx ny nz oa bi translated">如果数值不再显著提高(收敛)，则停止该过程。</li></ul><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="766c" class="mz kz it mv b gy na nb l nc nd">from typing import Iterator<br/>import itertools<br/><br/><br/>def approximate_e() -&gt; Iterator[float]:<br/>    n = 1<br/>    while True:<br/>        yield (1.0 + 1.0 / n) ** n<br/>        n += 1<br/><br/>def early_stop(<br/>    values: Iterator[float], max_iter: int = 100<br/>) -&gt; Iterator[float]:<br/>    return itertools.islice(values, max_iter)<br/><br/>def convergence(<br/>    values: Iterator[float], epsilon: float = 0.01<br/>) -&gt; Iterator[float]:<br/>    for a, b in itertools.pairwise(values):<br/>        yield a<br/><br/>        if (a - b) &lt; epsilon:<br/>            break</span></pre><p id="28fa" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这种设计使用迭代器，迭代器实现了“懒惰”加载。数据项只有在被请求时才被一个接一个地返回(因此有了关键字<code class="fe ne nf ng mv b">yield</code>)。多亏了这一点，我们(几乎)不必担心记忆。</p><p id="b2ef" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">此外，这三种功能中的每一种都可以单独存在。它们有特定的接口，可以单独进行单元测试。</p><p id="c572" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">最后(也是最重要的)，最后的结果可以通过<em class="mt">把</em>链接在一起得到！</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="624f" class="mz kz it mv b gy na nb l nc nd">values = approximate_e()<br/>values = early_stop(values, max_iter=50)<br/>values = convergence(values, epsilon=0.001)<br/><br/>for value in values:<br/>    print("e becomes:", value)</span></pre><h2 id="d408" class="mz kz it bd la nh ni dn le nj nk dp li lz nl nm lk md nn no lm mh np nq lo nr bi translated">旧 python</h2><p id="f623" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">对于 3.10 之前的 python，可以将<code class="fe ne nf ng mv b">itertools.pairwise</code>写成:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="9534" class="mz kz it mv b gy na nb l nc nd">def pairwise(values: Iterator[D]) -&gt; Iterator[Tuple[D, D]]:<br/>    a = next(values, None)<br/>    if a is None:<br/>        return<br/>    for b in values:<br/>        yield a, b<br/>        a = b</span></pre><h1 id="f522" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">结论</h1><p id="95f1" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">科学编程带来了额外的挑战。这是一个令人兴奋的学科，但是陷阱的数量似乎至少与问题的复杂性成二次方增长。</p><p id="c2e9" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在本文中，我们讨论了似乎在每个科学编程任务中反复出现的两个主要组成部分:数据和计算。希望通过正确的方式抽象它们，你不仅可以提高代码的效率，减少错误，还可以让编码成为一种更好的体验。为了你和你的团队！</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><p id="9d47" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><em class="mt">原载于</em><a class="ae oo" href="https://zerowithdot.com/improve-data-science-code/" rel="noopener ugc nofollow" target="_blank"><em class="mt">https://zerowithdot.com</em></a><em class="mt">。</em></p></div></div>    
</body>
</html>