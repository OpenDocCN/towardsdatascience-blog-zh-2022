<html>
<head>
<title>What Happens When you Import a Python Module?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">导入Python模块会发生什么？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/what-happens-when-you-import-a-python-module-ad6c0efd2640#2022-08-30">https://towardsdatascience.com/what-happens-when-you-import-a-python-module-ad6c0efd2640#2022-08-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="91a4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入研究进口系统</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/52c591ac4d00d0867fe9df35cf5f08e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UA8dxOnhFqn1pBfo"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@mike_van_den_bos" rel="noopener ugc nofollow" target="_blank">迈克·范·登博斯</a>从<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="33ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">可用性是衡量代码质量的关键指标之一。它是指代码可以在不同的程序中以最小的改动使用的程度。在Python中，我们使用<code class="fe me mf mg mh b">import</code>从模块中导入代码。但是你有没有好奇过<code class="fe me mf mg mh b">import</code>是如何在幕后实现的？在本文中，我们将深入探讨Python的导入系统。我们还会讨论一个有趣的问题:循环导入。喝杯茶，让我们直接进入正题。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="c61a" class="mp mq it bd mr ms mt dn mu mv mw dp mx li my mz na lm nb nc nd lq ne nf ng nh bi translated">模块v.s .包</h2><p id="eba9" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Python被组织成模块和包。<strong class="lb iu">模块是一个Python文件，包是模块的集合。</strong>考虑以下导入模块的示例:</p><pre class="kj kk kl km gt nn mh no np aw nq bi"><span id="afe5" class="mp mq it mh b gy nr ns l nt nu">import random<br/>random.randint(1,10)</span></pre><p id="cdeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b"><a class="ae ky" href="https://docs.python.org/3/library/random.html" rel="noopener ugc nofollow" target="_blank">random</a></code>是Python内置的模块。在第一行中，它导入<code class="fe me mf mg mh b">random</code>模块并使其可用，然后它访问<code class="fe me mf mg mh b">randint()</code>。如果您打开一个IDE并调试导入，您将看到代码位于<code class="fe me mf mg mh b">random.py</code>文件中。</p><p id="4ed7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也可以这样导入<code class="fe me mf mg mh b">randint</code>:</p><pre class="kj kk kl km gt nn mh no np aw nq bi"><span id="d16b" class="mp mq it mh b gy nr ns l nt nu">from random import randint<br/>randint(1,10)</span></pre><p id="ffdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看一个包中的例子:</p><pre class="kj kk kl km gt nn mh no np aw nq bi"><span id="01fb" class="mp mq it mh b gy nr ns l nt nu">import pandas<br/>pandas.DataFrame()</span></pre><p id="cbf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">乍一看，你真的分辨不出它是模块还是包。但是如果您调试导入，它会将您重定向到<code class="fe me mf mg mh b"><a class="ae ky" href="https://github.com/pandas-dev/pandas/tree/main/pandas" rel="noopener ugc nofollow" target="_blank">pandas</a>.__init__.py</code>而不是<code class="fe me mf mg mh b">pandas.py</code>。一个包包含子模块或递归子包，而<code class="fe me mf mg mh b">__init__.py</code>是包的入口点。</p><p id="12ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但不是唯一的方法，像<code class="fe me mf mg mh b">importlib.import_module()</code>和内置<code class="fe me mf mg mh b">__import__()</code>这样的函数也可以使用。</p><pre class="kj kk kl km gt nn mh no np aw nq bi"><span id="dce3" class="mp mq it mh b gy nr ns l nt nu">&gt;&gt;&gt; import importlib<br/>&gt;&gt;&gt; importlib.import_module('random')<br/>&lt;module 'random' from '/Users/xiaoxu/.pyenv/versions/3.9.0/lib/python3.9/random.py'&gt;</span><span id="aeb7" class="mp mq it mh b gy nv ns l nt nu">&gt;&gt;&gt; __import__('random')<br/>&lt;module 'random' from '/Users/xiaoxu/.pyenv/versions/3.9.0/lib/python3.9/random.py'&gt;</span></pre></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="24eb" class="mp mq it bd mr ms mt dn mu mv mw dp mx li my mz na lm nb nc nd lq ne nf ng nh bi translated">包裹。__init__。巴拉圭</h2><p id="d79c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">那么什么是<code class="fe me mf mg mh b">__init__.py</code>？</p><blockquote class="nw nx ny"><p id="3995" class="kz la nz lb b lc ld ju le lf lg jx lh oa lj lk ll ob ln lo lp oc lr ls lt lu im bi translated">一个<a class="ae ky" href="https://docs.python.org/3/reference/import.html#regular-packages" rel="noopener ugc nofollow" target="_blank">常规Python包</a>包含一个<code class="fe me mf mg mh b">__init__.py</code>文件。当包被导入时，这个<code class="fe me mf mg mh b">__init__.py</code>文件被隐式执行，它定义的对象被绑定到包的名称空间中的名称。该文件可以留空。</p></blockquote><p id="0985" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子。我有一个这样的文件夹结构。<code class="fe me mf mg mh b">p1</code>是我的包，<code class="fe me mf mg mh b">m1</code>是子模块。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/107b31cda7177fb2325b57f47fa509af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*5NW1-pVeFEbGPFr_osePHg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">文件夹结构(由<a class="oe of ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----ad6c0efd2640--------------------------------" rel="noopener" target="_blank">高</a>创建)</p></figure><p id="6647" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe me mf mg mh b">m1.py</code>中，我有一个变量<code class="fe me mf mg mh b">DATE</code>，我想在<code class="fe me mf mg mh b">main.py</code>中使用它。我将创建几个版本的<code class="fe me mf mg mh b">__init__.py</code>，看看它如何影响<code class="fe me mf mg mh b">main.py</code>中的导入。</p><pre class="kj kk kl km gt nn mh no np aw nq bi"><span id="8f74" class="mp mq it mh b gy nr ns l nt nu"># m1.py<br/>DATE = "2022-01-01"</span></pre><p id="83b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">案例1:清空</strong> <code class="fe me mf mg mh b"><strong class="lb iu">__init__.py</strong></code> <strong class="lb iu">文件。</strong></p><p id="42dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于导入<code class="fe me mf mg mh b">p1</code>时<code class="fe me mf mg mh b">__init__.py</code>文件为空，所以没有导入子模块，所以不知道<code class="fe me mf mg mh b">m1</code>的存在。如果我们使用<code class="fe me mf mg mh b">from p1 import m1</code>显式导入<code class="fe me mf mg mh b">m1</code>，那么<code class="fe me mf mg mh b">m1.py</code>中的所有内容都将被导入。但是，我们实际上不是导入一个包，而是导入一个模块。可以想象，如果您的包有很多子模块，您需要显式地导入每个模块，这可能会非常繁琐。</p><pre class="kj kk kl km gt nn mh no np aw nq bi"><span id="3002" class="mp mq it mh b gy nr ns l nt nu"># main.py<br/>import p1<br/>p1.m1.DATE</span><span id="899e" class="mp mq it mh b gy nv ns l nt nu">&gt;&gt; AttributeError: module 'p1' has no attribute 'm1'</span><span id="bd5e" class="mp mq it mh b gy nv ns l nt nu">from p1 import m1<br/>from p1 import m2, m3 ...# needs to explictly import every submodule</span><span id="62fd" class="mp mq it mh b gy nv ns l nt nu">m1.DATE</span><span id="134e" class="mp mq it mh b gy nv ns l nt nu">Works!!</span></pre><p id="5961" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">情况2:导入</strong> <code class="fe me mf mg mh b"><strong class="lb iu">__init__.py</strong></code> <strong class="lb iu">文件</strong>中的子模块</p><p id="a63d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从<code class="fe me mf mg mh b">__init__.py</code>文件中的<code class="fe me mf mg mh b">m1</code>导入所有内容，而不是将其留空。然后，<code class="fe me mf mg mh b">main.py</code>文件中的<code class="fe me mf mg mh b">import p1</code>会识别<code class="fe me mf mg mh b">m1.py</code>中的变量，你可以直接调用<code class="fe me mf mg mh b">p1.DATE</code>而不知道它来自哪个模块。</p><pre class="kj kk kl km gt nn mh no np aw nq bi"><span id="f967" class="mp mq it mh b gy nr ns l nt nu"># __init__.py<br/>from .m1 import * # or from p1.m1 import *<br/>from .m2 import * </span><span id="20c2" class="mp mq it mh b gy nv ns l nt nu"># main.py<br/>import p1<br/>p1.DATE</span></pre><p id="f51c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能已经注意到了<code class="fe me mf mg mh b">m1</code>前面的<em class="nz">点</em>。这是一个告诉它在当前包中搜索的快捷方式。这是一个相对进口的例子。一个等价的绝对导入将像<code class="fe me mf mg mh b">from p1.m1 import *</code>一样显式地命名当前包。</p><p id="9f3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过有一个警告。如果包中的另一个子模块包含相同的变量，后面导入的子模块将覆盖前面的子模块。</p><p id="ad3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">拥有一个非空的<code class="fe me mf mg mh b">__init__.py</code>的好处是当客户端导入包时，所有的子模块都已经可用，所以客户端代码看起来更整洁。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="2443" class="mp mq it bd mr ms mt dn mu mv mw dp mx li my mz na lm nb nc nd lq ne nf ng nh bi translated">Python如何找到模块和包？</h2><p id="b97b" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在Python中查找模块和包的系统被称为<strong class="lb iu">导入机制</strong>，它由<strong class="lb iu"> </strong>查找器、加载器、缓存和编排器组成。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/c7807bf1a7b7502b98c59ecfd7cd8189.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xYGdwZGa5X8AYt8sWOZ4NA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">进口机械(由高创造)</p></figure><ol class=""><li id="165e" class="oh oi it lb b lc ld lf lg li oj lm ok lq ol lu om on oo op bi translated"><strong class="lb iu">搜索模块中缓存的</strong> <code class="fe me mf mg mh b"><strong class="lb iu">sys.modules</strong></code></li></ol><p id="012e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次导入模块，首先搜索的是<code class="fe me mf mg mh b">sys.modules</code>字典。键是模块名，值是实际的模块本身。<code class="fe me mf mg mh b">sys.modules</code>是一个缓存的字典，如果模块在那里，那么它将被立即返回，否则，它将在系统中被搜索。</p><p id="f829" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到前面的例子。当我们导入<code class="fe me mf mg mh b">p1</code>时，两个条目被添加到<code class="fe me mf mg mh b">sys.modules</code>。顶层模块<code class="fe me mf mg mh b">__init__.py</code>和子模块<code class="fe me mf mg mh b">m1.py</code>。</p><pre class="kj kk kl km gt nn mh no np aw nq bi"><span id="2a26" class="mp mq it mh b gy nr ns l nt nu">import p1<br/>import sys<br/>print(sys.modules)</span><span id="6971" class="mp mq it mh b gy nv ns l nt nu">{<br/>'p1': &lt;module 'p1' from '/xiaoxu/sandbox/p1/__init__.py'&gt;,<br/>'p1.m1': &lt;module 'p1.m1' from '/xiaoxu/sandbox/p1/m1.py'&gt;<br/>...<br/>}</span></pre><p id="09c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们导入它两次，第二次导入将从缓存中读取。但是如果我们故意从<code class="fe me mf mg mh b">sys.modules</code>字典中删除条目，那么第二次导入将返回一个新的模块对象。</p><pre class="kj kk kl km gt nn mh no np aw nq bi"><span id="4bf8" class="mp mq it mh b gy nr ns l nt nu"># read from cache<br/>import p1<br/>import sys<br/>old = p1<br/>import p1<br/>new = p1<br/>assert old is new</span><span id="0a89" class="mp mq it mh b gy nv ns l nt nu"># read from system<br/>import p1<br/>import sys<br/>old = p1<br/>del sys.modules['p1']<br/>import p1<br/>new = p1<br/>assert not old is new</span></pre><p id="7954" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 2。搜索模块规格</strong></p><p id="f144" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果模块不在<code class="fe me mf mg mh b">sys.modules</code>字典中，那么它需要被一列<a class="ae ky" href="https://docs.python.org/3/library/sys.html#sys.meta_path" rel="noopener ugc nofollow" target="_blank">元路径查找器</a>对象搜索，这些对象有它们的<code class="fe me mf mg mh b">find_spec()</code>方法，以查看模块是否可以被导入。</p><pre class="kj kk kl km gt nn mh no np aw nq bi"><span id="29e4" class="mp mq it mh b gy nr ns l nt nu">import sys<br/>print(sys.meta_path)<br/>[   &lt;class '_frozen_importlib.BuiltinImporter'&gt;,<br/>    &lt;class '_frozen_importlib.FrozenImporter'&gt;,<br/>    &lt;class '_frozen_importlib_external.PathFinder'&gt;]</span></pre><p id="24f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">BuiltinImporter</code>用于内置模块。<code class="fe me mf mg mh b">FronzenImporter</code>用于定位冻结的模块。<code class="fe me mf mg mh b">PathFinder</code>负责查找位于这些路径之一的模块。</p><ul class=""><li id="8c74" class="oh oi it lb b lc ld lf lg li oj lm ok lq ol lu oq on oo op bi translated"><code class="fe me mf mg mh b">sys.path</code></li><li id="277a" class="oh oi it lb b lc or lf os li ot lm ou lq ov lu oq on oo op bi translated"><code class="fe me mf mg mh b">sys.path_hooks</code></li><li id="29cb" class="oh oi it lb b lc or lf os li ot lm ou lq ov lu oq on oo op bi translated"><code class="fe me mf mg mh b">sys.path_importer_cache</code></li><li id="bfdb" class="oh oi it lb b lc or lf os li ot lm ou lq ov lu oq on oo op bi translated"><code class="fe me mf mg mh b">__path__</code></li></ul><p id="a00e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看<code class="fe me mf mg mh b">sys.path</code>里有什么。</p><pre class="kj kk kl km gt nn mh no np aw nq bi"><span id="8499" class="mp mq it mh b gy nr ns l nt nu">import sys<br/>print(sys.path)<br/>[   '/xiaoxu/sandbox',<br/>    '/xiaoxu/.pyenv/versions/3.9.0/lib/python39.zip',<br/>    '/xiaoxu/.pyenv/versions/3.9.0/lib/python3.9',<br/>    '/xiaoxu/.pyenv/versions/3.9.0/lib/python3.9/lib-dynload',<br/>    '/xiaoxu/.local/lib/python3.9/site-packages',<br/>    '/xiaoxu/.pyenv/versions/3.9.0/lib/python3.9/site-packages']</span></pre><p id="b86e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">PathFinder</code>将使用<code class="fe me mf mg mh b">find_spec</code>方法寻找模块的<code class="fe me mf mg mh b">__spec__</code>。每个模块都有一个规范对象，它是模块的元数据。其中一个属性是<code class="fe me mf mg mh b">loader</code>。<code class="fe me mf mg mh b">loader</code>指示输入机械在创建模块时使用哪个加载器。</p><pre class="kj kk kl km gt nn mh no np aw nq bi"><span id="f9d7" class="mp mq it mh b gy nr ns l nt nu">import p1<br/>print(p1.__spec__)</span><span id="3403" class="mp mq it mh b gy nv ns l nt nu">ModuleSpec(name='p1', loader=&lt;_frozen_importlib_external.SourceFileLoader object at 0x1018b6ac0&gt;, origin='/xiaoxu/sandbox/p1/__init__.py', submodule_search_locations=['/xiaoxu/sandbox/p1'])</span></pre><p id="39d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 3。加载模块</strong></p><p id="1a94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦找到模块规范，导入机器将使用loader属性初始化模块，并将其存储在<code class="fe me mf mg mh b">sys.modules</code>字典中。您可以阅读这个<a class="ae ky" href="https://docs.python.org/3/reference/import.html#loading" rel="noopener ugc nofollow" target="_blank">伪代码</a>来理解在导入的加载部分发生了什么。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="099a" class="mp mq it bd mr ms mt dn mu mv mw dp mx li my mz na lm nb nc nd lq ne nf ng nh bi translated">Python循环导入</h2><p id="ce87" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">最后我们来看一个进口的有趣问题:循环进口。当两个或多个模块相互依赖时，就会发生循环导入。在这个例子中，<code class="fe me mf mg mh b">m2.py</code>依赖于<code class="fe me mf mg mh b">m1.py</code>，而<code class="fe me mf mg mh b">m1.py</code>依赖于<code class="fe me mf mg mh b">m2.py</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/1f751495ac127412ef2eb614dfb29650.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*2o-YGK122igWCBHp_KWGOw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">模块依赖(由<a class="oe of ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----ad6c0efd2640--------------------------------" rel="noopener" target="_blank">高</a>创建)</p></figure><pre class="kj kk kl km gt nn mh no np aw nq bi"><span id="b464" class="mp mq it mh b gy nr ns l nt nu"># m1.py<br/>import m2<br/>m2.do_m2()</span><span id="3059" class="mp mq it mh b gy nv ns l nt nu">def do_m1():<br/>  print("m1")</span><span id="5614" class="mp mq it mh b gy nv ns l nt nu"># m2.py<br/>import m1<br/>m1.do_m1()</span><span id="33ca" class="mp mq it mh b gy nv ns l nt nu">def do_m2():<br/>  print("m2")</span><span id="847d" class="mp mq it mh b gy nv ns l nt nu"># main.py<br/>import m1<br/>m1.do_m1()</span><span id="3d4f" class="mp mq it mh b gy nv ns l nt nu">AttributeError: partially initialized module 'm1' has no attribute 'do_m1' (most likely due to a circular import)</span></pre><p id="801c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python无法从模块<code class="fe me mf mg mh b">m1</code>中找到属性<code class="fe me mf mg mh b">do_m1</code>。那么为什么会出现这种情况呢？该图说明了这一过程。当<code class="fe me mf mg mh b">import m1</code>时，Python逐行遍历<code class="fe me mf mg mh b">m1.py</code>。它找到的第一个东西是<code class="fe me mf mg mh b">import m2</code>，所以它去导入<code class="fe me mf mg mh b">m2.py</code>。第一行是导入<code class="fe me mf mg mh b">m1</code>，但是因为Python还没有遍历<code class="fe me mf mg mh b">m1.py</code>中的所有内容，所以我们得到了一个半初始化的对象。当我们调用哪个python没有看到的<code class="fe me mf mg mh b">m1.do_m1()</code>时，会引发AttributeError异常。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/d1f33f2f28db00047add8ed3bd1a25ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*Kzcajm2tNpC5NRmKeX9KbQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">循环进口(由<a class="oe of ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----ad6c0efd2640--------------------------------" rel="noopener" target="_blank">高</a>创造)</p></figure><p id="4d92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">那么如何修复循环导入呢？</strong>一般来说，循环导入是糟糕设计的结果。大多数时候，这种依赖关系实际上并不是必需的。一个简单的解决方案是将两种功能合并到一个模块中。</p><pre class="kj kk kl km gt nn mh no np aw nq bi"><span id="75b4" class="mp mq it mh b gy nr ns l nt nu"># m.py<br/>def do_m1():<br/>  print("m1")<br/>def do_m2():<br/>  print("m2")</span><span id="32bc" class="mp mq it mh b gy nv ns l nt nu"># main.py<br/>import m<br/>m.do_m1()<br/>m.do_m2()</span></pre><p id="c39c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，合并的模块会变得非常大。另一个解决方案是推迟<code class="fe me mf mg mh b">m2</code>的导入，以便在需要时导入。这可以通过将<code class="fe me mf mg mh b">import m2</code>置于功能<code class="fe me mf mg mh b">def do_m1()</code>中来实现。在这种情况下，Python会加载<code class="fe me mf mg mh b">m1.py</code>中的所有函数，然后只在需要的时候加载<code class="fe me mf mg mh b">m2.py</code>。</p><pre class="kj kk kl km gt nn mh no np aw nq bi"><span id="4494" class="mp mq it mh b gy nr ns l nt nu"># m1.py<br/>def do_m1():<br/>  import m2<br/>  m2.do_m2()<br/>  print("m1")</span><span id="be60" class="mp mq it mh b gy nv ns l nt nu">def do_m1_2():<br/>  print("m1_2")</span><span id="3c17" class="mp mq it mh b gy nv ns l nt nu"># m2.py<br/>import m1</span><span id="a38a" class="mp mq it mh b gy nv ns l nt nu">def do_m2():<br/>  m1.do_m1_2()<br/>  print("m2")</span><span id="f5fc" class="mp mq it mh b gy nv ns l nt nu"># main.py<br/>import m1<br/>m1.do_m1()</span></pre><p id="14c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多代码库使用延迟导入不一定是为了解决循环依赖，而是为了加快启动时间。来自<a class="ae ky" href="https://airflow.apache.org/docs/apache-airflow/stable/best-practices.html#top-level-python-code" rel="noopener ugc nofollow" target="_blank"> Airflow </a>的一个例子是不要编写构建Dag所不需要的顶级代码。这是因为顶级代码解析速度对Airflow的性能和可伸缩性都有影响。</p><pre class="kj kk kl km gt nn mh no np aw nq bi"><span id="c4ff" class="mp mq it mh b gy nr ns l nt nu"># example from Airflow doc</span><span id="6c92" class="mp mq it mh b gy nv ns l nt nu"><strong class="mh iu">from</strong> <strong class="mh iu">airflow</strong> <strong class="mh iu">import</strong> DAG<br/><strong class="mh iu">from</strong> <strong class="mh iu">airflow.operators.python</strong> <strong class="mh iu">import</strong> PythonOperator<br/><br/><strong class="mh iu">with</strong> DAG(<br/>    dag_id="example_python_operator",<br/>    schedule_interval=<strong class="mh iu">None</strong>,<br/>    start_date=pendulum.datetime(2021, 1, 1, tz="UTC"),<br/>    catchup=<strong class="mh iu">False</strong>,<br/>    tags=["example"],<br/>) <strong class="mh iu">as</strong> dag:<br/><br/>    <strong class="mh iu">def</strong> print_array():<br/>        <strong class="mh iu">import</strong> <strong class="mh iu">numpy</strong> <strong class="mh iu">as</strong> <strong class="mh iu">np</strong>  <br/>        <em class="nz"># &lt;- THIS IS HOW NUMPY SHOULD BE IMPORTED IN THIS CASE</em><br/><br/>        a = np.arange(15).reshape(3, 5)<br/>        print(a)<br/>        <strong class="mh iu">return</strong> a<br/><br/>    run_this = PythonOperator(<br/>        task_id="print_the_context",<br/>        python_callable=print_array,<br/>    )</span></pre></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="1c41" class="mp mq it bd mr ms mt dn mu mv mw dp mx li my mz na lm nb nc nd lq ne nf ng nh bi translated">结论</h2><p id="c953" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">一如既往，我希望这篇文章对你有用，并能给你启发。我们认为Python中的许多东西都是理所当然的，但是当发现它内部是如何工作的时候，就变得有趣了。希望你喜欢，干杯！</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="596b" class="mp mq it bd mr ms mt dn mu mv mw dp mx li my mz na lm nb nc nd lq ne nf ng nh bi translated">参考</h2><p id="1446" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><a class="ae ky" href="https://alone-djangonaut.com/how-pythons-import-machinery-works" rel="noopener ugc nofollow" target="_blank">https://alone-djangonaut . com/how-python-import-machinery-works</a></p></div></div>    
</body>
</html>