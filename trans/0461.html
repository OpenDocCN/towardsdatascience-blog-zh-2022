<html>
<head>
<title>Using multi-stage builds to make your docker image 10x smaller</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用多阶段构建将您的 docker 映像缩小 10 倍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-multi-stage-builds-to-make-your-docker-image-almost-10x-smaller-239068cb6fb0#2022-02-18">https://towardsdatascience.com/using-multi-stage-builds-to-make-your-docker-image-almost-10x-smaller-239068cb6fb0#2022-02-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ce7e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">留下不必要的工具，清理你的 Docker 图片</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/138a15c9b4015cbc747871eae93d4646.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8_OAFA8YA-2T61F3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如果你完成了建造，你需要清理你的工具</p></figure><p id="9817" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇短文中，我们分多个阶段构建图像，以显著减小 docker 图像的大小。最终，我们会得到一个图像，做完全相同的事情，但是尺寸却小了 10 倍！我们这样做的方法是留下我们用来建立图像的工具。</p><p id="907b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将创建一个 docker 文件，用于以“常规”方式构建图像。然后我们升级这个文件，利用一个额外的阶段，留下我们不必要的工件。最后，我们将通过试验不同的 docker 图像来进一步优化。让我们看看我们能减掉多少脂肪；我们来编码吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="95d7" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">开始之前</h2><p id="01ce" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们使用了很多终端命令。不熟悉的话可以看看<a class="ae ky" href="https://mikehuls.medium.com/terminals-consoles-command-line-for-absolute-beginners-de7853c7f5e8" rel="noopener"> <strong class="lb iu">这篇</strong> </a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bde3" class="na md it bd me nb nc nd mh ne nf ng mk jz nh ka mn kc ni kd mq kf nj kg mt nk bi translated">设置</h1><p id="ea57" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">假设我们正在构建一个需要地理数据的应用程序。Open StreetMap 为我们提供了这种地理数据:通过<code class="fe nl nm nn no b">geofabrik.de</code>，我们可以以<code class="fe nl nm nn no b">.osm.pbf</code>格式下载每个国家的地理数据。接下来我们可以使用一个叫做<code class="fe nl nm nn no b">Osmium</code>的工具将这些文件合并在一起。想象一下，我们只需要将这个合并文件输入到我们的应用程序中。</p><p id="f3e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之:我们只需要使用<code class="fe nl nm nn no b">curl</code>(下载)和<code class="fe nl nm nn no b">osmium</code>(合并)一次:当我们获得合并后的文件时，我们就不再需要这些工具了。在两阶段构建中，我们在第一阶段下载这些工具，在那里使用它们，然后只将结果(合并的文件)带到下一阶段，留下工具。</p><p id="851a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们看到两阶段构建之前，让我们看看“正常”的方式。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dfa8" class="na md it bd me nb nc nd mh ne nf ng mk jz nh ka mn kc ni kd mq kf nj kg mt nk bi translated">1.普通的身材</h1><p id="4756" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在这一部分，我们将用最简单的方式来建立我们的形象。尽管如此，我们还是要记住一些小技巧来最小化我们的形象，详见本文<a class="ae ky" href="https://mikehuls.medium.com/5-easy-to-implement-tricks-to-trim-down-your-docker-image-size-263978a6ed29" rel="noopener"><strong class="lb iu"/></a>。这是 dockerfile 文件:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="e945" class="mc md it no b gy nt nu l nv nw">FROM ubuntu:20.04</span><span id="e31a" class="mc md it no b gy nx nu l nv nw"># BUNDLE LAYERS<br/>RUN apt-get update -y &amp;&amp; apt install -y --no-install-recommends \<br/>  curl \<br/>  osmium-tool \<br/> &amp;&amp; rm -rf /var/lib/apt/lists/*</span><span id="abe4" class="mc md it no b gy nx nu l nv nw">RUN mkdir /osmfiles \<br/> &amp;&amp; mkdir /merged \<br/> &amp;&amp; curl <a class="ae ky" href="https://download.geofabrik.de/europe/monaco-latest.osm.pbf" rel="noopener ugc nofollow" target="_blank">https://download.geofabrik.de/europe/monaco-latest.osm.pbf</a> -o /osmfiles/monaco.osm.pbf \<br/> &amp;&amp; curl <a class="ae ky" href="https://download.geofabrik.de/europe/andorra-latest.osm.pbf" rel="noopener ugc nofollow" target="_blank">https://download.geofabrik.de/europe/andorra-latest.osm.pbf</a> -o /osmfiles/andorra.osm.pbf \<br/> &amp;&amp; osmium merge /osmfiles/monaco.osm.pbf /osmfiles/andorra.osm.pbf -o /merged/merged.osm.pbf</span></pre><p id="06ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个 does 文件正是我们需要的:安装 curl 和 osmium，下载文件并合并它们。我们最终得到驻留在<code class="fe nl nm nn no b">/merged</code>中的合并文件。</p><p id="c9ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ny">注意，我们在获得合并文件后不做任何事情。出于本文的目的，我们将保持这个 docker 文件简单，并跳过对文件的实际操作。</em></p><p id="0434" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看这张图片的大小:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="3f5a" class="mc md it no b gy nt nu l nv nw">testimg:latest        a88a8848201b   16 seconds ago       96.9MB</span></pre><p id="7cd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你看到的图像大约是 97MB。在下一部分中，我们将使用多个阶段来升级 docker 文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/18ba9b99de4c2c8bdb25db335214b21f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qItJjomm12Tg2jdT"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">本文清理了大量垃圾(图片由<a class="ae ky" href="https://unsplash.com/@unarchive" rel="noopener ugc nofollow" target="_blank">杰里米·贝赞格</a>在<a class="ae ky" href="https://unsplash.com/photos/u5mCQ-c5oSI" rel="noopener ugc nofollow" target="_blank"> unsplash </a>上提供)</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c6b9" class="na md it bd me nb nc nd mh ne nf ng mk jz nh ka mn kc ni kd mq kf nj kg mt nk bi translated">2.实现多阶段构建</h1><p id="d07b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在前面的例子中，我们只使用了一次构建工具(curl 和 osmium)。使用后，它们会留在我们的印象中。打个比方:你买了一辆新车，但发现所有用于制造汽车的工具都还在后备箱里，占据了宝贵的空间！</p><p id="de9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一部分，我们将重点放在留下我们用来制造汽车的工具。让我们检查新的 docker 文件并检查代码。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="db26" class="mc md it no b gy nt nu l nv nw">FROM ubuntu:20.04 AS final<br/>FROM ubuntu:20.04 as build</span><span id="eec1" class="mc md it no b gy nx nu l nv nw"># BUNDLE LAYERS<br/>RUN apt-get update -y &amp;&amp; apt install -y --no-install-recommends \<br/>  curl \<br/>  osmium-tool \<br/> &amp;&amp; rm -rf /var/lib/apt/lists/*</span><span id="8f60" class="mc md it no b gy nx nu l nv nw">RUN mkdir /osmfiles \<br/> &amp;&amp; mkdir /merged \<br/> &amp;&amp; curl <a class="ae ky" href="http://download.geofabrik.de/europe/monaco-latest.osm.pbf" rel="noopener ugc nofollow" target="_blank">http://download.geofabrik.de/europe/monaco-latest.osm.pbf</a> -o /osmfiles/monaco.osm.pbf \<br/> &amp;&amp; curl <a class="ae ky" href="http://download.geofabrik.de/europe/andorra-latest.osm.pbf" rel="noopener ugc nofollow" target="_blank">http://download.geofabrik.de/europe/andorra-latest.osm.pbf</a> -o /osmfiles/andorra.osm.pbf \<br/> &amp;&amp; osmium merge /osmfiles/monaco.osm.pbf /osmfiles/andorra.osm.pbf -o /merged/merged.osm.pbf</span><span id="7311" class="mc md it no b gy nx nu l nv nw">FROM final</span><span id="9e48" class="mc md it no b gy nx nu l nv nw">RUN mkdir /merged<br/>COPY --from=build /merged /merged</span></pre><p id="40db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我们使用了两个阶段:一个称为<em class="ny">构建</em>，一个称为<em class="ny">最终</em>。在我们的建造阶段安装卷曲和锇。使用它们创建合并文件，最后只需将<code class="fe nl nm nn no b">merged</code>文件夹复制到<code class="fe nl nm nn no b">final</code>阶段。</p><p id="951e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们输入了<code class="fe nl nm nn no b">FROM final</code>，我们就“进入”了最后一个阶段，所以<code class="fe nl nm nn no b">FROM final</code>之后的任何事情都会在那里发生。二号线的<code class="fe nl nm nn no b">FROM ubuntu:20.04 as build</code>也是如此。请注意，curl 和锇只是在我们的构建阶段安装的。一旦我们到达 docker 文件的末尾，我们只保留我们所处的阶段。因为<em class="ny"> final </em>阶段在 dockerfile 的末尾是活动的，所以<em class="ny"> build </em>阶段中的所有内容都会被留下。让我们来看看新容器的尺寸:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="2cab" class="mc md it no b gy nt nu l nv nw">testimgbetter:latest        7342ee3948e8   3 seconds ago    75.1MB</span></pre><p id="5c0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的新形象是<strong class="lb iu"> 75MB </strong>:通过留下我们不再需要的工具，我们节省了超过<strong class="lb iu"> 20MB </strong>或不到 20%的空间。这已经是非常好的改进了。让我们来看看如何进一步优化。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="55d0" class="na md it bd me nb nc nd mh ne nf ng mk jz nh ka mn kc ni kd mq kf nj kg mt nk bi translated">3.具有较小最终图像的多阶段</h1><p id="c902" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在前一部分中，我们在构建和最终阶段都使用了<code class="fe nl nm nn no b">ubuntu:20.04</code>图像。对于构建阶段，这是非常合理的；在这里我们做复杂的事情:安装包，下载东西，git 克隆，在其他情况下甚至可能使用<code class="fe nl nm nn no b">cmake</code>或<code class="fe nl nm nn no b">make</code>来编译代码！然而，<em class="ny">最终</em>阶段并不需要像<em class="ny">构建</em>阶段那么智能。</p><p id="6d4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一部分的想法是，你需要一个大而丰富的图像，像复杂的<em class="ny">构建</em>阶段的<code class="fe nl nm nn no b">ubuntu:20.04</code>。然后，我们可以将来自<em class="ny">构建</em>阶段的结果复制到基于更简单图像的<em class="ny">最终</em>阶段。在我们的例子中，我们甚至可以使用非常小的图像，如 Alpine。让我们稍微调整一下我们的 docker 文件:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="8b36" class="mc md it no b gy nt nu l nv nw">FROM alpine:3.14 AS final</span></pre><p id="b89e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，一旦构建阶段完成，我们只需将合并后的文件复制到 alpine 阶段。让我们检查一下新构建的图像的总大小:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="d634" class="mc md it no b gy nt nu l nv nw">testimgbetter                                                latest        8ad3278671e1   17 minutes ago   7.95MB</span></pre><p id="760f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从<strong class="lb iu"> 75MB </strong>降到了略低于<strong class="lb iu"> 8MB: </strong>几乎减少了<strong class="lb iu">90%！</strong></p><p id="2a6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ny">请注意，使用 alpine 图像并不总是有效；本文这一部分的想法是，我们可以使用比构建阶段更小的最终图像。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/062d8369192eb1aeab71330279d1f5c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NLvoJBOnqihYkSfW"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">整洁有序(图片由<a class="ae ky" href="https://unsplash.com/@barnimages" rel="noopener ugc nofollow" target="_blank">谷仓图片</a>在<a class="ae ky" href="https://unsplash.com/photos/t5YUoHW6zRo" rel="noopener ugc nofollow" target="_blank"> unsplash </a>上拍摄)</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="44c6" class="na md it bd me nb nc nd mh ne nf ng mk jz nh ka mn kc ni kd mq kf nj kg mt nk bi translated">结论</h1><p id="61cb" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在本文中，我们重点了解了 docker 构建的方式，并通过删除所有我们不再需要的工具来最小化 docker 映像。我们可以通过多个阶段非常有效地做到这一点:执行复杂的任务，如在丰富的映像中安装和构建，然后将结果复制到更精简的最终映像中，并留下构建阶段。</p><p id="8736" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文中的例子非常少；只留下了<code class="fe nl nm nn no b">curl</code>和<code class="fe nl nm nn no b">osmium</code>。有这样的例子，我使用了一个更大的构建阶段，并通过留下我们不再需要的工件，使<strong class="lb iu">节省了超过 1.5GB </strong>，图像大小从<strong class="lb iu"> 1.8GB </strong> <strong class="lb iu">变为 0.3GB </strong>！</p><p id="6ef5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章是清楚的，但如果你有建议/澄清，请评论，以便我可以做出改进。与此同时，看看我的<a class="ae ky" href="http://mikehuls.com/articles" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">其他关于各种编程相关主题的文章</strong> </a>，比如:</p><ul class=""><li id="de49" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated"><a class="ae ky" href="https://mikehuls.medium.com/docker-for-absolute-beginners-what-is-docker-and-how-to-use-it-examples-3d3b11efd830" rel="noopener">面向绝对初学者的 Docker</a></li><li id="29f2" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><a class="ae ky" href="https://mikehuls.medium.com/docker-compose-for-absolute-beginners-how-does-it-work-and-how-to-use-it-examples-733ca24c5e6c" rel="noopener"> Docker 为绝对初学者编写</a></li><li id="7225" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">把你的代码变成一个真正的程序:使用 Docker 打包、运行和分发脚本</li><li id="55bb" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><a class="ae ky" href="https://mikehuls.medium.com/why-is-python-so-slow-and-how-to-speed-it-up-485b5a84154e" rel="noopener">Python 为什么慢，如何加速</a></li><li id="ddb0" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><a class="ae ky" href="https://mikehuls.medium.com/advanced-multi-tasking-in-python-applying-and-benchmarking-threadpools-and-processpools-90452e0f7d40" rel="noopener">Python 中的高级多任务处理:应用线程池和进程池并进行基准测试</a></li><li id="5579" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><a class="ae ky" href="https://mikehuls.medium.com/write-your-own-c-extension-to-speed-up-python-x100-626bb9d166e7" rel="noopener">写你自己的 C 扩展来加速 Python x100 </a></li><li id="ae28" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">【Cython 入门:如何在 Python 中执行&gt;每秒 17 亿次计算</li><li id="dc80" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><a class="ae ky" href="https://mikehuls.medium.com/create-a-fast-auto-documented-maintainable-and-easy-to-use-python-api-in-5-lines-of-code-with-4e574c00f70e" rel="noopener">使用 FastAPI 用 5 行代码创建一个快速自动记录、可维护且易于使用的 Python API</a></li></ul><p id="e887" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p><p id="961d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">—迈克</p><p id="5bc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">页（page 的缩写）学生:比如我正在做的事情？<a class="ae ky" href="https://mikehuls.medium.com/membership" rel="noopener">跟我来</a>！</p><div class="on oo gp gr op oq"><a href="https://mikehuls.medium.com/membership" rel="noopener follow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">通过我的推荐链接加入 Medium—Mike Huls</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">mikehuls.medium.com</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe ks oq"/></div></div></a></div></div></div>    
</body>
</html>