<html>
<head>
<title>Exploring Alternatives to Python’s Built-in Data Structures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索Python内置数据结构的替代方案</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/exploring-alternatives-to-pythons-built-in-data-structures-e3b20d933c0c#2022-05-25">https://towardsdatascience.com/exploring-alternatives-to-pythons-built-in-data-structures-e3b20d933c0c#2022-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5ffc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用强大但被低估的模块来利用数据容器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4fa10cff10b8c7073dc256a66ea74cf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5GEu7ALdCR8yy-DBK11KHg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由pix abay:<a class="ae ky" href="https://www.pexels.com/photo/blue-white-orange-and-brown-container-van-163726/" rel="noopener ugc nofollow" target="_blank">https://www . pexels . com/photo/blue-white-orange-and-brown-container-van-163726/</a></p></figure><p id="a0df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python的内置数据结构是许多操作的基础。也就是说，利用这些数据结构的用户很快就不得不接受它们的局限性。</p><p id="2802" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，Python提供了<code class="fe lv lw lx ly b">collections</code>包，该包提供了替代的数据容器，对于某些任务来说可能更好。该包包含各种数据结构，可以用来替代传统的列表、元组或字典。</p><p id="ee3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我简要介绍了这个模块中的一些容器数据类型，它们应该在您的编程库中。</p><h2 id="426e" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">1.默认字典</h2><p id="7bf6" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">在处理键值对时，字典是首选的数据结构。也就是说，他们有一个警告:访问一个不存在的键将会返回一个KeyError。</p><p id="302f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设您有以下元组列表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="026f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以将这些值存储在字典中，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="303c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一种可行的方法，但是预测不存在的键需要包含if语句。否则，当你搜索一项不在字典中的运动时，你会得到一个错误。</p><p id="da93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，访问字典中的“Rugby”键会引发一个KeyError，因为这个键不存在。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="6c50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认字典为这一困境提供了一个解决方案。它为尚未创建的键分配一个默认的数据类型。</p><p id="59d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用默认字典重复前面的任务。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="0b3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当默认的dict对象被创建时，任何没有被创建的键在被访问时将被分配一个空列表。因此，搜索不存在的键不会引发任何错误。</p><p id="b6ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，搜索“Rugby”键将返回一个空列表，而不是一个KeyError。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="8ec7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这个特性，不需要执行初始检查来在字典中搜索键。因此，可以用更少的代码行来执行该操作。</p><h2 id="4987" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">2.命名元组</h2><p id="c000" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">集合模块的命名元组是Python内置元组的变体。就内存效率而言，它是平等的，但由于其独特的功能而脱颖而出，该功能允许用户命名元组的索引。</p><p id="afa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您有一个存储运动员及其各自运动的元组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="dc87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果希望获得元组中的运动项目，可以通过调用索引来访问包含该信息的元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/b61f6d1864e864963234f7bb6b13877a.png" data-original-src="https://miro.medium.com/v2/resize:fit:144/format:webp/1*VdnISJSZ6IF7jsWRO_F4Pg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><p id="58d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一个完全有效的方法。然而，在读者看来，这一行代码可能很难理解。毕竟，元组中的索引号可以是任意的，所以代码的功能可能很难一眼看出(特别是当您处理大量索引时)。</p><p id="78e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免妨碍代码的可读性，命名元组可能是更好的选择。</p><p id="6cc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用命名元组需要创建一个命名元组对象，它包含元组的名称以及每个索引的标签。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="0bda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，您可以用命名的元组定义运动员。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="396b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的好处是用户现在可以通过标签而不是索引号来调用某些元素。下面是如何从命名元组中获取sport元素的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/b61f6d1864e864963234f7bb6b13877a.png" data-original-src="https://miro.medium.com/v2/resize:fit:144/format:webp/1*VdnISJSZ6IF7jsWRO_F4Pg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><p id="04a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法消除了所有的歧义，使读者能够准确地理解提取的是什么信息。</p><h2 id="14b6" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">3.计数器</h2><p id="d402" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">收集模块的计数器是为给定的数据收集导出计数的理想工具。</p><p id="2734" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将元素及其对应的频率存储为键值对。</p><p id="b829" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您有以下运动列表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7705" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">手动获取每项运动的计数可以通过字典来完成:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/cf199b7cefb07811f5c80d577a52c4b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*7qoQKz_K9jbkE4cF5pDKAg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><p id="86e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这是一个可以接受的解决方案，但计数器允许用户使用简单的一行程序获得相同的结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/a6f5082231f191b41c95b7a4bd0e70fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*6hfmqzTzfmRsgED0e22zWg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><p id="861c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，计数器拥有许多方法，可以方便后续任务。</p><p id="9937" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">most_common</code>方法可以找到给定数据中N个最频繁出现的元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/888f846c175b88b7b0c2e9560bd62aae.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*v8DurX3GoXahu1RG2YmXPQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><p id="4303" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">人们也可以使用计数器来比较不同的数据集合。在下面的例子中，我们找到了在第一个列表中但不在第二个列表中的元素的计数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/bdea74f260c0ea84c759e6fa778067b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*dEHHHFfKtaIRD-zAKJL77Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><h2 id="40d6" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">结论</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/ae9bee0e8fcc3692ebce83743c2e2a44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k8LRBfno5AznP7Oc"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@prateekkatyal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Prateek Katyal </a>拍摄的照片</p></figure><p id="2844" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终，Python内置数据结构的替代方案值得考虑。我鼓励尝试这样的工具，因为它们可以为某些用例提供更合适的解决方案。</p><p id="8254" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">collections</code>模块中的许多容器数据类型功能强大，但没有得到充分利用。理解和实现它们应该很容易，因为它们是Python内置数据结构的变体。</p><p id="106d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，这并不是对<code class="fe lv lw lx ly b">collections</code>模块效用的全面概括。如果你对这个模块中的其他容器数据类型感兴趣，可以在模块的<a class="ae ky" href="https://docs.python.org/3/library/collections.html" rel="noopener ugc nofollow" target="_blank">文档</a>中了解它们。</p><p id="4f99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div></div>    
</body>
</html>