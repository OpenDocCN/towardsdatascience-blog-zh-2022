<html>
<head>
<title>5 SQL Functions Every Analytics Engineer Needs to Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个分析工程师都需要知道的5个SQL函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-sql-functions-every-analytics-engineer-needs-to-know-e356b26495c2#2022-08-26">https://towardsdatascience.com/5-sql-functions-every-analytics-engineer-needs-to-know-e356b26495c2#2022-08-26</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""/><div class=""><h2 id="e2f9" class="pw-subtitle-paragraph js iu iv bd b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj dk translated">从基础到窗口功能，你会一直用到它们</h2></div><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/8c8fefc67bdb7d108ffa861b0543123a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*55qRevgpZ1D6TuCPaKqjyQ.jpeg"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">蒂姆·莫斯霍尔德在<a class="ae la" href="https://unsplash.com/s/photos/know?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="749a" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">SQL无疑是每个分析工程师都需要知道的最重要的技能。这是基础性的，也是数据从业者经常忽略的顶级技能。因为它没什么“新的”或“新奇的”，所以被搁置了。但是，为了编写高质量的数据模型，您需要能够编写干净、简洁的SQL代码。</p><p id="8bc8" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">SQL是数据建模的核心。虽然这不是数据建模的唯一方面，但它占了数据建模的很大一部分。虽然您也可以在不了解SQL的情况下编写数据模型，例如通过使用拖放模型来编写SQL函数，但SQL仍然是大多数分析工程师用来构建数据模型的工具。</p><p id="4a4a" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">编写清晰、简洁的SQL代码可以为您的数据模型带来很多好处。首先，它可以帮助您的模型运行得更快，当您的查询以最佳方式编写时，使用更少的计算能力。其次，它可以帮助您拼凑复杂的数据集，计算关键业务指标。第三，写得好的话，代码可以随着你的业务扩展，减少你的技术债务。</p><h1 id="1c6d" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">为什么分析工程师需要练习SQL</h1><p id="60a1" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">虽然您可能认为只了解SQL基础知识会让您走得更远，但是您可以了解基础知识，仍然可以编写糟糕的代码。分析工程师需要不断实践新功能，重写查询以更好地优化它们。数据模型应该总是针对可伸缩性、运行时和效率进行优化。为了专注这三件事，你需要学会写干代码。这意味着您必须提前考虑，并以可伸缩的方式编写SQL查询。在找到理想的解决方案之前，你可能会遇到一些死胡同。</p><p id="477e" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">您的SQL代码也需要考虑可读性。同样，这需要练习。你需要让你自己接受团队成员的代码审查，以便学会编写每个人都能理解的代码。对你来说容易读懂的，对别人来说未必有意义。每次你写一段代码时，添加注释并做出修改，这样别人就能确切地知道<em class="mu">代码在做什么</em>。可读性总是胜过复杂性。</p><p id="a39e" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">最后，作为分析工程师，我们需要计算核心指标并拼凑复杂的数据集。企业依靠我们来解决这些问题，并提供他们可以依赖的数据集。当我第一次想成为一名分析工程师时，我在<a class="ae la" href="https://leetcode.com/" rel="noopener ugc nofollow" target="_blank"> Leetcode </a>上练习了大量现实世界的商业问题。这帮助我学习了SQL函数，比如窗口函数，帮助我以我需要的方式解决问题。如果您习惯于编写基本的连接和聚合，练习更复杂的业务相关问题可以扩展其他类型函数的使用。</p><h1 id="b8a7" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">你需要知道的5个SQL函数</h1><p id="a19a" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">作为一名分析工程师，我使用两种类型的SQL函数，一种是我可以一直依赖的，另一种是我发现在解决复杂问题时非常有用的。你很自然地会比其他人更频繁地使用一些功能，但是当一个特定的用例需要它时，你总是很高兴你知道的那个<em class="mu">独特的</em>。让我们来看看我的前5名。</p><h2 id="c5f5" class="mv ly iv bd lz mw mx dn md my mz dp mh lk na nb mj lo nc nd ml ls ne nf mn ng bi translated"><strong class="ak">伯爵()</strong></h2><p id="7847" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">验证是数据建模的一大部分。无论您是重写一个已经存在的数据模型，还是完全从头开始编写一个数据模型，您都需要在编写之后对其进行验证。这涉及到一些最佳实践，比如将模型与其基本数据表进行比较，以及计算具有某些特征的行数。执行此操作时，COUNT()函数很方便。它允许您对模型和基表中的列进行分组，并对它们的值进行计数，以便于比较。</p><p id="05ac" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我经常用COUNT()来统计某月或某年生成的行数。这确保了模型在所有时刻都正确运行，而不仅仅是在一个孤立的时间段内。</p><p id="8a69" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">假设我需要验证一个order_details模型。我想将模型中每年的订单数与基础模型中的订单数进行比较。如果计数几乎相同，那么我知道我模型写的是正确的。如果没有，我可能需要更改一些逻辑，以使结果匹配。</p><p id="7ce9" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我的查询应该是这样的:</p><pre class="kl km kn ko gt nh ni nj nk aw nl bi"><span id="3bdc" class="mv ly iv ni b gy nm nn l no np">SELECT<br/>   YEAR(ordered_at) AS year,<br/>   COUNT(order_id)<br/>FROM order_details<br/>GROUP BY YEAR(ordered_at)</span></pre><p id="901b" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">根据需要验证的列，也可以用另一个值替换year(ordered_at)。</p><p id="c63f" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">COUNT()函数也非常有助于您更好地理解数据集。它可以告诉你你的数据是如何分布的，在某一列中哪些值是最受欢迎的。这就是为什么像COUNT()这样的集合函数是初学者课程中最先教给你的函数之一！</p><h2 id="2b94" class="mv ly iv bd lz mw mx dn md my mz dp mh lk na nb mj lo nc nd ml ls ne nf mn ng bi translated"><strong class="ak"> ROW_NUMBER() </strong></h2><p id="22a3" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">现在，这个可能会让你吃惊。许多人说学习窗口函数不是必须的，但我不敢苟同。虽然它们不用于日常工作，但当你遇到复杂的问题时，它们会派上用场。很多时候这个问题<em class="mu">不使用窗口函数</em>是解决不了的。或者，查询执行起来极其缓慢，难以理解。</p><p id="5cb9" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">ROW_NUMBER()根据指定的分区和顺序排列值。您可以指定要分区的内容或值的分组依据，以及这些组中值的排序顺序。</p><p id="d3bd" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">例如，如果您按学生的数学成绩对他们进行排名，但按性别对他们进行分类，则查询如下所示:</p><pre class="kl km kn ko gt nh ni nj nk aw nl bi"><span id="525f" class="mv ly iv ni b gy nm nn l no np">SELECT<br/>   first_name,<br/>   ROW_NUMBER() OVER(PARTITION BY gender ORDER BY score DESC) AS rank_by_gender<br/>FROM student_scores</span></pre><p id="3219" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我们按性别将他们分开，然后从大到小排序。您将看到两个相同的“rank_by_gender ”,因为为两种性别生成了相同的值。</p><p id="562d" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我曾经在拼凑web会话序列、确定用户最近的订单以及发现订单从哪个仓库发出时使用过这个函数。当消除值略有不同的重复主键时，这很方便，这是连接数据集时的最佳实践。</p><p id="ea01" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">您还可以使用RANK()函数，它的作用类似于“排列”值。不过我发现ROW_NUMBER()更直观，更容易理解。</p><h2 id="826a" class="mv ly iv bd lz mw mx dn md my mz dp mh lk na nb mj lo nc nd ml ls ne nf mn ng bi translated"><strong class="ak"> DATEDIFF() </strong></h2><p id="b740" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">有许多业务指标要求您计算时间段，有时以天为单位，有时以周为单位，甚至可能以月为单位。DATEDIFF()以您指定的单位计算两个日期或时间戳之间的时间。这使得分析工程师不必将时间段转换成所需的单位。DATEDIFF()简单地返回您正在寻找的任何单位。</p><p id="ad02" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">您可以使用的一些值如下:</p><ul class=""><li id="a218" class="nq nr iv ld b le lf lh li lk ns lo nt ls nu lw nv nw nx ny bi translated">年</li><li id="84bc" class="nq nr iv ld b le nz lh oa lk ob lo oc ls od lw nv nw nx ny bi translated">四分之一</li><li id="9370" class="nq nr iv ld b le nz lh oa lk ob lo oc ls od lw nv nw nx ny bi translated">工作日</li><li id="caf2" class="nq nr iv ld b le nz lh oa lk ob lo oc ls od lw nv nw nx ny bi translated">分钟</li></ul><p id="7a49" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我个人发现季度在计算季度指标时非常有用。DATDIFF()将返回您传递的两个日期值之间的季度数，这使得区分业务将会增长的时间段变得非常容易。我还发现DATEDIFF()有助于计算用户的web会话时间。这通常包括将网站上的不同事件拼凑在一起，并计算第一个和最后一个事件之间的时间。</p><p id="7f83" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">下面是我如何使用它来计算用户会话持续时间的示例:</p><pre class="kl km kn ko gt nh ni nj nk aw nl bi"><span id="e740" class="mv ly iv ni b gy nm nn l no np">SELECT<br/>   user_id,<br/>   device,<br/>   session_started_at,<br/>   session_ended_at,<br/>   DATEDIFF(second, session_started_at, session_ended_at) AS session_duration<br/>FROM user_sessions</span></pre><p id="cb6f" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">现在，您可以计算用户会话开始和结束之间的秒数差，而不必从一个单位转换到另一个单位。</p><h2 id="920a" class="mv ly iv bd lz mw mx dn md my mz dp mh lk na nb mj lo nc nd ml ls ne nf mn ng bi translated"><strong class="ak">剧组()</strong></h2><p id="e438" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">虽然CAST()是一个相当简单的SQL函数，但它是我几乎每天都要使用的函数。在编写基本模型时，这是一个关键的功能。在基本模型中，您希望在将日期和数据类型用于组合来自多个不同来源的数据的数据模型之前，对它们进行标准化。CAST()确保所有的日期和时间戳都是同一类型。</p><p id="dbb9" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">当我第一次开始编写数据模型时，我假设所有的时间戳函数都是相同的。当web会话记录每天都在减少时，我很快意识到情况并非如此。原来我写的一个模型是比较两种不同类型的时间戳，排除了关键会话。幸运的是，我能够发现这个问题，并将我的所有时间戳列转换为相同的数据类型——确切地说是timestamp_ntz。</p><p id="0c72" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">使用CAST()的基本模型通常如下所示:</p><pre class="kl km kn ko gt nh ni nj nk aw nl bi"><span id="ab02" class="mv ly iv ni b gy nm nn l no np">SELECT<br/>   ad_id,<br/>   ad_name,<br/>   platform,<br/>   CAST(date_created AS date) AS date_created,<br/>   CAST(created_at AS timestamp_ntz) AS created_at<br/>FROM ads</span></pre><p id="5ecf" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">而且，如果您喜欢SQL快捷方式，这也会将值转换为您指定的数据类型:</p><p id="3cd2" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated"><code class="fe oe of og ni b">created_at::timestamp_ntz</code></p><p id="d504" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">CAST()函数也可用于其他数据类型，如下所示:</p><ul class=""><li id="0b33" class="nq nr iv ld b le lf lh li lk ns lo nt ls nu lw nv nw nx ny bi translated">小数</li><li id="35f7" class="nq nr iv ld b le nz lh oa lk ob lo oc ls od lw nv nw nx ny bi translated">二进制的</li><li id="b178" class="nq nr iv ld b le nz lh oa lk ob lo oc ls od lw nv nw nx ny bi translated">（同Internationalorganizations）国际组织</li><li id="bd87" class="nq nr iv ld b le nz lh oa lk ob lo oc ls od lw nv nw nx ny bi translated">茶</li></ul><p id="8a74" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">虽然您不一定要在基本模型中的每一列上使用CAST()函数，但是一定要将它应用于经常涉及比较或连接的列。这些是真正重要的栏目。您不希望在连接或筛选时得到不正确的结果，因为数据类型的比较方式很奇怪。</p><h2 id="3f90" class="mv ly iv bd lz mw mx dn md my mz dp mh lk na nb mj lo nc nd ml ls ne nf mn ng bi translated"><strong class="ak"> SUM() </strong></h2><p id="5276" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">SUM()是另一个经典的聚合函数。由于它的实用性，尤其是在商业中，它是最常用的方法之一。通常使用SUM()来计算支出、收入和激活次数。然而，它也有助于分析工程师验证数据模型。</p><p id="70b1" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">类似于COUNT()，它可用于比较模型和基表之间的值。例如，如果您为公司收入创建了一个数据模型，您希望确保它等于可以在基本模型中计算的利润和损失。如果您计算出来自一个基本模型的钱比模型预测的多，您可能需要仔细检查逻辑。</p><p id="7e6f" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">SUM()在比较数值列的实际值而不仅仅是行数时非常方便。这是一种不同类型的验证，由一个同样有用的人来验证。</p><p id="17ce" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">让我们回到order_details模型。我想计算所有订单中售出的产品数量。我将查找某个月内所下订单的产品数量总和。然后，我将这个数字与orders基表的相同查询进行比较。</p><pre class="kl km kn ko gt nh ni nj nk aw nl bi"><span id="82b4" class="mv ly iv ni b gy nm nn l no np">SELECT<br/>   SUM(product_quantity)<br/>FROM order_details<br/>WHERE ‘2021–01–01 &lt;= order_date &lt;= ‘2021–01–31’</span></pre><p id="f89b" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">现在，即使每个表中的COUNT()行匹配，我们也可以检查特定的数量是否匹配。</p><h1 id="211e" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">结论</h1><p id="f3a9" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">强大的SQL是每个分析工程师为了成功都需要学习的基本技能。为了提高数据建模技能，这是您需要不断练习的事情之一。尽管它可能被视为一项“基本”技能，但在你的职业生涯中不断提高它仍然是必不可少的。没有人会在没有练习的情况下变得更好。我强烈建议每天在Leetcode上做一到两个SQL问题，帮助你优化查询，学习解决业务问题的新方法。</p><p id="ef18" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">学习更好的SQL实践只会有助于优化您的数据模型，使它们更快、更可读。改进的数据模型将渗透到数据团队工作的其他方面，在公司内部培养更好的数据文化。</p><p id="e0b5" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">训练和提高SQl技能的一种方法是使用类似于<a class="ae la" href="https://www.y42.com/product/model?utm_source=medium_tds&amp;utm_medium=organic&amp;utm_campaign=sql_functions_article" rel="noopener ugc nofollow" target="_blank"> Y42 </a>这样的工具，它允许你使用无代码、低代码或SQL查询来构建模型。通过这种方式，您可以逐渐地从不用编写一行代码，到使用基本的SQL查询，再到完全用SQL编写您的模型。您可以使用您最熟悉的任何函数来混合、匹配和构建您的模型，但是您也可以直接进入SQL模型，并将我刚才与您分享的所有函数付诸实践。</p><p id="6508" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">看看我的第一本电子书，<a class="ae la" href="https://madisonmae.gumroad.com/l/learnanalyticsengineering" rel="noopener ugc nofollow" target="_blank">分析工程基础知识</a>，一本全方位的分析工程入门指南。</p></div></div>    
</body>
</html>