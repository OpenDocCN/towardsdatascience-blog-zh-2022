<html>
<head>
<title>Building Word Correctors and Code Comparison Tools with Python enums and difflib.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python 枚举和 difflib 构建单词校正器和代码比较工具。</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-word-correctors-and-code-comparison-tools-with-python-enums-and-difflib-860d369d53d1#2022-02-13">https://towardsdatascience.com/building-word-correctors-and-code-comparison-tools-with-python-enums-and-difflib-860d369d53d1#2022-02-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d64d48c5c618c44a038abde668a88909.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ak9uUdTsphEk_XPMqPvr8Q.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@nordwood" rel="noopener ugc nofollow" target="_blank">诺德伍德主题</a>在<a class="ae kf" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="564e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python 总是以其几乎无穷无尽的模块和 API 适应任何平台给我们带来惊喜。无论何时，只要您有时间阅读文档，寻找实际的实现，总有一些东西需要学习。此外，当您发现某些模块时，您可以想到有趣的用例，反之亦然。</p><p id="5b51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在 Python 附带的有趣的附加元素中，我们将在这个简短的教程中关注两个 gem，即<code class="fe le lf lg lh b">enums ( since Python 3.4 )</code>和<code class="fe le lf lg lh b">difflib ( since Python 2.1 )</code>，以解决与词法纠正和版本代码比较相关的简单用例。</p><p id="0572" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第一部分中，我们试图提出一个带有枚举的 Python 词法校正器。在第二部分，我们缓慢但稳定地过渡到使用<code class="fe le lf lg lh b">difflib</code>，并尝试用它构建一个小的代码比较工具。</p><h2 id="672b" class="li lj it bd lk ll lm dn ln lo lp dp lq kr lr ls lt kv lu lv lw kz lx ly lz ma bi translated"><strong class="ak"> 1。枚举</strong>:</h2><p id="79f5" class="pw-post-body-paragraph kg kh it ki b kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz mf lb lc ld im bi translated">枚举器也是用其他编程语言实现的数据结构。它们帮助我们建立一组带有常量值的逻辑实体。<br/>根据官方文件:</p><blockquote class="mg mh mi"><p id="186a" class="kg kh mj ki b kj kk kl km kn ko kp kq mk ks kt ku ml kw kx ky mm la lb lc ld im bi translated">枚举是绑定到唯一常数值的一组符号名称(成员)。在枚举中，成员可以通过标识进行比较，并且枚举本身可以被迭代。</p></blockquote><p id="1413" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一般来说，建议用大写字母指定成员。我们不一定会一直遵守这条规则。</p><p id="06c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们宣布一个<code class="fe le lf lg lh b">DSStrategy</code>，它包含任何数据科学策略的通用和重要步骤:</p><pre class="mn mo mp mq gt mr lh ms mt aw mu bi"><span id="4a6a" class="li lj it lh b gy mv mw l mx my">from enum import Enum</span><span id="4041" class="li lj it lh b gy mz mw l mx my">class DSStrategy(Enum):<br/>    Cleaning = 1<br/>    Exploring = 2<br/>    Learning = 3<br/>    Evaluating = 4</span></pre><p id="a5e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以像这样循环遍历枚举结构:</p><pre class="mn mo mp mq gt mr lh ms mt aw mu bi"><span id="ab6f" class="li lj it lh b gy mv mw l mx my">&gt;&gt;&gt; for strategy in Strategy:<br/>...    print(strategy, end=" "), print(strategy.value)</span><span id="70a1" class="li lj it lh b gy mz mw l mx my">Strategy.Cleaning 1<br/>Strategy.Exploring 2<br/>Strategy.Learning 3<br/>Strategy.Evaluating 4</span></pre><p id="a3ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有趣的事情:我们有一组<a class="ae kf" href="#https://docs.python.org/3/library/enum.html#supported-sunder-names" rel="noopener ugc nofollow">分解方法</a>可以用来将额外的行为分层到我们的枚举器中。例如，当我们声明成员时，<code class="fe le lf lg lh b">_order_</code>分隔符规定了特定的顺序。假设你不遵守指示的顺序:</p><pre class="mn mo mp mq gt mr lh ms mt aw mu bi"><span id="010e" class="li lj it lh b gy mv mw l mx my">&gt;&gt;&gt; class DSStrategy(Enum):<br/>...    _order_ = 'Cleaning Exploring Learning Evaluating'<br/>...    Cleaning = 1<br/>...    Learning = 2<br/>...    Exploring = 3<br/>...    Evaluating = 4</span><span id="1ed8" class="li lj it lh b gy mz mw l mx my">...<br/>TypeError: member order does not match _order_</span></pre><p id="6fc3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果成员的值不重要，将每个成员与<code class="fe le lf lg lh b">auto</code>实例相关联就可以了。然后，Enum 类将为您计算出这些值。如果没有指定，默认情况下，该值从 1 开始。</p><pre class="mn mo mp mq gt mr lh ms mt aw mu bi"><span id="03c9" class="li lj it lh b gy mv mw l mx my">&gt;&gt;&gt; from enum import Enum, auto</span><span id="c231" class="li lj it lh b gy mz mw l mx my">&gt;&gt;&gt; class DSStrategy(Enum):<br/>...    _order_ = 'Cleaning Exploring Learning Evaluating'<br/>...    Cleaning = auto()<br/>...    Exploring = auto()<br/>...    Learning = auto()<br/>...    Evaluating = auto()<br/>    <br/>&gt;&gt;&gt; for strategy in Strategy:<br/>...    print(strategy, end=" "), print(strategy.value)</span><span id="5380" class="li lj it lh b gy mz mw l mx my">Strategy.Cleaning 1<br/>Strategy.Exploring 2<br/>Strategy.Learning 3<br/>Strategy.Evaluating 4</span></pre><p id="f2d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">枚举器使用起来非常简单，不会引起太多的麻烦..并不总是这样！<br/>我们的下一个用例将枚举带到了下一个层次。我们将构建一个小而简单的词法 Python 校正器。</p><p id="1ef5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们最初为枚举器提供 Python 关键字，以单下划线为前缀，并将类型和错误消息作为值。使用单下划线不是为了扰乱成员的可访问性、名称空间或类似的东西。只是从语法上来说，不能使用简单的 python 关键字作为变量或成员。这是我想到的第一个简单的解决方法，所以我应用了它。</p><figure class="mn mo mp mq gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="cf13" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">__init__</code>方法将每个成员视为一个整体实例。它调用第一个和第二个值作为成员的属性。<code class="fe le lf lg lh b">custom_message</code>方法用于动态构建一个<code class="fe le lf lg lh b">property</code>,显示一条消息来警告我们出现了词法错误。</p><p id="5cbe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们编写了一个小库，在其中我们故意注入了一些词法错误:</p><figure class="mn mo mp mq gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="1c7c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将它保存到一个本地文件中，并用一些基于正则表达式的处理加载它:</p><figure class="mn mo mp mq gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="9020" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意<code class="fe le lf lg lh b">lines_of_code</code>是如何存储预处理的代码行的:</p><pre class="mn mo mp mq gt mr lh ms mt aw mu bi"><span id="2002" class="li lj it lh b gy mv mw l mx my">&gt;&gt;&gt; lines_of_code</span><span id="cbcf" class="li lj it lh b gy mz mw l mx my">['def_ add x  y  ',<br/> 'return x   y',<br/> '',<br/> 'def sub x  y  ',<br/> 'return x   y',<br/> '',<br/> 'deff mul x  y  ',<br/> 'returnn x   y',<br/> '',<br/> 'def div x  y  ',<br/> 'tryy  ',<br/> 'return x   y',<br/> 'exceptt ',<br/> 'print  Problem dividing by 0.  ',<br/> 'return Nonne']</span></pre><p id="2d89" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们编写一个函数，一行一行地扫描<code class="fe le lf lg lh b">lines_of_code</code>，一次看一行，扫描每个单词，并与我们的<code class="fe le lf lg lh b">KeyWords</code>枚举器中定义的 python 关键字列表进行比较。</p><figure class="mn mo mp mq gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="cfa1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们慢慢地开始过早地揭开一些<code class="fe le lf lg lh b">difflib</code>的美丽。注意使用了<code class="fe le lf lg lh b">get_close_matches</code>来查找最近的单词。我们稍后将对此进行详细阐述。让我们首先测试我们的功能。我们用<code class="fe le lf lg lh b">__members__</code>属性调用关键字成员列表。</p><pre class="mn mo mp mq gt mr lh ms mt aw mu bi"><span id="6bbf" class="li lj it lh b gy mv mw l mx my">&gt;&gt;&gt; check_and_correct(lines_of_code, KeyWords.__members__)</span><span id="5d16" class="li lj it lh b gy mz mw l mx my">Error at line 0 .<br/>Function definer. Careful how you define your function. <br/>Error at line 6 .<br/>Function definer. Careful how you define your function. <br/>Error at line 7 .<br/>Return Keyword. Careful how you close your functions !<br/>Error at line 10 .<br/>Exception Keyword. Easier to ask for forgiveness than permission. Wink wink !<br/>Error at line 14 .<br/>None operator. You should be reviewing your None usage.</span></pre><p id="a94b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实验很有趣，但是没有检测到一些错误的行，这是可以理解的，因为我们只向枚举器提供了所有 Python 关键字的子集。因此，我们没有足够的地面真相。</p><p id="ca49" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">拥有所有 Python 关键字的更正确和完整的方法是调用<code class="fe le lf lg lh b">keyword</code>库并调用它的<code class="fe le lf lg lh b">kwlist</code>实例。您可能会找到组成 Python 语法的所有关键词。</p><pre class="mn mo mp mq gt mr lh ms mt aw mu bi"><span id="e4f0" class="li lj it lh b gy mv mw l mx my">&gt;&gt;&gt; from keyword import kwlist<br/>&gt;&gt;&gt; for kw in kwlist: print(kw, end=" |")</span><span id="bd54" class="li lj it lh b gy mz mw l mx my">False |None |True |and |as |assert |async |await |break |class |continue |def |del |elif |else |except |finally |for |from |global |if |import |in |is |lambda |nonlocal |not |or |pass |raise |return |try |while |with |yield |</span></pre><p id="e0dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们稍微修改一下前面的函数，使其适应新的关键字查找列表:</p><figure class="mn mo mp mq gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="502d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来的内容清楚地表明，我们的模块拦截了更多的词法不规则性:</p><pre class="mn mo mp mq gt mr lh ms mt aw mu bi"><span id="6940" class="li lj it lh b gy mv mw l mx my">&gt;&gt;&gt; check_and_correct_kwlist(lines_of_code, kwlist)</span><span id="b084" class="li lj it lh b gy mz mw l mx my">Error at line 0.<br/>Maybe you wanted to write def instead of def_.<br/>Error at line 6 .<br/>Maybe you wanted to write def instead of deff.<br/>Error at line 7 .<br/>Maybe you wanted to write return instead of returnn.<br/>Error at line 10 .<br/>Maybe you wanted to write try instead of tryy.<br/>Error at line 12 .<br/>Maybe you wanted to write except instead of exceptt.<br/>Error at line 14 .<br/>Maybe you wanted to write None instead of Nonne.</span></pre><p id="8476" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们对我们的小型修正引擎更有信心，因为我们有一个更完整的关键字集(不像我们的关键字枚举器仍然缺少一些)。</p><p id="16ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能仍然对<code class="fe le lf lg lh b">get_close_matches</code>功能感到好奇，您应该深入了解一下。让我们在英语词汇的一个重要的<a class="ae kf" href="https://github.com/dwyl/english-words/blob/master/words_alpha.txt" rel="noopener ugc nofollow" target="_blank">子集上尝试一下，并从中构建一个单词校正器。首先，我们将词汇表作为一个列表加载:</a></p><pre class="mn mo mp mq gt mr lh ms mt aw mu bi"><span id="6553" class="li lj it lh b gy mv mw l mx my">with open('words_alpha.txt','r') as f:<br/>    lines = [line.lstrip(' ').rstrip('\n') for line in f]</span></pre><p id="971a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我能想到的第一个词:<code class="fe le lf lg lh b">computers</code>。让我们寻找<code class="fe le lf lg lh b">compputeers</code>，这样我们就可以测试校正器了:</p><pre class="mn mo mp mq gt mr lh ms mt aw mu bi"><span id="77b0" class="li lj it lh b gy mv mw l mx my">&gt;&gt;&gt; get_close_matches('compputeers', lines, n = 4, cutoff = .8)</span><span id="ff7d" class="li lj it lh b gy mz mw l mx my">['computers', 'computes', 'computer', 'compeers']</span></pre><p id="6212" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用非常直观。<code class="fe le lf lg lh b">1st</code>和<code class="fe le lf lg lh b">2nd</code>自变量分别代表要查找的单词和要提供的查找列表。<code class="fe le lf lg lh b">n</code>是与搜索的单词最相似的候选单词的数量。<code class="fe le lf lg lh b">cutoff</code>是一个相似性得分阈值，低于该阈值的候选人将不予考虑。这将节省你很多时间来探索和测试其他模糊匹配和相似性包。<code class="fe le lf lg lh b">difflib</code>是标准库的纯宝石。</p><h2 id="c6b2" class="li lj it bd lk ll lm dn ln lo lp dp lq kr lr ls lt kv lu lv lw kz lx ly lz ma bi translated">2.difflib 的增量:</h2><p id="e627" class="pw-post-body-paragraph kg kh it ki b kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz mf lb lc ld im bi translated">通俗地说，<code class="fe le lf lg lh b">difflib</code>是一个比较序列的包，无论是简单的列表，字符串等等。</p><p id="108b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在许多方面，似乎<code class="fe le lf lg lh b">difflib</code>比我们之前看到的更有诱惑力。我们能想到的一个有趣的用例是代码比较器。我们的目的是比较两个版本的基本平均计算模块。</p><p id="1757" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi nc translated">还记得当你是一个完全的 Python 初学者时，你奋力克服了它。凭借当时获得的技能，你最初的反应会驱使你写下以下内容:</p><pre class="mn mo mp mq gt mr lh ms mt aw mu bi"><span id="11b6" class="li lj it lh b gy mv mw l mx my"><em class="mj">## V1.py</em></span><span id="f3bb" class="li lj it lh b gy mz mw l mx my">def compute_average_V1(elements):<br/>    sum_elements = 0<br/>    for el in elements:<br/>        sum_elements += el<br/>    length = len(elements)<br/>    mean = sum_elements / length<br/>    return mean</span></pre><p id="b9c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，由于您从未停止学习并热衷于优化您的代码，在您编写新版本一年后:</p><pre class="mn mo mp mq gt mr lh ms mt aw mu bi"><span id="fb66" class="li lj it lh b gy mv mw l mx my"><em class="mj">## V2.py</em></span><span id="310f" class="li lj it lh b gy mz mw l mx my">def compute_average_V2(elements):<br/>    sum_elements = sum(elements)<br/>    mean = sum_elements / len(elements)<br/>    return mean</span></pre><p id="b379" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，你正在想比较这两个版本的最快方法。让我们一起努力吧。首先，我们将两个版本都作为列表加载。</p><figure class="mn mo mp mq gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="388c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们决定将它们作为两个<strong class="ki iu">大</strong>字符串进行比较:</p><pre class="mn mo mp mq gt mr lh ms mt aw mu bi"><span id="e984" class="li lj it lh b gy mv mw l mx my">V1 = ' '.join(lines_of_code_V1)<br/>V2 = ' '.join(lines_of_code_V2)</span></pre><p id="e807" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以第一个版本应该是这样的:</p><pre class="mn mo mp mq gt mr lh ms mt aw mu bi"><span id="db13" class="li lj it lh b gy mv mw l mx my">'def compute_average_V1(elements): sum_elements = 0 for el in elements: sum_elements += el length = len(elements) mean = sum_elements / length return mean'</span></pre><p id="8d60" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">出于好奇，我们用<code class="fe le lf lg lh b">SequenceMatcher</code>类检查两个版本之间的任何相似之处。我们可以把它看作一个 API，帮助我们捕获和匹配两个字符串共有的部分:</p><pre class="mn mo mp mq gt mr lh ms mt aw mu bi"><span id="50b5" class="li lj it lh b gy mv mw l mx my">&gt;&gt;&gt; from difflib import SequenceMatcher<br/>&gt;&gt;&gt; sm = SequenceMatcher(None, V1, V2)</span><span id="790b" class="li lj it lh b gy mz mw l mx my">&gt;&gt;&gt; for block in sm.get_matching_blocks():<br/>...    print(block)</span><span id="6684" class="li lj it lh b gy mz mw l mx my">Match(a=0, b=0, size=21)<br/>Match(a=22, b=22, size=27)<br/>Match(a=71, b=49, size=3)<br/>Match(a=102, b=52, size=36)<br/>Match(a=139, b=95, size=1)<br/>Match(a=141, b=98, size=12)<br/>Match(a=153, b=110, size=0)</span></pre><p id="384c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管看起来很有趣，但它并没有提供足够的信息来动态地告诉我们代码进化是如何进行的。我们可以尝试另一种方法:</p><figure class="mn mo mp mq gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="9767" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">get_opcodes</code>在从第一个版本到第二个版本所需的透明性和操作方面非常优雅。<br/>在每个操作码的开头，你知道代码片段是否被替换、删除或者在整个版本中保持不变。<br/> <code class="fe le lf lg lh b">difflib</code>提供了第二个 api，它更侧重于计算差异，而不是匹配序列，这也有一个简单的实现。</p><figure class="mn mo mp mq gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="5706" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">different delta 的每一行都以两个字母的代码开头:</p><ul class=""><li id="a117" class="nl nm it ki b kj kk kn ko kr nn kv no kz np ld nq nr ns nt bi translated"><code class="fe le lf lg lh b">‘- ‘ </code>:表示该行是版本 1 独有的。</li><li id="fff7" class="nl nm it ki b kj nu kn nv kr nw kv nx kz ny ld nq nr ns nt bi translated"><code class="fe le lf lg lh b">‘+ ’</code>:表示该行是版本 2 独有的</li><li id="25db" class="nl nm it ki b kj nu kn nv kr nw kv nx kz ny ld nq nr ns nt bi translated"><code class="fe le lf lg lh b">‘‘ </code>:表示该行为两个版本所共有。</li><li id="2fa6" class="nl nm it ki b kj nu kn nv kr nw kv nx kz ny ld nq nr ns nt bi translated"><code class="fe le lf lg lh b">‘? ‘ </code>:表示该行在两个序列中都不存在。这也意味着该行可能只是描述了导致上面行中增量的特定字符。</li></ul><p id="ed80" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么，你把所有关于差异的细节汇总到一个格式化的文件中怎么样？第三个有趣的 API 允许将增量转换成 HTML 页面，如果代码片段更大的话，这个页面会更直观、更易读。</p><pre class="mn mo mp mq gt mr lh ms mt aw mu bi"><span id="9533" class="li lj it lh b gy mv mw l mx my">from difflib import HtmlDiff</span><span id="fe46" class="li lj it lh b gy mz mw l mx my">htmlDiff = HtmlDiff()<br/>result = htmlDiff.make_file(lines_of_code_V1, lines_of_code_V2)<br/>with open('comparison_result.html','w') as file :<br/>    file.write(result)</span></pre><p id="e9fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们剩下要做的就是通过浏览器打开文件:</p><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nz"><img src="../Images/01304395f3d9863c4faada186987801c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RmUxWqiqJru4799Tb4LwoQ.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">作者拍摄的照片</p></figure><p id="4a5d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你现在对自己在学习道路上的进步有了更清晰的认识。这个工具可以帮助你做到这一点。</p></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h2 id="085d" class="li lj it bd lk ll lm dn ln lo lp dp lq kr lr ls lt kv lu lv lw kz lx ly lz ma bi translated">参考</h2><p id="b37d" class="pw-post-body-paragraph kg kh it ki b kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz mf lb lc ld im bi translated">公文— <a class="ae kf" href="https://docs.python.org/3/library/enum.html" rel="noopener ugc nofollow" target="_blank">列举</a>和<a class="ae kf" href="https://docs.python.org/3/library/difflib.html" rel="noopener ugc nofollow" target="_blank"> difflib </a></p></div></div>    
</body>
</html>