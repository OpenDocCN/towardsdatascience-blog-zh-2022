<html>
<head>
<title>How to do fast multiplication using the FFT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用FFT进行快速乘法运算</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-perform-fast-multiplications-in-science-using-the-fft-b751fafc2bac#2022-05-18">https://towardsdatascience.com/how-to-perform-fast-multiplications-in-science-using-the-fft-b751fafc2bac#2022-05-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="aab7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">当前的深度学习工作流依赖于成千上万的整数乘法，因此获得高效的乘法性能现在至关重要。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9ea369bf477f6315294e82c727cc9276.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r51o8l--4agY9I1R"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/es/@vandehei?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Gsightfotos </a>拍摄</p></figure><p id="36ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">乘法运算是许多科学和数据科学应用中的核心。这种操作的复杂性不是线性的，因此在时间上对其进行缩放可能是一项难以实现的任务。当前的深度学习工作流依赖于成千上万的整数乘法，并且这个数字随着DL架构的复杂性或训练模型的可用数据而增长。因此，如今获得高效的乘法性能至关重要。本文展示了如何使用20世纪最重要的信号发现快速傅立叶变换来执行整数乘法。</p><p id="d77a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不仅深度学习卷积依赖于整数乘法，其他科学和计算应用，如高倍渲染分形图像和公钥密码学，都依赖于整数乘法。经典的向量乘法复杂度为O(N)，其中<em class="ls"> N </em>是位数。几乎可以说，O(logN)以上的任何复杂度都很难在众核平台上扩展，这意味着尽管我们的云基础设施中的计算单元数量增加了，但它将成为我们计算的瓶颈。任何编译器优化，以及其他性能技术，如平铺或缓存策略，都是无用的，除非降低二次复杂度。有可能降低传统乘法运算的复杂性吗？是的，它是。</p><h1 id="316e" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">一切都是关于多项式的</h1><p id="0d02" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在解释如何降低乘法运算的复杂度之前，我先给大家演示一下<strong class="ky ir">任意一个基数为<em class="ls"> x </em>的整数都可以分解成一个多项式系数向量</strong>。生成的多项式由一组系数描述，原始整数通过计算基数为<em class="ls"> x: </em>的多项式来构建</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/77f43efd0565ab3ecfba5fee13364cc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*6L7ov4r3hbz759toWbW08w.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="62e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">系数的个数等于位数；也就是多项式的大小。这被称为<strong class="ky ir">系数表示</strong>。请记住，在数学课中，两个多项式的乘积会产生第三个大小为<em class="ls"> 2N、</em>的多项式，这个过程称为矢量卷积。</p><p id="7c31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面我声称任何具有N位数的整数都可以分解成一个大小为<em class="ls"> N、</em>的多项式，并且两个大小为<em class="ls"> N </em>的多项式的乘积是另一个大小为<em class="ls"> 2N </em>的多项式。下一个问题是知道如何执行多项式乘法:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/308ee2b9b8f0ab8ab907b4dc82667f86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*lkzxX92VMdWMkySzs8KjOQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="cfc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我在上面的图片中指出的，卷积两个多项式的自然方法是利用分配特性，逐项相乘，然后通过添加相同多项式次数的系数来减少冗余项。这就是我之前提到的经典乘法，有O(N)步。然而，看看我在图像上标记的点。每个点都有坐标(I，P(i))，其中P(i)是x=i时P(x)的值。任何次数为<em class="ls"> d </em>的多项式都由平面上的<em class="ls"> d+1 </em>个点定义，这称为<strong class="ky ir">值表示</strong>。FFT乘法背后的思想是对至少<em class="ls"> d+1 </em>个点(x_i，A(x_i))和(x_i，B(x_i))的A(x)和B(x)进行采样，然后简单地将函数值一个接一个地相乘(成对乘积)，以便获得两个多项式的值表示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/47a0cddbb6f3eea48dc2c437c20c6b6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*hKZ3fpil_88AJbn-ZvIdqQ.png"/></div></figure><p id="4551" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与系数表示乘法相比，值表示乘法大大减少了所执行的运算的数量。因此，想法是从系数表示变为值表示，以成对的方式执行乘法，并且将值表示变换回系数表示。在理解如何做之前，我们需要更多的概念。</p><h1 id="a8eb" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">虚拟离散傅立叶变换</strong></h1><p id="63a4" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">好了，在更新了我们的多项式知识之后，我们现在能够深入信号世界了。如果你从来没有听说过傅立叶变换，你只需要知道信号可以分解为其他信号的总和。时域图显示信号幅度如何随时间变化，而频域图显示信号如何位于一个频率范围内的每个频带内:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/f4e93ba2524473821efd1aeff53e6c22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*vKlaPLyggzBCO4IFzni7Ug.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="67fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">傅立叶变换将任何信号分解成复杂的正弦和余弦波的总和</strong>。虽然它可以应用于连续波和离散波，但我在本文中只关注离散波，也就是离散傅立叶变换(DFT)。DFT是允许从一个域转换到另一个域的函数，FFT是一种非常高效地计算DFT的算法，但我们将在稍后讨论。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/0050223e0953be4b9032bbfccd29a1e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*5UQbBD7DI98YVtbcyU0GPw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="0d97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们对多项式和DFT有了一个整体的概念，所以我们可以继续我们的乘法问题。我们说过:</p><blockquote class="mv"><p id="a576" class="mw mx iq bd my mz na nb nc nd ne lr dk translated">因此，想法是从系数表示变为值表示，以成对的方式执行乘法，并且将值表示变换回系数表示。</p></blockquote><h1 id="6e77" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw nf jx mf jz ng ka mh kc nh kd mj mk bi translated">理解FFT的直观方法</h1><p id="4142" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">也许你在想，DFT可以帮助你从一种表示转换到另一种表示。你是对的，让我们看看为什么。我们说过，我们至少需要对<em class="ls"> d+1 </em>个点进行采样，以获得精确定义多项式的多项式值。有一些技巧可能有助于进一步减少样本评估的数量:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/8ab033465a543e2161f4d4bf693a8e31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*aalVcHYNDEUrilnuhXqTUA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="4f26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们能够应用一些多项式性质，我们可以减少我们需要的样本评估的数量。请记住，在偶数多项式中，P(-x)=P(x)是正确的，这意味着它关于y轴对称。让我们把多项式P(x)分解成偶数多项式:P(x)=P_e(x) + x*P_o(x):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/9d4e01e6d7d31c7282b630d14e2928d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*wuOWB8EEiegDzVg6-g7P7A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="5a9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，点<em class="ls"> -k </em>的多项式求值重用了<em class="ls"> k </em>的多项式求值:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/55259e9b0aff5dd962ecf7e654f1a7a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*CwauwlIfiqCbUQKuVg-_7A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="42ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着我们可以改为评估<em class="ls"> n/2 </em>点(互补的<em class="ls"> n/2 </em>点是即时获得的)，这进一步减少了运算次数。在这一点上，你可能在考虑一个递归过程，你是对的。我们可以如下直观地构建这个过程。对于给定的多项式<em class="ls"> P(x) </em>和<em class="ls"> n </em>个点(实际上是<em class="ls"> n/2 </em>个成对点)，我们一方面变换P(x)=P_e(x )+x*P_o(x)并在<em class="ls"> n/2 </em>个正点上递归求P_e多项式；并且还在相同的<em class="ls"> n/2 </em>正点上递归地评估P_o。在得到他们的结果后，很容易得到对剩余的<em class="ls"> n/2 </em>负面点的P(x)评价:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/37f81b3c40126df16017d8387c18a8a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*nKIMMnJc2EcHFdN_zJvByQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="11b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一个要回答的问题是我们选择哪n个点来评估我们的多项式。我们能选择任意一组对数吗？不，我们不能:</p><ol class=""><li id="fb3e" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr nq nr ns nt bi translated">我们将一半的点传递到下一个递归层次。该算法假设多项式在每次递归调用时都有正负成对的求值点。但是，每个点都是平方的，最后都是正的。有没有一个数即使在平方时也能保持符号不变？答案是复数<em class="ls"> i </em>。</li><li id="79f9" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated">除此之外，每一个递归层次都依赖于这样一个事实，即接收点的后一半与前一半相等，但符号相反。这最终成为一个方程组，递归的底层将有一个值为1的单点。有不同的方法可以解决这个问题，但是最直接的方法是使用单位的N次方根(找到当被提升到某个正整数N次幂时产生1的<strong class="ky ir"> </strong>)。</li></ol><p id="0527" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们的<em class="ls"> n </em>等于12，求解单位的12次方根给出以下几点来评价:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/57b78154446be812516ca606c41e11b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QOeX50Bj0-RRQcwhc84c5w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://www.askiitians.com/iit-jee-algebra/complex-numbers/nth-roots-of-unity.aspx" rel="noopener ugc nofollow" target="_blank">来源aski tians</a></p></figure><p id="1c19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，我们将有2的幂级递归，因此很容易找到<em class="ls"> n </em>作为大于<em class="ls"> d+1，</em>的2的最小幂，即使<em class="ls"> </em>我们只计算其中的<em class="ls"> n/2 </em>。好消息是，我们刚刚完成了最重要的信号处理算法！<strong class="ky ir">这种算法被称为快速傅立叶变换</strong>。</p><p id="3c79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们将所有这些放入一个伪代码中:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/63181bd400f7f407006849259361961b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5fbW7YAsS3ddrl1ZArahoA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://www.youtube.com/watch?v=h7apO7q16V0&amp;t=813s" rel="noopener ugc nofollow" target="_blank">可还原的Youtube频道</a></p></figure><p id="5c83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于FFT，我们已经获得了应用离散傅立叶变换的每个多项式的值表示，并且这是在仅仅<em class="ls"> O(logN) </em>复杂度下完成的。为了将两个多项式在值表示中相乘，我们只需对每个点上的函数求值进行成对乘法，其中成对乘法意味着将向量成对地、逐个元素地相乘，这在计算上来说是非常便宜的。</p><h1 id="d85c" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">大整数乘法的Strassen FFT算法</h1><p id="faac" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这个算法是由Strassen和Schö nhage在1971年发明的，但是在本文的这一点上，你将能够很容易地理解它。</p><p id="726b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们想将两个大整数<em class="ls"> A </em>和<em class="ls"> B </em>相乘，大小为<em class="ls"> N，</em>我们首先将它们转换成以<em class="ls"> x为基数的多项式系数表示。我们将得到的系数分别存储到矢量<em class="ls"> a </em>和<em class="ls"> b </em>中。根据卷积定理，如果<em class="ls"> c </em>是两个输入向量<em class="ls"> a </em>和<em class="ls"> b </em>，<em class="ls"> c = a b </em>，那么<em class="ls"> c </em>的离散傅里叶变换(DFT)等于每个输入向量的DFT变换的两两两相乘，<em class="ls"> DFT(c) = DFT(a)DFT(b) </em>。</em></p><blockquote class="mv"><p id="9ced" class="mw mx iq bd my mz na nb nc nd ne lr dk translated">因此，<em class="ob"> c </em>向量也可以作为该成对乘法的离散傅立叶逆变换(IDFT)来获得，<em class="ob"> c = IDFT(DFT(a)DFT(b))。</em></p></blockquote><p id="54b7" class="pw-post-body-paragraph kw kx iq ky b kz oc jr lb lc od ju le lf oe lh li lj of ll lm ln og lp lq lr ij bi translated">如果输入向量不具有相同的长度，<em class="ls"> M &lt; N </em>，则最短的一个用零填充，直到<em class="ls"> M = N </em>。最后，系数必须归一化到与表示整数的基数相同的基数，这一步通常称为“T4”，称为进位传播。这很重要，因为由于成对乘法的性质，在逆FFT之后，<em class="ls"> c </em>的每个元素将容纳比基数<em class="ls"> x </em>大的整数。下图显示了进位传播方法<em class="ls">、</em>的一个示例，其中元素最终保留在基数为10的<em class="ls">中。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/9e3bcd290e233808622708184558abf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*Agb6ITyres8YK59Wghmo6Q.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h1 id="0c68" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">计算方法</strong></h1><p id="f04c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在实现Strassen算法时，大多数现有库不使用复数域中的FFT。在复数域中，整数系数被转换成复数。在执行逆FFT运算后，最终得到类似于<em class="ls"> 14.999878 </em>的值，而不是<em class="ls"> 15 </em>。相比之下，大多数实现使用有限域<em class="ls"> Z=pZ </em>，其中素数<em class="ls"> p. </em>在这种情况下，希望使用一个<em class="ls"> p </em>数来最小化模运算的延迟，并且在大多数情况下为此选择<em class="ls">费马素数</em>。</p><p id="bfa3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，除了找到单位的第n个根之外，有限域还有几个重要的限制:</p><p id="92d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">-最大值必须适合该字段，即<em class="ls"> (n/2)(x-1) &lt; p </em>。<br/> -乘入<em class="ls"> Z=pZ </em>必须取模<em class="ls"> p </em>，因此快速取模<em class="ls"> p </em>运算符的存在是可取的(就像<em class="ls">蒙哥马利约简算法</em>)。</p><p id="ee4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">传统上，有限域上的实现不如复数域上的实现有效，因为需要不同的模运算。<a class="ae kv" href="https://journals.sagepub.com/doi/10.1177/10943420221077964" rel="noopener ugc nofollow" target="_blank">在最近的这篇论文</a>中，我们已经证明了Strassen算法和FFT在复数域上的运行比其他方法更好，并且它非常适合GPU架构。我们还从数学上证明了对少于50万位数的整数使用它是安全的(尽管是在复数上工作)。</p><p id="dfcc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里要理解的重要主题是，尽管经典乘法对于小尺寸运算可以执行得很好，但其复杂性从不存在。当增加位数时，尽管进行了平铺等优化，性能还是会下降，因为它的<em class="ls"> O(N)。</em>取而代之的是Strassen算法，wit <em class="ls"> h O(Nlog N (log log N)) </em>在统计所有涉及的运算时，要快得多。下图描绘了实/复FFT Strassen实现(通过两个不同的库ID/CuFFT)与经典算法的基于平铺的实现的性能对比:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/f9b30de5c69d1ce3f4cca37cd345259c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NYllH5nlI2RxuxHvG3uHkA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="9161" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls"> Adrian Perez在伯克利实验室从事研究，拥有超级计算并行算法的博士学位。你可以在他的</em> <a class="ae kv" href="https://adrianpd.medium.com/" rel="noopener"> <em class="ls">中简介</em> </a> <em class="ls">中查看更多关于他的西班牙语和英语内容。</em></p><p id="15d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">参考书目</strong></p><p id="8f87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">迭格斯等人</em>。GPU上高效的高精度整数乘法。<em class="ls">国际高性能计算应用杂志</em> (2022)。</p></div></div>    
</body>
</html>