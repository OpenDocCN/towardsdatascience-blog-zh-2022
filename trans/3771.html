<html>
<head>
<title>Mastering Git: Merge and Rebase</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握Git:合并和重建基础</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/mastering-git-merge-and-rebase-f2a7c5c348a9#2022-08-22">https://towardsdatascience.com/mastering-git-merge-and-rebase-f2a7c5c348a9#2022-08-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="33b2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">它们是什么，如何使用它们？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1ce029be4bd8c48376044ee9feb1ebb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wOw0ed_kFmof2VAW"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@praveentcom?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Praveen Thirumurugan </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="2fe9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Git是所有数据科学家和软件工程师都应该知道如何使用的工具。无论您是单独从事一个项目，还是作为大型分布式团队的一部分，从长远来看，了解如何使用Git都可以为您节省大量时间。这是因为git，以及更广泛的版本控制，允许您跟踪对代码库所做的更改，并与其他人有效地协作。你想逆转你所做的改变，用git很容易做到，你想从现有的代码中分离出一个新的特性，git，你想在你做改变的同时运行一个有效的产品，git，你想和其他人在同一段代码上工作，git和github！这真的很神奇。</p><p id="e806" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">学习其中一个重要的关键功能是合并和重组，将分支工作引入主线。阅读本文的大多数人都会在某个地方遇到过合并或重组(当然，有些比其他的更容易、更简洁)。这可能是因为你自己正在开发一个特性，你把它引入了你的主线，或者是其他人把他们已经完成的工作引入了一个共享的主线分支。这意味着理解merge和rebase是如何工作的，它们的区别是什么，以及如何使用它们来为自己服务，以便将来使用git时更加有效，这是非常重要的。</p><p id="571a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">合并和重定基础之间的关键区别在于它如何处理代码历史，以及您是否需要新的提交。在合并的情况下，维护代码的历史，包括分支最初从主线分叉的点，并且需要新的提交来将分支合并在一起。相反，rebase只是将新分支的提交放在主线的顶部，而不管分支的来源。这保持了主线中的线性，可以很容易地导航，但这是以保留提交的直接历史为代价的。您使用哪一个通常是个人偏好或取决于项目负责人，但为了以防万一，了解如何使用这两者是值得的！</p><h2 id="0b15" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">安装</h2><p id="7689" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果你已经安装了git和gitbash，那太好了！不用担心设置，你应该准备好了。如果没有，请随意查看下面的帖子，其中涵盖了如何安装git和开始使用git命令。</p><div class="mt mu gp gr mv mw"><a rel="noopener follow" target="_blank" href="/git-and-github-basics-for-data-scientists-b9fd96f8a02a"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">面向数据科学家的Git和GitHub基础知识</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">UCL数据科学研讨会8:什么是Git，创建本地存储库，提交第一批文件，链接到远程…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">towardsdatascience.com</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk ks mw"/></div></div></a></div><h2 id="7c79" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">合并</h2><p id="06ae" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">一旦设置好git和gitbash，我们就可以继续创建一个测试文件夹，我们将使用它来查看git merge会发生什么。我们将简单地称这个文件夹为<code class="fe nl nm nn no b">git_test_merge</code>,但是你想怎么叫都可以！一旦创建了文件夹，您就需要<code class="fe nl nm nn no b">cd</code>进入并创建一个新的空存储库。</p><p id="2629" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，您将需要使用命令<code class="fe nl nm nn no b">git init</code>来创建新的存储库。然后你应该看到文件夹中创建的<code class="fe nl nm nn no b">.git</code>文件，并且<code class="fe nl nm nn no b">main</code>或<code class="fe nl nm nn no b">master</code>(如果你使用的是旧版本的git)应该出现在你所在的文件夹目录之后。为此，您应该已经运行了这三个命令:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="d098" class="lv lw it no b gy nt nu l nv nw">mkdir git_test_merge</span><span id="102d" class="lv lw it no b gy nx nu l nv nw">cd git_test_merge</span><span id="cc4d" class="lv lw it no b gy nx nu l nv nw">git init</span></pre><p id="d218" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将在文件夹<code class="fe nl nm nn no b">git_test_merge</code>中创建一个git存储库，并为您提供该存储库的所有功能。出于这个测试的目的，我们将首先创建一个文件，添加一些行并创建两个提交，然后再创建一个分支，稍后我们将合并到这个分支中。这只是为了展示提交的结构以及分支如何处理这些提交。</p><p id="98fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要创建一个文件并向其中添加一行，我们可以使用下面的命令<code class="fe nl nm nn no b">echo "This is a test file" &gt;&gt; test_file.txt</code>。这将创建文件<code class="fe nl nm nn no b">test_file.txt</code>，并附加第一行“这是一个测试文件”。如果你想检查这是不是真的，你可以使用命令<code class="fe nl nm nn no b">nano test_file.txt</code>来检查它是否工作。</p><p id="2093" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦您创建了文件，我们希望使用<code class="fe nl nm nn no b">git add test_file.txt</code>提交该文件，然后我们可以使用<code class="fe nl nm nn no b">git commit -m "Create new test_file"</code>提交我们所做的更改。这将在我们的存储库中创建第一个提交。</p><p id="532f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这应该采用以下命令的形式:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="b353" class="lv lw it no b gy nt nu l nv nw">echo "This is a test file" &gt;&gt; test_file.txt</span><span id="d876" class="lv lw it no b gy nx nu l nv nw">git add test_file.txt</span><span id="7be6" class="lv lw it no b gy nx nu l nv nw">git commit -m "Create new test_file"</span></pre><p id="e36b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过使用<code class="fe nl nm nn no b">gitk</code>使用内置的git GUI来检查这种情况。在这种情况下，将出现以下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/3f79b00d260fa5ad1859da33d27d6157.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*00FjCNjBylVej6fVMBLyoQ.png"/></div></div></figure><p id="6d5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个GUI，向您显示以前的提交以及它们是如何交互的。到目前为止，我们只在主分支上创建了一个提交，如下所示。它还向您展示了是谁在何时提交的，以及与此提交相关的文件中的更改。虽然这是非常有用的功能，但我们将只关注之前提交的可视化表示，这样我们就可以看到<code class="fe nl nm nn no b">git merge</code>和<code class="fe nl nm nn no b">git rebase</code>都发生了什么。</p><p id="aef5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们继续之前，我们可以创建第二个提交，这样在我们创建一个新的分支来合并之前，我们可以在我们的<code class="fe nl nm nn no b">master</code>分支上看到一个清晰的历史。这可以通过以下方式简单实现:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="3eb8" class="lv lw it no b gy nt nu l nv nw">echo "This is the second line of the test_file" &gt;&gt; test_file.txt</span><span id="4b5b" class="lv lw it no b gy nx nu l nv nw">git add test_file.txt</span><span id="ab3e" class="lv lw it no b gy nx nu l nv nw">git commit -m "Add second line to the test_file"</span></pre><p id="8a68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，我们应该在<code class="fe nl nm nn no b">master</code>分支上看到两个提交，这创建了一个清晰的历史。然后我们想要创建一个分支，稍后我们想要将它合并回<code class="fe nl nm nn no b">master</code>分支。出于我们的目的，这可以称为<code class="fe nl nm nn no b">merge_branch</code>，但是通常以您试图创建的特征命名。我们可以使用以下命令创建这个分支:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="85da" class="lv lw it no b gy nt nu l nv nw">git checkout -b merge_branch</span></pre><p id="e699" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将创建分支(由于<code class="fe nl nm nn no b">-b</code>命令)并由于<code class="fe nl nm nn no b">checkout</code>命令检查分支。</p><p id="7393" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您再次使用<code class="fe nl nm nn no b">gitk</code>,您应该会看到如下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/c0a43efef450fe58218d714f92671006.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1EOaMWLCiG0m8KzAdDnTmA.png"/></div></div></figure><p id="a857" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中我们现在有一个<code class="fe nl nm nn no b">master</code>和一个<code class="fe nl nm nn no b">merge_branch</code>，它们目前都处于“向test_file添加第二行”提交状态。我们还可以看到，我们已经检出了<code class="fe nl nm nn no b">merge_branch</code>，因为它是粗体的(不是很清楚，但它在那里)。</p><p id="9c1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了检查merge是如何工作的，我们可以为这个分支创建两个新的提交。这将像以前一样通过创建一个新文件并向其中添加两行来完成。您可以自己尝试一下，看看是否可以复制我们在上面完成的过程，如果不能，那么您可以遵循下面的命令:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="1eb6" class="lv lw it no b gy nt nu l nv nw">echo "This is a new file" &gt;&gt; merge_file.txt</span><span id="d9dc" class="lv lw it no b gy nx nu l nv nw">git add merge_file.txt</span><span id="2f05" class="lv lw it no b gy nx nu l nv nw">git commit -m "Create a merge_file"</span><span id="eadf" class="lv lw it no b gy nx nu l nv nw">echo "This is the second line of the merge file" &gt;&gt; merge_file.txt</span><span id="6cd2" class="lv lw it no b gy nx nu l nv nw">git add merge_file.txt</span><span id="88b0" class="lv lw it no b gy nx nu l nv nw">git commit -m "Add a second line to the merge file"</span></pre><p id="68ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以再次使用<code class="fe nl nm nn no b">gitk</code>命令来查看<code class="fe nl nm nn no b">merge_branch</code>应该比主分支提前两次提交，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/4c5f34b913f14e48b85d7f1515986b2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7PBWD7rAtzpUqDxSJnc7uw.png"/></div></div></figure><p id="6631" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们现在简单地进行合并，我们将不得不使用<code class="fe nl nm nn no b">git checkout master</code>检查<code class="fe nl nm nn no b">master</code>分支并运行<code class="fe nl nm nn no b">git merge merge_branch</code>。结果看起来会像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/b898485e97ff3956404ed8cd914e5e8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D0dMdIaoALufZExfRSjpYw.png"/></div></div></figure><p id="3073" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将为您提供一个完整的合并，很好，但它并没有真正显示您想要的合并。以这种方式运行它将会把来自<code class="fe nl nm nn no b">merge_branch</code>的所有提交放到<code class="fe nl nm nn no b">master</code>分支上。这并没有显示太多，因为在现实中，<code class="fe nl nm nn no b">master</code>分支可能会有进一步的提交，这会使过程变得复杂。</p><p id="a785" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可以通过检查<code class="fe nl nm nn no b">master</code>分支并创建一个新的提交来复制它。这可以通过以下方式实现:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="d97c" class="lv lw it no b gy nt nu l nv nw">git checkout master</span><span id="c9ad" class="lv lw it no b gy nx nu l nv nw">echo "This is the third line" &gt;&gt; test_file.txt</span><span id="576d" class="lv lw it no b gy nx nu l nv nw">git add test_file.txt</span><span id="fd2c" class="lv lw it no b gy nx nu l nv nw">git commit -m "Add third line to the test_file"</span></pre><p id="ba60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们需要创建合并，将<code class="fe nl nm nn no b">merge_branch</code>引入到<code class="fe nl nm nn no b">master</code>分支中。我们这样做是因为<strong class="lb iu">位于我们想要将提交放入</strong>的分支中。在这种情况下，我们已经检查了<code class="fe nl nm nn no b">master</code>分支，所以我们是在正确的地方。</p><p id="29cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们执行<code class="fe nl nm nn no b">git merge merge_branch</code>，指定我们想要将<code class="fe nl nm nn no b">merge_branch</code>合并到主分支中。然后，它会要求将提交消息添加到合并中，因为合并将被注册为提交。这种情况下，我们可以简单的命名为<code class="fe nl nm nn no b">merge merge_branch into master</code>。</p><p id="6a6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦完成，我们就将<code class="fe nl nm nn no b">merge_branch</code>合并到<code class="fe nl nm nn no b">master</code>分支中。我们可以再次使用<code class="fe nl nm nn no b">gitk</code>将它形象化如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/8b3e42768563afcd43bacf80b1d8755c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-otS0hcXXgACPsVdA8zIAQ.png"/></div></div></figure><p id="f633" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，提交的图形保留了提交来自两个分支的位置，这两个分支源自提交“将第二行添加到test_file”。我们还可以看到它们在那之后如何分化的历史，直到我们将<code class="fe nl nm nn no b">merge_branch</code>合并回<code class="fe nl nm nn no b">master</code>。</p><p id="588b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做的好处是它维护了提交历史和顺序。您知道提交的顺序以及它们来自哪里，这意味着跟踪提交来自哪里变得更加容易。然而，问题是，如果你有许多分支，你想合并，那么这可能会变得凌乱和难看。这意味着清楚地理解历史会变得困难，这也是为什么许多开发人员更喜欢使用rebase而不是merge。</p><h2 id="9127" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">重置基础</h2><p id="d2ae" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">git中的Rebasing将接受指定的提交，并将它们放在另一个分支中的提交之上。这样做的好处是，一旦您删除了分支，提交流将呈现线性，这将很容易导航和跟踪。然而，这样做的缺点是，它不能像合并那样直接保存工作流的历史。</p><p id="4d74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了了解这是如何工作的，我们可以基本上重复我们为合并工作流所采取的大部分步骤。我们可以使用<code class="fe nl nm nn no b">mkdir git_test_rebase</code>、<code class="fe nl nm nn no b">cd</code>创建一个名为<code class="fe nl nm nn no b">git_test_rebase</code>的新文件夹，然后使用<code class="fe nl nm nn no b">git_init</code>初始化git存储库。然后，我们可以创建一个包含两行代码和两次提交的新文件:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="ca0a" class="lv lw it no b gy nt nu l nv nw">echo "This is a new file in the rebase folder" &gt;&gt; rebase_file.txt</span><span id="64d5" class="lv lw it no b gy nx nu l nv nw">git add rebase_file.txt</span><span id="5bbd" class="lv lw it no b gy nx nu l nv nw">git commit -m "Create a new rebase text file"</span><span id="0a23" class="lv lw it no b gy nx nu l nv nw">echo "This is the second line in the rebase file" &gt;&gt; rebase_file.txt</span><span id="c36c" class="lv lw it no b gy nx nu l nv nw">git add rebase_file.txt</span><span id="aed7" class="lv lw it no b gy nx nu l nv nw">git commit -m "Add second line to rebase_file"</span></pre><p id="efea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由此，我们可以创建一个新的分支，稍后我们将使用以下内容将该分支重置回<code class="fe nl nm nn no b">master</code>分支:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="b547" class="lv lw it no b gy nt nu l nv nw">git checkout -b "rebase_branch"</span></pre><p id="8300" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个新分支中，和以前一样，我们可以创建另一个新文件并添加两个提交，这样新分支就有了一些历史:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="21ad" class="lv lw it no b gy nt nu l nv nw">echo "This is a new file in the rebase branch" &gt;&gt; new_file.txt</span><span id="eb91" class="lv lw it no b gy nx nu l nv nw">git add new_file.txt</span><span id="4c97" class="lv lw it no b gy nx nu l nv nw">git commit -m "Create new file"</span><span id="e450" class="lv lw it no b gy nx nu l nv nw">echo "This is the second line in the new file" &gt;&gt; new_file.txt</span><span id="7e8a" class="lv lw it no b gy nx nu l nv nw">git add new_file.txt</span><span id="a25b" class="lv lw it no b gy nx nu l nv nw">git commit -m "Add second line to the new file"</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/0896f33d440934a69b7d6615a7a835fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DTabQ2_pNB4fjlPpwCAVNg.png"/></div></div></figure><p id="51fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以进行<code class="fe nl nm nn no b">checkout master</code>分支，以便像以前一样，我们可以向<code class="fe nl nm nn no b">rebase_file</code>添加一个新行，并在主分支上创建第三个提交:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="eb8d" class="lv lw it no b gy nt nu l nv nw">echo "Third line to the rebase_file" &gt;&gt; rebase_file.txt</span><span id="9c7a" class="lv lw it no b gy nx nu l nv nw">git add rebase_file.txt</span><span id="88c1" class="lv lw it no b gy nx nu l nv nw">git commit -m "Add third line to the rebase_file"</span></pre><p id="1e4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一点上，我们回到了在最后一个存储库中执行<code class="fe nl nm nn no b">merge</code>时的位置，在<code class="fe nl nm nn no b">master</code>分支中执行了三次提交，在<code class="fe nl nm nn no b">rebase_branch</code>中执行了两次提交，在第二次提交后rebase分支被分支。</p><p id="dec2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的不同之处在于，我们现在必须再次对<code class="fe nl nm nn no b">checkout</code>和<code class="fe nl nm nn no b">rebase_branch</code>进行调整，因为<strong class="lb iu">是从</strong>中您想要合并的分支开始执行的，而不是从您想要合并的分支开始。一旦我们完成了这些，我们可以使用<code class="fe nl nm nn no b">git rebase master</code>来告诉分支，我们想要将这个分支的所有提交重新放入<code class="fe nl nm nn no b">master</code>分支。我们可以再次使用<code class="fe nl nm nn no b">gitk</code>来检查发生了什么:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/de1142640cc6c67baba1352ceee25d93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AeELMV3Tbt38jiTdJCg9Fg.png"/></div></div></figure><p id="1fdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的主要区别是这个<code class="fe nl nm nn no b">rebase</code>命令只是将来自<code class="fe nl nm nn no b">rebase_branch</code>的提交放在了<code class="fe nl nm nn no b">master</code>分支提交之上，而不需要创建新的提交。它也没有将<code class="fe nl nm nn no b">master</code>分支指针移动到最近提交的位置。为此，我们可以使用以下命令强制<code class="fe nl nm nn no b">master</code>分支执行<code class="fe nl nm nn no b">rebase_branch</code>上的最新提交:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="70a8" class="lv lw it no b gy nt nu l nv nw">git branch -f master rebase_branch</span></pre><p id="7804" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将显示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/9fb1843a8dee1980896de2fb14c0f21c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c-UN3mUBk6vJycjcSk2gQQ.png"/></div></div></figure><p id="34e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们做<code class="fe nl nm nn no b">gitk</code>时。为此，你必须确保没有检出<code class="fe nl nm nn no b">master</code>分支，否则你将无法移动指针。</p><p id="c16b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，rebase已经将<code class="fe nl nm nn no b">rebase_branch</code>的提交放在了<code class="fe nl nm nn no b">master</code>分支的顶部，我们必须将<code class="fe nl nm nn no b">master</code>分支的指针向上移动到这些新的提交。虽然这保留了提交的行结构，并且看起来很清晰，但是它没有按照提交的顺序保留提交的历史，这对于某些人来说是不理想的。</p><h2 id="36dc" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">结论</h2><p id="dc19" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在，您知道了如何在一个特性分支上执行合并和重置，以合并提交。要记住的一个关键点是，必须从您想要合并的分支执行rebase，而合并必须从您想要合并的分支执行。您还需要记住，合并将保留提交的历史以及它们来自哪里，但它可能会创建一个混乱的历史，通常很难破译，您需要一个额外的提交。相比之下，rebase会产生一个很好的线性历史，易于阅读，但它不会保留它们的直接历史，而是将来自签出分支的提交放在指定分支的现有提交之上。您更喜欢哪种类型将是个人偏好之一，取决于他们各自的权衡，但在项目中，通常最好在开始时指定您将使用哪种约定。否则，您可能会以rebases和merges结束，这会混淆存储库的历史。</p></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><p id="a23f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢你所读的，并且还不是medium会员，请使用下面我的推荐链接注册Medium，来支持我和这个平台上其他了不起的作家！提前感谢。</p><div class="mt mu gp gr mv mw"><a href="https://philip-wilkinson.medium.com/membership" rel="noopener follow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">通过我的推荐链接加入Medium—Philip Wilkinson</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">philip-wilkinson.medium.com</p></div></div><div class="nf l"><div class="on l nh ni nj nf nk ks mw"/></div></div></a></div><p id="a3c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者随意查看我在Medium上的其他文章:</p><div class="mt mu gp gr mv mw"><a rel="noopener follow" target="_blank" href="/eight-data-structures-every-data-scientist-should-know-d178159df252"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">每个数据科学家都应该知道的八种数据结构</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">从Python中的基本数据结构到抽象数据类型</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">towardsdatascience.com</p></div></div><div class="nf l"><div class="oo l nh ni nj nf nk ks mw"/></div></div></a></div><div class="mt mu gp gr mv mw"><a rel="noopener follow" target="_blank" href="/a-complete-data-science-curriculum-for-beginners-825a39915b54"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">面向初学者的完整数据科学课程</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">UCL数据科学协会:Python介绍，数据科学家工具包，使用Python的数据科学</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">towardsdatascience.com</p></div></div><div class="nf l"><div class="op l nh ni nj nf nk ks mw"/></div></div></a></div><div class="mt mu gp gr mv mw"><a href="https://python.plainenglish.io/a-practical-introduction-to-random-forest-classifiers-from-scikit-learn-536e305d8d87" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">scikit-learn中随机森林分类器的实用介绍</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">UCL数据科学学会研讨会14:什么是随机森林分类器、实现、评估和改进</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">python .平原英语. io</p></div></div><div class="nf l"><div class="oq l nh ni nj nf nk ks mw"/></div></div></a></div></div></div>    
</body>
</html>