<html>
<head>
<title>Clinical Named Entity Recognition Using spaCy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于空间的临床命名实体识别</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/clinical-named-entity-recognition-using-spacy-5ae9c002e86f#2022-04-13">https://towardsdatascience.com/clinical-named-entity-recognition-using-spacy-5ae9c002e86f#2022-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d148" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一种基于空间的医疗保健领域NER方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f3968882d1af69798fb6bd2699fe4499.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_lLev6XKQXqWg0cS-N6Mig.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者照片</p></figure><p id="3d25" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如我在以前的文章[1]中所描述的，自然语言处理(<a class="ae lr" href="https://en.wikipedia.org/wiki/Natural_language_processing" rel="noopener ugc nofollow" target="_blank"> NLP </a>)成为了<a class="ae lr" href="https://en.wikipedia.org/wiki/Artificial_intelligence" rel="noopener ugc nofollow" target="_blank"> AI </a>研究和应用的热门话题，因为文本(例如，英语句子)是自然语言数据的主要类型。医疗领域文本数据的人工智能方法有很多，如临床文本分类、临床命名实体识别(<a class="ae lr" href="https://en.wikipedia.org/wiki/Named-entity_recognition" rel="noopener ugc nofollow" target="_blank"/>)、……等。</p><p id="e437" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在[1]中，我使用了一个开源的临床文本数据集[2][3]来介绍一些常见的用于临床文本分类的机器学习和深度学习方法。</p><p id="a5f0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我使用相同的数据集来演示如何使用spaCy [4]实现特定于医疗保健领域的命名实体识别(<a class="ae lr" href="https://en.wikipedia.org/wiki/Named-entity_recognition" rel="noopener ugc nofollow" target="_blank"> NER </a>)方法。</p><p id="0895" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">新NER方法包括以下步骤:</p><ul class=""><li id="3573" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">预处理数据集</li><li id="fb92" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">定义特定于领域的实体和类型</li><li id="7875" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">生成带注释的数据集</li><li id="62d0" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">创建和培训NER模型</li><li id="a934" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">评估NER模型</li><li id="0b2e" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">扩展NER模型</li><li id="25a3" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">预测和可视化命名实体</li></ul><h1 id="c54a" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">1.预处理数据集</h1><p id="d70d" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">从Kaggle [3]下载数据集<em class="nd"> mtsamples.csv </em>文件后，数据集可以作为Pandas数据帧加载到内存中，如下所示:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="3914" class="nj mh iq nf b gy nk nl l nm nn">raw_df = pd.read_csv('./medical-nlp/data/mtsamples.csv', index_col=0)<br/>raw_df.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/2bfd3595045e70f338ece763b6ed2dcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CiLMqjeqkeEFQyLeXiP5SA.png"/></div></div></figure><p id="6613" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">数据集中有40个独特的医学专业类别。如[1]中所述，通过以各种方式过滤数据集，医学专业类别的数量可以从40个减少到以下9个类别:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/d0856560bfde0fd13860d44bfeb35b55.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*ahdxiKYEU1MaqX4ZGj4Aeg.png"/></div></figure><p id="fb1c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了更好地演示，通过将本文中的<em class="nd">转录</em>列改为小写，对这个过滤后的数据集进行进一步预处理。</p><h1 id="3078" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">2.定义特定于领域的实体和类型</h1><p id="9204" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">空间中的NER模型是有监督的深度学习模型。因此，数据集中的每个文档都需要标记的实体来进行模型训练和测试。</p><p id="9e8c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">典型的文本注释工具如<a class="ae lr" href="https://prodi.gy/" rel="noopener ugc nofollow" target="_blank"> prodigy </a>用于注释文档中的实体类型。本文利用另一种方法来自动生成带注释的文本数据集。为此，需要指定实体(不是它们在文档中的位置)和类型。</p><p id="6eae" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">出于演示的目的，假设我们对以下实体(疾病或医学)和类型(医学专业)感兴趣:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/4686bcd706b906d037da5187db740acc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pwGa_YsIXUNFazI3Y9B5bA.png"/></div></div></figure><p id="c39d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每种实体类型的实体在实现中存储为一个集合。作为一个例子，下面是手术的设置:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="1da3" class="nj mh iq nf b gy nk nl l nm nn">surgery = set(['acute cholangitis', 'appendectomy', <br/>               'appendicitis', 'cholecystectomy', <br/>               'laser capsulotomy', 'surgisis xenograft', <br/>               'sclerotomies', 'tonsillectomy' <br/>               ])</span></pre><h1 id="b099" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">3.生成带注释的数据集</h1><p id="45a8" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">如前所述，为了训练和测试空间NER模型，每个包含实体的文本文档都需要使用以下模板中的文本注释进行标记:</p><p id="e3a0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nd">('文档文本'，{ '实体':[(开始，结束，类型)，…，(开始，结束，类型)]))</em></p><p id="56d2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦确定了实体和类型(参见上一节)，就可以自动生成一个带注释的文本数据集，如下所示:</p><ul class=""><li id="a25d" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">使用识别的实体和类型创建空间实体标尺模型</li><li id="1fb2" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">使用实体标尺模型从给定文档中查找每个实体的位置和类型</li><li id="a19c" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">使用确定的位置和类型以及上面的模板来标记给定的文档</li></ul><p id="b82e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">可以通过三个步骤创建空间实体标尺模型(参见下面的<em class="nd"> RulerModel </em>类中的__ <em class="nd"> init </em> __方法):</p><ul class=""><li id="b605" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">为给定语言(如英语)创建空模型</li><li id="beee" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">将一个<em class="nd"> entity_ruler </em>管道组件添加到模型中</li><li id="190b" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">创建实体规则，并将其添加到<em class="nd"> entity_ruler </em>管道组件中</li></ul><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="3371" class="nj mh iq nf b gy nk nl l nm nn">import spacy<br/>from spacy.lang.en import English<br/>from spacy.pipeline import EntityRuler</span><span id="32e6" class="nj mh iq nf b gy nr nl l nm nn">class RulerModel():<br/>    def __init__(self, surgery, internalMedicine, medication, obstetricsGynecology):<br/>        self.ruler_model = spacy.blank('en')<br/>        self.entity_ruler =      self.ruler_model.add_pipe('entity_ruler')<br/>        <br/>        total_patterns = []</span><span id="8991" class="nj mh iq nf b gy nr nl l nm nn">        patterns = self.create_patterns(surgery, 'surgery')<br/>        total_patterns.extend(patterns)</span><span id="d515" class="nj mh iq nf b gy nr nl l nm nn">        patterns = self.create_patterns(internalMedicine, 'internalMedicine')<br/>        total_patterns.extend(patterns)</span><span id="a005" class="nj mh iq nf b gy nr nl l nm nn">        patterns = self.create_patterns(medication, 'medication')<br/>        total_patterns.extend(patterns)<br/> <br/>        patterns = self.create_patterns(obstetricsGynecology, 'obstetricsGynecology')<br/>        total_patterns.extend(patterns)<br/>        <br/>        self.add_patterns_into_ruler(total_patterns)<br/>        <br/>        self.save_ruler_model()<br/>        <br/>    def create_patterns(self, entity_type_set, entity_type):<br/>        patterns = []<br/>        for item in entity_type_set:<br/>            pattern = {'label': entity_type, 'pattern': item}<br/>            patterns.append(pattern)</span><span id="9f86" class="nj mh iq nf b gy nr nl l nm nn">        return patterns<br/>    <br/>    def add_patterns_into_ruler(self, total_patterns):<br/>        self.entity_ruler.add_patterns(total_patterns)</span></pre><p id="ef1d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">创建实体标尺模型后，可将其保存到文件中供以后使用，如下所示:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="6ded" class="nj mh iq nf b gy nk nl l nm nn">ruler_model.to_disk('./model/ruler_model')</span></pre><p id="e507" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面的<em class="nd"> </em>类<em class="nd">generated dataset</em>中的<em class="nd">assign _ labels _ to _ documents</em>()<em class="nd"/>方法使用上述实体标尺模型查找实体的位置和类型，并使用它们生成带注释的数据集:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="aec3" class="nj mh iq nf b gy nk nl l nm nn">class GenerateDataset(object):<br/>    <br/>    def __init__(self, ruler_model):<br/>        self.ruler_model = ruler_model<br/>        <br/>    def find_entitytypes(self, text):<br/>        ents = [] <br/>        doc = self.ruler_model(str(text))<br/>        for ent in doc.ents:<br/>            ents.append((ent.start_char, ent.end_char, ent.label_))</span><span id="9650" class="nj mh iq nf b gy nr nl l nm nn">        return ents     <br/>    <br/>    def assign_labels_to_documents(self, df):<br/>        dataset = []<br/>        text_list = df['transcription'].values.tolist()</span><span id="38f9" class="nj mh iq nf b gy nr nl l nm nn">        for text in text_list:<br/>            ents = self.find_entitytypes(text)<br/>            if len(ents) &gt; 0:<br/>                dataset.append((text, {'entities': ents}))<br/>            else:<br/>                continue </span><span id="de4f" class="nj mh iq nf b gy nr nl l nm nn">        return dataset</span></pre><p id="8df0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦生成了带注释的文本数据集，就可以将其分成子集，用于模型训练、验证和测试。</p><h1 id="883d" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">4.创建和培训NER模型</h1><p id="06fd" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">与实体标尺模型类似，空间NER模型可以分两步创建(参见下面的<em class="nd"> NERModel </em>类的<em class="nd"> __init__ </em>方法):</p><ul class=""><li id="b3aa" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">为给定语言(如英语)创建空模型</li><li id="35f4" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">将一个<em class="nd"> ner </em>管道组件添加到模型中</li></ul><p id="8458" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦创建了NER模型，就可以调用类<em class="nd"> NERModel </em>的方法<em class="nd"> fit </em>()来使用模型训练数据集训练该模型。</p><p id="317b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">模型训练遵循典型的深度学习模型训练过程:</p><ul class=""><li id="a37c" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">设置纪元的数量(在本文中默认为10)</li><li id="66f5" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">混洗训练数据并将其分成每个时期的小批</li><li id="a06d" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">设置模型超参数，如丢弃率</li><li id="15db" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">获取空间优化器，并使用它来管理目标函数损失的计算和通过反向传播更新权重</li><li id="9001" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">显示模型训练进度(通过使用本文中的tqdm库)</li></ul><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="5901" class="nj mh iq nf b gy nk nl l nm nn">import spacy<br/>from spacy.util import minibatch<br/>from spacy.scorer import Scorer<br/>from tqdm import tqdm<br/>import random</span><span id="8b91" class="nj mh iq nf b gy nr nl l nm nn">class NERModel():<br/>    def __init__(self, iterations=10):<br/>        self.n_iter = iterations <br/>        self.ner_model = spacy.blank('en') <br/>        self.ner = self.ner_model.add_pipe('ner', last=True)<br/>        <br/>    def fit(self, train_data):<br/>        for text, annotations in train_data:<br/>            for ent_tuple in annotations.get('entities'):<br/>                self.ner.add_label(ent_tuple[2])<br/>        other_pipes = [pipe for pipe in self.ner_model.pipe_names <br/>                       if pipe != 'ner']<br/>        <br/>        self.loss_history = []<br/>        <br/>        train_examples = []<br/>        for text, annotations in train_data:<br/>            train_examples.append(Example.from_dict(<br/>               self.ner_model.make_doc(text), annotations))<br/>        <br/>        with self.ner_model.disable_pipes(*other_pipes): <br/>            optimizer = self.ner_model.begin_training()<br/>            for iteration in range(self.n_iter):<br/>                print(f'---- NER model training iteration {iteration + 1} / {self.n_iter} ... ----')<br/>                random.shuffle(train_examples)<br/>                train_losses = {}<br/>                batches = minibatch(train_examples, <br/>                  size=spacy.util.compounding(4.0, 32.0, 1.001))<br/>                batches_list = [(idx, batch) for idx, batch in <br/>                  enumerate(batches)]<br/>                for idx, batch in tqdm(batches_list):<br/>                     self.ner_model.update(<br/>                         batch,<br/>                         drop=0.5,<br/>                         losses=train_losses,<br/>                         sgd=optimizer,<br/>                     )<br/>                 <br/>                self.loss_history.append(train_losses)<br/>                print(train_losses)</span><span id="17ea" class="nj mh iq nf b gy nr nl l nm nn">        <br/>    def accuracy_score(self, test_data):<br/>        examples = []<br/>        scorer = Scorer()<br/>        for text, annotations in test_data:<br/>            pred_doc = self.ner_model(text)<br/>            try:<br/>                example = Example.from_dict(pred_doc, annotations)<br/>            except:<br/>                print(f'Error: failed to process document: \n{text}, <br/>                      \n\n annotations: {annotations}')<br/>                continue<br/>            <br/>            examples.append(example)<br/>            <br/>        accuracy = scorer.score(examples)<br/>        <br/>        return accuracy</span></pre><p id="6803" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是斯帕西·NER模型训练输出的屏幕截图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/af1265f50418b8370e1051bfa096bd1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_A4j2mmXYeDVLECcdPWW6A.png"/></div></div></figure><p id="6f26" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在模型训练期间，<em class="nd">损失</em>历史已经保存在<em class="nd"> NERModel </em>类的<em class="nd"> fit </em>()方法中。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="6d0e" class="nj mh iq nf b gy nk nl l nm nn">from matplotlib import pyplot as plt</span><span id="5e07" class="nj mh iq nf b gy nr nl l nm nn">loss_history = [loss['ner'] for loss in ner_model.loss_history]<br/>plt.title("Model Training Loss History")<br/>plt.xlabel("Iterations")<br/>plt.ylabel("Loss")<br/>plt.plot(loss_history)</span></pre><p id="b301" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上述代码使用保存的<em class="nd">损失</em>历史数据绘制了以下损失历史图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/63bc5780e95d9d7ed1e1c73c78a2847d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*c4FqX3-541q6Q8wt3S1Xog.png"/></div></figure><p id="b7da" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦<em class="nd"> NER </em>模型被训练，它可以保存到文件中以备后用，如下所示:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="faae" class="nj mh iq nf b gy nk nl l nm nn">ner_model.to_disk('./model/ner_model')</span></pre><h1 id="e4c8" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">5.评估NER模型</h1><p id="65ae" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">一旦一个空间<em class="nd"> NER </em>模型被训练，那么<em class="nd"> NERModel </em>类的<em class="nd"> accuracy_score </em>()方法就可以用模型测试数据集来调用，以获得模型精度性能结果。</p><p id="9252" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">原始精度结果是一个Python字典，其中包含令牌、实体和每种实体类型的精度、召回率和f1值。这样的字典可以被格式化为熊猫数据帧，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/3afc0e498bc92f128530e4f1876c72b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*fdRFKEubBxjIXSnr6dz1sg.png"/></div></figure><h1 id="079a" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">6.扩展NER模型</h1><p id="6251" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">如前所述，本文创建了一个实体标尺模型，用于自动生成带注释的文本数据集。</p><p id="65d1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下代码显示了如何通过将相同的实体标尺模型和NER模型合并为一个来扩展已训练的NER模型。这很有用，因为实体标尺模型识别的实体可能由于训练数据和/或时间的限制而被<em class="nd"> NER </em>模型遗漏。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="86ab" class="nj mh iq nf b gy nk nl l nm nn">from spacy.language import Language</span><span id="3af7" class="nj mh iq nf b gy nr nl l nm nn">def extend_model(surgery, internalMedicine, <br/>                 medication, obstetricsGynecology):<br/>    ruler_model = spacy.load('./model/ruler_model') <br/>    base_ner_model = spacy.load('./model/ner_model') </span><span id="6a97" class="nj mh iq nf b gy nr nl l nm nn">    @Language.component("my_entity_ruler")<br/>    def ruler_component(doc):<br/>        doc = ruler_model(doc)<br/>        return doc<br/>    <br/>    for entity_type_set in [surgery, internalMedicine, <br/>                            medication, obstetricsGynecology]:<br/>        for item in entity_type_set:<br/>            base_ner_model.vocab.strings.add(item)</span><span id="58b4" class="nj mh iq nf b gy nr nl l nm nn">    if 'my_entity_ruler' in base_ner_model.pipe_names:<br/>        base_ner_model.remove_pipe('my_entity_ruler')</span><span id="7f54" class="nj mh iq nf b gy nr nl l nm nn">    base_ner_model.add_pipe("my_entity_ruler", before='ner') <br/>    <br/>    return base_ner_model</span></pre><h1 id="08f0" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">7.识别和可视化命名实体</h1><p id="1d7d" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">一旦空间NER模型被训练和/或扩展，那么我们可以使用它从给定的文本文档中识别命名实体，如下所示:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="1d33" class="nj mh iq nf b gy nk nl l nm nn">doc = <em class="nd">extended_ner_model</em>(text)</span></pre><p id="63fb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">可以通过<em class="nd">文档</em>访问已识别的实体。</p><p id="1b2f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面的功能是在Jupyter记事本中使用颜色编码显示已识别的命名实体:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="fbbc" class="nj mh iq nf b gy nk nl l nm nn">def display_doc(doc): <br/>    colors = { "surgery": "pink",<br/>               "internalMedicine": "orange",<br/>               "medication": "lightblue",<br/>               "obstetricsGynecology": "lightgreen", <br/>             }<br/>    options = {"ents": ["surgery", <br/>                        "internalMedicine", <br/>                        "medication",<br/>                        "obstetricsGynecology",<br/>                       ], <br/>                "colors": colors<br/>              }</span><span id="65b4" class="nj mh iq nf b gy nr nl l nm nn">     displacy.render(doc, style='ent', <br/>                     options=options, jupyter=True)</span><span id="7741" class="nj mh iq nf b gy nr nl l nm nn">display_doc(doc)</span></pre><p id="2720" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是两个示例文档中带注释的实体的显示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/f8f1efdc4d8d4c879f0196b5998e1d3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lzwzqBH-gmC0Qqt3eMqFiQ.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/682b139207dec043c703af99c7ee7421.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eYEZYjm-NjonFgE-BIyYzA.png"/></div></div></figure><h1 id="7b73" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">8.结论</h1><p id="ad63" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">在本文中，我使用了与[1]中描述的相同的数据集[2][3]，来展示如何使用spaCy [4]实现特定于医疗保健领域的命名实体识别(<a class="ae lr" href="https://en.wikipedia.org/wiki/Named-entity_recognition" rel="noopener ugc nofollow" target="_blank"> NER </a>)方法。在该方法中，首先识别一组医疗实体和类型，然后创建空间实体标尺模型并用于自动生成用于模型训练和测试的带注释的文本数据集，之后创建并训练空间NER模型，最后使用相同的实体标尺模型来扩展训练的NER模型的能力。结果表明，这种新的NER方法在识别临床领域特定命名实体方面是有效的。</p><h1 id="e882" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">参考</h1><p id="7842" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">[1] Y. Huang，<a class="ae lr" rel="noopener" target="_blank" href="/common-machine-learning-and-deep-learning-methods-for-clinical-text-classification-188473477a32">用于临床文本分类的常用机器学习和深度学习方法</a></p><p id="43b6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[2]MTS示例:<a class="ae lr" href="https://www.mtsamples.com" rel="noopener ugc nofollow" target="_blank">https://www.mtsamples.com</a></p><p id="673e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[3] T .波义耳，<a class="ae lr" href="https://www.kaggle.com/tboyle10/medicaltranscriptions" rel="noopener ugc nofollow" target="_blank">https://www.kaggle.com/tboyle10/medicaltranscriptions</a></p><p id="a366" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[4]空间:<a class="ae lr" href="https://allenai.github.io/scispacy/" rel="noopener ugc nofollow" target="_blank">https://allenai.github.io/scispacy/</a></p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="8be5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">鸣谢:我要感谢MTSamples和Kaggle提供的数据集。</p></div></div>    
</body>
</html>