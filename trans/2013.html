<html>
<head>
<title>A Guide To Python’s Dunder Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python的Dunder方法指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-guide-to-pythons-dunder-methods-3b8104fce335#2022-05-07">https://towardsdatascience.com/a-guide-to-pythons-dunder-methods-3b8104fce335#2022-05-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b1b1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python背后的魔力</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8b3f9072e62cf761aef8b1bbce83d430.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_OD79hy5cwDRMI8m"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯·里德在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4c92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python有几个神奇的方法——你通常会听到从业者称之为<em class="lv"> dunder方法(我将它们互换使用)</em>。这些方法执行一个称为<em class="lv">操作符重载的过程:</em> <strong class="lb iu">向操作符</strong> <em class="lv">提供超出预定义含义的扩展含义。我们使用操作重载将自定义行为添加到我们的类中，这样我们就可以将它们与Python的操作符和内置函数一起使用。</em></p><p id="84d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想到一个更笨的方法的最简单的方法是作为你的实现和Python解释器之间的契约。合同的一个条款涉及Python在某些给定的情况下在幕后执行一些动作(例如，试图向自定义类添加一个整数)。</p><p id="226b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Dunder方法以两个下划线开始和结束:您可能遇到的最流行的方法是<code class="fe lw lx ly lz b">__init__()</code>方法。我们在一个类中创建了<code class="fe lw lx ly lz b">__init__()</code>方法，这样我们就可以用该类的特定属性来初始化该类— <em class="lv">在</em><a class="ae ky" href="https://medium.com/geekculture/getting-started-with-object-oriented-programming-in-python-3-e0a87d38acfc" rel="noopener"><em class="lv">Python 3</em></a><em class="lv">面向对象编程入门中了解更多关于面向对象编程的信息。</em></p><p id="35b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是<code class="fe lw lx ly lz b">__init__()</code>只是几种魔法方法中的一种。在本文中，我们将介绍您可能遇到的不同类型的dunder方法以及它们的作用。</p><h1 id="23b6" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">字符串表示方法</h1><p id="1b7d" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">每当我们在Python中创建新对象时，我们都会隐式地创建一个相关的对象，因为所有的类都继承自<code class="fe lw lx ly lz b">Object</code>。在<code class="fe lw lx ly lz b">Object</code>中定义的方法被我们新创建的类继承，并在各种情况下使用，比如打印一个对象。</p><pre class="kj kk kl km gt mx lz my mz aw na bi"><span id="90f4" class="nb mb it lz b gy nc nd l ne nf"><strong class="lz iu">class </strong>Car: <br/>    pass</span><span id="e84b" class="nb mb it lz b gy ng nd l ne nf">car = Car()</span><span id="f00a" class="nb mb it lz b gy ng nd l ne nf"><strong class="lz iu">print</strong>(car)</span><span id="666d" class="nb mb it lz b gy ng nd l ne nf">"""<br/>&lt;__main__.Car object at 0x7f53e19a8d90&gt;<br/>"""</span></pre><p id="e217" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码是怎么知道要打印什么的？简单。Python中所有类的父类<code class="fe lw lx ly lz b">Object</code>，有一个名为<code class="fe lw lx ly lz b">__repr__()</code>(发音为dunder repper)的dunder方法；当我们调用<code class="fe lw lx ly lz b">print()</code>语句时，它从我们的<code class="fe lw lx ly lz b">Car</code>对象调用<code class="fe lw lx ly lz b">__repr__()</code>方法，该对象是从父类<code class="fe lw lx ly lz b">Object</code>继承的，并将一个值返回给主程序。</p><p id="aeb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是子类可以覆盖父类。我们所要做的就是在子类中创建一个同名的方法——在<a class="ae ky" href="https://medium.com/geekculture/inheritance-getting-to-grips-with-oop-in-python-2ec35b52570" rel="noopener"> <em class="lv">继承:在Python </em> </a>中了解更多关于继承的知识。</p><pre class="kj kk kl km gt mx lz my mz aw na bi"><span id="e4a5" class="nb mb it lz b gy nc nd l ne nf"><strong class="lz iu">class </strong>Car: <br/>    <strong class="lz iu">def </strong>__repr__(self):<br/>        <strong class="lz iu">return </strong>f"{self.__class__.__qualname__}"<br/>        <br/>car = Car()</span><span id="6fcb" class="nb mb it lz b gy ng nd l ne nf"><strong class="lz iu">print</strong>(car)</span><span id="0ece" class="nb mb it lz b gy ng nd l ne nf">"""<br/>Car<br/>"""</span></pre><p id="c4cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以使用<code class="fe lw lx ly lz b">__str__()</code>(发音为stir) dunder方法来创建一个字符串表示。<code class="fe lw lx ly lz b">__str__()</code>方法返回一个人类可读的字符串，该字符串提供了关于对象的更多有见地的信息。</p><p id="280c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">注意</em> </strong> <em class="lv">:我们的对象没有太多的变化，所以我们将使用与</em> <code class="fe lw lx ly lz b"><em class="lv">__repr__()</em></code> <em class="lv">中相同的信息。</em></p><pre class="kj kk kl km gt mx lz my mz aw na bi"><span id="1a26" class="nb mb it lz b gy nc nd l ne nf"><strong class="lz iu">class</strong> Car: <br/>    <strong class="lz iu">def </strong>__str__(self):<br/>        <strong class="lz iu">return </strong>f"{self.__class__.__qualname__}"<br/>        <br/>car = Car()</span><span id="e2fc" class="nb mb it lz b gy ng nd l ne nf"><strong class="lz iu">print</strong>(car)</span><span id="ecc2" class="nb mb it lz b gy ng nd l ne nf">"""<br/>Car<br/>"""</span></pre><p id="2656" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe lw lx ly lz b">__str__()</code>丢失，<code class="fe lw lx ly lz b">__repr__()</code>方法将作为备份行为。因此，当您调用<code class="fe lw lx ly lz b">print()</code>时，它首先查找<code class="fe lw lx ly lz b">__str__()</code>以查看它是否已被定义，否则它调用<code class="fe lw lx ly lz b">__repr__()</code>。</p><h1 id="7515" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">数学方法</h1><p id="cde6" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">当我们创建表达式时，我们使用称为<em class="lv">操作符</em>的特殊符号。如果我们希望在一个表达式中使用操作数，那么它必须有一个数学方法，操作符可以用它来计算表达式。如果不创建math dunder方法，Python会引发类型错误。</p><pre class="kj kk kl km gt mx lz my mz aw na bi"><span id="1a1f" class="nb mb it lz b gy nc nd l ne nf"><strong class="lz iu">class </strong>RandomNumbers: <br/>    <strong class="lz iu">def </strong>__init__(self, a, b): <br/>        self.a = a <br/>        self.b = b<br/>        <br/>set_a = RandomNumbers(2, 4)<br/>set_b = RandomNumbers(3, 5)</span><span id="b113" class="nb mb it lz b gy ng nd l ne nf"><strong class="lz iu">print</strong>(set_a + set_b)</span><span id="3ebe" class="nb mb it lz b gy ng nd l ne nf">"""<br/>Traceback (most recent call last):<br/>  File "&lt;string&gt;", line 9, in &lt;module&gt;<br/>TypeError: unsupported operand type(s) for +: 'RandomNumbers' and 'RandomNumbers'<br/>"""</span></pre><p id="869c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我们可以简单地在我们的类中创建一个<code class="fe lw lx ly lz b">add_random_numbers()</code>方法，但是解决这个问题的更好的方法是使用<code class="fe lw lx ly lz b">__add__()</code> dunder方法——这样，我们可以对我们的<code class="fe lw lx ly lz b">RandomNumbers</code>对象使用<code class="fe lw lx ly lz b">+</code>操作符。</p><pre class="kj kk kl km gt mx lz my mz aw na bi"><span id="0906" class="nb mb it lz b gy nc nd l ne nf"><strong class="lz iu">class </strong>RandomNumbers: <br/>    <strong class="lz iu">def </strong>__init__(self, a, b): <br/>        self.a = a <br/>        self.b = b<br/>    <br/>    <strong class="lz iu">def </strong>__add__(self, other):<br/>        # Only permit RandomNumber objects to be added<br/>        <strong class="lz iu">if not </strong>isinstance(other, RandomNumbers): <br/>            <strong class="lz iu">return</strong> NotImplemented<br/>            <br/>        <strong class="lz iu">return </strong>RandomNumbers(other.a + self.a, other.b + self.b)<br/>    <br/>    <strong class="lz iu">def </strong>__repr__(self):<br/>        <strong class="lz iu">return </strong>f"{self.__class__.__qualname__}({self.a}, {self.b})"<br/>        <br/>set_a = RandomNumbers(2, 4)<br/>set_b = RandomNumbers(3, 5)</span><span id="0386" class="nb mb it lz b gy ng nd l ne nf"><strong class="lz iu">print</strong>(set_a + set_b)</span><span id="8dcd" class="nb mb it lz b gy ng nd l ne nf">"""<br/>RandomNumbers(5, 9)<br/>"""</span></pre><p id="5d16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个<code class="fe lw lx ly lz b">RandomNumbers</code>对象位于<code class="fe lw lx ly lz b">+</code>操作符的左侧时，Python将调用<code class="fe lw lx ly lz b">__add__()</code>方法:<code class="fe lw lx ly lz b">+</code>操作符右侧的方法作为<code class="fe lw lx ly lz b">other</code>参数传递给<code class="fe lw lx ly lz b">__add__()</code>方法。</p><p id="0b22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，我们防止我们的对象添加不是<code class="fe lw lx ly lz b">RandomNumber</code>实例的对象。让我们来看另一种方法，它允许我们将数字与整数相乘:</p><pre class="kj kk kl km gt mx lz my mz aw na bi"><span id="1503" class="nb mb it lz b gy nc nd l ne nf"><strong class="lz iu">class </strong>RandomNumbers: <br/>    <strong class="lz iu">def </strong>__init__(self, a, b): <br/>        self.a = a <br/>        self.b = b<br/>    <br/>    <strong class="lz iu">def </strong>__add__(self, other):<br/>        <strong class="lz iu">if not</strong> <strong class="lz iu">isinstance</strong>(other, RandomNumbers):<br/>            <strong class="lz iu">return NotImplemented</strong><br/>            <br/>        <strong class="lz iu">return </strong>RandomNumbers(other.a + self.a, other.b + self.b)<br/>        <br/>    <strong class="lz iu">def </strong>__mul__(self, other): <br/>        if not isinstance(other, int): <br/>            <strong class="lz iu">return NotImplemented </strong><br/>            <br/>        <strong class="lz iu">return </strong>RandomNumbers(self.a * other, self.b * other)<br/>    <br/>    <strong class="lz iu">def </strong>__repr__(self):<br/>        return f"{self.__class__.__qualname__}({self.a}, {self.b})"<br/>        <br/>set_a = RandomNumbers(2, 4)</span><span id="c7bd" class="nb mb it lz b gy ng nd l ne nf"><strong class="lz iu">print</strong>(set_a * 3)</span><span id="0b78" class="nb mb it lz b gy ng nd l ne nf">"""<br/>RandomNumbers(6, 12)<br/>"""</span></pre><p id="565d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，请注意<code class="fe lw lx ly lz b">RandomNumbers</code>实例位于<code class="fe lw lx ly lz b">*</code>操作符的左侧。如果我们把它移到右边会发生什么？</p><pre class="kj kk kl km gt mx lz my mz aw na bi"><span id="b5f7" class="nb mb it lz b gy nc nd l ne nf">-- snip -- </span><span id="4739" class="nb mb it lz b gy ng nd l ne nf">set_a = RandomNumbers(2, 4)</span><span id="a95b" class="nb mb it lz b gy ng nd l ne nf"><strong class="lz iu">print</strong>(3 * set_a)</span><span id="1abe" class="nb mb it lz b gy ng nd l ne nf">"""<br/>Traceback (most recent call last):<br/>  File "&lt;string&gt;", line 23, in &lt;module&gt;<br/>TypeError: unsupported operand type(s) for *: 'int' and 'RandomNumbers'<br/>"""</span></pre><p id="4b8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python引发了一个类型错误。</p><p id="320a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出现这种情况的原因是，当对象位于数学运算符的左侧时，会调用math dunder方法。如果你想扩展这个功能，那么你也可以调用右边的对象，那么你必须定义<em class="lv"> reverse dunder方法</em>。</p><p id="39e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用乘法的例子来证明这一点:</p><pre class="kj kk kl km gt mx lz my mz aw na bi"><span id="354b" class="nb mb it lz b gy nc nd l ne nf"><strong class="lz iu">class </strong>RandomNumbers:<br/>    <strong class="lz iu">def </strong>__init__(self, a, b): <br/>        self.a = a <br/>        self.b = b<br/>    <br/>    <strong class="lz iu">def </strong>__add__(self, other):<br/>        <strong class="lz iu">if not</strong> <strong class="lz iu">isinstance</strong>(other, RandomNumbers):<br/>            <strong class="lz iu">return </strong>NotImplemented<br/>            <br/>        <strong class="lz iu">return </strong>RandomNumbers(other.a + self.a, other.b + self.b)<br/>        <br/>    <strong class="lz iu">def </strong>__mul__(self, other): <br/>        <strong class="lz iu">i</strong>f <strong class="lz iu">not isinstance</strong>(other, int): <br/>            <strong class="lz iu">return </strong>NotImplemented <br/>            <br/>        <strong class="lz iu">return </strong>RandomNumbers(self.a * other, self.b * other)<br/>    <br/>    <strong class="lz iu">def </strong>__rmul__(self, other): <br/>        <strong class="lz iu">return </strong>self.__mul__(other)<br/>    <br/>    <strong class="lz iu">def </strong>__repr__(self):<br/>        <strong class="lz iu">return</strong> f"{self.__class__.__qualname__}({self.a}, {self.b})"<br/>        <br/>set_a = RandomNumbers(2, 4)</span><span id="d5d8" class="nb mb it lz b gy ng nd l ne nf"><strong class="lz iu">print</strong>(3 * set_a)</span><span id="aaa7" class="nb mb it lz b gy ng nd l ne nf">"""<br/>RandomNumbers(6, 12)<br/>"""</span></pre><p id="3750" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题解决了。</p><p id="cdab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是两种类型的邓德方法，但是有几种——你可以在这里找到它们的列表<a class="ae ky" href="https://docs.python.org/2/reference/datamodel.html#special-method-names" rel="noopener ugc nofollow" target="_blank"/>。如果你对提升你的Python技能感兴趣，我建议你查看一下<a class="ae ky" href="https://www.datacamp.com/learn/python" rel="noopener ugc nofollow" target="_blank">数据营</a>提供的Python技能和职业轨迹。</p><p id="b29e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">感谢阅读。</em></p><p id="2836" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">联系我:</strong><br/><a class="ae ky" href="https://www.linkedin.com/in/kurtispykes/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a><br/><a class="ae ky" href="https://twitter.com/KurtisPykes" rel="noopener ugc nofollow" target="_blank">Twitter</a><br/><a class="ae ky" href="https://www.instagram.com/kurtispykes/" rel="noopener ugc nofollow" target="_blank">insta gram</a></p><p id="5525" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢阅读这样的故事，并希望支持我的写作，可以考虑<a class="ae ky" href="https://kurtispykes.medium.com/membership" rel="noopener">成为灵媒成员</a>。每月支付5美元，你就可以无限制地阅读媒体上的故事。如果你使用<a class="ae ky" href="https://kurtispykes.medium.com/membership" rel="noopener">我的注册链接</a>，我会收到一小笔佣金。</p><p id="4354" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">已经是会员了？订阅在我发布时得到通知。</p><div class="nh ni gp gr nj nk"><a href="https://kurtispykes.medium.com/subscribe" rel="noopener follow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">每当Kurtis Pykes发表文章时都收到一封电子邮件。</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">每当Kurtis Pykes发表文章时都收到一封电子邮件。通过注册，您将创建一个中型帐户，如果您还没有…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">kurtispykes.medium.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny ks nk"/></div></div></a></div></div></div>    
</body>
</html>