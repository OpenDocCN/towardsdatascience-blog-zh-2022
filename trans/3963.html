<html>
<head>
<title>Understanding Affinity Propagation Clustering And Implementation with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解相似性传播聚类和Python实现</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-affinity-propagation-clustering-and-implementation-with-python-c1e78fe57cde#2022-09-02">https://towardsdatascience.com/understanding-affinity-propagation-clustering-and-implementation-with-python-c1e78fe57cde#2022-09-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="c0cf" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">无监督学习</h2><div class=""/><div class=""><h2 id="4d25" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">最常用的聚类方法之一，相似性传播，连同Python的实现一起被清楚地解释</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/20001189bac16dd1437956d4d9e2e3de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A6YsfUsTanDWh26L"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@madebyluca?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卢卡</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="804c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi me translated"><span class="l mf mg mh bm mi mj mk ml mm di"> A </span>模糊传播是数据科学中使用最广泛的聚类方法之一。它既没有对聚类形状的假设，也不需要聚类的数量作为输入。相似性传播的另一个优点是它不依赖于初始聚类质心选择的任何运气。</p><p id="8f79" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这篇文章中，我将详细介绍如何理解和使用Python中的仿射传播。</p><h2 id="8b91" class="mn mo it bd mp mq mr dn ms mt mu dp mv lr mw mx my lv mz na nb lz nc nd ne iz bi translated">亲和传播的主要思想</h2><p id="6f0d" class="pw-post-body-paragraph li lj it lk b ll nf kd ln lo ng kg lq lr nh lt lu lv ni lx ly lz nj mb mc md im bi translated">我们来想想社会上大多数人的行为。</p><blockquote class="nk nl nm"><p id="d74b" class="li lj nn lk b ll lm kd ln lo lp kg lq no ls lt lu np lw lx ly nq ma mb mc md im bi translated">一开始，你谁都不认识，所以你是你自己的代表。然后，在你认识更多的人之后，在一些交流之后，你发现有些人和你有相似的价值观，有些人很难相处。所以，你倾向于和那些和你相似的人有更多的互动，避免和那些在你眼里“怪异”的人混在一起。随着沟通次数的增加，你终于找到了你的“小组”，你的脑海中出现了一个可以完美代表你的小组的候选人。</p></blockquote><p id="7e94" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">其实我所描述的正是亲和传播的<strong class="lk jd"> <em class="nn">基本思路</em> </strong>。</p><p id="f160" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该算法使用数据点之间的<em class="nn">“通信”</em>来为每个数据点寻找<em class="nn">“样本”</em>。并且共享相同<em class="nn">“样本”</em>的数据点被分配到相同的聚类(组)。</p><p id="d29f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">尽管算法的想法很简单，但在上面的描述中仍然有一些令人困惑的地方。你可能已经注意到，最大的缺失部分是那些<strong class="lk jd"> <em class="nn">【沟通】</em> </strong>是如何执行的。</p><p id="561f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们使用与上面相同的例子。“沟通”实际上是你和你心目中的团体代表候选人之间传递的信息。如果你发现迈克尔是你的最佳候选人，你可以发短信给他，“迈克尔，我认为你应该是代表我的人。”</p><p id="e9b8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，也许迈克尔会回答:“我很感激。我很乐意这么做！”</p><p id="1038" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">或者，迈克尔会回答:“谢谢你信任我。然而，考虑到所有其他人都有同样的要求，我没有足够的带宽向您介绍。抱歉。”</p><p id="ce9c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，根据迈克尔的回答，你将调整你心目中的代表候选人的排名，并再次向他们发送消息。之后，迈克尔将再次收到所有人(包括你)发来的信息，说他们多么渴望迈克尔成为他们的代表。然后他会从那里开始调整…</p><p id="48dc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我描述的过程正是仿射传播中的迭代。你发送给迈克尔的信息在算法中被称为<strong class="lk jd"> <em class="nn">【责任】</em> </strong>，这表明迈克尔非常适合作为你的样本，同时考虑到你的其他潜在样本。</p><p id="3221" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">迈克尔发回的信息被称为<strong class="lk jd"> <em class="nn">【可用性】</em> </strong>，它反映了考虑到其他人对迈克尔应该成为榜样的支持，你选择迈克尔作为榜样是多么合适。</p><p id="f30d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">那么，通信应该在什么时候停止呢？当范例和他们所代表的人群没有大的变化时，就是这样。</p><h2 id="66c7" class="mn mo it bd mp mq mr dn ms mt mu dp mv lr mw mx my lv mz na nb lz nc nd ne iz bi translated">该算法</h2><p id="f8d0" class="pw-post-body-paragraph li lj it lk b ll nf kd ln lo ng kg lq lr nh lt lu lv ni lx ly lz nj mb mc md im bi translated">在深入研究算法之前，我们需要理解几个矩阵。</p><p id="ae92" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">第一个是相似度矩阵，<strong class="lk jd"> <em class="nn"> S </em> </strong>，是数据点之间相似度的集合，其中相似度<strong class="lk jd"> <em class="nn"> s(i，k) </em> </strong>表示数据点<strong class="lk jd"> <em class="nn"> k </em> </strong>与数据点<strong class="lk jd"> <em class="nn"> i </em> </strong>的相似度。</p><p id="11c1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">直观上，相似度值越大，两个数据点之间的距离越小。因此，传统上，负欧几里德距离用于定义相似性。这里，<strong class="lk jd"> <em class="nn"> s(i，k) </em> </strong>，点<strong class="lk jd"> <em class="nn"> i </em> </strong>与点<strong class="lk jd"> <em class="nn"> k </em> </strong>的相似性，是</p><blockquote class="nr"><p id="3132" class="ns nt it bd nu nv nw nx ny nz oa md dk translated">s(i，k)= | | Xi xk | |</p></blockquote><p id="ed48" class="pw-post-body-paragraph li lj it lk b ll ob kd ln lo oc kg lq lr od lt lu lv oe lx ly lz of mb mc md im bi translated">需要注意的是，相似度矩阵的对角线值<strong class="lk jd"><em class="nn">【s(k，k)】</em></strong>在相似性传播中具有特定的含义和用法，而不是简单地被赋值为零。该设计是具有较大的值<strong class="lk jd"><em class="nn">【k，k】</em></strong>的数据点更有可能被选为样本。</p><p id="896e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">想象一下，所有的<strong class="lk jd"> <em class="nn"> s(k，k) </em> </strong>值都超级大。这意味着每个点肯定是自己的样本，其中每个数据点都是自己的聚类；然而，如果所有的<strong class="lk jd"><em class="nn">【s(k，k) </em> </strong>的值都非常小，那么所有的数据点都不能作为自己的样本，所有的数据点都属于同一个大的聚类。</p><p id="c314" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以看到，相似度矩阵对角线上的值可以影响最终检测到的聚类数，因此命名为“偏好”。我们知道上述两种情况都不理想，所以我们必须为首选项初始化好的值。</p><p id="98f2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因为我们在开始时不知道数据点的偏好值，所以我们必须假设所有的数据点作为样本是同样可能的。因此，应该将首选项设置为一个公共值。根据经验，人们通常使用输入相似度的中值作为偏好值。</p><p id="f37d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">第二个矩阵是责任矩阵，<strong class="lk jd"> <em class="nn"> R </em> </strong>，其中的<em class="nn"/><strong class="lk jd"><em class="nn">R(I，k) </em> </strong>，反映的是如何很好地将点<strong class="lk jd"> <em class="nn"> k </em> </strong>作为点<strong class="lk jd"> <em class="nn"> i </em> </strong>的样本，同时考虑到点<strong class="lk jd"> <em class="nn"> i </em> </strong>的其他潜在样本。</p><p id="b7ab" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">第三个矩阵是可用性矩阵，<strong class="lk jd"> <em class="nn"> A </em> </strong>，其中<em class="nn"/><strong class="lk jd"><em class="nn">A(I，k) </em> </strong>，反映了点<strong class="lk jd"><em class="nn">【I</em></strong>选择点<strong class="lk jd"> <em class="nn"> k </em> </strong>作为其范例是多么合适，同时考虑了其他点对该点<strong class="lk jd"><em class="nn">k</em><strong class="lk jd"/></strong></p><p id="e60a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该算法将<strong class="lk jd"> <em class="nn"> R </em> </strong>和<strong class="lk jd"> <em class="nn"> A </em> </strong>初始化为零矩阵，然后迭代更新<strong class="lk jd"> <em class="nn"> R </em> </strong>和<strong class="lk jd"> <em class="nn"> A </em> </strong>。</p><p id="55c0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="nn"> R </em> </strong>使用以下等式更新。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi og"><img src="../Images/53410d59acc9241ee5eb714c73292d33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*spebqgoX6lCMVkTWYCiKJA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="9d7e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个等式的构造相对简单。在第一次迭代时(记住<strong class="lk jd"> <em class="nn"> A </em> </strong>被设置为零矩阵)，<strong class="lk jd"> <em class="nn"> r(i，k) </em> </strong>仅仅是点<strong class="lk jd"> <em class="nn"> i </em> </strong>和点<em class="nn"><em class="nn">k</em>之间的相似性减去点<strong class="lk jd"><em class="nn">I<em class="nn">之间的最大<strong class="lk jd">相似性</strong></em></em></strong></em></p><p id="d7a5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在以后的迭代中，如果一个点具有比<strong class="lk jd"> <em class="nn"> i </em> </strong>更高的分数作为其他点的范例(比调查点更类似于其他点，<strong class="lk jd"> <em class="nn"> i </em> </strong>)，则该点的(<strong class="lk jd"><em class="nn">′</em></strong>)可用性值将减少。在这种情况下，通过减小<strong class="lk jd"> <em class="nn"> max{a(i，k’)+s(I，k’)}</em></strong>的值，会对<strong class="lk jd"><em class="nn">【I，k’)</em></strong>产生负面影响，然后<strong class="lk jd"> <em class="nn"> r(i，k) </em> </strong>会得到加强，因为点<strong class="lk jd"><em class="nn">k’</em></strong>相当于点<strong class="lk jd"> <em class="nn"> i </em></strong></p><p id="bbe5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，这个分数，<strong class="lk jd"> <em class="nn"> r(i，k) </em> </strong>将显示出<strong class="lk jd"> <em class="nn"> k </em> </strong>与所有其他点相比是如何突出地成为<strong class="lk jd"><em class="nn"/></strong>的范例。</p><p id="0d3b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要注意，<strong class="lk jd"> <em class="nn"> r(i，i) </em> </strong>叫做自我负责，这表明点<strong class="lk jd"> <em class="nn"> i </em> </strong>是一个典范的可能性有多大。</p><p id="a65f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面是<strong class="lk jd"> <em class="nn"> A </em> </strong>的更新方式。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/8a3ce83c6cfd7173c9772299bb52198a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*jZ8i15pN7XIzvGGEP1izcQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/cd619d00b1d9564e0e0f9aaca837ceb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*1WzkyItxhzLd1N-FmDkMkA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="a064" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">点<strong class="lk jd"> <em class="nn"> k </em> </strong>成为<strong class="lk jd"> <em class="nn"> i </em> </strong>的样例(<strong class="lk jd"> <em class="nn"> a(i，k) </em> </strong>)的可用性被设置为点<strong class="lk jd"> <em class="nn"> k </em> </strong>是样例(<strong class="lk jd"> <em class="nn"> r(k，k) </em> </strong>)加上外部最小设置试图将<strong class="lk jd"> <em class="nn"> a(i，k) </em> </strong>限制为零，以避免超大的正责任值。</p><p id="fe10" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">自我可用性(<strong class="lk jd"> <em class="nn"> a(k，k) </em> </strong>)就是从所有其他点接收到的积极责任点<strong class="lk jd"> <em class="nn"> k </em> </strong>的总和。</p><p id="1b64" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="nn"> A </em> </strong>和<strong class="lk jd"> <em class="nn"> R </em> </strong>在仿射传播算法中通过迭代不断更新，直到在固定次数的迭代后没有变化。</p><p id="7880" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="nn"> A </em> </strong>更新给定<strong class="lk jd"> <em class="nn"> R </em> </strong>和<strong class="lk jd"> <em class="nn"> R </em> </strong>更新给定<strong class="lk jd"> <em class="nn"> A </em> </strong>。听起来很像吧？</p><p id="ca22" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">是的，该算法非常类似于EM(期望最大化)算法。如果你对EM算法感兴趣，你可以<a class="ae lh" href="https://medium.com/towards-data-science/gaussian-mixture-models-with-python-36dabed6212a" rel="noopener">在这里</a>阅读我以前的一篇帖子。</p><p id="76f7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一点要注意的是，阻尼因子总是用来避免迭代中的数值振荡。具体地，矩阵中的新值被定义为，</p><blockquote class="nr"><p id="1208" class="ns nt it bd nu nv nw nx ny nz oa md dk translated"><em class="oj"> val_new =(丹皮事实)(val _ old)+(1-丹皮事实)(val_new) </em></p></blockquote><p id="fa23" class="pw-post-body-paragraph li lj it lk b ll ob kd ln lo oc kg lq lr od lt lu lv oe lx ly lz of mb mc md im bi translated">当算法停止时，根据<strong class="lk jd"> <em class="nn"> R </em> </strong>和<strong class="lk jd"> <em class="nn"> A </em> </strong>之和做出最终决定。然后，每行的最大值的对应列名就是该行的样本。共享同一样本的行被分配到同一簇。</p><p id="bccd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">比如我们用一个人工矩阵作为下面的<strong class="lk jd"> <em class="nn"> R </em> </strong>和<strong class="lk jd"> <em class="nn"> A </em> </strong>的和矩阵，</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ok"><img src="../Images/181b2de19126169f0b8c408d36dbca5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Ya1Hp4TMQxMf0-f67oPDQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">A + R(图片由作者提供)</p></figure><p id="b717" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">每行的最大值突出显示，对应的列是样本，其中是这个数据集中的Jim和Clark。迈克尔、约翰、吉姆和亚历克斯属于吉姆组，而克拉克和布朗属于克拉克组。</p><h2 id="a753" class="mn mo it bd mp mq mr dn ms mt mu dp mv lr mw mx my lv mz na nb lz nc nd ne iz bi translated">履行</h2><p id="1ba6" class="pw-post-body-paragraph li lj it lk b ll nf kd ln lo ng kg lq lr nh lt lu lv ni lx ly lz nj mb mc md im bi translated">在Python中，算法是在sklearn包中实现的。我在下面列出了如何使用它，</p><pre class="ks kt ku kv gt ol om on oo aw op bi"><span id="a23e" class="mn mo it om b gy oq or l os ot"><strong class="om jd">from</strong> <strong class="om jd">sklearn.cluster</strong> <strong class="om jd">import</strong> AffinityPropagation<br/>clustering = AffinityPropagation(random_state=25).fit(X)<br/>clustering.labels_</span></pre></div><div class="ab cl ou ov hx ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="im in io ip iq"><p id="5ce8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">就是这样！相似性传播算法。很简单，对吧？</p><p id="173e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你喜欢阅读我的帖子，请<a class="ae lh" href="https://jianan-lin.medium.com/subscribe" rel="noopener">订阅我的电子邮件列表</a>或<a class="ae lh" href="https://jianan-lin.medium.com/membership" rel="noopener">成为媒体</a>的推荐会员(我会得到你的部分费用作为我写作的支持)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pb"><img src="../Images/bdf557c2d5a8f0652b6d68174b92a827.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QvllYdZoNFNr8a4r"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@carminesavarese?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡迈恩·萨瓦雷斯</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="1024" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">参考资料:</p><p id="6881" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">弗雷，布兰登j .和德尔伯特.杜克。"通过在数据点之间传递消息进行聚类."科学315.5814(2007):972–976。</p></div></div>    
</body>
</html>