<html>
<head>
<title>How to Connect to SQL Databases from Python Using SQLAlchemy and Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用 SQLAlchemy 和 Pandas 从 Python 连接到 SQL 数据库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/work-with-sql-in-python-using-sqlalchemy-and-pandas-cd7693def708#2022-03-21">https://towardsdatascience.com/work-with-sql-in-python-using-sqlalchemy-and-pandas-cd7693def708#2022-03-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9744" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过 SQLAlchemy 提取 SQL 表，在 SQL 数据库中插入、更新和删除行</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7f594dbc39a464b175acbdbd98d3da4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iY8aCBChcAk2DESXI3JxcQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">帕斯卡尔·米勒在<a class="ae ky" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片(作者修改)</p></figure><p id="89e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个数据科学项目中，我们经常需要与<strong class="lb iu">关系数据库</strong>进行交互，例如，在 SQL 表中提取表、插入、更新和删除行。为了完成这些任务，Python 有一个这样的库，叫做<strong class="lb iu"> SQLAlchemy </strong>。它支持流行的 SQL 数据库，如<strong class="lb iu"> PostgreSQL </strong>、<strong class="lb iu"> MySQL </strong>、<strong class="lb iu"> SQLite </strong>、<strong class="lb iu"> Oracle </strong>、<strong class="lb iu">微软 SQL Server </strong>等。更好的是，它有内置功能，可以与<strong class="lb iu">熊猫</strong>集成。SQLAlchemy 和 Pandas 是处理数据管理的完美组合。</p><h1 id="1bfd" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">安装库</h1><p id="b754" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">除了 SQLAlchemy 和 pandas，我们还需要安装一个 SQL 数据库适配器来实现<strong class="lb iu"> Python 数据库 API </strong>。例如，我们需要为 PostgreSQL 安装“psycopg2”或“pg8000”，为 mysql 安装“mysql-connector-python”或“oursql”，为 Oracle SQL 数据库安装“cx-Oracle”，为 Microsoft SQL Server 安装“pyodbc”或“pymssql”等。在本文中，我将讨论如何将 PostgreSQL 与 Python 集成，因此，让我们安装“<strong class="lb iu"> psycopg2 </strong>”。</p><p id="7178" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开 anaconda 提示符或命令提示符，并键入以下命令。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="4906" class="mx lw it mt b gy my mz l na nb">pip install SQLAlchemy<br/>pip install pandas <br/>pip install psycopg2</span></pre><h1 id="6877" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">导入库</h1><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="9363" class="mx lw it mt b gy my mz l na nb">import sqlalchemy<br/>import pandas as pd</span></pre><h1 id="78ee" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">创建到数据库的连接</h1><p id="f985" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先，让我们基于一个<strong class="lb iu"> URL </strong>使用“<strong class="lb iu"> create_engine() </strong>”函数创建一个与 PostgreSQL 数据库的连接。URL 通常由方言、驱动程序、用户名、密码、主机名、数据库名以及用于附加配置的可选参数组成。数据库 URL 的典型形式看起来像“<strong class="lb iu">方言+驱动://用户名:密码@主机:端口/数据库</strong>”。比如微软 SQL Server 的“MSSQL+py odbc://username:password @ host:port/database”，mysql 的“MySQL+MySQL connector://username:password @ host:port/database”，postgresql 的“PostgreSQL+psycopg 2://username:password @ host:port/database”。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="9214" class="mx lw it mt b gy my mz l na nb">url = '<strong class="mt iu">postgresql+psycopg2://username:password@host:port/database</strong>'<br/>engine = sqlalchemy.<strong class="mt iu">create_engine</strong>(url)</span></pre><p id="db61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以在“create_engine()”函数中包含可选参数。例如，我们可以添加“-csearch_path=schema_name”来覆盖 PostgreSQL 中当前会话的搜索路径。这相当于写一个查询，“将 search_path 设置为 schema_name”。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="1639" class="mx lw it mt b gy my mz l na nb">engine = sqlalchemy.create_engine(params, <strong class="mt iu">connect_args</strong>={'options': '<strong class="mt iu">-csearch_path=schema_name</strong>'})</span></pre><h1 id="326a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用 SQLAlchemy 运行 SQL 查询</h1><p id="1f4c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">一旦创建了连接，我们就可以用 Python 与 SQL 数据库进行交互。让我们从最简单的查询开始，“SELECT * FROM table”。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="33e6" class="mx lw it mt b gy my mz l na nb">from sqlalchemy.sql import <strong class="mt iu">text</strong><br/>sql = '''<br/>    SELECT * FROM table;<br/>'''<br/><strong class="mt iu">with engine.connect()</strong>.execution_options(<strong class="mt iu">autocommit=True</strong>) as conn:<br/>    query = conn.execute(<strong class="mt iu">text</strong>(sql))         <br/>df = pd.DataFrame(query.<strong class="mt iu">fetchall()</strong>)</span></pre><p id="fe4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用几个关键功能。</p><ul class=""><li id="e408" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated"><strong class="lb iu"> text(): </strong> SQLAlchemy 允许用户通过函数“text()”使用 Python 中的<strong class="lb iu">原生 SQL 语法</strong>。它会将文本语句原封不动地传递给 SQL 数据库。因此，我们可以在一个 Python 框架内使用原生 SQL 语法，比如，<strong class="lb iu"> DELETE </strong>，<strong class="lb iu"> UPDATE </strong>，<strong class="lb iu"> INSERT </strong>，<strong class="lb iu"> SELECT，全文搜索</strong>等。</li><li id="ea9c" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu"> engine.connect(): </strong>该函数返回一个 SQL <strong class="lb iu">连接</strong>对象。通过使用 Python 上下文管理器(例如，<strong class="lb iu">和</strong>语句)，"<strong class="lb iu"> Connection.close() </strong>"函数将自动包含在代码块的末尾。</li><li id="ed47" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu"> autocommit=True: </strong>函数内部的可选参数。execution_options()"允许我们打开自动提交特性。这意味着我们不需要编写额外的代码，例如，“connection.commit()”和“connection.rollback()”。"<strong class="lb iu"> connection.commit() </strong>"将提交对 SQL 数据库的任何更改，而"<strong class="lb iu"> connection.rollback() </strong>"将放弃任何更改。使用自动提交的一个好处是我们有更少的代码行，并且解决了忘记提交变更的潜在问题。</li><li id="c506" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu"> fetchall(): </strong>这个函数将返回 row 对象，这些对象可以与 Pandas 集成在一起，创建一个数据框。</li></ul><p id="2a35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，我们将<strong class="lb iu">更新、插入、删除 SQL 表中的</strong>行。与<strong class="lb iu"> SELECT </strong>唯一不同的是我们编写了“conn.execute(text(sql))”而不是“query = conn.execute(text(sql))”，因为我们不提取表。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="dfce" class="mx lw it mt b gy my mz l na nb"># <strong class="mt iu">Update </strong>rows in a SQL table<br/>sql = '''<br/>    UPDATE table <br/>    SET col='abc'<br/>    WHERE condition;<br/>'''<br/>with engine.connect().execution_options(autocommit=True) as conn:<br/>    <strong class="mt iu">conn.execute(text(sql))</strong></span><span id="282f" class="mx lw it mt b gy nr mz l na nb"># <strong class="mt iu">Insert </strong>new rows in a SQL table<br/>sql = '''<br/>    INSERT INTO df<br/>    VALUES <br/>       (1, 'abc'),<br/>       (2, 'xyz'),<br/>       (1, 'abc');<br/>'''<br/>with engine.connect().execution_options(autocommit=True) as conn:<br/>    <strong class="mt iu">conn.execute(text(sql))</strong></span><span id="8242" class="mx lw it mt b gy nr mz l na nb"># <strong class="mt iu">Delete</strong> rows in a SQL table<br/>sql = '''<br/>    DELETE FROM df<br/>    WHERE condition;<br/>'''<br/>with engine.connect().execution_options(autocommit=True) as conn:<br/>    <strong class="mt iu">conn.execute(text(sql))</strong></span></pre><p id="fdff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 Python 中运行 SQL 查询可以非常<strong class="lb iu">灵活</strong>。我们可以设置一个 for 循环来基于不同的条件运行多个 SQL 查询。例如:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="e4f4" class="mx lw it mt b gy my mz l na nb">For i in [value_1, value_2, value_3, ...]:<br/> if condition_1:<br/>  sql = '''<strong class="mt iu">sql_query_1</strong>'''<br/> elif condition_2:<br/>  sql = '''<strong class="mt iu">sql_query_2</strong>'''<br/> else:<br/>  sql = '''<strong class="mt iu">sql_query_3</strong>'''<br/>  <br/> with engine.connect().execution_options(autocommit=True) as conn:<br/>  conn.execute(text(sql))</span></pre><h1 id="f0e6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">运行多个 SQL 查询</h1><p id="cf1f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在单个块中运行多个 SQL 查询也很简单。我们只需要用<strong class="lb iu">分号</strong>分隔语句。SQLAlchemy 的简单实现使得在 Python 中与 SQL 交互变得容易。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="9849" class="mx lw it mt b gy my mz l na nb">sql = '''<br/>    DROP TABLE IF EXISTS df;<br/>    CREATE TABLE df(<br/>            id SERIAL PRIMARY KEY,<br/>            salary integer<br/>    );<br/>    INSERT INTO df (salary)<br/>    VALUES <br/>            (400),<br/>            (200),<br/>            (3001);<br/>    SELECT * FROM df;<br/>'''<br/>with engine.connect().execution_options(autocommit=True) as conn:<br/>    query = conn.execute(text(sql))         <br/>df = pd.DataFrame(query.fetchall())</span></pre><h1 id="4145" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">在 Pandas 数据框中存储 SQL 表</h1><p id="41b2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们已经提到了在 pandas 数据框中保存 SQL 表的“fetchall()”函数。<strong class="lb iu">或者</strong>，我们也可以使用“<strong class="lb iu"> pandas.read_sql </strong>”来实现。由于 SQLAlchemy 是和 Pandas 集成的，所以我们可以用“con = conn”直接使用它的 SQL 连接。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="11dd" class="mx lw it mt b gy my mz l na nb">with engine.connect().execution_options(autocommit=True) as conn:<br/>    df = pd.<strong class="mt iu">read_sql</strong>(f"""SELECT * FROM table_name WHERE condition""", <strong class="mt iu">con = conn</strong>)</span></pre><h1 id="4171" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">将数据帧插入现有的 SQL 数据库</h1><p id="a738" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">要将新行插入到现有的 SQL 数据库中，我们可以使用带有原生 SQL 语法 insert 的代码，如上所述。或者，我们可以用“T2”熊猫。DataFrame.to_sql ，带有选项“<em class="nq">if _ exists = ' append</em><strong class="lb iu">'</strong>”将<strong class="lb iu">行大容量插入到 sql 数据库中。这种方法的一个好处是我们可以充分利用 Pandas 的功能，比如导入外部数据文件和转换原始数据。因此，我们可以有一个兼容的 Pandas 数据帧(例如，具有与 SQL 表相同的列和数据类型),并准备好插入到现有的 SQL 数据库中。</strong></p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="f9e3" class="mx lw it mt b gy my mz l na nb">df = pd.read_excel('sample.xlsx')<br/>with engine.connect().execution_options(autocommit=True) as conn:<br/>    df.<strong class="mt iu">to_sql</strong>('table_name', con=conn, <strong class="mt iu">if_exists=</strong>'<strong class="mt iu">append</strong>', index= False)</span></pre><h1 id="fb94" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">创建新的 SQL 数据库</h1><p id="bcd9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><strong class="lb iu">熊猫。DataFrame.to_sql </strong>”也用于创建新的 sql 数据库。正如您在下面的示例中看到的，我们从 excel 电子表格中导入外部数据，并从 pandas 数据框架中创建新的 SQL 表。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="7d4e" class="mx lw it mt b gy my mz l na nb">from <strong class="mt iu">sqlalchemy.types</strong> import Integer, Text, String, DateTime</span><span id="c474" class="mx lw it mt b gy nr mz l na nb">df = pd.read_excel('sample.xlsx')<br/>df.<strong class="mt iu">to_sql</strong>(<br/>    "table_name", <br/>    con = engine,<br/>    <strong class="mt iu">if_exists = "replace"</strong>,<br/>    schema='shcema_name',   <br/>    index=False,<br/>    chunksize=1000,<br/>    dtype={<br/>       "col_1_name": Integer,<br/>       "col_2_name": Text,<br/>       "col_3_name": String(50),<br/>       "col_4_name": DateTime<br/>     }<br/>)</span></pre><p id="0328" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了正确地创建一个新的 sql 表，我们需要用"<strong class="lb iu"> to_sql() </strong>"函数指定几个重要的参数。</p><ul class=""><li id="481a" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated"><strong class="lb iu"> if_exists </strong>:如果数据库中已经存在一个名为“table_name”的表，该参数将指示如何处理。传递“<strong class="lb iu"> replace </strong>”将删除现有表中的所有行，并将其替换为当前的 pandas 数据框。如上所述，传递“<strong class="lb iu"> append </strong>”只会将 pandas 数据框追加到现有的 SQL 表中。</li><li id="b007" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu"> schema </strong>:该参数将获取保存新 SQL 表的模式名。如果已经在连接中指定了模式名，则不需要。</li><li id="7d40" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu"> index </strong>:该参数表示我们是否要在新的 SQL 表中为 DataFrame 的索引创建一列。</li><li id="00c4" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu"> chuncksize </strong>:该参数将指定每批中一次要插入的行数。默认情况下，所有行都将一次写入。</li><li id="08a3" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu"> dtype </strong>:该参数将指定新 SQL 表中列的数据类型。我们使用的数据类型来自<strong class="lb iu"> sqlalchemy.types. </strong></li></ul><h1 id="cf2b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">感谢您的阅读！！！</h1><p id="11e8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果你喜欢这篇文章，并且想<strong class="lb iu">请我喝杯咖啡，</strong>请<a class="ae ky" href="https://ko-fi.com/aaronzhu" rel="noopener ugc nofollow" target="_blank">点击这里</a>。</p><p id="aab3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以注册一个<a class="ae ky" href="https://aaron-zhu.medium.com/membership" rel="noopener"> <strong class="lb iu">会员</strong> </a>来解锁我的文章的全部访问权限，并且可以无限制访问介质上的所有内容。如果你想在我发表新文章时收到电子邮件通知，请订阅。</p></div></div>    
</body>
</html>