<html>
<head>
<title>Solving the Travelling Salesman Problem for Germany using NetworkX in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python中的NetworkX解决德国的旅行推销员问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/solving-the-travelling-salesman-problem-for-germany-using-networkx-in-python-2b181efd7b07#2022-06-21">https://towardsdatascience.com/solving-the-travelling-salesman-problem-for-germany-using-networkx-in-python-2b181efd7b07#2022-06-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fb7a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Christofides算法，在访问德国16个联邦州的首府城市时，发现穿越每个城市的最短路线。</h2></div><p id="2358" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我已经在德国住了六年了。德国是由16个联邦州组成的，到目前为止我已经访问了5个州的首府。最近，我想到了一个想法:</p><blockquote class="le lf lg"><p id="3ccb" class="ki kj lh kk b kl km ju kn ko kp jx kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">我想穿越所有16个联邦州的首府，并且从柏林开始，到柏林结束，每个城市只去一次。这样做的最短路线是什么？</p></blockquote><p id="d373" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这类问题被称为<strong class="kk iu">旅行推销员问题(TSP) </strong>。顾名思义，旅行推销员会挨家挨户，或在一个特定的地域内挨家挨户地推销自己公司的产品或服务。TSP处理寻找恰好一次覆盖所有点的最短路线，因为这将是在成本、时间和能量方面最有效的路线。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ll"><img src="../Images/1405b805d93eb486630c3ff54c344ddc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6niLOHj5kkP4Jl3PUG-fEQ.jpeg"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">图片由<a class="ae mb" href="https://unsplash.com/@joincapture" rel="noopener ugc nofollow" target="_blank">安德鲁·怀斯</a>在<a class="ae mb" href="http://www.unsplash.com" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="3e85" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">TSP是一个NP难问题</h1><p id="1a56" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">决策问题是一个有“是”或“否”答案的问题。可能有不同的复杂度等级来解决它。比如:</p><ul class=""><li id="ead5" class="ng nh it kk b kl km ko kp kr ni kv nj kz nk ld nl nm nn no bi translated">P 是一个复杂类，其中决策问题可以通过确定性图灵机(DTM)在多项式时间内解决。对于某个非负整数<em class="lh"> k </em>，多项式时间算法的执行时间为<em class="lh"> O(nᵏ) </em>级，其中<em class="lh"> n </em>是输入的复杂度。</li></ul><p id="4e4e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以用多项式时间算法解决的问题称为易处理问题。这种算法的例子有线性搜索<em class="lh"> (O(n)) </em>、二分搜索法<em class="lh"> (O(log n)) </em>、插入排序<em class="lh"> (O(n )) </em>、合并排序<em class="lh"> (O(n log n)) </em>和矩阵乘法<em class="lh"> (O(n )) </em> (Bari，2018和Maru，2020)。</p><ul class=""><li id="69d7" class="ng nh it kk b kl km ko kp kr ni kv nj kz nk ld nl nm nn no bi translated"><strong class="kk iu"> NP </strong>(非确定性多项式时间)是指一组可以用非确定性图灵机(NTM)在多项式时间内解决的决策问题。一个NTM可以有一组动作来解决问题，但是每次执行的转换都是不确定的(随机的)。一旦为NP问题提供了潜在的解决方案，DTM可以在多项式时间内验证其正确性(Viswarupan，2016)。</li></ul><p id="025b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个算法，今天是非确定性的，如果明天有人找到它的解，它也可以是确定性的(Bari，2018和Maru，2020)。这意味着DTM在多项式时间内可以解决的问题也可以由NTM在多项式时间内解决。因此，<strong class="kk iu"> P是NP </strong>的子集。</p><ul class=""><li id="0648" class="ng nh it kk b kl km ko kp kr ni kv nj kz nk ld nl nm nn no bi translated"><strong class="kk iu"> NP-hard </strong>是“至少和NP中最难的问题一样难”的决策问题的复杂性类别。一个问题<em class="lh"> H </em>是<strong class="kk iu"> NP-hard </strong>当NP中的每一个问题<em class="lh"> L </em>都可以在多项式时间内<a class="ae mb" href="https://www.cs.umd.edu/class/fall2017/cmsc451-0101/Lects/lect19-np-reduc.pdf" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">约化</strong> </a>为<em class="lh">H</em>；即假设求解<em class="lh"> H </em>需要1个单位时间，那么<em class="lh"> H </em>的解可以用来在多项式时间内求解<em class="lh"> L </em>。<em class="lh"> H </em>和<em class="lh"> L </em>(是或否)的解法也必须相同。</li></ul><p id="8763" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TSP是一个NP难问题。这意味着，如果有大量的城市，在“合理”的时间内评估每个可能的解决方案是不可行的(Hayes，2019)。</p><h1 id="4197" class="mj mk it bd ml mm np mo mp mq nq ms mt jz nr ka mv kc ns kd mx kf nt kg mz na bi translated">哈密尔顿/哈密尔顿循环</h1><p id="e53c" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">要解决旅行商问题(TSP)，首先需要理解哈密尔顿圈(也称为哈密尔顿圈)的概念。一个<strong class="kk iu">哈密尔顿循环</strong>是一个图循环(闭环)，它通过一个图恰好访问每个节点一次(Mathworld，2022a)。这是以威廉·罗恩·汉密尔顿爵士的名字命名的，他通过一个叫做哈密尔顿难题的游戏引入了这个概念。</p><p id="6fde" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在具有<code class="fe nu nv nw nx b">n</code>个节点的图中，如果我们将顺时针和逆时针路径视为两条不同的路径，则可能的哈密尔顿圈的总数由<code class="fe nu nv nw nx b">(n-1)!</code>给出。如果我们认为顺时针和逆时针路径相同，就有<code class="fe nu nv nw nx b">(n-1)!/2</code>可能的哈密顿圈。</p><p id="6b84" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们以四个城市为例:柏林、杜塞尔多夫、汉堡和慕尼黑。我的目标是穿越这四个城市，起点和终点都在柏林，同时正好经过这四个城市之间的一次。本例中可能的唯一路径(哈密尔顿圈)的数量由(4–1)给出！= 3!= 6.</p><p id="0f37" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的代码中，<code class="fe nu nv nw nx b">cities</code>是这四个城市的列表，但是<code class="fe nu nv nw nx b">start</code>和<code class="fe nu nv nw nx b">end</code>是柏林。其他三个城市定义为<code class="fe nu nv nw nx b">*rest</code>。这三个城市的排列一次占据所有三个城市，导致所有可能的汉密尔顿循环。这显示在下面的Python代码中。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ny"><img src="../Images/6e6da5988c28205e8b0203043de64fac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*COzgeSvb--YOD2KwBMeZjA.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">Python代码生成除柏林之外的三个城市的排列，一次取全部三个。图片作者。</p></figure><p id="daaf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的要点中，<code class="fe nu nv nw nx b">make_tsp_tree</code>函数首先创建一个Hamilton路径列表，然后从这些路径列表中创建一个有向前缀树，然后通过删除根节点和nil节点返回graph对象<code class="fe nu nv nw nx b">G</code>。使用Graphviz的<a class="ae mb" href="https://graphviz.org/docs/layouts/dot/" rel="noopener ugc nofollow" target="_blank">点布局</a>设置<code class="fe nu nv nw nx b">G</code>中每个节点的位置，Graphviz在有向图中设置层次结构。</p><figure class="lm ln lo lp gt lq"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="45a7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这四个城市列表的哈密尔顿路径如下图所示:</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ob"><img src="../Images/c2bd9a05df9b3278277df78e143aa057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lZSw5JFxiw9VerwDby8INQ.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">示例中四个城市的汉密尔顿路径。图片作者。</p></figure><h1 id="79a6" class="mj mk it bd ml mm np mo mp mq nq ms mt jz nr ka mv kc ns kd mx kf nt kg mz na bi translated">在德国地图上对16个州的首府进行地理编码和绘图</h1><p id="15e2" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">我把德国16个州首府的列表定义为<code class="fe nu nv nw nx b">capitals</code>。使用一个叫做地理编码的过程，我可以得到所有16个城市的<code class="fe nu nv nw nx b">coordinates</code>。在这个<a class="ae mb" href="https://medium.com/towards-data-science/network-and-interconnection-in-python-maps-6c797580b3b1" rel="noopener">故事</a>中详细描述了使用geopy包进行地理编码的过程。</p><pre class="lm ln lo lp gt oc nx od oe aw of bi"><span id="374a" class="og mk it nx b gy oh oi l oj ok">capitals = [‘Berlin’, ‘Bremen’, ‘Dresden’, ‘Dusseldorf’,<br/>            ‘Erfurt’, ‘Hamburg’, ‘Hannover’, ‘Kiel’,<br/>            ‘Magdeburg’, ‘Mainz’, ‘Munich’, ‘Potsdam’,   ‘Saarbrucken’, ‘Schwerin’, ‘Stuttgart’, ‘Wiesbaden’]</span></pre><p id="a280" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用GeoPandas包，我在名为<code class="fe nu nv nw nx b">germany</code>的地理数据框架中提取德国地图。为了绘制<code class="fe nu nv nw nx b">germany</code>中的<code class="fe nu nv nw nx b">capitals</code>，首先我使用NetworkX创建一个图形对象<code class="fe nu nv nw nx b">G</code>。然后我创建16个节点，每个城市一个。接下来，我为<code class="fe nu nv nw nx b">positions</code>创建一个每个城市的节点和坐标的字典。我为<code class="fe nu nv nw nx b">labels</code>创建了另一个节点和首都名称的字典。下面的截图给出了代码和生成的地图。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ol"><img src="../Images/1a197e3412a2ccaf344c904b259fc88d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0j-UH1oD8rk3tUFrvp0i0w.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">使用GeoPandas和NetworkX在德国地图上绘制16个联邦州的首府。图片作者。</p></figure><h1 id="ba73" class="mj mk it bd ml mm np mo mp mq nq ms mt jz nr ka mv kc ns kd mx kf nt kg mz na bi translated">德国任何两个首都之间所有可能的路径</h1><p id="0025" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">下一步是确定和绘制德国任何两个城市之间所有可能的路径。由于我们的列表中有16个城市，因此任意两个城市之间的可能路径数为ⁿCᵣ = ⁶C₂ = 120。在现有的图形对象<code class="fe nu nv nw nx b">G</code>中，我添加了任意两个节点之间的边，除了它本身，如下所示:</p><pre class="lm ln lo lp gt oc nx od oe aw of bi"><span id="888b" class="og mk it nx b gy oh oi l oj ok">for i in nodes:<br/>     for j in nodes:<br/>          if i!=j:<br/>               G.add_edge(i, j)</span></pre><p id="7ee1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用带有最近添加的边的<code class="fe nu nv nw nx b">germany</code>绘制更新的图形对象<code class="fe nu nv nw nx b">G</code>,如下所示:</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi om"><img src="../Images/6de4983de62ff7d2cab48d1d866d03a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K_Tm40re2buDr_jXeEOqUA.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">所有可能的路径(120)由德国16个联邦州中任意两个城市之间的蓝色边缘表示。图片作者。</p></figure><p id="72a2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我创建了<code class="fe nu nv nw nx b">H</code>作为<code class="fe nu nv nw nx b">G</code>的备份供以后使用。</p><p id="0b37" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我计算德国所有两个城市之间的欧几里德距离，这些信息作为边的权重存储在<code class="fe nu nv nw nx b">G</code>中。因此，<code class="fe nu nv nw nx b">G</code>现在是一个<strong class="kk iu">完全加权图</strong>，其中一条边连接每对图节点，并且每条边都具有与之相关联的权重。</p><pre class="lm ln lo lp gt oc nx od oe aw of bi"><span id="dfd3" class="og mk it nx b gy oh oi l oj ok">H <strong class="nx iu">=</strong> G<strong class="nx iu">.</strong>copy()<br/><br/><em class="lh">#Calculating the distances between the nodes as edge's weight.</em><br/><strong class="nx iu">for</strong> i <strong class="nx iu">in</strong> range(len(pos)):<br/>     <strong class="nx iu">for</strong> j <strong class="nx iu">in</strong> range(i <strong class="nx iu">+</strong> 1, len(pos)):<br/><br/>        <em class="lh">#Multidimensional Euclidean distan<br/>          </em>dist <strong class="nx iu">=</strong> math<strong class="nx iu">.</strong>hypot(pos[i][0] <strong class="nx iu">-</strong> pos[j][0], pos[i][1] <strong class="nx iu">-</strong> pos[j][1])<br/>          dist <strong class="nx iu">=</strong> dist<br/>          G<strong class="nx iu">.</strong>add_edge(i, j, weight<strong class="nx iu">=</strong>dist)<br/></span></pre><p id="e7d2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">城市之间的距离可以在下表中以矩阵形式观察到。在下表中，在主对角线上观察到的城市之间的距离为零。主对角线上方的所有条目都反映在对角线下方的相等条目中。因此，它是一个<strong class="kk iu">中空(零对角线)对称矩阵</strong>的例子。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi on"><img src="../Images/fc9f9a1e3616ebf883861952b457c514.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ntpo37AuOxdrnodh_f035Q.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">德国16个联邦州首府之间的距离矩阵。图片作者。</p></figure><h1 id="3f8c" class="mj mk it bd ml mm np mo mp mq nq ms mt jz nr ka mv kc ns kd mx kf nt kg mz na bi translated">求解TSP的算法</h1><p id="7170" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">为了找到解决方案<code class="fe nu nv nw nx b">cycle</code>，NetworkX对无向图<strong class="kk iu">、</strong>使用默认算法<strong class="kk iu"> Christofides算法</strong>，作为解决方案<code class="fe nu nv nw nx b">cycle</code>一部分的边列表存储为<code class="fe nu nv nw nx b">edge_list</code>。这在下面的代码中实现:</p><pre class="lm ln lo lp gt oc nx od oe aw of bi"><span id="207f" class="og mk it nx b gy oh oi l oj ok">cycle <strong class="nx iu">=</strong> nx_app<strong class="nx iu">.</strong>christofides(G, weight<strong class="nx iu">=</strong>"weight")<br/>edge_list <strong class="nx iu">=</strong> list(nx<strong class="nx iu">.</strong>utils<strong class="nx iu">.</strong>pairwise(cycle))</span></pre><h2 id="7f25" class="og mk it bd ml oo op dn mp oq or dp mt kr os ot mv kv ou ov mx kz ow ox mz oy bi translated">克里斯托菲迪斯算法</h2><p id="8252" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">Christofides算法在距离形成一个<a class="ae mb" href="https://www.britannica.com/science/metric-space" rel="noopener ugc nofollow" target="_blank">度量空间</a>的情况下找到TSP的近似解(它们是对称的，并且遵守三角形不等式，即在ABC中，a+b≥c ) (Goodrich和Tamassia，2014)。这种算法是以塞浦路斯数学家尼科斯·克里斯托菲德斯的名字命名的，他在1976年发明了这种算法。到目前为止，该算法提供了解决TSP的最佳近似比(克里斯托菲德斯，2022)。</p><p id="d941" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面给出了该算法的基本步骤。这些步骤已经在NetworkX <a class="ae mb" href="https://networkx.org/documentation/stable/_modules/networkx/algorithms/approximation/traveling_salesman.html#christofides" rel="noopener ugc nofollow" target="_blank">这里</a>的源代码中实现。我还说明了我们的问题的算法逐步实施。</p><ol class=""><li id="2312" class="ng nh it kk b kl km ko kp kr ni kv nj kz nk ld oz nm nn no bi translated"><strong class="kk iu">求<em class="lh"> G </em>的最小(重量)生成树<em class="lh"> T </em>。</strong></li></ol><p id="89d3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">加权、连通、无向图的最小生成树(此处为<code class="fe nu nv nw nx b">G</code>)是由连接所有连通节点(此处为16个)的边的子集组成的图，同时最小化边上权重的总和。</p><p id="02b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">NetworkX使用一个<a class="ae mb" href="https://www.programiz.com/dsa/kruskal-algorithm#:~:text=Kruskal%27s%20algorithm%20is%20a%20minimum,be%20formed%20from%20the%20graph" rel="noopener ugc nofollow" target="_blank"> Kruskal算法</a>来寻找最小生成树(NetworkX，2015)。对于德国及其16个联邦州的首都来说，情况如下:</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi pa"><img src="../Images/7ed3c410fe35ba90111042a1ad3a4fa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gXrL9P_lRXBOPdukZxielQ.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">最小生成树(<em class="pb"> T) </em>为德。图片作者。</p></figure><p id="1a5a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 2。在<em class="lh"> T </em>中做一组奇数度<em class="lh"> O </em>的节点。</strong></p><p id="ac7e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下一步中，创建一组名为<em class="lh"> O </em>的节点，其中每个节点的度数都是奇数。从上面的树中，我们看到柏林、波茨坦、斯图加特和施韦林的度都是2，即偶数。因此，这些节点在新的集合<em class="lh"> O </em>中被移除，如下所示:</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi pc"><img src="../Images/40d68457a4b5b1eff2fdcd66cc61fbb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nzYhiXfQRs-R4gWfVoSvQg.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">T中奇数度(O)的节点集。图片作者。</p></figure><p id="beec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 3。从<em class="lh"> O </em>的顶点给出的诱导子图中找到一个</strong> <a class="ae mb" href="https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.matching.min_weight_matching.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">最小权完美匹配</strong> </a> <strong class="kk iu"> <em class="lh"> M </em>。</strong></p><p id="effd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了有一个<strong class="kk iu">完美匹配</strong>，在一个图中需要有<strong class="kk iu"> </strong>个偶数个节点，并且每个节点恰好与另一个节点相连。因此，完美匹配是包含n/2条边的匹配(最大可能)(Mathworld，2022b)。</p><p id="4cc0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最小权重完美匹配<em class="lh"> M </em>计算完美匹配，使匹配边的权重最小化，如下图所示。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi pd"><img src="../Images/d41657957f77cce8d926f424ec2e0079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*khYxIzQsexhb8mKZQGSftw.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">由O. Image的顶点给出的诱导子图中的最小权完美匹配(M)。</p></figure><p id="c673" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 4。将<em class="lh"> M </em>和<em class="lh"> T </em>的边缘组合在一起，形成一个相连的多联图<em class="lh"> H </em>。</strong></p><p id="48f1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下一步中，该算法将步骤1中的<em class="lh">T</em><em class="lh"/>的边与步骤3中的<em class="lh"> M </em>的边组合起来，以形成连通的多图<em class="lh"> H </em>。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi pe"><img src="../Images/07b400a02d55dc4f20f3384e075920f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NlOEOlK-WYCYWhMjyyViHA.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">步骤1中T的边和步骤3中M的边的联合产生作者的H. Image。</p></figure><p id="d8f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 5。用M和t的边建立一个欧拉电路</strong></p><p id="28b8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一步，Christofides算法使用<em class="lh"> M </em>和<em class="lh"> T </em>的边缘构建欧拉电路。欧拉回路是有限图中恰好访问每条边一次的轨迹。欧拉电路中的每个节点都必须有偶数度(麻省理工开放式课程，2016)。哈密尔顿圈和欧拉圈的区别在于，哈密尔顿圈恰好经过每个节点一次，结束于初始节点，而欧拉圈恰好经过每个边一次，结束于初始节点。</p><p id="93b5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注:一个循环可以是汉密尔顿循环，也可以是欧拉循环。</p><p id="4b97" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 6。通过跳过重复的节点，将欧拉循环转换为哈密尔顿循环。</strong></p><p id="b315" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的TSP的例子中，在欧拉电路中可能有一些重复的节点。这种节点的度大于2，即该节点被访问了不止一次。Christofides算法利用一个<strong class="kk iu">快捷</strong>函数从欧拉电路中移除重复节点，并创建一个<code class="fe nu nv nw nx b">cycle</code>。因此，TSP的解决方案是通过使用<code class="fe nu nv nw nx b">cycle</code>中节点之间的连续边列表来实现的。</p><p id="76a6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Christofides算法产生的解的权重在最优值的3/2以内(麻省理工学院开放课件，2016)。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi pf"><img src="../Images/4892ff0b16a00eaafc26fec4c7e7ace9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NwAGIGZMmJbaaTZ0tz9ynw.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">德国TSP解决方案。图片作者。</p></figure><h1 id="b03d" class="mj mk it bd ml mm np mo mp mq nq ms mt jz nr ka mv kc ns kd mx kf nt kg mz na bi translated">使用NetworkX直接实施TSP解决方案</h1><p id="282f" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">使用如上所述的克里斯托菲迪斯算法，TSP的解由<code class="fe nu nv nw nx b">cycle</code>给出。由于<code class="fe nu nv nw nx b">cycle</code>只包含了<code class="fe nu nv nw nx b">capitals</code>城市的指数，我得到了表示城市顺序为<code class="fe nu nv nw nx b">tsp_cycle</code>的求解路线，如下图所示。</p><p id="a3e4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如下面截图中的[17]所示，我在德国地图上用蓝线标出了任意两个城市之间所有可能的路径。红线代表<code class="fe nu nv nw nx b">edge_list</code>，它包含城市之间的边列表，这些边是解决方案<code class="fe nu nv nw nx b">cycle</code>的一部分。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi pg"><img src="../Images/99d06cf5a2dcb3a1b78b8e3cd035a01c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HEZZh1ZN4ViMIoT4_D0rmg.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">获得针对德国的TSP的解决方案路线，并将其绘制在德国地图上。图片作者。</p></figure><p id="730e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下图通过移除两个城市之间的蓝色(所有可能的)边，仅用红色绘制德国TSP的解决方案，提供了一个更清晰的解决方案。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ph"><img src="../Images/26ccd04e4f0a40332caf3dc40c1ae2b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NJEshcz7pqTwJ4zwO4oBlA.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">德国TSP的解决方案路线，用红边表示。图片作者。</p></figure><h2 id="50f6" class="og mk it bd ml oo op dn mp oq or dp mt kr os ot mv kv ou ov mx kz ow ox mz oy bi translated">用独特的颜色为每条边绘制解决方案</h2><p id="2e93" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">我想让我的解决方案更吸引人一点，为城市之间的每条边绘制一种独特的颜色。</p><p id="307a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">计算机显示器上使用的任何颜色都可以表示为可见光谱中RGB(红、绿、蓝)的比例(Mathisfun，2021)。因此，在Python中，任何颜色都可以表示为#RRGGBB，其中RR、GG和BB具有从00到ff的十六进制值。#000000代表白色，而#ffffff代表黑色。</p><p id="6581" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我创建一个名为<code class="fe nu nv nw nx b">get_colors(n)</code>的函数，根据十六进制的#RRGGBB的随机值创建一个随机颜色列表。</p><pre class="lm ln lo lp gt oc nx od oe aw of bi"><span id="e5ca" class="og mk it nx b gy oh oi l oj ok">import random<br/>get_colors = lambda n: list(map(lambda i: “#” +”%06x” % random.randint(0, 0xffffff),range(n)))</span></pre><p id="9227" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的代码中，我将<code class="fe nu nv nw nx b">get_colors(16)</code>作为<code class="fe nu nv nw nx b">edge_color</code>进行传递。</p><pre class="lm ln lo lp gt oc nx od oe aw of bi"><span id="c35e" class="og mk it nx b gy oh oi l oj ok">fig, ax = plt.subplots(figsize = (20, 12))</span><span id="34b8" class="og mk it nx b gy pi oi l oj ok">germany.plot(ax = ax, color = “whitesmoke”, edgecolor = “black”)</span><span id="6e5b" class="og mk it nx b gy pi oi l oj ok"># Draw the route<br/>nx.draw_networkx(G, pos = positions, labels = labels, <br/> edgelist=edge_list, edge_color=get_colors(16), width=3,<br/> node_color = “snow”, node_shape = “s”, node_size = 300,<br/> bbox = dict(facecolor = “#ffffff”, boxstyle = “round”,ec = “silver”),<br/> ax = ax)</span><span id="2226" class="og mk it nx b gy pi oi l oj ok">plt.title(“Travelling Salesman Problem Solution for Germany”, fontsize = 15)<br/>plt.axis(“off”)</span></pre><p id="94e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结果，我得到了下面的图，这是丰富多彩的，比前面的更有吸引力，解决方案中的每个边都有独特的颜色。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi pj"><img src="../Images/1bf91f223eb91707054aed72f20cba1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F5T0f9mnxo_2XV_j-m2rrA.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">适用于德国的TSP解决方案，每条边都有独特的颜色。图片作者。</p></figure><h2 id="43bd" class="og mk it bd ml oo op dn mp oq or dp mt kr os ot mv kv ou ov mx kz ow ox mz oy bi translated">使用叶子绘制解决方案</h2><p id="06df" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">也可以使用<a class="ae mb" href="https://python-visualization.github.io/folium/" rel="noopener ugc nofollow" target="_blank">叶</a>包在交互式传单地图中绘制上面的图。</p><p id="0413" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我将<code class="fe nu nv nw nx b">coordinates</code>修改为<code class="fe nu nv nw nx b">folium_coordinates</code>，将<code class="fe nu nv nw nx b">cycle</code>修改为<code class="fe nu nv nw nx b">route</code>。这些都是相同的数据，但是采用了新的格式:一个GPS坐标列表(纬度和经度)的列表，与folium兼容。</p><p id="5db4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我在北纬51度、东经10度的位置创建了一张地图<code class="fe nu nv nw nx b">m1</code>，这是德国的大概坐标。我选择OpenStreetMap图块和6点的<code class="fe nu nv nw nx b">zoom_start</code>。我在地图上每个城市的坐标处添加一个标记。最后，我使用反映TSP解决方案的<code class="fe nu nv nw nx b">route</code>在地图上绘制折线覆盖图。</p><figure class="lm ln lo lp gt lq"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="d1ea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">生成的图显示在交互式传单地图中:</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi pk"><img src="../Images/ab8fa189bc36545ae3e83e18e7b95c4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Opa91qlYGKS6OuwSNLiyBg.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">德国TSP的解决方案路线使用lyus绘制。为每个城市添加标记，并在地图上绘制解决方案路线。图片作者。</p></figure><h1 id="7c8b" class="mj mk it bd ml mm np mo mp mq nq ms mt jz nr ka mv kc ns kd mx kf nt kg mz na bi translated">结论</h1><p id="5203" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">这篇文章的问题陈述是寻找最短的路线穿越德国16个联邦州的首都城市，从柏林开始，到柏林结束，同时访问中间的每个城市一次。我首先描述了解决任何决策问题的不同复杂性类别:P(多项式时间)、NP(非确定性多项式时间)和NP-hard。接下来，我讨论了哈密尔顿循环的概念。</p><p id="c0fc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我使用地理编码找到了德国16个联邦州的首府城市的坐标，并使用GeoPandas包将它们绘制在德国地图上。我添加了地图上任意两个城市之间的所有边。接下来，我演示了Christofides算法如何通过它的逐步实现为旅行推销员问题提供解决方案。最后，我使用NetworkX、GeoPandas和Matplotlib包为这个问题绘制了一个清晰的解决方案。我还用独特的颜色绘制了每个边缘的解决方案，并使用follow包绘制了活页包装中的解决方案。</p><p id="6851" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个故事中的分析实现可以在这个<a class="ae mb" href="https://github.com/hbshrestha/Geospatial-Analysis" rel="noopener ugc nofollow" target="_blank"> GitHub存储库</a>中获得。如果你想进一步了解Python图形可视化的基础知识，你可以参考下面的故事和本系列的其他相关故事。</p><div class="pl pm gp gr pn po"><a rel="noopener follow" target="_blank" href="/graph-visualisation-basics-with-python-part-ii-directed-graph-with-networkx-5c1cd5564daa"><div class="pp ab fo"><div class="pq ab pr cl cj ps"><h2 class="bd iu gy z fp pt fr fs pu fu fw is bi translated">Python图形可视化基础第二部分:NetworkX有向图</h2><div class="pv l"><h3 class="bd b gy z fp pt fr fs pu fu fw dk translated">用NetworkX软件包创建有向无环图</h3></div><div class="pw l"><p class="bd b dl z fp pt fr fs pu fu fw dk translated">towardsdatascience.com</p></div></div><div class="px l"><div class="py l pz qa qb px qc lv po"/></div></div></a></div><p id="2174" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读！</p><h1 id="54f0" class="mj mk it bd ml mm np mo mp mq nq ms mt jz nr ka mv kc ns kd mx kf nt kg mz na bi translated">参考</h1><p id="b28a" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">巴里，2018。<a class="ae mb" href="https://www.youtube.com/watch?v=e2cF8a5aAhE" rel="noopener ugc nofollow" target="_blank"> NP难和NP完全问题</a>。</p><p id="37b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">克里斯托菲德斯，2022年。<a class="ae mb" href="https://link.springer.com/article/10.1007/s43069-021-00101-z" rel="noopener ugc nofollow" target="_blank">旅行商问题新启发式算法的最坏情况分析</a>。</p><p id="92c2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">古德里奇和塔玛西亚，2014年。<a class="ae mb" href="https://www.wiley.com/en-us/Algorithm+Design+and+Applications-p-9781118335918" rel="noopener ugc nofollow" target="_blank">算法设计与应用| Wiley </a></p><p id="0082" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">海耶斯，2019。<a class="ae mb" rel="noopener" target="_blank" href="/solving-travelling-salesperson-problems-with-python-5de7e883d847">用Python解决旅行推销员问题。</a></p><p id="189c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">丸，2020。<a class="ae mb" href="https://www.youtube.com/watch?v=ivkQBh74SNo" rel="noopener ugc nofollow" target="_blank"> P，NP，NP难和NP完全问题|归约| NP难和NP难|多项式类</a>。</p><p id="6033" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">马图塞克，1996年。<a class="ae mb" href="https://www.seas.upenn.edu/~cit596/notes/dave/p-and-np2.html#:~:text=A%20polynomial%2Dtime%20algorithm%20is,algorithm%20are%20called%20tractable%20problems." rel="noopener ugc nofollow" target="_blank">多项式时间算法。</a></p><p id="4fa5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Mathisfun.com，2021年。<a class="ae mb" href="https://www.mathsisfun.com/hexadecimal-decimal-colors.html#:~:text=Hexadecimals&amp;text=So%20one%20hexadecimal%20digit%20can,256%20different%20levels%20of%20color" rel="noopener ugc nofollow" target="_blank">十六进制颜色。</a></p><p id="4b04" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数学世界，2022a。<a class="ae mb" href="https://mathworld.wolfram.com/HamiltonianCycle.html#:~:text=A%20Hamiltonian%20cycle%2C%20also%20called,to%20be%20a%20Hamiltonian%20graph." rel="noopener ugc nofollow" target="_blank">哈密顿循环</a>。</p><p id="b96a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数学世界，2022b。<a class="ae mb" href="https://mathworld.wolfram.com/PerfectMatching.html" rel="noopener ugc nofollow" target="_blank">完美搭配。</a></p><p id="379f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">麻省理工学院开放式课程，2016。<a class="ae mb" href="https://www.youtube.com/watch?v=zM5MW5NKZJg&amp;t=1098s" rel="noopener ugc nofollow" target="_blank"> R9。近似算法:旅行推销员问题</a></p><p id="c0ad" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">NetworkX，2015。<a class="ae mb" href="https://networkx.org/documentation/networkx-1.10/reference/generated/networkx.algorithms.mst.minimum_spanning_tree.html" rel="noopener ugc nofollow" target="_blank">最小生成树。</a></p><p id="3274" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Tutorialspoint，2022。<a class="ae mb" href="https://www.tutorialspoint.com/automata_theory/non_deterministic_turing_machine.htm#" rel="noopener ugc nofollow" target="_blank">非确定性图灵机</a>。</p><p id="e77a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">维斯瓦鲁潘，2016。<a class="ae mb" href="https://niruhan.medium.com/p-vs-np-problem-8d2b6fc2b697" rel="noopener"> P vs NP问题</a>。</p></div></div>    
</body>
</html>