<html>
<head>
<title>An easy way to understand GIT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解GIT的简单方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/an-easy-way-to-understand-git-80717c4b98e9#2022-11-04">https://towardsdatascience.com/an-easy-way-to-understand-git-80717c4b98e9#2022-11-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ae30" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">中间git命令及其含义解释</h2></div><p id="accf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">和许多程序员一样，我一直在使用GIT对我的工作库进行版本控制，我想回顾一下最常用的命令及其逻辑，以便有更深入的理解。这是我在一些在线教程和课程后收集的，我想和你分享一下！</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi le"><img src="../Images/e7cc679259b9a725edaee6c700bb5d7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*PvTWv63iEKJM1oMDYRYDSg.jpeg"/></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">图片来自unsplash.com</p></figure><ol class=""><li id="2f8c" class="lq lr it kk b kl km ko kp kr ls kv lt kz lu ld lv lw lx ly bi translated">创建新分支</li></ol><ul class=""><li id="8331" class="lq lr it kk b kl km ko kp kr ls kv lt kz lu ld lz lw lx ly bi translated"><code class="fe ma mb mc md b">git branch new_branch_name<br/> git checkout new_branch_name</code>(或<code class="fe ma mb mc md b">git switch new_branch_name</code>)或</li><li id="450b" class="lq lr it kk b kl me ko mf kr mg kv mh kz mi ld lz lw lx ly bi translated"><code class="fe ma mb mc md b">git checkout -b new_branch_name </code>或</li><li id="519d" class="lq lr it kk b kl me ko mf kr mg kv mh kz mi ld lz lw lx ly bi translated"><code class="fe ma mb mc md b">git switch -c new_branch_name</code></li></ul><p id="b5f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2.用旧的提交创建一个新的分支，从那里继续工作</p><pre class="lf lg lh li gt mj md mk ml aw mm bi"><span id="b6bd" class="mn mo it md b gy mp mq l mr ms">git log  (to check the commit id)<br/>git checkout id (to pass related commit)<br/>git checkout -b new_branch_name commit_id (create a new branch with that commit) </span></pre><p id="58f4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">3.舞台机制</p><p id="ea3e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您已经暂存了一些文件(在您的跟踪区域中)，并且您在这些文件中有一些未暂存的更改，您想要删除这些更改。</p><ul class=""><li id="2b62" class="lq lr it kk b kl km ko kp kr ls kv lt kz lu ld lz lw lx ly bi translated"><code class="fe ma mb mc md b">git restore filename</code>或</li><li id="cceb" class="lq lr it kk b kl me ko mf kr mg kv mh kz mi ld lz lw lx ly bi translated"><code class="fe ma mb mc md b">git checkout filename</code>删除特定文件中的修改</li></ul><p id="773f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">和</p><ul class=""><li id="bade" class="lq lr it kk b kl km ko kp kr ls kv lt kz lu ld lz lw lx ly bi translated"><code class="fe ma mb mc md b">git restore .</code>或者</li><li id="f8c5" class="lq lr it kk b kl me ko mf kr mg kv mh kz mi ld lz lw lx ly bi translated"><code class="fe ma mb mc md b">git checkout .</code>删除这种情况下的所有修改。</li></ul><p id="d193" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您有未暂存的文件，并且您想从添加这些文件的地方返回</p><ul class=""><li id="c9ff" class="lq lr it kk b kl km ko kp kr ls kv lt kz lu ld lz lw lx ly bi translated"><code class="fe ma mb mc md b">git clean -dn (to check which files you are going to delete)<br/>git clean -df (to delete these files)</code></li></ul><p id="a48a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您想取消转移一些已经转移的文件，告诉git不要跟踪它们</p><ul class=""><li id="68a5" class="lq lr it kk b kl km ko kp kr ls kv lt kz lu ld lz lw lx ly bi translated"><code class="fe ma mb mc md b">git restore --staged filename</code>或<code class="fe ma mb mc md b">git reset filename</code></li></ul><p id="7b4a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">检查哪些文件在您的暂存区域中</p><ul class=""><li id="c4cb" class="lq lr it kk b kl km ko kp kr ls kv lt kz lu ld lz lw lx ly bi translated"><code class="fe ma mb mc md b">git ls-files</code></li></ul><p id="208e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">4.删除提交</p><ul class=""><li id="bb23" class="lq lr it kk b kl km ko kp kr ls kv lt kz lu ld lz lw lx ly bi translated"><code class="fe ma mb mc md b">git reset HEAD~n</code>或<br/> <code class="fe ma mb mc md b">git reset --SOFT HEAD~n</code>返回n次提交(删除n次提交)，不删除变更</li><li id="9e02" class="lq lr it kk b kl me ko mf kr mg kv mh kz mi ld lz lw lx ly bi translated"><code class="fe ma mb mc md b">git reset --HARD HEAD~n</code>通过从您的工作存储库中删除变更来删除n个提交。</li></ul><p id="ba6f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">5.隐藏机制</p><p id="c51f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您已经进行了一些更改，但是没有提交，因为它还没有准备好提交。你想要改变你的分支，但是你不希望这些阶段性的改变进入你刚刚传递到的分支。您必须将这些更改保存在内存中，以免丢失，不会带到另一个分支，并且能够在需要时保留它们。</p><ul class=""><li id="26b6" class="lq lr it kk b kl km ko kp kr ls kv lt kz lu ld lz lw lx ly bi translated"><code class="fe ma mb mc md b">git stash</code>把它们保存在记忆中，让它们暂时消失</li><li id="5247" class="lq lr it kk b kl me ko mf kr mg kv mh kz mi ld lz lw lx ly bi translated"><code class="fe ma mb mc md b">git stash apply</code>收回更改</li><li id="17cb" class="lq lr it kk b kl me ko mf kr mg kv mh kz mi ld lz lw lx ly bi translated"><code class="fe ma mb mc md b">git stash apply n</code>仅获取隐藏存储器中id n的变化</li><li id="1268" class="lq lr it kk b kl me ko mf kr mg kv mh kz mi ld lz lw lx ly bi translated"><code class="fe ma mb mc md b">git stash pop</code>取回更改并将其从存储存储器中删除(n参数也适用，如在apply中)</li><li id="7584" class="lq lr it kk b kl me ko mf kr mg kv mh kz mi ld lz lw lx ly bi translated"><code class="fe ma mb mc md b">git stash list</code>查看你的收藏区有什么</li><li id="1dd3" class="lq lr it kk b kl me ko mf kr mg kv mh kz mi ld lz lw lx ly bi translated"><code class="fe ma mb mc md b">git stash clear</code>删除你所有隐藏的记忆</li><li id="4590" class="lq lr it kk b kl me ko mf kr mg kv mh kz mi ld lz lw lx ly bi translated"><code class="fe ma mb mc md b">git stash drop n</code>删除id为n的stash(你可以用上面提到的“git stash list”命令检查id！！)</li></ul><p id="c8d1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">6.带来丢失的数据</p><p id="a013" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您希望恢复已删除的提交或分支:</p><ul class=""><li id="9341" class="lq lr it kk b kl km ko kp kr ls kv lt kz lu ld lz lw lx ly bi translated"><code class="fe ma mb mc md b">git reflog</code>查看过去30天内发生的所有事件及其哈希id。因此，与git log命令相比，这里我们不仅可以看到提交历史，还可以看到我们执行的每个步骤，如切换分支、转移、存储、删除提交或分支等。</li><li id="b1a2" class="lq lr it kk b kl me ko mf kr mg kv mh kz mi ld lz lw lx ly bi translated"><code class="fe ma mb mc md b">git reset --hard hash_id</code>恢复已删除的提交</li><li id="da42" class="lq lr it kk b kl me ko mf kr mg kv mh kz mi ld lz lw lx ly bi translated"><code class="fe ma mb mc md b">git checkout hash_id<br/>git checkout -b new_branch_name</code>恢复已删除的分支</li></ul><p id="7ffa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">7.合并类型</p><p id="84c5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">合并操作主要有两种类型:<strong class="kk iu">快进</strong>和<strong class="kk iu">非快进</strong>，分别有1和4种不同的应用方式。<strong class="kk iu"> </strong>在本教程中，对于非快进类别，我只提快进合并和递归合并。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/29256eb61982690672e66a6f5b435fc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*15u-WYkldtN9ILIJub_0Xg.png"/></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">合并类型—按作者排序的图像</p></figure><p id="ef8e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mu">快进:</em>在您为您的新特性创建了一个新的分支(姑且称之为特性分支)之后，您提交到这个分支，同时，主分支中没有任何改变。在这种情况下，合并过程非常容易应用，没有任何冲突，我们称这种情况为快进合并。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/e155b769fafd9ffd2a17a8ffa609e87e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*VVoRRqI5lfWkLTJxTwpO7g.png"/></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">快进合并结构—按作者排序的图像</p></figure><p id="632b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">快进并没有添加任何额外的提交来提到这个合并操作，它只是把提交从新分支放到主分支。</p><p id="5855" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了应用这种合并，</p><ul class=""><li id="ae39" class="lq lr it kk b kl km ko kp kr ls kv lt kz lu ld lz lw lx ly bi translated"><code class="fe ma mb mc md b">git checkout master<br/>git merge new_branch</code></li></ul><p id="91cc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，当您在主分支中检查您的提交历史时，您将看到来自特性分支的提交也被列出。</p><p id="ca7d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mu">递归非快进:</em>在你为你的新特性创建了一个新的分支(姑且称之为特性分支)之后，你向这个分支提交，同时，一些新的提交也在主分支中进行。在这种情况下，我们讨论的是非快进合并。当这两个分支合并时，提交按日期排序。与快进合并相反，在非快进情况下，进行合并操作的提交，并作为主分支的最后一次提交添加。</p><p id="8449" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">应用非快速前进合并的命令与快速前进合并相同，很明显快速前进合并是不可能的，并且会导致非快速前进合并。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/d690c34bc7ca4b344600ff3d05ad08be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*k2YNIVFIlZGKZ9Nf0U6A5A.png"/></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">递归非快进结构—作者图片</p></figure><p id="0c02" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在一个非快速向前的合并中，可能有一些<strong class="kk iu">冲突</strong>需要修复，因为在两个分支中都有一些变化。如果您在特征分支中更改了一个文件，同时在主分支中也更改了该文件，您必须决定接受哪个更改(或两个都接受)来解决冲突并完成合并。另一方面，如果在这两个分支中只更改了不同的文件，则在合并期间不会有冲突。</p><p id="2c69" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要修复合并，我建议您使用Visual Studio代码接口，因为它可以让您看到差异并更容易地决定做什么:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/f15470909dbed9656b990b0f7c6d072a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*mjDqyRrq02pS5L2esGdmOQ.png"/></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">Visual Studio合并冲突—按作者排序的图像</p></figure><p id="989f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">8.重置基础机制</p><p id="1164" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我提到过，在非快进合并中，由于在两个分支中进行了不同的提交，所以提交是按日期对齐的。例如，在上图中，不能确定master中的提交顺序是m1 → m2 → m3 → f1 → f2还是m1 → m2 → f1 → f2 → m3还是m1→m2→f1→m3→m3→F2。</p><p id="4112" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您希望按照主分支提交→功能分支提交的顺序排列这些提交，您可以使用rebase机制用主分支的最新版本来更改功能分支的基础，并在这个新基础之后添加功能分支提交。该过程还允许您应用快速合并，因为在这种重新组织的情况下，我们将所有在master中进行的提交放在feature分支中，这意味着当我们合并它们时，master中没有任何变化。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi my"><img src="../Images/b6777b4438c821b82df51838d3b70df1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*bwhq0s1IzXjTvOgB6j466Q.png"/></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">重置基础和快进合并结构—作者图片</p></figure><p id="f6d4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要应用于rebase，请执行以下操作:</p><pre class="lf lg lh li gt mj md mk ml aw mm bi"><span id="78b0" class="mn mo it md b gy mp mq l mr ms">git checkout feature<br/>git rebase master<!-- --> (rebase feature branch using the master branch)<br/>git checkout master<br/>git merge feature<!-- --> (merge the master branch with feature branch via fast forward) </span></pre><p id="6f19" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">9.樱桃采摘</p><p id="7aa9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有时，您可能希望挑选一些提交添加到主分支，而不是特性分支中的每个提交。在这种情况下，cherry-pick命令就是您要找的命令！</p><pre class="lf lg lh li gt mj md mk ml aw mm bi"><span id="3004" class="mn mo it md b gy mp mq l mr ms">git checkout feature<br/>git log<!-- --> (check the ids of commits you wanna apply to the master)<br/>git checkout master<br/>git cherry-pick commit_id</span></pre><p id="c646" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Cherry-pick操作只在您的主分支上添加1个提交，作为您挑选的提交的zip版本。</p><p id="dee7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本教程是关于重要的git命令及其逻辑的。不要忘记Git是用来控制你本地计算机上的工作流的，如果你想在云上运行这个库，并在这些本地云库之间进行通信，你必须在<a class="ae mz" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"> Github </a>上开一个账户。Git和GitHub之间的一些基本命令如下:</p><ul class=""><li id="30e7" class="lq lr it kk b kl km ko kp kr ls kv lt kz lu ld lz lw lx ly bi translated"><code class="fe ma mb mc md b">git remote add origin URL</code>将GitHub云存储库连接到您的本地工作存储库</li><li id="1cc2" class="lq lr it kk b kl me ko mf kr mg kv mh kz mi ld lz lw lx ly bi translated"><code class="fe ma mb mc md b">git push origin master</code>将文件从本地存储库加载到云中，如果不是第一次推送，则更新更改(合并)!</li></ul><p id="f035" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">基础词汇:</strong></p><ul class=""><li id="60f1" class="lq lr it kk b kl km ko kp kr ls kv lt kz lu ld lz lw lx ly bi translated"><em class="mu"> Staging </em>表示用下面的命令<br/> <code class="fe ma mb mc md b">git add filename (or) git add .</code>将变更添加到git跟踪区</li><li id="870f" class="lq lr it kk b kl me ko mf kr mg kv mh kz mi ld lz lw lx ly bi translated"><em class="mu">提交</em>意味着使用下面的命令<br/> <code class="fe ma mb mc md b">git commit -m "commit message"</code>将阶段性变更保存为项目的更新版本</li><li id="8ef7" class="lq lr it kk b kl me ko mf kr mg kv mh kz mi ld lz lw lx ly bi translated"><em class="mu">分支</em>表示从主目录创建的附加工作目录。主要目标是在不影响主存储库的情况下，在额外的分支上开发新特性，并在特性被测试并准备好实时使用时，通过将您的分支与您的主分支合并来添加这些新特性<em class="mu">。</em></li><li id="3b3a" class="lq lr it kk b kl me ko mf kr mg kv mh kz mi ld lz lw lx ly bi translated"><em class="mu">主分支</em>意味着默认的主分支附带了工作存储库的git初始化。Main是一些人喜欢使用的另一个常用名称，您可以使用<code class="fe ma mb mc md b">git branch -M branch_name</code>命令更改您的主分支名称</li></ul></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><p id="fbb1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您对本教程的兴趣，我希望它是有帮助的！在学习了Git命令及其用法之后，我建议您看一看<a class="ae mz" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>命令，以便更好地控制您在云和本地存储库之间的版本控制。熟悉GitHub总是一个好主意，因为在协作中，云存储库是最常见的方式，而不是本地方式。💥</p></div></div>    
</body>
</html>