<html>
<head>
<title>Side Effects Of Python Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python函数的副作用</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/side-effects-of-python-functions-822fae38295e#2022-08-27">https://towardsdatascience.com/side-effects-of-python-functions-822fae38295e#2022-08-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c866" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">什么时候一个函数改变了一个定义在它自己作用域之外的变量？</h2></div><p id="3939" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您是否想知道Python函数如何改变在其作用域之外定义的变量？这可能会让来自其他语言的开发人员感到困惑，但是一旦您理解了一些基本原则，预测副作用就很简单了。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/03e4e50403f8b67f3dd61cb48bcf7b01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qhO-VFYF3KxiDbyh"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">照片由<a class="ae lr" href="https://unsplash.com/@jannerboy62?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">在<a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的</a>刻痕拍摄</p></figure><p id="b188" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数副作用可能很难调试，而且大多数时候都不是有意的。相反，从函数中返回对象最好使用带有单个对象或元组的return语句。在Python中，副作用可能以两种方式出现:</p><ul class=""><li id="ea10" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la lx ly lz ma bi translated">改变可变对象的值</li><li id="749d" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">更改在本地命名空间之外定义的变量的绑定</li></ul><p id="861b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将通过一组例子来研究这些方面。在此之前，我们将重温Python如何向函数传递参数。</p><h1 id="54ac" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">在Python中向函数传递参数</h1><p id="5c02" class="pw-post-body-paragraph kf kg iq kh b ki my jr kk kl mz ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">如果您使用过其他编程语言，您可能听说过按值传递和按引用传递这两个术语。按值传递意味着将参数的副本传递给函数，而按引用传递意味着函数接收对参数的引用。您可能会惊讶地听到Python没有使用以上两者。当我开始使用Python时，我感到完全困惑，因为我认为只有两种选择，而Python函数显然都不适合。</p><p id="bc4d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在使用Python传递函数参数的机制之前，让我们快速回顾一下Python中的名称绑定。考虑以下代码:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6cb7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一条语句做了两件事。首先，它创建一个字符串对象，然后将这个对象绑定到变量<code class="fe nf ng nh ni b">a</code>。第二条语句将另一个变量<code class="fe nf ng nh ni b">b</code>绑定到绑定到<code class="fe nf ng nh ni b">a</code>的对象。第三条语句创建了另一个字符串对象并将变量<code class="fe nf ng nh ni b">b</code>重新绑定到它，而<code class="fe nf ng nh ni b">a</code>仍然绑定到字符串<code class="fe nf ng nh ni b">'hello'</code>。假设仍然有一个变量绑定到字符串<code class="fe nf ng nh ni b">'hello'</code>，它不会被垃圾收集。这看似琐碎，但要注意用词。我们没有使用诸如“将内存分配给一个字符串变量<code class="fe nf ng nh ni b">a</code>并将字符串<code class="fe nf ng nh ni b">'hello'</code>存储在其中”这样的表达式。相反，我们谈论创建对象并将变量绑定到它们。</p><p id="be63" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么可变对象呢，比如一个列表？以上同样适用于可变对象。然而，有一个警告。请看下面的代码:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3bf6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那会打印</p><pre class="lc ld le lf gt nj ni nk nl aw nm bi"><span id="5a8a" class="nn mh iq ni b gy no np l nq nr">a -&gt; 2199273128320 [10, 2, 3]<br/>b -&gt; 2199273128320 [10, 2, 3]</span></pre><p id="ea81" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">改变绑定到<code class="fe nf ng nh ni b">a</code>的列表中的一个元素也会改变<code class="fe nf ng nh ni b">b</code>。事实上，这种表达是有误导性的。只有一个列表，<code class="fe nf ng nh ni b">a</code>和<code class="fe nf ng nh ni b">b</code>都绑定到它，这可以从<code class="fe nf ng nh ni b">id()</code>函数返回的内存位置中看出。</p><p id="b35c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来让我们看一个函数:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="722e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这张照片</p><pre class="lc ld le lf gt nj ni nk nl aw nm bi"><span id="8fb3" class="nn mh iq ni b gy no np l nq nr">outside function x -&gt; 140731263354656, 5<br/>inside function x_f -&gt; 140731263354656, 5<br/>{'x_f': 5}<br/>inside function x_f -&gt; 140731263354816, 10<br/>{'x_f': 10}<br/>outside function x -&gt; 140731263354656, 5</span></pre><p id="ed3c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是怎么回事？在调用该函数之前，我们创建了一个整数对象并将变量<code class="fe nf ng nh ni b">x</code>绑定到它。然后将参数传递给函数。我们可以看到函数参数<code class="fe nf ng nh ni b">x_f</code>被初始化到函数外部变量<code class="fe nf ng nh ni b">x</code>所指向的相同内存位置。这反映在由<code class="fe nf ng nh ni b">locals()</code>函数返回的函数的本地名称空间中。在函数内部，我们创建了一个新的integer对象，其值为<code class="fe nf ng nh ni b">10</code>，被反弹到局部变量<code class="fe nf ng nh ni b">x_f</code>。这不影响在函数外绑定到<code class="fe nf ng nh ni b">x</code>的对象。我们可以通过<code class="fe nf ng nh ni b">id()</code>函数返回的内存位置和显示变量<code class="fe nf ng nh ni b">x</code>继续绑定到整数<code class="fe nf ng nh ni b">5</code>的最终打印语句来确认这一点。</p><p id="9e54" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是什么意思？我们显然没有通过引用传递参数，因为函数没有改变绑定到<code class="fe nf ng nh ni b">x</code>的值。我们也没有通过值传递参数，因为最初<code class="fe nf ng nh ni b">x_f</code>与<code class="fe nf ng nh ni b">x</code>指向相同的内存位置。向Python函数传递参数遵循某种混合模式。我们可以说我们传递了一个引用，但是这个引用是通过值传递的，也就是所谓的通过赋值传递。一旦理解了Python中的变量绑定，这有点令人难以置信，但却是可以预见的。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h1 id="67da" class="mg mh iq bd mi mj nz ml mm mn oa mp mq jw ob jx ms jz oc ka mu kc od kd mw mx bi translated">改变可变对象的值</h1><p id="3d70" class="pw-post-body-paragraph kf kg iq kh b ki my jr kk kl mz ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">根据上一节，人们可能认为Python函数根本不能改变传递的参数。这是部分正确的。Python函数不能完全改变参数，因为参数不能整体指向内存中的不同位置。如果函数内部的参数被绑定到一个新的对象，那么函数外部的参数就没有关系。然而，参数可以部分或全部改变，这是函数在Python中产生副作用的方式之一。让我们看一个例子:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ef51" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那会打印</p><pre class="lc ld le lf gt nj ni nk nl aw nm bi"><span id="6a09" class="nn mh iq ni b gy no np l nq nr">outside function x -&gt; 2199273130560, [1, 2, 3]<br/>inside function x_f -&gt; 2199273130560, [1, 2, 3]<br/>{'x_f': [1, 2, 3]}<br/>inside function x_f -&gt; 2199273130560, [1, 10, 3]<br/>{'x_f': [1, 10, 3]}<br/>outside function x -&gt; 2199273130560, [1, 10, 3]</span></pre><p id="4ea6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该函数有副作用，因为它改变了传递的参数数组的第二个元素。如果我们记住上面介绍的基本原则，这种行为是完全可以预测的。函数在函数外部定义的同一个数组上操作，正如我们从<code class="fe nf ng nh ni b">id()</code>函数的输出中看到的，它总是打印相同的内存地址。</p><p id="cfa2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们能改变数组的全部内容吗？下面的例子表明我们可以:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="35b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那会打印</p><pre class="lc ld le lf gt nj ni nk nl aw nm bi"><span id="e2db" class="nn mh iq ni b gy no np l nq nr">outside function x -&gt; 2199272856256, [1, 2, 3]<br/>inside function x_f -&gt; 2199272856256, [1, 2, 3]<br/>{'x_f': [1, 2, 3]}<br/>inside function x_f -&gt; 2199272856256, [10, 20, 30, 40]<br/>{'x_f': [10, 20, 30, 40]}<br/>outside function x -&gt; 2199272856256, [10, 20, 30, 40]</span></pre><p id="c1d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不仅改变了数组中所有元素的值，甚至还改变了它的长度。但是我们没有改变它的地址。当对象作为参数传递时，这是Python函数无法做到的。但是这可以通过第二种机制来实现，在第二种机制中，函数会引入副作用，我们将在下一节中看到。但在此之前，我想提一下，有一些方法可以在函数内部创建数组的本地副本，这样可以避免副作用，如下所示:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2685" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那会打印</p><pre class="lc ld le lf gt nj ni nk nl aw nm bi"><span id="0e10" class="nn mh iq ni b gy no np l nq nr">outside function x -&gt; 2199273194880, [1, 2, 3]<br/>inside function x_f -&gt; 2199273194880, [1, 2, 3]<br/>{'x_f': [1, 2, 3]}<br/>inside function x_f -&gt; 2199272856256, [1, 10, 3]<br/>{'x_f': [1, 10, 3]}<br/>outside function x -&gt; 2199273194880, [1, 2, 3]</span></pre><p id="fa0a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到，在函数中创建数组的副本防止了副作用。通过简单地将<code class="fe nf ng nh ni b">x</code>的副本传递给函数，也就是用<code class="fe nf ng nh ni b">f(x[:])</code>调用函数，也可以达到同样的效果。</p><p id="9b53" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是在嵌套数组的情况下，事情仍然可能出错:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6190" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那会打印</p><pre class="lc ld le lf gt nj ni nk nl aw nm bi"><span id="5c2c" class="nn mh iq ni b gy no np l nq nr">outside function x -&gt; 2199272857344, [1, [-1, -2, -3], 3]<br/>inside function x_f -&gt; 2199272857344, [1, [-1, -2, -3], 3]<br/>inside function x_f -&gt; 2199273194240, ['we guard against this side effect', [-1, 'we do not guard against this side effect', -3], 3]<br/>outside function x -&gt; 2199272857344, [1, [-1, 'we do not guard against this side effect', -3], 3]</span></pre><p id="4660" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上述行为可以用同样的基本原理来理解。在函数中复制数组意味着数组中不可变的元素在被改变时会被反弹。所有的元素都是不可变的，除了数组的第二个元素像以前一样绑定到同一个数组。我们可以用<code class="fe nf ng nh ni b">id()</code>函数来验证这一点:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="00e6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那会打印</p><pre class="lc ld le lf gt nj ni nk nl aw nm bi"><span id="0976" class="nn mh iq ni b gy no np l nq nr">outside function x<br/>2199273306608, 1000<br/>2199273249088, [-1000, -2000, -3000]<br/>.. 2199273307216, -1000<br/>.. 2199273307280, -2000<br/>.. 2199273306448, -3000<br/>2199273306384, 3000</span><span id="84e1" class="nn mh iq ni b gy oe np l nq nr">inside function x_f<br/>2199273306608, 1000<br/>2199273249088, [-1000, -2000, -3000]<br/>.. 2199273307216, -1000<br/>.. 2199273307280, -2000<br/>.. 2199273306448, -3000<br/>2199273306384, 3000</span><span id="4ac8" class="nn mh iq ni b gy oe np l nq nr">inside function x_f<br/>2199272920720, we guard against this side effect<br/>2199273249088, [-1000, 'we do not guard against this side effect', -3000]<br/>.. 2199273307216, -1000<br/>.. 2199273257072, we do not guard against this side effect<br/>.. 2199273306448, -3000<br/>2199273306384, 3000</span><span id="e877" class="nn mh iq ni b gy oe np l nq nr">outside function x<br/>2199273306608, 1000<br/>2199273249088, [-1000, 'we do not guard against this side effect', -3000]<br/>.. 2199273307216, -1000<br/>.. 2199273257072, we do not guard against this side effect<br/>.. 2199273306448, -3000<br/>2199273306384, 3000</span></pre><p id="b6b1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe nf ng nh ni b">copy</code>模块的<code class="fe nf ng nh ni b">deepcopy()</code>功能实际上是避免副作用的最安全的方法。</p><h1 id="d62b" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">更改在本地命名空间之外定义的变量的绑定</h1><p id="cab2" class="pw-post-body-paragraph kf kg iq kh b ki my jr kk kl mz ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">使用变量时，Python会在四个名称空间中进行搜索:局部、封闭、全局和内置。按照这个顺序搜索名称空间，直到找到名称，如果没有找到，Python会抛出一个<code class="fe nf ng nh ni b">NameError</code>异常。我们不会涉及名称空间的所有讨厌的细节(如果你好奇的话，请参阅本教程<a class="ae lr" href="https://realpython.com/python-namespaces-scope/" rel="noopener ugc nofollow" target="_blank">和</a>),而是把重点放在全局和局部名称空间上。让我们看一个例子:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1f75" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">印刷品</p><pre class="lc ld le lf gt nj ni nk nl aw nm bi"><span id="f972" class="nn mh iq ni b gy no np l nq nr">{'x': 'local'}<br/>global</span></pre><p id="0ca2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">原因是我们在函数内部创建了一个新的string对象，并将一个名为<code class="fe nf ng nh ni b">x</code>的局部变量绑定到它，正如<code class="fe nf ng nh ni b">locals()</code>函数的输出所示。正如我们所预期的，全局变量<code class="fe nf ng nh ni b">x</code>被绑定到字符串<code class="fe nf ng nh ni b">'global'</code>。将以上内容与以下内容进行对比:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="398a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那会打印</p><pre class="lc ld le lf gt nj ni nk nl aw nm bi"><span id="e3a2" class="nn mh iq ni b gy no np l nq nr">{}<br/>local</span></pre><p id="f19b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到，函数外部的变量<code class="fe nf ng nh ni b">x</code>现在被绑定到函数内部创建的string对象。这是一个副作用，也是应该避免的事情的主要例子。同样可以通过直接访问全局字典来实现。事实上，在调用函数之前，甚至没有必要绑定变量<code class="fe nf ng nh ni b">x</code>:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2fe5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那会打印</p><pre class="lc ld le lf gt nj ni nk nl aw nm bi"><span id="e59d" class="nn mh iq ni b gy no np l nq nr">{}<br/>local</span></pre><p id="75db" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这实际上是可怕的做法。没有看过函数内部的读者会感到困惑。与<code class="fe nf ng nh ni b">global</code>类似，在嵌套函数中使用<code class="fe nf ng nh ni b">nonlocal</code>也会产生副作用。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="fb37" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有副作用的函数会导致难以发现的错误。如果副作用是有意的，则需要在函数docstring中彻底记录。但即使这样也不理想，因为为有副作用的函数编写测试可能更难。通常，很少需要在局部范围之外修改变量，通常有更好的方法来达到相同的结果。每当传递可变参数时，都要仔细考虑函数可能会无意中对它们做什么，并采取预防措施来防止意外的副作用。</p></div></div>    
</body>
</html>