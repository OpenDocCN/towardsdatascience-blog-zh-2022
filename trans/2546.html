<html>
<head>
<title>Single Responsibility Principle in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的单一责任原则</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/single-responsibility-principle-in-python-ac4178b922de#2022-06-02">https://towardsdatascience.com/single-responsibility-principle-in-python-ac4178b922de#2022-06-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b2f3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为初学者提供易于理解的解释</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cecaf4ca367cd7c7c2d5e58e6232effa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UnUBhhUdcxKBXieC"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@d_lipenchuk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Dmitriy </a>拍摄的照片</p></figure><blockquote class="kz la lb"><p id="3993" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">让软件工作和让软件干净是两个非常不同的活动——<strong class="lf iu">罗伯特·C·马丁(干净的代码)</strong></p></blockquote><p id="0d52" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">编码时，你很容易被手头的任务冲昏头脑，只专注于让你的代码工作。结果，你失去了添加到代码中的代码行的踪迹，并以<strong class="lf iu">庞大、无组织、但仍能工作的函数</strong>结束。</p><p id="fbcb" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><strong class="lf iu">单一责任原则</strong>是一个软件设计指南，它规定您代码中的每个<strong class="lf iu">模块</strong>、<strong class="lf iu">类</strong>或<strong class="lf iu">函数</strong>都应该有<strong class="lf iu">唯一的责任和唯一的更改理由</strong>。</p><p id="a428" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">这个原则是关于<strong class="lf iu">组织你的代码的复杂性，把因为同样原因而改变的东西收集在一起</strong>，这样你就知道<strong class="lf iu">在哪里寻找</strong>来修改东西，而不用考虑<strong class="lf iu">所有涉及的复杂性。</strong></p><p id="9318" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">继续阅读，了解更多关于单一责任原则的内容，为什么以及如何在Python中实现。</p><h1 id="36be" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">适用单一责任原则的好处</h1><p id="33e6" class="pw-post-body-paragraph lc ld it lf b lg mu ju li lj mv jx ll lz mw lo lp ma mx ls lt mb my lw lx ly im bi translated">如果你遵循<strong class="lf iu">单一责任原则</strong>，你最终会得到<strong class="lf iu">大量的小函数，或者类</strong>而不是大函数。</p><p id="6eef" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">你可能会认为这可能不是一个好主意。也许你更喜欢一些大的函数和类。</p><p id="2c41" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">显然，如果你盲目地遵循这个原则，将你的代码分解成原子部分，这也会导致一些不希望的副作用。应该有一个<strong class="lf iu">平衡考虑</strong>，下面的引用定义了它是什么；</p><blockquote class="kz la lb"><p id="a9fa" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><em class="it">把</em> <strong class="lf iu"> <em class="it">因为同样的原因而改变的东西</em> </strong> <em class="it">。把那些</em> <strong class="lf iu"> <em class="it">因不同原因而改变的东西分开</em></strong><em class="it">——</em><strong class="lf iu">罗伯特·C·马丁</strong></p></blockquote><p id="d995" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">为什么遵循单一责任原则是一个好主意；</p><ul class=""><li id="a440" class="mz na it lf b lg lh lj lk lz nb ma nc mb nd ly ne nf ng nh bi translated">它有助于将一大块代码转换成定义明确、标记良好、高度内聚、干净和健壮的组件。</li><li id="9367" class="mz na it lf b lg ni lj nj lz nk ma nl mb nm ly ne nf ng nh bi translated">它要求你命名更多的代码块，并强迫你明确你的意图。随着时间的推移，这将使您的代码更具可读性。</li><li id="0a73" class="mz na it lf b lg ni lj nj lz nk ma nl mb nm ly ne nf ng nh bi translated">当你的函数和类尽可能小的时候，很容易发现重复的代码。</li><li id="8ff9" class="mz na it lf b lg ni lj nj lz nk ma nl mb nm ly ne nf ng nh bi translated">定义良好的小代码块可以更好地混合和重用。</li><li id="26ef" class="mz na it lf b lg ni lj nj lz nk ma nl mb nm ly ne nf ng nh bi translated">小功能容易测试，也容易被别人理解。</li><li id="391f" class="mz na it lf b lg ni lj nj lz nk ma nl mb nm ly ne nf ng nh bi translated">当一个函数不属于一个名称空间时，很容易发现。</li><li id="baac" class="mz na it lf b lg ni lj nj lz nk ma nl mb nm ly ne nf ng nh bi translated">花时间确定独特的职责有助于我们在代码中识别和创建更好的抽象。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/05003830b6d20e05473d902711106183.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Pr4L0cMJ_NN2HMGw"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@austindistel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Austin Distel </a>拍摄的照片</p></figure><h1 id="d601" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">单一责任原则的Python实现</h1><h2 id="6453" class="no md it bd me np nq dn mi nr ns dp mm lz nt nu mo ma nv nw mq mb nx ny ms nz bi translated">单一责任原则— Python类:</h2><p id="a942" class="pw-post-body-paragraph lc ld it lf b lg mu ju li lj mv jx ll lz mw lo lp ma mx ls lt mb my lw lx ly im bi translated">你可以看到下面的<strong class="lf iu">模型</strong>类有很多职责。预处理数据、训练和评估模型、做出预测是不同的职责，都在<strong class="lf iu">模型</strong>类中处理。这违反了单一责任原则，由于上述原因，强烈建议不要这样做。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="e19f" class="no md it ob b gy of og l oh oi"><strong class="ob iu"># Before the single responsibility principle</strong></span><span id="4c49" class="no md it ob b gy oj og l oh oi">class <strong class="ob iu">Model</strong>:<br/>  <br/>  def <strong class="ob iu">pre_process(self)</strong>:<br/>    pass</span><span id="2e33" class="no md it ob b gy oj og l oh oi">  def <strong class="ob iu">train(self)</strong>:<br/>    pass<br/>  <br/>  def <strong class="ob iu">evaluate(self):</strong><br/>    pass</span><span id="4c59" class="no md it ob b gy oj og l oh oi">  def <strong class="ob iu">predict(self):</strong><br/>    pass</span></pre><p id="ece5" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">如下所示，我们可以创建单独的类来处理每个职责，以使我们的类与单一职责原则兼容。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="5f85" class="no md it ob b gy of og l oh oi"><strong class="ob iu"># After the single responsibility principle applied</strong></span><span id="3f2b" class="no md it ob b gy oj og l oh oi">class <strong class="ob iu">PreProcess</strong>:<br/>  pass</span><span id="4548" class="no md it ob b gy oj og l oh oi">class <strong class="ob iu">Train</strong>:<br/>  pass</span><span id="79d6" class="no md it ob b gy oj og l oh oi">class <strong class="ob iu">Evaluate</strong>:<br/>  pass</span><span id="db13" class="no md it ob b gy oj og l oh oi">class <strong class="ob iu">Predict</strong>:<br/>  pass</span></pre><h2 id="dbb9" class="no md it bd me np nq dn mi nr ns dp mm lz nt nu mo ma nv nw mq mb nx ny ms nz bi translated">单一责任原则— Python函数:</h2><p id="7352" class="pw-post-body-paragraph lc ld it lf b lg mu ju li lj mv jx ll lz mw lo lp ma mx ls lt mb my lw lx ly im bi translated">说到职能，遵循单一责任原则就更重要了。我总是发现自己在一个功能体中处理许多任务，这使得功能变得庞大而不杂乱。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="986e" class="no md it ob b gy of og l oh oi"><strong class="ob iu"># Before the single responsibility principle applied</strong></span><span id="5e8a" class="no md it ob b gy oj og l oh oi">def <strong class="ob iu">pre_processing_data()</strong>:<br/>  #importing data<br/>  #converting data types<br/>  #handling missing values<br/>  #handling outliers<br/>  #transforming data</span></pre><p id="b2c6" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">现在，一旦我们在一个单独的函数中处理每个任务，我们就可以拥有比第一个更干净、更容易混合和重用的函数。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="bb67" class="no md it ob b gy of og l oh oi"><strong class="ob iu"># After the single responsibility principle applied</strong></span><span id="e572" class="no md it ob b gy oj og l oh oi">def <strong class="ob iu">import_data()</strong>: <br/>  pass</span><span id="eee8" class="no md it ob b gy oj og l oh oi">def <strong class="ob iu">convert_data_type(): <br/>  </strong>pass</span><span id="4a4e" class="no md it ob b gy oj og l oh oi">def <strong class="ob iu">handle_missing_values(): <br/> </strong> pass</span><span id="00c1" class="no md it ob b gy oj og l oh oi">def <strong class="ob iu">handle_outliers(): <br/>  </strong>pass</span><span id="9e12" class="no md it ob b gy oj og l oh oi">def <strong class="ob iu">transform_data(): <br/>  </strong>pass<br/></span></pre><h1 id="f4c2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">关键要点和结论</h1><p id="49a2" class="pw-post-body-paragraph lc ld it lf b lg mu ju li lj mv jx ll lz mw lo lp ma mx ls lt mb my lw lx ly im bi translated">关键要点是:</p><ul class=""><li id="b29f" class="mz na it lf b lg lh lj lk lz nb ma nc mb nd ly ne nf ng nh bi translated"><strong class="lf iu">单一责任原则</strong>是一个软件设计指南，它规定您代码中的每个<strong class="lf iu">模块</strong>、<strong class="lf iu">类</strong>或<strong class="lf iu">函数</strong>都应该有<strong class="lf iu">唯一的责任和唯一的更改理由</strong>。</li><li id="46d8" class="mz na it lf b lg ni lj nj lz nk ma nl mb nm ly ne nf ng nh bi translated">它有助于将一大块代码转换成<strong class="lf iu">定义明确、标记良好、高度内聚、干净和健壮的组件</strong>。</li><li id="7cfa" class="mz na it lf b lg ni lj nj lz nk ma nl mb nm ly ne nf ng nh bi translated">定义良好的小代码块可以更好地混合和重用。</li></ul><p id="272d" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">我希望你发现这篇文章很有用，并且<strong class="lf iu">将开始在你自己的代码</strong>中应用单一责任原则。</p></div></div>    
</body>
</html>