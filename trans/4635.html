<html>
<head>
<title>Comparing floating-point numbers with easycheck</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用easycheck比较浮点数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/comparing-floating-point-numbers-with-easycheck-dcbae480f75f#2022-10-14">https://towardsdatascience.com/comparing-floating-point-numbers-with-easycheck-dcbae480f75f#2022-10-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7602" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">easycheck可以帮助您在类似断言的情况下比较浮点数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/259f464143814d9eacbd7365f11eab79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6T7Gca_LVURz0PHsY5Td3w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">比较浮点数。图片作者。</p></figure><p id="57bc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Python中比较浮点数比您想象的要简单。这要感谢<code class="fe lu lv lw lx b">math</code>模块，但不仅仅是。大卫·阿莫斯最近在他的<a class="ae ly" href="https://medium.com/better-programming/the-right-way-to-compare-floats-in-python-ee18042abcc" rel="noopener"> <em class="lz">关于数据科学的</em>文章</a>中非常好地描述了这个主题，所以如果你对基础知识感兴趣，请先阅读它。</p><p id="a2d2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将向您展示如何在类似断言的情况下比较浮点数。人们不应该在<em class="lz">生产</em>代码中使用<code class="fe lu lv lw lx b">assert</code>语句，因为在调用Python脚本时，所有断言都可能被屏蔽，这是通过<code class="fe lu lv lw lx b">-O</code>优化标志完成的。所以，在你的产品代码中使用<code class="fe lu lv lw lx b">assert</code>是有风险的，尤其是当它们负责重要的检查时。这样的应用程序可能会出现意外行为。</p><p id="eafa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面我强调了“生产”。这是因为在开发过程中，当您检查代码中的各种条件时，您可以使用<code class="fe lu lv lw lx b">assert</code>。但是，您需要记住，不要运行带有优化标志的代码。记住，一旦你完成了开发，以后就要依赖它们了。</p><p id="91a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您想在生产代码中使用断言，该怎么办？如果不是<code class="fe lu lv lw lx b">assert</code>，那是什么？</p><p id="50b4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">幸运的是，还有其他选择，在这里我们将讨论其中的一个:<code class="fe lu lv lw lx b"><a class="ae ly" href="https://github.com/nyggus/easycheck" rel="noopener ugc nofollow" target="_blank">easycheck</a></code>包。它提供了我们称之为类似于<code class="fe lu lv lw lx b">assert</code>的功能。这些函数允许检查一个条件(或几个条件)并在违反条件时抛出异常(或发出警告);当一个条件满足时，什么都不会发生。</p><p id="b8da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你看到与<code class="fe lu lv lw lx b">assert</code>陈述的相似之处了吗？事实上，<code class="fe lu lv lw lx b">easycheck</code>的行为与此类似，但是提供了更丰富的功能。</p><p id="4809" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将在一个上下文中讨论<code class="fe lu lv lw lx b">easycheck</code>:比较浮点数。在此之前，我们需要讨论比较浮点数的基础知识。主要的Python工具是标准库中的<code class="fe lu lv lw lx b">math.isclose()</code>函数。了解其工作原理将为我们分析<code class="fe lu lv lw lx b">easycheck</code>的报价提供背景。</p><h1 id="274a" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">比较浮动有什么大惊小怪的？</h1><p id="1a6c" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">一方面，</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="462d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一切都好。另一方面，</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c4a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一点都不好！</p><p id="595b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些都是常见的问题，当浮点数以这种意想不到的方式运行时，我可以提供更多类似的例子。但这不是本文的目的。你可以在David Amos的文章中看到更多的例子和相当详细的解释。</p><p id="7f42" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最常见的——也是大多数情况下最好的——解决方案是使用标准库<code class="fe lu lv lw lx b">math.isclose()</code>函数。它允许使用差异的相对容差(<code class="fe lu lv lw lx b">rel_tol</code>，默认为<code class="fe lu lv lw lx b">rel_tol=1e-09</code>)或差异的绝对容差(<code class="fe lu lv lw lx b">abs_tol</code>，默认为<code class="fe lu lv lw lx b">abs_tol=0.0</code>)来比较两个浮点数。这是最简单的用例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="167c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面，我使用了该函数的默认设置，这意味着用相对容差<code class="fe lu lv lw lx b">1e-09</code>和无绝对容差(默认设置为0)来比较这两个数字。换句话说，这两个数字被认为相对<em class="lz">不接近</em>时</p><pre class="kj kk kl km gt mz lx na nb aw nc bi"><span id="dbc1" class="nd mb it lx b gy ne nf l ng nh">abs(x — y)/min(x, y) &gt; rel_tol</span></pre><p id="e454" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">否则，它们被认为是相对<em class="lz">接近</em>。当然，我们必须在提供的容差范围内考虑这个<em class="lz">接近度</em>。两个数字在一个容差的上下文中可以接近，在另一个容差的上下文中可以不接近。</p><p id="11ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意<em class="lz">关闭</em>并不意味着<em class="lz">没有不同</em>和<em class="lz">没有关闭</em>并不意味着<em class="lz">不同。</em>这只是文字，我们如何解读数字取决于我们自己。然而，本质上，这个函数并不能让你判断两个数字是否相同。顾名思义，它使您能够分析两个数字有多接近。</p><p id="c736" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要了解更多信息，请阅读Python的 <code class="fe lu lv lw lx b"><a class="ae ly" href="https://docs.python.org/3/library/math.html" rel="noopener ugc nofollow" target="_blank">math</a></code> <a class="ae ly" href="https://docs.python.org/3/library/math.html" rel="noopener ugc nofollow" target="_blank">模块</a>的文档，以及上面提到的David Amos的文章。</p><h1 id="dc5c" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">用<code class="fe lu lv lw lx b">easycheck</code>比较浮动</h1><p id="4480" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated"><code class="fe lu lv lw lx b">math.isclose()</code>函数返回一个布尔值，告知两个数字在给定容差下是否接近，是相对还是绝对，或者两者都有。这样，当你想回答这样一个问题:这两个数字是否接近时，它将满足你的需要。</p><p id="1d92" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，当您想在类似断言的上下文中这样做时，<code class="fe lu lv lw lx b">math.isclose()</code>不能直接应用。您可以使用一个<code class="fe lu lv lw lx b">if-else</code>块来实现，在这个块中，当条件不满足时，您会引发一个异常。但是你可以使用一个专用的工具来完成，因为这正是<code class="fe lu lv lw lx b">easycheck</code>包设计的目的。</p><p id="f044" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过类似断言的上下文，我理解了检查条件的情况，当条件不满足时，就会引发异常；如果是的话，什么也不会发生。这就是<code class="fe lu lv lw lx b">assert</code>的工作原理。有了<code class="fe lu lv lw lx b">easycheck</code>，你可以发出警告，但是你还可以做更多的事情。因此，在提供<code class="fe lu lv lw lx b">assert</code>所提供的同时，<code class="fe lu lv lw lx b">easycheck</code>实际上提供了更多:</p><ul class=""><li id="413a" class="ni nj it la b lb lc le lf lh nk ll nl lp nm lt nn no np nq bi translated"><code class="fe lu lv lw lx b">assert</code>语句不应该在生产代码中使用，因为在运行程序时，它在代码中的所有实例都可以被优化标志(<code class="fe lu lv lw lx b">-O</code>)屏蔽。在某些情况下，这是一件好事，因此<code class="fe lu lv lw lx b">easycheck</code>将很快获得类似的功能。</li><li id="12aa" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated"><code class="fe lu lv lw lx b">assert</code>语句使您能够仅引发<code class="fe lu lv lw lx b">AssertionError</code>，并带有可选消息。使用<code class="fe lu lv lw lx b">easycheck</code>，您可以引发任何您想要的异常并发出任何您想要的警告。</li><li id="c02a" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated"><code class="fe lu lv lw lx b">assert</code>作为裸机工具，速度更快。</li></ul><p id="6b71" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可以使用一个<code class="fe lu lv lw lx b">if</code>块或一系列<code class="fe lu lv lw lx b">if</code>块来代替<code class="fe lu lv lw lx b">easycheck</code>。然而，<code class="fe lu lv lw lx b">easycheck</code>更加优雅，提供了更加丰富的功能。此外，<code class="fe lu lv lw lx b">if</code>-与<code class="fe lu lv lw lx b">easycheck</code>不同，块用于各种目的。因此，当你看到一个<code class="fe lu lv lw lx b">if</code>-块时，你必须阅读它，看看它的目的是什么。当你看到一个<code class="fe lu lv lw lx b">assert</code>语句或者一个<code class="fe lu lv lw lx b">easycheck</code>函数调用时，你马上就知道它是验证码。</p><p id="983e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了比较浮点数，我们可以使用<code class="fe lu lv lw lx b">easycheck.check_if_isclose()</code>函数。它的名字，你也看到了，和<code class="fe lu lv lw lx b">math.isclose()</code>差不多，很好记。它的API也和<code class="fe lu lv lw lx b">math.isclose()</code>差不多。我写“几乎相同”只是因为它有几个额外的(我们在下面讨论它们)。关键是在比较数字方面，这两个函数的工作方式完全相同，因为<code class="fe lu lv lw lx b">easycheck.check_if_isclose()</code>是<code class="fe lu lv lw lx b">math.isclose()</code>的直接包装器。</p><p id="ece2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，从数学的角度来看，这两个函数的工作方式完全相同。区别在于它们的行为方式:</p><ul class=""><li id="800f" class="ni nj it la b lb lc le lf lh nk ll nl lp nm lt nn no np nq bi translated"><code class="fe lu lv lw lx b">math.isclose()</code>返回一个布尔值:如果数字足够接近，则返回<code class="fe lu lv lw lx b">True</code>，否则返回<code class="fe lu lv lw lx b">False</code>。</li><li id="d73b" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">当两个数字足够接近时，不执行任何操作。当它们不是时，它要么引发一个错误，要么发出一个警告，这取决于您的请求。您可以使用可选消息。</li></ul><p id="ac76" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一节将详细分析这个函数。</p><h1 id="da63" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated"><code class="fe lu lv lw lx b">easycheck.check_if_isclose()</code>在行动</h1><p id="ea10" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">这是该函数的签名:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="801b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，</p><ul class=""><li id="99d6" class="ni nj it la b lb lc le lf lh nk ll nl lp nm lt nn no np nq bi translated"><code class="fe lu lv lw lx b">x</code>和<code class="fe lu lv lw lx b">y</code>都是仅位置参数，是传递给<code class="fe lu lv lw lx b">math.isclose()</code>的两个参数(作为<code class="fe lu lv lw lx b">a</code>和<code class="fe lu lv lw lx b">b</code>)。</li><li id="d480" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated"><code class="fe lu lv lw lx b">handle_with</code>是一个典型的<code class="fe lu lv lw lx b">easycheck</code>参数，用在它的所有检查函数中。它设置不满足条件时使用的异常类。在这个函数中，默认为<code class="fe lu lv lw lx b">NotCloseEnoughError</code>，一个在<code class="fe lu lv lw lx b">easycheck</code>中定义的异常类。如果您需要捕捉和处理这个异常，您必须从包中导入它。</li><li id="6488" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated"><code class="fe lu lv lw lx b">message</code>当然是与异常一起使用的消息。你可以随意定制。默认值是<code class="fe lu lv lw lx b">None</code>，对于这个函数来说，这实际上意味着消息将是<code class="fe lu lv lw lx b">"The two float numbers are not close enough"</code>。如果不想使用任何信息，使用<code class="fe lu lv lw lx b">message=""</code>。</li><li id="e627" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated"><code class="fe lu lv lw lx b">rel_tol</code>和<code class="fe lu lv lw lx b">abs_tol</code>与<code class="fe lu lv lw lx b">math.isclose()</code>中使用的参数完全相同。它们具有相同的名称、默认值和行为，并且它们被直接传递给<code class="fe lu lv lw lx b">math.isclose()</code>。</li></ul><p id="edd7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，如果你已经知道如何使用<code class="fe lu lv lw lx b">math.isclose()</code>——如果你想使用<code class="fe lu lv lw lx b">easycheck.check_if_isclose()</code>，你就应该知道后者如何比较数字。<em class="lz">注意一个微小的区别</em>:调用<code class="fe lu lv lw lx b">math.isclose()</code>时，您可以使用关键字参数<code class="fe lu lv lw lx b">a</code>和<code class="fe lu lv lw lx b">b</code>，而<code class="fe lu lv lw lx b">easycheck</code>函数只使用位置参数。因此，如果您在<code class="fe lu lv lw lx b">isclose()</code>函数中使用了<code class="fe lu lv lw lx b">a</code>和<code class="fe lu lv lw lx b">b</code>参数名称，请记住删除它们。</p><p id="886d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，您可以做的唯一额外定制是特定于<code class="fe lu lv lw lx b">easycheck</code>的参数，即<code class="fe lu lv lw lx b">handle_with</code>和<code class="fe lu lv lw lx b">message</code>，尽管实际上您可以简单地将它们保留。默认错误可能工作得很好，它的名字传达了您需要的一切:<code class="fe lu lv lw lx b">NotCloseEnoughError</code>。当然，你也可以使用任何其他的例外，一个<a class="ae ly" rel="noopener" target="_blank" href="/should-we-use-custom-exceptions-in-python-b4b4bca474ac">自定义一个</a>。</p><p id="0036" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是时候看看这个函数的实际作用了。我确信，如果你知道如何使用<code class="fe lu lv lw lx b">math.isclose()</code>并且使用过几次，你在理解下面例子中发生的事情时不会有任何问题。</p><p id="ceb8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="lz">注意</em> </strong>:一定要记住，如果满足条件，什么都不会发生，几次检查都会看到这个。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="32df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上述对<code class="fe lu lv lw lx b">easycheck.check_if_isclose()</code>的调用既不改变<code class="fe lu lv lw lx b">handle_with</code>也不改变<code class="fe lu lv lw lx b">message</code>。让我们看看我们能做些什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="adc6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">花几分钟分析上面的片段，自己决定<code class="fe lu lv lw lx b">easycheck.check_if_isclose()</code>是否容易使用。</p><h1 id="e241" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">用<code class="fe lu lv lw lx b">easycheck</code>比较单元测试中的浮点</h1><p id="65aa" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">由于单元测试是基于断言的环境，你可以在单元测试中使用<code class="fe lu lv lw lx b">easycheck.check_if_isclose()</code>，例如在<code class="fe lu lv lw lx b"><a class="ae ly" href="https://docs.pytest.org/en/7.1.x/" rel="noopener ugc nofollow" target="_blank">pytest</a></code>和<code class="fe lu lv lw lx b"><a class="ae ly" href="https://docs.python.org/3/library/doctest.html" rel="noopener ugc nofollow" target="_blank">doctest</a></code>中。然而，<code class="fe lu lv lw lx b">easycheck</code>带有一个别名<code class="fe lu lv lw lx b">easycheck.check_if_isclose()</code>，专用于测试:<code class="fe lu lv lw lx b">easycheck.assert_if_isclose()</code>。作为别名，它的用法和<code class="fe lu lv lw lx b">easycheck.check_if_isclose()</code>完全一样。下面的脚本展示了一个典型的<code class="fe lu lv lw lx b">pytest</code>文件的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="5005" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，这个代码没有什么特别的。这与之前的检查类似，但是之前是在代码上下文中进行的，而现在是在单元测试上下文中进行的。</p><p id="b696" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您运行测试文件，您将会看到测试将会失败:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/6248cdd044a30af7c4b772a8658ef252.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ndiqJnY7IVxbpi3s-S2dqA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">pytest中<code class="fe lu lv lw lx b">easycheck.assert_if_isclose()</code>的使用:失败测试的输出。图片作者。</p></figure></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h1 id="a46f" class="ma mb it bd mc md oe mf mg mh of mj mk jz og ka mm kc oh kd mo kf oi kg mq mr bi translated">结论</h1><p id="bcdf" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">浮动相对容易比较，但是只有当你知道如何比较的时候。在大多数情况下，<code class="fe lu lv lw lx b">math.isclose()</code>将是首选方法。这是一个简单的函数，我认为使用起来相当简单，我希望你同意我的观点。</p><p id="972d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，在某些情况下，<code class="fe lu lv lw lx b">easycheck.check_if_isclose()</code>或者它的单元测试别名<code class="fe lu lv lw lx b">easycheck.assert_if_isclose()</code>会更适合您的需要。例如，您可能更喜欢在生产代码中使用前者。</p><p id="c28d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">easycheck</code>是一个外部包，需要安装。它可以从PyPi获得，所以您可以使用<code class="fe lu lv lw lx b">pip</code>安装它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ae4e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您决定使用<code class="fe lu lv lw lx b">easycheck</code>，您将得到一个模块，您不仅可以使用它来比较两个浮点数，还可以执行各种检查。但是这个故事我以后会讲的…</p><p id="c3ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读！留下你对比较浮动、<code class="fe lu lv lw lx b">math.isclose()</code>和<code class="fe lu lv lw lx b">easycheck.check_if_isclose()</code>的看法的评论。也许你知道另一个工具，在这些或不同的场景中，它对比较浮点数特别有帮助？</p><h1 id="c6d0" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">资源</h1><ul class=""><li id="090b" class="ni nj it la b lb ms le mt lh oj ll ok lp ol lt nn no np nq bi translated">大卫·阿莫斯(2022)。Python中比较浮点数的正确方法，<em class="lz">走向数据科学</em> </li><li id="394d" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated"><a class="ae ly" href="https://github.com/nyggus/easycheck" rel="noopener ugc nofollow" target="_blank">仓库中的</a> <code class="fe lu lv lw lx b"><a class="ae ly" href="https://github.com/nyggus/easycheck" rel="noopener ugc nofollow" target="_blank">easycheck</a></code> <a class="ae ly" href="https://github.com/nyggus/easycheck" rel="noopener ugc nofollow" target="_blank">包</a></li><li id="01bc" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated"><a class="ae ly" href="http://Documentation of the math module" rel="noopener ugc nofollow" target="_blank"/><code class="fe lu lv lw lx b"><a class="ae ly" href="http://Documentation of the math module" rel="noopener ugc nofollow" target="_blank">math</a></code><a class="ae ly" href="http://Documentation of the math module" rel="noopener ugc nofollow" target="_blank">模块</a>的文档</li><li id="d850" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">科萨克米(2022)。我们应该在Python中使用自定义异常吗？<em class="lz">走向数据科学</em> </li><li id="d62e" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated"><code class="fe lu lv lw lx b"><a class="ae ly" href="https://docs.pytest.org/en/7.1.x/" rel="noopener ugc nofollow" target="_blank">pytest</a></code> <a class="ae ly" href="https://docs.pytest.org/en/7.1.x/" rel="noopener ugc nofollow" target="_blank">的网页</a></li><li id="c601" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated"><a class="ae ly" href="https://docs.python.org/3/library/doctest.html" rel="noopener ugc nofollow" target="_blank"/><code class="fe lu lv lw lx b"><a class="ae ly" href="https://docs.python.org/3/library/doctest.html" rel="noopener ugc nofollow" target="_blank">doctest</a></code><a class="ae ly" href="https://docs.python.org/3/library/doctest.html" rel="noopener ugc nofollow" target="_blank">模块</a>的文档</li></ul><h1 id="26e5" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">感谢</h1><p id="d95c" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">感谢<a class="om on ep" href="https://medium.com/u/2b3100272a2a?source=post_page-----dcbae480f75f--------------------------------" rel="noopener" target="_blank"> David Amos </a>关于比较浮点数的好文章。如果没有它，我将不得不把这篇文章写得更长，这样就不那么关注它的内容:使用<code class="fe lu lv lw lx b">easycheck</code>来比较浮动。</p></div></div>    
</body>
</html>