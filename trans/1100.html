<html>
<head>
<title>Closures in Action: The Dramatic Power of Closure Functions as Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">闭包在起作用:闭包函数作为类型的巨大威力</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/closures-in-action-the-dramatic-power-of-closure-functions-as-types-bf52be2b632e#2022-03-21">https://towardsdatascience.com/closures-in-action-the-dramatic-power-of-closure-functions-as-types-bf52be2b632e#2022-03-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dc3a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在 Julia 中，将函数视为正常类型的各种用法产生了一些相当有趣的结果。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/06ed546944d02ff7f0a3b63766329fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rs8fttSzPR6mg-n6oIZtCA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由<a class="ae ky" href="http://pixabay.com" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上的<a class="ae ky" href="https://pixabay.com/photos/code-programming-javascript-5113374/" rel="noopener ugc nofollow" target="_blank"> roketpik </a>提供)</p></figure><h1 id="2c80" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="ddb0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Julia 编程语言及其功能的一个非常强大的地方是对闭包的强大支持。也就是说，在将函数视为数据方面，Julia 是一种出色的语言。使用 dispatch 函数是完全可能的，因此会产生一些非常棒的语法。当涉及到使类型和函数协同工作以实现给定目标时，这种语法也有许多应用。如果您不熟悉闭包函数，这可能是本文信息的一个先决条件。幸运的是，我正好有一篇文章更详细地介绍了这些是什么，你可以在这里阅读:</p><div class="mn mo gp gr mp mq"><a rel="noopener follow" target="_blank" href="/what-on-earth-are-closures-a4f9c7c652d2"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">闭包到底是什么？</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">闭包函数及其使用方法概述</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">towardsdatascience.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne ks mq"/></div></div></a></div><p id="17b6" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">另一篇文章提供了更多相关信息，介绍了这类事情在 Julia 中通常是如何通过匿名函数定义来实现的，在接下来的文章中也会有更详细的讨论:</p><div class="mn mo gp gr mp mq"><a rel="noopener follow" target="_blank" href="/what-on-earth-is-an-anonymous-function-f8043eb845f3"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">匿名函数到底是什么？</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">揭开 Julia 中匿名函数和类型的来龙去脉</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">towardsdatascience.com</p></div></div><div class="mz l"><div class="nk l nb nc nd mz ne ks mq"/></div></div></a></div><p id="c9d3" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">如果代码是你正在寻找的，我在这个项目中使用的代码可以在 Github 的这个资源库中以<a class="ae ky" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/Functions%20as%20types%20in%20Julia.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本格式获得。</a></p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="b159" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">快速复习</h1><p id="a3b5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在 Julia 中，闭包函数定义处理得非常漂亮。通常情况下，函数和类型之间的差异是无法衡量的，除非我们想通过提供()将该函数用作函数。它总是含蓄的，这是一件伟大的事情。同样，函数也很容易定义，任何东西都可以等同于函数，例如我们可以这样定义:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="b976" class="oc la it ny b gy od oe l of og">n = function hello(x, y)<br/>   println("hi") <br/>end</span></pre><p id="30fe" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">然后我们可以像调用 hello()的定义一样调用 n。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="fd89" class="oc la it ny b gy od oe l of og">n(5, 1)</span></pre><p id="e722" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">我们当然也可以内联定义函数，使得函数和传统构造的数据结构之间的区别更加抽象——这是一件很棒的事情。特别重要的是，这种实现也不会妨碍其他事情，而这类事情经常会发生。这是闭包赋予的基本能力，仅仅利用这种思想，就可以实现一些非常激进和强大的解决方案。</p><h1 id="87dd" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">原始闭包实现</h1><p id="d8f4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">使用函数作为参数的第一个实现实际上将是一个非常酷的用例。在这个例子中，我们需要为我们的服务器制作一个路由器，因为默认的 HTTP。HTTP 包中的路由器类型只能在非异步的服务器上工作，至少据我所知是这样。无论哪种方式，这都可以被认为是一种更加手动的方式，实际上，人们可以围绕这个实现制作他们自己的 mimes 所以这非常酷。为了清楚起见，mime 是 Julia 中的 display()函数到常规 HTT 协议之间的转换层。这只是一种奇特的方式来表达我们如何把这个 Julia 翻译成 HTML。所有这些都可以通过闭包有效地完成。想想这可能会有多强大是有点意思的。让我们看看这在 Julia 代码中是什么样子的。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="8747" class="oc la it ny b gy od oe l of og">using HTTP</span></pre><p id="32a3" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">我从定义一些构造函数开始编写代码，使一些类型实际上保存我们可能希望在服务器上保存的大量信息。这些信息包括不同的部分，比如路径、页面的组成部分，以及我们希望通过 HTTP 在前端显示的所有信息。我们将从路由构造器开始:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="bce7" class="oc la it ny b gy od oe l of og">mutable struct Route<br/>    path::String<br/>    page::Any<br/>    function Route(path::String = "", page::Any = "")<br/>        new(path, page)<br/>    end<br/>end</span></pre><p id="1b3c" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">这是我们自己的独特类型，最著名的构造函数是 Route(::String，:Any)。也就是说，每当我们要创建一条路线时，我们都要注意这一点。接下来，我将为我们的服务器创建一个外部构造函数。我将使用闭包方法定义，并将它们保存在一个常规闭包实现之上的结构中，使用一个函数来控制传入的路由。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="b041" class="oc la it ny b gy od oe l of og">mutable struct OurServer<br/>    ip::String<br/>    port::Integer<br/>    routes::AbstractVector<br/>    remove::Function<br/>    add::Function<br/>    start::Function</span></pre><p id="0506" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">考虑到这一点，我们需要首先查看为我们创建这些方法的支持函数，</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="addf" class="oc la it ny b gy od oe l of og">function funcdefs(routes::AbstractVector, ip::String, port::Integer)<br/>    add(r::Route) = push!(routes, r)<br/>    remove(i::Int64) = deleteat!(routes, i)<br/>    start() = _start(routes, ip, port)<br/>    return(add, remove, start)<br/>end</span></pre><p id="b444" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">这些新功能只是添加和删除路由以及启动服务器。记住，start 只是开始为 HTTP 服务器提供服务。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="fe89" class="oc la it ny b gy od oe l of og">function _start(routes::AbstractVector, ip::String, port::Integer)<br/>    server = Sockets.listen(Sockets.InetAddr(parse(IPAddr, ip), port))<br/>    println("Starting server on port ", string(port))<br/>    routefunc = generate_router(routes, server)<br/>    <a class="ae ky" href="http://twitter.com/async" rel="noopener ugc nofollow" target="_blank">@async</a> HTTP.listen(routefunc, ip, port; server = server)<br/>    println("Successfully started server on port ", port, "\n")<br/>    println("You may visit it now at http://" * string(ip) * ":" * string(port))<br/>    return(server)<br/>end</span></pre><p id="3eca" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">虽然这个基本实现中没有日志记录，但这可能是处理整个事情的更好方法，因为现在我将只使用 println()。我们的 start 函数只是启动一个服务器，然后使用一个自动生成的 router 函数异步地为它服务。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="364e" class="oc la it ny b gy od oe l of og">function generate_router(routes::AbstractVector, server)<br/>    route_paths = Dict([route.path =&gt; route.page for route in routes])<br/>    routeserver = function serve(http)<br/>     HTTP.setheader(http, "Content-Type" =&gt; "text/html")<br/>        fullpath = http.message.target<br/>    if contains(http.message.target, '?')<br/>         fullpath = split(http.message.target, '?')<br/>         args = ""<br/>    end<br/>     if length(fullpath) &gt; 1<br/>         args = fullpath[2]<br/>     end<br/>     if fullpath in keys(route_paths)<br/>        write(http, route_paths[fullpath])<br/>     else<br/>         write(http, route_paths["404"])<br/>     end<br/> end # serve()<br/>    return(routeserver)<br/>end<br/>function stop!(x::Any)<br/>    close(x)<br/>end</span><span id="8dc8" class="oc la it ny b gy oh oe l of og">function stop!(x::Any)<br/>    close(x)<br/>end</span></pre><p id="e9ea" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">还有一站！()函数杀死服务器。最终，这个 generate_router 函数就是神奇之处，它定义了一个到其内容的页面路由，然后使用 write()将正确的内容写出流。需要注意的重要部分是 routeserver 定义所在的位置。这使得该功能在关于路由的所有情况下都是可再现的，并且在没有找到路由的情况下，该路由请求 404 路由。现在我们完成了我们的内部构造函数，它依赖于我们在它下面创建的这个新的类型系统。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="8582" class="oc la it ny b gy od oe l of og">mutable struct OurServer<br/>    ip::String<br/>    port::Integer<br/>    routes::AbstractVector<br/>    remove::Function<br/>    add::Function<br/>    start::Function<br/>    function OurServer(ip::String, port::Int64)<br/>        routes = []<br/>        add, remove, start = funcdefs(routes, ip, port)<br/>        new(ip, port, routes, remove, add, start)<br/>    end</span><span id="82ed" class="oc la it ny b gy oh oe l of og">function OurServer()<br/>        port = 8001<br/>        ip = "127.0.0.1"<br/>        OurServer(ip, port)<br/>    end<br/>end</span></pre><p id="48c6" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">使用这种技术，我们现在已经构建了一个服务器，它将根据请求本身的内容来引导或限制流量请求。非常棒，这个结果非常好合作。首先，我们创建路线:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="89b5" class="oc la it ny b gy od oe l of og">home = Route("/", "&lt;h1&gt;HELLO WORLD&lt;/h1&gt;")<br/>four04 = Route("404", "&lt;h1&gt; Directory not found &lt;/h1&gt;")</span></pre><p id="ad5d" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">然后，我们创建一个服务器，并在其中添加两条新的 HTTP 路由。感谢我们的内部构造器，这绝对是轻而易举的事:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="2da9" class="oc la it ny b gy od oe l of og">server = OurServer()<br/>server.add(home)<br/>server.add(four04)</span></pre><p id="ef40" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">现在我们可以像这样启动一个新的异步服务器:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="6efa" class="oc la it ny b gy od oe l of og">serving = server.start()</span><span id="e1cb" class="oc la it ny b gy oh oe l of og">Starting server on port 8001<br/>Successfully started server on port 8001<br/><br/>You may visit it now at <a class="ae ky" href="http://127.0.0.1:8001/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8001</a></span><span id="2310" class="oc la it ny b gy oh oe l of og">Sockets.TCPServer(RawFD(45) active)</span></pre><p id="3ca6" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">访问该链接会产生以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/a33fa74abdb1f26483e057048c7b6da5.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*pPhwhu218KKqh7ieTgr_4Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="d98d" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">现在我们可以关闭服务器，转到另一个更酷的闭包实现。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="be66" class="oc la it ny b gy od oe l of og">stop!(serving)</span></pre><h1 id="5e26" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">作为参数的函数</h1><p id="0ba7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">虽然使用这些闭包函数的非常规酷的方式可能是将它们用作 HTTP 服务器的路由函数，但更有可能的情况是，人们最终会看到这些函数被用作参数。这通常是在处理复杂数据结构的基本 Julia 方法中完成的，所以这绝对是你想了解 Julia base 及其生态系统的东西。像这样的函数的一个例子就是过滤器！()函数，它采用一个函数作为筛选依据。这通常是通过匿名函数完成的。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="d76a" class="oc la it ny b gy od oe l of og">x = [5, 10, 15, 20, 25]</span></pre><p id="01cd" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">假设我们想从这个数组中得到的只是 15 以上的值。分离这些值的典型方法是制作一个掩码。掩码是一个 bitarray，意思是一个布尔值数组，它决定每个值是否满足某个条件。我们真正需要做的是设计一个函数，然后应用于每个单独的值，以创建这个掩码。我们使用按位逻辑右操作符<code class="fe oj ok ol ny b">-&gt;</code>创建这些函数。下面是我们如何单独创建该函数的示例:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="8200" class="oc la it ny b gy od oe l of og">x -&gt; x &gt; 15<br/>#11 (generic function with 1 method)</span></pre><p id="0c12" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">或者，我们可以在过滤器的直接调用中定义它！()方法:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="3097" class="oc la it ny b gy od oe l of og">filter!(x -&gt; x &gt; 15, x)</span></pre><p id="42c3" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">虽然我们可以简单地通过名称将函数作为参数传递，但是还有另一个非常好的语法您可能想知道。这种语法称为 do/end 语法，它允许您在给定调用后将函数定义为代码块，然后将该函数作为参数进行处理。作为一个例子，我引用了我的代数数组的实现。这里有两个链接，一个是我详细介绍这些阵列如何工作的文章，另一个是这个项目的笔记本资源:</p><div class="mn mo gp gr mp mq"><a rel="noopener follow" target="_blank" href="/my-new-big-brain-way-to-handle-big-data-creatively-in-julia-57be77fc6a04"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">我在 Julia 中创造性地处理大数据的新大脑方法</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">我想出了为了应用表达式来压缩内存中的大量数据，让我们来看看吧</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">towardsdatascience.com</p></div></div><div class="mz l"><div class="om l nb nc nd mz ne ks mq"/></div></div></a></div><div class="mn mo gp gr mp mq"><a href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/Algebraic%20Arrays.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">Emmetts-DS-笔记本/代数阵列. ipynb at master emmett GB/Emmetts-DS-笔记本</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">各种项目的随机笔记本。通过创建帐户，为 emmettgb/Emmetts-DS 笔记本电脑的开发做出贡献…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">github.com</p></div></div><div class="mz l"><div class="on l nb nc nd mz ne ks mq"/></div></div></a></div><p id="46a1" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">代数数组基本上是可以用某种规范形式表示的数据，所以计算机只计算它需要处理的部分。这个想法是将所有这些内存消耗和事物排除在环境之外，通过选择何时与什么数据进行交互，使科学在更大范围内变得更加可行。Julia 实际上使这个实现变得非常简单，这要归功于完成这类事情所需要的非常简单的多重调度绑定。无论如何，这里是看看什么类型，然后是使用 do/end 语法计算函数。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="5e6a" class="oc la it ny b gy od oe l of og">mutable struct AlgebraicArray<br/>    f::Function<br/>    n::Int64<br/>    calls::Vector{Pair{Function, Tuple}}<br/>    function AlgebraicArray(f::Function, n::Int64)<br/>        new(f, n, [])<br/>    end<br/>end</span></pre><p id="27b1" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">在这之上是生成层，它允许我们为一个调用生成单独的索引。这存在于几种不同的调度形式中，如 range、bitarray 和没有附加参数的代数数组。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="e8e5" class="oc la it ny b gy od oe l of og">function generate(aa::AlgebraicArray, range::UnitRange)<br/>    if range[2] &gt; aa.n<br/>        throw(BoundsError(string("Invalid algebraic index, ", string(range[2], <br/>                        " on algebraic expression of length ", string(aa.n)))))<br/>    end<br/>    [aa.f(n) for n in range]<br/>end</span></pre><p id="8653" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">最后一个前端是计算()。Compute 是通常用来从类似这样的代数运算中获取值的方法。使用 do 语法，我们可以将它作为一个流参数来使用，为了设置它，我们应该像这样构造我们的方法:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="47b9" class="oc la it ny b gy od oe l of og">function compute(f::Function, aa::AlgebraicArray) # compute(aa)<br/>    gen = generate(aa)<br/>    for call in aa.calls<br/>        gen = [call[1](gen, call[2]...)]<br/>    end<br/>    return(f(gen))<br/>end</span></pre><p id="4c50" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">这一努力的最终结果变成了这样的语法:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="8ead" class="oc la it ny b gy od oe l of og">mask = compute(z) do aa<br/>    [if val &gt; 12 true else false end for val in aa[1]]<br/>end<br/>20-element Vector{Bool}:<br/> 0<br/> 0<br/> 0<br/> 0<br/> 0<br/> 1<br/> 1<br/> 1<br/> 1<br/> 1<br/> 1<br/> 1<br/> 1<br/> 1<br/> 1<br/> 1<br/> 1<br/> 1<br/> 1<br/> 1</span></pre><p id="21e9" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">如果您想深入了解这背后的实际代码，并且想了解更多关于它的一般信息，那么我肯定会建议您阅读上面的文章，因为它可能会给出关于这些数组实际如何工作的更多解释。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="5529" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">结论</h1><p id="61de" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">关闭的力量被大大低估了。该技术提供了许多好处和解决困难或复杂问题的新方法，这无疑使它有别于许多其他编程技术和方法。此外，Julian 实现确实允许以一些非常酷的方式使用函数。虽然在其他编程语言中肯定有这种元素，Python/Java 的 lambda 和 Javascript 的函数定义浮现在脑海中，但我必须说我真的更喜欢 Julia 处理这些事情的方式。</p><p id="80af" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">感谢您阅读我的文章，我希望对闭包功能的强调似乎是有道理的。也许在你的下一个项目中，你会用它来解决一些问题，因为它们经常会派上用场！</p></div></div>    
</body>
</html>