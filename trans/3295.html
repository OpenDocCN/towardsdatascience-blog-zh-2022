<html>
<head>
<title>Limiting Python Function Execution Time with a Parameterized Decorator via Multiprocessing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过多重处理使用参数化装饰器限制Python函数的执行时间</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/limiting-a-python-functions-execution-time-using-a-decorator-and-multiprocessing-6fcfe01da6f8#2022-07-22">https://towardsdatascience.com/limiting-a-python-functions-execution-time-using-a-decorator-and-multiprocessing-6fcfe01da6f8#2022-07-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8398" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">限制Python函数执行时间的装饰器</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/67bc0d46f7be4eff45ab60e59ef42aa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OF7Abht6pqgT6hWDgjMEzw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">丹尼尔·利维斯·佩鲁西https://unsplash.com/photos/WxmZT3sIe4gT2<strong class="bd kv">摄影</strong></p></figure><p id="c507" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在本文中，我将带您创建一个装饰器，通过多重处理来限制Python程序中函数的执行时间。我构建这个装饰器的主要动机是用简单的语法和最少的依赖性来限制Python函数的执行时间。</p><p id="25d5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">一种简单的方法是在Python函数中使用一个计时器，定期检查正在执行的Python函数是否超出了限制，然后退出。对于简单的一次性解决方案来说，这种方法可能是可行的，但是任何对第三方库的调用都会阻止检查时间限制。</p><p id="d7bd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我还想要一个尽可能不引人注目的解决方案，并且可以在整个代码库中轻松应用。装饰者提供了很好的语法和抽象来实现这个目标。</p><p id="9669" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">考虑到这一点，我知道我想要创建一个可以附加到我的项目中的任何函数的装饰器。装饰器会将函数的执行时间限制在某个特定的数量。我还想让所有东西都用Python编写，以限制添加这种调度程序的依赖性/复杂性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="3851" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这样做的主要挑战是</p><ol class=""><li id="954a" class="lv lw iq kz b la lb ld le lg lx lk ly lo lz ls ma mb mc md bi translated">装饰者应该为最大执行时间取一个参数，使其易于扩展。</li><li id="a6e7" class="lv lw iq kz b la me ld mf lg mg lk mh lo mi ls ma mb mc md bi translated">修饰函数能够具有任意的输入/输出。</li><li id="e933" class="lv lw iq kz b la me ld mf lg mg lk mh lo mi ls ma mb mc md bi translated">即使正在执行的函数调用了第三方库，计时器也应该工作。</li></ol></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><p id="6b73" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">首先，我需要创建一个可以接受参数作为自变量的装饰器。经过一些研究，我发现了一个优秀的<a class="ae kw" href="https://stackoverflow.com/questions/5929107/decorators-with-parameters." rel="noopener ugc nofollow" target="_blank">堆栈溢出线程</a>，人们在那里提出了几种解决方案。</p><p id="1d25" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我按照彼得·莫滕森在评论中给出的架构为装饰者创建了一个装饰器。我不会深入讨论这是如何工作的，但是你可以进入这个线程来获得更详细的解释。为了获得更多关于装饰者的信息，我经常去<a class="ae kw" href="https://realpython.com/primer-on-python-decorators/" rel="noopener ugc nofollow" target="_blank">这里</a>复习。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="c6be" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然后，您可以将这个装饰器附加到您想要应用到您的函数的装饰器上，允许您参数化该装饰器。我想创建一个<strong class="kz ir"> run_with_timer </strong> decorator，它将最大执行时间作为一个参数。看起来是这样的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div></figure></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><p id="1902" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">接下来，我们可以填充代码来限制执行时间。逻辑如下；主进程将使用Python的多重处理在一个单独的进程中运行修饰函数。主进程将设置一个定时器，如果定时器超时，则终止执行该函数的子进程。</p><p id="27a4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">设置多重处理的代码由两部分组成。第一个是我称为<strong class="kz ir"> function_runner，</strong>的函数，它充当在新进程中运行的包装器，处理Python函数的运行并返回多处理函数可以处理的结果。第二个是多重处理代码，它产生新的进程，设置一个计时器，如果没有及时完成，就终止产生的进程。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="602b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">最后，我可以创建函数来包装我的<strong class="kz ir"> run_with_timer </strong>装饰器。我叫它睡熊。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="a9f4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当我们运行<strong class="kz ir"> sleeping_bear </strong>函数时，如果它超过了装饰参数中设置的时间限制，它就会终止。如果Python函数在时间限制之前完成，那么<strong class="kz ir"> send_end </strong>处理程序将返回结果。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="da57" class="mv mw iq mr b gy mx my l mz na"><strong class="mr ir">sleeping_bear</strong>("Grizzly", hibernation=10)</span><span id="fe41" class="mv mw iq mr b gy nb my l mz na">&gt;&gt; Grizzly is going to hibernate<br/>&gt;&gt; 0 zZZ<br/>&gt;&gt; 1 zZZzZZ<br/>&gt;&gt; 2 zZZzZZzZZ<br/>&gt;&gt; 3 zZZzZZzZZzZZ<br/>&gt;&gt; 4 zZZzZZzZZzZZzZZ<br/>&gt;&gt;<br/>&gt;&gt; TimeExceededException: <strong class="mr ir">Exceeded Execution Time</strong></span><span id="6740" class="mv mw iq mr b gy nb my l mz na"><strong class="mr ir">sleeping_bear</strong>("Grizzly", hibernation=2)</span><span id="9c4d" class="mv mw iq mr b gy nb my l mz na">&gt;&gt; Grizzly is going to hibernate<br/>&gt;&gt; 0 zZZ<br/>&gt;&gt; 1 zZZzZZ<br/>&gt;&gt; <br/>&gt;&gt; "Grizzly is waking up!"</span></pre></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><p id="62d4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">总之，我已经向您展示了如何创建一个装饰器来限制使用多处理作为调度器的Python函数的执行时间。我能够解决三个主要问题。</p><ol class=""><li id="1b4d" class="lv lw iq kz b la lb ld le lg lx lk ly lo lz ls ma mb mc md bi translated">创建一个参数化装饰器来限制最大执行时间。</li><li id="ad34" class="lv lw iq kz b la me ld mf lg mg lk mh lo mi ls ma mb mc md bi translated">允许向被包装的Python函数输入任意参数。</li><li id="c06b" class="lv lw iq kz b la me ld mf lg mg lk mh lo mi ls ma mb mc md bi translated">通过利用多处理模块中的系统级调度程序来限制任何函数的执行时间。</li></ol><p id="6a85" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">另外，这一切都是用Python完成的，没有第三方依赖。启动多处理会有一些开销，但是我的目标是限制长时间运行的函数，所以这不是一个问题。</p><p id="2a86" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果你喜欢这个，一定要关注我，在未来支持更多这样的内容。感谢您的阅读，一如既往，如果您有任何建议或反馈，请在评论中告诉我。</p></div></div>    
</body>
</html>