<html>
<head>
<title>Data Transformations in Scala with Gallia: Version 0.4.0 Is Out</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Gallia的Scala中的数据转换:版本0.4.0已经过时</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-transformations-in-scala-with-gallia-version-0-4-0-is-out-f0b8df3e48f3#2022-10-27">https://towardsdatascience.com/data-transformations-in-scala-with-gallia-version-0-4-0-is-out-f0b8df3e48f3#2022-10-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7202" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">介绍这个增压版本的新功能</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4a3dc2882598ab760b84772fea5bf967.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-QiHSUWChN0V_vgS"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/@theshubhamdhage?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Shubham Dhage </a>拍摄的照片</p></figure><p id="6681" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我之前对Gallia 的<a class="ae kv" rel="noopener" target="_blank" href="/gallia-a-library-for-data-transformation-3fafaaa2d8b9">介绍的后续文章，Gallia是Scala中的模式感知数据转换库。本文将关注最新版本中包含的最重要的变化:</a><a class="ae kv" href="https://github.com/galliaproject/gallia-core/releases/tag/v0.4.0" rel="noopener ugc nofollow" target="_blank"> 0.4.0 </a>(适用于Scala <a class="ae kv" href="https://search.maven.org/artifact/io.github.galliaproject/gallia-core_2.12/0.4.0/jar" rel="noopener ugc nofollow" target="_blank"> 2.12 </a>和<a class="ae kv" href="https://search.maven.org/artifact/io.github.galliaproject/gallia-core_2.13/0.4.0/jar" rel="noopener ugc nofollow" target="_blank"> 2.13 </a>)。</p><p id="3bb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">目录</em> </strong></p><ul class=""><li id="abd7" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated"><a class="ae kv" href="#166d" rel="noopener ugc nofollow"> <em class="ls">读写自阿帕奇Avro/拼花</em></a><em class="ls"><br/></em><strong class="ky ir"><em class="ls">–</em></strong><em class="ls"/><a class="ae kv" href="#ff5d" rel="noopener ugc nofollow"><em class="ls">阿帕奇Avro</em></a><em class="ls"><br/></em><strong class="ky ir"><em class="ls">–</em></strong><em class="ls"/><a class="ae kv" href="#beec" rel="noopener ugc nofollow"><em class="ls">阿帕奇拼花</em> </a></li><li id="f9f4" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><a class="ae kv" href="#d0c0" rel="noopener ugc nofollow"> <em class="ls">从案例类中读取</em> </a></li><li id="0580" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><a class="ae kv" href="#102c" rel="noopener ugc nofollow"> <em class="ls">活接头类型</em> </a></li><li id="a005" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><a class="ae kv" href="#d600" rel="noopener ugc nofollow"> <em class="ls">元模式</em> </a></li><li id="8eca" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><a class="ae kv" href="#a75a" rel="noopener ugc nofollow"> <em class="ls">复杂聚合</em> </a></li><li id="16ee" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><a class="ae kv" href="#e3eb" rel="noopener ugc nofollow"> <em class="ls">复杂转换/共转换</em></a><em class="ls"><br/></em><strong class="ky ir"><em class="ls">–</em></strong><em class="ls"/><a class="ae kv" href="#d204" rel="noopener ugc nofollow"><em class="ls">通过数据类转换(用于嵌套实体)</em></a><em class="ls"><br/></em><strong class="ky ir"><em class="ls">–</em></strong><em class="ls"/><a class="ae kv" href="#9a3b" rel="noopener ugc nofollow"><em class="ls">通过数据类共转换(用于当前级别)</em> </a> <em class="ls"> <br/> </em></li><li id="a401" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><a class="ae kv" href="#069f" rel="noopener ugc nofollow"> <em class="ls">新支持的类型</em></a><em class="ls"><br/></em><strong class="ky ir"><em class="ls">–</em></strong><em class="ls"/><a class="ae kv" href="#4987" rel="noopener ugc nofollow"><em class="ls">枚举</em></a><em class="ls"><br/></em><strong class="ky ir"><em class="ls">–</em></strong><em class="ls"/><a class="ae kv" href="#8a0a" rel="noopener ugc nofollow"><em class="ls">二进制数据</em> </a> <em class="ls"/></li><li id="8267" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><a class="ae kv" href="#e9d4" rel="noopener ugc nofollow"> <em class="ls">结论</em> </a></li></ul></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="166d" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">从Apache Avro/Parquet读取/写入</h1><p id="bd69" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">回想一下上一篇文章，Gallia中的典型处理过程如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="274c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它产生:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="2be3" class="ns mp iq no b gy nt nu l nv nw">&lt;root&gt;<br/> title            _String<br/> air_date         _String<br/> doctor           _Int</span><span id="c3ea" class="ns mp iq no b gy nx nu l nv nw">title                   | air_date         | doctor<br/>----------------------- | ---------------- | ------<br/>THE ELEVENTH HOUR       | 3 April 2010     | 11    <br/>THE DOCTOR'S WIFE       | 14 May 2011      | 11 <br/>...</span></pre><p id="c8e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注:</strong>一个<em class="ls"> TSV </em>版本的剧集数据集可作为要点<a class="ae kv" href="https://gist.github.com/anthony-cros/3db86cca82cf27d0ea42a724bd78555c" rel="noopener ugc nofollow" target="_blank">在此</a>。</p><h2 id="ff5d" class="ns mp iq bd mq ny nz dn mu oa ob dp my lf oc od na lj oe of nc ln og oh ne oi bi translated">阿帕奇Avro</h2><p id="418b" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">类似地，Avro文件现在可以通过以下方式使用:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="ef96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这产生了完全相同的结果。</p><p id="ce4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，可以用<code class="fe oj ok ol no b">.writeAvro(“./mydata.avro”)</code>将结果写入Avro文件</p><p id="0aa7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">备注:</strong></p><ul class=""><li id="955c" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">原始文件本身是否是Avro文件并不重要，因为Gallia中的输入和输出是完全独立的</li><li id="f3b5" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">上述说明的一个直接后果是，人们可以纯粹出于转换目的使用Gallia:<em class="ls">Avro-&gt;JSON，Avro- &gt; TSV，Avro- &gt; Parquet，Parquet- &gt; Avro </em>等。但是有一点需要注意:数据必须符合Gallia的<a class="ae kv" href="https://github.com/galliaproject/gallia-docs/blob/master/modeling.md" rel="noopener ugc nofollow" target="_blank">数据模型</a>(例如，不使用Avro的<a class="ae kv" href="https://avro.apache.org/docs/1.10.2/spec.html#Maps" rel="noopener ugc nofollow" target="_blank">映射</a>，不使用2+D数组等)。</li><li id="11aa" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">将来，<code class="fe oj ok ol no b">streamAvro/writeAvro</code>方法将被通用的<code class="fe oj ok ol no b">stream/write</code>方法所取代，扩展作为参考(参见<a class="ae kv" href="https://github.com/galliaproject/gallia-core/blob/v0.4.0/README.md#io" rel="noopener ugc nofollow" target="_blank"> I/O </a>部分)</li></ul><h2 id="beec" class="ns mp iq bd mq ny nz dn mu oa ob dp my lf oc od na lj oe of nc ln og oh ne oi bi translated">阿帕奇拼花地板</h2><p id="f807" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">要处理拼花文件而不是Avro，代码完全相同，除了:</p><ul class=""><li id="addc" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">模块名称是<code class="fe oj ok ol no b">gallia-<strong class="ky ir">parquet</strong></code>而不是<code class="fe oj ok ol no b">gallia-avro</code></li><li id="a1f3" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">进口是<code class="fe oj ok ol no b">import gallia.<strong class="ky ir">parquet</strong>._</code>而不是<code class="fe oj ok ol no b">import gallia.avro._</code></li><li id="4fe5" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">方法名是<code class="fe oj ok ol no b">stream<strong class="ky ir">Parquet</strong>/write<strong class="ky ir">Parquet</strong></code>而不是<code class="fe oj ok ol no b">streamAvro/writeAvro</code></li></ul><p id="dffc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">备注:</strong></p><ul class=""><li id="8b83" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">Gallia使用罩下的Avro转换器，即<a class="ae kv" href="https://github.com/apache/parquet-mr/blob/apache-parquet-1.12.3/parquet-avro/src/main/java/org/apache/parquet/avro/AvroParquetReader.java" rel="noopener ugc nofollow" target="_blank"><em class="ls">AvroParquetReader</em></a>和<a class="ae kv" href="https://github.com/apache/parquet-mr/blob/apache-parquet-1.12.3/parquet-avro/src/main/java/org/apache/parquet/avro/AvroParquetWriter.java" rel="noopener ugc nofollow" target="_blank"><em class="ls">AvroParquetWriter</em></a></li><li id="d057" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">在未来的版本中，我们将改为提供直接处理，通过Parquet提供的自定义<a class="ae kv" href="https://github.com/apache/parquet-mr/blob/apache-parquet-1.12.3/parquet-hadoop/src/main/java/org/apache/parquet/hadoop/api/ReadSupport.java" rel="noopener ugc nofollow" target="_blank"><em class="ls">read support</em></a>/<a class="ae kv" href="https://github.com/apache/parquet-mr/blob/apache-parquet-1.12.3/parquet-hadoop/src/main/java/org/apache/parquet/hadoop/api/WriteSupport.java" rel="noopener ugc nofollow" target="_blank">/<em class="ls">write support</em></a>抽象</li></ul></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="d0e0" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">从案例类中阅读</h1><p id="de99" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">让我们考虑下面的案例类:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="fb06" class="ns mp iq no b gy nt nu l nv nw">    case class <strong class="no ir">Person</strong>(<strong class="no ir">name</strong>: String, <strong class="no ir">age</strong>: Int, <strong class="no ir">income</strong>: Int)</span></pre><p id="0399" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它现在可以作为一个单一的实体被摄取:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="ca06" class="ns mp iq no b gy nt nu l nv nw">  val peter = gallia.<strong class="no ir"><em class="ls">aobjFromDataClass</em></strong>(<br/>      <strong class="no ir">Person</strong>(<strong class="no ir">name</strong> = "Peter" , <strong class="no ir">age</strong> = 29, <strong class="no ir">income</strong> = 80000))</span></pre><p id="c048" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同时，其集合可以如下摄取:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="aa59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">举个例子，如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="dc47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">会产生预期的:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="4b56" class="ns mp iq no b gy nt nu l nv nw">&lt;root&gt;<br/>  name             _String<br/>  age              _Int<br/>  hourly_rate      _Double</span><span id="3ff3" class="ns mp iq no b gy nx nu l nv nw">name   | age | hourly_rate      <br/>------ | --- | ------------------<br/>Peter  | 29  | 38.31417624521073<br/>Joanna | 29  | 14.367816091954023<br/>Samir  | 28  | 38.31417624521073</span></pre><p id="c72a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意</strong>:虽然Gallia还不允许<strong class="ky ir">将</strong>写入case类，但它将在下一个版本中发布——参见<a class="ae kv" href="https://github.com/galliaproject/gallia-core/blob/2a5c81f/NEXT_RELEASES.md" rel="noopener ugc nofollow" target="_blank"> NEXT_RELEASES </a>(将通过反射和宏允许)</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="102c" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">工会类型</h1><p id="57dd" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">在<a class="ae kv" href="https://github.com/galliaproject/gallia-core/releases/tag/v0.4.0" rel="noopener ugc nofollow" target="_blank"> 0.4.0 </a>中也增加了对联合类型的部分支持。</p><p id="9503" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用法示例如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="4023" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这会产生以下输出:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="315d" class="ns mp iq no b gy nt nu l nv nw">&lt;root&gt; [... schema unchanged]</span><span id="3635" class="ns mp iq no b gy nx nu l nv nw">name  | age<br/>----- | ------------<br/>Peter | 29<br/>Samir | TWENTY-EIGHT</span></pre><p id="711f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为<code class="fe oj ok ol no b">toUpperCase</code>是一个纯字符串操作，所以具有整数值的实体<em class="ls"> age </em>保持不变。</p><p id="c3e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的例子给出了一个简单的例子，但是当然还有更复杂的例子。例如，当多个嵌套实体是一个联合的一部分时:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="7dac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它产生以下输出:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="34dd" class="ns mp iq no b gy nt nu l nv nw">&lt;root&gt; [... schema unchanged]</span><span id="faa6" class="ns mp iq no b gy nx nu l nv nw">{ "data":           "Michael (27yo)" }<br/>{ "data": { "name": "<strong class="no ir">PETER</strong>", "age": 29 }}<br/>{ "data":           "Joanna (29 years old)" }<br/>{ "data": { "name": "Samir", "dob": "March 14, 1971" } }</span></pre><p id="b7b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只有值<code class="fe oj ok ol no b">"Peter"</code>是大写的，因为它是唯一具有<em class="ls"> age </em>条目的嵌套实体。</p><p id="957c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">备注:</strong></p><ul class=""><li id="b1d1" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">参见<a class="ae kv" href="https://github.com/galliaproject/gallia-docs/blob/v0.4.0/union_types.md" rel="noopener ugc nofollow" target="_blank"> union_types.md </a></li><li id="ff30" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">更多的例子可以在<a class="ae kv" href="https://github.com/galliaproject/gallia-testing/blob/v0.4.0/src/main/scala/galliatest/suites/UnionTypeTest.scala" rel="noopener ugc nofollow" target="_blank"> UnionTypeTest.scala </a>中看到</li><li id="01ea" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">Gallia中的联合类型在这一点上仍然被认为是试验性的，并不是所有的操作都支持它们(但是基本的操作支持它们)。</li><li id="10ea" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">支持联合类型的主要原因之一是帮助数据清理/特性工程工作。事实上，在遗留数据集中，用不同类型捕获字段的情况非常普遍(想想<code class="fe oj ok ol no b">true</code>和<code class="fe oj ok ol no b">"Yes"</code>之类的)</li></ul></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="d600" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">元架构</h1><p id="d1cd" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">增加对联合类型支持的结果是Gallia能够提供自己的<a class="ae kv" href="https://github.com/galliaproject/gallia-core/blob/v0.4.0/src/main/scala/gallia/MetaSchema.scala" rel="noopener ugc nofollow" target="_blank">元模式</a>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="f355" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着Gallia可以自己进行模式转换。例如，下面是嵌套字段重命名的样子(这里从<em class="ls"> f </em>到<em class="ls"> F </em>):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="746e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">备注:</strong></p><ul class=""><li id="d110" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">Gallia实际上并没有在内部以这种方式使用元模式</li><li id="8290" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><em class="ls">模式</em>是数据的特例，即<em class="ls">元数据</em>(或“关于数据的数据”)，因此Gallia的<em class="ls">元模式</em>也是<em class="ls">元元数据</em>。而且既然Gallia的<em class="ls"> metaschema </em>也可以用来自己建模，那么它也是自己的<em class="ls">meta schema</em>。因此它也是<em class="ls">元元元数据</em>。很明显。</li></ul></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="a75a" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated"><strong class="ak">复杂聚合</strong></h1><p id="771f" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">让我们重复使用早先中<a class="ae kv" href="https://gist.github.com/anthony-cros/2760c3dbb6f5d9d2f8c3cd41edbb0ba6" rel="noopener ugc nofollow" target="_blank">的<code class="fe oj ok ol no b">people</code>手柄。汇总数据的一个非常简单的方法是:</a></p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="e0fe" class="ns mp iq no b gy nt nu l nv nw">people<em class="ls"><br/>  </em>.<strong class="no ir">group</strong>("name" ~&gt; "names").<strong class="no ir">by</strong>("age")<br/>  .printJsonl()</span></pre><p id="ab0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它产生以下内容:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="8626" class="ns mp iq no b gy nt nu l nv nw">{ "age": 29, "names": [ "Peter", "Joanna" ] }<br/>{ "age": 28, "names": [ "Samir" ] }</span></pre><p id="7e26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也可以(不一定)通过以下方式实现:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="6eda" class="ns mp iq no b gy nt nu l nv nw">people<em class="ls"><br/>  </em>.<strong class="no ir">aggregateBy</strong>("age").as("names")<br/>    .<strong class="no ir">using</strong> { _.strings("name") }<br/>  .printJsonl()</span></pre><p id="ece9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这产生了与上面相同的结果，但是显示了对<code class="fe oj ok ol no b">aggregateBy</code>的简单使用。</p><p id="b6ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然Gallia中有更多的内置聚合器可用(<em class="ls"> SUM BY </em>，<em class="ls"> MEAN BY </em>，…)，但是要在单个操作中实现这样的处理，就需要使用<code class="fe oj ok ol no b">aggregateBy</code>构造:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="d09b" class="ns mp iq no b gy nt nu l nv nw">people<em class="ls"><br/>  </em>.aggregateBy("age").as("names")<br/>    .using { _.strings("name").<strong class="no ir">concatenateStrings</strong> }<br/>  .printJsonl()</span></pre><p id="34ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它产生:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="8bf7" class="ns mp iq no b gy nt nu l nv nw">{ "age": 29, "names": "<strong class="no ir">PeterJoanna</strong>" }<br/>{ "age": 28, "names": "<strong class="no ir">Samir</strong>" }</span></pre><p id="01f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上是:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="4b05" class="ns mp iq no b gy nt nu l nv nw">people<em class="ls"><br/>  </em>.aggregateBy("age").as("names")<br/>    .using { _.strings("name")<br/>      .<strong class="no ir">mapV</strong> { _.reduceLeft(_ + _) } }<br/>  .printJsonl()</span></pre><p id="8ddf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，它可以根据需要进行定制，例如:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="a85a" class="ns mp iq no b gy nt nu l nv nw">people<em class="ls"><br/>  </em>.aggregateBy("age").as("names")<br/>    .using { _.strings("name")<br/>      .mapV { _.reduceLeft(<br/>        <strong class="no ir">_.toUpperCase + "|" + _.toUpperCase</strong>) } }<br/>  .printJsonl()</span></pre><p id="b926" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">生产:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="680d" class="ns mp iq no b gy nt nu l nv nw">{ "age": 29, "names": "<strong class="no ir">PETER|JOANNA</strong>" }<br/>{ "age": 28, "names": "<strong class="no ir">SAMIR</strong>" }</span></pre><p id="dd61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是,<code class="fe oj ok ol no b">aggregateBy</code>构造的真正威力在于能够实现以下更具定制性的聚合类型:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="0a78" class="ns mp iq no b gy nt nu l nv nw">people<em class="ls"><br/>  </em>.aggregateBy("age").using { <strong class="no ir">group</strong> =&gt;<br/>    <strong class="no ir">(</strong>"names"       <strong class="no ir">-&gt;</strong> <strong class="no ir">group</strong>.strings("name")<strong class="no ir">,</strong><br/>     "mean_income" <strong class="no ir">-&gt;</strong> <strong class="no ir">group</strong>.ints   ("income").mean<strong class="no ir">)</strong> }<br/>  .printJsonl()</span></pre><p id="12e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这导致:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="c582" class="ns mp iq no b gy nt nu l nv nw">{"age": 29, "names": [ "Peter", "Joanna" ], "mean_income": 55000.0}<br/>{"age": 28, "names": [ "Samir" ],           "mean_income": 80000.0}</span></pre><p id="66d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意</strong>:上面使用的基于元组的实体创建只是更显式的<code class="fe oj ok ol no b">gallia.headO("names" -&gt; ...)</code>的简写，最多可用于5个条目</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="e3eb" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated"><strong class="ak">复杂的转换/协同转换</strong></h1><p id="4078" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">让我们切换到一个更严肃的领域来突出这些新特性。考虑以下数据集:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="83fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意</strong>:提醒一下<code class="fe oj ok ol no b">bobj</code>和<code class="fe oj ok ol no b">bobjs</code>构造是一种方便的机制，允许构造那些模式很容易推断的实体。因此<code class="fe oj ok ol no b">bobj("f" -&gt; 1)</code>相当于更显式的<code class="fe oj ok ol no b">aobj("f".int)(obj("f" -&gt; 1))</code>。</p><h2 id="d204" class="ns mp iq bd mq ny nz dn mu oa ob dp my lf oc od na lj oe of nc ln og oh ne oi bi translated"><strong class="ak">通过数据类的转换(用于嵌套实体)</strong></h2><p id="39a2" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">Gallia现在提供了通过case类(“数据类”)转换嵌套实体的能力。例如，考虑:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="492b" class="ns mp iq no b gy nt nu l nv nw">case class <strong class="no ir">Change</strong>(<br/>   <strong class="no ir">chromosome</strong>: String,<br/>   <strong class="no ir">position</strong>  : Int   ,<br/>   <strong class="no ir">from</strong>      : String,<br/>   <strong class="no ir">to</strong>        : String) {<br/><br/>  def<strong class="no ir"> shorthand</strong>: String<strong class="no ir"> </strong>=<br/>    s"${<strong class="no ir">chromosome</strong>}:${<strong class="no ir">position</strong>};${<strong class="no ir">from</strong>}&gt;${<strong class="no ir">to</strong>}"<br/><br/>}</span></pre><p id="ec8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它对上面的<code class="fe oj ok ol no b">mutations</code>数据集中的<em class="ls">变化</em>嵌套实体进行建模，并封装一个操作，该操作为遗传变化产生一个简写符号(例如<code class="fe oj ok ol no b">"3:14532127;C&gt;GG"</code>)。</p><p id="9860" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的代码将把<em class="ls">变更</em>实体转换成它的速记副本:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="5ae6" class="ns mp iq no b gy nt nu l nv nw">mutations<br/>  .transformDataClass[<strong class="no ir">Change</strong>]("<strong class="no ir">change</strong>")<br/>    .using(_.<strong class="no ir">shorthand</strong>)<br/>  .display()</span></pre><p id="d243" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它产生:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="c951" class="ns mp iq no b gy nt nu l nv nw">[...]</span><span id="4a6d" class="ns mp iq no b gy nx nu l nv nw">patient_id | age | change<br/>---------- | --- | ----------------<br/>p1         | 23  | 3:14532127;C&gt;GG<br/>p2         | 22  | 4:1554138;C&gt;T<br/>p3         | 21  | Y:16552149;AA&gt;GT</span></pre><p id="d088" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意事项:</p><ul class=""><li id="f7eb" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">这将通过<code class="fe oj ok ol no b">.transformDataClass[<strong class="ky ir">Option</strong>[Change]]</code>、<code class="fe oj ok ol no b"> .transformDataClass[<strong class="ky ir">Seq</strong>[Change]]</code>、<code class="fe oj ok ol no b"> </code>和<code class="fe oj ok ol no b"> .transformDataClass[<strong class="ky ir">Option</strong>[<strong class="ky ir">Seq</strong>[Change]]</code>应用于嵌套实体的可选/必需和单个/多个的任何其他组合</li><li id="670a" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">Gallia的后续版本将利用宏使这种机制更加有效(目前依赖于反射)</li></ul><h2 id="9a3b" class="ns mp iq bd mq ny nz dn mu oa ob dp my lf oc od na lj oe of nc ln og oh ne oi bi translated"><strong class="ak">通过数据类的协同转换(针对当前级别)</strong></h2><p id="b298" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">现在让我们考虑下面的case类，它模拟了当前级别<strong class="ky ir">的字段子集</strong>(这次与嵌套实体相反):</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="990a" class="ns mp iq no b gy nt nu l nv nw">import java.time.Year</span><span id="a84f" class="ns mp iq no b gy nx nu l nv nw">case class <strong class="no ir">Demographics</strong>(<br/>    <strong class="no ir">age</strong>: Int,<br/>    <strong class="no ir">sex</strong>: String) {<br/><br/>  def<strong class="no ir"> </strong>toNewDemographics =<br/>    <strong class="no ir">NewDemographics</strong>(<br/>      <strong class="no ir">year_of_birth</strong>    = Year.<em class="ls">now</em>().getValue - age,<br/>      <strong class="no ir">has_Y_chromosome</strong> = sex == "male")<br/><br/>}</span></pre><p id="78ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以及对期望的模型变化建模的以下case类:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="06a7" class="ns mp iq no b gy nt nu l nv nw">case class <strong class="no ir">NewDemographics</strong>(<br/>    <strong class="no ir">year_of_birth</strong>   : Int,<br/>    <strong class="no ir">has_Y_chromosome</strong>: Boolean)</span></pre><p id="0910" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下代码通过使用origin case类中的封装方法来共同转换这两个字段:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="3fb4" class="ns mp iq no b gy nt nu l nv nw">mutations<br/>  .cotransformViaDataClass[<strong class="no ir">Demographics</strong>]<br/>    .usingWithErasing(_.<strong class="no ir">toNewDemographics</strong>)<br/>  .display()</span></pre><p id="277a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这导致了预期的结果:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="78e3" class="ns mp iq no b gy nt nu l nv nw">&lt;root&gt;<br/> patient_id       _String<br/> year_of_birth    <strong class="no ir">_Int</strong><br/> has_Y_chromosome <strong class="no ir">_Boolean</strong><br/> change ...</span><span id="fabd" class="ns mp iq no b gy nx nu l nv nw">{ "patient_id"      : "p1",<br/>  "change"          : { ... },<br/>  "year_of_birth"   : <strong class="no ir">1999</strong>,<br/>  "has_Y_chromosome": <strong class="no ir">true</strong> }<br/>...</span></pre><p id="1f65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">备注:</strong></p><ul class=""><li id="183d" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">按照现在的情况，分别转换年龄和性别更有意义，但是这里的目标是强调一个联合转换，其中的字段可以任意混合和匹配</li><li id="1658" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><code class="fe oj ok ol no b">.usingWithErasing</code>删除原始条目，而<code class="fe oj ok ol no b">.using</code>会保留它们</li></ul><h2 id="41f6" class="ns mp iq bd mq ny nz dn mu oa ob dp my lf oc od na lj oe of nc ln og oh ne oi bi translated"><strong class="ak">通过定制处理进行联合转换</strong></h2><p id="9756" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">Gallia现在还为真正的定制处理提供了改进的机制，尽管这通常不是一个好主意(因为我们失去了模式/数据将相应地共同发展的保证)。例如，为了重现上面的共同转换，我们可以创建下面的对象，扩展<code class="fe oj ok ol no b">gallia.ObjToObj</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="e0b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的代码将利用它:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="6838" class="ns mp iq no b gy nt nu l nv nw">mutations<br/>  .custom(<strong class="no ir">CustomDemographicsTransformation</strong>)<br/>  .display()</span></pre><p id="47ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将产生相同的输出。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="069f" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated"><strong class="ak">新支持的类型</strong></h1><p id="9150" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">Gallia现在支持其他类型:</p><ul class=""><li id="1a20" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">枚举</li><li id="8649" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">二进制数据</li><li id="5ebe" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">时间类型</li></ul><h2 id="4987" class="ns mp iq bd mq ny nz dn mu oa ob dp my lf oc od na lj oe of nc ln og oh ne oi bi translated">枚举</h2><p id="ad30" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">枚举可以这样创建/使用:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="7d95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它产生:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="65a0" class="ns mp iq no b gy nt nu l nv nw">&lt;root&gt;<br/>  choice           _Enm(List(rock, paper, scissors, <strong class="no ir">spock</strong>))</span><span id="fdc1" class="ns mp iq no b gy nx nu l nv nw">choice<br/>------<br/><strong class="no ir">paper</strong></span></pre><h2 id="8a0a" class="ns mp iq bd mq ny nz dn mu oa ob dp my lf oc od na lj oe of nc ln og oh ne oi bi translated">二进制数据</h2><p id="fe6a" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">可以像这样创建/使用二进制数据:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="5b08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它产生:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="f8f6" class="ns mp iq no b gy nt nu l nv nw">bin<br/>-----------<br/>base64:<strong class="no ir">Ym9v</strong></span></pre><p id="d15e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">备注:</strong></p><ul class=""><li id="529c" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated"><code class="fe oj ok ol no b">"Ym9v"</code>将<code class="fe oj ok ol no b">"boo"</code>编码到<em class="ls"> Base64 </em>中，因为我们在<code class="fe oj ok ol no b">'f'</code>字节(<code class="fe oj ok ol no b">0x66</code>)的地方放了一个<code class="fe oj ok ol no b">'b'</code>字节(<code class="fe oj ok ol no b">0x62</code>)。</li><li id="a42f" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><em class="ls"> Base64 </em>输出仅用于序列化，内存中的表示在整个处理过程中保持不变</li></ul><h2 id="0964" class="ns mp iq bd mq ny nz dn mu oa ob dp my lf oc od na lj oe of nc ln og oh ne oi bi translated">时间类型</h2><p id="c548" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">Gallia中支持的时态类型与它们的Java对应物相匹配:<code class="fe oj ok ol no b">java.time.{LocalDate, LocalTime, LocalDateTime, OffsetDateTime, ZonedDateTime, Instant}</code></p><p id="ea81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们可以这样创建/使用(例如使用<code class="fe oj ok ol no b">LocalDateTime</code>):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="eb50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它产生:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="ff8d" class="ns mp iq no b gy nt nu l nv nw">&lt;root&gt;<br/>   hungover         _LocalDateTime</span><span id="4696" class="ns mp iq no b gy nx nu l nv nw"><strong class="no ir">hungover</strong><br/>-------------------<br/><strong class="no ir">2022-01-01</strong>T00:00:00</span></pre></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="e9d4" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">结论</h1><p id="964c" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">这就结束了我们对<a class="ae kv" href="https://github.com/galliaproject/gallia-core/releases/tag/v0.4.0" rel="noopener ugc nofollow" target="_blank"> 0.4.0 </a>带来的主要变化的浏览，至少是那些将改善客户端代码体验的变化。</p><p id="60d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其他值得注意的新增内容包括:</p><ul class=""><li id="a8eb" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">与<strong class="ky ir"> Python </strong>生态系统的实验性整合:<br/>–<strong class="ky ir">熊猫</strong>:参见<a class="ae kv" href="https://github.com/galliaproject/gallia-python-integration/blob/v0.4.0/gallia-pandas/src/main/scala/gallia/pandas/ScalaPyPandasTest.scala#L10" rel="noopener ugc nofollow" target="_blank"> ScalaPyPandasTest.scala </a>和<a class="ae kv" href="https://github.com/galliaproject/gallia-python-integration/blob/v0.4.0/gallia-python-viz/src/main/scala/gallia/pyviz/GalliaPandasTests.scala#L29" rel="noopener ugc nofollow" target="_blank">gallapandas test . Scala</a>–<strong class="ky ir">Seaborn</strong>:参见<a class="ae kv" href="https://github.com/galliaproject/gallia-python-integration/blob/v0.4.0/gallia-python-viz/src/main/scala/gallia/pyviz/GalliaVizTest.scala#L37-L40" rel="noopener ugc nofollow" target="_blank"> GalliaVizTest.scala </a></li><li id="e63c" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">对<strong class="ky ir">密集数据</strong>进行实验性内存优化，捕获为<code class="fe oj ok ol no b">(size: Int, data: Array[Any])</code>而不是<code class="fe oj ok ol no b">Array((Symbol, Any))</code>，并进行一些相应的操作。参见<a class="ae kv" href="https://github.com/galliaproject/gallia-core/blob/v0.4.0/src/main/scala/gallia/obg9/Obg9.scala" rel="noopener ugc nofollow" target="_blank"> Obg9.scala </a>和<a class="ae kv" href="https://github.com/galliaproject/gallia-testing/blob/v0.4.0/src/main/scala/galliatest/suites/Obg9Test.scala" rel="noopener ugc nofollow" target="_blank"> Obg9Test.scala </a>的示例用法</li></ul><p id="0d53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有关此版本带来的变更和改进的更完整列表，请参见<a class="ae kv" href="https://github.com/galliaproject/gallia-core/blob/2a5c81f/CHANGELOG.md" rel="noopener ugc nofollow" target="_blank"> CHANGELOG.md </a>。</p><p id="e5df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随时欢迎反馈！</p></div></div>    
</body>
</html>