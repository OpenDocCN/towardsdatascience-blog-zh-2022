<html>
<head>
<title>How to Calculate Medians with Grouping in MySQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MySQL 中如何用分组计算中位数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-calculate-medians-with-grouping-in-mysql-abb22a3e5097#2022-12-06">https://towardsdatascience.com/how-to-calculate-medians-with-grouping-in-mysql-abb22a3e5097#2022-12-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3b86" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习高级 MySQL 查询来计算不同场合的中位数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/66cd7a279d1ef31fbb7ec27dc6468896.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ozssbuQUlrZs6erz.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://pixabay.com/illustrations/entrepreneur-diagram-curve-4664726/" rel="noopener ugc nofollow" target="_blank">图片由杰勒特拍摄于 Pixabay </a></p></figure><p id="e9fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在任何编程语言中，计算一组数据的中值都非常简单，即使在 Excel 中，也可以直接使用内置或第三方中值函数。但是，在 MySQL 中，median 函数不是原生支持的。为了得到中间值，我们需要编写一些带有子查询的智能查询。</p><p id="3c05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本帖中，我们将揭开 MySQL 中计算中位数的查询的神秘面纱。特别是，我们将演示如何计算分组字段的中位数。如果一个列有多个类别，这些类别的中位数应该单独计算，那么逐个计算每个类别的中位数就变得很麻烦。在这篇文章中，你可以通过一个简单的查询来计算所有类别的中位数。此外，您还将学习如何同时计算多个列的中位数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="f3b9" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">准备</h2><p id="bcbc" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">首先，我们需要一个 MySQL 服务器，创建一个数据库和表，并插入一些虚拟数据进行处理。我们将使用 Docker 在本地启动一个 MySQL 8 服务器:</p><pre class="kj kk kl km gt na nb nc bn nd ne bi"><span id="0208" class="nf md it nb b be ng nh l ni nj"># Create a volume to persist the data.<br/>$ docker volume create mysql8-data<br/><br/># Create the container for MySQL.<br/>$ docker run --name mysql8 -d -e MYSQL_ROOT_PASSWORD=root -p 13306:3306 -v mysql8-data:/var/lib/mysql mysql:8<br/><br/># Connect to the local MySQL server in Docker.<br/>$ docker exec -it mysql8 mysql -u root -proot<br/><br/>mysql&gt; SELECT VERSION();<br/>+-----------+<br/>| VERSION() |<br/>+-----------+<br/>| 8.0.31    |<br/>+-----------+<br/>1 row in set (0.00 sec)</span></pre><p id="bf78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要编写复杂的 SQL 查询，建议使用 IDE 而不是控制台。IDE 的好处是代码完成、代码格式化、语法突出显示等。在本文中，我们将使用<a class="ae ky" rel="noopener" target="_blank" href="/some-tips-for-using-dbeaver-a-univeral-database-tool-94af18d50671"> DBeaver </a>，这是一个通用的数据库管理工具，可用于管理各种关系数据库和 NoSQL 数据库。然而，任何 IDE 都可以工作。您甚至可以复制本文中演示的查询，并直接在 MySQL 控制台中运行它们。</p><p id="d0ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于 DBeaver，如果遇到“不允许检索公钥”错误，应该编辑连接并为驱动程序添加以下两个用户属性:</p><pre class="kj kk kl km gt na nb nc bn nd ne bi"><span id="2519" class="nf md it nb b be ng nh l ni nj"># User properties<br/>useSSL: false<br/>allowPublicKeyRetrieval: true</span></pre><p id="71c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更多 DBeaver 的设置，请查看<a class="ae ky" rel="noopener" target="_blank" href="/some-tips-for-using-dbeaver-a-univeral-database-tool-94af18d50671">本帖</a>。</p><p id="527b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后运行以下查询来创建数据库、创建表并插入一些虚拟数据:</p><pre class="kj kk kl km gt na nb nc bn nd ne bi"><span id="2d06" class="nf md it nb b be ng nh l ni nj">CREATE DATABASE products;<br/><br/>CREATE TABLE `products`.`prices` (<br/>  `pid` int(11) NOT NULL AUTO_INCREMENT,<br/>  `category` varchar(100) NOT NULL,<br/>  `price` float NOT NULL,<br/>  PRIMARY KEY (`pid`)<br/>);<br/><br/>INSERT INTO products.prices<br/>    (pid, category, price)<br/>VALUES<br/>    (1, 'A', 2),<br/>    (2, 'A', 1),<br/>    (3, 'A', 5),<br/>    (4, 'A', 4),<br/>    (5, 'A', 3),<br/>    (6, 'B', 6),<br/>    (7, 'B', 4),<br/>    (8, 'B', 3),<br/>    (9, 'B', 5),<br/>    (10, 'B', 2),<br/>    (11, 'B', 1)<br/>;</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="f5e0" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">以“经典”方式计算中位数</h2><p id="c487" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">既然数据库和数据已经设置好了，我们可以开始计算中位数了。传统的解决方案是使用 SQL 变量:</p><pre class="kj kk kl km gt na nb nc bn nd ne bi"><span id="f3c1" class="nf md it nb b be ng nh l ni nj">SELECT AVG(sub.price) AS median<br/>FROM ( <br/>    SELECT @row_index := @row_index + 1 AS row_index, p.price<br/>    FROM products.prices p, (SELECT @row_index := -1) r<br/>    WHERE p.category = 'A'<br/>    ORDER BY p.price <br/>) AS sub<br/>WHERE sub.row_index IN (FLOOR(@row_index / 2), CEIL(@row_index / 2))<br/>;<br/><br/>median|<br/>------+<br/>   3.0|</span></pre><p id="e5fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此查询的要点:</p><ul class=""><li id="8cd2" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated"><code class="fe nt nu nv nb b">@row_index</code>是一个 SQL 变量，在<code class="fe nt nu nv nb b">FROM</code>语句中初始化，并在<code class="fe nt nu nv nb b">SELECT</code>语句中为每一行更新。</li><li id="e1da" class="nk nl it lb b lc nw lf nx li ny lm nz lq oa lu np nq nr ns bi translated">应该对将要计算中值的列(本例中的<code class="fe nt nu nv nb b">price</code>列)进行排序。不管是升序还是降序排序都没关系。</li><li id="d8a1" class="nk nl it lb b lc nw lf nx li ny lm nz lq oa lu np nq nr ns bi translated">根据<a class="ae ky" href="https://en.wikipedia.org/wiki/Median" rel="noopener ugc nofollow" target="_blank">对中位数</a>的定义，中位数是中间元素的值(总计数为奇数)或两个中间元素的平均值(总计数为偶数)。在本例中，类别 A 有 5 行，因此中位数是排序后第三行的值。<code class="fe nt nu nv nb b">FLOOR(@row_index / 2)</code>和<code class="fe nt nu nv nb b">CEIL(@row_index / 2)</code>的值都是 2，这是第三行。另一方面，对于具有 6 行的类别 B，中值是第三和第四行的平均值。</li></ul><p id="041a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个解决方案简单易懂。但是，如果表有许多类别，我们需要为每个类别运行查询，这很麻烦，并且结果不容易存储和比较。</p><p id="4c27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们需要一个使用<code class="fe nt nu nv nb b">GROUP BY</code>、<code class="fe nt nu nv nb b">GROUP_CONCAT</code>和<code class="fe nt nu nv nb b"> SUBSTRING_INDEX</code>的非经典解决方案。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="b716" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">灵活计算中位数</h2><p id="94b5" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">让我们一步一步来。最终的查询乍看起来可能很复杂。然而，一旦你知道它是如何工作的，它实际上更容易理解，你可以根据自己的用例自由地改变它。</p><p id="eb8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先获得每个类别的所有排序价格:</p><pre class="kj kk kl km gt na nb nc bn nd ne bi"><span id="5134" class="nf md it nb b be ng nh l ni nj">SELECT<br/>    category,<br/>    GROUP_CONCAT(price ORDER BY p.price) AS prices,<br/>    COUNT(*) AS total<br/>FROM products.prices p<br/>GROUP BY p.category<br/>;<br/><br/>category|prices     |total|<br/>--------+-----------+-----+<br/>A       |1,2,3,4,5  |    5|<br/>B       |1,2,3,4,5,6|    6|</span></pre><p id="b79c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，如果你的表有很多数据，<code class="fe nt nu nv nb b">GROUP_CONCAT</code>不会包含所有的数据。在这种情况下，通过以下方式增加<code class="fe nt nu nv nb b">GROUP_CONCAT</code>的限值:</p><pre class="kj kk kl km gt na nb nc bn nd ne bi"><span id="9403" class="nf md it nb b be ng nh l ni nj">SET GROUP_CONCAT_MAX_LEN = 100000;</span></pre><p id="0d90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以将限制设置为适合您的用例的数字。但是，如果您的表包含太多数据，您可能会遇到内存问题。在这种情况下，您需要编写一些脚本，以更智能的方式执行数据处理和计算。尽管如此，本文中提供的解决方案适用于大多数中小型表。</p><p id="aa59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，让我们获得每个类别的中间元素，我们需要检查总计数是奇数还是偶数，并相应地处理它:</p><pre class="kj kk kl km gt na nb nc bn nd ne bi"><span id="48ae" class="nf md it nb b be ng nh l ni nj">SELECT <br/>    sub1.category,<br/>    sub1.total,<br/>    CASE WHEN MOD(sub1.total, 2) = 1 THEN SUBSTRING_INDEX(SUBSTRING_INDEX(sub1.prices, ',', CEIL(sub1.total/2)), ',', '-1')<br/>         WHEN MOD(sub1.total, 2) = 0 THEN SUBSTRING_INDEX(SUBSTRING_INDEX(sub1.prices, ',', sub1.total/2 + 1), ',', '-2')<br/>    END AS mid_prices<br/>FROM <br/>    (<br/>        SELECT<br/>            p.category,<br/>            GROUP_CONCAT(p.price ORDER BY p.price) AS prices,<br/>            COUNT(*) AS total<br/>        FROM products.prices p<br/>        GROUP BY p.category<br/>    ) sub1<br/>;<br/><br/>category|total|mid_prices|<br/>--------+-----+----------+<br/>A       |    5|3         |<br/>B       |    6|3,4       |</span></pre><p id="57c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用<code class="fe nt nu nv nb b">MOD</code>函数来检查总数是奇数还是偶数。使用了两次<code class="fe nt nu nv nb b">SUBSTRING_INDEX</code>函数来提取中间元素。让我们更详细地演示一下它是如何工作的:</p><pre class="kj kk kl km gt na nb nc bn nd ne bi"><span id="2645" class="nf md it nb b be ng nh l ni nj">-- Categoy A, 5 rows:<br/>SUBSTRING_INDEX('1,2,3,4,5', ',', CEIL(5/2)) =&gt; '1,2,3'<br/>SUBSTRING_INDEX('1,2,3', ',', -1) =&gt; 3<br/><br/>-- Categoy B, 6 rows:<br/>SUBSTRING_INDEX('1,2,3,4,5,6', ',', 6/2 + 1) =&gt; '1,2,3,4'<br/>SUBSTRING_INDEX('1,2,3,4', ',', -2) =&gt; '3,4'</span></pre><p id="6c27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们计算中间元素的平均值，以获得每个类别的中值:</p><pre class="kj kk kl km gt na nb nc bn nd ne bi"><span id="0517" class="nf md it nb b be ng nh l ni nj">SELECT<br/>    sub2.category,<br/>    CASE WHEN MOD(sub2.total, 2) = 1 THEN sub2.mid_prices<br/>         WHEN MOD(sub2.total, 2) = 0 THEN (SUBSTRING_INDEX(sub2.mid_prices, ',', 1) + SUBSTRING_INDEX(sub2.mid_prices, ',', -1)) / 2<br/>    END AS median    <br/>FROM <br/>    (<br/>        SELECT <br/>            sub1.category,<br/>            sub1.total,<br/>            CASE WHEN MOD(sub1.total, 2) = 1 THEN SUBSTRING_INDEX(SUBSTRING_INDEX(sub1.prices, ',', CEIL(sub1.total/2)), ',', '-1')<br/>                 WHEN MOD(sub1.total, 2) = 0 THEN SUBSTRING_INDEX(SUBSTRING_INDEX(sub1.prices, ',', sub1.total/2 + 1), ',', '-2')<br/>            END AS mid_prices<br/>        FROM <br/>            (<br/>                SELECT<br/>                    p.category,<br/>                    GROUP_CONCAT(p.price ORDER BY p.price) AS prices,<br/>                    COUNT(*) AS total<br/>                FROM products.prices p<br/>                GROUP BY p.category<br/>            ) sub1<br/>    ) sub2<br/>;<br/><br/>category|median|<br/>--------+------+<br/>A       |3     |<br/>B       |3.5   |</span></pre><p id="b7c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">干杯！两个类别的中值计算正确。这比传统的解决方案要多一点代码。然而，它更透明，因此更容易理解。此外，它更加灵活，您可以针对不同的用例轻松调整查询，而不仅仅是使用分组来获得不同类别的中值。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="9a3e" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">奖金-计算多列的中间值</h2><p id="e33e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在中间值以上，只计算一列。有了新的解决方案，我们可以很容易地计算多个列的中位数。让我们首先用一些虚拟数据创建一个新表:</p><pre class="kj kk kl km gt na nb nc bn nd ne bi"><span id="ce12" class="nf md it nb b be ng nh l ni nj">CREATE TABLE `products`.`orders` (<br/>  `order_id` int(11) NOT NULL AUTO_INCREMENT,<br/>  `price` float NOT NULL,<br/>  `quantity` float NOT NULL,<br/>  PRIMARY KEY (`order_id`)<br/>);<br/><br/>INSERT INTO products.orders<br/>    (order_id, price, quantity)<br/>VALUES<br/>    (1, 2, 50),<br/>    (2, 1, 40),<br/>    (3, 5, 10),<br/>    (4, 3, 30),<br/>    (5, 4, 20)<br/>;</span></pre><p id="1ff3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这些数据是假的，只是为了演示，因此越简单越好。</p><p id="89e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用于计算多个列的中间值的查询可以很容易地从上面的查询修改而来。不同之处在于，我们不再需要按类别分组，而是需要对需要计算中值的每一列重复查询:</p><pre class="kj kk kl km gt na nb nc bn nd ne bi"><span id="7f17" class="nf md it nb b be ng nh l ni nj">SELECT<br/>    CASE WHEN MOD(sub2.total, 2) = 1 THEN sub2.mid_prices<br/>         WHEN MOD(sub2.total, 2) = 0 THEN (SUBSTRING_INDEX(sub2.mid_prices, ',', 1) + SUBSTRING_INDEX(sub2.mid_prices, ',', -1)) / 2<br/>    END AS median_of_price,<br/>    CASE WHEN MOD(sub2.total, 2) = 1 THEN sub2.mid_quantities<br/>         WHEN MOD(sub2.total, 2) = 0 THEN (SUBSTRING_INDEX(sub2.mid_quantities, ',', 1) + SUBSTRING_INDEX(sub2.mid_prices, ',', -1)) / 2<br/>    END AS median_of_quantity<br/>FROM <br/>    (<br/>        SELECT <br/>            sub1.total,<br/>            CASE WHEN MOD(sub1.total, 2) = 1 THEN SUBSTRING_INDEX(SUBSTRING_INDEX(sub1.prices, ',', CEIL(sub1.total/2)), ',', '-1')<br/>                 WHEN MOD(sub1.total, 2) = 0 THEN SUBSTRING_INDEX(SUBSTRING_INDEX(sub1.prices, ',', sub1.total/2 + 1), ',', '-2')<br/>            END AS mid_prices,<br/>            CASE WHEN MOD(sub1.total, 2) = 1 THEN SUBSTRING_INDEX(SUBSTRING_INDEX(sub1.quantities, ',', CEIL(sub1.total/2)), ',', '-1')<br/>                 WHEN MOD(sub1.total, 2) = 0 THEN SUBSTRING_INDEX(SUBSTRING_INDEX(sub1.quantities, ',', sub1.total/2 + 1), ',', '-2')                 <br/>            END AS mid_quantities<br/>        FROM <br/>            (<br/>                SELECT<br/>                    COUNT(*) AS total,<br/>                    GROUP_CONCAT(o.price ORDER BY o.price) AS prices,<br/>                    GROUP_CONCAT(o.quantity ORDER BY o.quantity) AS quantities<br/>                FROM products.orders o<br/>            ) sub1<br/>    ) sub2<br/>;<br/><br/><br/>median_of_price|median_of_quantity|<br/>---------------+------------------+<br/>3              |30                |</span></pre><p id="e72b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次欢呼，果然有效！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="133a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前，计算中位数的功能还没有在 MySQL 中实现，因此我们需要自己编写一些查询来计算它们。本文介绍了两种解决方案。第一种是使用 SQL 变量的经典解决方案。第二个是新的，用<code class="fe nt nu nv nb b">GROUP_CONCAT</code>和<code class="fe nt nu nv nb b">SUBSTRING_INDEX</code>完成。第二个代码多一点，但是可扩展性更好。您可以使用它来计算不同类别的相同字段的中位数，也可以计算多个字段的中位数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="9ef1" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">相关文章:</h2><ul class=""><li id="bd8b" class="nk nl it lb b lc mv lf mw li ob lm oc lq od lu np nq nr ns bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/some-tips-for-using-dbeaver-a-univeral-database-tool-94af18d50671">使用通用数据库工具 DBeaver 的一些技巧</a></li><li id="d0ab" class="nk nl it lb b lc nw lf nx li ny lm nz lq oa lu np nq nr ns bi translated"><a class="ae ky" href="https://betterprogramming.pub/how-to-execute-plain-sql-queries-with-sqlalchemy-627a3741fdb1" rel="noopener ugc nofollow" target="_blank">如何用 Python 中的 SQLAlchemy 执行普通 SQL 查询</a></li></ul></div></div>    
</body>
</html>