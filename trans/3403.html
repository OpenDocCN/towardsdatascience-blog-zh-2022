<html>
<head>
<title>Exception Handling in Methods of the Multiprocessing Pool Class in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中多处理池类的方法中的异常处理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/exception-handling-in-methods-of-the-multiprocessing-pool-class-in-python-7fbb73746c26#2022-07-28">https://towardsdatascience.com/exception-handling-in-methods-of-the-multiprocessing-pool-class-in-python-7fbb73746c26#2022-07-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6fc4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用map、imap和imap_unordered方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/fac3fb35185bc1eb96226666fdb0285e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JBKqw2WvaKIug_6HtOna7Q.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@marekpiwnicki?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Marek Piwnicki </a>在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><h2 id="b04b" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">介绍</h2><p id="b821" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">处理大数据时，通常需要并行计算。在python中，标准的<a class="ae kv" href="https://docs.python.org/3/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lu ir">多处理</strong> </a>模块通常用于需要大量计算资源的任务。在DS中，我们必须不断地解决容易并行化的问题。示例可以是<a class="ae kv" href="https://medium.com/towards-data-science/bootstrap-and-statistical-inference-in-python-a06d098a8bfd" rel="noopener">引导</a>、多重预测(多个示例的模型预测)、<a class="ae kv" rel="noopener" target="_blank" href="/parallelization-w-multiprocessing-in-python-bd2fc234f516">数据预处理</a>等。</p><p id="4884" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在本文中，我想谈谈在python中使用多重处理<code class="fe mq mr ms mt b"><a class="ae kv" href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing.pool" rel="noopener ugc nofollow" target="_blank">Pool</a></code>类时需要考虑的一些有趣而重要的事情:</p><ul class=""><li id="9378" class="mu mv iq lu b lv ml ly mm lf mw lj mx ln my mk mz na nb nc bi translated">Pool类的方法中的异常处理</li><li id="14a5" class="mu mv iq lu b lv nd ly ne lf nf lj ng ln nh mk mz na nb nc bi translated">python中悬挂函数的处理</li><li id="943d" class="mu mv iq lu b lv nd ly ne lf nf lj ng ln nh mk mz na nb nc bi translated">进程使用的内存限制(仅适用于Unix系统)</li></ul><p id="e474" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">我将在OS Ubuntu 20.04上使用3.9版本的Python。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><p id="f9c3" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">所以让我们开始吧！</p><h2 id="a196" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Pool类的方法中的异常处理</h2><p id="33d2" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">在我的实践中，我经常不得不使用<strong class="lu ir">多重处理</strong>模块。把电脑的所有能力都用上，把处理器的汁液都挤出来，感觉很不错吧？让我们想象一下，你写了非常复杂的代码，你的计算量非常大，以至于你决定在晚上运行它们，希望醒来后能看到你工作的精彩结果。所以，这就是我们美丽的函数(假设我们忘记了不可能除以一个零，有谁没发生呢？)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="f2cc" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">早上你会看到什么？我想你会非常沮丧，因为很明显，你会看到下面的追溯:</p><pre class="kg kh ki kj gt nr mt ns nt aw nu bi"><span id="26db" class="kw kx iq mt b gy nv nw l nx ny">multiprocessing.pool.RemoteTraceback: <br/>"""<br/>Traceback (most recent call last):<br/>  File "/usr/lib/python3.9/multiprocessing/pool.py", line 125, in worker<br/>    result = (True, func(*args, **kwds))<br/>  File "/usr/lib/python3.9/multiprocessing/pool.py", line 48, in mapstar<br/>    return list(map(*args))<br/>  File "/home/PycharmProjects/myproject/main.py", line 9, in my_awesome_foo<br/>    1 / 0<br/>ZeroDivisionError: division by zero<br/>"""</span><span id="b553" class="kw kx iq mt b gy nz nw l nx ny">The above exception was the direct cause of the following exception:</span><span id="643a" class="kw kx iq mt b gy nz nw l nx ny">Traceback (most recent call last):<br/>  File "/home/PycharmProjects/myproject/main.py", line 19, in &lt;module&gt;<br/>    result = p.map(my_awesome_foo, tasks)<br/>  File "/usr/lib/python3.9/multiprocessing/pool.py", line 364, in map<br/>    return self._map_async(func, iterable, mapstar, chunksize).get()<br/>  File "/usr/lib/python3.9/multiprocessing/pool.py", line 771, in get<br/>    raise self._value<br/>ZeroDivisionError: division by zero</span></pre><p id="c875" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">有人会说，这不奇怪，这应该发生，而且绝对正确。但是让我们稍微修改一下我们的代码，试着更详细地了解当一个进程中发生异常时，池内部发生了什么。我们将在我们的功能中添加打印消息的功能，该过程已经开始，我将完成这项工作。使用<strong class="lu ir">多重处理</strong>模块的函数<code class="fe mq mr ms mt b"><a class="ae kv" href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.current_process" rel="noopener ugc nofollow" target="_blank">current_procces().name</a></code>可以获得进程名称。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><pre class="kg kh ki kj gt nr mt ns nt aw nu bi"><span id="b8bf" class="kw kx iq mt b gy nv nw l nx ny">Process ForkPoolWorker-1 started working on task 0<br/>Process ForkPoolWorker-2 started working on task 1<br/>Process ForkPoolWorker-4 started working on task 3<br/>Process ForkPoolWorker-3 started working on task 2<br/>Process ForkPoolWorker-1 started working on task 4<br/>Process ForkPoolWorker-2 ended working on task 1<br/>Process ForkPoolWorker-2 started working on task 5<br/>Process ForkPoolWorker-4 ended working on task 3<br/>Process ForkPoolWorker-4 started working on task 6<br/>Process ForkPoolWorker-2 ended working on task 5<br/>Process ForkPoolWorker-2 started working on task 7<br/>Process ForkPoolWorker-1 ended working on task 4<br/>Process ForkPoolWorker-1 started working on task 8<br/>Process ForkPoolWorker-4 ended working on task 6<br/>Process ForkPoolWorker-4 started working on task 9<br/>Process ForkPoolWorker-3 ended working on task 2<br/>Process ForkPoolWorker-1 ended working on task 8<br/>Process ForkPoolWorker-4 ended working on task 9<br/>Process ForkPoolWorker-2 ended working on task 7<br/>multiprocessing.pool.RemoteTraceback: <br/>"""<br/>Traceback (most recent call last):<br/>  File "/usr/lib/python3.9/multiprocessing/pool.py", line 125, in worker<br/>    result = (True, func(*args, **kwds))<br/>  File "/usr/lib/python3.9/multiprocessing/pool.py", line 48, in mapstar<br/>    return list(map(*args))<br/>  File "/home/PycharmProjects/myproject/main.py", line 9, in my_awesome_foo<br/>    1 / 0<br/>ZeroDivisionError: division by zero<br/>"""</span><span id="12c5" class="kw kx iq mt b gy nz nw l nx ny">The above exception was the direct cause of the following exception:</span><span id="c095" class="kw kx iq mt b gy nz nw l nx ny">Traceback (most recent call last):<br/>  File "/home/PycharmProjects/myproject/main.py", line 19, in &lt;module&gt;<br/>    result = p.map(my_awesome_foo, tasks)<br/>  File "/usr/lib/python3.9/multiprocessing/pool.py", line 364, in map<br/>    return self._map_async(func, iterable, mapstar, chunksize).get()<br/>  File "/usr/lib/python3.9/multiprocessing/pool.py", line 771, in get<br/>    raise self._value<br/>ZeroDivisionError: division by zero</span><span id="9b21" class="kw kx iq mt b gy nz nw l nx ny">Process finished with exit code 1</span></pre><p id="782a" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir">嘭！</strong></p><p id="1408" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">所以我们的函数在第一次迭代时捕捉到了一个异常，但是我们看到了什么呢？我们看到所有的过程都在我们看到出错之前开始并成功完成了它们的工作。事实上，这意味着你的程序真的会通宵工作，但是最后，它仍然以一个错误结束，你不会得到任何结果。很遗憾，不是吗？</p><p id="5d2d" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">这个例子清楚地显示了在使用Pool类的map方法时处理异常是多么重要。那么<code class="fe mq mr ms mt b">imap</code>和<code class="fe mq mr ms mt b">imap_unordered</code>方法呢？这里我们看到更多可预测的行为:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><pre class="kg kh ki kj gt nr mt ns nt aw nu bi"><span id="f991" class="kw kx iq mt b gy nv nw l nx ny">Process ForkPoolWorker-1 started working on task 0<br/>Process ForkPoolWorker-3 started working on task 2<br/>Process ForkPoolWorker-2 started working on task 1<br/>Process ForkPoolWorker-4 started working on task 3<br/>Process ForkPoolWorker-1 started working on task 4<br/>multiprocessing.pool.RemoteTraceback: <br/>"""<br/>Traceback (most recent call last):<br/>  File "/usr/lib/python3.9/multiprocessing/pool.py", line 125, in worker<br/>    result = (True, func(*args, **kwds))<br/>  File "/home/PycharmProjects/myproject/main.py", line 8, in my_awesome_foo<br/>    1 / 0<br/>ZeroDivisionError: division by zero<br/>"""</span><span id="a877" class="kw kx iq mt b gy nz nw l nx ny">The above exception was the direct cause of the following exception:</span><span id="8cff" class="kw kx iq mt b gy nz nw l nx ny">Traceback (most recent call last):<br/>  File "/home/PycharmProjects/myproject/main.py", line 21, in &lt;module&gt;<br/>    result = list(p.imap(my_awesome_foo, tasks))<br/>  File "/usr/lib/python3.9/multiprocessing/pool.py", line 870, in next<br/>    raise value<br/>ZeroDivisionError: division by zero</span><span id="bd49" class="kw kx iq mt b gy nz nw l nx ny">Process finished with exit code 1</span></pre><p id="4ded" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">不幸的是，正确处理<code class="fe mq mr ms mt b">map</code>方法中出现的异常超出了本文的范围。有像<a class="ae kv" href="https://github.com/noxdafox/pebble" rel="noopener ugc nofollow" target="_blank"> <strong class="lu ir"> pebble </strong> </a>这样的库可以让你这么做。</p><p id="2510" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">下面是<code class="fe mq mr ms mt b">imap</code>方法的一个异常处理选项的例子(也适用于<code class="fe mq mr ms mt b">imap_unordered</code>)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><pre class="kg kh ki kj gt nr mt ns nt aw nu bi"><span id="1bcf" class="kw kx iq mt b gy nv nw l nx ny">Process ForkPoolWorker-1 started working on task 0<br/>Process ForkPoolWorker-2 started working on task 1<br/>Process ForkPoolWorker-4 started working on task 3<br/>Process ForkPoolWorker-3 started working on task 2<br/>Process ForkPoolWorker-1 started working on task 4<br/>Process ForkPoolWorker-4 ended working on task 3<br/>Process ForkPoolWorker-4 started working on task 5<br/>Process ForkPoolWorker-2 ended working on task 1<br/>Process ForkPoolWorker-3 ended working on task 2<br/>Process ForkPoolWorker-2 started working on task 6<br/>Process ForkPoolWorker-3 started working on task 7<br/>Process ForkPoolWorker-1 ended working on task 4<br/>Process ForkPoolWorker-1 started working on task 8<br/>Process ForkPoolWorker-4 ended working on task 5<br/>Process ForkPoolWorker-4 started working on task 9<br/>Process ForkPoolWorker-2 ended working on task 6<br/>Process ForkPoolWorker-3 ended working on task 7<br/>Process ForkPoolWorker-1 ended working on task 8<br/>Process ForkPoolWorker-4 ended working on task 9<br/>time took: 3.0<br/>[ZeroDivisionError('division by zero'), 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><span id="fe8e" class="kw kx iq mt b gy nz nw l nx ny">Process finished with exit code 0</span></pre><p id="80aa" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">然后，您可以打印出完整的回溯，看看哪里出错了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><pre class="kg kh ki kj gt nr mt ns nt aw nu bi"><span id="b7fc" class="kw kx iq mt b gy nv nw l nx ny">Traceback (most recent call last):<br/>  File "/usr/lib/python3.9/multiprocessing/pool.py", line 125, in worker<br/>    result = (True, func(*args, **kwds))<br/>  File "/home/PycharmProjects/myproject/main.py", line 9, in my_awesome_foo<br/>    1 / 0<br/>ZeroDivisionError: division by zero<br/>"""</span><span id="509d" class="kw kx iq mt b gy nz nw l nx ny">The above exception was the direct cause of the following exception:</span><span id="83f9" class="kw kx iq mt b gy nz nw l nx ny">Traceback (most recent call last):<br/>  File "/home/PycharmProjects/myproject/main.py", line 23, in &lt;module&gt;<br/>    result.append(next(iterator))<br/>  File "/usr/lib/python3.9/multiprocessing/pool.py", line 870, in next<br/>    raise value<br/>ZeroDivisionError: division by zero</span></pre><p id="e7bb" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">因此，我们成功地捕获了异常，我们的池完成了它的工作，并给了我们结果。此外，我们可以打印整个异常堆栈，并查看代码中发生错误的地方。</p><h2 id="b593" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Python中悬挂函数的处理</h2><p id="94b0" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">让我们改变我们美丽的功能:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="3183" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">对于<em class="oa"> n=0 </em>，我们的函数休眠<em class="oa"> 5 </em>秒，对于所有其他<em class="oa"> n </em>，休眠<em class="oa"> 1 </em>秒。现在想象一下，举例来说，不是5秒，而是5小时。或者更糟，对于一些输入数据，你的函数陷入了一个无限循环。我们不想永远等下去，不是吗？那么在这种情况下该怎么办呢？下面是针对<code class="fe mq mr ms mt b">imap</code>方法的python文档摘录:</p><blockquote class="ob oc od"><p id="2fa1" class="ls lt oa lu b lv ml jr lx ly mm ju ma oe mn mc md of mo mf mg og mp mi mj mk ij bi translated">同样，如果<em class="iq"> chunksize </em>为<code class="fe mq mr ms mt b">1</code>，那么<code class="fe mq mr ms mt b"><a class="ae kv" href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.imap" rel="noopener ugc nofollow" target="_blank">imap()</a></code>方法返回的迭代器的<code class="fe mq mr ms mt b">next()</code>方法有一个可选的<em class="iq">超时</em>参数:如果在<em class="iq">超时</em>秒内不能返回结果，<code class="fe mq mr ms mt b"><em class="iq">next(timeout)</em></code>将引发<code class="fe mq mr ms mt b"><a class="ae kv" href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.TimeoutError" rel="noopener ugc nofollow" target="_blank">multiprocessing.TimeoutError</a></code>。</p></blockquote><p id="a34c" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">因此，让我们尝试使用文档中描述的带有超时参数的迭代器<code class="fe mq mr ms mt b">next()</code>方法。在前一章中，我们学习了如何处理错误，理论上，我们应该正确处理<a class="ae kv" href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.TimeoutError" rel="noopener ugc nofollow" target="_blank"> <strong class="lu ir"> TimeoutError </strong> </a>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="04de" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">这次我们应该看什么？</p><pre class="kg kh ki kj gt nr mt ns nt aw nu bi"><span id="1ed0" class="kw kx iq mt b gy nv nw l nx ny">Process ForkPoolWorker-1 started working on task 0<br/>Process ForkPoolWorker-2 started working on task 1<br/>Process ForkPoolWorker-3 started working on task 2<br/>Process ForkPoolWorker-4 started working on task 3<br/>Process ForkPoolWorker-2 ended working on task 1<br/>Process ForkPoolWorker-3 ended working on task 2<br/>Process ForkPoolWorker-4 ended working on task 3<br/>Process ForkPoolWorker-2 started working on task 4<br/>Process ForkPoolWorker-3 started working on task 5<br/>Process ForkPoolWorker-4 started working on task 6<br/>Process ForkPoolWorker-2 ended working on task 4<br/>Process ForkPoolWorker-3 ended working on task 5<br/>Process ForkPoolWorker-2 started working on task 7</span><span id="5dfa" class="kw kx iq mt b gy nz nw l nx ny">Process ForkPoolWorker-4 ended working on task 6<br/>Process ForkPoolWorker-3 started working on task 8<br/>Process ForkPoolWorker-4 started working on task 9<br/>Process ForkPoolWorker-2 ended working on task 7<br/>Process ForkPoolWorker-4 ended working on task 9<br/>Process ForkPoolWorker-3 ended working on task 8<br/>Process ForkPoolWorker-1 ended working on task 0<br/>time took: 6.0<br/>[TimeoutError(), TimeoutError(), TimeoutError(), TimeoutError(), 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><span id="bef6" class="kw kx iq mt b gy nz nw l nx ny">Process finished with exit code 0</span></pre><p id="2f3f" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir">双啵！</strong></p><p id="0c20" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">我们捕获了超时错误异常<em class="oa"> 4 </em>次并处理了它，而函数在<em class="oa"> n=0 </em>时仍然工作。也就是说，<code class="fe mq mr ms mt b">ForkPoolWorker-1</code>进程本身并没有停止等待<em class="oa"> 5 </em>秒，每隔<em class="oa"> 1.5 </em>秒就会出现一个异常，我们拦截了这个异常。然后<code class="fe mq mr ms mt b">ForkPoolWorker-1</code>进程成功完成其工作并返回值<em class="oa"> 0 </em>。这根本不是我们想要的，是吗？</p><p id="8615" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">这种情况下我们该怎么办？超时过期后如何强行终止进程？</p><p id="41f6" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">让我们考虑一下如何中断函数的执行。可能很多，我知道这甚至可以从键盘上使用键盘快捷键<strong class="lu ir"> Ctr+C </strong>来完成。如何在python中强制中断呢？我们需要向我们的进程发送一个中断信号。让我们看看<code class="fe mq mr ms mt b">os</code>模块的<code class="fe mq mr ms mt b">kill</code>功能的文档:</p><blockquote class="ob oc od"><p id="ead9" class="ls lt oa lu b lv ml jr lx ly mm ju ma oe mn mc md of mo mf mg og mp mi mj mk ij bi translated"><code class="fe mq mr ms mt b"><a class="ae kv" href="https://docs.python.org/3/library/os.html#os.kill" rel="noopener ugc nofollow" target="_blank">os.<strong class="lu ir">kill</strong></a></code> <a class="ae kv" href="https://docs.python.org/3/library/os.html#os.kill" rel="noopener ugc nofollow" target="_blank"> (pid，sig) </a></p><p id="4267" class="ls lt oa lu b lv ml jr lx ly mm ju ma oe mn mc md of mo mf mg og mp mi mj mk ij bi translated">向进程<em class="iq"> pid </em>发送信号<em class="iq"> sig </em>。主机平台上可用的特定信号的常数在<code class="fe mq mr ms mt b"><a class="ae kv" href="https://docs.python.org/3/library/signal.html#module-signal" rel="noopener ugc nofollow" target="_blank">signal</a></code>模块中定义。</p></blockquote><p id="a591" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">查阅<a class="ae kv" href="https://docs.python.org/3/library/signal.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lu ir">信号</strong> </a>模块的文档，可以看到<code class="fe mq mr ms mt b"><a class="ae kv" href="https://docs.python.org/3/library/signal.html#signal.SIGINT" rel="noopener ugc nofollow" target="_blank">SIGINT</a></code>负责从键盘中断(默认动作是抬起<code class="fe mq mr ms mt b"><a class="ae kv" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" rel="noopener ugc nofollow" target="_blank">KeyboardInterrupt</a></code></p><p id="9323" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir">注意:</strong>这种方法只适用于Unix系统。稍后我将描述如何在<strong class="lu ir">窗口</strong>中完成这项工作。</p><blockquote class="ob oc od"><p id="859d" class="ls lt oa lu b lv ml jr lx ly mm ju ma oe mn mc md of mo mf mg og mp mi mj mk ij bi translated"><a class="ae kv" href="https://docs.python.org/3/library/threading.html#threading.Timer" rel="noopener ugc nofollow" target="_blank"> <em class="iq">类</em> </a> <code class="fe mq mr ms mt b"><a class="ae kv" href="https://docs.python.org/3/library/threading.html#threading.Timer" rel="noopener ugc nofollow" target="_blank">threading.<strong class="lu ir">Timer</strong></a></code> <a class="ae kv" href="https://docs.python.org/3/library/threading.html#threading.Timer" rel="noopener ugc nofollow" target="_blank">(区间，函数，args=None，kwargs=None) </a></p><p id="f226" class="ls lt oa lu b lv ml jr lx ly mm ju ma oe mn mc md of mo mf mg og mp mi mj mk ij bi translated">创建一个计时器，在经过<em class="iq">间隔</em>秒后，该计时器将运行<em class="iq">函数</em>，其参数为<em class="iq"> args </em>和关键词参数<em class="iq"> kwargs </em>。如果<em class="iq">参数</em>为<code class="fe mq mr ms mt b">None</code>(默认)，那么将使用空列表。如果<em class="iq"> kwargs </em>为<code class="fe mq mr ms mt b">None</code>(默认值)，那么将使用空字典。</p></blockquote><p id="97e9" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">很好，现在需要的是，我们将创建一个函数来模拟来自键盘的中断，并且我们将在一个等于超时的计时器上运行这个函数。如果它没有来，我们将简单地取消计时器。让我们以装饰器的形式实现我们的想法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="daa0" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">让我们看看它是如何为我们的功能工作的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><pre class="kg kh ki kj gt nr mt ns nt aw nu bi"><span id="07bb" class="kw kx iq mt b gy nv nw l nx ny">Process MainProcess started working on task 0<br/>function my_awesome_foo took longer than 1.5 s.<br/>time took: 1.5</span><span id="2fdc" class="kw kx iq mt b gy nz nw l nx ny">Process finished with exit code 0</span></pre><p id="4aa6" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">一切都如我们所愿！对于基于<strong class="lu ir"> Windows </strong>的系统，可以用<code class="fe mq mr ms mt b"><a class="ae kv" href="https://docs.python.org/3/library/_thread.html#thread.interrupt_main" rel="noopener ugc nofollow" target="_blank">_thread.interrupt_main()</a></code>代替<code class="fe mq mr ms mt b">os.kill()</code>。我在Windows 11上进行了测试，一切正常。让我们看看我们的修饰函数如何与Pool类的<code class="fe mq mr ms mt b">imap</code>方法一起工作:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><pre class="kg kh ki kj gt nr mt ns nt aw nu bi"><span id="8cce" class="kw kx iq mt b gy nv nw l nx ny">Process ForkPoolWorker-2 started working on task 1<br/>Process ForkPoolWorker-1 started working on task 0<br/>Process ForkPoolWorker-4 started working on task 3<br/>Process ForkPoolWorker-3 started working on task 2<br/>Process ForkPoolWorker-2 ended working on task 1<br/>Process ForkPoolWorker-4 ended working on task 3<br/>Process ForkPoolWorker-3 ended working on task 2<br/>Process ForkPoolWorker-4 started working on task 4<br/>Process ForkPoolWorker-2 started working on task 6<br/>Process ForkPoolWorker-3 started working on task 5<br/>Process ForkPoolWorker-1 started working on task 7<br/>Process ForkPoolWorker-3 ended working on task 5<br/>Process ForkPoolWorker-4 ended working on task 4<br/>Process ForkPoolWorker-2 ended working on task 6<br/>Process ForkPoolWorker-4 started working on task 9<br/>Process ForkPoolWorker-3 started working on task 8<br/>Process ForkPoolWorker-1 ended working on task 7<br/>Process ForkPoolWorker-4 ended working on task 9<br/>Process ForkPoolWorker-3 ended working on task 8</span><span id="9927" class="kw kx iq mt b gy nz nw l nx ny">time took: 3.0</span><span id="c4fc" class="kw kx iq mt b gy nz nw l nx ny">['function my_awesome_foo took longer than 1.5 s.', 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><span id="f8ce" class="kw kx iq mt b gy nz nw l nx ny">Process finished with exit code 0</span></pre><p id="0056" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">这就是我们想要的！</p><h2 id="bdc6" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">进程使用的内存限制(仅适用于Unix系统)</h2><p id="72a9" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">现在让我们设想一种情况，您想要限制一个进程可以使用的内存。这可以在Unix系统上使用<a class="ae kv" href="https://docs.python.org/3/library/resource.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lu ir">资源</strong> </a>模块轻松完成。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><pre class="kg kh ki kj gt nr mt ns nt aw nu bi"><span id="dda7" class="kw kx iq mt b gy nv nw l nx ny">Process ForkPoolWorker-1 started working on task 0<br/>Process ForkPoolWorker-2 started working on task 1<br/>Process ForkPoolWorker-3 started working on task 2<br/>Process ForkPoolWorker-4 started working on task 3<br/>Process ForkPoolWorker-1 started working on task 4<br/>Process ForkPoolWorker-4 ended working on task 3<br/>Process ForkPoolWorker-2 ended working on task 1<br/>Process ForkPoolWorker-3 ended working on task 2<br/>Process ForkPoolWorker-2 started working on task 5<br/>Process ForkPoolWorker-3 started working on task 6<br/>Process ForkPoolWorker-4 started working on task 7<br/>Process ForkPoolWorker-1 ended working on task 4<br/>Process ForkPoolWorker-1 started working on task 8<br/>Process ForkPoolWorker-2 ended working on task 5<br/>Process ForkPoolWorker-3 ended working on task 6<br/>Process ForkPoolWorker-4 ended working on task 7<br/>Process ForkPoolWorker-2 started working on task 9<br/>Process ForkPoolWorker-1 ended working on task 8<br/>Process ForkPoolWorker-2 ended working on task 9</span><span id="eb42" class="kw kx iq mt b gy nz nw l nx ny">time took: 3.0</span><span id="cf5f" class="kw kx iq mt b gy nz nw l nx ny">[MemoryError(), 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><span id="58a1" class="kw kx iq mt b gy nz nw l nx ny">Process finished with exit code 0</span></pre><p id="3ff3" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">嗯，就像蛋糕上的樱桃一样，让我们把所有的例子收集到一个例子中，看看我们在这里讨论的所有事情是如何通过使用<a class="ae kv" href="https://pypi.org/project/parallelbar/" rel="noopener ugc nofollow" target="_blank"> <strong class="lu ir"> parallelbar </strong> </a>库的一个命令来完成的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/c140061a6517dcdc86f5b575ce71726e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/1*ESA4z_QW88JIEK99AB5mGw.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="e2d9" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">结果是:</p><pre class="kg kh ki kj gt nr mt ns nt aw nu bi"><span id="74a3" class="kw kx iq mt b gy nv nw l nx ny">time took: 8.2<br/>[MemoryError(), 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, TimeoutError('function my_awesome_foo took longer than 1.5 s.'), 21, 22, 23, 24, 25, 26, 27, 28, 29]</span><span id="e7f3" class="kw kx iq mt b gy nz nw l nx ny">Process finished with exit code 0</span></pre><p id="3042" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">因此，多亏了进度条，我们能够估计到执行结束还剩下多少时间，他还向我们展示了被拦截的错误。</p><p id="af99" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">您可以在我的文章中了解更多关于<strong class="lu ir"> parallelbar </strong>的信息:</p><div class="oi oj gp gr ok ol"><a href="https://medium.com/pythoneers/visualize-your-multiprocessing-calculations-in-python-with-parallelbar-5395651f35aa" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">使用parallelbar模块在python中可视化您的多处理计算</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">也许每个数据科学家迟早都会面临使用多处理器数据处理的需要。在本文中，我们…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">medium.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz kp ol"/></div></div></a></div><p id="9329" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">或者您可以查看<a class="ae kv" href="http://or you can check the documentation" rel="noopener ugc nofollow" target="_blank">文档</a></p><h2 id="4b6e" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h2><ul class=""><li id="0f5d" class="mu mv iq lu b lv lw ly lz lf pa lj pb ln pc mk mz na nb nc bi translated">在本文中，我们以<strong class="lu ir">多重处理</strong>模块的<code class="fe mq mr ms mt b">Pool</code>类为例，简要回顾了python中的多重处理。</li><li id="c363" class="mu mv iq lu b lv nd ly ne lf nf lj ng ln nh mk mz na nb nc bi translated">我们已经看到了如何使用<code class="fe mq mr ms mt b">imap</code>函数在进程池中处理异常。</li><li id="7a17" class="mu mv iq lu b lv nd ly ne lf nf lj ng ln nh mk mz na nb nc bi translated">我们实现了一个装饰器，允许你在指定的超时后中断函数的执行</li><li id="a466" class="mu mv iq lu b lv nd ly ne lf nf lj ng ln nh mk mz na nb nc bi translated">我们以限制使用的内存为例，研究了如何限制进程池中某个进程使用的资源</li><li id="ff28" class="mu mv iq lu b lv nd ly ne lf nf lj ng ln nh mk mz na nb nc bi translated">我们看了一个使用<a class="ae kv" href="https://github.com/dubovikmaster/parallelbar" rel="noopener ugc nofollow" target="_blank"> <strong class="lu ir"> parallelbar </strong> </a>库实现异常处理和限制进程使用资源的小例子</li></ul><p id="0b64" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">我希望这篇文章对你有用！</p></div></div>    
</body>
</html>