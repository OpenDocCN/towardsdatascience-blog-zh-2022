<html>
<head>
<title>How to prepare data for K-fold cross-validation in Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习中如何准备 K 重交叉验证的数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-prepare-data-for-k-fold-cross-validation-in-machine-learning-924a44ec322c#2022-12-19">https://towardsdatascience.com/how-to-prepare-data-for-k-fold-cross-validation-in-machine-learning-924a44ec322c#2022-12-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/ae7c6f1b051dc15605daadb4190a2ec6.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*5Qy406_ubijCkT5yXord8w.jpeg"/></div><p class="jx jy gj gh gi jz ka bd b be z dk translated">作者图片</p></figure><p id="4fc0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">交叉验证是第一个用来避免过度拟合和数据泄漏的技术，当我们想要在我们的数据上训练一个预测模型的时候。</p><p id="556c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它的功能是必不可少的，因为它允许我们<strong class="kd iu">以一种安全的方式</strong>对我们的数据进行功能和逻辑测试——也就是说，避免这些过程污染我们的验证数据。</p><p id="c094" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们想做预处理、特征工程或其他转换，<strong class="kd iu">我们必须首先正确地划分我们的数据。</strong></p><p id="2743" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这确保了我们的验证数据实际上代表了我们的训练集，并且(可能)也代表了我们还没有的真实世界的数据。</p><p id="e51e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，如果我们能够<a class="ae kz" rel="noopener" target="_blank" href="/building-your-own-dataset-benefits-approach-and-tools-6ab096e37f2">创建一个数据集</a>并对我们的数据进行适当的划分，那么我们就可以相对确定我们从训练中观察到的结果实际上是可用的并且是无偏差的。</p><h1 id="2c38" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">如何为交叉验证准备数据</h1><p id="dd0c" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">正如我在关于<a class="ae kz" rel="noopener" target="_blank" href="/what-is-cross-validation-in-machine-learning-14d2a509d6a5">交叉验证以及如何在 Python </a>中应用它的文章中所写的，其中一个基本步骤是根据折叠(数据集部分)对<strong class="kd iu">目标变量进行分层。</strong></p><p id="d1cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样做是为了防止可能的类不平衡对模型的性能产生负面影响。</p><p id="6851" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，在二元分类的情况下，可能 80%的类别是肯定的，而只有 20%是否定的。训练模型而不考虑这种不平衡可能会导致不可靠的结果。</p><p id="d11a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有一些数据平衡技术，但是我们不会在本文中涉及它们。相反，我将解释如何使用 Python、Pandas 和 Sklearn <strong class="kd iu">创建一个带有额外列的数据集，该列将指示数据集中的一行属于哪个文件夹。</strong></p><blockquote class="md"><p id="f6ee" class="me mf it bd mg mh mi mj mk ml mm ky dk translated">对于数据集的每个样本，我们将指出它属于哪个折叠，以便我们可以在每个折叠上测试我们的算法，使我们的评估总体上更加稳健。</p></blockquote><p id="3062" class="pw-post-body-paragraph kb kc it kd b ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky im bi translated">让我们看看如何在 Python 中应用这个过程。</p><p id="43c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们从导入基本库开始</p><pre class="ms mt mu mv gt mw mx my bn mz na bi"><span id="521a" class="nb lb it mx b be nc nd l ne nf">import pandas as pd<br/>from sklearn import model_selection</span></pre><p id="3f63" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设我们的训练数据在路径为<code class="fe ng nh ni mx b">./data/dataset_train.csv</code>的文件中，让我们用 Pandas 导入它，并创建一个名为 fold 的列，我们用值-1 初始化它。这是因为我们的折叠值将从 0 开始。</p><pre class="ms mt mu mv gt mw mx my bn mz na bi"><span id="0ecf" class="nb lb it mx b be nc nd l ne nf"># import our training dataset<br/>df = pd.read_csv("./data/dataset_train.csv")<br/><br/># define a new column named 'fold'<br/>df["fold"] = -1</span></pre><p id="d42d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通常数据集是混洗的——我们使用<code class="fe ng nh ni mx b">.sample</code>进行推理。我们将使用参数<code class="fe ng nh ni mx b">frac=1</code>告诉 Pandas 获取整个数据集并随机采样。事实上，这将以简单有效的方式打乱数据集的每一行。</p><pre class="ms mt mu mv gt mw mx my bn mz na bi"><span id="e679" class="nb lb it mx b be nc nd l ne nf">df = df.sample(frac=1).reset_index(drop=True)</span></pre><p id="04e2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">既然我们已经打乱了数据集，我们可以定义我们的目标变量，将其传递给<code class="fe ng nh ni mx b">sklearn.model_selection.StratifiedKFold</code>来对数据集进行分层。我们将使用一个任意的数字 5 作为我们的折叠。</p><p id="2bcb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦创建了对象，我们就遍历数据集的每一行，并将 Sklearn 生成的部分应用于之前具有常数值-1 的列。</p><p id="b906" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">完成后，我们保存数据集。</p><pre class="ms mt mu mv gt mw mx my bn mz na bi"><span id="ccfe" class="nb lb it mx b be nc nd l ne nf">y = df["target"].values<br/><br/># we initialize the kfold object with 5 slices<br/>kf = model_selection.StratifiedKFold(n_splits=5)<br/><br/># populate the fold column<br/>for fold, (train_idx, valid_idx) in enumerate(kf.split(X=df, y=y)):<br/>    df.loc[valid_idx, "fold"] = fold<br/><br/># save the dataset<br/>df.to_csv("./data/dataset_train_folds.csv")</span></pre><p id="86a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们有了一个数据集，除了它最初拥有的列之外，现在还有一个额外的列来指示要在其上执行验证的折叠。</p><p id="f019" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看整个剧本。</p><pre class="ms mt mu mv gt mw mx my bn mz na bi"><span id="ab47" class="nb lb it mx b be nc nd l ne nf">import pandas as pd<br/>from sklearn import model_selection<br/><br/>if __name__ == "__main__":<br/><br/>    # import our training dataset<br/>    df = pd.read_csv("./data/dataset_train.csv")<br/>    <br/>    # define a new column named 'fold'<br/>    df["fold"] = -1<br/>    <br/>    # shuffle the dataset<br/>    df = df.sample(frac=1).reset_index(drop=True)<br/>    <br/>    # initialize the target variable y<br/>    y = df["target"].values<br/><br/>    # we initialize the kfold object with 5 slices<br/>    kf = model_selection.StratifiedKFold(n_splits=5)<br/>    <br/>    # populate the fold column<br/>    for fold, (train_idx, valid_idx) in enumerate(kf.split(X=df, y=y)):<br/>        df.loc[valid_idx, "fold"] = fold<br/>    <br/>    # save the dataset<br/>    df.to_csv("./data/dataset_train_folds.csv")</span></pre><p id="9a5f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们可以运行这个脚本，只需简单地更改数据集在磁盘上的路径，就可以创建一个带有验证折叠的副本<strong class="kd iu">。</strong></p><p id="17e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">这种方法是完全可扩展的，几乎可以用于任何机器学习问题。</strong></p><h1 id="5103" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="a219" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在这篇简短的文章中，我与你分享了一段代码，我可能会在每个机器学习项目中使用<strong class="kd iu">。</strong></p><p id="7a19" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">事实上，在即将到来的项目中不使用它对我来说会很奇怪。<strong class="kd iu">它适用于传统的机器学习，也适用于深度学习。</strong></p><p id="6bc9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦数据被分割成多个折叠，我们就可以遍历每个折叠，一次一个折叠地测试我们的假设。这是强大的。</p><p id="95b0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">如果您想支持我的内容创作活动，请随时关注我下面的推荐链接，并加入 Medium 的会员计划</strong>。我将收到你投资的一部分，你将能够以无缝的方式访问 Medium 的大量数据科学文章。</p><div class="nj nk gp gr nl nm"><a href="https://medium.com/@theDrewDag/membership" rel="noopener follow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd iu gy z fp nr fr fs ns fu fw is bi translated">通过我的推荐链接加入 Medium-Andrew D # data science</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">阅读 Andrew D #datascience(以及媒体上成千上万的其他作者)的每一个故事。您的会员费直接…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">medium.com</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa jv nm"/></div></div></a></div><p id="6c4d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望我对你的教育有所贡献。下次见！👋</p></div></div>    
</body>
</html>