<html>
<head>
<title>River: Online Machine Learning in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">river:Python 中的在线机器学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/river-online-machine-learning-in-python-d0f048120e46#2022-12-06">https://towardsdatascience.com/river-online-machine-learning-in-python-d0f048120e46#2022-12-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7d10" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一种在生产中更新 ML 模型的快速廉价方法</h2></div><h1 id="505b" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">批量学习的问题</h1><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="9973" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">数据从业者使用批量学习从数据中学习是很常见的。批量学习就是批量训练 ML 模型。批量学习的 ML 管道通常包括:</p><ul class=""><li id="c6ee" class="md me it lj b lk ll ln lo lq mf lu mg ly mh mc mi mj mk ml bi translated">将数据分为训练集和测试集</li><li id="5e02" class="md me it lj b lk mm ln mn lq mo lu mp ly mq mc mi mj mk ml bi translated">将模型拟合到列车组</li><li id="2744" class="md me it lj b lk mm ln mn lq mo lu mp ly mq mc mi mj mk ml bi translated">在测试集上计算模型的性能</li><li id="3e1f" class="md me it lj b lk mm ln mn lq mo lu mp ly mq mc mi mj mk ml bi translated">将模型推向生产</li></ul><p id="0f34" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然而，在生产中，流水线并没有到此为止。为了确保模型在输入数据发生变化时是稳健的，数据从业者还需要定期对新数据集和现有数据集的组合进行重新训练。</p><p id="3e3e" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">随着数据的增长，训练模型需要更多的时间和资源。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/78e9bf7d8ee6cba3e665f9f700c1295a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zqlGFR_QvU3zVZFT7CwPMg.gif"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">批量学习演示(作者)</p></figure><p id="9313" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">因此，批量学习在以下情况下并不理想:</p><ul class=""><li id="d8be" class="md me it lj b lk ll ln lo lq mf lu mg ly mh mc mi mj mk ml bi translated">应用程序需要频繁的模型更新。</li><li id="7806" class="md me it lj b lk mm ln mn lq mo lu mp ly mq mc mi mj mk ml bi translated">公司负担不起存储和训练大数据的计算资源。</li></ul><h1 id="64f9" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">在线学习简介</h1><p id="13b4" class="pw-post-body-paragraph lh li it lj b lk nc ju lm ln nd jx lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated">在在线学习中，模型是在数据流而不是整个数据集上进行增量训练的。换句话说，模型每次只从一个观察值或一小组观察值中学习。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/3a76782f9e719033059c6e7d8f2b95e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nFUpJK-9iRvJlDUZH377rA.gif"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">在线学习演示(作者)</p></figure><p id="b005" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">因此，每个学习步骤既快又便宜，这使得它非常适合快速变化的应用程序和计算资源有限的公司。</p><p id="ac28" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本文中，您将学习如何使用 River 对流数据进行机器学习。</p><p id="5cf3" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">随意发挥，并在这里叉这篇文章的源代码:</p><div class="nh ni gp gr nj nk"><a href="https://github.com/khuyentran1401/Data-science/blob/master/machine-learning/river_streaming/streaming.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">数据科学/streaming . ipynb at master khuyentran 1401/数据科学</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">github.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny mw nk"/></div></div></a></div><h1 id="cf88" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">什么是河流？</h1><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="6893" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><a class="ae nz" href="https://github.com/online-ml/river" rel="noopener ugc nofollow" target="_blank"> River </a>是一个在线机器学习的 Python 库。要安装 River，请键入:</p><pre class="la lb lc ld gt oa ob oc bn od oe bi"><span id="a21f" class="of kj it ob b be og oh l oi oj">pip install river</span></pre><p id="cc71" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在接下来的几节中，我们将比较使用 scikit-learn 进行批量学习和使用 River 进行在线学习。</p><h1 id="83ec" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">准备数据</h1><p id="2666" class="pw-post-body-paragraph lh li it lj b lk nc ju lm ln nd jx lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated">在做任何新奇的事情之前，我们将从准备数据开始。</p><p id="6905" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">从 seaborn 导入<code class="fe ok ol om ob b">penguins</code>数据集:</p><pre class="la lb lc ld gt oa ob oc bn od oe bi"><span id="696a" class="of kj it ob b be og oh l oi oj">import seaborn as sns<br/><br/>df = sns.load_dataset("penguins")</span></pre><p id="555c" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">查看数据的信息:</p><pre class="la lb lc ld gt oa ob oc bn od oe bi"><span id="6203" class="of kj it ob b be og oh l oi oj">df.info()</span></pre><pre class="on oa ob oc bn od oe bi"><span id="3425" class="of kj it ob b be og oh l oi oj">Data columns (total 7 columns):<br/> #   Column             Non-Null Count  Dtype  <br/>---  ------             --------------  -----  <br/> 0   species            344 non-null    object <br/> 1   island             344 non-null    object <br/> 2   bill_length_mm     342 non-null    float64<br/> 3   bill_depth_mm      342 non-null    float64<br/> 4   flipper_length_mm  342 non-null    float64<br/> 5   body_mass_g        342 non-null    float64<br/> 6   sex                333 non-null    object</span></pre><p id="bf96" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">创建特征数据(<code class="fe ok ol om ob b">X</code>)和标签数据(<code class="fe ok ol om ob b">y</code>):</p><pre class="la lb lc ld gt oa ob oc bn od oe bi"><span id="0f81" class="of kj it ob b be og oh l oi oj">target = 'species'<br/>y = df[target]<br/>X = df.drop(target, axis=1)</span></pre><p id="f173" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在我们准备用 scikit-learn 和 River 创建一个 ML 管道！</p><h1 id="4286" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">使用 scikit-learn 进行批量学习</h1><p id="a7f2" class="pw-post-body-paragraph lh li it lj b lk nc ju lm ln nd jx lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated">导入有用的库:</p><pre class="la lb lc ld gt oa ob oc bn od oe bi"><span id="93ee" class="of kj it ob b be og oh l oi oj">from sklearn.model_selection import train_test_split<br/>from sklearn.pipeline import make_pipeline<br/>from sklearn.impute import SimpleImputer<br/>from sklearn.preprocessing import OneHotEncoder<br/>from sklearn.tree import DecisionTreeClassifier<br/>from sklearn.compose import ColumnTransformer<br/>from sklearn.metrics import confusion_matrix, f1_score</span></pre><p id="57a1" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了在批量学习中训练模型，我们通常从将数据集分成训练集和测试集开始:</p><pre class="la lb lc ld gt oa ob oc bn od oe bi"><span id="86aa" class="of kj it ob b be og oh l oi oj">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=1)</span></pre><p id="f88a" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">使用 scikit-learn 的转换器和分类器创建管道:</p><pre class="la lb lc ld gt oa ob oc bn od oe bi"><span id="b70b" class="of kj it ob b be og oh l oi oj"># Get numerical and categorical features<br/>numeric_features = X_train.select_dtypes(exclude=object).columns<br/>categorical_features = X_train.select_dtypes(include=object).columns<br/><br/># Specify transformers for each type of features<br/>numeric_transformer = SimpleImputer()<br/>categorical_transformer = make_pipeline(<br/>    SimpleImputer(strategy="most_frequent"), OneHotEncoder()<br/>)<br/>preprocessor = ColumnTransformer(<br/>    transformers=[<br/>        ("num", numeric_transformer, numeric_features),<br/>        ("cat", categorical_transformer, categorical_features),<br/>    ]<br/>)<br/><br/># Create a pipeline with transformers and classifier<br/>sklearn_clf = make_pipeline(preprocessor, DecisionTreeClassifier())</span></pre><p id="2be4" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">管道概述:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi oo"><img src="../Images/0165dfd5d67ed11919ced0f50741d13f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vFmoER0Dvm2-AHa_EMgD3A.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">作者图片</p></figure><p id="7762" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">训练模型并预测测试数据:</p><pre class="la lb lc ld gt oa ob oc bn od oe bi"><span id="65bb" class="of kj it ob b be og oh l oi oj"># Train the model<br/>sklearn_clf.fit(X_train, y_train)<br/><br/># Get prediction<br/>y_pred = sklearn_clf.predict(X_test)</span></pre><p id="c37b" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这些步骤对于数据从业者来说是非常标准的。让我们把这段代码变成在线学习，比较两种方法的区别。</p><h1 id="fb42" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">用 River 进行在线学习</h1><h2 id="a04f" class="op kj it bd kk oq or dn ko os ot dp ks lq ou ov ku lu ow ox kw ly oy oz ky pa bi translated">流过数据集</h2><p id="f130" class="pw-post-body-paragraph lh li it lj b lk nc ju lm ln nd jx lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated">导入有用的库:</p><pre class="la lb lc ld gt oa ob oc bn od oe bi"><span id="d9e3" class="of kj it ob b be og oh l oi oj">from river import (<br/>    stream,<br/>    compose,<br/>    preprocessing,<br/>    evaluate,<br/>    metrics,<br/>    tree,<br/>    imblearn,<br/>    stats,<br/>)<br/>import numbers import numbers</span></pre><p id="6f4e" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在在线学习中，观察是一次提供一个。我们将通过用<code class="fe ok ol om ob b">stream.iter_pandas</code>遍历两个熊猫数据帧(<code class="fe ok ol om ob b">X</code>和<code class="fe ok ol om ob b">y</code>)的每一行来模仿这种行为:</p><pre class="la lb lc ld gt oa ob oc bn od oe bi"><span id="7c0c" class="of kj it ob b be og oh l oi oj">for xi, yi in stream.iter_pandas(X, y):<br/>    pass</span></pre><p id="57f1" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们看看最后的<code class="fe ok ol om ob b">xi</code>和<code class="fe ok ol om ob b">yi</code>是什么样子的:</p><pre class="la lb lc ld gt oa ob oc bn od oe bi"><span id="9a19" class="of kj it ob b be og oh l oi oj">&gt;&gt;&gt; xi<br/>{'island': 'Biscoe',<br/> 'bill_length_mm': 49.9,<br/> 'bill_depth_mm': 16.1,<br/> 'flipper_length_mm': 213.0,<br/> 'body_mass_g': 5400.0,<br/> 'sex': 'MALE'}<br/><br/>&gt;&gt;&gt; yi<br/>'Gentoo'</span></pre><h2 id="846c" class="op kj it bd kk oq or dn ko os ot dp ks lq ou ov ku lu ow ox kw ly oy oz ky pa bi translated">计算运行统计</h2><p id="a225" class="pw-post-body-paragraph lh li it lj b lk nc ju lm ln nd jx lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated">由于数据集中有一些缺失值，我们将用数据集的平均值来估算缺失值。</p><p id="dcdf" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了找到数据集的平均值，我们将数据集中的 N 个非空值相加，然后将结果除以 N。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/11a547355c8a3dcd0431e92417ed37e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*socHr0JAfVKAxsFJxEl-PQ.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">作者图片</p></figure><p id="85ad" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在在线学习中，我们不能应用相同的程序来计算平均值，因为我们不知道整个数据集的值。因此，我们将使用<em class="pb">运行统计数据</em>来估计平均值。</p><p id="d656" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">要计算移动平均值，只要有新值就更新平均值。然后使用运行平均值来更新缺失值。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/15f3d1da932551295ee563d815a7cd94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Vyb23sqIJhaVG9tqz7nV4w.gif"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">作者图片</p></figure><p id="6435" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在 River 中，我们可以使用<code class="fe ok ol om ob b">preprocessing.StatImputer</code>用一个运行统计来替换丢失的值。</p><p id="99b8" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了从一个实例中学习并转换该实例，我们将使用<code class="fe ok ol om ob b">learn_one</code>方法和<code class="fe ok ol om ob b">transform_one</code>方法。</p><pre class="la lb lc ld gt oa ob oc bn od oe bi"><span id="63da" class="of kj it ob b be og oh l oi oj">X_sample = [{"age": 10}, {"age": 30}, {"age": None}, {"age": 2}]<br/>mean = stats.Mean()<br/>imputer = preprocessing.StatImputer(("age", mean))<br/>for xi_sample in X_sample:<br/>    imputer.learn_one(xi_sample)<br/>    print(imputer.transform_one(xi_sample))</span></pre><pre class="on oa ob oc bn od oe bi"><span id="abcd" class="of kj it ob b be og oh l oi oj">{'age': 10}<br/>{'age': 30}<br/>{'age': 20.0}<br/>{'age': 2}</span></pre><h2 id="bc48" class="op kj it bd kk oq or dn ko os ot dp ks lq ou ov ku lu ow ox kw ly oy oz ky pa bi translated">创建一个 ML 管道</h2><p id="3f70" class="pw-post-body-paragraph lh li it lj b lk nc ju lm ln nd jx lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated"><code class="fe ok ol om ob b">river.compose</code>提供了几种类似于<code class="fe ok ol om ob b">sklearn.compose</code>的方法来构建机器学习管道。</p><p id="4547" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们使用这些方法来创建一个转换分类和数字特征的管道:</p><pre class="la lb lc ld gt oa ob oc bn od oe bi"><span id="341e" class="of kj it ob b be og oh l oi oj">cat = (<br/>    compose.SelectType(object)<br/>    | preprocessing.StatImputer()<br/>    | preprocessing.OneHotEncoder(sparse=True)<br/>)<br/>num = compose.SelectType(numbers.Number) | preprocessing.StatImputer()<br/>preprocessor = num + cat</span></pre><p id="e523" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">使用管道学习和转换观察结果:</p><pre class="la lb lc ld gt oa ob oc bn od oe bi"><span id="330c" class="of kj it ob b be og oh l oi oj">preprocessor.learn_one(xi)<br/>preprocessor.transform_one(xi)</span></pre><pre class="on oa ob oc bn od oe bi"><span id="f121" class="of kj it ob b be og oh l oi oj">{'island_Biscoe': 1,<br/> 'bill_length_mm_49.9': 1,<br/> 'bill_depth_mm_16.1': 1,<br/> 'flipper_length_mm_213.0': 1,<br/> 'body_mass_g_5400.0': 1,<br/> 'sex_MALE': 1,<br/> 'bill_length_mm': 49.9,<br/> 'bill_depth_mm': 16.1,<br/> 'flipper_length_mm': 213.0,<br/> 'body_mass_g': 5400.0}</span></pre><p id="896e" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最后，我们将使用决策树算法从数据中学习。</p><p id="11ae" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">传统的批量决策树无法处理在线学习需求，因为当有新的观察值时，它们需要用整个数据集进行重新训练。</p><p id="1bb4" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">因此，我们将使用<a class="ae nz" href="https://riverml.xyz/0.14.0/api/tree/HoeffdingTreeClassifier/" rel="noopener ugc nofollow" target="_blank"> Hoeffding 树</a> (HT)分类器进行在线学习。HT 是迄今为止最流行的增量决策树家族。</p><pre class="la lb lc ld gt oa ob oc bn od oe bi"><span id="b0cf" class="of kj it ob b be og oh l oi oj">classifier = tree.HoeffdingTreeClassifier()</span></pre><blockquote class="pc pd pe"><p id="3220" class="lh li pb lj b lk ll ju lm ln lo jx lp pf lr ls lt pg lv lw lx ph lz ma mb mc im bi translated">了解更多关于<a class="ae nz" href="https://maxhalford.github.io/slides/online-decision-trees.pdf" rel="noopener ugc nofollow" target="_blank">决策树在线机器学习</a>。</p></blockquote><p id="6888" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">接下来，将转换器和超线程分类器结合到一个管道中，转换数据并从中学习:</p><pre class="la lb lc ld gt oa ob oc bn od oe bi"><span id="d1c9" class="of kj it ob b be og oh l oi oj">def get_pipeline():<br/>    cat = (<br/>        compose.SelectType(object)<br/>        | preprocessing.StatImputer()<br/>        | preprocessing.OneHotEncoder(sparse=True)<br/>    )<br/>    num = compose.SelectType(numbers.Number) | preprocessing.StatImputer()<br/>    classifier = tree.HoeffdingTreeClassifier()<br/><br/>    return (num + cat) | classifier<br/><br/>pipeline = get_pipeline()</span></pre><p id="3c19" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">可视化管道:</p><pre class="la lb lc ld gt oa ob oc bn od oe bi"><span id="80bc" class="of kj it ob b be og oh l oi oj">pipeline</span></pre><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/f4a0b1186e8dd844346b304194d66112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UhStwUQir8H9lm2Hx5FWTQ.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">作者图片</p></figure><h2 id="e179" class="op kj it bd kk oq or dn ko os ot dp ks lq ou ov ku lu ow ox kw ly oy oz ky pa bi translated">训练模型并预测新的观察结果</h2><p id="8381" class="pw-post-body-paragraph lh li it lj b lk nc ju lm ln nd jx lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated">让我们使用这个管道来创建一个函数，该函数根据数据流进行预测并训练一个模型:</p><pre class="la lb lc ld gt oa ob oc bn od oe bi"><span id="fa5e" class="of kj it ob b be og oh l oi oj">def train(X, y):<br/>    pipeline = get_pipeline()<br/><br/>    # Initialize metrics <br/>    f1_score = metrics.MicroF1()<br/>    cm = metrics.ConfusionMatrix()<br/><br/>    f1_scores = []<br/><br/>    # Iterate over the dataset<br/>    for xi, yi in stream.iter_pandas(X, y, shuffle=True, seed=1):<br/>        # Predict the new sample<br/>        yi_pred = pipeline.predict_one(xi)<br/><br/>        # Get the score<br/>        if yi_pred is not None:<br/>            f1_score.update(yi, yi_pred)<br/>            f1_scores.append(f1_score.get() * 100)<br/>            cm.update(yi, yi_pred)<br/><br/>        # Train the model with the new sample<br/>        pipeline.learn_one(xi, yi)<br/><br/>    return f1_scores, cm, pipeline<br/><br/><br/>f1_scores, cm, pipeline = train(X, y)</span></pre><p id="5610" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在上面的代码中，我们遍历了每个样本。对于每个样本，我们:</p><ul class=""><li id="9ff5" class="md me it lj b lk ll ln lo lq mf lu mg ly mh mc mi mj mk ml bi translated">用现有模型预测新样本</li><li id="00d4" class="md me it lj b lk mm ln mn lq mo lu mp ly mq mc mi mj mk ml bi translated">计算新预测的微观平均 F1 分数和混淆矩阵，然后更新现有分数</li><li id="1f4c" class="md me it lj b lk mm ln mn lq mo lu mp ly mq mc mi mj mk ml bi translated">将新的 F1 分数保存到 F1 分数列表中，以供进一步分析</li><li id="1fa2" class="md me it lj b lk mm ln mn lq mo lu mp ly mq mc mi mj mk ml bi translated">用新样本训练模型并更新模型</li></ul><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/57a99c5f62f54a12f124638f781ff5ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*1ALM6vXR3nEa21IcJubPsQ.gif"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">作者图片</p></figure><p id="c50e" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们检查树分类器的参数:</p><pre class="la lb lc ld gt oa ob oc bn od oe bi"><span id="7728" class="of kj it ob b be og oh l oi oj">pipeline.steps['HoeffdingTreeClassifier'].summary</span></pre><pre class="on oa ob oc bn od oe bi"><span id="cfe9" class="of kj it ob b be og oh l oi oj">{'n_nodes': 1,<br/> 'n_branches': 0,<br/> 'n_leaves': 1,<br/> 'n_active_leaves': 1,<br/> 'n_inactive_leaves': 0,<br/> 'height': 1,<br/> 'total_observed_weight': 344.0}</span></pre><p id="3ee3" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">随着迭代次数的增加，用线形图直观显示分数的变化。</p><pre class="la lb lc ld gt oa ob oc bn od oe bi"><span id="aff6" class="of kj it ob b be og oh l oi oj">import matplotlib.pyplot as plt <br/><br/>def plot(scores: list):<br/>    iters = range(len(scores))<br/>    ax = sns.lineplot(x=iters, y=scores)<br/>    ax.set(xlabel='num_iters', ylabel='score')<br/>    plt.show()<br/>    <br/>plot(f1_scores)</span></pre><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/a0bac991e3a5ddb1fe102ad7afddc852.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*NrL7EWk33ZeigPzGBeQakA.png"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">作者图片</p></figure><p id="25d9" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以看到，微 F1 分数在第 150 次迭代前后达到最高值，然后下降。</p><p id="3cc0" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们还可以使用<code class="fe ok ol om ob b">evaluate.progressive_val_score</code>方法在流数据集上评估模型的性能:</p><pre class="la lb lc ld gt oa ob oc bn od oe bi"><span id="1dc5" class="of kj it ob b be og oh l oi oj">metric = metrics.MicroF1()<br/><br/>evaluate.progressive_val_score(<br/>    dataset=stream.iter_pandas(X, y, shuffle=True, seed=1),<br/>    model=pipeline,<br/>    metric=metric,<br/>    print_every=50, # print every 50 iterations<br/>)</span></pre><pre class="on oa ob oc bn od oe bi"><span id="e87f" class="of kj it ob b be og oh l oi oj">[50] MicroF1: 73.47%<br/>[100] MicroF1: 84.85%<br/>[150] MicroF1: 88.59%<br/>[200] MicroF1: 83.42%<br/>[250] MicroF1: 74.70%<br/>[300] MicroF1: 68.90%<br/>MicroF1: 64.72%</span></pre><p id="3647" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最终分数相当低。让我们通过查看混淆矩阵来深入了解模型性能:</p><pre class="la lb lc ld gt oa ob oc bn od oe bi"><span id="5263" class="of kj it ob b be og oh l oi oj">cm</span></pre><pre class="on oa ob oc bn od oe bi"><span id="409b" class="of kj it ob b be og oh l oi oj">            Adelie   Chinstrap   Gentoo  <br/>   Adelie      143           8        0  <br/>Chinstrap       44          22        2  <br/>   Gentoo       66           1       57</span></pre><p id="ad50" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以看到，大多数错误预测被归类为<code class="fe ok ol om ob b">Adelie</code>物种。这可能是因为数据不平衡。我们可以通过查看<code class="fe ok ol om ob b">y</code>中每个值的计数来确认这一点。</p><pre class="la lb lc ld gt oa ob oc bn od oe bi"><span id="c868" class="of kj it ob b be og oh l oi oj">y.value_counts()</span></pre><pre class="on oa ob oc bn od oe bi"><span id="3609" class="of kj it ob b be og oh l oi oj">Adelie       152<br/>Gentoo       124<br/>Chinstrap     68</span></pre><p id="8c2a" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当检查<code class="fe ok ol om ob b">y</code>的值时，我们可以看到<code class="fe ok ol om ob b">Adelie</code>标签比其他标签多。</p><p id="eb57" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在下一节中，我们将学习如何用 River 处理不平衡数据集。</p><h1 id="4f93" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">处理不平衡数据</h1><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="a183" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了处理不平衡的数据，我们将使用<code class="fe ok ol om ob b">RandomSampler</code>类来调整每个标签的样本数量，这允许我们获得目标分布。</p><p id="d4b4" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><code class="fe ok ol om ob b">RandomSampler</code>使用<a class="ae nz" href="https://machinelearningmastery.com/random-oversampling-and-undersampling-for-imbalanced-classification/" rel="noopener ugc nofollow" target="_blank">欠采样和过采样</a>来适应指定的约束。</p><p id="fdaa" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">例如，在下面的示例中，<code class="fe ok ol om ob b">desired_dist={"Adelie": 0.1, "Gentoo": 0.4, "Chinstrap": 0.5}</code>告诉 River 对数据进行采样，以便分类器遇到 10%的<code class="fe ok ol om ob b">Adelie</code>，40%的<code class="fe ok ol om ob b">Gentoo</code>，以及 50%的<code class="fe ok ol om ob b">Chinstrap</code>。</p><pre class="la lb lc ld gt oa ob oc bn od oe bi"><span id="e258" class="of kj it ob b be og oh l oi oj">classifier = tree.HoeffdingTreeClassifier()<br/>sampler = imblearn.RandomSampler(<br/>    classifier=classifier,<br/>    desired_dist={"Adelie": 0.1, "Gentoo": 0.4, "Chinstrap": 0.5},<br/>    seed=2,<br/>)</span></pre><p id="f273" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们将<code class="fe ok ol om ob b">RandomSampler</code>类合并到我们的管道中，看看性能是否有所提高:</p><pre class="la lb lc ld gt oa ob oc bn od oe bi"><span id="eae4" class="of kj it ob b be og oh l oi oj">def get_pipeline():<br/>    # Specify the transfomers<br/>    cat = (<br/>        compose.SelectType(object)<br/>        | preprocessing.StatImputer()<br/>        | preprocessing.OneHotEncoder(sparse=True)<br/>    )<br/>    num = compose.SelectType(numbers.Number) | preprocessing.StatImputer()<br/><br/>    # Specify classifiers<br/>    classifier = tree.HoeffdingTreeClassifier()<br/>    sampler = imblearn.RandomSampler(<br/>        classifier=classifier,<br/>        desired_dist={"Adelie": 0.1, "Gentoo": 0.4, "Chinstrap": 0.5},<br/>        seed=2,<br/>    ) <br/>    return (num + cat) | sampler<br/><br/>f1_scores, cm, pipeline = train(X, y)</span></pre><p id="8d46" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">绘制跨迭代的微观平均 F1 分数:</p><pre class="la lb lc ld gt oa ob oc bn od oe bi"><span id="0636" class="of kj it ob b be og oh l oi oj">plot(f1_scores)</span></pre><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/29f290de4663b8ed7d465de5cd4e1f7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*IBQg_vMlmWrNNTFKZQJXUA.png"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">作者图片</p></figure><p id="62cf" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">微观平均 F1 分数最初在最初几次迭代中降低，然后在后面的迭代中增加。</p><p id="c9fc" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">混淆矩阵还显示使用<code class="fe ok ol om ob b">RandomSampler</code>时有更多的正确预测。</p><pre class="la lb lc ld gt oa ob oc bn od oe bi"><span id="41f1" class="of kj it ob b be og oh l oi oj">cm</span></pre><pre class="on oa ob oc bn od oe bi"><span id="5780" class="of kj it ob b be og oh l oi oj">            Adelie   Chinstrap   Gentoo  <br/>   Adelie      111          37        3  <br/>Chinstrap        5          62        1  <br/>   Gentoo        5           6      113  </span></pre><p id="5c2d" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们调用<code class="fe ok ol om ob b">evaluate.progressive_val_score</code>方法来获得每次迭代的 F1 分数:</p><pre class="la lb lc ld gt oa ob oc bn od oe bi"><span id="1db0" class="of kj it ob b be og oh l oi oj">pipeline = get_pipeline()<br/><br/>metric = metrics.MicroF1()<br/><br/>evaluate.progressive_val_score(<br/>    dataset=stream.iter_pandas(X, y, shuffle=True, seed=1),<br/>    model=pipeline,<br/>    metric=metric,<br/>    print_every=50,<br/>)</span></pre><pre class="on oa ob oc bn od oe bi"><span id="bdfb" class="of kj it ob b be og oh l oi oj">[50] MicroF1: 42.86%<br/>[100] MicroF1: 67.68%<br/>[150] MicroF1: 75.17%<br/>[200] MicroF1: 75.88%<br/>[250] MicroF1: 80.32%<br/>[300] MicroF1: 82.61%<br/>MicroF1: 83.38%</span></pre><p id="6efa" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">不错！使用<code class="fe ok ol om ob b">RandomSampler</code>时最终微均 F1 分 83.38%。</p><h1 id="7556" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">结论</h1><p id="c082" class="pw-post-body-paragraph lh li it lj b lk nc ju lm ln nd jx lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated">恭喜你！您刚刚学习了如何使用 River 进行在线机器学习。我希望这篇文章能给你创建一个生产就绪的机器学习模型所需的知识。</p></div><div class="ab cl pj pk hx pl" role="separator"><span class="pm bw bk pn po pp"/><span class="pm bw bk pn po pp"/><span class="pm bw bk pn po"/></div><div class="im in io ip iq"><p id="b91e" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我喜欢写一些基本的数据科学概念，并尝试不同的数据科学工具。你可以在 LinkedIn 和 T2 Twitter 上与我联系。</p><p id="1414" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">星<a class="ae nz" href="https://github.com/khuyentran1401/Data-science" rel="noopener ugc nofollow" target="_blank">这个回购</a>如果你想检查我写的所有文章的代码。在 Medium 上关注我，了解我的最新数据科学文章，例如:</p><div class="nh ni gp gr nj nk"><a rel="noopener follow" target="_blank" href="/statsannotations-add-statistical-significance-annotations-on-seaborn-plots-6b753346a42a"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">statan 注释:在 Seaborn 图上添加统计显著性注释</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">从三行代码的比较中获得洞察力</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">towardsdatascience.com</p></div></div><div class="nt l"><div class="pq l nv nw nx nt ny mw nk"/></div></div></a></div><div class="nh ni gp gr nj nk"><a rel="noopener follow" target="_blank" href="/texthero-text-preprocessing-representation-and-visualization-for-a-pandas-dataframe-525405af16b6"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">Texthero:熊猫数据帧的文本预处理、表示和可视化</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">用一行 Python 代码处理您的文本</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">towardsdatascience.com</p></div></div><div class="nt l"><div class="pr l nv nw nx nt ny mw nk"/></div></div></a></div><div class="nh ni gp gr nj nk"><a rel="noopener follow" target="_blank" href="/shap-explain-any-machine-learning-model-in-python-24207127cad7"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">SHAP:用 Python 解释任何机器学习模型</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">SHAP 和沙普利价值观综合指南</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">towardsdatascience.com</p></div></div><div class="nt l"><div class="ps l nv nw nx nt ny mw nk"/></div></div></a></div><div class="nh ni gp gr nj nk"><a rel="noopener follow" target="_blank" href="/predict-movie-ratings-with-user-based-collaborative-filtering-392304b988af"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">通过基于用户的协作过滤预测电影分级</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">Python 中协作过滤的全面介绍</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">towardsdatascience.com</p></div></div><div class="nt l"><div class="pt l nv nw nx nt ny mw nk"/></div></div></a></div><h1 id="4545" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">参考</h1><p id="69fe" class="pw-post-body-paragraph lh li it lj b lk nc ju lm ln nd jx lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated">库马尔，A. (2022，4 月 7 日)。<em class="pb">区别在线&amp;批量学习</em>。数据分析。2022 年 12 月 5 日检索，来自<a class="ae nz" href="https://vitalflux.com/difference-between-online-batch-learning" rel="noopener ugc nofollow" target="_blank">https://vital flux . com/difference-between-online-batch-learning</a></p></div></div>    
</body>
</html>