<html>
<head>
<title>Optimize Your SQL Code with This Window Function</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用这个窗口函数优化你的 SQL 代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/optimize-your-sql-code-with-this-window-function-409d3341cb20#2022-02-16">https://towardsdatascience.com/optimize-your-sql-code-with-this-window-function-409d3341cb20#2022-02-16</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""/><div class=""><h2 id="33fd" class="pw-subtitle-paragraph js iu iv bd b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj dk translated">通过使用 FIRST_VALUE()来替换您痛苦的 cte</h2></div><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/7cdfdea4ec74bd0e73b3f41c1aa49a24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-0kna50rBV73MOLtIYGnMw.jpeg"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">照片由<a class="ae la" href="https://unsplash.com/@saycheezestudios?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Say Cheeze 工作室</a>在<a class="ae la" href="https://unsplash.com/s/photos/first?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="b4c2" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我们都遇到过这种 SQL 代码块…它很容易阅读，但是它的某些部分就是，嗯，<em class="lx">烦人的</em>。通常，可以用一个查询编写的代码被视为 CTE。</p><p id="010a" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在清理一些旧的数据模型时，我遇到过很多这样的代码。其他代码很容易修复，因为读起来很痛苦，而且如何改进也很简单。然而，这并不是板上钉钉的事。</p><p id="5467" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我说的是什么 SQL 代码？</p><p id="d0af" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这个。</p><h1 id="d246" class="ly lz iv bd ma mb mc md me mf mg mh mi kb mj kc mk ke ml kf mm kh mn ki mo mp bi translated">问题是</h1><pre class="kl km kn ko gt mq mr ms mt aw mu bi"><span id="efad" class="mv lz iv mr b gy mw mx l my mz">WITH</span><span id="3321" class="mv lz iv mr b gy na mx l my mz">orders AS (<br/>   SELECT <br/>      name, <br/>      model,<br/>      year, <br/>      date_at_lot<br/>      row_number() over(partition by model, year order by date_at_lot asc) AS order<br/>   FROM cars <br/>)</span><span id="c359" class="mv lz iv mr b gy na mx l my mz">SELECT<br/>   name AS oldest_car_name,<br/>   model, <br/>   year<br/>FROM orders<br/>where order = 1 </span></pre><p id="b22d" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这是一个你非常想把它写得更好，但又不确定如何去做的 cte。这并不是说它超级低效，但是如果你不断地写这样的查询，读起来就变得多余了。</p><p id="a1d3" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">还有，可以的话为什么不优化一下呢？</p><h1 id="add5" class="ly lz iv bd ma mb mc md me mf mg mh mi kb mj kc mk ke ml kf mm kh mn ki mo mp bi translated">解决方案</h1><p id="4210" class="pw-post-body-paragraph lb lc iv ld b le nb jw lg lh nc jz lj lk nd lm ln lo ne lq lr ls nf lu lv lw io bi translated">如果你熟悉<a class="ae la" rel="noopener" target="_blank" href="/how-to-use-sql-window-functions-5d297d29f810">窗口功能</a>，那么你可能已经知道我在这里暗示的功能。然而，这个窗口功能并没有得到应有的重视。</p><p id="fc32" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">当我第一次学习窗口函数的时候，我从来没有接触过这个函数！你经常听说<code class="fe ng nh ni mr b"><a class="ae la" rel="noopener" target="_blank" href="/how-to-use-sql-rank-and-dense-rank-functions-7c3ebf84b4e8?source=your_stories_page----------------------------------------">LEAD()</a></code>、<code class="fe ng nh ni mr b"><a class="ae la" rel="noopener" target="_blank" href="/how-to-use-sql-rank-and-dense-rank-functions-7c3ebf84b4e8">RANK()</a></code>、<code class="fe ng nh ni mr b">ROW_NUMBER()</code>，但从来没听说过<code class="fe ng nh ni mr b">FIRST_VALUE()</code>。</p><h2 id="69f4" class="mv lz iv bd ma nj nk dn me nl nm dp mi lk nn no mk lo np nq mm ls nr ns mo nt bi translated">FIRST_VALUE()返回有序、分区数据输出中的第一个值。</h2><p id="65fb" class="pw-post-body-paragraph lb lc iv ld b le nb jw lg lh nc jz lj lk nd lm ln lo ne lq lr ls nf lu lv lw io bi translated">它基本上取代了在一个查询中使用<code class="fe ng nh ni mr b">ROW_NUMBER()</code>然后在下一个查询中使用<code class="fe ng nh ni mr b">column = 1</code>进行过滤的需要。</p><p id="a985" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">它的工作原理与任何其他窗口函数相同，您可以在其中指定希望对数据进行分区的列以及希望对它们进行排序的顺序。</p><h2 id="a658" class="mv lz iv bd ma nj nk dn me nl nm dp mi lk nn no mk lo np nq mm ls nr ns mo nt bi translated">分割</h2><p id="e55c" class="pw-post-body-paragraph lb lc iv ld b le nb jw lg lh nc jz lj lk nd lm ln lo ne lq lr ls nf lu lv lw io bi translated">如果您不熟悉的话，<code class="fe ng nh ni mr b">PARTITION BY</code>帮助对数据进行分组，以便对每个分区重新开始计数。</p><p id="e6ab" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">例如，使用<code class="fe ng nh ni mr b">FIRST_VALUE()</code>时按型号和年份划分会将数据分成不同的组，这些组具有相同的汽车型号和年份。然后，在这些组中，它将根据组的排序方式找到第一个值。</p><p id="b818" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">所有 2013 款福特 Escapes 将被分组在一起，然后所有 2013 款福特 Escapes 的<strong class="ld iw"> first_value </strong>将作为输出，这取决于<code class="fe ng nh ni mr b">ORDER BY</code>子句中指定的内容。</p><p id="5256" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">如果不包含<code class="fe ng nh ni mr b">PARTITION BY</code>子句，该函数会将整个数据集视为一个单独的分区。</p><h2 id="68f6" class="mv lz iv bd ma nj nk dn me nl nm dp mi lk nn no mk lo np nq mm ls nr ns mo nt bi translated">排序</h2><p id="e469" class="pw-post-body-paragraph lb lc iv ld b le nb jw lg lh nc jz lj lk nd lm ln lo ne lq lr ls nf lu lv lw io bi translated">有了 first_value 函数，<code class="fe ng nh ni mr b">ORDER BY</code>就显得尤为重要。如果你用错了方法，你可能得到的是最后一个值而不是第一个值。在对数据分区进行排序时，确保使用<code class="fe ng nh ni mr b">ASC</code>或<code class="fe ng nh ni mr b">DESC</code>来正确指定排序。</p><p id="c982" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">例如，如果您想要某个型号的最新汽车，您想要<code class="fe ng nh ni mr b">ORDER BY date_at_lot DESC </code>。但是，如果您想要某个型号的批次中最老的汽车，您需要编码<code class="fe ng nh ni mr b">ORDER BY date_at_lot ASC</code>。</p><p id="a883" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">您也可以选择使用<code class="fe ng nh ni mr b">LAST_VALUE()</code>函数，其工作方式相同，但选择数据子集中的最后一个值，而不是第一个值。这完全取决于您如何对数据进行排序。</p><p id="c593" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">那么，使用<code class="fe ng nh ni mr b">ROW_NUMBER()</code>的例子和使用<code class="fe ng nh ni mr b">FIRST_VALUE()</code>的例子会是什么样子呢？让我展示给你看。</p><pre class="kl km kn ko gt mq mr ms mt aw mu bi"><span id="7de5" class="mv lz iv mr b gy mw mx l my mz">SELECT <br/>   FIRST_VALUE(name) OVER(PARTITION BY model, year ORDER BY date_at_lot ASC) AS oldest_car_name<br/>   model,<br/>   year<br/>FROM cars</span></pre><p id="23b3" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">注意我是如何在函数的<code class="fe ng nh ni mr b">FIRST_VALUE()</code>部分包含<code class="fe ng nh ni mr b">name</code>的。这样做将导致该函数输出第一辆汽车的名称。您可以在这里指定任何列，但是这个名称最有意义，因为它在不同的型号和年份中都是唯一的。</p><h1 id="92cc" class="ly lz iv bd ma mb mc md me mf mg mh mi kb mj kc mk ke ml kf mm kh mn ki mo mp bi translated">结论</h1><p id="4267" class="pw-post-body-paragraph lb lc iv ld b le nb jw lg lh nc jz lj lk nd lm ln lo ne lq lr ls nf lu lv lw io bi translated">现在您已经准备好进一步优化您的 SQL 代码了！停止使用<code class="fe ng nh ni mr b">ROW_NUMBER()</code>切换到<code class="fe ng nh ni mr b">FIRST_VALUE()</code>对第一个输出进行滤波。这个功能的创建是有原因的，现在是我们都开始使用它的时候了！</p><p id="60bf" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">不断改进你的代码是成为更好的程序员、分析师、工程师等的关键。当我们停止进步，我们就停止成长。我强烈建议对您的旧代码进行这样的小改动，不断优化它，并不断学习。</p><p id="bc10" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">如果你想获得更多关于编写 SQL、成为一名<a class="ae la" rel="noopener" target="_blank" href="/analytics-engineer-the-newest-data-career-role-b312a73d57d7">分析工程师</a>或学习现代数据堆栈的技巧，请订阅我即将发布的<a class="ae la" href="https://mailchi.mp/e04817c8e57e/learn-analytics-engineering" rel="noopener ugc nofollow" target="_blank">时事通讯</a>。</p></div></div>    
</body>
</html>