<html>
<head>
<title>Mastering Dynamic Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握动态编程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/mastering-dynamic-programming-a627dbdf0229#2022-02-28">https://towardsdatascience.com/mastering-dynamic-programming-a627dbdf0229#2022-02-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="354f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解基本原理，知道何时以及如何应用这种优化技术</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4412103052351880ce92d9f2531da2f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c0gU2CkZ880j1_pfnGS1fw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">除特别注明外，所有图片均为作者所有</em></p></figure><p id="11e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> A </span>你期待去FAANG这样的大科技公司面试吗？如果是这样，请准备好进行一轮或多轮技术编码评估。</p><p id="3804" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，越来越多的公司已经开始在数据科学家、机器学习工程师或软件工程师职位的面试过程中纳入技术编码评估。</p><p id="5748" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种评估通常测试候选人的数据库和SQL数据操作技能，或者数据结构和算法的问题解决和编程技能。后者通常包括动态编程，这是一种优化技术，可以产生时间或空间复杂度降低的高效代码。</p><p id="405a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们行动起来，开始学习动态编程。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="9ad7" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated"><strong class="ak">内容</strong></h1><p id="74ae" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated"><a class="ae ni" href="#5517" rel="noopener ugc nofollow"> <strong class="lb iu"> 1。动态编程的特点</strong></a><strong class="lb iu"><br/></strong><a class="ae ni" href="#0862" rel="noopener ugc nofollow"><strong class="lb iu">2。动态规划题型</strong></a><strong class="lb iu"><br/></strong><a class="ae ni" href="#a994" rel="noopener ugc nofollow"><strong class="lb iu">3。实现动态编程的方法</strong></a><strong class="lb iu"><br/>∘</strong><a class="ae ni" href="#0914" rel="noopener ugc nofollow"><strong class="lb iu">自上而下的方法</strong></a><strong class="lb iu"><br/>∘</strong><a class="ae ni" href="#7a46" rel="noopener ugc nofollow"><strong class="lb iu">自下而上的方法</strong></a><strong class="lb iu"><br/></strong><a class="ae ni" href="#3e46" rel="noopener ugc nofollow"><strong class="lb iu">4。动态编程示例</strong></a><strong class="lb iu"><br/>∘</strong><a class="ae ni" href="#4501" rel="noopener ugc nofollow"><strong class="lb iu">示例1:爬楼梯</strong></a><strong class="lb iu"><br/>∘</strong><a class="ae ni" href="#6909" rel="noopener ugc nofollow"><strong class="lb iu">示例2:入室抢劫犯</strong></a><strong class="lb iu"><br/>∘</strong><a class="ae ni" href="#aab6" rel="noopener ugc nofollow"><strong class="lb iu">示例3:樱桃皮卡</strong></a><strong class="lb iu"><br/></strong><a class="ae ni" href="#1dc7" rel="noopener ugc nofollow"><strong class="lb iu">什么</strong></a><strong class="lb iu"><br/></strong><a class="ae ni" href="#0d47" rel="noopener ugc nofollow"><strong class="lb iu">概要</strong> </a></p><h1 id="5517" class="ml mm it bd mn mo nj mq mr ms nk mu mv jz nl ka mx kc nm kd mz kf nn kg nb nc bi translated">1.动态规划的特征</h1><p id="a415" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">我们许多人都面临着识别动态编程问题的困难。我们如何知道我们能否用动态编程解决一个问题？我们可以问自己以下问题。</p><ul class=""><li id="0cbd" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">我们能把这个问题分解成更小的子问题吗？</li><li id="0b79" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">有没有重叠的子问题？</li><li id="66ca" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">如果是，我们能否最优地解决较小的子问题，然后用它们构造一个最优解来解决主问题？</li><li id="121a" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">在解决问题的同时，当前步骤的决策是否影响后续步骤的结果和决策？</li></ul><p id="1432" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对以上问题的回答是肯定的，那么你可以应用动态规划来解决给定的问题。根据<a class="ae ni" href="https://en.wikipedia.org/wiki/Dynamic_programming" rel="noopener ugc nofollow" target="_blank">维基百科</a>，</p><blockquote class="oc"><p id="c2dc" class="od oe it bd of og oh oi oj ok ol lu dk translated">一个问题必须具备两个关键属性，才能应用动态规划:<a class="ae ni" href="https://en.wikipedia.org/wiki/Optimal_substructure" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">最优子结构</strong> </a>和<a class="ae ni" href="https://en.wikipedia.org/wiki/Overlapping_subproblem" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">重叠子问题</strong> </a></p></blockquote><blockquote class="om on oo"><p id="f92f" class="kz la op lb b lc oq ju le lf or jx lh os ot lk ll ou ov lo lp ow ox ls lt lu im bi translated">不要混淆动态编程与分治或贪婪算法。</p><p id="ff61" class="kz la op lb b lc ld ju le lf lg jx lh os lj lk ll ou ln lo lp ow lr ls lt lu im bi translated"><a class="ae ni" href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">分治</strong> </a>也是通过组合子问题的最优解来解决一个问题。但《分治法》中的子问题是<strong class="lb iu">不重叠</strong>。</p><p id="f060" class="kz la op lb b lc ld ju le lf lg jx lh os lj lk ll ou ln lo lp ow lr ls lt lu im bi translated">一个<a class="ae ni" href="https://en.wikipedia.org/wiki/Greedy_algorithm" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">贪婪算法</strong> </a>将试图做出贪婪的选择来为每一步提供<strong class="lb iu">局部最优解</strong>。这可能无法保证最终的解决方案是最优的。贪婪算法永远不会回顾并重新考虑它的选择，而动态编程可能会根据对前面步骤的回顾来修改它的决定。</p></blockquote><h1 id="0862" class="ml mm it bd mn mo nj mq mr ms nk mu mv jz nl ka mx kc nm kd mz kf nn kg nb nc bi translated">2.动态规划问题的类型</h1><p id="b7e0" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">动态编程题是什么样子的？</p><p id="73e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看一些最常见的动态编程问题。</p><p id="f57e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一种类型的动态规划问题，也是经常遇到的一种，是为一个给定的问题找到一个最优解。例子包括寻找最大利润、最小成本、最短路径或最长公共子序列。</p><p id="64e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二类动态规划问题是寻找达到某种结果的可能性，到达某一点的可能性，或者在规定的条件下完成一项任务的可能性。</p><p id="177b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三种类型通常被称为动态规划计数问题(或组合问题)，如寻找执行或完成一项任务的方法的数量。</p><p id="befa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们讨论的所有三种类型的动态规划问题也可以以矩阵的形式作为二维问题出现。更复杂的问题可能涉及多个方面。</p><h1 id="a994" class="ml mm it bd mn mo nj mq mr ms nk mu mv jz nl ka mx kc nm kd mz kf nn kg nb nc bi translated">3.实现动态规划的方法</h1><p id="91fc" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">我们可以用自底向上或自顶向下的方法解决动态规划问题。不管哪种情况，我们都需要定义并得出问题的基本情况。</p><p id="1753" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，自上而下的方法是从查看全局开始的。从高层开始，它逐渐深入到更小的子问题的解决方案，最后是构建解决方案的基础案例。</p><p id="8ef2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与自上而下的方法相反，自下而上的方法从小处着手，首先查看基础案例，然后在整体解决整个问题之前，一步一步地构建更大的子问题的解决方案。</p><p id="636c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象以下情况:</p><p id="d179" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="op">自上而下</em> </strong> <em class="op">:“我想做一个好吃的，看起来很华丽的生日蛋糕。如何实现这一点？嗯……我可以用甘美的香蒂伊奶油、浆果果盘、鲜花和新鲜草莓来装饰蛋糕。如何准备它们？我需要用糖搅打浓奶油，切草莓，煮浆果果盘。但是蛋糕在哪里？哎呀，我需要准备蛋糕面糊，然后烘烤它。怎么会？用糖和鸡蛋搅打黄油，然后拌入面粉和牛奶。每种成分的用量是多少？我需要根据所需的比例来衡量它们”。</em></p><p id="d1fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="op">自下而上</em> </strong> <em class="op">:“我先从测量和准备蛋糕配料开始。所有的材料都准备好了，我把黄油和糖、鸡蛋搅拌在一起，然后加入面粉和牛奶。接下来，我把它放进烤箱，烤30分钟。烤好蛋糕并让它冷却后，我煮浆果果盘，切新鲜草莓，用糖搅打浓奶油。此后，我在蛋糕上涂上尚蒂伊奶油，在上面铺上浆果果盘，最后放上并摆好切好的草莓和可食用的花”。</em></p><p id="1485" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你能注意到自下而上的方法是如何从基础开始有序地做事的吗？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/96935b84e6ca74c98a2cf1e2ac0ffcdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GzvYn2gH5dBEOgfE"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ni" href="https://unsplash.com/@sebastiancoman?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">塞巴斯蒂安·科曼摄影</a>在<a class="ae ni" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="0914" class="oz mm it bd mn pa pb dn mr pc pd dp mv li pe pf mx lm pg ph mz lq pi pj nb pk bi translated">自上而下的方法</h2><p id="f038" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">自顶向下方法的实现使用带记忆的递归。</p><p id="321f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ni" href="https://en.wikipedia.org/wiki/Memoization" rel="noopener ugc nofollow" target="_blank">记忆化</a>是一种存储计算结果的技术，这样当程序再次需要它们时，就可以直接检索和使用它们。这对于重叠的子问题特别有用，因为它有助于避免两次执行相同的计算，从而提高效率并节省计算时间。哈希表或数组通常用于记忆。</p><p id="bc4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只要当前状态不是基本情况，这种方法将根据我们定义的递归关系进行递归函数调用。</p><h2 id="7a46" class="oz mm it bd mn pa pb dn mr pc pd dp mv li pe pf mx lm pg ph mz lq pi pj nb pk bi translated">自下而上的方法</h2><p id="9c42" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">为了实现自底向上的方法，我们需要从基础案例开始，以特定的顺序迭代问题的所有状态。</p><p id="6ea2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这样做，我们从小到大一步一步地构建解决方案，这样当前步骤的答案可以很容易地使用从先前步骤计算的可用子问题解决方案来计算。这个过程会一直持续下去，直到我们构建出完整的解决方案。</p><p id="ca94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自下而上的方法也被称为列表法。由于这种方法会以特定的顺序遍历每一步并执行计算，因此很容易将结果列表成数组或列表，这样就可以通过相关索引方便地检索它们，以便在后续步骤中使用。</p><p id="4c4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于某些情况，可以避免制表以节省空间和内存。我们将在后面的示例1和示例2中看到这一点。</p><blockquote class="om on oo"><p id="4472" class="kz la op lb b lc ld ju le lf lg jx lh os lj lk ll ou ln lo lp ow lr ls lt lu im bi translated">那么使用哪种方法呢？</p><p id="a88a" class="kz la op lb b lc ld ju le lf lg jx lh os lj lk ll ou ln lo lp ow lr ls lt lu im bi translated">通常使用这两种方法都可以。毕竟，动态编程不容易理解。你可以使用对你来说更自然的方法，也可以使用你更习惯的方法。</p><p id="ae18" class="kz la op lb b lc ld ju le lf lg jx lh os lj lk ll ou ln lo lp ow lr ls lt lu im bi translated">虽然有些人可能发现使用自顶向下的方法用递归关系和代码构建解决方案更容易，但自底向上的迭代过程有时会执行得更快，因为它没有递归的堆栈开销。大多数时候，这种差异是微不足道的。不用说，如果你很有技巧，能够编写两种代码，那么就选择时间和空间复杂度较低的一种。</p></blockquote><h1 id="3e46" class="ml mm it bd mn mo nj mq mr ms nk mu mv jz nl ka mx kc nm kd mz kf nn kg nb nc bi translated">4.动态编程示例</h1><p id="9a52" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">在本帖中，我们将详细讨论三个解决动态编程问题的例子。</p><h2 id="4501" class="oz mm it bd mn pa pb dn mr pc pd dp mv li pe pf mx lm pg ph mz lq pi pj nb pk bi translated">示例1:爬楼梯</h2><p id="2abc" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">先说一个简单易懂的例子，<a class="ae ni" href="https://leetcode.com/problems/climbing-stairs/" rel="noopener ugc nofollow" target="_blank">爬楼梯</a>。</p><blockquote class="om on oo"><p id="05b0" class="kz la op lb b lc ld ju le lf lg jx lh os lj lk ll ou ln lo lp ow lr ls lt lu im bi translated">在这个问题中，我们有一个楼梯，它会带我们走<code class="fe pl pm pn po b">n</code>步到达顶端。每次，我们只允许爬1步或2步。</p><p id="b6a2" class="kz la op lb b lc ld ju le lf lg jx lh os lj lk ll ou ln lo lp ow lr ls lt lu im bi translated">在<strong class="lb iu">中，我们可以用多少种不同的方式</strong>爬到山顶？</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/e34b086efeb4b5e3ef7578343055b031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*gQj2FAyWhBW3Io64fUMu_Q.png"/></div></figure><p id="9c09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从思考基本情况开始。如果我们要迈出第一步，有多少种方法可以做到？当然只有一条路，那就是爬1级台阶。</p><p id="0d21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">进入第二步怎么样？有两种方法可以做到这一点。我们可以两次爬1级台阶，也可以一次爬2级台阶。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pq"><img src="../Images/967bffd0af7d54d2a654703cd7b815b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R_18Fs30usvh1QGjBypwMQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">爬楼梯问题的基本情况</p></figure><p id="7917" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很好！到达第一步和到达第二步构成了这个问题的基本情况。那么，第三步，第四步，等等呢？</p><p id="21af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于第三步，只有3种可能的方法可以到达那里。它们是:</p><ul class=""><li id="3253" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">爬1级台阶3次，或</li><li id="dffb" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">先爬1步，再爬2步，或</li><li id="5550" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">先爬两步，再爬一步</li></ul><p id="f073" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们怎么得到这个数字？就是把第一步和第二步的结果相加(1 + 2 = 3)。这告诉我们，从基础案例出发，我们可以构建其他步骤的解决方案。假设<code class="fe pl pm pn po b">climb(n)</code>是返回到达步骤<code class="fe pl pm pn po b">n</code>的路径数的函数，那么</p><pre class="kj kk kl km gt pr po ps pt aw pu bi"><span id="1d82" class="oz mm it po b gy pv pw l px py">climb<!-- -->(n) = <!-- -->climb<!-- -->(n-1) + <!-- -->climb<!-- -->(n-2)</span></pre><p id="72da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了，这是这个爬楼梯问题的<strong class="lb iu">递推关系</strong>。当前步骤采用前两步的计算结果，并将它们相加。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/6b633d28e66ab330e78b81408afa4ea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*sY7pL4FeGkbWrgR_TYtmDg.png"/></div></figure><p id="181e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，这就是我们如何将一个问题分解成子问题，解决子问题将构建主问题的解决方案。</p><p id="b42b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你能看出这些子问题是重叠的吗？</p><pre class="kj kk kl km gt pr po ps pt aw pu bi"><span id="36e9" class="oz mm it po b gy pv pw l px py">climb<!-- -->(6) = <!-- -->climb<!-- -->(5) + <!-- -->climb<!-- -->(4)<br/>climb<!-- -->(5) = <!-- -->climb<!-- -->(4) + <!-- -->climb<!-- -->(3)<br/>climb<!-- -->(4) = <!-- -->climb<!-- -->(3) + <!-- -->climb<!-- -->(2)<br/>climb<!-- -->(3) = <!-- -->climb<!-- -->(2) + <!-- -->climb<!-- -->(1)</span></pre><p id="f70d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了得到<code class="fe pl pm pn po b">climb(6)</code>的结果，我们需要计算<code class="fe pl pm pn po b">climb(5)</code>和<code class="fe pl pm pn po b">climb(4)</code>。为了得到<code class="fe pl pm pn po b">climb(5)</code>的结果，我们需要再次计算<code class="fe pl pm pn po b">climb(4)</code>。</p><p id="2149" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从下图我们可以清楚的看到，为了得到<code class="fe pl pm pn po b">climb(6)</code>，我们要计算<code class="fe pl pm pn po b">climb(4)</code>两次，计算<code class="fe pl pm pn po b">climb(3)</code>三次。这将导致O(2^n).的时间复杂度</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qa"><img src="../Images/dc321c3099c5464ef157b53c26a09109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZdizPFcdqBF7XKQle36x1g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">重叠子问题— <code class="fe pl pm pn po b">climb(6)</code>无记忆</p></figure><p id="48cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了记忆化，我们可以摆脱多余的计算，只检索先前存储的结果。时间复杂度将降低到O(n)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qb"><img src="../Images/6d47014162cde1805f8db566613ca2ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SIaTwY48ENEYNuS907S1qQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe pl pm pn po b">climb(6)</code>带记忆功能</p></figure><p id="f737" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，我们有了基本情况和递归关系，现在是时候使用自顶向下的方法编写实现了。</p><p id="447e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，为了记忆，我们使用hashmap (Python字典)来存储计算结果。如果<code class="fe pl pm pn po b">n</code>的结果存在，我们跳过计算并从hashmap中检索结果。</p><p id="303c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法的时间和空间复杂度均为O(n)。这是因为我们实际上经历了每一步，并且对于每一步，我们都将计算结果存储在hashmap中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="qc qd l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">爬楼梯的自上而下解决方案</p></figure><p id="d8b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是使用自下而上方法的解决方案。</p><p id="5ef3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，我们可以使用一个数组来列出每一步的计算值。然而，对于这个问题，由于当前状态只依赖于前两个状态，我们可以有效地只使用两个变量，<code class="fe pl pm pn po b">case1</code>和<code class="fe pl pm pn po b">case2</code>，在迭代<code class="fe pl pm pn po b">for</code>循环时跟踪它们。</p><p id="9640" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这样做，我们能够实现恒定的空间复杂度O(1)。时间复杂度将与自顶向下的方法相同，O(n)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="qc qd l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">爬楼梯的自下而上解决方案</p></figure><h2 id="6909" class="oz mm it bd mn pa pb dn mr pc pd dp mv li pe pf mx lm pg ph mz lq pi pj nb pk bi translated">例子2:入室抢劫犯</h2><p id="7319" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">这是动态编程问题的另一个经典例子，<a class="ae ni" href="https://leetcode.com/problems/house-robber/" rel="noopener ugc nofollow" target="_blank">入室抢劫</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qe"><img src="../Images/03136100afe44cb2911b995712dd2189.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5mB2uXknwjXsUb2CH06r3A.png"/></div></div></figure><blockquote class="om on oo"><p id="b481" class="kz la op lb b lc ld ju le lf lg jx lh os lj lk ll ou ln lo lp ow lr ls lt lu im bi translated">在这个问题中，我们得到了一个整数数组，代表一个强盗可以抢劫的每所房子的钱数。这些房子排列在一条街上。不过有一个限制，即强盗不能抢劫邻近的房子。例如，如果房屋的索引从0到4，强盗可以抢劫房屋0、2、4或房屋1、3。</p><p id="32de" class="kz la op lb b lc ld ju le lf lg jx lh os lj lk ll ou ln lo lp ow lr ls lt lu im bi translated">强盗能从这些房子里抢劫的最大金额是多少？</p></blockquote><p id="e28e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用一个示例输入<code class="fe pl pm pn po b"><em class="op">house = [10, 60, 80, 20, 8]</em></code> <em class="op">来演示一下。</em></p><p id="c588" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们从考虑基本情况开始。如果只有一套房子，<code class="fe pl pm pn po b">house[0]</code>，我们怎么办？我们只会抢劫，从<code class="fe pl pm pn po b">house[0]</code>那里拿钱。这是因为没有其他选择可以考虑。</p><p id="1bd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们有两栋房子，<code class="fe pl pm pn po b">house[0]</code>和<code class="fe pl pm pn po b">house[1]</code>，我们抢哪栋？我们不能抢劫两家，因为它们相邻。我们要么抢<code class="fe pl pm pn po b">house[0]</code>要么抢<code class="fe pl pm pn po b">house[1]</code>。好吧，当然，我们会抢劫装有更多钱的房子。为了找到包含更多钱的房子，我们应用<code class="fe pl pm pn po b">max(house[0], house[1])</code>。</p><p id="9e0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意上面是如何构成这个问题的基础的？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qf"><img src="../Images/c29b96dd3fe532349e24d5e64712290f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M1r81saZa3lzAYrR6NgDOA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">入室抢劫问题的基本情况</p></figure><p id="097c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果有很多房子呢？那我们该怎么办？我们这么想吧。如果我们在<code class="fe pl pm pn po b">house[n]</code>，我们有两个选择，即是否抢劫房子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qg"><img src="../Images/fbdeb5aef71a2b34228e169416588db4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*ghJjHaqOMhCD5lnqUjRWDw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">抢还是不抢这房子？</p></figure><ul class=""><li id="c081" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">假设我们在<code class="fe pl pm pn po b">house[9]</code>。如果我们决定抢劫<code class="fe pl pm pn po b">house[9]</code>，那么我们将得到的是来自<code class="fe pl pm pn po b">house[9]</code>的钱加上我们之前得到的2栋房子的钱。</li><li id="4867" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">如果我们决定不抢劫<code class="fe pl pm pn po b">house[9]</code>，那么我们所拥有的仅仅是我们在<code class="fe pl pm pn po b">house[8]</code>之前从抢劫房屋中获得的金额。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qh"><img src="../Images/574aea85ff10304f2bf50afa6a06357e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*agE_P6yECfPtfzgTiYLc_A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">入室抢劫问题的递推关系</p></figure><p id="8c09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了找出哪个选项能产生最大金额，我们对这两个选项应用了<code class="fe pl pm pn po b">max()</code>函数，这就形成了我们的递归关系:</p><pre class="kj kk kl km gt pr po ps pt aw pu bi"><span id="da48" class="oz mm it po b gy pv pw l px py">rob_house(n) = max(rob_house(n-2) + house[n], rob_house(n-1))</span></pre><p id="a6dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了基本情况和递归关系，我们现在可以使用自顶向下的方法来编写解决方案。该方法的时间和空间复杂度为O(n)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="qc qd l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自上而下的入室抢劫解决方案</p></figure><p id="ccab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于自底向上的方法，我们再次使用两个变量<code class="fe pl pm pn po b">case1</code>和<code class="fe pl pm pn po b">case2</code>来跟踪前两个状态，而不是将数组列表。</p><p id="39a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还记得只有一栋房子和有两栋房子的基本情况吗？<code class="fe pl pm pn po b">case1</code>用第一个房子的值初始化，<code class="fe pl pm pn po b">case2</code>用<code class="fe pl pm pn po b">max(house[0], house[1])</code>的结果初始化。</p><p id="57bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图说明了我们有3个房子时的训练。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qi"><img src="../Images/36b3fce468ce15a35a27d6091f2d4754.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*1wBsezAijc_q1bN_Ml-SMQ.png"/></div></figure><p id="88cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe pl pm pn po b">n = 2</code>所在的第三个房子，以及后续的迭代，我们可以通过应用<code class="fe pl pm pn po b">max(case1 + house[n], case2)</code>来计算<code class="fe pl pm pn po b">result</code>。因为我们正在回收这两个变量，所以在当前计算之后，<code class="fe pl pm pn po b">case1</code>将被替换为<code class="fe pl pm pn po b">case2</code>，并且当前计算的结果将被赋给<code class="fe pl pm pn po b">case2</code>。</p><p id="b2ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅使用两个变量允许我们实现恒定的空间复杂度O(1)。时间复杂度将与自顶向下的方法相同，O(n)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="qc qd l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自下而上解决入室抢劫</p></figure><h2 id="aab6" class="oz mm it bd mn pa pb dn mr pc pd dp mv li pe pf mx lm pg ph mz lq pi pj nb pk bi translated">示例3:樱桃皮卡</h2><p id="6694" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">让我们来尝试一个更有挑战性的问题，<a class="ae ni" href="https://leetcode.com/problems/cherry-pickup/" rel="noopener ugc nofollow" target="_blank">樱桃皮卡</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qg"><img src="../Images/957d627df795b1c49e5a7804c8e7e70a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*SGbvTo65sjTb9CnBeSGCAg.png"/></div></figure><blockquote class="om on oo"><p id="ff15" class="kz la op lb b lc ld ju le lf lg jx lh os lj lk ll ou ln lo lp ow lr ls lt lu im bi translated">在这个问题中，有一个<code class="fe pl pm pn po b">n x n</code>网格，其中每个单元格中的值可以是<code class="fe pl pm pn po b">1</code>(单元格中有一颗樱桃)<code class="fe pl pm pn po b">0</code>(单元格是空的)，或者<code class="fe pl pm pn po b">-1</code>(有一根刺，一个挡住去路的障碍物)。</p><p id="db5d" class="kz la op lb b lc ld ju le lf lg jx lh os lj lk ll ou ln lo lp ow lr ls lt lu im bi translated">从单元格<code class="fe pl pm pn po b">(0,0)</code>开始，我们应该移动到位于<code class="fe pl pm pn po b">(n-1, n-1)</code>的目的地。如果一路上有樱桃，我们就把它们捡起来。如果我们从一个细胞中拿起樱桃，这个细胞就变成了一个空细胞，<code class="fe pl pm pn po b">0</code>。我们只允许向下或向右移动，如果有荆棘，我们将无法通过。</p><p id="9887" class="kz la op lb b lc ld ju le lf lg jx lh os lj lk ll ou ln lo lp ow lr ls lt lu im bi translated">在<code class="fe pl pm pn po b">(n-1, n-1)</code>到达目的地后，我们必须返回起点<code class="fe pl pm pn po b">(0,0)</code>。回程时，我们只允许向上或向左移动，捡起剩余的樱桃，如果有的话。</p><p id="9857" class="kz la op lb b lc ld ju le lf lg jx lh os lj lk ll ou ln lo lp ow lr ls lt lu im bi translated">如果我们在<code class="fe pl pm pn po b">(n-1, n-1)</code>找不到到达目的地的方法，那么我们就收不到任何樱桃。</p><p id="54c5" class="kz la op lb b lc ld ju le lf lg jx lh os lj lk ll ou ln lo lp ow lr ls lt lu im bi translated">我们被要求归还我们能够收集的最大数量的樱桃。</p></blockquote><p id="f715" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们想到的是建模一个解决方案，如问题所述，在向前的行程中拾取樱桃，然后返回。</p><p id="e0e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，让我们用从<a class="ae ni" href="https://leetcode.com/problems/cherry-pickup/solution/" rel="noopener ugc nofollow" target="_blank">这里</a>采用的方法来尝试一种新的方法。</p><p id="5c6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，我们将只在向前的行程中遍历，而不是先向前再返回。为什么？这是因为在这个问题中，向前的行程和向后的行程实际上是一样的。换句话说，我们可以在只能向下移动或right️的向前行程中，以及在只能向上移动或left️.的返回行程中，遍历相同的路径这有意义吗？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qj"><img src="../Images/33ba84cfc347c5d009431430b361fcd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*VzKmebYOLdY0gWJb3rX2Yg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">向前行程或返回行程可以穿过相同的路径</p></figure><p id="c9df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们可以用两个人同时移动的想法简单地做一次向前的旅行，而不是做两次旅行。因此，在任何时间点上，这两个人都会移动相同的次数。</p><p id="9f04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设<em class="op">人员1 </em>在位置<code class="fe pl pm pn po b">(r1,c1)</code>并且<em class="op">人员2 </em>在位置<code class="fe pl pm pn po b">(r2,c2)</code>移动一定次数后，我们有<code class="fe pl pm pn po b">r1 + c1</code>等于<code class="fe pl pm pn po b">r2 + c2</code>。听起来很奇怪？看看下面的插图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qk"><img src="../Images/fa49b003e4755eb4a55560632b8a9f3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*OGZFBP2PLVn0G5MpRNwWxg.png"/></div></figure><p id="4267" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们可以在我们的问题中使用<code class="fe pl pm pn po b">r1</code>、<code class="fe pl pm pn po b">c1</code>、<code class="fe pl pm pn po b">r2</code>、<code class="fe pl pm pn po b">c2</code>作为状态变量。但是我们真的需要这四个吗？对于长度为<code class="fe pl pm pn po b">n</code>的网格，它将产生O(n⁴)状态。</p><p id="7083" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以改进并将状态变量减少到只有三个，即<code class="fe pl pm pn po b">r1</code>、<code class="fe pl pm pn po b">c1</code>、<code class="fe pl pm pn po b">c2</code>。但是<code class="fe pl pm pn po b">r2</code>怎么样？好吧，我们还需要<code class="fe pl pm pn po b">r2</code>，我们可以从等式中导出它的值。这个<a class="ae ni" href="https://www.hackerearth.com/practice/algorithms/dynamic-programming/state-space-reduction/tutorial/" rel="noopener ugc nofollow" target="_blank">状态空间约简</a>将把这个问题的时间和空间复杂度从O(n⁴)降低到O(n)。</p><pre class="kj kk kl km gt pr po ps pt aw pu bi"><span id="7fab" class="oz mm it po b gy pv pw l px py">r1 + c1 = r2 + c2</span><span id="c10b" class="oz mm it po b gy ql pw l px py">Derive r2 as:<br/>  r2 = r1 + c1 - c2</span><span id="b3ef" class="oz mm it po b gy ql pw l px py">Where<br/>  <!-- -->r1<!-- --> is the row index of <em class="op">person1</em><br/>  c1 is the column index of <em class="op">person1</em><br/>  r2 is the row index of <em class="op">person2</em><br/>  c2 is the column index of <em class="op">person2</em></span></pre><p id="fd9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，这个问题中的三个状态变量是怎么算出来的呢？因为我们有两个人同时移动，所以每次移动有四种可能性，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qm"><img src="../Images/b70a110d7990bec5a4443ff6bf771cb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*OIs37E6s9IhVJUe9ir2wXw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用三个状态变量(r1、c1、c2)来表示每次移动的四种可能性</p></figure><p id="e1e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在对概念有了清晰的理解和足够的信息后，让我们构建自顶向下的解决方案。</p><p id="0a79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，我们将使用来自<code class="fe pl pm pn po b"><a class="ae ni" href="https://docs.python.org/3/library/functools.html#module-functools" rel="noopener ugc nofollow" target="_blank">functools</a></code>模块的Python的<code class="fe pl pm pn po b"><a class="ae ni" href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="noopener ugc nofollow" target="_blank">lru_cache()</a></code>装饰器，而不是使用hashmap进行记忆。</p><p id="7338" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的解决方案中，我们将创建一个<code class="fe pl pm pn po b">get_cherry()</code>递归函数，并使用一个名为<code class="fe pl pm pn po b">cherries</code>的变量来累加采摘的樱桃。</p><p id="d513" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设<em class="op">人员1 </em>在<code class="fe pl pm pn po b">(r1,c1)</code>位置<em class="op">人员2 </em>在<code class="fe pl pm pn po b">(r2,c2)</code>位置，并且两个位置都没有刺，我们首先将<code class="fe pl pm pn po b">(r1,c1)</code>到<code class="fe pl pm pn po b">cherries</code>的值相加。因为没有刺，所以值为<code class="fe pl pm pn po b">0</code>或<code class="fe pl pm pn po b">1</code>。</p><p id="0554" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其次，为了避免重复计算，只有当<em class="op">人员2 </em>在不同的位置时，我们才会将<code class="fe pl pm pn po b">(r2,c2)</code>的值加到<code class="fe pl pm pn po b">cherries</code>上。</p><p id="c97c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们已经在<em class="op">人员1 </em>和<em class="op">人员2 </em>的当前位置积累了樱桃。我们也需要对后续位置进行同样的累积。</p><p id="9754" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还记得我们之前说过的吗，每一步都有四种可能？为了确定哪条路径可以获得后续位置的最大樱桃数量，我们可以对四个选项应用<code class="fe pl pm pn po b">max()</code>函数。这就形成了这个问题的递归关系。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qn"><img src="../Images/a64a2f91203ca57b770282d628b3fff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*hmmFm_5Za9NCxrmCmyG98A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">樱桃采摘的递归关系</p></figure><p id="dad6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">递归函数调用将继续，直到到达目标单元格。当这种情况发生时，函数将返回该单元格的值。因为这是基本情况，所以不会进行进一步的递归函数调用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="qc qd l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">樱桃采摘自顶向下解决方案</p></figure><p id="dc85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哇。这是个完美的计划，不是吗？但也有例外。</p><p id="503f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe pl pm pn po b">(r1,c1)</code>或<code class="fe pl pm pn po b">(r2,c2)</code>有刺怎么办？如果<em class="op">人员1 </em>或<em class="op">人员2 </em>越界了呢？</p><p id="cc98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，我们想尽可能避开那些地方。如果发生这种情况，函数将返回一个负无穷大，表示不值得采取特定的路径来寻找最佳答案。负无穷大本质上是最小值，所以<code class="fe pl pm pn po b">max()</code>函数会采用另一个值最大的选项。</p><p id="8bd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，如果<em class="op">人员1 </em>或<em class="op">人员2 </em>无法到达目的地怎么办？嗯，这是可能的，它可能会发生由于荆棘阻碍。在这种情况下，没有樱桃可以收集，最后的答案将是<code class="fe pl pm pn po b">0</code>。</p><blockquote class="om on oo"><p id="e5c7" class="kz la op lb b lc ld ju le lf lg jx lh os lj lk ll ou ln lo lp ow lr ls lt lu im bi translated">对于这个问题，我将把它留给好奇的读者去思考自底向上的解决方案。谁知道呢，你也许能想出一个绝妙的解决方案。</p></blockquote><h1 id="1dc7" class="ml mm it bd mn mo nj mq mr ms nk mu mv jz nl ka mx kc nm kd mz kf nn kg nb nc bi translated">下一步是什么？</h1><p id="3abc" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">无论如何，去练习解决动态编程问题。</p><p id="24dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迈出第一步。如果你不能破解解决方案，不要烦恼。查看一些论坛，在那里您通常可以找到有用的提示和指导。</p><p id="610a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最知名的可以练习的平台是<a class="ae ni" href="https://leetcode.com/tag/dynamic-programming/" rel="noopener ugc nofollow" target="_blank"> LeetCode </a>。其他还有<a class="ae ni" href="https://practice.geeksforgeeks.org/explore?page=2&amp;category[]=Dynamic%20Programming&amp;sortBy=submissions" rel="noopener ugc nofollow" target="_blank"> GeeksforGeeks </a>、<a class="ae ni" href="https://www.hackerearth.com/practice/algorithms/dynamic-programming/introduction-to-dynamic-programming-1/practice-problems/" rel="noopener ugc nofollow" target="_blank">hackere earth</a>和<a class="ae ni" href="https://www.hackerrank.com/domains/algorithms?filters%5Bsubdomains%5D%5B%5D=dynamic-programming" rel="noopener ugc nofollow" target="_blank"> HackerRank </a>。</p><blockquote class="oc"><p id="9d9f" class="od oe it bd of og oh oi oj ok ol lu dk translated">我们练习得越多，学到的就越多。我们学得越多，就越容易！</p></blockquote><h1 id="0d47" class="ml mm it bd mn mo nj mq mr ms nk mu mv jz qo ka mx kc qp kd mz kf qq kg nb nc bi translated">摘要</h1><p id="0da4" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">☑️:在这篇文章中，我们讨论了动态编程的特征以及适用于动态编程的关键属性。</p><p id="88c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">☑️:我们揭示了经常被问到的动态编程问题的典型类型。</p><p id="b703" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">☑️我们探讨了自顶向下和自底向上方法之间的差异，以及以何种方式实现它们。</p><p id="0de2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">☑️:我们通过3个例子学习了如何解决动态编程问题，其中包括详细的解释和解决方案。</p><h1 id="3747" class="ml mm it bd mn mo nj mq mr ms nk mu mv jz nl ka mx kc nm kd mz kf nn kg nb nc bi translated">参考</h1><p id="7670" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">[1] LeetCode，<a class="ae ni" href="https://leetcode.com/problems/climbing-stairs/" rel="noopener ugc nofollow" target="_blank">爬楼梯</a>，<a class="ae ni" href="https://leetcode.com/problems/house-robber/" rel="noopener ugc nofollow" target="_blank">入室抢劫</a>，<a class="ae ni" href="https://leetcode.com/problems/cherry-pickup/" rel="noopener ugc nofollow" target="_blank">樱桃皮卡</a></p><p id="02ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2] GeeksforGeeks，<a class="ae ni" href="https://www.geeksforgeeks.org/dynamic-programming/" rel="noopener ugc nofollow" target="_blank">动态编程</a></p><p id="6242" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[3] Prateek Garg <em class="op">，</em> <a class="ae ni" href="https://www.hackerearth.com/practice/algorithms/dynamic-programming/introduction-to-dynamic-programming-1/tutorial/" rel="noopener ugc nofollow" target="_blank">动态编程介绍1 </a></p><p id="46ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[4]编程，<a class="ae ni" href="https://www.programiz.com/dsa/dynamic-programming" rel="noopener ugc nofollow" target="_blank">动态编程</a></p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><blockquote class="oc"><p id="b30a" class="od oe it bd of og oh oi oj ok ol lu dk translated">动态编程很有趣。有些问题可能是令人生畏和难以置信的，但是学习解决它们并掌握技巧可以打开一个可能性的彩虹！</p></blockquote><figure class="qs qt qu qv qw kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qr"><img src="../Images/0dc7bd1350b62986e411cb8421d36bbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sGZ_E0qlNOMg9vcA"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ni" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ni" href="https://unsplash.com/@ramone?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">不锈钢图片</a>拍摄</p></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt pr po ps pt aw pu bi"><span id="02d6" class="oz mm it po b gy pv pw l px py"><strong class="po iu"><em class="op">Before You Go...</em></strong></span><span id="eece" class="oz mm it po b gy ql pw l px py"><em class="op">Thank you for reading this post, and I hope you’ve enjoyed learning dynamic programming as much as I do. Please leave a comment if you’d like to see more articles of this nature in the future.</em></span><span id="91e7" class="oz mm it po b gy ql pw l px py"><em class="op">If you like my post, don’t forget to hit </em><a class="ae ni" href="https://peggy1502.medium.com/" rel="noopener"><strong class="po iu"><em class="op">Follow</em></strong></a><em class="op"> and </em><a class="ae ni" href="https://peggy1502.medium.com/subscribe" rel="noopener"><strong class="po iu"><em class="op">Subscribe</em></strong></a><em class="op"> to get notified via email when I publish.</em></span><span id="bfe0" class="oz mm it po b gy ql pw l px py"><em class="op">Optionally, you may also </em><a class="ae ni" href="https://peggy1502.medium.com/membership" rel="noopener"><em class="op">sign up</em></a><em class="op"> for a Medium membership to get full access to every story on Medium.</em></span><span id="44f7" class="oz mm it po b gy ql pw l px py">📑 <em class="op">Visit this </em><a class="ae ni" href="https://github.com/peggy1502/Data-Science-Articles/blob/main/README.md" rel="noopener ugc nofollow" target="_blank"><em class="op">GitHub repo</em></a><em class="op"> for all codes and notebooks that I’ve shared in my post.</em></span><span id="8f36" class="oz mm it po b gy ql pw l px py">© 2022 All rights reserved.</span></pre><p id="1f98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">准备好深入潜水了吗？跳上<a class="ae ni" href="https://peggy1502.medium.com/mastering-dynamic-programming-ii-73149d26b16d" rel="noopener"> <strong class="lb iu">掌握动态编程II </strong> </a></p><div class="qx qy gp gr qz ra"><a href="https://peggy1502.medium.com/mastering-dynamic-programming-ii-73149d26b16d" rel="noopener follow" target="_blank"><div class="rb ab fo"><div class="rc ab rd cl cj re"><h2 class="bd iu gy z fp rf fr fs rg fu fw is bi translated">掌握动态编程2</h2><div class="rh l"><h3 class="bd b gy z fp rf fr fs rg fu fw dk translated">手动制表和锻炼是一个伟大的方式开始搜索，分析，发现模式，以及…</h3></div><div class="ri l"><p class="bd b dl z fp rf fr fs rg fu fw dk translated">peggy1502.medium.com</p></div></div><div class="rj l"><div class="rk l rl rm rn rj ro ks ra"/></div></div></a></div><p id="77bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有兴趣阅读我的其他数据科学文章吗？查看以下内容:</p><div class="qx qy gp gr qz ra"><a rel="noopener follow" target="_blank" href="/transformers-can-you-rate-the-complexity-of-reading-passages-17c76da3403"><div class="rb ab fo"><div class="rc ab rd cl cj re"><h2 class="bd iu gy z fp rf fr fs rg fu fw is bi translated">变形金刚，你能评价阅读段落的复杂程度吗？</h2><div class="rh l"><h3 class="bd b gy z fp rf fr fs rg fu fw dk translated">用PyTorch微调RoBERTa以预测文本摘录的阅读难易程度</h3></div><div class="ri l"><p class="bd b dl z fp rf fr fs rg fu fw dk translated">towardsdatascience.com</p></div></div><div class="rj l"><div class="rp l rl rm rn rj ro ks ra"/></div></div></a></div><div class="qx qy gp gr qz ra"><a rel="noopener follow" target="_blank" href="/advanced-techniques-for-fine-tuning-transformers-82e4e61e16e"><div class="rb ab fo"><div class="rc ab rd cl cj re"><h2 class="bd iu gy z fp rf fr fs rg fu fw is bi translated">微调变压器的先进技术</h2><div class="rh l"><h3 class="bd b gy z fp rf fr fs rg fu fw dk translated">学习这些先进的技术，看看它们如何帮助改善结果</h3></div><div class="ri l"><p class="bd b dl z fp rf fr fs rg fu fw dk translated">towardsdatascience.com</p></div></div><div class="rj l"><div class="rq l rl rm rn rj ro ks ra"/></div></div></a></div><div class="qx qy gp gr qz ra"><a rel="noopener follow" target="_blank" href="/aws-certified-machine-learning-specialty-97eacbd1a0fe"><div class="rb ab fo"><div class="rc ab rd cl cj re"><h2 class="bd iu gy z fp rf fr fs rg fu fw is bi translated">AWS认证机器学习—专业</h2><div class="rh l"><h3 class="bd b gy z fp rf fr fs rg fu fw dk translated">关于如何准备和通过考试的提示和建议</h3></div><div class="ri l"><p class="bd b dl z fp rf fr fs rg fu fw dk translated">towardsdatascience.com</p></div></div><div class="rj l"><div class="rr l rl rm rn rj ro ks ra"/></div></div></a></div><div class="qx qy gp gr qz ra"><a href="https://pub.towardsai.net/building-a-product-recommendation-engine-with-aws-sagemaker-321a0e7c7f7b" rel="noopener  ugc nofollow" target="_blank"><div class="rb ab fo"><div class="rc ab rd cl cj re"><h2 class="bd iu gy z fp rf fr fs rg fu fw is bi translated">用AWS SageMaker构建产品推荐引擎</h2><div class="rh l"><h3 class="bd b gy z fp rf fr fs rg fu fw dk translated">了解如何使用Amazon SageMaker因式分解机构建和训练个性化推荐引擎</h3></div><div class="ri l"><p class="bd b dl z fp rf fr fs rg fu fw dk translated">pub.towardsai.net</p></div></div><div class="rj l"><div class="rs l rl rm rn rj ro ks ra"/></div></div></a></div></div></div>    
</body>
</html>