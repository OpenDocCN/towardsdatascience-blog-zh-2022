<html>
<head>
<title>A Deep Dive into Stacking Ensemble Machine Learning — Part III</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入探讨堆叠集成机器学习—第三部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-deep-dive-into-stacking-ensemble-machine-learning-part-iii-1ebd6bedc442#2022-03-02">https://towardsdatascience.com/a-deep-dive-into-stacking-ensemble-machine-learning-part-iii-1ebd6bedc442#2022-03-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0d4c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何通过在Python和Jupyter中实现一个从零开始的堆叠模型来充分理解堆叠并在机器学习中有效地使用它</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2d420a2545a608a63b549a3cb4f4daea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vYFLsDkljoM6wG4LERwM-w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">蒂姆·怀尔德史密斯在<a class="ae ky" href="https://unsplash.com/s/photos/stack-of-books?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h2 id="ea30" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">背景</h2><p id="c565" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在我最近的两篇关于使用堆栈实现集成机器学习算法的文章中，我探讨了堆栈是如何工作的，以及如何在<code class="fe mo mp mq mr b">scikit-learn</code>中构建和理解堆栈算法。</p><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/a-deep-dive-into-stacking-ensemble-machine-learning-part-i-10476b2ade3"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">深入研究堆叠集成机器学习—第一部分</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">如何通过充分理解堆叠是什么以及如何工作，在机器学习中有效地使用堆叠</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj ks mv"/></div></div></a></div><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/a-deep-dive-into-stacking-ensemble-machine-learning-part-ii-69bfc0d6e53d"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">深入研究堆叠集成机器学习—第二部分</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">如何通过在Python、Jupyter和Scikit-Learn中实现堆栈来有效地在机器学习中使用堆栈</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj ks mv"/></div></div></a></div><p id="f8e1" class="pw-post-body-paragraph lv lw it lx b ly nk ju ma mb nl jx md li nm mf mg lm nn mi mj lq no ml mm mn im bi translated">本系列的最后一篇文章将通过从头构建一个堆叠算法，并使用流水线来链接0级和1级模型，进一步加深对这个问题的理解。</p><h2 id="d59d" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">入门指南</h2><p id="ed46" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">与本系列的其他文章一样，我们需要导入一组将在代码中使用的库，并创建一些常量…</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="e06f" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">获取一些数据</h2><p id="ef0f" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">我们还将坚持使用其他文章中使用过的相同数据集…</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/29dea16cc56796f831216b11d281a2a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PXdj-f7ZZvFAVPzyC07czw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="7c95" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">第二部分的快速提醒</h2><p id="2f5d" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">如果你想知道所有的细节，请回头看看第二部分(或者在进行任何编码之前，回头看看第一部分的原则指南)。</p><p id="9164" class="pw-post-body-paragraph lv lw it lx b ly nk ju ma mb nl jx md li nm mf mg lm nn mi mj lq no ml mm mn im bi translated">总之,<code class="fe mo mp mq mr b">scikit-learn</code>在第二部分中被用于实现堆叠部分，其中0级和1级模型被组合以产生一个分类器，该分类器通过添加分类预测作为工程特征来提高性能</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/4407f7bcd36a99cb64497d04de804734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XOsoyzF6a9ugIizT_PMI8A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/3d99d37f0d7e79bbc69f2042d5ae36ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r2Hf61OkFSzs-ioLE4wP6g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="ebe8" class="pw-post-body-paragraph lv lw it lx b ly nk ju ma mb nl jx md li nm mf mg lm nn mi mj lq no ml mm mn im bi translated">下一步是使用经过训练的堆积模型来生成一组预测…</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/5df4b791a31d3a8d15e646b98212190a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*amiOkHXsrvQt7Si-GZ5oDw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><pre class="kj kk kl km gt nv mr nw nx aw ny bi"><span id="a5f1" class="kz la it mr b gy nz oa l ob oc">array([0, 1, 0, ..., 0, 0, 0])</span></pre><h2 id="72c8" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">从头开始构建堆叠分类器</h2><p id="89a3" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">临时构建的分类器的设计如下-</p><ol class=""><li id="ef8d" class="od oe it lx b ly nk mb nl li of lm og lq oh mn oi oj ok ol bi translated">使用<code class="fe mo mp mq mr b">Transformer</code>模式构建一组0级模型。</li><li id="6e91" class="od oe it lx b ly om mb on li oo lm op lq oq mn oi oj ok ol bi translated">将级别1模型实现为一个简单的分类器。</li><li id="273e" class="od oe it lx b ly om mb on li oo lm op lq oq mn oi oj ok ol bi translated">使用管道将两者连接在一起。</li></ol><h2 id="106c" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">1.使用Python中的面向对象技术构建0级和1级模型</h2><p id="9490" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">使用<code class="fe mo mp mq mr b">Transformer</code>模式构建0级模型，使用<code class="fe mo mp mq mr b">Estimator</code>模式构建1级模型，如下所示-</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="9f89" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">2.使用管道训练堆叠模型</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/0547398ddf28385cdecae16445c53b39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*alKyxlsYvwwF13QMO_eHCw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="9268" class="pw-post-body-paragraph lv lw it lx b ly nk ju ma mb nl jx md li nm mf mg lm nn mi mj lq no ml mm mn im bi translated">首先要注意的是，临时构建堆栈模型在训练阶段产生与<code class="fe mo mp mq mr b">scikit-learn</code>相同的输出，这是对实现的良好验证。</p><p id="613a" class="pw-post-body-paragraph lv lw it lx b ly nk ju ma mb nl jx md li nm mf mg lm nn mi mj lq no ml mm mn im bi translated">第二件要注意的事情是,<code class="fe mo mp mq mr b">icecream</code>调试输出告诉我们管道是如何工作的(注意:我可以使用<code class="fe mo mp mq mr b">print</code>语句，但是当代码被移入外部库时<code class="fe mo mp mq mr b">icecream</code>仍然工作，而<code class="fe mo mp mq mr b">print</code>只在本地工作)</p><ul class=""><li id="8371" class="od oe it lx b ly nk mb nl li of lm og lq oh mn os oj ok ol bi translated">管道必须由一个或多个<code class="fe mo mp mq mr b">Transformer</code>对象组成，后跟一个<code class="fe mo mp mq mr b">Estimator</code>对象。</li><li id="b622" class="od oe it lx b ly om mb on li oo lm op lq oq mn os oj ok ol bi translated">在任何事情发生之前，对每个对象调用<code class="fe mo mp mq mr b">init</code>方法。</li><li id="9430" class="od oe it lx b ly om mb on li oo lm op lq oq mn os oj ok ol bi translated">当在管道上调用<code class="fe mo mp mq mr b">fit()</code>方法id时...</li><li id="b638" class="od oe it lx b ly om mb on li oo lm op lq oq mn os oj ok ol bi translated">对于每个<code class="fe mo mp mq mr b">Transformer</code>，调用<code class="fe mo mp mq mr b">fit()</code>方法，然后调用<code class="fe mo mp mq mr b">transform()</code>方法。这是调用训练数据的正确方法顺序。</li><li id="c713" class="od oe it lx b ly om mb on li oo lm op lq oq mn os oj ok ol bi translated">对于管道中的最后一个对象(<code class="fe mo mp mq mr b">Estimator</code>)，只调用了<code class="fe mo mp mq mr b">fit</code>方法。</li></ul><p id="03f9" class="pw-post-body-paragraph lv lw it lx b ly nk ju ma mb nl jx md li nm mf mg lm nn mi mj lq no ml mm mn im bi translated">我构建<code class="fe mo mp mq mr b">Level1Stacker</code>类而不是直接添加<code class="fe mo mp mq mr b">Estimator</code>的原因是，我可以向<code class="fe mo mp mq mr b">icecream</code>添加调试语句，以准确演示正在调用的方法。</p><p id="5c8c" class="pw-post-body-paragraph lv lw it lx b ly nk ju ma mb nl jx md li nm mf mg lm nn mi mj lq no ml mm mn im bi translated"><code class="fe mo mp mq mr b">Level0Stacker</code>类不是很复杂。<code class="fe mo mp mq mr b">fit()</code>方法只是将0级模型中的每个分类器与整个训练数据相匹配。我已经查看了一些代码样本，其中使用了出折叠预测，但是<code class="fe mo mp mq mr b">scikit-learn</code>在整个X上训练，所以对我来说已经足够好了。</p><p id="785c" class="pw-post-body-paragraph lv lw it lx b ly nk ju ma mb nl jx md li nm mf mg lm nn mi mj lq no ml mm mn im bi translated">也值得考虑一下<code class="fe mo mp mq mr b">copy_data</code>helper函数的情况。我发现，当<code class="fe mo mp mq mr b">DataFrame</code>对象通过管道传递时，管道会崩溃，除非每一步都严格地处理已经重置了索引的深层副本。</p><p id="2a27" class="pw-post-body-paragraph lv lw it lx b ly nk ju ma mb nl jx md li nm mf mg lm nn mi mj lq no ml mm mn im bi translated"><code class="fe mo mp mq mr b">transform()</code>方法简单地在0级模型周围迭代，根据<code class="fe mo mp mq mr b">stack_method</code>参数的设置调用<code class="fe mo mp mq mr b">predict</code>或<code class="fe mo mp mq mr b">predict_proba</code>，然后将预测作为新特征添加到数据中。</p><p id="1feb" class="pw-post-body-paragraph lv lw it lx b ly nk ju ma mb nl jx md li nm mf mg lm nn mi mj lq no ml mm mn im bi translated">非常重要的是，用<code class="fe mo mp mq mr b">fit()</code>方法拟合0级模型，然后用<code class="fe mo mp mq mr b">transform()</code>方法进行预测，我们将在下面看到...</p><h2 id="0f9d" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">3.根据测试数据进行预测</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/a16d35319d22e0095cd8c2195d210600.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZFirmjA6RVZrRIQ21dB5Dw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><pre class="kj kk kl km gt nv mr nw nx aw ny bi"><span id="8771" class="kz la it mr b gy nz oa l ob oc">array([1, 1, 0, ..., 0, 0, 0])</span></pre><p id="29e4" class="pw-post-body-paragraph lv lw it lx b ly nk ju ma mb nl jx md li nm mf mg lm nn mi mj lq no ml mm mn im bi translated">再次，<code class="fe mo mp mq mr b">icecream</code>调试使我们能够看到到底发生了什么。调用管道上的<code class="fe mo mp mq mr b">predict()</code>方法依次调用每个<code class="fe mo mp mq mr b">Transformer</code>的<code class="fe mo mp mq mr b">transform()</code>方法，然后调用<code class="fe mo mp mq mr b">Estimator</code>对象的<code class="fe mo mp mq mr b">predict()</code>方法。</p><h2 id="b9fe" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">有效果吗？</h2><p id="f8ff" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">嗯，我们已经成功地从零开始建立了一个堆叠模型。训练模型并生成作为新数据特征的0级预测的步骤肯定有效，因为临时构建的模型的输出与<code class="fe mo mp mq mr b">scikit-learn</code>相同。</p><p id="89c8" class="pw-post-body-paragraph lv lw it lx b ly nk ju ma mb nl jx md li nm mf mg lm nn mi mj lq no ml mm mn im bi translated">然而，最终的预测是不一样的…</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><pre class="kj kk kl km gt nv mr nw nx aw ny bi"><span id="82f6" class="kz la it mr b gy nz oa l ob oc">Accuracy of scikit-learn stacking classifier: 0.8825<br/>Accuracy of scratch built stacking classifier: 0.8735</span></pre><p id="1d04" class="pw-post-body-paragraph lv lw it lx b ly nk ju ma mb nl jx md li nm mf mg lm nn mi mj lq no ml mm mn im bi translated"><code class="fe mo mp mq mr b">scikit-learn</code> <code class="fe mo mp mq mr b">StackingClassifier</code>的文档说明-</p><p id="8e3d" class="pw-post-body-paragraph lv lw it lx b ly nk ju ma mb nl jx md li nm mf mg lm nn mi mj lq no ml mm mn im bi translated">"<code class="fe mo mp mq mr b">estimators_</code>在全X上拟合，而<code class="fe mo mp mq mr b">final_estimator_</code>通过使用<code class="fe mo mp mq mr b">cross_val_predict</code>的基础估计器的交叉验证预测进行训练"</p><p id="d93c" class="pw-post-body-paragraph lv lw it lx b ly nk ju ma mb nl jx md li nm mf mg lm nn mi mj lq no ml mm mn im bi translated">然而，当我试图在临时构建堆栈器中复制时，精确度远低于<code class="fe mo mp mq mr b">scikit-learn</code>堆栈模型或在最后一步没有交叉折叠验证的临时构建模型</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/6e4f3140efe7c83d258694e7723a89c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bsH3HFCHexYzdqMRahl2lA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><pre class="kj kk kl km gt nv mr nw nx aw ny bi"><span id="6951" class="kz la it mr b gy nz oa l ob oc">Accuracy of scratch built stacking classifier using level 1 cross-validation: 0.8195</span></pre><p id="37c1" class="pw-post-body-paragraph lv lw it lx b ly nk ju ma mb nl jx md li nm mf mg lm nn mi mj lq no ml mm mn im bi translated">这有点令人不满意，但我永远也不会知道<code class="fe mo mp mq mr b">scikit-learn</code>堆叠模型的1级部分是如何实现的，除非我能看到代码或与其中一名开发人员交谈，而不是能够做到这一点，我对调查和研究实现了其目标感到满意。</p><h1 id="1a5b" class="ov la it bd lb ow ox oy le oz pa pb lh jz pc ka ll kc pd kd lp kf pe kg lt pf bi translated">结论</h1><p id="21c6" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">这组文章的第一部分旨在提供一个简单易懂的解释，解释什么是堆叠以及它是如何工作的。第二部分通过提供一个使用<code class="fe mo mp mq mr b">scikit-learn</code>库的完整工作示例和更详细的解释对此进行了扩展。第三部分通过使用Python面向对象和<code class="fe mo mp mq mr b">Transformer</code>和<code class="fe mo mp mq mr b">Estimator</code>编码模式从头构建一个完整的堆栈模型来完成探索。</p><p id="7a8f" class="pw-post-body-paragraph lv lw it lx b ly nk ju ma mb nl jx md li nm mf mg lm nn mi mj lq no ml mm mn im bi translated">从零开始构建一个堆叠模型已经证明是一个练习，它完善了我对堆叠如何工作的理解。我能够精确地复制<code class="fe mo mp mq mr b">scikit-learn</code>模型的训练阶段，但是我不能完全复制库为最终1级预测工作的方式。尽管如此，这项研究让我了解了如何使用堆叠，何时使用以及何时不使用。</p><p id="c537" class="pw-post-body-paragraph lv lw it lx b ly nk ju ma mb nl jx md li nm mf mg lm nn mi mj lq no ml mm mn im bi translated">将来，只要我认为堆叠在一起的多个模型的复杂性增加以及解释最终模型如何达到其预测的相关困难被驱动更高准确性和改进性能的更大需求所抵消，我就会使用堆叠的<code class="fe mo mp mq mr b">scikit-learn</code>实现。</p><p id="0c49" class="pw-post-body-paragraph lv lw it lx b ly nk ju ma mb nl jx md li nm mf mg lm nn mi mj lq no ml mm mn im bi translated">我希望这一系列文章能够帮助其他数据科学家充分理解这种有效而迷人的技术，并消除一些关于堆叠内部究竟发生了什么以及如何工作的神秘。</p><h1 id="5a05" class="ov la it bd lb ow ox oy le oz pa pb lh jz pc ka ll kc pd kd lp kf pe kg lt pf bi translated">感谢您的阅读！</h1><p id="86ef" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">如果你喜欢读这篇文章，为什么不去https://grahamharrison-86487.medium.com/的<a class="ae ky" href="https://grahamharrison-86487.medium.com/" rel="noopener">看看我的其他文章呢？此外，我很乐意听到您对这篇文章、我的任何其他文章或任何与数据科学和数据分析相关的内容的看法。</a></p><p id="f565" class="pw-post-body-paragraph lv lw it lx b ly nk ju ma mb nl jx md li nm mf mg lm nn mi mj lq no ml mm mn im bi translated">如果你想联系我讨论这些话题，请在LinkedIn上找我—【https://www.linkedin.com/in/grahamharrison1 T4】或者发电子邮件给我<a class="ae ky" href="mailto:GHarrison@lincolncollege.ac.uk" rel="noopener ugc nofollow" target="_blank">ghar rison @ Lincoln college . AC . uk</a>。</p><p id="e8a0" class="pw-post-body-paragraph lv lw it lx b ly nk ju ma mb nl jx md li nm mf mg lm nn mi mj lq no ml mm mn im bi translated">如果你想通过订阅来支持作者和全世界1000个为文章写作做出贡献的人，请使用下面的链接(注意:如果你使用这个链接免费注册，作者将收到一定比例的费用)。</p><div class="ms mt gp gr mu mv"><a href="https://grahamharrison-86487.medium.com/membership" rel="noopener follow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">通过我的推荐链接加入媒体-格雷厄姆哈里森</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">grahamharrison-86487.medium.com</p></div></div><div class="ne l"><div class="pg l ng nh ni ne nj ks mv"/></div></div></a></div></div></div>    
</body>
</html>