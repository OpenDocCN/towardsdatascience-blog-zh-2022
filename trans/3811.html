<html>
<head>
<title>Random Forest Regression for Continuous Well Log Prediction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">连续测井预测的随机森林回归</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/random-forest-regression-for-continuous-well-log-prediction-61d3ec1c683a#2022-08-24">https://towardsdatascience.com/random-forest-regression-for-continuous-well-log-prediction-61d3ec1c683a#2022-08-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="5cae" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">机器学习|岩石物理学</h2><div class=""/><div class=""><h2 id="eb90" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">应用于岩石物理学的流行机器学习算法综述</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/9dc4ee0a8c99656faeffd48e78be9691.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7mXV-WsrAgscRMNf7CV9Jw.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">HoliHo的照片:<a class="ae lh" href="https://www.pexels.com/photo/pathway-in-between-trees-at-daytime-1112186/" rel="noopener ugc nofollow" target="_blank">https://www . pexels . com/photo/pathway-in-trees-between-daytime-1112186/</a></p></figure><p id="f5cd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">随机森林是一种非常流行，也相对容易理解的机器学习算法。<a class="ae lh" href="https://medium.com/p/4a1380ef025b" rel="noopener">在我之前关于随机森林的文章中，我们试图从一系列测井测量中预测分类数据(岩性)。</a>在本文中，我们将重点关注连续测量的预测。</p><h1 id="ad77" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">回归随机森林简介</h1><p id="d57a" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">在很高的层次上，随机森林本质上是决策树的集合(系综)。决策树理解起来非常简单和直观。我们经常在日常生活中使用它们来做决定，尽管我们可能没有意识到。</p><p id="b1fc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你想知道随机森林是如何应用于分类问题的，可以看看下面的文章。</p><div class="nb nc gp gr nd ne"><a rel="noopener follow" target="_blank" href="/random-forest-for-lithology-classification-from-well-log-data-4a1380ef025b"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jd gy z fp nj fr fs nk fu fw jc bi translated">用于测井数据岩性分类的随机森林</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">用机器学习对地下进行分类</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns lb ne"/></div></div></a></div><p id="a37d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在分类的情况下，我们试图使用决策将我们的数据分开，并将它们放入类中。当它们应用于回归时，我们试图做类似的事情，但我们预测的不是一个类，而是一个值。</p><p id="ad2c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在树的顶端(根节点),我们首先做出一个决定，拆分我们的数据。这一过程沿树向下继续，直到不能再进行分割，这通常定义为每个末端节点(叶节点)的最小样本数或树的最大深度。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nt"><img src="../Images/8400d5c1381afcd0b763307da275e40f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k5b4lWcy75nZC0HdLg_RIw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">随机森林中的单个决策树示例。图片由作者提供。</p></figure><p id="609a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">随机森林算法由以随机方式构造的多个决策树形成。这包括随机抽样我们的数据，并从我们的数据集中为每棵树随机选择变量/特征。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nu"><img src="../Images/05cf482d9657fa7ff70ccbd3f023ee2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DAY61ORImpaE0ndTLVTiyw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">使用测井/岩石物理数据的随机森林回归示例。图片由作者提供。</p></figure><p id="638a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一旦森林建成，我们将所有预测的平均值作为最终的输出值。与单个决策树相比，这种平均允许我们提高预测的准确性，并且还减少了过度拟合的机会。</p><p id="24cf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们已经对随机森林回归有了很高的理解，我们可以继续我们的Python示例，看看如何实现从测井测量预测声波压缩慢度。</p><p id="9294" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">即使您不熟悉测井测量或岩石物理学，所使用的大部分代码也可以应用于任何数据集。</p><h1 id="6aa0" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">本教程中使用的数据</h1><p id="e190" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">本教程中使用的数据是Equinor在2018年发布的Volve数据集的子集。数据集的全部细节，包括许可证可以在下面的链接中找到。</p><div class="nb nc gp gr nd ne"><a href="https://www.equinor.com/energy/volve-data-sharing" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jd gy z fp nj fr fs nk fu fw jc bi translated">Volve现场数据集</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">Equinor已经正式发布了一套完整的北海油田数据，供研究、学习和应用</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">www.equinor.com</p></div></div><div class="nn l"><div class="nv l np nq nr nn ns lb ne"/></div></div></a></div><p id="c78e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Volve数据许可证基于CC BY 4.0许可证。许可协议的全部细节可以在这里找到:</p><p id="6f77" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://cdn.sanity.io/files/h61q9gi9/global/de6532f6134b9a953f6c41bac47a0c055a3712d3.pdf?equinor-hrs-terms-and-conditions-for-licence-to-data-volve.pdf" rel="noopener ugc nofollow" target="_blank">https://cdn . sanity . io/files/h 61 q 9 gi 9/global/de 6532 f 6134 b 9 a 953 f 6 c 41 BAC 47 a 0 c 055 a 3712d 3 . pdf？equinor-hrs-条款和条件-许可-数据-volve.pdf </a></p><h1 id="b4e2" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">导入库和数据</h1><p id="4fd8" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">本教程的第一步是导入我们将要使用的库。在这个例子中，我们将结合使用<a class="ae lh" href="http://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> pandas </a>来加载和存储我们的数据，以及<a class="ae lh" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> matplotlib </a>来可视化我们的数据。</p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="e8ab" class="ob mf it nx b gy oc od l oe of">import pandas as pd<br/>import matplotlib.pyplot as plt</span></pre><p id="b03d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，我们将使用<code class="fe og oh oi nx b">pd.read_csv()</code>从csv文件导入数据。在这个函数中，我们将传入我们的文件路径以及我们将使用的列。只要csv文件包含每一列的标题，我们就可以使用<code class="fe og oh oi nx b">usecols</code>参数。</p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="9819" class="ob mf it nx b gy oc od l oe of">df = pd.read_csv('Data/Volve/volve_wells.csv', usecols=['WELL', 'DEPTH', 'RHOB', 'GR', 'NPHI', 'PEF', 'DT'])</span></pre><h1 id="d510" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">检查我们有哪些井</h1><p id="19bd" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">数据成功加载后，我们可以检查一下，看看我们有哪些井。最简单的方法是在包含井名(数据源)的井列上调用<code class="fe og oh oi nx b">.unique()</code>。</p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="96a8" class="ob mf it nx b gy oc od l oe of">df['WELL'].unique()</span></pre><p id="d7b6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它返回:</p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="ecc5" class="ob mf it nx b gy oc od l oe of">array(['15/9-F-11 B', '15/9-F-11 A', '15/9-F-1 B', '15/9-F-1 A'],<br/>      dtype=object)</span></pre><p id="aa0b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以看到Volve油田有四口井。</p><h1 id="738e" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">创建培训、测试和验证数据集</h1><p id="dd47" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">由于我们使用多口井的测量数据，将我们的数据分成有效子集进行训练、验证和测试的一种方法是留出一口井(盲测试井),用于观察我们的模型在未知数据上的表现，然后使用剩余的井进行训练。</p><p id="ddbb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">需要注意的一点是，测试和验证数据集的术语可能因文章、网站和视频而异。这里使用的定义说明如下:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oj"><img src="../Images/eb3cd039534286e1b74a910d06817df5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MF3B-hznDKihUoNQwzcBPQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">将数据分为训练、验证和测试的示例。图片由作者提供，来自麦当劳，2021。</p></figure><p id="a458" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">训练数据集:</strong>用于训练模型的数据</p><p id="22f9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">验证数据集:</strong>用于验证模型和调整参数的数据。</p><p id="013c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">测试数据集:</strong>留出的数据，用于在看不见的数据上测试最终模型。</p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="21d6" class="ob mf it nx b gy oc od l oe of"># Training Wells<br/>training_wells = ['15/9-F-11 B', '15/9-F-11 A', '15/9-F-1 A']</span><span id="0e91" class="ob mf it nx b gy ok od l oe of"># Test Well<br/>test_well = ['15/9-F-1 B']</span><span id="3399" class="ob mf it nx b gy ok od l oe of">train_val_df = df[df['WELL'].isin(training_wells)].copy()<br/>test_df = df[df['WELL'].isin(test_well)].copy()</span><span id="8c18" class="ob mf it nx b gy ok od l oe of">train_val_df.describe()</span></pre><p id="2033" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这将返回我们的训练数据集:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ol"><img src="../Images/9bfd5aae379d6c6a6839e22f842656c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iNnNgORZ9wiqK03N4424Dw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">我们的训练数据集的数据帧统计。图片由作者提供。</p></figure><p id="ac61" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们还可以对测试数据集进行同样的操作，以确认数据帧已经创建。</p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="e47b" class="ob mf it nx b gy oc od l oe of">test_df.describe()</span></pre><p id="3565" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这将返回下面的数据帧，其中包含我们的测试数据集所需的曲线。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi om"><img src="../Images/82d2a4cfffd503a26b55bac5f86238bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*HnMDAVEUFFbceu36KBK5eA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">我们的测试数据集的数据帧统计。图片由作者提供。</p></figure><h1 id="13b7" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">从数据帧中删除缺失值</h1><p id="d16c" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">我们可以从前面的图像中看到，每列的计数行中有不同的数字。这表明我们缺少值。</p><p id="5a3c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从数据帧中移除缺失值是处理它们的一种方法，但是，这样做会减少可用的训练数据量。</p><p id="3cf2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">从数据集中移除值时应小心谨慎，应进行完整的EDA以了解值缺失的原因。可以使用其他更复杂的方法来填充具有更可能和更合理的值的nan。</strong></p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="af27" class="ob mf it nx b gy oc od l oe of">train_val_df.dropna(inplace=True)<br/>test_df.dropna(inplace=True)<br/>train_val_df.describe()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi on"><img src="../Images/795c180068532219caf37f4d6a0beffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IjOMgOFy8yDnXQe7wTfJsQ.png"/></div></div></figure><h1 id="1c85" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">实现随机森林回归模型</h1><p id="3368" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">既然我们已经准备好了数据并移除了缺失值，现在我们可以继续构建随机森林回归模型了。为此，我们需要从<a class="ae lh" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> Scikit-learn </a>库中导入一些模块。</p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="5e4c" class="ob mf it nx b gy oc od l oe of">from sklearn.model_selection import train_test_split<br/>from sklearn import metrics<br/>from sklearn.ensemble import RandomForestRegressor</span></pre><p id="aba0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，我们需要将我们的数据分成哪些变量将用于训练模型(X)和我们的目标变量，<code class="fe og oh oi nx b">DT</code> (y)。</p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="52bf" class="ob mf it nx b gy oc od l oe of">X = train_val_df[['RHOB', 'GR', 'NPHI', 'PEF']]<br/>y = train_val_df['DT']</span></pre><p id="9420" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们接下来调用<code class="fe og oh oi nx b">train_test_split()</code>函数将我们的数据分成训练和验证数据集。</p><p id="8a0a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们传入X和y变量，以及表示我们想要多大的测试数据集的参数。这是作为十进制值输入的，范围在0和1之间。在这种情况下，我们使用0.2，这意味着我们的测试数据集将是原始数据的20%，我们的训练数据集将是原始数据的80%。</p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="efa4" class="ob mf it nx b gy oc od l oe of">X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.2)</span></pre><h2 id="9554" class="ob mf it bd mg oo op dn mk oq or dp mo lr os ot mq lv ou ov ms lz ow ox mu iz bi translated">构建随机森林回归模型</h2><p id="37a0" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">为了建立我们的回归模型，我们首先需要创建一个名为<code class="fe og oh oi nx b">regr</code>的变量。这可以是你想要的任何东西，只要有意义。</p><p id="7dea" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一旦我们初始化了模型，我们就可以根据数据进行拟合。这本质上是训练过程。如果需要，我们可以更改许多参数，但在本例中，我们将保留默认值。</p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="fdc0" class="ob mf it nx b gy oc od l oe of">regr = RandomForestRegressor()<br/>regr.fit(X_train, y_train)</span></pre><p id="fb70" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在模型被训练之后，我们可以通过调用<code class="fe og oh oi nx b">.predict()</code>对我们的验证数据进行预测。</p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="faa6" class="ob mf it nx b gy oc od l oe of">y_pred = regr.predict(X_val)</span></pre><h2 id="2337" class="ob mf it bd mg oo op dn mk oq or dp mo lr os ot mq lv ou ov ms lz ow ox mu iz bi translated">检查预测结果</h2><p id="3c5f" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">现在，我们的模型已经被训练并应用于验证数据，我们需要检查我们的模型表现如何。</p><p id="4803" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将用到的第一个指标是平均绝对误差，计算方法如下:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/22d1dd81266568f7eb2d74b93126f8c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*S82kkD3BhWzt-YHZ2aXb7A.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">平均绝对误差公式。图片由作者提供。</p></figure><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="a2af" class="ob mf it nx b gy oc od l oe of">metrics.mean_absolute_error(y_val, y_pred)</span></pre><p id="9fae" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这将返回值1.6841。这将告知我们实际测量值(<code class="fe og oh oi nx b">y_val</code>)和预测测量值(<code class="fe og oh oi nx b">y_pred</code>)之间的平均绝对误差，其测量单位与目标特征相同。在这种情况下，美国/英尺。</p><p id="4783" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以利用的另一个指标是均方根误差(RMSE)。这可以通过以下方式计算:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/caeecbf32e3a45d5de2b194a745a129e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*epBPSpZC1zq420vSGRHlzg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">均方根误差(RMSE)公式。图片由作者提供。</p></figure><p id="e13a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要使用scikit-learn计算RMSE，我们首先需要计算均方误差，然后求它的平方根，这可以通过将MSE提高到0.5的幂来实现。</p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="86f0" class="ob mf it nx b gy oc od l oe of">mse = metrics.mean_squared_error(y_val, y_pred)<br/>rmse = mse**0.5</span></pre><p id="564d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这将返回值3.0664。RMSE方程为我们提供了预测误差大小的概念。</p><h2 id="ae43" class="ob mf it bd mg oo op dn mk oq or dp mo lr os ot mq lv ou ov ms lz ow ox mu iz bi translated">超越度量标准</h2><p id="521e" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">像上面这样的简单指标是查看模型表现的好方法，但是您应该总是检查实际数据。</p><p id="db10" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一种方法是使用散点图，x轴表示验证数据，y轴表示预测数据。为了帮助观想，我们可以添加一条一对一的关系线。</p><p id="dfce" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">完成这项工作的代码如下。</p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="9b79" class="ob mf it nx b gy oc od l oe of">plt.scatter(y_val, y_pred)<br/>plt.xlim(40, 140)<br/>plt.ylim(40, 140)<br/>plt.ylabel('Predicted DT')<br/>plt.xlabel('Actual DT')<br/>plt.plot([40,140], [40,140], 'black') #1 to 1 line</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/627ef8d56e84f448861b8d6e2afe6d04.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*JtOPN6dKQg9fSOdHOysDag.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">实际测量值与预测测量值的散点图。图片由作者提供。</p></figure><p id="1026" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们得到的是上面的图，这表明我们有一个相当好的预测。有几个点在60到80 us/ft之间，预测值高于实际值。</p><p id="f009" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">理想情况下，我们应该回到我们的数据或模型，看看我们是否可以改善这种预测。这可能涉及改变输入、检查异常值、处理异常值以及收集更多数据。</p><h2 id="4353" class="ob mf it bd mg oo op dn mk oq or dp mo lr os ot mq lv ou ov ms lz ow ox mu iz bi translated">测试数据预测(盲测试井)</h2><p id="45c8" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">一旦我们最终确定了我们的模型，我们就可以用我们为盲测留出的数据来测试它了。</p><p id="2481" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我们将创建用于应用模型的特征。</p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="5bb8" class="ob mf it nx b gy oc od l oe of">test_well_x = test_df[['RHOB', 'GR', 'NPHI', 'PEF']]</span></pre><p id="591a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，我们将为预测数据的数据框架分配一个新列。</p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="d535" class="ob mf it nx b gy oc od l oe of">test_df['TEST_DT'] = regr.predict(test_well_x)</span></pre><p id="d530" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">预测完成后，我们可以查看与上面相同的散点图。</p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="fe54" class="ob mf it nx b gy oc od l oe of">plt.scatter(test_df['DT'], test_df['TEST_DT'])<br/>plt.xlim(40, 140)<br/>plt.ylim(40, 140)<br/>plt.ylabel('Predicted DT')<br/>plt.xlabel('Actual DT')<br/>plt.plot([40,140], [40,140], 'black') #1 to 1 line</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/d0ddc452d3b3753513ef6e58b70c7b8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*I9wbdLcnXJqoJpW9rVwzYg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">实际测量值与预测测量值的散点图。图片由作者提供。</p></figure><p id="2067" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了更好地了解预测相对于实际测量的效果，我们可以查看一个简单的数据对深度的线图。</p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="4284" class="ob mf it nx b gy oc od l oe of">plt.figure(figsize=(15, 5))<br/>plt.plot(test_df['DEPTH'], test_df['DT'], label='Actual DT')<br/>plt.plot(test_df['DEPTH'], test_df['TEST_DT'], label='Predicted DT')<br/>plt.xlabel('Depth (m)')<br/>plt.ylabel('DT')<br/>plt.ylim(40, 140)<br/>plt.legend()<br/>plt.grid()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pc"><img src="../Images/0a6d6ab7e230bf142d36e350bce6ef4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h9VcFV2iLsNavAjUT2uqmA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">预测测量值与实际测量值的线图(对数图)。图片由作者提供。</p></figure><p id="9efe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如上所述，这个简单的模型表现得相当好。然而，有几个地区的结果预测不足(在3170米和3200米之间)，也有一些地区我们预测过高(在3370米和3450米之间)。</p><h1 id="c9fe" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">摘要</h1><p id="c973" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">随机森林是一种强大的机器学习算法，可以同样应用于基于分类和回归的问题。不需要对模型进行重大调整，我们就可以得到一个好的结果，尤其是在盲测数据上。随着模型的进一步调整和新数据训练的引入，我们可能能够提高模型的泛化能力。但是，请记住，随着数据集变得越来越大，训练时间也会增加。</p><p id="5387" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在达到最终模型之前，比较几个机器学习模型的结果也是值得的。</p></div><div class="ab cl pd pe hx pf" role="separator"><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi"/></div><div class="im in io ip iq"><p id="6890" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="pk">感谢阅读。在你走之前，你一定要订阅我的内容，把我的文章放到你的收件箱里。</em> <a class="ae lh" href="https://andymcdonaldgeo.medium.com/subscribe" rel="noopener"> <strong class="lk jd"> <em class="pk">你可以在这里做！</em></strong></a><strong class="lk jd"><em class="pk"/></strong><em class="pk">或者，您也可以</em> <a class="ae lh" href="https://fabulous-founder-2965.ck.page/2ca286e572" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> <em class="pk">注册我的简讯</em> </strong> </a> <em class="pk">免费将更多内容直接发送到您的收件箱。</em></p><p id="1210" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">其次，通过注册会员，你可以获得完整的媒介体验，并支持我和其他成千上万的作家。它每个月只花你5美元，你可以完全接触到所有令人惊叹的媒体文章，也有机会用你的写作赚钱。如果你用 <a class="ae lh" href="https://andymcdonaldgeo.medium.com/membership" rel="noopener"> <strong class="lk jd"> <em class="pk">我的链接</em></strong></a><strong class="lk jd"><em class="pk"/></strong><em class="pk">报名，你直接用你的一部分费用支持我，不会多花你多少钱。如果你这样做了，非常感谢你的支持！</em></p></div></div>    
</body>
</html>