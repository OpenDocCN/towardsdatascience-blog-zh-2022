<html>
<head>
<title>Strong Static Typing to Prevent Illegal Code States | Python Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">防止非法代码状态的强大静态类型| Python模式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/strong-static-typing-to-prevent-illegal-code-states-7a13e122cbab#2022-07-26">https://towardsdatascience.com/strong-static-typing-to-prevent-illegal-code-states-7a13e122cbab#2022-07-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d169" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python静态类型专注于业务逻辑，而不是使用“使非法状态不可表示”模式来验证数据的正确性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e2ec7e05bd0ee0b4a43077be58e9c4b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4pVvRdXPx0tpL0WO"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@wesleyphotography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">韦斯利·廷吉</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="c31c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python的动态类型简化了生命周期很短的脚本的编写。然而，尽管Python经常被认为是一种“脚本语言”，但它在机器学习和数据科学领域事实上的垄断地位使得它成为大型项目的常见选择，这些项目将被使用多年。</p><p id="36d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当软件应该被长期使用时，动态类型的短期便利性可能与易于理解的需要相冲突，并且通常与有原则的软件工程相冲突，因此静态类型系统可能是受青睐的。静态类型系统在大型项目中有很多好处:它提供了在团队中协作所必需的类型文档，包括与未来的自己，但它也帮助你设计更好的软件。</p><p id="cff6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我个人使用Python中的工具对所有预期寿命超过几个小时的软件进行静态类型化。我开始这样做是因为我真的讨厌那些试图理解我不熟悉的代码库时，我进入了带有如下签名的关键函数:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="73df" class="mb mc it lx b gy md me l mf mg">def process(data):</span></pre><p id="d0da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面代码的问题是，不仅我们不知道它做了什么(<code class="fe mh mi mj lx b">process</code>？？)，而且我们也不知道它期望接收什么样的数据以及它返回什么数据(如果有的话)。当然，我们可以阅读代码，但是当它有几十行长时，祝你好运。无论如何，这肯定比阅读一个有意义的签名要花更多的时间，比如:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="7167" class="mb mc it lx b gy md me l mf mg">def remove_punctuation(data: str) -&gt; str:</span></pre><p id="8cc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样的签名告诉我们，我们的函数将一个字符串作为输入，并返回一个新的字符串作为输出(它是新的，因为<code class="fe mh mi mj lx b">str</code>在python中是不可变的)这是没有标点符号的原始字符串。我们在没有阅读实现甚至文档字符串的情况下获得了所有这些信息。</p><p id="8258" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个简单的例子，说明了类型系统如何使我们的代码更易读，但是当我们积极地使用类型系统而不仅仅是作为代码文档时，我们可以获得更好的结果。我们可以用较少的条件分支和正确性的静态证明来编写代码。</p><p id="be9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在继续之前，你们中的一些人可能会问，如果我们把一个不同于字符串的参数传递给上面的函数，会发生什么？显然，Python(意为Python解释器)不会在运行时阻止它，但是我们可以使用一个静态分析器，比如现在是官方Python工具的<a class="ae ky" href="https://github.com/python/mypy" rel="noopener ugc nofollow" target="_blank"> mypy </a>，或者其他类似的第三方工具。静态分析器检查您的源代码(因此，没有运行时)来执行多种分析，通常会发现bug。在特定情况下，mypy检查类型是否受到尊重。编译语言在编译器中集成了这一特性，但是由于Python被认为是一种动态类型的语言，我们不得不依赖其他工具。</p><h1 id="7d17" class="mk mc it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">例如:一些复杂的代码</h1><p id="2321" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">假设我们有运行翻译模型的代码，可以翻译文本或音频，并且一次只能给出一个输入。此外，该函数在将输入输入到模型中之前对输入运行预处理步骤。此外，文本预处理功能只能与文本输入一起传递，而音频预处理只能与音频输入一起传递。不可能混合:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="2fb5" class="mb mc it lx b gy md me l mf mg">def forward(<br/>  model: Model, <br/>  text_input: Optional[str], <br/>  audio_input: Optional[np.ndarray],<br/>  text_preprocessing: Optional[Callable[[str], np.ndarray]],<br/>  audio_preprocessing: Optional[Callable[[np.ndarray], np.ndarray]],<br/>) -&gt; np.ndarray:<br/>  if text_input and audio_input:<br/>    raise ValueError("Only one between text_input and audio_input can be provided")<br/>  if text_input:<br/>    if not text_preprocessing:<br/>      raise ValueError("text_preprocessing must be provided with text_input")<br/>    if audio_preprocessing:<br/>      raise ValueError("provided audio_preprocessing with text_input")</span><span id="e336" class="mb mc it lx b gy ng me l mf mg">    processed_input = text_preprocessing(text_input)<br/>    <br/>    # symmetric checks on audio input<br/>    .<br/>    .<br/>    .<br/>  return model(processed_input)</span></pre><p id="5fb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管处理代码量很少，但确保数据一致性的脚手架很长、很复杂且容易出错。如果我们想改变什么，它也是脆弱的。</p><div class="nh ni gp gr nj nk"><a rel="noopener follow" target="_blank" href="/machine-translation-evaluation-with-cometinho-c89880731409"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">使用Cometinho进行机器翻译评估</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">着眼于性能，减少模型大小、节省计算时间和金钱的实用建议</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">towardsdatascience.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny ks nk"/></div></div></a></div><p id="e64e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在想做的是让我们的静态分析工具，如mypy，为我们做烦人的工作，同时我们专注于建模什么是允许的，什么是非法的，以及带来价值的代码。</p><p id="d075" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是“让非法国家无代表性”背后的理念。</p><h1 id="6ce5" class="mk mc it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">使非法国家没有代表性</h1><p id="c9dd" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">这个想法最初是由<a class="ae ky" href="https://blog.janestreet.com/effective-ml-revisited/" rel="noopener ugc nofollow" target="_blank"> Yaron Minsky </a>在使用像OCaml这样的强类型语言时推广的，但是为了我们的利益，我们可以在Python中应用相同的想法。</p><p id="55e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述函数的问题是，它有4个单独的可选参数，我们无法从签名中推断出允许哪些参数组合。我们通过应用我们对问题的了解来进行改进。我们必须提供一个且只有一个输入，一个且只有一个预处理函数。因此，与其使用不描述彼此之间关系的可选值，不如让我们用Python类型和代码来表达这个想法。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="8550" class="mb mc it lx b gy md me l mf mg">Text_PP = Callable[[str], np.ndarray]<br/>Audio_PP = Callable[[np.ndarray], np.ndarray]</span><span id="0560" class="mb mc it lx b gy ng me l mf mg">def forward(<br/>  model: Model, <br/>  input: Union[str, np.ndarray], <br/>  preprocessing: Union[Text_PP, Audio_PP],<br/>) -&gt; np.ndarray:<br/>  if (isinstance(input, str) and isinstance(preprocessing, Audio_PP)) or (isinstance(input, np.ndarray) and isinstance(preprocessing, Text_PP)):<br/>    raise ValueError("Illegal combination of input and preprocessing type")</span></pre><p id="56c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先为预处理函数(Text_PP和Audio_PP)的函数类型定义类型别名，这更易于内联编写。</p><p id="e7b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我们在这个新定义中的输入可以是一个str或一个np.ndarray。没有一个是不合法的，也不可能两者都有。预处理也是一样，可以是Text_PP，也可以是Audio_PP，不能两者都是，也可以都不是。</p><p id="afb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里所做的是让我们的签名接管一些验证工作，我们可以减少函数体中的检查。</p><p id="6d3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，非法状态仍然是可表示的，因为我们可以有一个str类型的输入并预处理Audio_TT，或者输入np.ndarray并预处理Text_PP。</p><p id="eeb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的第一个函数签名的问题是大量的参数，这些参数是可替换的。通过减少参数的数量，我们成倍地减少了可能的非法状态的数量。</p><p id="aa25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以再做一次，接受一个包含输入序列和正确类型的预处理函数的单个参数。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="705e" class="mb mc it lx b gy md me l mf mg">from abc import ABC<br/>from dataclasses import dataclass</span><span id="ad20" class="mb mc it lx b gy ng me l mf mg">Text_PP = Callable[[str], np.ndarray]<br/>Audio_PP = Callable[[np.ndarray], np.ndarray]</span><span id="3d53" class="mb mc it lx b gy ng me l mf mg">class DataWithFunc(ABC):<br/>  def __init__(self, data, func):<br/>    self.data = data<br/>    self.func = func</span><span id="57a0" class="mb mc it lx b gy ng me l mf mg">  def apply(self) -&gt; np.ndarray:<br/>    return self.func(self.input)</span><span id="af61" class="mb mc it lx b gy ng me l mf mg">@dataclass<br/>class TextWithPreprocess(DataWithFunc):<br/>  data: str<br/>  func: Text_PP</span><span id="a4ef" class="mb mc it lx b gy ng me l mf mg">@dataclass<br/>class AudioWithPreprocess(DataWithFunc):<br/>  data: np.ndarray<br/>  func: Audio_PP</span><span id="cd19" class="mb mc it lx b gy ng me l mf mg">def forward(<br/>  model: Model, <br/>  input: DataWithFunc, <br/>) -&gt; np.ndarray:<br/>  return input.apply()</span></pre><p id="1910" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要做一些搭建工作，这在这个小例子中看起来像是额外的工作，但是对于那些类型可以并且应该被重用的大型项目来说非常有帮助。</p><p id="eee9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要定义一个新的类型DataWithFunc，它包含数据和一个函数，并且有一个方法将函数应用于数据。然后，我们定义了DataWithFunc的两个子类型，即TextWithPreprocess和audiowithprocessor，每个子类型定义了两个有效输入组合中的一个。最后，我们的forward函数现在只接受模型和一个DataWithFunc类型的新参数作为参数，由于它是一个抽象类(ABC ),我们需要使用一个有效的子类型:现在只有合法的表示是有效的。</p><div class="nh ni gp gr nj nk"><a rel="noopener follow" target="_blank" href="/python-polymorphism-with-class-discovery-28908ac6456f"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">带寄存器的Python多态性| Python模式</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">学习一种模式来隔离包，同时扩展Python代码的功能。</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">towardsdatascience.com</p></div></div><div class="nt l"><div class="nz l nv nw nx nt ny ks nk"/></div></div></a></div><p id="72b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种设计的一个好处是，我们可以通过再次为新的有效组合子类化DataWithFunc来添加输入和预处理类型的新组合。因为我们的输入是DataWithFunc类型，所以签名不需要改变。</p><h1 id="506c" class="mk mc it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="604e" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">“使非法状态不可表示”是一个简单而强大的想法，旨在通过巧妙使用类型系统来设计更优雅的代码。我们没有编写验证代码来确保输入数据的正确性，而是显式地对允许的状态建模，并让类型检查器来验证代码使用的正确性。</p><p id="1764" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一种强大的技术，需要实践和对语言类型系统的良好了解，但在代码可维护性和可读性方面有巨大的回报。</p><p id="5bb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我看到的唯一缺点是，它有时会导致“过度杀伤”的解决方案，并在不必要时导致过于复杂的代码，或者它不会带来任何好处。然而，只有不断地练习，你才能知道什么时候该用，什么时候不该用。</p><h1 id="72af" class="mk mc it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">中等会员</h1><p id="54f8" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">你喜欢我的文章吗？你是否正在考虑申请一个中级会员来无限制地阅读我的文章？</p><p id="c0cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您决定通过此链接订阅，您将通过您的订阅支持我，无需为您支付额外费用<a class="ae ky" href="https://medium.com/@mattiadigangi/membership" rel="noopener">https://medium.com/@mattiadigangi/membership</a></p><h1 id="393d" class="mk mc it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">进一步阅读</h1><div class="nh ni gp gr nj nk"><a rel="noopener follow" target="_blank" href="/dynamically-add-arguments-to-argparse-python-patterns-a439121abc39"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">向Argparse | Python模式动态添加参数</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">如何使用argparse.ArgumentParser根据用户输入指定不同的参数。</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">towardsdatascience.com</p></div></div><div class="nt l"><div class="oa l nv nw nx nt ny ks nk"/></div></div></a></div><div class="nh ni gp gr nj nk"><a rel="noopener follow" target="_blank" href="/tips-for-reading-and-writing-an-ml-research-paper-a505863055cf"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">阅读和撰写ML研究论文的技巧</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">从几十次同行评审中获得的经验教训</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">towardsdatascience.com</p></div></div><div class="nt l"><div class="ob l nv nw nx nt ny ks nk"/></div></div></a></div></div></div>    
</body>
</html>