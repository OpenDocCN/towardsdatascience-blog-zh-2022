<html>
<head>
<title>Stream Processing and Data Analysis with ksqlDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用ksqlDB进行流处理和数据分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/stream-processing-and-data-analysis-with-ksqldb-97f1ca4fcf6a#2022-09-20">https://towardsdatascience.com/stream-processing-and-data-analysis-with-ksqldb-97f1ca4fcf6a#2022-09-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e254" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用流式ETL管道从数据中提取答案——使用真实数据集的完整教程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1f3ff268c2f2c6063daed05fd5192930.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qEApUVWBOMW3auMd"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@realaxer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> T K </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><h1 id="46f8" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="2d74" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">数据流是当今数据工程领域的热门话题。如果你正在Medium上阅读与数据相关的帖子，或者在LinkedIn上找工作，它可能已经不知何故地打动了你。它主要以工作必备的形式出现，如Kafka、Flink、Spark或其他面向大数据应用的复杂工具。</p><p id="870e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这些工具被大公司用来增强他们的数据处理能力。最近，我在巴西公共部门经历了IT的现实，所以我不仅在思考数据流如何帮助公司，还(直接)帮助社会。</p><p id="167f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">一如既往，我认为没有比尝试一个真实的(或几乎真实的)项目更好的方法来学习这些工具和验证我的想法。在本帖中，我们将探索使用ksqlDB(Kafka相关工具)来简化道路事故的数据分析，使用来自巴西联邦高速公路警察(<em class="mp"> Polícia Rodoviária Federal </em>，直译)的真实数据。</p><p id="66a0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们将建立一个受Medallion架构启发的数据管道，以允许对事故数据进行增量(可能是实时)分析。</p><p id="fbf7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们的目标是学习更多关于数据流、Kafka和ksqlDB的知识。</p><p id="5a7d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我希望你喜欢它！</p><h1 id="7b50" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">问题是</h1><p id="7092" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">顾名思义，巴西联邦高速公路警察(简称PRF)是我们负责保卫高速公路的警察。它每年从交通事故 (CC BY-ND 3.0 License)中收集并发布<a class="ae kv" href="https://www.gov.br/prf/pt-br/acesso-a-informacao/dados-abertos/dados-abertos-acidentes" rel="noopener ugc nofollow" target="_blank">数据，其中包含关于受害者的信息(年龄、性别、状况)、天气状况、时间和地点、原因和影响。</a></p><p id="4e14" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我在本科课程中了解了这个数据集，我认为学习ETL真的很有用，因为它同时包含非常丰富的信息，并且在格式化方面也很有问题。它有很多缺失值、不一致的类型、不一致的列、非标准化的值、错别字等等。</p><p id="4443" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，假设政府正试图制定更好的事故预防政策，但为此，他们需要回答以下<strong class="lq ir">个问题</strong>:</p><ul class=""><li id="5c7e" class="mq mr iq lq b lr mk lu ml lx ms mb mt mf mu mj mv mw mx my bi translated">每个月有多少人卷入事故？</li><li id="50cc" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">每月未受伤、轻伤、重伤和死亡的人数和百分比是多少？</li><li id="b724" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">每个月每个性别涉及事故的人的百分比是多少？</li><li id="f5cd" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">每种事故类型的死亡率</li></ul><p id="a765" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">不幸的是，他们不能等到年度报告发布，所以我们需要建立一个增量报告，与他们的内部数据库通信，并在系统中添加新的事故时更新仪表板中显示的结果。</p><p id="e0c3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然而，系统中插入的数据不一定是完美的，可能与发布的数据集有相同的问题，因此我们还需要清理和转换记录，使它们在最终报告中有用。</p><p id="54d4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这就是ksqlDB的用武之地。</p><blockquote class="ne nf ng"><p id="2de6" class="lo lp mp lq b lr mk jr lt lu ml ju lw nh mm lz ma ni mn md me nj mo mh mi mj ij bi translated">声明:除了使用来自巴西政府的真实数据，所描述的情况是虚构的，用于在实践中了解ksqlDB，并有一个冷静的目标。</p></blockquote><h1 id="603f" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">阿帕奇卡夫卡和ksqlDB</h1><p id="1603" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><a class="ae kv" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank">“Apache Kafka是一个开源的分布式事件流平台</a>”，简而言之，一个用来发送和接收消息的工具。在Kafka中，我们有一个主题结构，包含由生产者编写并由消费者阅读的信息(字面上只是一串字节)。</p><p id="7b01" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">它是数据流最重要的工具之一，尤其是在大数据环境中，因为它可以轻松地以高吞吐量处理数百万条消息。它被像<a class="ae kv" href="https://www.uber.com/en-TT/blog/presto-on-apache-kafka-at-uber-scale/" rel="noopener ugc nofollow" target="_blank">优步</a>和<a class="ae kv" href="https://www.confluent.io/blog/how-kafka-is-used-by-netflix/" rel="noopener ugc nofollow" target="_blank">网飞</a>这样的公司用来提高他们的数据处理能力，例如，允许实时数据分析和机器学习。</p><p id="3fd5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><a class="ae kv" href="https://docs.ksqldb.io/en/latest/" rel="noopener ugc nofollow" target="_blank">“ksqlDB是一个专门为基于Apache Kafka </a>的流处理应用程序而构建的数据库。是Kafka生态系统中的一个工具，它允许我们像处理关系数据库中的传统表一样处理Kafka主题，并对它们进行类似SQL的查询。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/6ed9e61ef98b817606c9b28f8dcd3b87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EGK1C-PElXJIymWiO2JMyA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用SQL过滤Kafka消息</p></figure><p id="861f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">ksqlDB的存储基于两种主要结构——流和表。流就像普通的Kafka主题，不可变的仅追加集合，<em class="mp">即</em>一个不断增长的消息列表。流可以用来表示事件的历史序列，比如银行的交易。</p><p id="111c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">另一方面，表是可变的集合，表示一个组的当前状态/快照。为此，他们使用了主键的概念。接收消息时，表将只存储给定键的最新值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/02e30ef289766febe0bef321d0c312af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hYnOf9sMXQoA2dQQwAIEjg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">ksqlDB中的流和表。图片作者。</p></figure><p id="4ec8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">除了它们的不同，《流》和《表》都是基于卡夫卡的基本主题结构。</p><p id="0c20" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如前所述，ksqlDB完全基于SQL，除非您正在做非常特殊的事情，否则不需要任何编程语言。因此，如果您已经有了使用SQL的经验，您可以轻松地从常见的关系环境迁移到流环境，而不会有太多的开销。</p><p id="c76e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">值得注意的是，类似的行为可以通过使用其他工具来实现，比如Apache Spark，甚至是手动编码的消费者，但是我认为ksqlDb有一个简单的、对初学者友好的界面。</p><blockquote class="ne nf ng"><p id="87be" class="lo lp mp lq b lr mk jr lt lu ml ju lw nh mm lz ma ni mn md me nj mo mh mi mj ij bi translated">ksqlDB不是开源的，它属于Confluent Inc .(了解更多关于它的许可<a class="ae kv" href="https://docs.ksqldb.io/en/latest/faq/#is-ksqldb-owned-by-the-apache-software-foundation" rel="noopener ugc nofollow" target="_blank">这里</a>)，但是这个教程可以用免费的独立版本来完成。</p><p id="4a80" class="lo lp mp lq b lr mk jr lt lu ml ju lw nh mm lz ma ni mn md me nj mo mh mi mj ij bi translated">在撰写本文时，作者与Confluent Inc. (ksqlDB的所有者)没有任何隶属关系，此处表达的观点多为个人观点。</p></blockquote><h1 id="ca7e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">实施</h1><p id="3871" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这个项目的主要思想是使用ksqlDB创建一个流ETL管道。该管道将基于Medallion架构，该架构将数据分成逐渐更精细的状态，分类为青铜、白银和黄金。</p><p id="addd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">简而言之，青铜层存储原始数据，白银层存储经过清理的数据，黄金层存储经过丰富和聚合的数据。我们将使用MongoDB进行长期存储。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/65903e86069f77c00ea22a3a51457809.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*J0vfZ1sduYrF-nTQT1d7rg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用ksqlDB在层间转换数据。图片作者。</p></figure><p id="bf5b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">除了流和表，我们还将使用数据库连接器在层间移动数据。这些连接器负责将记录从数据库(本例中为MongoDB)移动到Kafka主题(在一个称为变更数据捕获的过程中),反之亦然。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/cb4dd893039803c9bb590e86c2b30dcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JH2_J0Xq0AGMnDoJYV2NzQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">接收器和源连接器。图片作者。</p></figure><p id="ede8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">本帖中使用的原始数据可以在<a class="ae kv" href="https://www.gov.br/prf/pt-br/acesso-a-informacao/dados-abertos/dados-abertos-acidentes" rel="noopener ugc nofollow" target="_blank">链接</a>中以CSV格式找到。事先，我已经将2015年至2020年的数据转换成了一个<em class="mp">拼花</em>文件，以减小其大小并缩短读取时间，该文件将在GitHub存储库中提供。</p><h2 id="ac1c" class="no kx iq bd ky np nq dn lc nr ns dp lg lx nt nu li mb nv nw lk mf nx ny lm nz bi translated">设置环境</h2><p id="9730" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这个项目环境基于docker文件，可以在这个<a class="ae kv" href="https://docs.ksqldb.io/en/latest/tutorials/etl/#create-the-logistics-collections-in-mongodb" rel="noopener ugc nofollow" target="_blank">官方ksqlDB教程</a>上找到。</p><p id="ac26" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您需要什么:</p><ul class=""><li id="2d45" class="mq mr iq lq b lr mk lu ml lx ms mb mt mf mu mj mv mw mx my bi translated">码头工人和码头工人组成</li><li id="870b" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">Kafka的MongoDB接收器和源连接器— <a class="ae kv" href="https://www.confluent.io/hub/debezium/debezium-connector-mongodb" rel="noopener ugc nofollow" target="_blank"> Debezium MongoDB CDC源连接器</a>和<a class="ae kv" href="https://www.confluent.io/hub/mongodb/kafka-connect-mongodb" rel="noopener ugc nofollow" target="_blank"> MongoDB连接器</a>(接收器)。</li><li id="2410" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">(可选)Python 3.8+和。用于在MongoDB中插入条目</li></ul><p id="1509" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下载的连接器必须放在文件夹/插件中，路径与docker-compose文件相同。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/09cd5fe2a40d5c17c44b4591725e5e37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*KYQYRV6i8DAf97MT2PugLg.png"/></div></figure><p id="c111" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，集装箱可以通过<em class="mp"> docker-compose up正常启动。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/628336373f640d4603c45e7c8e69ed7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/0*v9v-1PbQoIE0Nimz"/></div></figure><p id="2898" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">之后，在容器内用命令<em class="mp"> mongo -u mongo -p mongo </em>连接到MongoDB shell，用<em class="mp"> rs.initiate() </em>启动数据库。</p><blockquote class="ne nf ng"><p id="1547" class="lo lp mp lq b lr mk jr lt lu ml ju lw nh mm lz ma ni mn md me nj mo mh mi mj ij bi translated">如果MongoDB连接器在执行过程中出现问题，可以在教程<a class="ae kv" href="https://docs.ksqldb.io/en/latest/tutorials/etl/#create-the-logistics-collections-in-mongodb" rel="noopener ugc nofollow" target="_blank">链接</a>和参考资料中找到深层定位。</p></blockquote><h2 id="30cd" class="no kx iq bd ky np nq dn lc nr ns dp lg lx nt nu li mb nv nw lk mf nx ny lm nz bi translated">青铜图层-提取原始数据</h2><p id="e479" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">青铜层存储从事务环境中提取的原始数据，没有任何转换或清理，只是一个<em class="mp"> ctrl+c ctrl+v </em>的过程。在我们的例子中，这一层应该从最初登记事故的数据库中提取信息。</p><p id="0e50" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为简单起见，我们将直接在青铜层上创建记录。</p><p id="0034" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">该层将由一个名为<em class="mp">事故_青铜</em>的MongoDB集合表示，该集合位于<em class="mp">事故</em>数据库中</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/d577ff84a580f875a7a001492396736f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4sb_35fpKV4u75RK"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">青铜层。图片作者。</p></figure><p id="c4e0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了将记录从MongoDB移动到ksqlDB，我们需要配置一个<strong class="lq ir">源连接器</strong>。这个连接器负责监视集合，并将检测到的每个更改(插入、删除和更新)以结构化消息的形式(在AVRO或JSON中)传输到Kafka主题。</p><p id="b2a3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">首先，使用<em class="mp"> docker exec </em>通过ksqlDB-client连接到ksqlDB服务器实例。</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="e4e4" class="no kx iq oe b gy oi oj l ok ol">docker exec -it ksqldb-cli ksql <a class="ae kv" href="http://ksqldb-server:8088" rel="noopener ugc nofollow" target="_blank">http://ksqldb-server:8088</a></span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/ea207f087f5d4467d04f0819dd318be2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X0ZWLRW9EY3bfUMomRZDHw.png"/></div></div></figure><p id="dd7d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果一切顺利，您应该会在屏幕上看到一个很大的KSQLDB，并显示“正在运行”的消息。这是ksqlDB客户机接口，从这里我们与服务器交互，定义我们的流、表、连接器和查询。</p><p id="2f38" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在继续之前，我们需要运行以下命令</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="9df5" class="no kx iq oe b gy oi oj l ok ol">SET 'auto.offset.reset' = 'earliest';</span></pre><p id="5b03" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这确保了所有已定义的查询都将从每个主题中最早的点开始。</p><p id="af58" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，创建连接器只是描述一些配置的问题。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="252b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">该命令以CREATE SOURCE CONNECTOR子句开始，后跟连接器名称和配置。WITH子句指定所使用的配置。</p><p id="5e7d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">首先，定义<em class="mp"> connector.class </em>。这是连接器本身，实现其逻辑的Java类。我们将使用Debezium MongoDB连接器，它包含在plugins文件夹中。</p><p id="ee5f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">其次，我们传递MongoDB地址(主机+名称)和凭证(登录名+密码)。</p><p id="7960" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，我们定义数据库中的哪些集合将被监视。</p><p id="25f8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最后，<em class="mp"> transforms </em>参数指定了Debezium连接器产生的消息的简化，而<em class="mp"> errors.tolerance </em>定义了产生错误的消息的连接器行为(默认行为是暂停执行)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/7cf4f02b9f1f66887ae63d51e8582849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IuuPdRCB0QI4Ev_empHKZQ.png"/></div></div></figure><p id="1cab" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">创建连接器后，让我们执行一个描述连接器查询来查看它的当前状态。执行过程中出现的任何错误都应在此处提示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/8801295aaa8e65d2f83c25b337bdf8f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fpfFPBvP5f6pfEmeSer0HA.png"/></div></div></figure><p id="3f41" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在我们的连接器正在运行，它将开始将<em class="mp">事故_青铜</em>集合中的所有更改流式传输到主题<br/> <strong class="lq ir">副本集。</strong></p><p id="3945" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">ksqlDB不能直接处理Kafka主题，所以我们需要使用它定义一个流。</p><p id="53eb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在ksqlDB中定义一个流几乎等同于在SQL中创建一个表。您需要在with子句中传递一个名称、一列及其各自的类型，以及一些配置。</p><p id="f8ed" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在我们的例子中，我们需要配置哪个主题将提供给我们的流。因此，列的名称和类型应该与原始主题消息中的字段相匹配。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/f20325a5e128f88c0ad7882b3d62bbe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qCITiCGYf4Z2QIE9KjzcrA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">流定义必须与消息中的字段匹配。图片作者。</p></figure><p id="6654" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">请参见下面的命令。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><blockquote class="ne nf ng"><p id="5c3c" class="lo lp mp lq b lr mk jr lt lu ml ju lw nh mm lz ma ni mn md me nj mo mh mi mj ij bi translated">你不需要像我上面那样包含所有的原始字段。</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/ac7cc705cef56b0be97b3de557e5b621.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j1tjiGfTIgcRG1RyZnvThA.png"/></div></div></figure><p id="2f3c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">简单回顾一下我们到目前为止所做的工作。我们配置了一个MongoDB源连接器，以结构化消息<br/> 2的形式传输集合<em class="mp"> accidents_bronze </em>中的更改。使用自动创建的<strong class="lq ir">副本集.事故.事故_青铜</strong>主题，我们在ksqlDB中定义了一个名为事故_青铜_流的流，以允许处理其消息</p><p id="c0fa" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，设置好流之后，就可以在其上运行选择查询了，这就是真正神奇的地方。</p><blockquote class="ne nf ng"><p id="d100" class="lo lp mp lq b lr mk jr lt lu ml ju lw nh mm lz ma ni mn md me nj mo mh mi mj ij bi translated">我冒昧地在mongoDB实例中插入了一些记录，这样我们就有数据可以使用了。</p></blockquote><p id="15ba" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">例如，让我们选择每个消息的<em class="mp">数据</em>和<em class="mp"> id </em>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/bf446d34a0f10fea3331ceefd06d6bb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AZDjakJM1Kybvt9zrk1jNw.png"/></div></div></figure><p id="f326" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在ksqlDB中，这些普通的SQL语句被称为<a class="ae kv" href="https://docs.ksqldb.io/en/latest/developer-guide/ksqldb-reference/select-pull-query/" rel="noopener ugc nofollow" target="_blank">拉查询</a>，因为它们根据流的当前状态返回响应并结束。</p><p id="7684" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">通过在拉查询的末尾添加发出更改，它变成了一个<a class="ae kv" href="https://docs.ksqldb.io/en/latest/developer-guide/ksqldb-reference/select-push-query/" rel="noopener ugc nofollow" target="_blank">推查询</a>。与它的对应物不同，它永远不会结束，并且总是根据到达的消息计算新的行。让我们看看这个工作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/0b8133cc6243725d82b4c903b303ada1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_HtE87AFSNEh00-bOyA_uw.gif"/></div></div></figure><p id="d07d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">左边是推送查询，右边是在MongoDB中插入记录的简单python脚本。随着新记录的插入，它们会自动出现在查询的答案中。</p><p id="b6e1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Push和Pull查询将是我们创建以下部分所需的所有转换的基础。</p><h2 id="bcb2" class="no kx iq bd ky np nq dn lc nr ns dp lg lx nt nu li mb nv nw lk mf nx ny lm nz bi translated">银层—清理数据</h2><p id="f021" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">银层的目标是存储清理后的数据，这些数据可以很容易地被其他应用程序使用，如机器学习项目和金层。</p><p id="dfb6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这一层将由在<em class="mp">事故</em>数据库中名为<em class="mp">事故_银</em>的MongoDB集合来表示。</p><p id="b9d4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们主要关心的是保证数据格式正确，这样下游任务就可以专注于解决它们特定的业务规则。</p><p id="0fce" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为此，我们需要处理<strong class="lq ir">青铜流</strong>中到达的消息，并将它们存储在<em class="mp">事故_白银</em>集合中。这个过程可以分为两个步骤:“创建一个流来清理消息”和“创建一个接收器连接器来将消息保存在<em class="mp"> accidents_silver </em>中”</p><p id="3792" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在探索ksqlDB的真正威力——流处理。</p><p id="0640" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">可以使用对其他流的查询来定义一个<strong class="lq ir"> </strong>流。新的流将由查询结果填充。</p><p id="773b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们看看这个工作。</p><p id="89c7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">例如，如果我们想要一个只包含不为空的<em class="mp"> _id </em>和<em class="mp">日期</em>的新流，我们可以这样做:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="9c9f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">使用这个功能，可以创建一个转换(<em class="mp"> bronze_to_silver </em>)流，负责从bronze流中选择和清理消息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/13fca0a6a90c2dc0583e56c1a91aab7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nXnhCjAV6QKjABa6SJTxqg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将原始记录转换成干净的数据。图片作者。</p></figure><p id="cfaf" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们的例子需要清理字段:<strong class="lq ir"> sexo </strong>(性别)<strong class="lq ir"> tipo_acidente </strong>(事故类型)<strong class="lq ir"> ilesos </strong>(未受伤)<strong class="lq ir"> feridos_leves </strong>(轻伤)<strong class="lq ir"> feridos_graves </strong>(重伤)<strong class="lq ir"> mortos </strong>(死亡)<strong class="lq ir"> data_inversa </strong>(日期)。</p><p id="e694" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">查看数据库后(我在屏幕外做了这个)，可能会注意到以下问题:</p><ol class=""><li id="fadb" class="mq mr iq lq b lr mk lu ml lx ms mb mt mf mu mj ov mw mx my bi translated">性别列包含多个代表相同性别的值:男性可以是'<em class="mp">男性</em>或'<em class="mp"> m </em>'，女性可以是'<em class="mp">女性</em>或'<em class="mp"> f </em>'。</li><li id="9c57" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj ov mw mx my bi translated">事故类型还包含“同一类型”的多个值。</li><li id="89e9" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj ov mw mx my bi translated">日期可以采用以下格式之一:2019–12–20、20/12/2019或20/12/19</li><li id="dc2a" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj ov mw mx my bi translated">缺少的值被编码为null、字符串“NULL”或字符串“(NULL)”</li></ol><p id="d6ef" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="mp">除了这些转换，我还会(试着)翻译字段和值以便于理解。</em></p><p id="de27" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这些问题的修复在下面定义的<strong class="lq ir">事故_青铜_白银</strong>流中实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="918e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我不会深入解释上面的SQL命令，重要的是用ksqlDB可以做什么。</p><p id="9a93" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们能够在(几乎)只有SQL知识的情况下，在信息流上构建一个强大的转换过程！</p><p id="ed40" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们看看下面的工作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/bfe47380fd3ac05d68201c9f223710e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*82-sq0G4RKDGQP53Fa98eg.gif"/></div></div></figure><p id="f97e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最后一步是使用<strong class="lq ir">接收器连接器</strong>将数据保存在MongoDB中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="7efc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">对于上面的连接器，使用Kafka MongoDB连接器，其余的配置不言自明。</p><p id="69b0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="mp">事故_白银</em>自动创建，结果如下图所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/bb781866d4fbf9e41c3edceb0a551252.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4mWdcIhORPRQ18vV47EAeQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">银层。图片作者。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/1030baff94137ae5680cc4f3c123dffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ImKdpVCDkrF9R2NiXd9Hlg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">银层中的记录。图片作者。</p></figure><p id="a5f0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在我们有了干净的事故数据，是时候最终回答我们的问题了。</p><h2 id="0685" class="no kx iq bd ky np nq dn lc nr ns dp lg lx nt nu li mb nv nw lk mf nx ny lm nz bi translated"><strong class="ak">黄金层—业务规则和聚合</strong></h2><p id="54f9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">黄金层包含特定于业务的规则，专注于解决特定项目的问题。</p><p id="cbf7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在我们的项目中，将定义两个“黄金层”，一个侧重于回答每月汇总的问题，另一个回答每次事故的死亡率，每个都存储在单独的集合中。</p><p id="1205" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">从架构的角度来看，这一步并没有带来什么新奇感。就像上一步一样，我们从一个流中消费数据，将其转换为我们需要的数据，并将结果保存在数据库中。</p><p id="fd07" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这一步的不同之处在于所需的<strong class="lq ir">聚合</strong>。</p><p id="d38a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了回答我们的问题，我们不需要存储每个事故，只需要存储每个月死亡和受伤事故的当前计数(<em class="mp">示例</em>)。因此，我们将使用表，而不是使用流。</p><p id="53db" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">幸运的是，在语法方面，表和流定义之间没有太大的区别。</p><blockquote class="ne nf ng"><p id="fa41" class="lo lp mp lq b lr mk jr lt lu ml ju lw nh mm lz ma ni mn md me nj mo mh mi mj ij bi translated">如前所述，表有一个主键。对于这些示例，我们不需要显式定义键，因为ksqlDB会使用GROUP BY中使用的列自动创建它们。</p></blockquote><p id="9fd7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在ksqlDB中，只能在推送查询中进行聚合，因此在查询端需要“发出更改”。</p><p id="4804" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">先说月度汇总表。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="af5a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">并查看该表的运行情况…</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/4a5b9130e568c0801c561ba4cc25f997.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ztjOi7R9qm6TWCRzzJ9rMQ.gif"/></div></div></figure><p id="9a85" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">随着新记录的插入，表格(在右边)自动更新每个月的计数。让我们仔细看看结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/23a52083bbde8d3f4e796a7ec92efaea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v9y6srVp_7TXk7vGsOYYVw.png"/></div></div></figure><p id="d02a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">同样的逻辑也适用于死亡率表，在这里我们计算每种事故的死亡概率。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="47dd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">再一次，看看表格的作用…</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/3e40fa319ce0daed9ce2c39f7a9a80ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*QHD0nXPO1ftk3xR_3HaAeA.gif"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/bff11892bac66f32c29cd5272e08a7cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S4UWrMy9G9MHlJ-vMsL-aw.png"/></div></div></figure><p id="462b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最后，剩下的就是将每个表保存在各自的MongoDB集合中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="dfae" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这个接收器连接器有一些不同的配置(<em class="mp">转换</em>和<em class="mp"> document.id.strategy </em>)，用于在MongoDB中创建一个<em class="mp"> _id </em>字段<em class="mp"> </em>来匹配表的主键。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="6fd7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">结果应该会在集合中显示出来。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pb"><img src="../Images/3d090500d8555f3ee9b303c57232ce22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xsP3B55iD-ApMzDjlTaj1w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">黄金收藏-意外事故_黄金和死亡率_意外事故_类型。图片作者。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pc"><img src="../Images/b246f9879e75d0c795a6ff6cff950cc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YkGJ3wsva7UaLkEz6Ta0Aw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">每种事故类型的死亡率。图片作者。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pd"><img src="../Images/497ee9070a5adf932440a471771f187c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-NDnis2nv-eN_wbEGgJPFw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">每月汇总统计数据。图片作者。</p></figure><h1 id="3ed2" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="8ed1" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在许多公司，尤其是大公司中，流处理已经成为现实。在所使用的技术中，Apache Kafka是在应用程序和数据库之间传输消息的领先解决方案，它有一个庞大的辅助工具生态系统来处理密集的数据相关工作。ksqlDB就是其中之一。</p><p id="9b51" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在本文中，我们通过一个使用真实数据集的动手项目了解了ksqlDB。</p><p id="a73f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在我的项目中，我总是试图将探索的工具和概念与现实中有趣的话题结合起来。正因为如此，我从巴西公开的政府数据中选择了一个真实的数据集，其中包含了道路事故的数据。</p><p id="7045" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了允许增量(可能是实时)数据分析，我提议使用Medallion架构将原始的无格式数据转换成问题的答案。这个架构的主要目的是允许探索ksqlDB的不同概念。</p><p id="cca3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们已经了解了ksqlSB主存储单元(流和表)、推和拉查询，最重要的是，这个工具如何帮助我们解决一个(real？)数据工程问题。</p><p id="83fb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">和往常一样，我不是任何讨论主题的专家，我强烈建议进一步阅读，见下面的参考资料。</p><p id="fd68" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">感谢您的阅读；)</p><h1 id="842d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">参考</h1><blockquote class="ne nf ng"><p id="8348" class="lo lp mp lq b lr mk jr lt lu ml ju lw nh mm lz ma ni mn md me nj mo mh mi mj ij bi translated"><em class="iq">所有的代码都在这个</em> <a class="ae kv" href="https://github.com/jaumpedro214/posts/tree/main/real_time_analysis_accidents" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> GitHub资源库</em> </a> <em class="iq">中。</em></p></blockquote><p id="4569" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">[1] <a class="ae kv" href="https://www.databricks.com/glossary/medallion-architecture" rel="noopener ugc nofollow" target="_blank">梅达莲建筑</a> — Databricks词汇表<br/>【2】<a class="ae kv" href="https://learn.microsoft.com/en-us/azure/databricks/lakehouse/medallion" rel="noopener ugc nofollow" target="_blank">什么是梅达莲湖畔小屋建筑？</a> —微软学习<br/>【3】<a class="ae kv" href="https://docs.ksqldb.io/en/latest/tutorials/etl/" rel="noopener ugc nofollow" target="_blank">流式ETL管道</a> — ksqlDB官方文档<br/>【4】<a class="ae kv" href="https://developer.confluent.io/learn-kafka/ksqldb/streams-and-tables/" rel="noopener ugc nofollow" target="_blank">流和表</a> —合流ksqlDB教程<br/>【5】<a class="ae kv" href="https://www.confluent.io/blog/how-kafka-is-used-by-netflix/" rel="noopener ugc nofollow" target="_blank">以网飞工作室和金融世界中的阿帕奇卡夫卡为特色</a> —合流博客<br/>【6】<a class="ae kv" href="https://www.mongodb.com/docs/kafka-connector/current/sink-connector/" rel="noopener ugc nofollow" target="_blank">MongoDB Kafka Sink Connector</a>—MongoDB官方文档<br/>【7】<a class="ae kv" href="https://www.confluent.io/hub/mongodb/kafka-connect-mongodb" rel="noopener ugc nofollow" target="_blank">MongoDB来源</a></p><p id="e3cf" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="mp">本帖所有图片，除特别注明外，均由作者制作。</em></p></div></div>    
</body>
</html>