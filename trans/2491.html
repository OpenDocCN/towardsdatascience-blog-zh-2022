<html>
<head>
<title>How to Voxelize Meshes and Point Clouds in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中对网格和点云进行体素化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-voxelize-meshes-and-point-clouds-in-python-ca94d403f81d#2022-05-31">https://towardsdatascience.com/how-to-voxelize-meshes-and-point-clouds-in-python-ca94d403f81d#2022-05-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="1d13" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">本文介绍了使用四个广泛流行的Python库生成点云和网格的体素表示的步骤，这四个Python库是:<a class="ae kp" href="http://www.open3d.org/" rel="noopener ugc nofollow" target="_blank"><em class="iq">【open 3d】</em></a><em class="iq">、</em> <a class="ae kp" href="https://trimsh.org/index.html" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> Trimesh </em> </a> <em class="iq">、</em> <a class="ae kp" href="https://docs.pyvista.org/" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> PyVista </em> </a>、<em class="iq">和</em> <a class="ae kp" href="https://github.com/daavoo/pyntcloud" rel="noopener ugc nofollow" target="_blank"> pyntcloud </a>。体素化是许多3D深度学习模型的重要预处理步骤。这篇文章展示了如何计算体素级别的特征，如颜色、点密度和占用率等。最后，还演示了如何创建简单的交互式体素化和阈值处理示例。谁说体素化要复杂？</p></blockquote><div class="kq kr ks kt gt ab cb"><figure class="ku kv kw kx ky kz la paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><img src="../Images/9f53493769572eee36badd81fcfdc119.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/1*1Il9Hyn7QaxyeWKk6gtfMg.gif"/></div></figure><figure class="ku kv lh kx ky kz la paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><img src="../Images/80f53fc9b5ee1bf134da8fb6c152bec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/1*g5sKk0oHAVFipGjDXMo6pg.gif"/></div><p class="li lj gj gh gi lk ll bd b be z dk lm di ln lo translated">Open3D中点云的体素化示例—不同的体素大小(左)和体素网格的构建(右)|作者的图像</p></figure></div><p id="76a6" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi ls translated">3D数据的深度学习正在成为机器学习和理解我们周围世界越来越重要的一部分。随着深度相机和激光雷达等新的3D数据提取硬件在CCTVs、相机和智能手机中变得越来越常见，越来越多的人正在使用它提供的额外维度。此外，摄影测量和基于运动的结构正成为3D重建和建模管道的正常部分，并且提取和操纵大型3D数据集正变得必要。用于3D深度学习的非结构化数据可以有不同的表示:</p><ul class=""><li id="081e" class="mb mc iq jt b ju jv jy jz lp md lq me lr mf ko mg mh mi mj bi translated">点云[3，4，11]</li><li id="da73" class="mb mc iq jt b ju mk jy ml lp mm lq mn lr mo ko mg mh mi mj bi translated">体素和体素网格[1，8，9]</li><li id="0848" class="mb mc iq jt b ju mk jy ml lp mm lq mn lr mo ko mg mh mi mj bi translated">深度图[2]</li><li id="c26f" class="mb mc iq jt b ju mk jy ml lp mm lq mn lr mo ko mg mh mi mj bi translated">图[5，10]</li></ul><p id="f242" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">这些远不是所有可能的3D数据表示，还有其他像参数化CAD模型、多视图图像、体积等。要想更好地了解其中的一些内容，你可以阅读Florent Paux撰写的关于“<a class="ae kp" rel="noopener" target="_blank" href="/how-to-represent-3d-data-66a0f6376afb">如何表示3D数据？</a>”。</p><p id="b383" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">在本文中，我们将着重于将3D数据表示为体素。但是首先什么是体素？最简单的比较就是体素就是3D像素。体素被排序到体素网格中，这可以被视为图像的有序结构的3D等价物。当点云或网格变成体素表示时，它与体素网格相交。然后，点云或网格中的点落入某些体素中。留下这些体素，而不与任何点相交的所有其他体素要么被丢弃，要么被置零，留给我们的是物体的雕刻表示。体素化可以仅仅是表面级别的，或者贯穿整个网格/点云体积。</p><div class="kq kr ks kt gt ab cb"><figure class="ku kv mp kx ky kz la paragraph-image"><img src="../Images/2a7bd38f5a2becfb828e48bfcbf33436.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/1*w82extXSCvBYVwJ5wRHSFA.gif"/></figure><figure class="ku kv mp kx ky kz la paragraph-image"><img src="../Images/c7efb3c225485c09afc069859ad28ce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/1*Uro2DTthFtFOjnwuEEETyw.gif"/><p class="li lj gj gh gi lk ll bd b be z dk mq di mr lo translated">作者使用PyVista | Image将左侧的天使雕像转换为右侧的体素表示的体素化示例</p></figure></div><p id="ae7d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">构建网格和点云的体素化表示是许多深度学习方法的数据预处理中的重要步骤。体素化也广泛用于处理点云，包括二次采样、特征提取和占用分析等。最后，生成网格的体素表示对于创建游戏资源和简化模拟表面也很有用。</p><p id="76e8" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">在文章中，我们将探索四个Python库的体素化能力——<a class="ae kp" href="http://www.open3d.org/" rel="noopener ugc nofollow" target="_blank"><em class="js">【Open3D】</em></a><em class="js"/><a class="ae kp" href="https://trimsh.org/index.html" rel="noopener ugc nofollow" target="_blank"><em class="js">Trimesh</em></a><em class="js"/><a class="ae kp" href="https://docs.pyvista.org/" rel="noopener ugc nofollow" target="_blank"><em class="js">py vista</em></a><em class="js">和<a class="ae kp" href="https://github.com/daavoo/pyntcloud" rel="noopener ugc nofollow" target="_blank"> pyntcloud </a>。我选择了这些库，因为它们提供了相对简单的体素化功能，以及用于分析所创建的体素的内置解决方案。其他较小的库，如<a class="ae kp" href="https://github.com/p-hofmann/PyVoxelizer" rel="noopener ugc nofollow" target="_blank"> PyVoxelizer </a>、<a class="ae kp" href="https://github.com/archi-coder/Voxelizer" rel="noopener ugc nofollow" target="_blank"> Voxelizer </a>、<a class="ae kp" href="https://simple-3dviz.com/" rel="noopener ugc nofollow" target="_blank"> simple-3dviz </a>和<a class="ae kp" href="https://github.com/ErenBalatkan/DepthVisualizer" rel="noopener ugc nofollow" target="_blank"> DepthVisualizer </a>也提供了体素化功能，但它们被认为过于有限。另一个提供体素化功能的库是<a class="ae kp" href="https://vedo.embl.es/" rel="noopener ugc nofollow" target="_blank"> Vedo </a>，但是在最初的测试之后，我发现它们是针对3D体数据的，这限制了它们的使用。如果您想了解更多关于如何使用这些库创建漂亮的可视化效果的信息，您可以看看我以前的文章“<strong class="jt ir">用于网格、点云和数据可视化的Python库</strong>”(第1和第2部分)。我们将使用的唯一一个以前没有讨论过的库是pyntcloud，所以我们将更详细地讨论如何安装和设置它。</em></p><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/python-libraries-for-mesh-and-point-cloud-visualization-part-1-daa2af36de30"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd ir gy z fp na fr fs nb fu fw ip bi translated">用于网格、点云和数据可视化的Python库(第1部分)</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">八个最好的Python库，用于惊人的3D可视化、绘图和动画</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj lf mv"/></div></div></a></div><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/python-libraries-for-mesh-point-cloud-and-data-visualization-part-2-385f16188f0f"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd ir gy z fp na fr fs nb fu fw ip bi translated">用于网格、点云和数据可视化的Python库(第2部分)</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">八个最好的Python库，用于惊人的3D可视化、绘图和动画(第二部分)。</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="nk l ng nh ni ne nj lf mv"/></div></div></a></div><p id="b870" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">为了演示点云和网格上的体素化，我提供了两个对象。首先是<strong class="jt ir">中的一个兔子雕像点云。txt </strong>格式，包含每个点的<em class="js"> X、Y、Z </em>坐标，以及它们的<em class="js"> R、G、B </em>颜色，最后是<em class="js"> Nx、Ny、Nz </em>法线。第二，一只公鸡雕像网在一个<strong class="jt ir">里。obj </strong>格式，加上一个<strong class="jt ir">。mat </strong>文件和一个纹理在<strong class="jt ir">中。jpg </strong>格式。这两个物体都是使用运动摄影测量的结构创建的，并且<strong class="jt ir">可以在商业、非商业、公共和私人项目中免费使用</strong>。这些对象是一个更大的数据集[6]的一部分，并已用于噪声检测和检查方法的开发[7]。为了跟随教程，除了使用的库和它们的依赖项，您还需要NumPy和SciPy。所有代码都可以在GitHub库<a class="ae kp" href="https://github.com/IvanNik17/python-3d-analysis-libraries" rel="noopener ugc nofollow" target="_blank">这里</a>获得</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h1 id="b316" class="ns nt iq bd nu nv nw nx ny nz oa ob oc od oe of og oh oi oj ok ol om on oo op bi translated">使用Open3D进行体素化</h1><figure class="kq kr ks kt gt kv gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/d964e592ef4cdd02e93067716123a3aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/1*1Il9Hyn7QaxyeWKk6gtfMg.gif"/></div><p class="li lj gj gh gi lk ll bd b be z dk translated">Open3D使用不同大小的体素网格进行体素化的结果|图片由作者提供</p></figure><p id="1be8" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi ls translated">pen3D 是功能最丰富的Python库之一，用于3D分析、网格和点云操作以及可视化。它包含了从点云和网格生成体素的优秀工具。该库还支持大量3D图元，如球体、立方体、圆柱体等。这使得从体素生成3D网格变得容易。最后，体素网格也可用于二次采样点云并生成分割。关于如何安装和使用Open3D的分步教程，可以看看我之前的文章“<a class="ae kp" rel="noopener" target="_blank" href="/python-libraries-for-mesh-and-point-cloud-visualization-part-1-daa2af36de30">网格、点云、数据可视化的Python库(第一部分)</a>”。我们将使用大量相同的可视化和回调代码。</p><p id="5fd0" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">我想再次指出Florent Poux博士的一个优秀教程—“如何使用Python 自动进行3D点云的体素建模”，其中他给出了使用Open3D从点云生成体素的很好的概述和用例。在我的文章中，我以教程中提供的信息为基础。</p><p id="5a38" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">为了更好地理解体素化过程，我们将使用Open3D构建两个示例—一个可视化多个体素网格级别以及它们如何影响体素化模型，另一个显示体素化过程。</p><p id="32be" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">我们首先使用NumPy的<code class="fe or os ot ou b">loadtxt()</code>函数加载兔子雕像点云。我们将数组分为点、颜色和法线，并通过首先使用<code class="fe or os ot ou b">Vector3dVector</code>函数将数组转换为矢量来创建一个Open3D点云。从这里开始，通过调用<code class="fe or os ot ou b">VoxelGrid.create_from_point_cloud()</code>并给它点云和体素尺寸参数，创建一个体素网格是很简单的。如果我们从一个网格开始，我们可以用<code class="fe or os ot ou b">create_from_triangle_mesh()</code>做同样的事情。如果我们在Open3D中使用体素网格来操作和分析点云/网格，我们可以在此停止。我们还可以通过调用将体素网格作为几何图形添加到Visualizer对象来快速可视化它。下面给出了代码。</p><figure class="kq kr ks kt gt kv"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="3c51" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">我们也将继续处理体素网格，并将其转换为网格，因为我们想用它来创建一个动画，截至编写时，体素网格不能被转换。我们使用Florent Poux博士提出的方法。我们通过调用<code class="fe or os ot ou b">geometry.TriangleMesh()</code>创建一个空的三角形网格，然后通过调用<code class="fe or os ot ou b">voxel_grid.get_voxels()</code>从网格中提取所有体素，并获得所创建体素的真实大小。这样，我们可以在每个体素位置创建一个Open3D box图元，将这些框缩放到体素的大小，并通过调用<code class="fe or os ot ou b">voxel_grid.get_voxel_center_coordinate()</code>将它们定位在体素中心。最后，我们将这样创建、缩放和定位的盒子添加到TriangleMesh对象中。</p><p id="e21a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">为了演示不同的体素网格大小如何改变最终的体素输出，并使示例更有趣一些，我们将制作体素输出之间的旋转过渡动画。为此，我们通过调用<code class="fe or os ot ou b">register_animation_callback()</code>向可视化工具注册一个新的回调。在回调函数中，我们生成体素网格，并从中创建一个体素网格。我们将这样创建的网格旋转360度，破坏网格，并重复不同大小的体素网格。我们还利用一个小类来保存在回调更新循环中会发生变化的所有变量。下面给出了完整旋转可视化的代码。</p><figure class="kq kr ks kt gt kv"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="5d26" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">为了更好地理解创建体素和体素网格的过程，我们将通过动画对其进行可视化。这个可视化的代码与我们已经展示过的非常相似，但是这次我们通过添加每个新的体素作为回调函数循环的一部分来可视化创建体素网格的过程。为了得到兔子雕像的轮廓，我们还使用体素函数<code class="fe or os ot ou b">get_voxel_center_coordinates</code>来提取体素中心，并使用它们来生成点云。这样，我们以迂回的方式生成输入点云的二次采样和均匀采样版本。整个可视化的代码如下所示。</p><figure class="kq kr ks kt gt kv gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/9b2d42312a99871a4aec19c4bee15a49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/1*g5sKk0oHAVFipGjDXMo6pg.gif"/></div><p class="li lj gj gh gi lk ll bd b be z dk translated">作者在Open3D| Image中从输入点云生成体素网格的可视化表示</p></figure><figure class="kq kr ks kt gt kv"><div class="bz fp l di"><div class="ov ow l"/></div></figure><h1 id="a1a6" class="ns nt iq bd nu nv oy nx ny nz oz ob oc od pa of og oh pb oj ok ol pc on oo op bi translated">使用Pyntcloud的体素化</h1><figure class="kq kr ks kt gt kv gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/9f6a78579ca781a13d49e1fd3f877fbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/1*mmkVbBQK3VRmnAnAMQAhsw.gif"/></div><p class="li lj gj gh gi lk ll bd b be z dk translated">Pyntcloud体素化的结果，体素基于密度着色|作者的图像</p></figure><p id="857e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi ls translated"><span class="l lt lu lv bm lw lx ly lz ma di">P</span>T3】ynt cloud是一个轻量级的强大的Python 3库，用于点云和网格的分析和预处理。它包含用于体素化、特征提取、网格平滑和抽取、点云二次采样、离群点检测等工具。它直接用作jupyter笔记本的一部分，包含用于<strong class="jt ir"> threejs </strong>、<a class="ae kp" href="https://pythreejs.readthedocs.io/en/stable/#:~:text=pythreejs%20is%20a%20Jupyter%20widgets,js." rel="noopener ugc nofollow" target="_blank"><strong class="jt ir">python reejs</strong></a>、<strong class="jt ir"> PyVista </strong>和<strong class="jt ir"> matplotlib </strong>的可视化绑定。它可以很容易地集成到其他大型库(如Open3D和PyVista)的工作流中。</p><p id="1cb6" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">pyntcloud的体素化功能非常强大，体素表示已经包含许多预先计算的特征，如体素到点的对应关系、体素网格段信息、每个体素中的点密度和二进制掩码等。</p><p id="240a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">Pyntcloud可以在Linux、Mac和Windows上使用Python 3。它需要NumPy和熊猫作为先决条件。该库在不断发展，并且每月更新。它可以使用pip或Anaconda安装。我们通常将每个库安装在一个新的Anaconda环境中，以保持一切整洁，但在这种情况下，我们将pyntcloud与Open3d一起安装，以利用前者的可视化功能。我们这样做是因为pyntcloud中的体素和网格可视化需要threejs或pythreejs，而这又需要jupyter笔记本或启动本地服务器。这些超出了本文的范围，但是我仍然会给出如何在pyntcloud中直接可视化体素的例子。</p><pre class="kq kr ks kt gt pd ou pe pf aw pg bi"><span id="e41f" class="ph nt iq ou b gy pi pj l pk pl">conda create -n pyntcloud_env python=3.8<br/>conda activate pyntcloud_env<br/>pip install open3d<br/>pip install pyntcloud<br/>OR<br/>conda install pyntcloud -c conda-forge</span></pre><p id="280b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">一旦我们安装了所有的东西并且没有错误，我们就可以测试两个库，首先一起调用<code class="fe or os ot ou b">import open3d as o3d</code>和<code class="fe or os ot ou b">print(o3d.__version__)</code>，然后一起调用<code class="fe or os ot ou b">from pyntcloud import PyntCloud</code>和<code class="fe or os ot ou b">print(PyntCloud.__version__)</code>。如果两个库都导入了，我们就可以继续学习教程了。</p><p id="9a26" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">pyntcloud的I/O模块无论好坏都相当简化。它使用<code class="fe or os ot ou b">PyntCloud.from_file()</code>来加载网格和点云。该函数根据需要加载的文件的扩展名来决定调用什么内部函数。要获得pyntcloud支持的所有文件类型的列表，您可以在这里阅读它们的I/O页面<a class="ae kp" href="https://pyntcloud.readthedocs.io/en/latest/io.html" rel="noopener ugc nofollow" target="_blank"/>。对于包含点云的ASCII文件，pyntcloud直接调用Pandas，并需要额外的输入参数，如分隔符、列名、是否有标题部分等。在本教程的情况下，我们导入兔子雕像点云，并需要显式指定所有列的名称。一旦我们加载了点云，我们需要调用<code class="fe or os ot ou b">.add_structure("voxelgrid", grid_size_x, grid_size_y, grid_size_z)</code>在点云的顶部创建一个体素网格。该函数的输出是点云中的点与网格相交的体素网格id。然后，我们通过调用<code class="fe or os ot ou b">name_of_point_cloud.structures[voxelgrid_ids]</code>使用这些id来创建点云的已占用体素表示。从这里开始，我们可以使用这个对象来提取体素的信息，并可视化一切。下面给出了导入点云并提取体素的代码。</p><figure class="kq kr ks kt gt kv"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="c5f6" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">一旦我们创建了点云的体素表示，我们可以通过调用<code class="fe or os ot ou b">voxelgrid.plot(cmap="hsv", backend="threejs")</code>使用pyntcloud直接可视化它。这里可以调用不同的后端，但是对于网格和体素，只支持<code class="fe or os ot ou b">threejs</code>和<code class="fe or os ot ou b">pythreejs</code>。为了能够在不需要运行服务器的情况下更容易地可视化一切，我们将把创建的体素网格转移到Open3D，并使用Open3D部分中显示的技术来可视化它。通过这种方式，我们还展示了结合这两个库，利用它们的优势是多么容易。</p><p id="5184" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">我们首先创建一个空的Open3D <code class="fe or os ot ou b">geometry.TriangleMesh()</code>，它将被体素填充。然后，我们循环遍历pyntcloud体素网格上的所有体素。我们可以从<code class="fe or os ot ou b">voxelgrid.voxel_n</code>数组中获得当前的体素id，并且我们可以通过调用<code class="fe or os ot ou b">voxelgrid.voxel_centers[voxel_id]</code>使用这个id来获得它的体素中心。为了获得我们将用作体素颜色的密度值，我们使用体素网格中体素的X、Y和Z位置，这是我们已经提取的。从这里开始，一切都与Open3D的例子相同。我们给盒子图元着色，缩放它，并将其平移到体素中心。最后，我们初始化一个Open3D可视化工具，并将创建的体素网格作为几何图形添加到其中。下面给出了完整的pyntcloud/Open3D可视化代码。</p><figure class="kq kr ks kt gt kv"><div class="bz fp l di"><div class="ov ow l"/></div></figure><div class="kq kr ks kt gt ab cb"><figure class="ku kv mp kx ky kz la paragraph-image"><img src="../Images/a60e8a8f6ef1e8815b686c3417b1c3d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*fV4Esc5K37XxDH-1RbKc6A.png"/></figure><figure class="ku kv mp kx ky kz la paragraph-image"><img src="../Images/05185e7d41878d6d784091f609bdfefe.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*YbDUG1mk7kYLLznKIdHY3g.png"/></figure></div><div class="ab cb"><figure class="ku kv mp kx ky kz la paragraph-image"><img src="../Images/439f1a3c8e17b7756b9d91ce5002a3b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*1gOtsi7Bj38_zlvjdzRpIg.png"/></figure><figure class="ku kv mp kx ky kz la paragraph-image"><img src="../Images/24b620455f4e37fb12a8489119acbaa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*gSvZdTkk7n6zad7s2a892Q.png"/><p class="li lj gj gh gi lk ll bd b be z dk mq di mr lo translated">使用圆锥体(左上)、圆柱体(右上)、八面体(左下)和球体(右下)的体素网格|作者图片</p></figure></div><p id="6665" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">为了更有趣，我们可以在创建体素网格时用其他图元替换长方体图元。Open3D有大量的图元——球体、圆柱体、圆环体、八面体、圆锥体等。我们创建一个小的选择函数，它采用图元的名称并返回3D对象。那么我们唯一要改变的就是将<code class="fe or os ot ou b">primitive = o3d.geometry.TriangleMesh.createbox()</code>改为新的函数调用<code class="fe or os ot ou b">primitive = choose_primitive("cylinder")</code>。该函数的代码如下所示。</p><figure class="kq kr ks kt gt kv"><div class="bz fp l di"><div class="ov ow l"/></div></figure><h1 id="2525" class="ns nt iq bd nu nv oy nx ny nz oz ob oc od pa of og oh pb oj ok ol pc on oo op bi translated">使用Trimesh的体素化</h1><div class="kq kr ks kt gt ab cb"><figure class="ku kv pm kx ky kz la paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><img src="../Images/51b3ca459e7582e14b01ab8ebb4302af.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/1*4jOoKZ7H42Q3Me5J0gnpYw.gif"/></div></figure><figure class="ku kv pm kx ky kz la paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><img src="../Images/52e5c032d776203dc4bd0fe3f0fd1630.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/1*g18bzGhcKBbMlVOnuHLqSg.gif"/></div></figure><figure class="ku kv pm kx ky kz la paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><img src="../Images/96056b8f685dee33d97f2e66b4e02fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/1*7yPfQDVv5TM-r8FX-MaQDw.gif"/></div><p class="li lj gj gh gi lk ll bd b be z dk pn di po lo translated">在Trimesh中创建彩色体素化网格的过程-带有纹理的输入网格(左)，带有映射到每个顶点的颜色信息的网格(中)，以及彩色体素化网格(右)|作者的图像</p></figure></div><p id="dc5d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi ls translated"><span class="l lt lu lv bm lw lx ly lz ma di"> T </span> <a class="ae kp" href="https://github.com/mikedh/trimesh" rel="noopener ugc nofollow" target="_blank"> rimesh </a>是使用最广泛的Python库之一，用于处理网格。大量其他库和独立项目使用它或者直接构建在它之上。它提供了大量的点云和网格分析和转换工具。有关Trimesh的安装说明和可视化使用示例，您可以查看文章“<a class="ae kp" rel="noopener" target="_blank" href="/python-libraries-for-mesh-and-point-cloud-visualization-part-1-daa2af36de30"> Python库用于网格、点云和数据可视化(第1部分)</a>”，其中我们展示了如何处理网格和点数据集。</p><p id="731a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">对于体素化，Trimesh有许多方法来创建体素网格，在内部挖空它们，以及使用形态学操作(如闭合和二进制膨胀)填充它们。它也有直接的方法，通过分别调用<code class="fe or os ot ou b">trimesh.voxel.morphology.surface </code>和<code class="fe or os ot ou b">trimesh.voxel.morphology.fill</code>来提取体素网格的表面或填充。该库还提供了快速分析体素网格的工具，如提取边界，检查网格中体素空间是空的还是填充的，以及计算被占用体素的比例和体积。用于执行行进立方体计算的功能也是容易获得的。</p><p id="cdb3" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">Trimesh的一个非常棘手的功能是提取网格的纹理颜色信息，并将其作为颜色提供给体素表示。为此，我们首先提取纹理信息，并将其作为颜色信息映射到网格的每个顶点。这是通过调用<code class="fe or os ot ou b">name_of_the_imported_mesh.visual.to_color().vertex_colors</code>来完成的。然后，我们可以将它转换成一个NumPy数组，并为每个网格顶点自由访问它。然后我们可以通过直接调用<code class="fe or os ot ou b">name_of_the_imported_mesh.voxelized().hollow()</code>从网格中创建一个体素网格，在这里我们可以指定体素网格的分辨率。我们还将体素化转换为空心表示，因为我们需要计算网格和体素表示之间的距离。</p><p id="97bc" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">由于Trimesh不包含将网格颜色直接映射到体素表示的体素的功能，我们首先需要调用<code class="fe or os ot ou b">trimesh.proximity.ProximityQuery(name_of_the_mesh).vertex(voxel_grid_name.points)</code>来计算网格的每个顶点和已经创建的体素表示点之间的距离。然后，我们需要遍历每个点，提取最近的网格顶点的颜色，并将其映射到大小为(X，Y，Z，4)的颜色数组中，其中X，Y和Z是生成的体素网格的大小，3是颜色的R，G，B和A分量。一旦我们有了映射，我们可以调用<code class="fe or os ot ou b">voxel_grid_name.as_boxes(colors = mapped_color_array)</code>，这使得体素网格成为一个三维网格对象，体素/框的颜色等于初始网格的颜色。运行代码时，读者会发现体素化的网格上有洞。这很可能是因为公鸡雕像的网格由于运动过程的结构而不是完全防水的。体素化过程的代码如下所示。</p><figure class="kq kr ks kt gt kv"><div class="bz fp l di"><div class="ov ow l"/></div></figure><h1 id="cdb7" class="ns nt iq bd nu nv oy nx ny nz oz ob oc od pa of og oh pb oj ok ol pc on oo op bi translated">使用PyVista的体素化</h1><figure class="kq kr ks kt gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi pp"><img src="../Images/d7623c09d1fa97260bee72935e87b833.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*aOQRjwGcWo77ovQBmwJmvQ.gif"/></div></div><p class="li lj gj gh gi lk ll bd b be z dk translated">PyVista网格的多点可视化(左上)、体素化表示(右上)、代替立方体的圆锥体表示(左下)以及到网格的每体素距离可视化(右下)|作者图片</p></figure><p id="7dd8" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi ls translated"><span class="l lt lu lv bm lw lx ly lz ma di"> P </span> <a class="ae kp" href="https://docs.pyvista.org/index.html" rel="noopener ugc nofollow" target="_blank"> yVista </a>是一个全功能的网格可视化和分析库，构建于VTK之上。它可以用来创建包含多个窗口、GUI元素以及通过鼠标、键盘和GUI进行交互的复杂应用程序。该库使用过滤例程来转换点云和网格，并提取任何所需的信息。它可以用作物理模拟、计算机图形、GIS、建筑可视化、光线跟踪和数学计算展示的一部分。有关PyVista的安装说明和可视化使用的示例，您可以查看文章“<a class="ae kp" rel="noopener" target="_blank" href="/python-libraries-for-mesh-and-point-cloud-visualization-part-1-daa2af36de30"> Python Libraries for Mesh，Point Cloud，and Data Visualization (Part 1) </a>”，其中我们展示了如何处理网格和点数据集。</p><p id="a105" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">由于PyVista建立在VTK之上，它包含了一个简单的接口，用于将网格转换成<code class="fe or os ot ou b">UniformGrid</code>对象，以构建体素表示。要提到的重要一点是PyVista只能用于网格的体素化。如果给定一个点云，首先需要将它三角化成网格。对于更简单的点云表面，这可以在PyVista中使用<code class="fe or os ot ou b">delaunay_3d</code>三角测量直接完成。另一个要点是，PyVista在体素化时默认期望无缝网格。如果网格有洞、重叠边或其他不正确的几何体，尝试对其进行体素化将会导致错误。体素化是通过调用<code class="fe or os ot ou b">pyvista.voxelize(input_mesh)</code>完成的。如果这个方法抛出一个错误，说明使用的网格不是防水的，有两种方法可以继续——要么在另一个软件如Blender中修复网格，要么添加参数<code class="fe or os ot ou b">check_surface=False</code>。在网格中有小瑕疵的情况下，第二种方法将产生良好的结果，没有任何噪声或伪影。请注意，如果有大洞或几何缺陷，跳过表面检查可能会导致不正确的体素化和噪声。</p><p id="6eec" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">一旦<code class="fe or os ot ou b">voxelize</code>被调用，结果是一个包含所有体素的统一网格对象。然后可以从表示中提取附加信息，如体素中心、每个体素的X、Y、Z边界坐标、包含网格部分的体素的凸包等。PyVista的<a class="ae kp" href="https://docs.pyvista.org/examples/01-filter/voxelize.html#sphx-glr-examples-01-filter-voxelize-py" rel="noopener ugc nofollow" target="_blank">示例</a>中给出了对体素表示的有用分析。一旦我们有了体素，我们可以调用<code class="fe or os ot ou b">compute_implicit_distance</code>来计算体素和网格之间的距离。这对于检查体素化过程是否有任何不一致是有用的，并且用于过滤掉网格内部的体素以创建中空体素表示。另一个有用的转换是使用不同于立方体的图元对象来表示体素。这可以在调用<code class="fe or os ot ou b">voxelize</code>时直接设置，也可以稍后通过调用<code class="fe or os ot ou b">voxelized_object.glyph(geom = type_of_primitive())</code>创建。最后，对于这一部分，我们还将在单独的子窗口中可视化所有内容，并将它们链接起来。这与matplotlib的方法相同，在设置绘图仪<code class="fe or os ot ou b">pyvista.Plotter(shape=(num_horiz_windows,num_vertical_windows))</code>时给出了窗口的数量。一旦设置完毕，就可以通过调用<code class="fe or os ot ou b">pyvista.subplot(horizontal_num, vertical_num)</code>来调用每个子窗口。下面给出了用于产生输入网格的四个子窗口可视化、具有立方体的体素化表示、具有锥体的体素化表示以及网格和体素之间的最终距离的代码。</p><figure class="kq kr ks kt gt kv"><div class="bz fp l di"><div class="ov ow l"/></div></figure><figure class="kq kr ks kt gt kv gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/dd3229aef08e29628a4b210a3830d078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/1*kr90TS_UpFSSJpl7uBaZ8g.gif"/></div><p class="li lj gj gh gi lk ll bd b be z dk translated">PyVista阈值化体素网格基于每个体素中的点密度，使用GUI部件|作者提供的图片</p></figure><p id="d6e9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">我们将使用体素化上下文来展示如何在PyVista中创建一个简单的GUI，并为生成过程添加交互性。首先，一个简短的例子演示了如何为每个体素生成点密度。之所以选择这一步，是因为这是一个有用的分析步骤，PyVista中没有这一步。为此，需要SciPy的<code class="fe or os ot ou b">KDTree</code>功能。我们用它来得到每个体素中心的所有相邻网格顶点。SciPy有一个函数<code class="fe or os ot ou b">query_ball_point</code>，它以一个点为圆心，以指定的半径制作一个球体，并将所有相邻的点都放到这个球体上。当然，当我们在一个体素立方体形状内部寻找点时，使用一个球体会导致不完美的结果。对于本教程，我们将使用这种简化。为了计算球体的半径，使其具有与体素立方体相同的体积，我们使用已知的立方体侧面<em class="js"> x </em>来首先找到立方体的体积:</p><figure class="kq kr ks kt gt kv gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/f9e3b995304abf02a53efbff5b20aae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:152/1*L4LtHiR0H2pMR7eRiZpWMw.gif"/></div></figure><p id="3128" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">接下来，我们得到球体的体积:</p><figure class="kq kr ks kt gt kv gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/667ea7f25c4c13ce0f5e4bdd7ffb6587.png" data-original-src="https://miro.medium.com/v2/resize:fit:224/1*YnbY5eUbJ8Q_4ty6doqbOQ.gif"/></div></figure><p id="e455" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">从那里如果想让两个体积相等，我们可以计算半径为:</p><figure class="kq kr ks kt gt kv gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/14ef285a153474dc39b250b1c38112ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:202/1*ICNYIYrzBlPqILAJVRp6aQ.gif"/></div></figure><p id="2292" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">这可以用Python写在一个小的帮助器函数中，如下所示。</p><figure class="kq kr ks kt gt kv"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="8f19" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">一旦我们有了每个体素中心附近的所有顶点，我们就对它们进行计数，并用最大计数将它们除以，以便在0和1之间对它们进行归一化以便可视化。最后，我们将这些值作为场添加到体素中。代码被分成下面给出的另一个函数。</p><figure class="kq kr ks kt gt kv"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="f358" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">PyVista包含一个现成的内置可视化工具，用于对网格和点云进行阈值处理，名为<code class="fe or os ot ou b">add_mesh_threshold</code>。这直接将对象添加到场景中，并创建一个滑块小部件，该小部件连接到最近的活动字段或指定字段。完整可视化的代码如下所示。</p><figure class="kq kr ks kt gt kv"><div class="bz fp l di"><div class="ov ow l"/></div></figure><figure class="kq kr ks kt gt kv gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/f3d4df2e57fecf499ad61743c06345e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/1*j23JwW9sd92uPBZIHI6ARA.gif"/></div><p class="li lj gj gh gi lk ll bd b be z dk translated">PyVista自定义GUI小部件，用于交互式更改体素化体素大小|作者图片</p></figure><p id="d722" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">最后，我们将创建一个自定义的slider小部件来演示它在PyVista中是多么简单。移动滑块将改变体素的大小，并重新计算整体。为了更简洁，我们将把所有东西添加到一个类中。要创建一个slider小部件，我们只需要调用<code class="fe or os ot ou b">add_slider_widget(name_of_callback_function, [min, max], start_value, title_of_widget, how_often_should_the_widget_call_callback)</code>。最后一个输入决定了当我们单击鼠标按钮、释放鼠标按钮或者每次移动鼠标时是否会调用回调函数。在我们的例子中，我们使用最后一个选项。在回调函数中，我们进行体素化计算，并将其添加到绘图仪中。这里，在绘图仪中指定网格对象的名称很重要。这样PyVista就知道我们在更新同一个网格，而不是每次移动滑块都创建一个新的。下面给出了整个GUI交互性的代码。</p><figure class="kq kr ks kt gt kv"><div class="bz fp l di"><div class="ov ow l"/></div></figure><h1 id="d93f" class="ns nt iq bd nu nv oy nx ny nz oz ob oc od pa of og oh pb oj ok ol pc on oo op bi translated">结论</h1><p id="9543" class="pw-post-body-paragraph jq jr iq jt b ju pu jw jx jy pv ka kb lp pw ke kf lq px ki kj lr py km kn ko ij bi ls translated"><span class="l lt lu lv bm lw lx ly lz ma di"> V </span>当使用点云和网格时，oxelization可以是你的武器库中最强大的工具之一。使用Python生成和处理体素非常简单。在本文中，我们探索了如何创建体素网格，从体素中提取特征，以及将图元从立方体更改为球体、圆柱体、圆锥体等。我们还展示了如何完成体素构建过程，以及如何创建交互式体素化和阈值工具。</p><p id="4ee3" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">一旦有了体素表示，就可以很容易地将其插入到现有的深度学习或资产创建管道中，以实现所需的结果。在接下来的文章中，我们将探索更多通过邻接分析、PCA特征提取、RANSAC实现等从点云和网格中提取特征和有用信息的方法。</p><p id="b2aa" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lp kd ke kf lq kh ki kj lr kl km kn ko ij bi translated">如果您想了解更多关于从点云和网格中提取特征的信息，请阅读我的一些关于三维表面检测和噪声检测的文章[11]和[7]。您可以在我的<a class="ae kp" href="https://ivannikolov.carrd.co/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt ir">页面</strong> </a>上找到这些文章和我的其他研究，如果您看到有趣的东西或只想聊天，请随时给我留言。继续关注更多！</p><h1 id="6470" class="ns nt iq bd nu nv oy nx ny nz oz ob oc od pa of og oh pb oj ok ol pc on oo op bi translated">参考</h1><ol class=""><li id="1c8f" class="mb mc iq jt b ju pu jy pv lp pz lq qa lr qb ko qc mh mi mj bi translated">Qi，C. R .，Su，h .，Nieß ner，m .，Dai，a .，Yan，m .，&amp; Guibas，L. J. (2016)。用于3d数据对象分类的体积和多视图cnns。在<em class="js">IEEE计算机视觉和模式识别会议记录</em>(第5648-5656页)；<a class="ae kp" href="https://openaccess.thecvf.com/content_cvpr_2016/html/Qi_Volumetric_and_Multi-View_CVPR_2016_paper.html" rel="noopener ugc nofollow" target="_blank">https://open access . the VF . com/content _ cvpr _ 2016/html/Qi _ volume _ and _ Multi-View _ CVPR _ 2016 _ paper . html</a></li><li id="41af" class="mb mc iq jt b ju mk jy ml lp mm lq mn lr mo ko qc mh mi mj bi translated">Su，h .，Maji，s .，Kalogerakis，e .，&amp; Learned-Miller，E. (2015)。用于三维形状识别的多视图卷积神经网络。<em class="js">《IEEE计算机视觉国际会议录》T11(第945-953页)；<a class="ae kp" href="https://www.cv-foundation.org/openaccess/content_iccv_2015/html/Su_Multi-View_Convolutional_Neural_ICCV_2015_paper.html" rel="noopener ugc nofollow" target="_blank">https://www . cv-foundation . org/open access/content _ iccv _ 2015/html/Su _ Multi-View _回旋_ neuro _ ICCV _ 2015 _ paper . html</a></em></li><li id="98b5" class="mb mc iq jt b ju mk jy ml lp mm lq mn lr mo ko qc mh mi mj bi translated">Qi，C. R .，Su，h .，Mo，k .，&amp; Guibas，L. J. (2017)。Pointnet:针对3d分类和分割的点集深度学习。<em class="js">摘自《IEEE计算机视觉与模式识别会议录》T15(第652-660页)；<a class="ae kp" href="https://openaccess.thecvf.com/content_cvpr_2017/html/Qi_PointNet_Deep_Learning_CVPR_2017_paper.html" rel="noopener ugc nofollow" target="_blank">https://open access . the VF . com/content _ cvpr _ 2017/html/Qi _ point net _ Deep _ Learning _ CVPR _ 2017 _ paper . html</a></em></li><li id="e01f" class="mb mc iq jt b ju mk jy ml lp mm lq mn lr mo ko qc mh mi mj bi translated">齐春日，易，李，苏，h .，，吉巴斯，刘杰(2017)。Pointnet++:度量空间中点集的深度层次特征学习。<em class="js">神经信息处理系统的进展</em>，<em class="js">30；</em><a class="ae kp" href="https://www.cs.toronto.edu/~bonner/courses/2022s/csc2547/papers/point_nets/pointnet++,_qi,_nips2017.pdf" rel="noopener ugc nofollow" target="_blank">https://www . cs . Toronto . edu/~ bonner/courses/2022s/CSC 2547/papers/point _ nets/point net++、_qi、_nips2017.pdf </a></li><li id="2f87" class="mb mc iq jt b ju mk jy ml lp mm lq mn lr mo ko qc mh mi mj bi translated">王，孙，刘，S. E .萨尔马，布朗斯坦，M. M .，&amp;所罗门，J. M. (2019)。用于点云学习的动态图cnn。<em class="js">Acm Transactions On Graphics(tog)</em>，<em class="js"> 38 </em> (5)，1–12；<a class="ae kp" href="https://dl.acm.org/doi/abs/10.1145/3326362" rel="noopener ugc nofollow" target="_blank">https://dl.acm.org/doi/abs/10.1145/3326362</a></li><li id="f921" class="mb mc iq jt b ju mk jy ml lp mm lq mn lr mo ko qc mh mi mj bi translated"><strong class="jt ir">尼科洛夫一世</strong>；麦德森，C. (2020)，“GGG——粗糙还是嘈杂？SfM重建中的噪声检测指标”，门德利数据，V2；<a class="ae kp" href="https://doi.org/10.17632/xtv5y29xvz.2" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.17632/xtv5y29xvz.2</a></li><li id="4e8b" class="mb mc iq jt b ju mk jy ml lp mm lq mn lr mo ko qc mh mi mj bi translated"><strong class="jt ir">尼科洛夫，I. </strong>，&amp;马德森，C. (2020)。粗暴还是吵闹？SfM重建中噪声估计的度量。<em class="js">传感器</em>、<em class="js"> 20 </em> (19)、5725；<a class="ae kp" href="https://doi.org/10.3390/s20195725" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.3390/s20195725</a></li><li id="e24c" class="mb mc iq jt b ju mk jy ml lp mm lq mn lr mo ko qc mh mi mj bi translated">Poux和r . Billen(2019年)。基于体素的三维点云语义分割:无监督的几何和关系特征与深度学习方法。国际摄影测量与遥感学会国际地理信息杂志。8(5), 213;<a class="ae kp" href="https://doi.org/10.3390/ijgi8050213" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.3390/ijgi8050213</a></li><li id="e360" class="mb mc iq jt b ju mk jy ml lp mm lq mn lr mo ko qc mh mi mj bi translated">徐俊杰，张，r，窦俊杰，朱，孙俊杰，&amp;蒲，s(2021)。Rpvnet:用于激光雷达点云分割的深度有效的距离-点-体素融合网络。在<em class="js">IEEE/CVF计算机视觉国际会议论文集</em>(第16024–16033页)；<a class="ae kp" href="https://openaccess.thecvf.com/content/ICCV2021/html/Xu_RPVNet_A_Deep_and_Efficient_Range-Point-Voxel_Fusion_Network_for_LiDAR_ICCV_2021_paper.html" rel="noopener ugc nofollow" target="_blank">https://open access . the CVF . com/content/iccv 2021/html/Xu _ RPVNet _ A _ Deep _ and _ Efficient _ Range-Point-Voxel _ Fusion _ Network _ for _ LiDAR _ ICCV _ 2021 _ paper . html</a></li><li id="a95f" class="mb mc iq jt b ju mk jy ml lp mm lq mn lr mo ko qc mh mi mj bi translated">豪勒姆，J. B .，阿拉哈姆，M. M .，林奇，M. S .，亨里克森，K. S .，<strong class="jt ir">尼科洛夫，I </strong>。默斯伦德，T. B. (2021年2月)。使用合成点云的下水道缺陷分类。在<em class="js"> VISIGRAPP (5: VISAPP) </em>(第891–900页)；【https://www.scitepress.org/Papers/2021/102079/102079.pdf T4】</li><li id="3068" class="mb mc iq jt b ju mk jy ml lp mm lq mn lr mo ko qc mh mi mj bi translated"><strong class="jt ir">尼科洛夫，I. </strong>，&amp;马德森，C. B. (2021)。使用砂纸粒度量化风力涡轮机叶片表面粗糙度:初步探索。在<em class="js">第16届计算机视觉理论与应用国际会议</em>(第801–808页)。科学出版社数字图书馆；<a class="ae kp" href="https://www.scitepress.org/Link.aspx?doi=10.5220/0010283908010808" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.5220/0010283908010808</a></li></ol></div></div>    
</body>
</html>