<html>
<head>
<title>Data Science for Cycling — How to Visualize Gradient Ranges of a GPX Route</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自行车运动的数据科学-如何可视化GPX路线的坡度范围</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-science-for-cycling-how-to-visualize-gradient-ranges-of-a-gpx-route-d709af02944d#2022-03-02">https://towardsdatascience.com/data-science-for-cycling-how-to-visualize-gradient-ranges-of-a-gpx-route-d709af02944d#2022-03-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="e1d0" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/data-science-for-cycling" rel="noopener" target="_blank">自行车数据科学</a></h2><div class=""/><div class=""><h2 id="850e" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated"><strong class="ak">第5/6部分——用Python和Plotly可视化Strava路线的坡度范围</strong></h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/d75d18824a9b6e3eb66b73f16489b458.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qWeMFXHQBa70Jgkq"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@vaccinium?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Dmitrii Vaccinium </a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="84b3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">据我所知，距离自行车系列的最后一篇文章<a class="ae lh" rel="noopener" target="_blank" href="/data-science-for-cycling-how-to-calculate-route-gradients-from-a-strava-gpx-file-2fc559980186">已经有一段时间了。好消息是——这个故事今天还在继续。我们将从中断的地方继续，那就是梯度分析和可视化。现在你知道了什么是自行车运动中的坡度，以及如何将坡度计算为两点之间的高差。</a></p><p id="62da" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">今天，我们将可视化梯度范围，这意味着显示在特定梯度范围内，例如，在3%和5%之间，所用的时间和距离。在接下来的文章中，我们将在一个交互式Python仪表板中包括这种可视化(以及其他)。</p><p id="c6c1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不想看书？请观看我的视频:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="dc25" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以在<a class="ae lh" href="https://github.com/better-data-science/data-science-for-cycling" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上下载源代码。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="0ffc" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated">如何读取Strava路径数据集</h1><p id="cccc" class="pw-post-body-paragraph li lj it lk b ll nf kd ln lo ng kg lq lr nh lt lu lv ni lx ly lz nj mb mc md im bi translated">我们今天不会为GPX路线文件而烦恼，因为我们已经有了一个包含数据点、高程、距离和坡度数据的CSV文件。首先，我们将导入Numpy、Pandas和Plotly，然后我们将读取数据集:</p><pre class="ks kt ku kv gt nk nl nm nn aw no bi"><span id="b272" class="np mo it nl b gy nq nr l ns nt">import numpy as np<br/>import pandas as pd<br/>import plotly.graph_objects as go<br/>import plotly.offline as pyo<br/><br/><br/>route_df = pd.read_csv('../data/route_df_gradient.csv')<br/>route_df.head()</span></pre><p id="a760" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它看起来是这样的:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nu"><img src="../Images/eb2ee68b03af1814e6acdffbc0680546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wnRZZo5zorSTZjJrnJeN2w.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片1-包含距离、高程和坡度数据的Strava路径数据集(图片由作者提供)</p></figure><p id="bb39" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们对<code class="fe nv nw nx nl b">gradient</code>栏特别感兴趣。为了开始分析，让我们调用它的<code class="fe nv nw nx nl b">describe()</code>方法:</p><pre class="ks kt ku kv gt nk nl nm nn aw no bi"><span id="aeca" class="np mo it nl b gy nq nr l ns nt">route_df['gradient'].describe()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/fdcac1b17873ff2a6f753811c843d222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*2nD6qdPn9pR-P8lbSXBrxA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图2-梯度统计(图片由作者提供)</p></figure><p id="8a86" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">路线看起来大多平坦(平均值和中间值)，最小坡度为-29.2%，最大坡度为17.5%。这些是我们下一步需要的关键信息—为梯度范围创建区间(箱)。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="d556" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated">如何创造与熊猫的时间间隔</h1><p id="7678" class="pw-post-body-paragraph li lj it lk b ll nf kd ln lo ng kg lq lr nh lt lu lv ni lx ly lz nj mb mc md im bi translated">我们现在将梯度值分组到箱中。这样，我们可以计算每个梯度范围的统计数据，例如，在3–5%梯度上捕获的所有数据点。为此，我们将使用熊猫的<code class="fe nv nw nx nl b">IntervalIndex</code>类。它允许我们从元组中创建二进制文件。</p><p id="cde6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以下区间指数中使用的值完全是随机的。您可以自由使用不同的文件来容纳您的路由文件。容器也是左闭合的，这意味着左边的值被包括在内，但右边的值不包括在内:</p><pre class="ks kt ku kv gt nk nl nm nn aw no bi"><span id="19e4" class="np mo it nl b gy nq nr l ns nt">bins = pd.IntervalIndex.from_tuples([<br/>    (-30, -10),<br/>    (-10, -5), <br/>    (-5, -3), <br/>    (-3, -1), <br/>    (-1, 0),<br/>    (0, 1), <br/>    (1, 3), <br/>    (3, 5), <br/>    (5, 7), <br/>    (7, 10), <br/>    (10, 12), <br/>    (12, 15), <br/>    (15, 20)<br/>], closed='left')<br/>bins</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nz"><img src="../Images/c080ff9aac7a4c5194806b6ab8e7a8b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MgRy5WuHJjNqNGlFE-luZg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图3-渐变范围的条块(作者图片)</p></figure><p id="d34f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在让我们使用Pandas的<code class="fe nv nw nx nl b">cut()</code>方法将这些条块添加到数据集:</p><pre class="ks kt ku kv gt nk nl nm nn aw no bi"><span id="d284" class="np mo it nl b gy nq nr l ns nt">route_df['gradient_range'] = pd.cut(route_df['gradient'], bins=bins) <br/>route_df.head()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oa"><img src="../Images/1af12e11717aa85a83dc6a8d533459b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*88VJCCervJ_RfWDgacYumw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图4 —添加了渐变范围的数据帧(图片由作者提供)</p></figure><p id="bd4b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们现在在<code class="fe nv nw nx nl b">gradient_range</code>列中存储了13个不同的组。下一步，我们将从中计算一些对可视化有用的统计数据。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="34d8" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated">从梯度范围计算统计数据</h1><p id="a8ec" class="pw-post-body-paragraph li lj it lk b ll nf kd ln lo ng kg lq lr nh lt lu lv ni lx ly lz nj mb mc md im bi translated">现在的目标是创建一个新的数据框架，其中包含每个梯度的统计数据，包括:</p><ul class=""><li id="fad5" class="ob oc it lk b ll lm lo lp lr od lv oe lz of md og oh oi oj bi translated">行驶距离</li><li id="f0a6" class="ob oc it lk b ll ok lo ol lr om lv on lz oo md og oh oi oj bi translated">在此坡度范围内花费的游乐设备百分比</li><li id="ec31" class="ob oc it lk b ll ok lo ol lr om lv on lz oo md og oh oi oj bi translated">获得的高度</li><li id="201e" class="ob oc it lk b ll ok lo ol lr om lv on lz oo md og oh oi oj bi translated">高程丢失</li></ul><p id="26dc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将通过迭代每个唯一的梯度范围并对数据集进行子集化来创建它，并从那里计算统计数据:</p><pre class="ks kt ku kv gt nk nl nm nn aw no bi"><span id="4033" class="np mo it nl b gy nq nr l ns nt">gradient_details = []<br/><br/># For each unique gradient range<br/>for gr_range in route_df['gradient_range'].unique():<br/>    # Keep that subset only<br/>    subset = route_df[route_df['gradient_range'] == gr_range]<br/>    <br/>    # Statistics<br/>    total_distance = subset['distance'].sum()<br/>    pct_of_total_ride = (subset['distance'].sum() / route_df['distance'].sum()) * 100<br/>    elevation_gain = subset[subset['elevation_diff'] &gt; 0]['elevation_diff'].sum()<br/>    elevation_lost = subset[subset['elevation_diff'] &lt; 0]['elevation_diff'].sum()<br/>    <br/>    # Save results<br/>    gradient_details.append({<br/>        'gradient_range': gr_range,<br/>        'total_distance': np.round(total_distance, 2),<br/>        'pct_of_total_ride': np.round(pct_of_total_ride, 2),<br/>        'elevation_gain': np.round(elevation_gain, 2),<br/>        'elevation_lost': np.round(np.abs(elevation_lost), 2)<br/>    })</span></pre><p id="8cb6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">完成后，将列表转换为数据帧，并按渐变范围排序。这是一个<code class="fe nv nw nx nl b">IntervalIndex</code>，意思是分类工作非常有效:</p><pre class="ks kt ku kv gt nk nl nm nn aw no bi"><span id="6bfb" class="np mo it nl b gy nq nr l ns nt">gradient_details_df = pd.DataFrame(gradient_details).sort_values(by='gradient_range').reset_index(drop=True)<br/>gradient_details_df</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi op"><img src="../Images/e80ccdd48b74e233cd01b857db182276.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R4MFyA307u2AvEAMcHbWqQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图5-每个渐变范围的统计数据(作者提供的图片)</p></figure><p id="cfac" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里有几个解释:</p><ul class=""><li id="5a9c" class="ob oc it lk b ll lm lo lp lr od lv oe lz of md og oh oi oj bi translated">我已经在[-30%，-10%的坡度范围内走完了442.96米，一路上损失了68.58米的海拔。</li><li id="b380" class="ob oc it lk b ll ok lo ol lr om lv on lz oo md og oh oi oj bi translated">大部分骑行是平的[-1%，1) —路线的71，56%或26公里。</li><li id="bddc" class="ob oc it lk b ll ok lo ol lr om lv on lz oo md og oh oi oj bi translated">我只在10%以上的坡度骑过911米。</li></ul><p id="a656" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在让我们将这些数据可视化。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="81d3" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated">用Plotly可视化Strava梯度范围</h1><p id="fdae" class="pw-post-body-paragraph li lj it lk b ll nf kd ln lo ng kg lq lr nh lt lu lv ni lx ly lz nj mb mc md im bi translated">我决定使用Plotly来可视化数据，因为默认情况下它会生成交互式图表。您可以继续使用Matplotlib或任何其他库。</p><p id="de28" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，让我们为每个渐变范围声明一个颜色列表—从蓝色到红色(下降到上升):</p><pre class="ks kt ku kv gt nk nl nm nn aw no bi"><span id="6b20" class="np mo it nl b gy nq nr l ns nt">colors = [<br/>    '#0d46a0', '#2f3e9e', '#2195f2', '#4fc2f7',<br/>    '#a5d6a7', '#66bb6a', '#fff59d', '#ffee58',<br/>    '#ffca28', '#ffa000', '#ff6f00', '#f4511e', '#bf360c'<br/>]</span></pre><p id="8645" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将制作一个条形图，每个条形图将显示一个梯度范围和以公里为单位的行驶距离。每个条形还将显示范围和行驶的距离。如果您使用英制系统，请随意将值转换为英里:</p><pre class="ks kt ku kv gt nk nl nm nn aw no bi"><span id="d750" class="np mo it nl b gy nq nr l ns nt">custom_text = [f'''&lt;b&gt;{gr}%&lt;/b&gt; - {dst}km''' for gr, dst in zip(<br/>    gradient_details_df['gradient_range'].astype('str'),<br/>    gradient_details_df['total_distance'].apply(lambda x: round(x / 1000, 2))<br/>)]</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/6978904d21b57272fe05f2831b1d22ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*LnIVe3M_yeuS_8kdZBvXEg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图6 —单个栏的文本(作者提供的图片)</p></figure><p id="e79c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，我们将创建图形:</p><pre class="ks kt ku kv gt nk nl nm nn aw no bi"><span id="ff03" class="np mo it nl b gy nq nr l ns nt">fig = go.Figure(<br/>    data=[go.Bar(<br/>        x=gradient_details_df['gradient_range'].astype(str),<br/>        y=gradient_details_df['total_distance'].apply(lambda x: round(x / 1000, 2)),<br/>        marker_color=colors,<br/>        text=custom_text<br/>    )],<br/>    layout=go.Layout(<br/>        bargap=0,<br/>        title='Gradient profile of a route',<br/>        xaxis_title='Gradient range (%)',<br/>        yaxis_title='Distance covered (km)',<br/>        autosize=False,<br/>        width=1440,<br/>        height=800,<br/>        template='simple_white'<br/>    )<br/>)<br/>fig.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi or"><img src="../Images/b56baead6eac1b746e9a62aa23285541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wkmKI6O2ZiYwPORbMCotfg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图7 —渐变范围的条形图(图片由作者提供)</p></figure><p id="c9d1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以看到，大部分乘坐是绿色的，这表明一个平坦的表面。5%及以上的坡度只有2.3公里的爬坡。听起来不多，但我的腿和肺当时不同意。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="4594" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated">结论</h1><p id="2776" class="pw-post-body-paragraph li lj it lk b ll nf kd ln lo ng kg lq lr nh lt lu lv ni lx ly lz nj mb mc md im bi translated">这就是你要做的——如何可视化斯特拉发GPX路线文件的渐变范围。我不认为最终目标从一开始就是明确的，因为术语“渐变范围”可以意味着几乎任何东西。我希望你能在阅读后理解我对这个术语的看法，并希望你在分析你的Strava训练时会发现它很有用。</p><p id="9ac4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在接下来的文章中，我们将在一个交互式Python仪表板上组合到目前为止本系列中涉及的所有内容以及更多内容，敬请关注。</p><p id="bc61" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以下是整个系列的链接——我会在发布文章时添加网址:</p><ul class=""><li id="c635" class="ob oc it lk b ll lm lo lp lr od lv oe lz of md og oh oi oj bi translated"><a class="ae lh" rel="noopener" target="_blank" href="/data-science-for-cycling-how-to-read-gpx-strava-routes-with-python-e45714d5da23">第1篇:从Strava加载并分析GPX文件</a></li><li id="4269" class="ob oc it lk b ll ok lo ol lr om lv on lz oo md og oh oi oj bi translated"><a class="ae lh" rel="noopener" target="_blank" href="/data-science-for-cycling-how-to-visualize-gpx-strava-routes-with-python-and-folium-21b96ade73c7">第二条:用圆形标记和多边形线可视化来自Strava的GPX文件</a></li><li id="8ec9" class="ob oc it lk b ll ok lo ol lr om lv on lz oo md og oh oi oj bi translated"><a class="ae lh" rel="noopener" target="_blank" href="/data-science-for-cycling-how-to-calculate-elevation-difference-and-distance-from-strava-gpx-route-cff147033c16">第三条:计算点与点之间的高差和距离，可视化路线的高程剖面图</a></li><li id="eadc" class="ob oc it lk b ll ok lo ol lr om lv on lz oo md og oh oi oj bi translated"><a class="ae lh" rel="noopener" target="_blank" href="/data-science-for-cycling-how-to-calculate-route-gradients-from-a-strava-gpx-file-2fc559980186">第四条:根据点与点之间的高差和距离计算路线坡度</a></li><li id="fdd3" class="ob oc it lk b ll ok lo ol lr om lv on lz oo md og oh oi oj bi translated">文章5:计算和可视化梯度剖面——在梯度范围内循环的距离</li><li id="c695" class="ob oc it lk b ll ok lo ol lr om lv on lz oo md og oh oi oj bi translated">文章6:创建一个web应用程序，分析并可视化用户从Strava上传的GPX文件</li></ul></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="1250" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="os">喜欢这篇文章吗？成为</em> <a class="ae lh" href="https://medium.com/@radecicdario/membership" rel="noopener"> <em class="os">中等会员</em> </a> <em class="os">继续无限制学习。如果你使用下面的链接，我会收到你的一部分会员费，不需要你额外付费。</em></p><div class="ot ou gp gr ov ow"><a href="https://medium.com/@radecicdario/membership" rel="noopener follow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd jd gy z fp pb fr fs pc fu fw jc bi translated">通过我的推荐链接加入Medium-Dario rade ci</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">medium.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk lb ow"/></div></div></a></div></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="13f7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="os">原载于2022年3月2日</em><a class="ae lh" href="https://betterdatascience.com/data-science-for-cycling-gradient-ranges/" rel="noopener ugc nofollow" target="_blank"><em class="os">https://betterdatascience.com</em></a><em class="os">。</em></p></div></div>    
</body>
</html>