<html>
<head>
<title>A Simple Method for Numerical Integration in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中数值积分的一种简单方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-simple-method-for-numerical-integration-in-python-579f785d7a93#2022-06-13">https://towardsdatascience.com/a-simple-method-for-numerical-integration-in-python-579f785d7a93#2022-06-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0c0a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">常微分方程系统近似解的分步编码示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8f7c5759c9c19b9a9754934e19535824.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hWPHhxXe3hFPnuRL"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Sanjeevan SatheesKumar 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4dbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数值积分是一种用来近似求解常微分方程的技术。有一系列数值积分的方法；这些在速度、准确性和复杂性方面有所不同。举几个例子，有欧拉法、龙格-库塔法和梯形法则。幸运的是，作为一名程序员或工程师，您不需要知道这些方法如何工作的确切细节，就可以获得一个好的ODE或ODE系统的解决方案。</p><p id="c785" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开始编写代码之前，让我们先简要介绍一下什么是常微分方程以及数值积分是如何工作的。这些微分方程的形式如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/8190c17d34ce4b260171e7dab6eacf89.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/1*dBglJe_cy4gbULKpdSUyyQ.gif"/></div></figure><p id="60af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，<em class="lw"> y </em>是<em class="lw"> x </em>的未知函数(我们试图在某些<em class="lw"> x </em>值上逼近这个函数)，而<em class="lw"> F </em>是<em class="lw"> x </em>、<em class="lw"> y </em>的函数，以及<em class="lw"> y </em>的导数(我们已有的或已给的)。<em class="lw"> n </em>代表微分方程的阶或最高导数。函数，<em class="lw"> F </em>，通常是一个由物理学家、数学家、科学家等导出的著名方程。例如，给定一个质点的速度函数，你可以求解该质点的位置。在这个例子中，时间将等于上面等式中的<em class="lw"> x </em>，速度将等于<em class="lw"> F </em>。</p><p id="7680" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，你可以有一个你想要解决(或近似)的常微分方程系统。这些方程将采用以下形式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/835f98c3d09f29c826ceada9b6f7d5af.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/1*EYkO-obbeAesKawVg-yadg.gif"/></div></figure><p id="2da5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们有一组我们感兴趣的<em class="lw"> y </em>值(数量为<em class="lw"> m </em>)，每个值都有自己的导数和未知解。</p><p id="68f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">涉及常微分方程的最常见问题之一是初值问题(IVPs)。在这些问题中，你会得到一个初始值和一个上面给出的ODE。通常，您将使用一阶ODE。对于一阶常微分方程，数值方法采用常微分方程并将其视为斜率。利用这个斜率和<em class="lw"> x </em>上的一个非常小的增量，可以将<em class="lw"> y </em>的初始值增加到接近<em class="lw"> y </em>的下一个值。重复这个过程，直到你找到所有你感兴趣的值。如果仔细选择<em class="lw"> x </em>的步长，那么近似可以产生非常精确的结果。这也适用于颂诗系统。</p><p id="35ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于本文，我们先解一组三(<em class="lw"> m </em>)阶(<em class="lw"> n </em>)阶常微分方程。这些等式是任意的，所以根据需要用你自己的来代替。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/b8dc5199db3a75519d69188e27082fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:332/1*AvmZYZegW01uUqZkdFFEjg.gif"/></div></figure><p id="ad89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，刻度线表示变量的一次导数。我们将把我们的常微分方程系统作为一个初值问题来解决。这意味着我们将把<em class="lw"> I </em>、<em class="lw"> L </em>和<em class="lw"> P </em>的初始值传递给我们的数值积分器。使用这些值，我们的数值积分器将在时间上采取小步骤，并在每个时间步骤使用导数来求解我们的变量。我将在编码部分更详细地介绍数字积分器及其功能。让我们直接进入代码吧！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="7deb" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated"><strong class="ak">导入库</strong></h2><p id="105e" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">这里，我们只是导入必要的库和函数来运行这段代码。</p><ul class=""><li id="36ba" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">来自<em class="lw">的<code class="fe nn no np nq b">solve_ivp</code>SciPy</em>库用于解决初值问题和数值积分</li><li id="b9e6" class="ne nf it lb b lc nr lf ns li nt lm nu lq nv lu nj nk nl nm bi translated"><em class="lw"> matplotlib </em>中的<code class="fe nn no np nq b"><em class="lw">pyplot</em></code> <em class="lw"> </em>用于绘制数值积分的结果(为便于调用，定义为<code class="fe nn no np nq b">plt</code>)</li></ul><pre class="kj kk kl km gt nw nq nx ny aw nz bi"><span id="f5ea" class="mg mh it nq b gy oa ob l oc od"># Importing Packages<br/>from scipy.integrate import solve_ivp<br/>import matplotlib.pyplot as plt</span></pre><h2 id="ab29" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated"><strong class="ak">创建用户自定义函数</strong></h2><p id="28e4" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">下一步是将我们的ODEs系统定义为一个名为<code class="fe nn no np nq b">model</code>的用户自定义Python函数。这将允许<code class="fe nn no np nq b">solve_ivp</code>在数值积分时使用该功能。你会在下面的代码中看到，我们首先从传入函数的<em class="lw"> Y </em>向量中拉出<em class="lw"> I </em>、<em class="lw"> L </em>和<em class="lw"> P </em>变量(<code class="fe nn no np nq b">solve_ivp</code>在幕后传递<em class="lw"> t </em>和<em class="lw"> Y </em>)。然后，我们使用这些值来求解我们在本文前面定义的时间导数。我们为这些衍生品创建一个列表并返回它们。</p><pre class="kj kk kl km gt nw nq nx ny aw nz bi"><span id="a6e4" class="mg mh it nq b gy oa ob l oc od"># Model for solve_ivp<br/>def model(t, Y):<br/>    I = Y[0]<br/>    L = Y[1]<br/>    P = Y[2]<br/>    dIdt = 1/2*P<br/>    dLdt = 2*(L*P)**(1/3)<br/>    dPdt = 100/I<br/>    dYdt = [dIdt, dLdt, dPdt]<br/>    return dYdt</span></pre><h2 id="c08b" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated"><strong class="ak">数值积分求解</strong></h2><p id="ac87" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">如本文前面所述，我们将使用<code class="fe nn no np nq b">solve_ivp</code>对我们的ODEs系统进行数值积分。<code class="fe nn no np nq b">solve_ivp</code>函数有两个必需的参数:用户定义的函数<code class="fe nn no np nq b">model</code>、时间跨度元组<code class="fe nn no np nq b">tspan</code>和一组初始条件<code class="fe nn no np nq b">Y0</code>。时间跨度和初始条件是随机选择的，所以你可以随意摆弄它们，看看你会得到什么结果。我们还可以传入额外的可选参数，这些参数将帮助我们定义我们希望我们的解决方案具有什么样的数值方法和精度。我们将选择5(4)阶的龙格-库塔方法和1/10 ⁰.的相对容差(相对精度)<code class="fe nn no np nq b">solve_ivp</code>还有很多其他选择。点击查看文档<a class="ae ky" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html" rel="noopener ugc nofollow" target="_blank">。</a></p><pre class="kj kk kl km gt nw nq nx ny aw nz bi"><span id="f802" class="mg mh it nq b gy oa ob l oc od"># Initial Conditions<br/>Y0 = [0.5, 0.2, 0.1]  # [I0, L0, P0]<br/><br/># Time Span of Interest<br/>tspan = (0, 5)  # (t0, tf)<br/><br/># Solving ODE<br/>sol = solve_ivp(model, tspan, Y0, method='RK45', rtol=1e-10)<br/>I_sol, L_sol, P_sol = sol.y<br/>time = sol.t</span></pre><p id="05ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们运行数值积分器，我们将把结果存储在变量<code class="fe nn no np nq b">sol</code>中。然后，我们可以使用点运算符提取变量<em class="lw"> I </em>、<em class="lw"> L </em>和<em class="lw"> P </em>的时间历程或近似解。此外，我们可以提取变量求解的时间步长。</p><h2 id="e134" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated"><strong class="ak">绘图结果</strong></h2><p id="815d" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">最后，我们可以使用<em class="lw"> Pyplot </em>来可视化<code class="fe nn no np nq b">solve_ivp</code>的输出。使用我们收集的时间和时间历史数据，我们可以在同一个图上绘制每个变量。没有标题、轴标签或图例的图是不完整的，所以我们也将包括它们。</p><pre class="kj kk kl km gt nw nq nx ny aw nz bi"><span id="33c2" class="mg mh it nq b gy oa ob l oc od"># Plotting Results<br/>plt.plot(time, I_sol)<br/>plt.plot(time, L_sol)<br/>plt.plot(time, P_sol)<br/>plt.title('Numerical Integration Results')<br/>plt.xlabel('Time')<br/>plt.ylabel('Solution Values')<br/>plt.legend(['I', 'L', 'P'])<br/>plt.show()</span></pre><p id="6071" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这部分代码的输出显示了使用数字积分器时I <em class="lw">、L </em>和P 的近似解。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/66adb8cb606bcc41a6fdccbbf68e926b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*YjRf-HIqui4rHkA1-Egqkg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数值积分结果[由作者创建]</p></figure><p id="6624" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至此，我们已经使用<code class="fe nn no np nq b">solve_ivp</code>成功地解决了我们的原始常微分方程组。如你所见，过程相对简单；您所需要的就是为数值积分器设置参数。一旦你这样做了，就一帆风顺了。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="0e6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于Python中ODEs数值积分的简单方法的文章到此结束。希望你学到了一些东西，并能应用到你的项目中。有问题就留言评论吧！如果你还没有，请留下你的掌声并跟随！谢谢大家！</p></div></div>    
</body>
</html>