<html>
<head>
<title>5 Snowflake Query Tricks You Aren’t Using but Should Be</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你没有使用但应该使用的5个雪花查询技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-snowflake-query-tricks-you-arent-using-but-should-be-7f264b2a72d8#2022-09-22">https://towardsdatascience.com/5-snowflake-query-tricks-you-arent-using-but-should-be-7f264b2a72d8#2022-09-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c817" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">更少的行、更低的成本和更快的执行时间</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/59f0c32735d64c1d39e48c2b263e9b04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BCjcU5MX1lUrDL7h"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">凯利·西克玛在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="760a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">雪花是一个云计算数据解决方案，允许用户在他们的云平台上直接存储数据和运行查询，可以通过网络浏览器直接访问。它通常用于廉价的数据存储和自动伸缩能力，集群可以自动启动和停止来管理查询工作负载。</p><p id="f460" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">经常被忽视的是，雪花不仅仅使在数据库上设置和运行查询变得更容易。它还具有独特的查询语法，这是PostgreSQL或MySQL等其他数据库系统所没有的。在下面的这篇文章中，我们将介绍我最喜欢的这些强大的子句，以及如何使用它们来改进语法和可读性，但最重要的是减少计算成本和执行时间。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="3fb1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.具有资格；合格；取得资格(或学历)</h1><p id="99b6" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated"><a class="ae ky" href="https://docs.snowflake.com/en/sql-reference/constructs/qualify.html" rel="noopener ugc nofollow" target="_blank"> qualify </a>子句允许我们直接过滤窗口函数的结果，而不是先在CTE中创建结果，然后再过滤。窗口函数的一个非常常见的方法是使用子查询首先获得row_number()</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="b6cb" class="ne md it na b gy nf ng l nh ni">row_number() over (partition by email order by created_at desc) as date_ranking</span></pre><p id="b5eb" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">然后在另一个CTE中对此进行过滤，以获得组中的第一行。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="bd8b" class="ne md it na b gy nf ng l nh ni">where date_ranking = 1</span></pre><p id="4fc6" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这种方法的问题是它需要一个额外的子查询。在Snowflake中，这可以通过使用qualify将窗口函数应用为where并同时执行这两个步骤来实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="bbfa" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">Qualify还有另一个非常强大的用例。一个常见的即席或QA查询是检查重复项，以找出唯一性测试失败的原因，并避免无意中复制行的连接。这通常看起来像这样。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="5409" class="ne md it na b gy nf ng l nh ni">select<br/>   product_id,<br/>   count(*)<br/>from product_sales<br/>group by 1<br/>having count(*) &gt; 1<br/>order by 2 desc</span></pre><p id="482c" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">然而，这仅仅给了我们主键，并没有告诉我们副本出现在哪一列。要修复重复，我们需要知道是什么导致了它，因此最简单的方法就是能够看到所有的列。这可以通过使用上述查询的CTE，然后执行另一个在id上过滤的选择(或者通过复制和粘贴主键值)来完成。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2378" class="ne md it na b gy nf ng l nh ni">with base as (<br/>  select<br/>     product_id,<br/>     count(*)<br/>  from product_sales<br/>  group by 1<br/>  having count(*) &gt; 1<br/>  order by 2 desc<br/>)</span><span id="3581" class="ne md it na b gy nl ng l nh ni">select *<br/>from product_sales<br/>where product_id in (select product_id from base)</span></pre><p id="8704" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">但是现在我们知道了qualify的存在，我们实际上可以在四分之一的行中完成这个查询，而不需要任何额外的步骤。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="9340" class="ne md it na b gy nf ng l nh ni">select *<br/>from product_sales<br/>qualify count(*) over (partition by product_id) &gt; 1</span></pre><h1 id="df38" class="mc md it bd me mf nm mh mi mj nn ml mm jz no ka mo kc np kd mq kf nq kg ms mt bi translated">2.敌我识别系统(Identification Friend or Foe)</h1><p id="4ea1" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated"><a class="ae ky" href="https://docs.snowflake.com/en/sql-reference/functions/iff.html" rel="noopener ugc nofollow" target="_blank"> iff </a>子句允许我们使用一个简单的例子，但是在语法上更漂亮。这样做的好处是可以替换单个比较的CASE子句(例如，创建一个true/false字段)。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8813" class="ne md it na b gy nf ng l nh ni">case when col is null then true else false end</span></pre><p id="ad5e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们现在可以用更少的单词和更常用的语法(如Excel或Python)来执行上述功能，这就是<code class="fe nr ns nt na b">if a then b else c</code>逻辑。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="6cb5" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这比前一种方法更漂亮(我认为),也清楚地表明了哪些情况下只执行一次比较，而哪些情况下实际上需要CASE子句。当与其他子句链接时是否更容易理解，因为它是一个带有开始和结束括号的自包含函数。</p><h1 id="0c94" class="mc md it bd me mf nm mh mi mj nn ml mm jz no ka mo kc np kd mq kf nq kg ms mt bi translated">3.在枢轴上转动</h1><p id="6920" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">在对每个列执行相同的聚合时，<a class="ae ky" href="https://docs.snowflake.com/en/sql-reference/constructs/pivot.html" rel="noopener ugc nofollow" target="_blank"> pivot </a>子句用于将一列中的唯一值分散到多个列中。透视值是一种常见的技术，用于对总数进行分段以供进一步分析，例如在创建产品销售群组视图以查看逐月业绩时。像sql中的许多东西一样，这可以通过使用CASE语句来实现。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="32c5" class="ne md it na b gy nf ng l nh ni">select<br/>  product_id,<br/>  sum(case when month = 'jan' then amount else 0 end) as amount_jan,<br/>  sum(case when month = 'feb' then amount else 0 end) as amount_feb,<br/>  sum(case when month = 'mar' then amount else 0 end) as amount_mar<br/>from product_sales<br/>group by 1<br/>order by product_id</span></pre><p id="a0ae" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">但是，这种方法要求我们为我们想要透视的每个月值重复CASE逻辑，随着月数的增加，这可能会变得很长(想象一下，如果我们想要透视2年的值)。值得庆幸的是，在Snowflake中这是不必要的，因为我们有pivot子句可用，但是要使用该子句，我们首先必须将表简化为只有行列(仍然是行)、pivot列(不同的值分布在多个列中)和值列(填充单元格值)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="e2f9" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这里，透视列在AS子句中有别名，以便使列名更具信息性，并删除列名中出现的引号，以便将来更容易引用它们。</p><h1 id="4fc3" class="mc md it bd me mf nm mh mi mj nn ml mm jz no ka mo kc np kd mq kf nq kg ms mt bi translated">4.尝试_到_日期</h1><p id="720a" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated"><a class="ae ky" href="https://docs.snowflake.com/en/sql-reference/functions/try_to_date.html" rel="noopener ugc nofollow" target="_blank"> try_to_date </a>子句使我们能够尝试多种类型的日期转换而不抛出错误。如果日期存储为字符串(不要这样做)或通过某种自由流动的文本框收集(也不要这样做)，这将特别有用。理论上，您处理的所有日期都应该作为日期或时间戳类型存储在数据库中，但在实践中，您可能会遇到需要将多种类型的日期字符串转换为日期的情况。这就是该子句的亮点，因为您可以应用各种日期格式而不会出现错误。</p><p id="9731" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">假设我们将日期存储为文本列中的<code class="fe nr ns nt na b">14/12/2020</code>和<code class="fe nr ns nt na b">19 September 2020</code>。如果我们试图将该列转换为日期，如果有任何日期不能正确转换，我们将会得到一个错误。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e5c5" class="ne md it na b gy nf ng l nh ni">Date '19 September 2020' is not recognized<br/>Date '14/12/2020' is not recognized</span></pre><p id="ff79" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">通过返回null而不是错误，try_to_date解决了我们之前的困境，它使我们能够将列转换为多种日期格式而不会引发错误，如果没有找到有效的日期转换，则最终返回null。我们可以用一个coalesce子句将多种日期格式链接起来以实现这一点。</p><p id="cf44" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这也处理了雪花的假设，即日期是以<code class="fe nr ns nt na b">MM/DD/YYYY</code>格式表示的，即使对于像<code class="fe nr ns nt na b"> 14/12/2020</code>这样的情况，这样的日期是不可能的，因为这将意味着一个月大于12。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="0dd5" class="mc md it bd me mf nm mh mi mj nn ml mm jz no ka mo kc np kd mq kf nq kg ms mt bi translated">5.变量引用</h1><p id="6275" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">可能是我们今天要讨论的最强大的技术。当执行select语句时，雪花实际上允许我们在查询的其他地方重用逻辑。这消除了对复制/粘贴业务逻辑的需要，这是在编写业务逻辑可能变得庞大和复杂的查询时的一个常见问题。在select和where中，有时甚至在group或order by子句中重复这样的逻辑既麻烦又不方便。</p><p id="4767" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">下面是一个简单的例子，我们重用了<code class="fe nr ns nt na b">month</code>别名，而不是重复最初构建它的查询。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="aa52" class="ne md it na b gy nf ng l nh ni">select<br/>   date_trunc('month', created_at) as month,<br/>   count(*) as total_transactions<br/>from product_sales<br/>where month = '2022-01-01'</span></pre><p id="ebbd" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">但是，如果我们使用的引用变成隐式的，我们需要小心(有两列引用)。在下面的例子中，雪花将使用第一个/已经存在的列<code class="fe nr ns nt na b">i.status</code>，而不是新创建的列。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="383f" class="ne md it na b gy nf ng l nh ni">select<br/>  iff(p.status in ('open', 'active'), 'active', i.status) as status,<br/>  iff(status = 'active', true, false) as is_active<br/>from product_sales p</span></pre><p id="7cbd" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">为了解决这个问题，我们可以简单地给中间列取不同的别名。这有助于减少成本和执行时间，因为我们只需要构建一次业务逻辑！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="5d4f" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这并不总是我最喜欢的结果，因为我遇到过在引用它之前应用一些转换来实现结果的情况。正如我们之前看到的，这遇到了我们在<code class="fe nr ns nt na b">status</code>中遇到的重复别名的问题，所以如果有人设法找到了一个很酷的解决方案，请告诉我！</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="0ef9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最后的想法</h1><p id="f4d9" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">雪花是一个强大的数据库解决方案，它还具有一些非常有用的查询选项。我们看了一些help，它们可以帮助我们绕过一些常见的查询障碍，减少相同输出所需的行数，最重要的是，改进语法和可读性，并减少成本和执行时间。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="a9a0" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果您喜欢这篇文章，您可以在我的上找到更多文章，并在我的<a class="ae ky" href="https://medium.com/@anthonyli358" rel="noopener">个人资料</a>上关注我！</p></div></div>    
</body>
</html>