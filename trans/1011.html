<html>
<head>
<title>Object Oriented Programming in Python — Understanding Variables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的面向对象编程—理解变量</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/object-oriented-programming-in-python-understanding-variable-e451cf581368#2022-03-16">https://towardsdatascience.com/object-oriented-programming-in-python-understanding-variable-e451cf581368#2022-03-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="99f1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理解 Python 类中不同类型的变量以及如何使用它们。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3326f5840042afd12b40498421e5ba2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kUMrXOBFLvjga_u7"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@pankajpatel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Pankaj Patel </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="edbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在之前的文章中，我们介绍了作为<em class="ls">类</em>的一个基本组件的<em class="ls">变量</em>，但是我们并没有深入探讨。在这篇文章中，我们将深入探讨类中不同类型的变量<em class="ls">以及它们如何用于不同的目的。</em></p><p id="3634" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">变量让我们在程序中存储特定的值。在<em class="ls">类</em>中，<em class="ls">变量</em>的一些常见用法是初始化一个空变量供<em class="ls">方法</em>使用，声明一个名称或默认值。</p><blockquote class="lt lu lv"><p id="346b" class="kw kx ls ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">一个 Python 类<em class="iq">可以有两种类型的</em>变量<em class="iq">:实例和类变量。</em></p></blockquote><h1 id="4b4b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">安装</h1><p id="e7aa" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们将使用我们在上一篇文章中创建的<em class="ls">类</em> — <code class="fe mw mx my mz b">NumList</code>的稍微修改版本来继续我们的讨论。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><pre class="kg kh ki kj gt nc mz nd ne aw nf bi"><span id="9b23" class="ng ma iq mz b gy nh ni l nj nk">Instance name of nlA1 =  Number List A1</span></pre><h1 id="d75f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">实例变量</h1><blockquote class="lt lu lv"><p id="f1bc" class="kw kx ls ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated"><em class="iq">这些是与</em>对象<em class="iq">或</em>类实例<em class="iq">紧密相关的</em>变量<em class="iq">，而不是</em>类<em class="iq">。</em></p></blockquote><p id="e17c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果你有一辆玩具车，我们认为它是一个<code class="fe mw mx my mz b">Toy</code>类类型，那么实例变量将是那些附加到<strong class="ky ir">你的</strong>玩具车的变量，而不是附加到<code class="fe mw mx my mz b">Toy</code>类的任何其他玩具车的变量。</p><h2 id="b08e" class="ng ma iq bd mb nl nm dn mf nn no dp mj lf np nq ml lj nr ns mn ln nt nu mp nv bi translated">声明实例变量</h2><blockquote class="lt lu lv"><p id="ee6b" class="kw kx ls ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated"><em class="iq">一个</em>实例变量<em class="iq">可以在</em>类<em class="iq">内部声明，也可以在</em>类实例<em class="iq">创建后声明。</em></p></blockquote><p id="a7c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">举个例子，</p><ul class=""><li id="f697" class="nw nx iq ky b kz la lc ld lf ny lj nz ln oa lr ob oc od oe bi translated"><code class="fe mw mx my mz b">__list</code>和<code class="fe mw mx my mz b">instName</code>是在<code class="fe mw mx my mz b">NumListA</code>类中声明的两个<em class="ls">实例变量</em>。另外，请注意如何在初始化<em class="ls">类</em>并在以后使用时传递参数，例如<code class="fe mw mx my mz b">nlA1.insName</code> = "Number List A1 "。</li><li id="3792" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated"><code class="fe mw mx my mz b">outOfClassVar</code>是直接为<code class="fe mw mx my mz b">nlA1</code>对象<em class="ls">创建的</em>。</li></ul><h2 id="3775" class="ng ma iq bd mb nl nm dn mf nn no dp mj lf np nq ml lj nr ns mn ln nt nu mp nv bi translated">实例变量是独立</h2><p id="f0c3" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><em class="ls">实例变量</em>是特定于实例的，因此与其他实例相隔离，即使它们可能都属于相同的<em class="ls">类</em>类型。检查实例变量<code class="fe mw mx my mz b">instName</code>在被两个不同名称参数创建的<em class="ls">实例</em>(<code class="fe mw mx my mz b">nl</code>和<code class="fe mw mx my mz b">nl2</code>)调用时如何产生不同的结果。</p><pre class="kg kh ki kj gt nc mz nd ne aw nf bi"><span id="24c7" class="ng ma iq mz b gy nh ni l nj nk">nlA2 = NumListA(name = "Number List A2")<br/>print('Name of nlA1 instance = ', nlA1.instName)<br/>print('Name of nlA2 instance = ', nlA2.instName)</span><span id="d905" class="ng ma iq mz b gy ok ni l nj nk">Name of nlA1 instance =  Number List A1<br/>Name of nlA2 instance =  Number List A2</span></pre><h1 id="b277" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">类别变量</h1><p id="5799" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><em class="ls">类变量</em>是在<em class="ls">类</em>中声明的，并且它们坚持使用<em class="ls">类</em>。这意味着，与<em class="ls">实例变量</em>不同，即使没有<em class="ls">对象</em>被创建<em class="ls">类变量</em>仍将存在，并且它们的值在<em class="ls">类</em>级别更新，而不是在<em class="ls">实例</em>级别更新。</p><h2 id="5299" class="ng ma iq bd mb nl nm dn mf nn no dp mj lf np nq ml lj nr ns mn ln nt nu mp nv bi translated">声明和调用类变量</h2><p id="5637" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><em class="ls">类变量</em>在<em class="ls">类</em>内声明，但在任何方法外声明。看下面的例子，在<code class="fe mw mx my mz b">NumListB</code>中创建了<em class="ls">类变量</em> <code class="fe mw mx my mz b">counter</code>。</p><p id="9f93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">类变量</em>的调用遵循与<em class="ls">实例变量</em>相同的约定有:&lt;<code class="fe mw mx my mz b">instance name</code>&lt;<code class="fe mw mx my mz b">.</code>&gt;&lt;<code class="fe mw mx my mz b">class variable name</code>&gt;。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="40e1" class="ng ma iq bd mb nl nm dn mf nn no dp mj lf np nq ml lj nr ns mn ln nt nu mp nv bi translated">类变量是粘性的！</h2><p id="58b2" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><em class="ls">实例变量</em>只被限制在它们的<em class="ls">实例</em>中，而<em class="ls">类变量</em>是粘性的。它们继承并更新从<em class="ls">类</em>创建的所有<em class="ls">对象</em>。</p><p id="ef2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mw mx my mz b">NumListB</code>中，我们在<code class="fe mw mx my mz b">__init__</code>方法中添加了<code class="fe mw mx my mz b">NumListB.counter += 1</code>，它基本上告诉 Python 在每次实例化<code class="fe mw mx my mz b">NumListB</code>时将<em class="ls">类变量</em> <code class="fe mw mx my mz b">counter</code>递增 1。</p><p id="2d1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">🛑注意到下面从<code class="fe mw mx my mz b">nlB1</code>和<code class="fe mw mx my mz b">nlB2</code>调用<code class="fe mw mx my mz b">counter</code>产生了相同的值。</p><pre class="kg kh ki kj gt nc mz nd ne aw nf bi"><span id="1a28" class="ng ma iq mz b gy nh ni l nj nk">nlB1 = NumListB(name = "Number List B1")<br/>nlB2 = NumListB(name = "Number List B2")</span><span id="e9dc" class="ng ma iq mz b gy ok ni l nj nk"># printing out class variable<br/>print("Number of NumList class instance created = ", nlB1.counter)<br/>print("Number of NumList class instance created = ", nlB2.counter)</span><span id="64b6" class="ng ma iq mz b gy ok ni l nj nk">Number of NumList class instance created =  2<br/>Number of NumList class instance created =  2</span></pre><h2 id="a69f" class="ng ma iq bd mb nl nm dn mf nn no dp mj lf np nq ml lj nr ns mn ln nt nu mp nv bi translated">检查属性是否存在</h2><p id="8c19" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">一旦你创建了一堆<em class="ls">类</em>和<em class="ls">对象</em>，你不太可能知道它们包含哪些属性或变量。或者想想当你不得不使用其他人创建的<em class="ls">类</em>的时候。在这种情况下，为了检查哪些属性包含在一个<em class="ls">类</em>或<em class="ls">对象</em>中，我们可以使用两个功能:<code class="fe mw mx my mz b">__dict__</code>和<code class="fe mw mx my mz b">hasattr</code>。</p><p id="2584" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">列出所有属性</strong></p><p id="0884" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mw mx my mz b">__dict__</code>是一个内置的功能，无论何时创建它们，都会自动带有一个<em class="ls">对象</em>或<em class="ls">类</em>。请看下面我们如何调用它来获得一个<em class="ls">对象</em>的所有属性。</p><pre class="kg kh ki kj gt nc mz nd ne aw nf bi"><span id="cdc9" class="ng ma iq mz b gy nh ni l nj nk"># printing out the instance variables<br/>print('Instance variables of %s are: \n' %(nlB1.instName), nlB1.__dict__)</span><span id="c364" class="ng ma iq mz b gy ok ni l nj nk">Instance variables of Number List B1 are: <br/> {'instName': 'Number List B1', '_NumListB__list': []}</span></pre><p id="1f32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">🛑注意到，<code class="fe mw mx my mz b">nlB1.__dict__</code>的输出没有显示<em class="ls">类变量</em> - <code class="fe mw mx my mz b">counter</code>。</p><blockquote class="ol"><p id="eab6" class="om on iq bd oo op oq or os ot ou lr dk translated"><em class="ov">从实例调用</em> <code class="fe mw mx my mz b"><em class="ov">__dict__</em></code> <em class="ov">不会显示</em>类变量<em class="ov">，因为它们不是</em>实例<em class="ov">的属性。</em></p></blockquote><p id="c384" class="pw-post-body-paragraph kw kx iq ky b kz ow jr lb lc ox ju le lf oy lh li lj oz ll lm ln pa lp lq lr ij bi translated">但是我们可以使用<em class="ls">类</em>中的<code class="fe mw mx my mz b">__dict__</code>来查看类属性。它将打印出一堆其他的东西，其中一些我们稍后会回来看，但是现在，检查下面代码的输出并寻找两个<em class="ls">类变量</em> : <code class="fe mw mx my mz b">counter</code>和<code class="fe mw mx my mz b">__hidden_code</code>。</p><pre class="kg kh ki kj gt nc mz nd ne aw nf bi"><span id="76c6" class="ng ma iq mz b gy nh ni l nj nk"># printing out the class variables<br/>print('Properties of NumListB class:\n', NumListB.__dict__)</span><span id="bd24" class="ng ma iq mz b gy ok ni l nj nk">Properties of NumListB class:<br/> {'__module__': '__main__', 'counter': 2, '_NumListB__hidden_code': 999, '__init__': &lt;function NumListB.__init__ at 0x0000019447733490&gt;, 'add_value': &lt;function NumListB.add_value at 0x0000019447733520&gt;, 'remove_value': &lt;function NumListB.remove_value at 0x0000019447733010&gt;, 'get_list': &lt;function NumListB.get_list at 0x0000019447253C70&gt;, '__dict__': &lt;attribute '__dict__' of 'NumListB' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'NumListB' objects&gt;, '__doc__': None}</span></pre><p id="8e9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">姓名莽撞</strong></p><p id="55ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">🛑你有没有注意到私有<em class="ls">变量</em>的名字是如何被<code class="fe mw mx my mz b">__dict__</code>变量打印出来的？</p><p id="fac3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于这些私有变量不应该在对象外部可用，<em class="ls"> Python </em>破坏了使它们可用的操作，</p><ul class=""><li id="0497" class="nw nx iq ky b kz la lc ld lf ny lj nz ln oa lr ob oc od oe bi translated">将<em class="ls">类</em>名称放在<em class="ls">变量</em>名称之前</li><li id="b4b4" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated">在开头加上一个额外的下划线(<code class="fe mw mx my mz b">_</code>)。</li></ul><p id="4c92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，在输出中，您应该看到<em class="ls">实例变量</em> <code class="fe mw mx my mz b">__list</code>打印为<code class="fe mw mx my mz b">_NumListA__list</code>，而<em class="ls">类变量</em> <code class="fe mw mx my mz b">__hidden_code</code>打印为<code class="fe mw mx my mz b">_NumListB__hidden_code</code>。</p><blockquote class="ol"><p id="4a53" class="om on iq bd oo op oq or os ot ou lr dk translated"><em class="ov">这些</em>损坏的<em class="ov">名称可以用来直接访问这些私有</em>变量<em class="ov">。这显示了 Python 类的</em>私有<em class="ov">特征是如何受到限制的。</em></p></blockquote><pre class="pb pc pd pe pf nc mz nd ne aw nf bi"><span id="ef36" class="ng ma iq mz b gy nh ni l nj nk"># printing out private instance variable using mangled name<br/>print('Private instance variable __list from instace: nlA1 =', nlA1._NumListA__list)</span><span id="4f20" class="ng ma iq mz b gy ok ni l nj nk"># printing out privatge class variable using mangled name<br/>print('Private class variable from class NumListB = ', NumListB._NumListB__hidden_code)</span><span id="af3c" class="ng ma iq mz b gy ok ni l nj nk">Private instance variable __list from instace: nlA1 = [2]<br/>Private class variable from class NumListB =  999</span></pre><p id="9c6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">检查特定属性</strong></p><p id="e3e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe mw mx my mz b">__dict__</code>大概是探索的好办法。但是如果你需要检查某个<em class="ls">属性</em>或者<em class="ls">属性</em>是否存在于<em class="ls">类</em>或者<em class="ls">对象</em>中呢？</p><blockquote class="ol"><p id="26db" class="om on iq bd oo op oq or os ot ou lr dk translated"><em class="ov"> Python 函数</em> <code class="fe mw mx my mz b"><em class="ov">hasattr()</em></code> <em class="ov">可以用来检查一个特定的</em>属性<em class="ov">。</em></p></blockquote><p id="28ce" class="pw-post-body-paragraph kw kx iq ky b kz ow jr lb lc ox ju le lf oy lh li lj oz ll lm ln pa lp lq lr ij bi translated"><code class="fe mw mx my mz b">hasattr()</code>接受两个参数:被检查的对象，以及要作为字符串值搜索的属性的名称。如果属性存在，则返回<code class="fe mw mx my mz b">True</code>，否则返回<code class="fe mw mx my mz b">False</code>。</p><pre class="kg kh ki kj gt nc mz nd ne aw nf bi"><span id="a7e1" class="ng ma iq mz b gy nh ni l nj nk"># n1B1 instance properties<br/>print(hasattr(nlB1, '__list'))<br/>print(hasattr(nlB1, 'counter')) # class variable</span><span id="e566" class="ng ma iq mz b gy ok ni l nj nk"># NumListB class properties<br/>print(hasattr(NumListB, 'counter'))<br/>print(hasattr(NumListB, '__hidden_code'))</span><span id="2338" class="ng ma iq mz b gy ok ni l nj nk"># checking mangled names for the private attributes<br/>print(hasattr(nlB1, '_NumListB__list'))<br/>print(hasattr(NumListB, '_NumListB__hidden_code'))</span><span id="a12d" class="ng ma iq mz b gy ok ni l nj nk">False<br/>True<br/>True<br/>False<br/>True<br/>True</span></pre><p id="5858" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:</p><p id="75ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与<code class="fe mw mx my mz b">__dict__</code>不同，<code class="fe mw mx my mz b">hasattr()</code>可以从<em class="ls">对象</em>中检查<em class="ls">类变量</em>并返回<code class="fe mw mx my mz b">True</code>。</p><p id="3945" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">🛑 <em class="ls">私有属性</em>可以使用它们的错位名称进行搜索，否则它们将返回<code class="fe mw mx my mz b">False</code>。</p><h1 id="90a4" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">下一步是什么</h1><p id="73b3" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在本文中，我们详细介绍了不同类型的<em class="ls">变量</em>及其在 Python <em class="ls">类</em>上下文中的属性。我们了解到，</p><ul class=""><li id="7238" class="nw nx iq ky b kz la lc ld lf ny lj nz ln oa lr ob oc od oe bi translated">什么实例和类变量？</li><li id="0400" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated">如何检查对象和类的属性？</li><li id="1075" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated">如何访问公共和私有变量？</li></ul><p id="48c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下一篇文章中，我们将深入探讨一个<em class="ls">类</em>的<em class="ls">方法</em>。</p></div><div class="ab cl pg ph hu pi" role="separator"><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl"/></div><div class="ij ik il im in"><p id="6fde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你喜欢这篇文章，请查看 Python 中面向对象系列的前几篇:</p><div class="pn po gp gr pp pq"><a rel="noopener follow" target="_blank" href="/object-oriented-programming-in-python-what-and-why-d966e9e0fd03"><div class="pr ab fo"><div class="ps ab pt cl cj pu"><h2 class="bd ir gy z fp pv fr fs pw fu fw ip bi translated">Python 中的面向对象编程——什么和为什么？</h2><div class="px l"><h3 class="bd b gy z fp pv fr fs pw fu fw dk translated">学习 Python 中的面向对象编程。</h3></div><div class="py l"><p class="bd b dl z fp pv fr fs pw fu fw dk translated">towardsdatascience.com</p></div></div><div class="pz l"><div class="qa l qb qc qd pz qe kp pq"/></div></div></a></div><div class="pn po gp gr pp pq"><a rel="noopener follow" target="_blank" href="/oop-in-python-understanding-a-class-bcc088e595c6"><div class="pr ab fo"><div class="ps ab pt cl cj pu"><h2 class="bd ir gy z fp pv fr fs pw fu fw ip bi translated">Python 中的 OOP 理解一个类</h2><div class="px l"><h3 class="bd b gy z fp pv fr fs pw fu fw dk translated">理解 Python 类的基本组件。</h3></div><div class="py l"><p class="bd b dl z fp pv fr fs pw fu fw dk translated">towardsdatascience.com</p></div></div><div class="pz l"><div class="qf l qb qc qd pz qe kp pq"/></div></div></a></div><div class="pn po gp gr pp pq"><a href="https://curious-joe.medium.com/object-oriented-programming-in-python-inheritance-and-subclass-9c62ad027278" rel="noopener follow" target="_blank"><div class="pr ab fo"><div class="ps ab pt cl cj pu"><h2 class="bd ir gy z fp pv fr fs pw fu fw ip bi translated">Python 中的面向对象编程——继承和子类</h2><div class="px l"><h3 class="bd b gy z fp pv fr fs pw fu fw dk translated">理解继承的基本概念，并通过创建子类来应用它们。</h3></div><div class="py l"><p class="bd b dl z fp pv fr fs pw fu fw dk translated">curious-joe.medium.com</p></div></div><div class="pz l"><div class="qg l qb qc qd pz qe kp pq"/></div></div></a></div></div></div>    
</body>
</html>