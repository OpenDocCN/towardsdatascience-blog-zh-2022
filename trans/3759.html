<html>
<head>
<title>Seven Killer Memory Optimization Techniques Every Pandas User Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个熊猫用户都应该知道的七个黑仔内存优化技术</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/seven-killer-memory-optimization-techniques-every-pandas-user-should-know-64707348ab20#2022-08-22">https://towardsdatascience.com/seven-killer-memory-optimization-techniques-every-pandas-user-should-know-64707348ab20#2022-08-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c50c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">优化熊猫记忆利用的简单技巧</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4ac53257df88a31a8cfb3e4c559b29b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UnxbaQNZOBP0-B5H"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">丹尼斯·简斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="a3d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设计和构建现实世界中适用的机器学习模型一直是数据科学家的兴趣所在。这不可避免地导致他们大规模利用优化、高效和准确的方法。</p><p id="a5f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行时和内存级别的优化在可持续交付真实世界和面向用户的软件解决方案中扮演着基础角色。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/9aaf9bcf724274e73cdd0b505adf2e1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*fbOM78Ru_e0PPJ8i4CrV0A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">优化分类(按作者分类的图片)</p></figure><p id="ad84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我之前的一篇文章中，我介绍了一些顶级的运行时优化技术，您可以在常规的数据科学项目中使用这些技术。</p><div class="lt lu gp gr lv lw"><a rel="noopener follow" target="_blank" href="/five-killer-optimization-techniques-every-pandas-user-should-know-266662bd1163"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd ir gy z fp mb fr fs mc fu fw ip bi translated">每个熊猫用户应该知道的五个黑仔优化技术</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">数据分析运行时优化的一步</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">towardsdatascience.com</p></div></div><div class="mf l"><div class="mg l mh mi mj mf mk kp lw"/></div></div></a></div><p id="55d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我们将探索优化的另一个领域，我将向你介绍一些令人难以置信的技术来优化你的熊猫数据帧的<strong class="ky ir">内存使用</strong>。</p><p id="b8ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些提示将帮助您在Pandas中有效地执行典型的表格数据分析、管理和处理任务。</p><p id="9659" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了得到一个简要的概述，我将在这篇文章中讨论以下主题:</p><p id="0d5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="#fbf8" rel="noopener ugc nofollow"> <strong class="ky ir"> #1就地修改数据帧</strong></a><strong class="ky ir"><br/></strong><a class="ae kv" href="#314b" rel="noopener ugc nofollow"><strong class="ky ir"># 2只读CSV中必需的列</strong></a><strong class="ky ir"><br/></strong><a class="ae kv" href="#55a9" rel="noopener ugc nofollow"><strong class="ky ir"># 3-# 5更改列的数据类型</strong><strong class="ky ir"><br/></strong></a><a class="ae kv" href="#0760" rel="noopener ugc nofollow"><strong class="ky ir"># 6在读取CSV</strong></a><strong class="ky ir"><br/></strong></p><p id="f076" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们开始吧🚀！</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="fbf8" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">#1对数据帧进行就地修改</h1><p id="ad6a" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">一旦我们将数据帧加载到Python环境中，我们通常会对数据帧进行大范围的修改，不是吗？这些包括添加新列、重命名标题、删除列、改变行值、替换NaN值等等。</p><p id="cb4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些操作通常可以通过两种方式执行，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/d1766543ca51fc4c9e508df41d005b21.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/0*zVudpHz7dit2UKLg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">熊猫数据帧操作的分类(图片由作者提供)。</p></figure><p id="6dec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">标准赋值</strong>旨在转换后创建数据帧的新副本，保持原始数据帧不变。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/a6d97db5592727757301c3a0e6d58418.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wtmh1KAZnu4x7ocME7aWnQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从给定的数据帧创建新的数据帧(图片由作者提供)。</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="ac73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为标准分配的结果，两个不同的熊猫数据帧(原始的和转换的)在环境中共存(上面的<code class="fe nt nu nv nw b">df</code>和<code class="fe nt nu nv nw b">df_copy</code>),加倍了存储器利用率。</p><p id="520a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与标准赋值操作相反，<strong class="ky ir">就地赋值操作</strong>打算修改原始数据帧本身，而不创建新的Pandas数据帧对象。下面演示了这一点:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/36e59390f3b6d0d8ce18e2468f3adc14.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/1*I9h9LAeTs9oMwwml7T5e9Q.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">执行就地操作(Gif由作者提供)</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny ns l"/></div></figure><p id="2af0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果DataFrame的中间副本(<code class="fe nt nu nv nw b">df_copy</code>)在您的项目中没有用处，那么在内存受限的应用程序中，采用就地赋值的方法是最理想的方法。</p><p id="9e3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在下面阅读我关于就地分配操作的详细帖子:</p><div class="lt lu gp gr lv lw"><a rel="noopener follow" target="_blank" href="/a-simple-guide-to-inplace-operations-in-pandas-7a1d97ecce24"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd ir gy z fp mb fr fs mc fu fw ip bi translated">大熊猫就地手术简单指南</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">介绍熊猫的就地手术，探索普遍支持的方法和一个常见的误解</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">towardsdatascience.com</p></div></div><div class="mf l"><div class="nz l mh mi mj mf mk kp lw"/></div></div></a></div><h2 id="f227" class="oa mt iq bd mu ob oc dn my od oe dp nc lf of og ne lj oh oi ng ln oj ok ni ol bi translated">关键要点/最终想法:</h2><ol class=""><li id="2dc1" class="om on iq ky b kz nk lc nl lf oo lj op ln oq lr or os ot ou bi translated">当需要中间数据帧，并且不想改变输入时，使用标准赋值(或<code class="fe nt nu nv nw b">inplace=False</code>)。</li><li id="6661" class="om on iq ky b kz ov lc ow lf ox lj oy ln oz lr or os ot ou bi translated">如果您正在处理内存限制，并且不特别使用中间数据帧，请使用就地赋值(或<code class="fe nt nu nv nw b">inplace=True</code>)。</li></ol><h1 id="314b" class="ms mt iq bd mu mv pa mx my mz pb nb nc jw pc jx ne jz pd ka ng kc pe kd ni nj bi translated"># 2 CSV中的只读必填列</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/299857d7b162ce46aecaee4d4f999daf.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*ziuBbYBzMneTbAWnvcM3rw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">只阅读感兴趣的栏目(图片由作者提供)。注意:CSV文件是一个文本文件，上面的插图不是CSV的样子。这只是为了直观地阐述观点。</p></figure><p id="009c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设想一个场景，您的CSV文件中有数百列，其中只有一部分列是您感兴趣的。</p><p id="bdaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，考虑我使用<a class="ae kv" href="https://faker.readthedocs.io/en/master/" rel="noopener ugc nofollow" target="_blank"> Faker </a> ( <code class="fe nt nu nv nw b">filename</code> : <code class="fe nt nu nv nw b">dummy_dataset.csv</code>)创建的具有25列和10⁵行的虚拟数据帧的前五行:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pg"><img src="../Images/bb70f8c90b291d69dfb0df835b22155c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Z1AlRiJ1MBbSCym_my70pQ.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">虚拟数据集(作者提供的Gif)</p></figure><p id="169c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这25列中，假设只有5列是您最感兴趣的，并且您希望将它们作为Pandas数据框架加载。这些列是<code class="fe nt nu nv nw b">Employee_ID</code>、<code class="fe nt nu nv nw b">First_Name</code>、<code class="fe nt nu nv nw b">Salary</code>、<code class="fe nt nu nv nw b">Rating</code>和<code class="fe nt nu nv nw b">Company</code>。</p><ul class=""><li id="6144" class="om on iq ky b kz la lc ld lf ph lj pi ln pj lr pk os ot ou bi translated"><strong class="ky ir">加载所有列:</strong></li></ul><p id="b662" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您打算将整个CSV文件读入python环境，那么Pandas将被迫加载那些无用的列并推断它们的数据类型，从而导致运行时间和内存使用量的增加。</p><p id="4e56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用如下所示的<code class="fe nt nu nv nw b"><a class="ae kv" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.info.html" rel="noopener ugc nofollow" target="_blank">info()</a></code>方法找到熊猫数据帧的内存使用情况:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pl ns l"/></div></figure><p id="3b89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在加载了所有25列的情况下，数据帧在内存中拥有137 MBs的空间。加载CSV文件的运行时间计算如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pm ns l"/></div></figure><ul class=""><li id="0dd1" class="om on iq ky b kz la lc ld lf ph lj pi ln pj lr pk os ot ou bi translated"><strong class="ky ir">加载所需列:</strong></li></ul><p id="f93c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与读取所有列相反，如果只有您感兴趣的列的子集，您可以将它们作为列表传递给<code class="fe nt nu nv nw b"><a class="ae kv" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html" rel="noopener ugc nofollow" target="_blank">pd.read_csv()</a></code>方法的<code class="fe nt nu nv nw b">usecols</code>参数。</p><p id="a840" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">内存利用率的计算如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pn ns l"/></div></figure><p id="853e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仅加载感兴趣的列将内存利用率降低了近9倍，占用了大约15 MBs的空间，而不是之前的137 MBs。</p><p id="7dfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">加载运行时间也显著减少，与加载所有列相比，提升了近<strong class="ky ir"> 4倍</strong>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pm ns l"/></div></figure><h2 id="4c16" class="oa mt iq bd mu ob oc dn my od oe dp nc lf of og ne lj oh oi ng ln oj ok ni ol bi translated">关键要点/最终想法:</h2><ol class=""><li id="8cf4" class="om on iq ky b kz nk lc nl lf oo lj op ln oq lr or os ot ou bi translated">只加载所需的列可以显著提高运行时间和内存利用率。因此，在加载大型CSV文件之前，只加载几行(比如前五行)并列出感兴趣的列。</li></ol><h1 id="55a9" class="ms mt iq bd mu mv pa mx my mz pb nb nc jw pc jx ne jz pd ka ng kc pe kd ni nj bi translated"># 3–5改变列的数据类型</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi po"><img src="../Images/8e557a49ff99416920fc0f2f32459e29.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*lnMw--ze1-VGwLQPuWTpLQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">熊猫的数据类型转换(图片由作者提供)</p></figure><p id="7747" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认情况下，Pandas总是将最高的内存数据类型分配给列。例如，如果Pandas将一个列解释为整数值，则可能有四个子类别(有符号)可供选择:</p><ul class=""><li id="50bf" class="om on iq ky b kz la lc ld lf ph lj pi ln pj lr pk os ot ou bi translated"><code class="fe nt nu nv nw b">int8</code> : 8位整数，包含来自【2⁷].-2⁷】的整数</li><li id="7bf9" class="om on iq ky b kz ov lc ow lf ox lj oy ln oz lr pk os ot ou bi translated"><code class="fe nt nu nv nw b">int16</code> : 16位整数，包含[-2 ⁵，2 ⁵].]中的整数</li><li id="1d85" class="om on iq ky b kz ov lc ow lf ox lj oy ln oz lr pk os ot ou bi translated"><code class="fe nt nu nv nw b">int32</code> : 32位整数，涵盖[-2，2 ]中的整数。</li><li id="0570" class="om on iq ky b kz ov lc ow lf ox lj oy ln oz lr pk os ot ou bi translated"><code class="fe nt nu nv nw b">int64</code> : 64位整数，包含来自【2⁶-2⁶】的整数。</li></ul><p id="0bac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，Pandas总是将<code class="fe nt nu nv nw b">int64</code>指定为整数值列的数据类型，而不管列中当前值的范围。</p><p id="7177" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">浮点数值也有类似的含义:<code class="fe nt nu nv nw b">float16</code>、<code class="fe nt nu nv nw b">float32</code>和<code class="fe nt nu nv nw b">float64</code>。</p><blockquote class="pp pq pr"><p id="de7f" class="kw kx ps ky b kz la jr lb lc ld ju le pt lg lh li pu lk ll lm pv lo lp lq lr ij bi translated"><strong class="ky ir">注意</strong>:我将引用我们在上一节中讨论的同一个虚拟数据集。下面，我再次提到了数据类型。</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pl ns l"/></div></figure><p id="9d4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据帧的当前内存利用率为<strong class="ky ir"> 137 MBs </strong>。</p><ul class=""><li id="9bd5" class="om on iq ky b kz la lc ld lf ph lj pi ln pj lr pk os ot ou bi translated"><strong class="ky ir">改变整数列(#3)的数据类型</strong></li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/afaca1471c6c13dc863df7caec5e92cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*hYGmu8_lTX7NZHCjETt_Ew.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">降级整数数据类型(图片由作者提供)</p></figure><p id="20b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们考虑一下<code class="fe nt nu nv nw b">Employee_ID</code>列，求它的最大值和最小值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="px ns l"/></div></figure><p id="4982" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，即使该列可能被解释为<code class="fe nt nu nv nw b">int32</code> (2 ⁵ &lt; 10⁵ &lt; 2)，熊猫仍然采用<code class="fe nt nu nv nw b">int64</code>类型作为列。</p><p id="8212" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，Pandas提供了使用<code class="fe nt nu nv nw b"><a class="ae kv" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.astype.html" rel="noopener ugc nofollow" target="_blank">astype()</a></code>方法改变列数据类型的灵活性。</p><p id="8f1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面演示了<code class="fe nt nu nv nw b">Employee_ID</code>列的转换，以及转换前后的内存使用情况:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="py ns l"/></div></figure><p id="4fae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这个简单的单行数据类型转换，<code class="fe nt nu nv nw b">Employee_ID</code>列使用的总内存减半。</p><p id="f28b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过类似的最小-最大分析，还可以改变其他整型和浮点型列的数据类型。</p><ul class=""><li id="7f5c" class="om on iq ky b kz la lc ld lf ph lj pi ln pj lr pk os ot ou bi translated"><strong class="ky ir">改变代表分类数据的列的数据类型(#4) </strong></li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/291ddd0b3750e95837cc832aafed4ce8.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*-3tPlq1jckMCgsOnshkeHQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">转换为分类列(作者图片)</p></figure><p id="813c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顾名思义，分类列是只包含几个唯一值的列，这些值在整个列中反复出现。</p><p id="b49d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，让我们使用如下所示的<code class="fe nt nu nv nw b"><a class="ae kv" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.nunique.html" rel="noopener ugc nofollow" target="_blank">nunique()</a></code>方法找出几列中唯一值的数量:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="qa ns l"/></div></figure><p id="e8f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些列中唯一值相对于数据帧大小的数量表明它们是分类列。</p><p id="605b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，默认情况下，Pandas将所有这些列的数据类型推断为<code class="fe nt nu nv nw b">object</code>，这实际上是一个<code class="fe nt nu nv nw b">string</code>类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="qb ns l"/></div></figure><p id="56dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe nt nu nv nw b">astype()</code>方法，您可以将分类列的数据类型更改为<code class="fe nt nu nv nw b">category</code>。内存利用率的降低如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="py ns l"/></div></figure><p id="6a52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着从字符串到分类的转换，我们注意到内存利用率下降了<strong class="ky ir"> 75% </strong>，这是一个巨大的下降。</p><p id="d506" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过类似的唯一元素分析，您可以改变其他潜在分类列的数据类型。</p><ul class=""><li id="c310" class="om on iq ky b kz la lc ld lf ph lj pi ln pj lr pk os ot ou bi translated"><strong class="ky ir">改变具有NaN值(#5)的列的数据类型</strong></li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/e95cc01f525c82d41fed732d0b9ae81f.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*sDOxVD1MO17TSKACD-IhQw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将各种数据类型转换为稀疏类型(图片由作者提供)</p></figure><p id="b05b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在现实世界的数据集中，缺失值是不可避免的，不是吗？假设数据帧中的一列有很大比例的NaN值，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="px ns l"/></div></figure><p id="a802" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，将列表示为一个备用数据结构<a class="ae kv" href="https://pandas.pydata.org/pandas-docs/dev/user_guide/sparse.html#" rel="noopener ugc nofollow" target="_blank"/>(在接下来的文章中会详细介绍)可以提供显著的内存效率。</p><p id="9bb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe nt nu nv nw b">astype()</code>方法，您可以将稀疏列的数据类型更改为<code class="fe nt nu nv nw b">Sparse[str]</code> / <code class="fe nt nu nv nw b">Sparse[float]</code> / <code class="fe nt nu nv nw b">Sparse[int]</code>数据类型。内存利用率的降低和数据类型的转换如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="py ns l"/></div></figure><p id="4df1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从<code class="fe nt nu nv nw b">float32</code>到<code class="fe nt nu nv nw b">Sparse[float32]</code>的转换减少了近40%的内存使用，这大约是<code class="fe nt nu nv nw b">Rating</code>列中NaN值的百分比。</p><h2 id="2cb8" class="oa mt iq bd mu ob oc dn my od oe dp nc lf of og ne lj oh oi ng ln oj ok ni ol bi translated">关键要点/最终想法:</h2><ol class=""><li id="4326" class="om on iq ky b kz nk lc nl lf oo lj op ln oq lr or os ot ou bi translated">Pandas总是用最大的内存数据类型来解释它的列。如果列中的值范围没有跨越数据类型的范围，请考虑将列的数据类型降级为最佳类型。</li></ol><p id="e81e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在<a class="ae kv" href="https://stackoverflow.com/a/57531404" rel="noopener ugc nofollow" target="_blank">这个StackOverflow答案</a>中找到执行这些数据类型转换的参考代码。</p><h1 id="0760" class="ms mt iq bd mu mv pa mx my mz pb nb nc jw pc jx ne jz pd ka ng kc pe kd ni nj bi translated">#6在读取CSV时指定列数据类型</h1><p id="6cc5" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">上面<a class="ae kv" href="#55a9" rel="noopener ugc nofollow"> <strong class="ky ir"> #3-#5 </strong> </a>小节中讨论的技巧假设您已经在python环境中加载了一个熊猫数据帧。换句话说，这些是优化内存利用的<strong class="ky ir">后输入</strong>技术。</p><p id="6f22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，在加载数据集是主要挑战的情况下，您可以控制Pandas在输入期间执行的数据类型解释任务，并指定您希望您的列被推断为的特定数据类型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qd"><img src="../Images/7d0c4287dbe20761e41a4484b7c53610.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z9EtOhcZua0Vos_W-h-0mQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">为熊猫提供数据类型说明(图片由作者提供)。注意:CSV文件是一个文本文件，上面的插图不是CSV的样子。这只是为了直观地阐述观点。</p></figure><p id="766f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以通过将<code class="fe nt nu nv nw b">dtype</code>参数传递给<code class="fe nt nu nv nw b">pd.read_csv()</code>方法来实现这一点，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="qe ns l"/></div></figure><p id="9b3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上所示，<code class="fe nt nu nv nw b">dtype</code>参数期望从<code class="fe nt nu nv nw b">column-name</code>到<code class="fe nt nu nv nw b">data-type</code>的字典映射。</p><h2 id="a663" class="oa mt iq bd mu ob oc dn my od oe dp nc lf of og ne lj oh oi ng ln oj ok ni ol bi translated">关键要点/最终想法:</h2><ol class=""><li id="8e52" class="om on iq ky b kz nk lc nl lf oo lj op ln oq lr or os ot ou bi translated">如果您通过数据字典或其他来源知道CSV的某些(或所有)列中的数据类型，尝试自己推断最合适的数据类型，并将其传递给<code class="fe nt nu nv nw b">pd.read_csv()</code>方法的<code class="fe nt nu nv nw b">dtype</code>参数。</li></ol><h1 id="524b" class="ms mt iq bd mu mv pa mx my mz pb nb nc jw pc jx ne jz pd ka ng kc pe kd ni nj bi translated">#7从CSV中读取数据块</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qf"><img src="../Images/ad164df9269c95916a0e51c5ba1d46cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*r2ZbLXf_zUALfavvm3SZvw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">分块读取文件(图片由作者提供)。注意:CSV文件是一个文本文件，上面的插图不是CSV的样子。这只是为了直观地阐述观点。</p></figure><p id="f826" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，假设您已经在<a class="ae kv" href="#0760" rel="noopener ugc nofollow">提示#6 </a>中做了所有可能做的事情，但是由于内存限制，CSV仍然无法加载。</p><p id="d7b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然我的最后一项技术无助于优化净内存利用率，但它更适合加载大型数据集，您可以在这种极端情况下使用。</p><p id="0f6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">熊猫的输入法是连载的。因此，它从CSV文件中一次只读取一行(或一行)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qg"><img src="../Images/7807389737122af4d9d5e2a259c40f3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/0*L6Mr0_qLbNYw8T4M.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一次读取一行(作者Gif)。注意:CSV文件是一个文本文件，上面的插图不是CSV的样子。这只是为了直观地阐述观点。</p></figure><p id="e5dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果行数非常大，无法一次加载到内存中，您可以加载一段(或一大块)行，对其进行处理，然后读取CSV文件的下一段。下面演示了这一点:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qh"><img src="../Images/59a8ceb3757cbf27d75ae772b6e9a0c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*bquxd1uAdemSbOMVkSWu2Q.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在熊猫里分块处理数据(作者Gif)。注意:CSV文件是一个文本文件，上面的插图不是CSV的样子。这只是为了直观地阐述观点。</p></figure><p id="fd84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以通过将<code class="fe nt nu nv nw b">chunksize</code>参数传递给<code class="fe nt nu nv nw b">pd.read_csv()</code>方法来利用上述基于块的输入过程，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="qi ns l"/></div></figure><p id="71d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个<code class="fe nt nu nv nw b">chunk</code>对象都是一个熊猫数据帧，我们可以使用Python中的<code class="fe nt nu nv nw b">type()</code>方法来验证这一点，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="qj ns l"/></div></figure><h2 id="b56a" class="oa mt iq bd mu ob oc dn my od oe dp nc lf of og ne lj oh oi ng ln oj ok ni ol bi translated">关键要点/最终想法:</h2><ol class=""><li id="0afd" class="om on iq ky b kz nk lc nl lf oo lj op ln oq lr or os ot ou bi translated">如果CSV文件太大，无法加载到内存中，请使用分块方法加载CSV的片段并逐个处理它们。</li><li id="901f" class="om on iq ky b kz ov lc ow lf ox lj oy ln oz lr or os ot ou bi translated">这种方法的一个主要缺点是不能执行需要整个数据帧的操作。例如，假设您想要在一列上执行一个<code class="fe nt nu nv nw b">groupby()</code>操作。这里，对应于一个组的行可能位于不同的块中。</li></ol></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="1720" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">结论</h1><p id="b7f0" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">总之，在这篇文章中，我讨论了Pandas中的七种令人难以置信的内存优化技术，你可以在下一个数据科学项目中直接利用它们。</p><p id="028d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我看来，我在这篇文章中讨论的领域是优化内存利用率的微妙方法，在寻求优化时经常被忽略。尽管如此，我希望这篇文章能让你深刻理解这些熊猫的日常功能。</p><p id="5bfb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="8553" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://subscribepage.io/450q" rel="noopener ugc nofollow" target="_blank"> 🧑‍💻<strong class="ky ir">成为数据科学专家！获取包含450多个熊猫、NumPy和SQL问题的免费数据科学掌握工具包。</strong> </a></p><p id="2a22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">✉️ <a class="ae kv" href="https://medium.com/subscribe/@avi_chawla" rel="noopener"> <strong class="ky ir">注册我的电子邮件列表</strong> </a>永远不要错过另一篇关于数据科学指南、技巧和提示、机器学习、SQL、Python等的文章。Medium会将我的下一篇文章直接发送到你的收件箱。</p></div></div>    
</body>
</html>