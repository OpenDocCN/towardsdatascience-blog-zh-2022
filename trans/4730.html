<html>
<head>
<title>Nine Rules for Creating Procedural Macros in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Rust中创建程序宏的九条规则</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/nine-rules-for-creating-procedural-macros-in-rust-595aa476a7ff#2022-10-21">https://towardsdatascience.com/nine-rules-for-creating-procedural-macros-in-rust-595aa476a7ff#2022-10-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8bf8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">来自<code class="fe kf kg kh ki b">anyinput</code>的实践经验，这是一个新的宏，可以轻松接受类似字符串/路径/迭代器/数组的输入</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/7f703d8efde1a7f097ac7ed0fc58be93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zXrh79vYois9fO05RoXt0g.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">锈蟹编程本身——来源:<a class="ae kz" href="https://openai.com/dall-e-2/" rel="noopener ugc nofollow" target="_blank">https://openai.com/dall-e-2/</a></p></figure><blockquote class="la lb lc"><p id="68c8" class="ld le lf lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">更新:你可以看到这篇文章的YouTube <a class="ae kz" href="https://www.youtube.com/watch?v=DMLBBZBlKis" rel="noopener ugc nofollow" target="_blank">版本。我出席了拉斯特林茨聚会。</a></p></blockquote><p id="1d10" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">我喜欢Rust编程语言，但它并不完美。例如，您知道如何编写一个Rust函数，它接受任何类似字符串的东西作为输入吗？接受任何类型路径的迭代器<em class="lf">怎么样？你能写一个接受一个<code class="fe kf kg kh ki b">Vec&lt;f32&gt;</code>作为<code class="fe kf kg kh ki b">ndarray::ArrayView1</code>的函数吗？</em></p><p id="6105" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">Rust函数<em class="lf">可以</em>接受所有这些输入，但是我发现语法很难记忆和阅读。因此，我创建了<code class="fe kf kg kh ki b">anyinput</code>宏来为我和其他Rust程序员记住复杂的语法。(参见https://crates.io/crates/anyinput的<a class="ae kz" href="https://crates.io/crates/anyinput" rel="noopener ugc nofollow" target="_blank">。)</a></p><p id="b259" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">在创建<code class="fe kf kg kh ki b">anyinput</code>的时候，我学到了九条规则，可以帮助你在Rust中轻松创建程序宏。规则是:</p><ol class=""><li id="b2ff" class="md me iq lg b lh li lk ll ma mf mb mg mc mh lz mi mj mk ml bi translated">使用Rust workspace和<code class="fe kf kg kh ki b">proc_macro2</code>在普通(非宏)项目中开发、调试和单元测试您的宏。</li><li id="92d0" class="md me iq lg b lh mm lk mn ma mo mb mp mc mq lz mi mj mk ml bi translated">使用<code class="fe kf kg kh ki b">syn</code>、<code class="fe kf kg kh ki b">proc_macro2</code>和<code class="fe kf kg kh ki b">quote</code>在文字代码、标记、语法树和字符串之间自由转换。</li><li id="9966" class="md me iq lg b lh mm lk mn ma mo mb mp mc mq lz mi mj mk ml bi translated">创建易于调试的单元测试，报告宏所做的和预期的任何差异。</li><li id="c895" class="md me iq lg b lh mm lk mn ma mo mb mp mc mq lz mi mj mk ml bi translated">使用<a class="ae kz" href="https://astexplorer.net/" rel="noopener ugc nofollow" target="_blank"> AST Explorer </a>和<code class="fe kf kg kh ki b"><a class="ae kz" href="https://docs.rs/syn/latest/syn/" rel="noopener ugc nofollow" target="_blank">syn</a></code>T26】文档来理解Rust语法树。使用Rust的模式匹配和结构/枚举访问来解构语法树。</li><li id="03c7" class="md me iq lg b lh mm lk mn ma mo mb mp mc mq lz mi mj mk ml bi translated">用<code class="fe kf kg kh ki b">parse_quote!</code>和Rust的结构更新语法构建语法树。</li><li id="0671" class="md me iq lg b lh mm lk mn ma mo mb mp mc mq lz mi mj mk ml bi translated">使用<code class="fe kf kg kh ki b">syn</code>的Fold特性递归地遍历、析构和构造语法树。</li><li id="ee81" class="md me iq lg b lh mm lk mn ma mo mb mp mc mq lz mi mj mk ml bi translated">使用<code class="fe kf kg kh ki b">proc_macro_error</code>返回人体工程学和可测试的错误。</li><li id="d0b7" class="md me iq lg b lh mm lk mn ma mo mb mp mc mq lz mi mj mk ml bi translated">创建集成测试。包括基于<code class="fe kf kg kh ki b">trybuild</code>的UI测试。</li><li id="f518" class="md me iq lg b lh mm lk mn ma mo mb mp mc mq lz mi mj mk ml bi translated">遵循优雅的Rust API设计的规则，特别是，吃你自己的狗粮，使用Clippy，写好文档。</li></ol></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><p id="4b99" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">Rust强大的<a class="ae kz" href="https://doc.rust-lang.org/reference/macros.html" rel="noopener ugc nofollow" target="_blank">宏系统</a>让我们用Rust写Rust。系统提供两种宏。对于第一种，您使用<code class="fe kf kg kh ki b">macro_rules!</code>宏来声明一个新宏。一般很简单。可悲的是，<code class="fe kf kg kh ki b">macro_rules!</code>不能做我想做的事。对于第二种类型的程序性宏，您可以获得更大的能力，因为您是在Rust中编程的。</p><p id="6ef2" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">过程宏有三种类型:</p><ul class=""><li id="e04a" class="md me iq lg b lh li lk ll ma mf mb mg mc mh lz my mj mk ml bi translated"><a class="ae kz" href="https://doc.rust-lang.org/reference/procedural-macros.html#function-like-procedural-macros" rel="noopener ugc nofollow" target="_blank">类似功能的宏</a>——<code class="fe kf kg kh ki b">custom!(…)</code></li><li id="825c" class="md me iq lg b lh mm lk mn ma mo mb mp mc mq lz my mj mk ml bi translated"><a class="ae kz" href="https://doc.rust-lang.org/reference/procedural-macros.html#derive-macros" rel="noopener ugc nofollow" target="_blank">派生宏</a> — <code class="fe kf kg kh ki b">#[derive(CustomDerive)]</code></li><li id="0bf5" class="md me iq lg b lh mm lk mn ma mo mb mp mc mq lz my mj mk ml bi translated"><a class="ae kz" href="https://doc.rust-lang.org/reference/procedural-macros.html#attribute-macros" rel="noopener ugc nofollow" target="_blank">属性宏</a>——<code class="fe kf kg kh ki b">#[CustomAttribute]</code></li></ul><p id="d8bb" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">我的宏，<strong class="lg ir"> </strong> <code class="fe kf kg kh ki b">anyinput</code> <strong class="lg ir">，</strong>是属性宏，但是这些规则适用于所有三种口味。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><p id="33a9" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">下面是一个使用中的<code class="fe kf kg kh ki b">anyinput</code>宏的简单例子:</p><blockquote class="la lb lc"><p id="2ccb" class="ld le lf lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">任务:创建一个函数，将<code class="fe kf kg kh ki b">2</code>加到任何类似字符串的东西的长度上。</p></blockquote><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="e37f" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">下一个例子表明<code class="fe kf kg kh ki b">anyinput</code>支持多输入和嵌套。</p><blockquote class="la lb lc"><p id="15d2" class="ld le lf lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">任务:创建一个有两个输入的函数。一个输入接受任何类似迭代器的东西<code class="fe kf kg kh ki b">usize</code>。第二个输入接受任何类似迭代器的东西或类似字符串的东西。该函数返回数字和字符串长度之和。将该函数应用于范围<code class="fe kf kg kh ki b">1..=10</code>和<code class="fe kf kg kh ki b">&amp;str</code>的一部分。</p></blockquote><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="952b" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">这两个例子使用了<code class="fe kf kg kh ki b">AnyString</code>和<code class="fe kf kg kh ki b">AnyIter</code>。宏也理解<code class="fe kf kg kh ki b">AnyPath</code>、<code class="fe kf kg kh ki b">AnyArray</code>和(可选)<code class="fe kf kg kh ki b">AnyNdArray</code>。</p><p id="c590" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">如何将<code class="fe kf kg kh ki b">anyinput</code>宏应用到用户函数中？在幕后，它用适当的Rust泛型重写了函数。它还向函数中添加了一些行，以便有效地从任何顶级泛型转换为具体类型。具体来说，在第一个示例中，它将<code class="fe kf kg kh ki b">len_plus_2</code>函数重写为:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="98c7" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">这里的<code class="fe kf kg kh ki b">AnyString0</code>是一个通用类型。生产线<code class="fe kf kg kh ki b">let s = s.as_ref();</code>将<code class="fe kf kg kh ki b">s</code>从通用型<code class="fe kf kg kh ki b">AnyString0</code>转换为具体型<code class="fe kf kg kh ki b">&amp;str</code>。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><p id="eac0" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">创建程序宏需要许多决策。根据我对<code class="fe kf kg kh ki b">anyinput</code>的经验，以下是我推荐的决定。为了避免含糊不清，我将把这些建议表述为规则。</p><h2 id="dd54" class="nb nc iq bd nd ne nf dn ng nh ni dp nj ma nk nl nm mb nn no np mc nq nr ns nt bi translated">规则1:使用Rust workspace和proc_macro2在普通(非宏)项目中开发、调试和单元测试您的宏</h2><p id="8160" class="pw-post-body-paragraph ld le iq lg b lh nu jr lj lk nv ju lm ma nw lp lq mb nx lt lu mc ny lx ly lz ij bi translated">如果我们设置得恰到好处，我们可以像常规Rust项目一样开发和调试宏的核心代码。比如我用<a class="ae kz" href="https://code.visualstudio.com/docs/languages/rust" rel="noopener ugc nofollow" target="_blank"> VS代码设置为Rust </a>。使用我的核心代码，我可以设置交互式断点，一行一行地单步执行代码，<a class="ae kz" href="https://marketplace.visualstudio.com/items?itemName=swellaby.vscode-rust-test-adapter" rel="noopener ugc nofollow" target="_blank">运行单元测试</a>等等。</p><p id="3951" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">Rust宏至少需要两个项目(顶级和派生)。我们将添加第三个项目，称为核心，以使开发更容易。</p><p id="a93a" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated"><strong class="lg ir">重要提示:在项目或文件名中任何地方看到“anyinput ”,请用您的项目替换<em class="lf">的名称。</em></strong></p><p id="2e7e" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">下表总结了您应该如何布置文件:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="c561" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">接下来，让我们详细了解一下文件布局。</p><p id="46fe" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated"><strong class="lg ir">顶层项目:</strong>使用Rust常用的<code class="fe kf kg kh ki b"><a class="ae kz" href="https://doc.rust-lang.org/cargo/guide/creating-a-new-project.html" rel="noopener ugc nofollow" target="_blank">cargo new anyinput --lib</a></code>命令创建顶层文件。<strong class="lg ir">(记住:用你的项目名称替换<em class="lf"> anyinput </em>。)</strong>打开新创建的顶层<code class="fe kf kg kh ki b"><a class="ae kz" href="https://github.com/CarlKCarlK/anyinput/blob/9rules/Cargo.toml" rel="noopener ugc nofollow" target="_blank">Cargo.toml</a> </code>并将这些行添加到文件的底部:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="0933" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated"><code class="fe kf kg kh ki b">[workspace]</code>部分定义了三项目<a class="ae kz" href="https://doc.rust-lang.org/cargo/reference/workspaces.html" rel="noopener ugc nofollow" target="_blank">生锈工作空间</a>。我们的<code class="fe kf kg kh ki b">[dev-dependencies]</code>包含<code class="fe kf kg kh ki b">trybuild</code>，一个我们将用于集成测试的依赖项(规则8)。我们的<code class="fe kf kg kh ki b">[dependencies]</code>只包含当前版本的<code class="fe kf kg kh ki b">anyinput-derive</code>，以及<code class="fe kf kg kh ki b">"anyinput-derive"</code>的<a class="ae kz" href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-path-dependencies" rel="noopener ugc nofollow" target="_blank">路径</a>。</p><p id="fc91" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">如果你看我的<code class="fe kf kg kh ki b"><a class="ae kz" href="https://github.com/CarlKCarlK/anyinput/blob/9rules/src/lib.rs" rel="noopener ugc nofollow" target="_blank">src/lib.rs</a></code>文件，你会看到它主要包含文档。唯一关键的一行是:</p><pre class="kk kl km kn gt nz ki oa ob aw oc bi"><span id="f806" class="nb nc iq ki b gy od oe l of og">pub use anyinput_derive::anyinput;</span></pre><p id="83a5" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">这使得宏<code class="fe kf kg kh ki b">anyinput::anyinput</code>通过<a class="ae kz" href="https://doc.rust-lang.org/reference/items/use-declarations.html#use-visibility" rel="noopener ugc nofollow" target="_blank">重新导出</a> <code class="fe kf kg kh ki b">anyinput_derive::anyinput</code>可见。我们现在将定义<code class="fe kf kg kh ki b">anyinput_derive::anyinput</code>。</p><p id="68c4" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">顶层的<code class="fe kf kg kh ki b"><a class="ae kz" href="https://github.com/CarlKCarlK/anyinput/blob/9rules/README.md" rel="noopener ugc nofollow" target="_blank">README.md</a></code>文件包含项目的主要文档。</p><p id="565e" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">当我们谈到规则#8时，我们将讨论顶层的<code class="fe kf kg kh ki b">tests</code>文件夹。</p><p id="d44c" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated"><strong class="lg ir">衍生项目:</strong>使用命令<code class="fe kf kg kh ki b"><a class="ae kz" href="https://doc.rust-lang.org/cargo/guide/creating-a-new-project.html" rel="noopener ugc nofollow" target="_blank">cargo new anyinput-derive --lib</a></code>在顶层文件夹中创建衍生文件。将这些行添加到<code class="fe kf kg kh ki b"><a class="ae kz" href="https://github.com/CarlKCarlK/anyinput/blob/9rules/anyinput-derive/Cargo.toml" rel="noopener ugc nofollow" target="_blank">anyinput-derive/Cargo.toml</a></code>的底部:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="b465" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated"><code class="fe kf kg kh ki b">[lib]</code>部分将<code class="fe kf kg kh ki b">anyinput-derive</code>定义为程序宏项目。<code class="fe kf kg kh ki b">[dependencies]</code>部分首先引入了我们尚未创建的<code class="fe kf kg kh ki b">anyinput-core</code>项目，以及它的当前版本和本地路径。它还引入了两个重要的外部板条箱(将在规则#2和#7中讨论)。</p><p id="27f1" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">文件<code class="fe kf kg kh ki b"><a class="ae kz" href="https://github.com/CarlKCarlK/anyinput/blob/9rules/anyinput-derive/README.md" rel="noopener ugc nofollow" target="_blank">anyinput-derive/README.md</a></code>真的是一个“<em class="lf">别读我的</em>”文件。字面意思是，“你可能正在寻找<code class="fe kf kg kh ki b"><a class="ae kz" href="https://docs.rs/anyinput/" rel="noopener ugc nofollow" target="_blank">anyinput</a></code>板条箱，它包裹着这个板条箱，使用起来更符合人体工程学。”</p><p id="4d22" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">我的<code class="fe kf kg kh ki b"><a class="ae kz" href="http://anyinput-derive/src/lib.rs" rel="noopener ugc nofollow" target="_blank">anyinput-derive/src/lib.rs</a></code>文件正好包含11行:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="33d8" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">下面是这些行的作用:</p><ul class=""><li id="0227" class="md me iq lg b lh li lk ll ma mf mb mg mc mh lz my mj mk ml bi translated">他们拉进了“<em class="lf">别读我的</em>”<a class="ae kz" href="https://blog.guillaume-gomez.fr/articles/2021-08-03+Improvements+for+%23%5Bdoc%5D+attributes+in+Rust" rel="noopener ugc nofollow" target="_blank">文件作为文档</a>。</li><li id="59ff" class="md me iq lg b lh mm lk mn ma mo mb mp mc mq lz my mj mk ml bi translated">他们从<code class="fe kf kg kh ki b">anyinput_core</code>项目中导入了<code class="fe kf kg kh ki b">anyinput_core</code>函数。</li><li id="a3f9" class="md me iq lg b lh mm lk mn ma mo mb mp mc mq lz my mj mk ml bi translated">他们使用<code class="fe kf kg kh ki b">#[proc_macro_attribute]</code>通过函数<code class="fe kf kg kh ki b">anyinput</code>定义一个宏。与所有属性宏函数一样，该函数接受两个<code class="fe kf kg kh ki b">TokenStream</code>输入并返回一个<code class="fe kf kg kh ki b">TokenStream</code>。(如果您希望创建类似函数的宏或派生宏，函数签名会略有不同。详见<a class="ae kz" href="https://doc.rust-lang.org/reference/procedural-macros.html#function-like-procedural-macros" rel="noopener ugc nofollow" target="_blank">程序宏-生锈参考</a>。)</li><li id="d824" class="md me iq lg b lh mm lk mn ma mo mb mp mc mq lz my mj mk ml bi translated">这些行根据<code class="fe kf kg kh ki b">anyinput_core</code>功能定义了<code class="fe kf kg kh ki b">anyinput</code>功能。<code class="fe kf kg kh ki b">.into()</code>方法在名为<code class="fe kf kg kh ki b">TokenStream</code>的类型的两个版本之间进行转换。</li><li id="ac49" class="md me iq lg b lh mm lk mn ma mo mb mp mc mq lz my mj mk ml bi translated">他们使用<code class="fe kf kg kh ki b">#[proc_macro_error]</code>来捕捉<code class="fe kf kg kh ki b">abort!</code>并返回人体工程学错误。详情见规则7。</li></ul><p id="8825" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated"><strong class="lg ir">核心项目:</strong>使用命令<code class="fe kf kg kh ki b"><a class="ae kz" href="https://doc.rust-lang.org/cargo/guide/creating-a-new-project.html" rel="noopener ugc nofollow" target="_blank">cargo new anyinput-core --lib</a></code>从顶层文件夹中创建核心项目。将这些行添加到<code class="fe kf kg kh ki b"><a class="ae kz" href="https://github.com/CarlKCarlK/anyinput/blob/9rules/anyinput-core/Cargo.toml" rel="noopener ugc nofollow" target="_blank">anyinput-core/Cargo.toml</a></code>的底部:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="b645" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">文件<code class="fe kf kg kh ki b"><a class="ae kz" href="https://github.com/CarlKCarlK/anyinput/blob/9rules/anyinput-core/README.md" rel="noopener ugc nofollow" target="_blank">anyinput-core/README.md</a></code>是另一个“<em class="lf">不要读我的内容</em>”文件，它将用户引向顶层项目。</p><p id="35a0" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">文件<code class="fe kf kg kh ki b"><a class="ae kz" href="https://github.com/CarlKCarlK/anyinput/blob/9rules/anyinput-core/src/tests.rs" rel="noopener ugc nofollow" target="_blank">anyinput-core/src/tests.rs</a></code>包含单元测试。我们将在规则3中讨论这个问题。</p><p id="02dd" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">文件<code class="fe kf kg kh ki b"><a class="ae kz" href="https://github.com/CarlKCarlK/anyinput/blob/9rules/anyinput-core/src/lib.rs" rel="noopener ugc nofollow" target="_blank">anyinput-core/src/lib.rs</a></code>将最终包含宏的大部分代码。现在，从以下内容开始:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="49ee" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">后面的规则将详细说明这些行的作用。大意是<code class="fe kf kg kh ki b">anyinput_core</code>叫<code class="fe kf kg kh ki b">transform_fn</code>。目前，<code class="fe kf kg kh ki b">transform_fn</code>函数将任何用户功能转换为“Hello World”功能。</p><p id="a85a" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">文件<code class="fe kf kg kh ki b"><a class="ae kz" href="https://github.com/CarlKCarlK/anyinput/blob/9rules/anyinput-core/src/tests.rs" rel="noopener ugc nofollow" target="_blank">anyinput-core/src/tests.rs</a></code>将最终包含所有的单元测试。(在规则#3中讨论)。目前，它包含:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="bdea" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">这几行创建了一个单元测试，测试宏是否将用户的<code class="fe kf kg kh ki b">hello_universe</code>函数变成了<code class="fe kf kg kh ki b">hello_world</code>函数。您可以通过运行<code class="fe kf kg kh ki b">cargo test first</code>从anyinput-core目录测试它。(你也可以在<a class="ae kz" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=6d64dc79a156255e45c9541be8e5be96" rel="noopener ugc nofollow" target="_blank"> Rust Playground </a>上运行这个版本。)</p><p id="8b1e" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">因为<code class="fe kf kg kh ki b">anyinput-core</code>是一个普通(非宏)Rust包，你可以用你的普通Rust工具开发它的代码。例如，如果您的代码编辑器支持交互式调试，您可以设置断点和/或单步执行代码。</p><p id="679b" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">当然，<code class="fe kf kg kh ki b">anyinput</code>宏不应该把用户的函数变成<code class="fe kf kg kh ki b">hello_world</code>函数。相反，它应该重写用户函数以接受任何字符串、路径等。为此，我们必须了解如何在文字代码、标记、语法树和字符串之间进行转换。这是第二条规则的主题。</p><h2 id="04b2" class="nb nc iq bd nd ne nf dn ng nh ni dp nj ma nk nl nm mb nn no np mc nq nr ns nt bi translated">规则2:使用<code class="fe kf kg kh ki b">syn</code>、<code class="fe kf kg kh ki b">proc_macro2</code>和<code class="fe kf kg kh ki b">quote</code>在文字代码、标记、语法树和字符串之间自由转换。</h2><p id="6ab4" class="pw-post-body-paragraph ld le iq lg b lh nu jr lj lk nv ju lm ma nw lp lq mb nx lt lu mc ny lx ly lz ij bi translated">通过允许我们使用语法树，<code class="fe kf kg kh ki b"><a class="ae kz" href="https://docs.rs/syn/latest/syn/" rel="noopener ugc nofollow" target="_blank">syn</a></code>、<code class="fe kf kg kh ki b"><a class="ae kz" href="https://docs.rs/proc-macro2/latest/proc_macro2/" rel="noopener ugc nofollow" target="_blank">proc_macro2</a></code>和<code class="fe kf kg kh ki b"><a class="ae kz" href="https://docs.rs/quote/latest/quote/" rel="noopener ugc nofollow" target="_blank">quote</a></code>箱使得创建过程宏更加容易。</p><p id="958a" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">例如，使用三个板条箱，您可以将对<code class="fe kf kg kh ki b">transform_fn</code>的输入打印为一个字符串。这对调试很有用。</p><p id="b0a6" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">首先，我们添加两个临时的<code class="fe kf kg kh ki b">println!</code>语句。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="aee6" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">然后，从<code class="fe kf kg kh ki b">anyinput-core</code>文件夹中，我们运行<code class="fe kf kg kh ki b">cargo test first -- --nocapture</code>。(你也可以在<a class="ae kz" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=6d64dc79a156255e45c9541be8e5be96" rel="noopener ugc nofollow" target="_blank"> Rust Playground </a>上运行这个版本。)最后，我们看到:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="2d8f" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">要利用这三个板条箱，您必须了解以下项目以及如何在它们之间转换。</p><ul class=""><li id="de03" class="md me iq lg b lh li lk ll ma mf mb mg mc mh lz my mj mk ml bi translated">文字代码—这是文件中的代码。例如:</li></ul><pre class="kk kl km kn gt nz ki oa ob aw oc bi"><span id="c133" class="nb nc iq ki b gy od oe l of og">fn hello_universe() {<br/>    println!("Hello, universe!");<br/>}</span></pre><ul class=""><li id="918d" class="md me iq lg b lh li lk ll ma mf mb mg mc mh lz my mj mk ml bi translated"><code class="fe kf kg kh ki b"><a class="ae kz" href="https://docs.rs/proc-macro2/latest/proc_macro2/struct.TokenStream.html" rel="noopener ugc nofollow" target="_blank">TokenStream</a></code> <a class="ae kz" href="https://docs.rs/proc-macro2/latest/proc_macro2/struct.TokenStream.html" rel="noopener ugc nofollow" target="_blank"> </a> —这代表一个抽象的令牌流。Rust编译器通过首先将用户的文字代码转换成<code class="fe kf kg kh ki b">TokenStream</code>来应用宏。编译器接下来将那个<code class="fe kf kg kh ki b">TokenStream </code>提供给宏进行处理。最后，宏返回一个编译器编译的新的<code class="fe kf kg kh ki b">TokenStream </code>。</li><li id="3762" class="md me iq lg b lh mm lk mn ma mo mb mp mc mq lz my mj mk ml bi translated">语法树—这是表示已分析代码的嵌套Rust结构和枚举。结构和枚举在板条箱<code class="fe kf kg kh ki b"><a class="ae kz" href="https://docs.rs/syn/latest/syn/" rel="noopener ugc nofollow" target="_blank">syn</a></code>中定义。例如，<code class="fe kf kg kh ki b"><a class="ae kz" href="https://docs.rs/syn/latest/syn/struct.ItemFn.html" rel="noopener ugc nofollow" target="_blank">ItemFn</a></code>是表示独立函数的结构。<code class="fe kf kg kh ki b"><a class="ae kz" href="https://docs.rs/syn/latest/syn/struct.ItemFn.html" rel="noopener ugc nofollow" target="_blank">ItemFn</a></code>的四个场之一<code class="fe kf kg kh ki b">block</code>包含<code class="fe kf kg kh ki b"><a class="ae kz" href="https://docs.rs/syn/latest/syn/enum.Stmt.html" rel="noopener ugc nofollow" target="_blank">Stmt</a></code>的矢量。枚举<code class="fe kf kg kh ki b"><a class="ae kz" href="https://docs.rs/syn/latest/syn/enum.Stmt.html" rel="noopener ugc nofollow" target="_blank">Stmt</a> </code>表示Rust语句。(规则4告诉我们如何了解<code class="fe kf kg kh ki b">syn</code>定义的结构和枚举。)</li><li id="ccab" class="md me iq lg b lh mm lk mn ma mo mb mp mc mq lz my mj mk ml bi translated">代码、语法和标记的字符串——我们可以将前面的项转换成字符串。此外，我们可以将字符串转换为前面的项目。</li></ul><p id="8c98" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">此表总结了如何从其他类型转换成您想要的类型。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">换算表</p></figure><blockquote class="la lb lc"><p id="bcbb" class="ld le lf lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">旁白:一套新的Rust宏的想法:一套更统一地进行这些转换的宏</p></blockquote><p id="8eb1" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">接下来，让我们看看演示这些转换的示例代码。(您也可以在<a class="ae kz" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=7ae7d8fd405a2af5afc60ef3de9b2dad" rel="noopener ugc nofollow" target="_blank">防锈操场</a>运行该示例代码。)</p><p id="47c1" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated"><strong class="lg ir">令牌的文字代码、语法和代码串</strong></p><p id="7c45" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">如果您有文字代码，请使用<code class="fe kf kg kh ki b">quote!</code>、<code class="fe kf kg kh ki b">parse_quote!</code>和<code class="fe kf kg kh ki b">stringify!</code>分别将其转换为<code class="fe kf kg kh ki b">TokenStream</code>、语法树或代码串。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="c7d5" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">注意，<code class="fe kf kg kh ki b">parse_quote!</code>必须看到一个<code class="fe kf kg kh ki b">syn</code>类型，这里是<code class="fe kf kg kh ki b">ItemFn</code>结构。这告诉它要解析成什么。同样，回想一下Rust让我们用任何类型的括号调用类似函数的宏:<code class="fe kf kg kh ki b">!(</code> … <code class="fe kf kg kh ki b">)</code>、<code class="fe kf kg kh ki b">![</code> … <code class="fe kf kg kh ki b">]</code>或<code class="fe kf kg kh ki b">!{</code> … <code class="fe kf kg kh ki b">}</code>。和差不多。</p><p id="2c1c" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated"><strong class="lg ir">令牌到代码串&amp;令牌串</strong></p><p id="03dd" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">了解a <code class="fe kf kg kh ki b">TokenStream </code>代表什么代码通常很有用。使用<code class="fe kf kg kh ki b">.to_string()</code>。您可能还对令牌本身的字符串表示感兴趣。如果是，使用<code class="fe kf kg kh ki b">format!("{:?}",…)</code>。使用<code class="fe kf kg kh ki b">format!("{:#?}",…)</code>来美化打印，即将新的行和制表符添加到令牌串中。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="69e1" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated"><strong class="lg ir">代码串的语法树&amp;语法串</strong></p><p id="78a9" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">了解语法树代表什么代码通常很有用。使用<code class="fe kf kg kh ki b">quote!(#syntax).to_string()</code>。将语法树本身看作一个字符串通常也是有用的。使用<code class="fe kf kg kh ki b">format!("{:?}",syntax)</code>。使用<code class="fe kf kg kh ki b">format!("{:#?}",syntax)</code>向语法字符串添加新的行和制表符。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="a99d" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated"><strong class="lg ir">令牌↔语法</strong></p><p id="7986" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">要将令牌流转换成语法树，请使用<code class="fe kf kg kh ki b">parse2</code>。注意<code class="fe kf kg kh ki b">parse2</code>需要解析的<code class="fe kf kg kh ki b">syn</code>类型(这里是<code class="fe kf kg kh ki b">ItemFn</code>)。另外，请注意<code class="fe kf kg kh ki b">parse2</code>可能会返回一个错误结果。我们将在规则7中看到如何处理错误。</p><p id="0d1d" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">要将语法树转换成<code class="fe kf kg kh ki b">TokenStream</code>，请使用<code class="fe kf kg kh ki b">quote!(#syntax)</code>。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="f404" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated"><strong class="lg ir">语法树或令牌的代码串</strong></p><p id="71ee" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">要将代码串转换成语法树或<code class="fe kf kg kh ki b">TokenStream</code>，请使用<code class="fe kf kg kh ki b">parse_str</code>。它需要一个<code class="fe kf kg kh ki b">syn</code>类型或<code class="fe kf kg kh ki b">TokenStream</code>，这样它就知道要解析成什么。它可以返回一个错误结果。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="46b6" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated"><strong class="lg ir">符号串和语法串的文字代码</strong></p><p id="85a3" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">最后，为了将文字代码转换成一串标记，我们首先转换成一个<code class="fe kf kg kh ki b">TokenStream </code>，然后再将其转换成一个字符串。将文字代码转换为语法字符串需要三个步骤:转换为标记、转换为语法树(可能会有错误结果)、转换为字符串。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="3c27" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">了解了如何在这些感兴趣的项目之间进行转换之后，我们接下来继续单元测试。</p><h2 id="7cd7" class="nb nc iq bd nd ne nf dn ng nh ni dp nj ma nk nl nm mb nn no np mc nq nr ns nt bi translated">规则3:创建易于调试的单元测试，报告宏所做的和你所期望的之间的任何差异</h2><blockquote class="la lb lc"><p id="8a86" class="ld le lf lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">旁白:<a class="ae kz" href="https://doc.rust-lang.org/book/ch11-03-test-organization.html" rel="noopener ugc nofollow" target="_blank"> Rust Book推荐</a>将单元测试放在你的<code class="fe kf kg kh ki b">lib.rs</code>中。我更喜欢把它们放在<code class="fe kf kg kh ki b">tests.rs</code>档案里。两种设置都可以。</p></blockquote><p id="7147" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">按照规则#1，我们的单元测试存在于标准(非宏)Rust项目中，可以用标准Rust工具运行和调试。但是那些单元测试应该采取什么形式呢？</p><p id="fe50" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">我推荐这样的测试</p><ul class=""><li id="f51c" class="md me iq lg b lh li lk ll ma mf mb mg mc mh lz my mj mk ml bi translated">指定用户的文字代码。这是进入宏的代码之前的<em class="lf">。</em></li><li id="349d" class="md me iq lg b lh mm lk mn ma mo mb mp mc mq lz my mj mk ml bi translated">在宏应用后指定预期的文字代码<em class="lf">。</em></li><li id="74de" class="md me iq lg b lh mm lk mn ma mo mb mp mc mq lz my mj mk ml bi translated">应用宏，然后检查<em class="lf">预期</em>是否等于之后的<em class="lf">。如果<em class="lf">预期</em>与</em>后的<em class="lf">不同，显示差异。</em></li><li id="1625" class="md me iq lg b lh mm lk mn ma mo mb mp mc mq lz my mj mk ml bi translated">最后，如果可能的话，运行预期代码的副本。</li></ul><p id="13b8" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">下面是一个简单的单元测试。可以看到它期望宏重写用户函数<code class="fe kf kg kh ki b">any_str_len</code>。它还检查预期的<code class="fe kf kg kh ki b">any_str_len</code>代码实际上返回了一个字符串的长度。(你可以在<a class="ae kz" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=dee4d37e3413104844fe3127d9a5698b" rel="noopener ugc nofollow" target="_blank"> Rust Playground </a>上运行这个，看测试失败。)</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="b71b" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">当我们运行它时会发生什么？它失败了！</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi oh"><img src="../Images/17b91da8b3a669dfad41438c7768a136.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VaH_9aX2dAb7XvcQKOUUaQ.png"/></div></div></figure><p id="3b41" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">为什么？在<a class="ae kz" href="https://code.visualstudio.com/docs/languages/rust" rel="noopener ugc nofollow" target="_blank"> VS代码</a>中，我在单元测试中设置了一个断点，然后单步执行代码。我看到<code class="fe kf kg kh ki b">anyinput_core</code>函数调用了<code class="fe kf kg kh ki b">transform_fn</code>。然后，我看到当前版本的<code class="fe kf kg kh ki b">transform_fn</code>将所有用户函数转换成了一个<code class="fe kf kg kh ki b">hello_world</code>函数。</p><p id="b81c" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">测试的输出还显示了预期的和之后的<em class="lf">之间的差异。单元测试调用的助手函数<code class="fe kf kg kh ki b">assert_tokens_eq</code>报告了差异。助手功能是:</em></p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="fca6" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">这是一个简单的单元测试。我们的下一步是创建更多的单元测试来测试我们还没有编写的宏。对于<code class="fe kf kg kh ki b">anyinput</code>宏，这些单元测试包括处理带有两个输入的用户函数、带有路径和数组的输入、嵌套输入等。</p><p id="421b" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">有了一些单元测试，我们接下来想开始写我们的宏。这需要创造一个更好的<code class="fe kf kg kh ki b">transform_fn</code>。然而，这需要理解Rust语法树，这就引出了规则4。</p><blockquote class="la lb lc"><p id="3d0d" class="ld le lf lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">旁白:<code class="fe kf kg kh ki b">anyinput </code>宏通过<code class="fe kf kg kh ki b">transform_fn</code>(<code class="fe kf kg kh ki b"><a class="ae kz" href="https://github.com/CarlKCarlK/anyinput/blob/9rules/anyinput-core/src/lib.rs" rel="noopener ugc nofollow" target="_blank"><em class="iq">anyinput-core/src/lib.rs</em></a></code><em class="iq">中的一个函数)转换用户的<em class="iq">函数</em>。</em>例如，如果您的宏转换了用户的<em class="iq">结构</em>，您可以将<code class="fe kf kg kh ki b"><em class="iq">transform_fn</em></code> <em class="iq">更改为</em> <code class="fe kf kg kh ki b">transform_struct</code>。</p></blockquote><h2 id="47ad" class="nb nc iq bd nd ne nf dn ng nh ni dp nj ma nk nl nm mb nn no np mc nq nr ns nt bi translated">规则4:使用<a class="ae kz" href="https://astexplorer.net/" rel="noopener ugc nofollow" target="_blank"> AST Explorer </a>和<code class="fe kf kg kh ki b"><a class="ae kz" href="https://docs.rs/syn/latest/syn/" rel="noopener ugc nofollow" target="_blank">syn</a></code>T20】文档来理解Rust语法树。具有Rust模式匹配和结构/枚举访问的析构语法树</h2><p id="316e" class="pw-post-body-paragraph ld le iq lg b lh nu jr lj lk nv ju lm ma nw lp lq mb nx lt lu mc ny lx ly lz ij bi translated">我们可以使用在线工具<a class="ae kz" href="https://astexplorer.net/" rel="noopener ugc nofollow" target="_blank"> AST Explorer </a>来查看由我们的简单测试用例<code class="fe kf kg kh ki b">any_str_len</code>创建的语法树。</p><blockquote class="la lb lc"><p id="8f9b" class="ld le lf lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">旁白:一定要将AST Explorer的语言设置为Rust。我一开始没有意识到这一点，最终创建了自己的在线小工具<a class="ae kz" href="https://carlkcarlk.github.io/rust-ast-explorer/" rel="noopener ugc nofollow" target="_blank"> Rust AST Explorer </a>。</p></blockquote><p id="fa0d" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">如果将版本之前的<em class="lf">粘贴到AST Explorer中，它会报告:</em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/6ea76eddd20673e8e4488abb977a2491.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*FP3q07Hf4ZzFDLUrUOosQw.png"/></div></figure><p id="5d30" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">我们猜测<code class="fe kf kg kh ki b">ItemFn</code>代表用户的功能。<code class="fe kf kg kh ki b">ItemFn</code>似乎是一个四字段结构。我们通过搜索 <code class="fe kf kg kh ki b"><a class="ae kz" href="https://docs.rs/syn/latest/syn/struct.ItemFn.html" rel="noopener ugc nofollow" target="_blank">ItemFn</a></code>的<code class="fe kf kg kh ki b"><a class="ae kz" href="https://docs.rs/syn/latest/syn/struct.ItemFn.html" rel="noopener ugc nofollow" target="_blank">syn</a></code> <a class="ae kz" href="https://docs.rs/syn/latest/syn/struct.ItemFn.html" rel="noopener ugc nofollow" target="_blank">板条箱文件来确认这一点。</a></p><p id="cc9e" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">下面是一个使用这些信息的例子。<code class="fe kf kg kh ki b">anyinput</code>宏经常需要在用户函数的where子句中添加条目。因此，宏需要一个已经在where子句中的初始项目列表。使用AST Explorer、<code class="fe kf kg kh ki b">syn</code>文档和标准的Rust模式匹配，我得到了:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7648" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">关于标准Rust模式匹配和析构技术的概述，参见<a class="ae kz" href="https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#destructuring-nested-structs-and-enums" rel="noopener ugc nofollow" target="_blank">析构嵌套结构和枚举。</a></p><p id="f601" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">我们现在可以从输入语法树中提取信息。我们接下来看一下在输出语法树中添加信息。</p><h2 id="17e9" class="nb nc iq bd nd ne nf dn ng nh ni dp nj ma nk nl nm mb nn no np mc nq nr ns nt bi translated">规则5:用<code class="fe kf kg kh ki b">parse_quote!</code>和Rust的结构更新语法构建语法树</h2><p id="6525" class="pw-post-body-paragraph ld le iq lg b lh nu jr lj lk nv ju lm ma nw lp lq mb nx lt lu mc ny lx ly lz ij bi translated">Rust通常不允许我们编辑结构或枚举的一部分。相反，我们创建一个新的结构或枚举，也许是基于旧结构或枚举的信息。<code class="fe kf kg kh ki b">syn</code> crate的<code class="fe kf kg kh ki b"><a class="ae kz" href="https://docs.rs/syn/latest/syn/macro.parse_quote.html" rel="noopener ugc nofollow" target="_blank">parse_quote!</a></code>宏是一种简单(也有点有趣)的方式。它将文字代码与语法树结合起来创建新的语法树。</p><p id="7000" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">下面是来自<code class="fe kf kg kh ki b">anyinput</code>宏的一个例子。这段代码生成一个要添加到用户函数中的语句。例如，在某些情况下，它会将语句<code class="fe kf kg kh ki b">let s = s.as_ref();</code>添加到用户函数中。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="5454" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">我还使用<code class="fe kf kg kh ki b">parse_quote!</code>来创建一些语法，比如一个左尖括号和一个空的<code class="fe kf kg kh ki b">WherePredicate</code>列表。(可在<a class="ae kz" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=a4c4d4274589609e7998ac60862ce2a3" rel="noopener ugc nofollow" target="_blank">铁锈操场</a>运行。)</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="75d1" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated"><code class="fe kf kg kh ki b">parse_quote!</code>宏对于构建新的语法来说是很棒的，但是如果你想改变现有的语法呢？为此，我推荐Rust的标准<a class="ae kz" href="https://www.reddit.com/r/rust/comments/pchp8h/media_struct_update_syntax_in_rust/" rel="noopener ugc nofollow" target="_blank">结构更新语法</a>。</p><p id="e0cb" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">这里有一个来自<code class="fe kf kg kh ki b">anyinput</code>宏的例子。它用字段<code class="fe kf kg kh ki b">sig </code>和<code class="fe kf kg kh ki b">block</code>的新值创建了一个<code class="fe kf kg kh ki b">ItemFn </code>结构，但在其他方面与<code class="fe kf kg kh ki b">old_fn</code>相同。同样，新的<code class="fe kf kg kh ki b"><a class="ae kz" href="https://docs.rs/syn/latest/syn/struct.Signature.html" rel="noopener ugc nofollow" target="_blank">Signature </a></code> <a class="ae kz" href="https://docs.rs/syn/latest/syn/struct.Signature.html" rel="noopener ugc nofollow" target="_blank">结构</a>包含字段<code class="fe kf kg kh ki b">generics </code>和<code class="fe kf kg kh ki b">inputs</code>的新值，但在其他方面与<code class="fe kf kg kh ki b">old_fn’s</code> <code class="fe kf kg kh ki b">sig</code>相同。为什么不直接指定每个字段？嗯，<code class="fe kf kg kh ki b">Signature </code>结构包含11个字段，所以更新语法更加简洁。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="29d1" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">我们现在知道如何使用标准的Rust方法(加上<code class="fe kf kg kh ki b">parse_quote!</code>)来处理语法树。然而，有时我们想要更强大的东西。规则#6展示了如何通过利用语法树固有的递归和嵌套来转换语法树。</p><h2 id="a9ec" class="nb nc iq bd nd ne nf dn ng nh ni dp nj ma nk nl nm mb nn no np mc nq nr ns nt bi translated">规则6:使用<code class="fe kf kg kh ki b">syn</code>的Fold特性递归地遍历、析构和构造语法树</h2><p id="3fc4" class="pw-post-body-paragraph ld le iq lg b lh nu jr lj lk nv ju lm ma nw lp lq mb nx lt lu mc ny lx ly lz ij bi translated"><code class="fe kf kg kh ki b">anyinput</code>宏必须处理用户函数的输入，例如:</p><ul class=""><li id="c880" class="md me iq lg b lh li lk ll ma mf mb mg mc mh lz my mj mk ml bi translated"><code class="fe kf kg kh ki b">s: AnyString</code></li><li id="d94d" class="md me iq lg b lh mm lk mn ma mo mb mp mc mq lz my mj mk ml bi translated"><code class="fe kf kg kh ki b">v: Vec&lt;AnyPath&gt;</code></li><li id="53aa" class="md me iq lg b lh mm lk mn ma mo mb mp mc mq lz my mj mk ml bi translated"><code class="fe kf kg kh ki b">a: AnyArray&lt;AnyPath&gt;</code></li><li id="79fa" class="md me iq lg b lh mm lk mn ma mo mb mp mc mq lz my mj mk ml bi translated"><code class="fe kf kg kh ki b">yikes: AnyIter&lt;Vec&lt;AnyArray&lt;AnyPath&gt;&gt;&gt;</code></li></ul><p id="e05b" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">这样的嵌套强烈建议我们应该使用递归。<code class="fe kf kg kh ki b">syn</code>机箱通过其<code class="fe kf kg kh ki b"><a class="ae kz" href="https://docs.rs/syn/latest/syn/fold/index.html" rel="noopener ugc nofollow" target="_blank">Fold</a></code> <a class="ae kz" href="https://docs.rs/syn/latest/syn/fold/index.html" rel="noopener ugc nofollow" target="_blank">特征</a>实现了这种递归。这里有一个例子。</p><p id="79f3" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">假设我们想要一个计算函数中语句数量的宏。这比听起来要难，因为——通过使用花括号——Rust语句可以包含子语句。同样，假设宏应该用打印“hello universe”的语句替换任何包含“galaxy”的语句。(你可以在<a class="ae kz" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=acce21f0c87ce66cb90c4cf12103e247" rel="noopener ugc nofollow" target="_blank"> Rust Playground </a>运行这个例子。)</p><p id="b8a3" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">我们首先创建自己的结构。它保存了我们在处理用户语法树时需要的任何信息:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="8204" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">接下来，我们为我们希望检查或重写的类型定义一个<code class="fe kf kg kh ki b">Fold</code>实现。在这种情况下，我们希望访问每个<code class="fe kf kg kh ki b">Stmt</code>，因此:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="13c2" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated"><code class="fe kf kg kh ki b">Fold</code>支持<a class="ae kz" href="https://docs.rs/syn/latest/syn/fold/index.html#functions" rel="noopener ugc nofollow" target="_blank"> 187种类型</a>，但是我们只实现感兴趣的类型，这里只实现一种。其他的自动接收默认实现。</p><p id="befe" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">你可能会对<code class="fe kf kg kh ki b">let stmt_middle = syn::fold::fold_stmt(self, stmt_old);</code>线感到疑惑。这很重要。如果我们希望访问当前正在访问的语句中的语句和其他类型<em class="lf">,这是必需的。</em></p><p id="81c1" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">这里是一个完整的<code class="fe kf kg kh ki b">fold_stmt</code>实现。注意，我们返回一个<code class="fe kf kg kh ki b">Stmt</code>(可能是转换后的)。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="e424" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">也许令人惊讶的是，我们不直接调用我们的<code class="fe kf kg kh ki b">fold_stmt</code>实现。相反，我们调用<code class="fe kf kg kh ki b">fold_item_fn</code>，因为在这个例子中，<code class="fe kf kg kh ki b">ItemFn</code>是我们从用户那里得到的输入类型。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="e917" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">运行<code class="fe kf kg kh ki b">count_statements</code>递归地对语句进行计数，并用“hello universe”替换“hello galaxy”:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="fc77" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">我们现在有了为完美用户编写宏所需的所有工具。但是如果我们的用户有时会犯错误呢？这是规则7的主题。</p><h2 id="166e" class="nb nc iq bd nd ne nf dn ng nh ni dp nj ma nk nl nm mb nn no np mc nq nr ns nt bi translated">规则7:使用<code class="fe kf kg kh ki b">proc_macro_error</code>返回人机工程学和可测试的错误</h2><p id="c3a4" class="pw-post-body-paragraph ld le iq lg b lh nu jr lj lk nv ju lm ma nw lp lq mb nx lt lu mc ny lx ly lz ij bi translated"><code class="fe kf kg kh ki b">anyinput</code>宏支持嵌套输入，如<code class="fe kf kg kh ki b">AnyIter&lt;AnyString&gt;</code>。如果用户使用圆括号而不是尖括号会发生什么？理想情况下，他们会收到一条指出确切错误位置的消息:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="9c3e" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">然而，困难是存在的。即，</p><ul class=""><li id="cf31" class="md me iq lg b lh li lk ll ma mf mb mg mc mh lz my mj mk ml bi translated">Rust宏不使用标准Rust错误<code class="fe kf kg kh ki b"><a class="ae kz" href="https://doc.rust-lang.org/std/result/" rel="noopener ugc nofollow" target="_blank">results</a></code>。</li><li id="5e7e" class="md me iq lg b lh mm lk mn ma mo mb mp mc mq lz my mj mk ml bi translated">标准的<code class="fe kf kg kh ki b">panic!</code>宏可以工作，但是它只返回错误消息，不返回错误位置。</li><li id="afdc" class="md me iq lg b lh mm lk mn ma mo mb mp mc mq lz my mj mk ml bi translated">做我们想做的事，但它只在夜间进行。</li><li id="f0e6" class="md me iq lg b lh mm lk mn ma mo mb mp mc mq lz my mj mk ml bi translated"><code class="fe kf kg kh ki b"><a class="ae kz" href="https://doc.rust-lang.org/std/macro.compile_error.html" rel="noopener ugc nofollow" target="_blank">std::compile_error</a></code>也做我们想做的但只能用在顶层宏功能中。所以，它没有帮助，例如，当我们在一个<code class="fe kf kg kh ki b">Fold</code>遍历中发现一个用户错误几十层时。(规则#6描述了<code class="fe kf kg kh ki b">Fold</code>遍历)。</li></ul><p id="501a" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated"><code class="fe kf kg kh ki b"><a class="ae kz" href="https://docs.rs/proc-macro-error/latest/proc_macro_error/" rel="noopener ugc nofollow" target="_blank">proc_macro_error</a></code>机箱解决了这些问题(以一点开销为代价)。它还为未来的验证提供了夜间兼容性。</p><p id="7487" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">下面是如何设置它。首先，将<code class="fe kf kg kh ki b">#[proc_macro_attribute]</code>应用到<code class="fe kf kg kh ki b"><a class="ae kz" href="https://github.com/CarlKCarlK/anyinput/blob/9rules/anyinput-derive/src/lib.rs" rel="noopener ugc nofollow" target="_blank">anyinput-derive/src/lib.rs</a></code>中的宏函数。(有关详细信息，请参见规则1。)</p><p id="9a96" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">当你在你的核心代码(<code class="fe kf kg kh ki b"><a class="ae kz" href="https://github.com/CarlKCarlK/anyinput/blob/9rules/anyinput-core/src/lib.rs" rel="noopener ugc nofollow" target="_blank">anyinput-core/src/lib.rs</a></code>)中发现一个用户错误时，调用<code class="fe kf kg kh ki b">abort!</code>宏。例如，这段代码检查三个用户错误。找到一个就调用<code class="fe kf kg kh ki b">abort!</code>。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="aaf6" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">除了第一个参数告诉错误的位置之外，<code class="fe kf kg kh ki b">abort!</code>宏的工作方式与标准<code class="fe kf kg kh ki b">panic!</code>宏一样。该参数可以是来自用户代码的语法树。或者，它可以是从语法树中提取的<code class="fe kf kg kh ki b">SpanRange</code>或<code class="fe kf kg kh ki b">TokenStream</code>，例如:</p><pre class="kk kl km kn gt nz ki oa ob aw oc bi"><span id="3b2a" class="nb nc iq ki b gy od oe l of og">let span_range = SpanRange::from_tokens(&amp;type_path_old);</span></pre><p id="e8f6" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">您的单元测试应该执行这种错误处理。下面是对“圆括号代替尖括号”错误的单元测试。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="a36f" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">您会注意到它使用了标准的<code class="fe kf kg kh ki b"><a class="ae kz" href="https://doc.rust-lang.org/reference/attributes/testing.html#the-should_panic-attribute" rel="noopener ugc nofollow" target="_blank">should_panic</a></code>测试属性。然而，单元测试寻找的信息是奇怪的。这是单元测试所能做到的最好的。然而，下一个规则显示了集成测试如何检查错误消息的文本。</p><h2 id="477d" class="nb nc iq bd nd ne nf dn ng nh ni dp nj ma nk nl nm mb nn no np mc nq nr ns nt bi translated">规则#8创建集成测试。包含基于<code class="fe kf kg kh ki b">trybuild</code>的UI测试</h2><p id="d886" class="pw-post-body-paragraph ld le iq lg b lh nu jr lj lk nv ju lm ma nw lp lq mb nx lt lu mc ny lx ly lz ij bi translated">集成测试将您的宏应用到实际代码中！他们住在<code class="fe kf kg kh ki b"><a class="ae kz" href="https://github.com/CarlKCarlK/anyinput/blob/9rules/tests/integration_test.rs" rel="noopener ugc nofollow" target="_blank">tests/integration_test.rs</a></code>。我的第一个集成测试是:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="6485" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">如果您按照规则#1设置您的项目，那么您可以使用<code class="fe kf kg kh ki b">cargo test</code>从顶层文件夹运行这个测试。Rust系统会自动编译所有级别的工作空间，以便进行测试和调试。</p><p id="48c3" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">如果你想运行所有的集成测试<em class="lf">和</em>所有的单元测试呢？使用<code class="fe kf kg kh ki b">cargo test --workspace</code>命令。如果您想交互式地运行代码，该怎么办？使用为Rust 设置的<a class="ae kz" href="https://code.visualstudio.com/docs/languages/rust" rel="noopener ugc nofollow" target="_blank"> VS代码，我可以在集成测试中的<code class="fe kf kg kh ki b">s.len()</code>上设置断点，并单步执行宏应用后的代码。</a></p><p id="9bd4" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">我们的测试还有一个漏洞——我们还没有完全测试我们的错误处理。(在规则#7中描述)。通过在集成测试中添加<code class="fe kf kg kh ki b"><a class="ae kz" href="https://crates.io/crates/trybuild" rel="noopener ugc nofollow" target="_blank">trybuild</a></code> UI测试来填补这个漏洞。添加它的步骤是:</p><ul class=""><li id="747f" class="md me iq lg b lh li lk ll ma mf mb mg mc mh lz my mj mk ml bi translated">创建包含使用宏的用户代码的文件。下面是“圆括号代替尖括号”的UI测试。它位于文件<code class="fe kf kg kh ki b"><a class="ae kz" href="https://github.com/CarlKCarlK/anyinput/blob/9rules/tests/ui/anyiter_paren.rs" rel="noopener ugc nofollow" target="_blank">tests/ui/anyiter_paren.rs</a></code>中:</li></ul><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="2fcf" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">在<code class="fe kf kg kh ki b"><a class="ae kz" href="https://github.com/CarlKCarlK/anyinput/blob/9rules/tests/integration_test.rs" rel="noopener ugc nofollow" target="_blank">tests/integration_test.rs</a></code>中添加集成测试<code class="fe kf kg kh ki b">ui</code>:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="2d0c" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">用<code class="fe kf kg kh ki b">cargo test ui</code>从顶层文件夹运行这些UI集成测试。第一次运行这个测试时，它会失败，但也会创建文件<code class="fe kf kg kh ki b">wip/<a class="ae kz" href="https://github.com/CarlKCarlK/anyinput/blob/9rules/tests/ui/anyiter_paren.rs" rel="noopener ugc nofollow" target="_blank">anyiter_paren</a>.stderr</code>。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="d61c" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">看看<code class="fe kf kg kh ki b"><a class="ae kz" href="https://github.com/CarlKCarlK/anyinput/blob/9rules/tests/ui/anyiter_paren.rs" rel="noopener ugc nofollow" target="_blank">anyiter_paren</a>.stderr</code>。如果您确定它包含正确的输出，将其移至<code class="fe kf kg kh ki b"><a class="ae kz" href="https://github.com/CarlKCarlK/anyinput/blob/9rules/tests/ui/anyiter_paren.stderr" rel="noopener ugc nofollow" target="_blank">tests/ui/anyiter_paren.stderr</a></code>。下一次运行测试时，他们将会得到这样的输出。关于(重新)生成预期输出文件的更多细节，参见<code class="fe kf kg kh ki b"><a class="ae kz" href="https://crates.io/crates/trybuild" rel="noopener ugc nofollow" target="_blank">trybuild</a></code>文档。</p><p id="a385" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">您的宏经过全面测试后，您可以考虑使用它并共享它。规则9讨论了如何让它准备好共享。</p><h2 id="a444" class="nb nc iq bd nd ne nf dn ng nh ni dp nj ma nk nl nm mb nn no np mc nq nr ns nt bi translated">规则9:遵循优雅的Rust API设计规则，特别是，吃你自己的狗粮，使用Clippy，写好文档</h2><p id="906a" class="pw-post-body-paragraph ld le iq lg b lh nu jr lj lk nv ju lm ma nw lp lq mb nx lt lu mc ny lx ly lz ij bi translated">前面的规则描述了宏的编码，但是您应该如何设计您的宏呢？我建议你遵循优雅的Rust库API的九条规则，尤其是这三条:</p><p id="b3f4" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated"><strong class="lg ir">使用夹子— </strong>用<a class="ae kz" href="https://github.com/rust-lang/rust-clippy" rel="noopener ugc nofollow" target="_blank">防锈夹子</a>涂抹严格的林挺。</p><p id="45e5" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated"><strong class="lg ir">写好文档以保持设计的诚实</strong> —生成文档并在浏览器中弹出的命令是<code class="fe kf kg kh ki b">cargo doc --no-deps --open</code>。</p><p id="5501" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">了解你的用户的需求，最好是吃你自己的狗粮——这意味着在其他项目中使用你的宏，看看它的效果如何。对于<code class="fe kf kg kh ki b">anyinput</code>宏，我在</p><ul class=""><li id="c650" class="md me iq lg b lh li lk ll ma mf mb mg mc mh lz my mj mk ml bi translated"><code class="fe kf kg kh ki b"><a class="ae kz" href="https://crates.io/crates/fetch-data" rel="noopener ugc nofollow" target="_blank">fetch-data</a></code> —我从网上下载并缓存样本文件的箱子)—我使用<code class="fe kf kg kh ki b">anyinput</code>来指定路径。效果很好。</li><li id="d277" class="md me iq lg b lh mm lk mn ma mo mb mp mc mq lz my mj mk ml bi translated"><code class="fe kf kg kh ki b"><a class="ae kz" href="https://crates.io/crates/bed-reader" rel="noopener ugc nofollow" target="_blank">bed-reader</a></code>——我们的基因组文件阅读器——我使用了<code class="fe kf kg kh ki b">anyinput</code>来指定路径(效果很好)和类似字符串的东西的迭代器(yikes)。</li></ul><p id="785e" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">有了<code class="fe kf kg kh ki b">bed-reader</code>，我意识到用户会看到我的宏生成的通用名。bed-reader的<a class="ae kz" href="https://docs.rs/bed-reader/latest/bed_reader/struct.MetadataBuilder.html#method.chromosome" rel="noopener ugc nofollow" target="_blank">文档</a>和代码编辑器(如VS Code)都显示了宏生成的泛型。如果我把它们命名为<code class="fe kf kg kh ki b">T0</code>、<code class="fe kf kg kh ki b">T1</code>等。它们会太模糊，可能会与用户函数中的其他类属发生冲突。为了避免碰撞，我尝试了像<code class="fe kf kg kh ki b">T8a0700b3-d16b-4b8e-bdb4–8fcb7e809ff3</code>这样的名字，但是它们看起来很可怕。我最终给泛型起了诸如<code class="fe kf kg kh ki b">AnyString0</code>、<code class="fe kf kg kh ki b">AnyIter1</code>等名字。多亏了“吃我自己的狗粮”，我最终得到了一个令我满意的设计。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><p id="1745" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">现在，你有了:在Rust中创建程序宏的九条规则。如果你想发布你的宏到<a class="ae kz" href="https://crates.io/" rel="noopener ugc nofollow" target="_blank"> crates.io </a>，你需要先发布<em class="lf">核心</em>，然后<em class="lf">派生</em>，最后<em class="lf">顶层</em>。在每个<code class="fe kf kg kh ki b"><a class="ae kz" href="https://doc.rust-lang.org/cargo/commands/cargo-publish.html" rel="noopener ugc nofollow" target="_blank">cargo publish</a></code>之间，您可能需要等待5秒钟左右。</p><p id="d414" class="pw-post-body-paragraph ld le iq lg b lh li jr lj lk ll ju lm ma lo lp lq mb ls lt lu mc lw lx ly lz ij bi translated">我使用<code class="fe kf kg kh ki b">anyinput</code>的经验表明，编写一个宏可以像编写一个普通的Rust程序一样简单……操作大型的嵌套结构。关键是组织工作空间，使用正确的工具，并理解这些工具。遵循这九条规则来创建你自己的强大的Rust宏。</p><blockquote class="la lb lc"><p id="b0ae" class="ld le lf lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">旁白:请试试https://crates.io/crates/anyinput。如果你喜欢这篇文章，请给它“鼓掌”。如果您对未来的文章感兴趣——关于Rust、机器学习、Python、统计学等。—请跟着我写。</p></blockquote></div></div>    
</body>
</html>