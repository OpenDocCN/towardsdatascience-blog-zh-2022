<html>
<head>
<title>Pandas vs. SQL — Part 3: Pandas Is More Flexible</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pandas与SQL —第3部分:Pandas更灵活</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pandas-vs-sql-part-3-pandas-is-more-flexible-cb43167189f5#2022-07-26">https://towardsdatascience.com/pandas-vs-sql-part-3-pandas-is-more-flexible-cb43167189f5#2022-07-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f3b9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Pandas灵活的数据模型非常适合数据科学用例</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/0a4d1f9c4243e6ee6ba87651f78d4480.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/0*JoiIyO9VvclTVAVR.jpeg"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">美洲虎坦巴克在<a class="ae kr" href="https://wordpress.org/openverse/image/149edeab-4fbb-4d62-9110-269f6e0474bb/" rel="noopener ugc nofollow" target="_blank"> Openverse </a>拍摄的照片(CC BY-ND 2.0)</p></figure><p id="7452" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">TL；在这篇文章中，我们在三个坐标轴的第二个坐标轴上比较了Pandas和SQL:灵活性。我们介绍了Pandas dataframe数据模型提供额外灵活性的八种方式，这使其非常适合数据科学和机器学习，优于SQL的关系模型。</strong></p><p id="d33c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们继续寻求理解Pandas和SQL的相对优势——两种用于数据操作和分析的流行且强大的语言。这是比较熊猫和SQL的系列帖子中的第三篇；下面是之前的两个帖子:<a class="ae kr" href="https://ponder.io/pandas-vs-sql-food-court-michelin-style-restaurant/" rel="noopener ugc nofollow" target="_blank">熊猫大战SQL —第一部分:美食广场和米其林风格的餐厅</a>和<a class="ae kr" href="https://ponder.io/pandas-vs-sql-part-2-pandas-is-more-concise/" rel="noopener ugc nofollow" target="_blank">熊猫大战SQL —第二部分:熊猫更简洁</a>。</p><p id="78ca" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">正如我们在上一篇关于Pandas与SQL的文章中所看到的，Pandas有600多个函数，可以让您以各种强大的方式对数据进行操作，这些方式在SQL中是不可能或极难做到的，涵盖了一系列关键的机器学习、线性代数、特征化和数据清理操作。在这篇文章中，我们展示了Pandas dataframe数据模型(或抽象)如何提供额外的灵活性，使其非常适合数据科学和机器学习，优于SQL底层的关系模型。因此，前一篇文章关注的是数据框架<strong class="ku ir">代数</strong>，而这篇文章将关注数据框架<strong class="ku ir">数据模型</strong>。</p><p id="8d72" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">以下是Pandas数据框架比关系/SQL数据框架更灵活的多种方式的列表:</p><ol class=""><li id="cfa2" class="lo lp iq ku b kv kw ky kz lb lq lf lr lj ls ln lt lu lv lw bi translated">将数据转移到元数据，然后再转移回来</li><li id="8121" class="lo lp iq ku b kv lx ky ly lb lz lf ma lj mb ln lt lu lv lw bi translated">行和列元数据</li><li id="3099" class="lo lp iq ku b kv lx ky ly lb lz lf ma lj mb ln lt lu lv lw bi translated">混合型色谱柱</li><li id="3129" class="lo lp iq ku b kv lx ky ly lb lz lf ma lj mb ln lt lu lv lw bi translated">灵活的模式</li><li id="4e0a" class="lo lp iq ku b kv lx ky ly lb lz lf ma lj mb ln lt lu lv lw bi translated">元数据转换</li><li id="7479" class="lo lp iq ku b kv lx ky ly lb lz lf ma lj mb ln lt lu lv lw bi translated">柱状操作</li><li id="bfe1" class="lo lp iq ku b kv lx ky ly lb lz lf ma lj mb ln lt lu lv lw bi translated">分层元数据</li><li id="7a6a" class="lo lp iq ku b kv lx ky ly lb lz lf ma lj mb ln lt lu lv lw bi translated">对元数据差异的容忍</li></ol><p id="cfdd" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们将从一个简单的数据集开始，类似于从电子表格加载数据后可能得到的数据集。这是一个包含2020年夏季奥运会最佳表现国家的奖牌总数的数据集。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><h1 id="d583" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">1.在Pandas中，你可以在元数据之间来回移动数据！在SQL中，您不能。</h1><p id="0ebc" class="pw-post-body-paragraph ks kt iq ku b kv mw jr kx ky mx ju la lb my ld le lf mz lh li lj na ll lm ln ij bi translated">关于上面的数据集，您可能注意到的第一件事是，我们有像<code class="fe nb nc nd ne b">A, B, C, ... </code>这样的非描述性列名，而实际的列名是数据的一部分(第0行)。理想情况下，我们希望用这些列名替换<code class="fe nb nc nd ne b">A, B, C, ...</code>。我们可以通过以下方式做到这一点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="5c39" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们所做的只是将标题行提取到<code class="fe nb nc nd ne b">header</code>，修整数据帧以保留最后的<code class="fe nb nc nd ne b">n-1</code>行，并通过<code class="fe nb nc nd ne b">df.columns</code>设置列名。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="4ec8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">类似地，可以将信息从元数据(列标题)反向移动到数据。见下文。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="322e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们在这里所做的是通过<code class="fe nb nc nd ne b">to_frame()</code>将列名提取为数据帧，通过单个字母<code class="fe nb nc nd ne b">T</code>将数据帧转置为一行，最后通过<code class="fe nb nc nd ne b">pd.concat</code>将该行与旧数据帧垂直连接。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="2182" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在SQL中，实际上不可能将数据移动到元数据(列名)中，或者将数据移动回来。</p><h1 id="4d77" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">2.Pandas支持行和列元数据；SQL只有列元数据。</h1><p id="ba79" class="pw-post-body-paragraph ks kt iq ku b kv mw jr kx ky mx ju la lb my ld le lf mz lh li lj na ll lm ln ij bi translated">虽然Pandas像数据库一样支持列元数据(即列标签)，但Pandas也支持行标签形式的逐行元数据。如果我们想以直观的方式组织和引用数据，这是很方便的。这里有一个例子:我们从重新加载数据帧开始。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="7ba1" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在我们需要做的就是使用<code class="fe nb nc nd ne b">set_index</code>来设置行标签或索引。这里我们将其设置为数据中的<code class="fe nb nc nd ne b">Name</code>列。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="bfa7" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">就像列标签一样，我们也可以使用<code class="fe nb nc nd ne b">reset_index</code>命令将行标签移回到数据中。</p><p id="469c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">数据库没有行标签的概念。您可能声称行标签功能可以用一个<code class="fe nb nc nd ne b"><em class="nf">PRIMARY</em> KEY / <em class="nf">UNIQUE</em></code>关键字来复制，但这并不完全正确——行标签实际上不需要唯一。这是熊猫灵活的另一种方式！</p><h1 id="91bc" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">3.熊猫允许混合式栏目；SQL只支持单一类型的列</h1><p id="ed4d" class="pw-post-body-paragraph ks kt iq ku b kv mw jr kx ky mx ju la lb my ld le lf mz lh li lj na ll lm ln ij bi translated">由于它在数据科学中的使用，在不同的清理阶段对数据进行操作，Pandas没有对每列强制严格的类型。再看我们的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="242b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这里，<code class="fe nb nc nd ne b">Ranking</code>列包含字符串和整数。如果我们检查该列的类型，我们将看到以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="7ec0" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们所做的是在通过<code class="fe nb nc nd ne b">apply</code>推断出列中每个值的类型之后，通过<code class="fe nb nc nd ne b">value_counts</code>计算每个类型的值。正如您在输出中看到的，<code class="fe nb nc nd ne b">Ranking</code>列包含四个整数和一个字符串(—)。如果我们希望将字符串值强制转换为空值，以便该列具有单一类型，我们可以通过以下方式实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><h1 id="3b03" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">4.在Pandas中，输出模式可以根据数据灵活变化；在SQL中，模式是固定的</h1><p id="e315" class="pw-post-body-paragraph ks kt iq ku b kv mw jr kx ky mx ju la lb my ld le lf mz lh li lj na ll lm ln ij bi translated">在SQL中，输出的模式(即一组列及其类型)基于输入和查询的模式进行约束。Pandas没有这种限制，允许输出根据数据而变化，从而提供了额外的灵活性。这里有一个例子，也是在我们熟悉的数据集上:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="b7d9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如您所见，<code class="fe nb nc nd ne b">get_dummies</code>函数为<code class="fe nb nc nd ne b">Continent</code>列中的每个值创建了一个新的布尔列。这对机器学习非常有帮助，因为大多数机器学习包只接受数字数据，所以所有的字符串列都需要转换成数字列。如果我们从数据集中省略了对应于<code class="fe nb nc nd ne b">ROC</code>的最后一行，就不会有对应于<code class="fe nb nc nd ne b">Continent_Europe/Asia</code>的列。通过这种方式，输出列可以依赖于数据——非常简单！</p><h1 id="e61c" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">5.Pandas允许您灵活地转换元数据(列/行标签)；在SQL中，您不能</h1><p id="2b8c" class="pw-post-body-paragraph ks kt iq ku b kv mw jr kx ky mx ju la lb my ld le lf mz lh li lj na ll lm ln ij bi translated">Pandas认识到模式总是不断变化的，并赋予我们灵活清理元数据的超能力，而不仅仅是以简单的编程方式清理数据。这里，如果我们发现<code class="fe nb nc nd ne b">Continent_</code>前缀很难跨列重复，我们可以使用一个命令在所有列中删除它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="f737" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">噗，就这样，没了！不幸的是，SQL不能像Pandas那样给你操作列名的能力。您需要手动指定每个列名将如何更改。</p><h1 id="8c2a" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">6.Pandas允许您像操作行一样操作列；SQL没有</h1><p id="7b36" class="pw-post-body-paragraph ks kt iq ku b kv mw jr kx ky mx ju la lb my ld le lf mz lh li lj na ll lm ln ij bi translated">不同于SQL对行和列的不同处理，Pandas对它们的处理是一样的。从上面使用<code class="fe nb nc nd ne b">Name</code>列作为行索引/标签的<code class="fe nb nc nd ne b">df_name_index</code>开始，我们可以简单地转置它，使行成为列，列成为行，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="5a7e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">最酷的是，Pandas自动推断新列的类型，而无需用户做任何工作。在这种情况下，所有这些列都是混合型的，因为它们既有整数也有字符串。以这种方式组织数据通常更容易比较。除了转置，我们还可以像对待行一样沿着列应用大多数函数。我们在之前的博客中已经提到了这方面的例子。</p><h1 id="5d00" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">7.Pandas让你拥有层次化的元数据；SQL没有</h1><p id="7434" class="pw-post-body-paragraph ks kt iq ku b kv mw jr kx ky mx ju la lb my ld le lf mz lh li lj na ll lm ln ij bi translated">分层元数据帮助我们以更易于阅读和直观的方式组织和呈现信息。幸运的是，Pandas支持分层的行标签和列标签。假设我们想要创建分层的行标签:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="6f25" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">正如我们在上面看到的，我们通过<code class="fe nb nc nd ne b">set_index</code>操作符创建了一个由一对大陆和国家名称组成的行标签层次结构。通过使用<code class="fe nb nc nd ne b">T</code>操作符转置这个结果，我们得到了一个分层列标签的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="5620" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在上面的结果中，列标签的第一行捕获了大陆，而第二行捕获了国家名称。与Pandas不同，SQL和关系数据库不支持分层元数据。对此最好的代理是使用半结构化数据格式(例如JSON、XML)，关系数据库通常支持这种格式作为列中的特殊数据类型。但是，在这些列上实施分层模式是很困难的，对这些嵌套数据格式的操作也是如此。</p><h1 id="5623" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">8.Pandas在对具有不同元数据的多个数据帧进行操作时是宽容的；SQL不是</h1><p id="c45f" class="pw-post-body-paragraph ks kt iq ku b kv mw jr kx ky mx ju la lb my ld le lf mz lh li lj na ll lm ln ij bi translated">当在多个数据帧上操作时，Pandas操作允许模式差异。我们将通过考虑一个常见的二元运算<code class="fe nb nc nd ne b">concat</code>来说明这一点。假设我们在当前数据框架旁边有另一个数据框架，包含关于另外三个国家(澳大利亚、法国和荷兰)的信息。我们可以使用<code class="fe nb nc nd ne b">concat</code>操作符来执行具有匹配模式的两个数据帧的有序联合，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="2a22" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">得到的数据帧有八行。这是一个简单的例子，类似于SQL <code class="fe nb nc nd ne b"><em class="nf">UNION</em></code>操作符。现在假设两个数据帧的模式不同；具体来说，<code class="fe nb nc nd ne b">df2</code>没有金牌榜栏目。这是我们从熊猫身上得到的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="cfc9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">正如我们所看到的，Pandas采用了一种“尽力而为”的方法，继续执行有序的联合(即连接)，为两个数据帧之一中缺少的列填充<code class="fe nb nc nd ne b">NaN</code>(即null)值。在这里，SQL会给出一个错误，因为模式需要匹配一个联合。</p><h1 id="8381" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">结论</h1><p id="d6b6" class="pw-post-body-paragraph ks kt iq ku b kv mw jr kx ky mx ju la lb my ld le lf mz lh li lj na ll lm ln ij bi translated">正如我们在上面的例子中看到的，Pandas中的dataframe抽象比SQL下的关系模型灵活得多。从最终用户的角度来看，这种额外的灵活性通常使表示和使用数据更加直观。此外，在执行数据清理时，这种增加的灵活性是必不可少的:数据通常是脏的，具有异构类型和不精确、未指定和/或未对齐的模式。最后，Pandas数据模型放弃了任意的区分:行和列是等价的，数据和元数据是等价的——这使得表达许多重要的数据科学和机器学习操作变得更加方便。</p><p id="e887" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果你能想到Pandas比SQL更灵活的其他例子，或者相反，我们很乐意听到！欢迎在推特上关注我们，了解更多类似的内容，并在这里回复我们的推特<a class="ae kr" href="https://twitter.com/ponderdata/status/1551977628722085888" rel="noopener ugc nofollow" target="_blank">！</a></p><p id="bb57" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在我们的Pandas与SQL系列的下一篇文章(第4篇，共4篇)中，我们认为Pandas是更方便的语言。在这里阅读更多<a class="ae kr" href="https://ponder.io/pandas-vs-sql-part-4-pandas-is-more-convenient/" rel="noopener ugc nofollow" target="_blank"/>！</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="7213" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><em class="nf">原载于2022年7月26日</em><a class="ae kr" href="https://ponder.io/pandas-vs-sql-part-3-pandas-is-more-flexible/" rel="noopener ugc nofollow" target="_blank"><em class="nf">https://pounder . io</em></a><em class="nf">。</em></p></div></div>    
</body>
</html>