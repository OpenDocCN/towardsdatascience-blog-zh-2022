<html>
<head>
<title>What to Do If a Time Series Is Growing (But Not in Length)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如果时间序列在增长(但长度不变)，该怎么办</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/what-to-do-if-a-time-series-is-growing-but-not-in-length-421fc84c6893#2022-11-03">https://towardsdatascience.com/what-to-do-if-a-time-series-is-growing-but-not-in-length-421fc84c6893#2022-11-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e52a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">只需使用AutoML进行多元时间序列预测</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4237e4c16c556a7b45ce07aeb38ec6a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hkqKK1aGeNoUNn33QRq8zg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用于多元时间序列预测的AutoML(图片由作者提供)</p></figure><p id="66e2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有一种观点认为时间序列预测是一项复杂的任务。但是大家也不要心烦，因为也有好处——一下子有好几个时间序列的时候任务很多，这样的任务就更难了！当我们开始比较时，我们明白预测一个单变量时间序列并不困难(为幸福而休息)。但是当时间序列与其他参数的并发序列(多维序列)一起扩展时，该怎么办呢？如果你有预测这样一个系列的任务，但没有太多的经验，该使用什么方法和算法，以及该做什么(剧透——使用AutoML，当它工作时，通过阅读关于这个主题的几篇文章来填补空白)。</p><h2 id="5b08" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><strong class="ak">什么是时间序列</strong></h2><p id="edfd" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">如果我们从头开始，它是一个按时间排序的值序列。时间序列有一种模式:一个序列的当前值与之前的值相关。如果序列没有这样的性质，那么恭喜你(或者不是)，你正在处理一个不能用经典(也不是很)模型预测的过程，在这种情况下你应该看看马尔可夫过程。</p><p id="49aa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面的简单图片说明了所描述的属性—这个背景足以继续阅读帖子(图1)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/0382b008a61caa429ea0b76e0f3a28d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6SLC4PAZrGalYWQ8FDZCig.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图一。时间序列示例(图片由作者提供)</p></figure><p id="e34d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你想了解更多关于如何预测时间序列的知识(尤其是用AutoML)，我已经贴了几篇关于这个话题的文章:<a class="ae mq" rel="noopener" target="_blank" href="/automl-for-time-series-definitely-a-good-idea-c51d39b2b3f"> AutoML for time series:绝对是个好主意</a>；<a class="ae mq" rel="noopener" target="_blank" href="/automl-for-time-series-advanced-approaches-with-fedot-framework-4f9d8ea3382c">时间序列的AutoML:使用FEDOT框架的高级方法</a>。</p><h2 id="ee99" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><strong class="ak">什么是多元时间序列</strong></h2><p id="63c1" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">越来越接近主题。多维(多变量)时间序列是由几个一维(单变量)序列组成的系统，其中一个(目标)的值不仅取决于其先前的值，还取决于另一个或几个额外序列的先前值。</p><p id="9c81" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">多元时间序列的一个例子如图2所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/03f549abbe2a1d092c5a3ae91fc95fc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b9FbMYpKud_6DgjjM5H71g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图二。多元时间序列示意图。目标参数显示为红色，外部时间序列显示为蓝色(图片由作者提供)</p></figure><p id="30dd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从图中可以看出，为了预测时间序列1的未来状态，我们可以使用时间序列2和3的值。如果你对这样一个系列的例子感兴趣——这里，在不同点测量的海平面如图3所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/b64f8680bb91ac60b27ede4527594f25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hDKgQhwWHtSC1lBxHEwXRg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图3。太平洋不同点水位的多元时间序列。基于卫星测高数据(<a class="ae mq" href="https://cds.climate.copernicus.eu/cdsapp#!/dataset/satellite-sea-level-global?tab=overview" rel="noopener ugc nofollow" target="_blank">哥白尼《来自卫星观测的海平面每日网格数据》</a> [1])(图片由作者提供)</p></figure><p id="9e41" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">“多元时间序列预测”的两个不同案例现在值得强调。在第一种情况下，我们将只有当前时间指数和历史值的外生时间序列的可用数据，即t，t-1，t-2，t-n，而预测指数t+1，t+2，t+f(其中f是预测范围)的数据是未知的。或者，在第二种情况下，目标时间序列的预测指数值是未知的，但有关于这些时间点的外生指数的信息。这可以在图表中最清楚地显示出来(见图4)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/b2c62fb9f60878d0d16b9b065deb3645.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dBr_g5yEX7GHUDTQt4ZWGw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图4。使用辅助时间序列预测目标变量(图片由作者提供)</p></figure><p id="9812" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在第一种情况下，我们处理传统的时间序列预测任务，因为未来的状态是可以预测的。在第二种情况下，我们解决了回归问题，但因为数据是按时间顺序排列的，我们也可以将这种情况称为“动态回归”，它考虑了数据的滞后依赖性。在本文中，我们将只讨论第一种情况，因为第二种情况是回归问题的特殊情况。</p><p id="3b19" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">P.S .如果你想了解更多关于使用时间模式的动态回归，请点击这篇文章:)这样，我会知道这个主题对你来说是有趣的，我会准备一个与该领域相关的新帖子。</p><h2 id="eb92" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><strong class="ak">我们如何预测这样的系列</strong></h2><p id="4a92" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">越来越接近主题。使用向量自回归(VAR)来预测时间序列系统的行为。VAR是对多个时间序列自回归思想的推广，因此被认为是多元序列预测的经典工具。一些时间序列可以包含在经典的预测模型中，如ARMA。在这种情况下，这种模型将被称为向量自回归移动平均模型(VARMA)。<a class="ae mq" href="https://ieeexplore.ieee.org/abstract/document/8830667" rel="noopener ugc nofollow" target="_blank">递归神经网络</a>也用于解决这个任务，它们是这个领域非常流行的工具。“更高级”方法的使用，例如基于VAR 优化的<a class="ae mq" href="https://www.sciencedirect.com/science/article/abs/pii/0169207086900919" rel="noopener ugc nofollow" target="_blank">，通常出现在科学文章中，关键词为“多元时间序列预测”。</a></p><p id="e44f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们尝试考虑将已知的预测单变量时间序列的方法推广到多变量情况的方法。正如在文章<a class="ae mq" rel="noopener" target="_blank" href="/automl-for-time-series-advanced-approaches-with-fedot-framework-4f9d8ea3382c">AutoML for time series:advanced approach with FEDOT framework</a>中所描述的，可以使用经典模型(AR，ARIMA)和回归机器学习模型来预测时间序列。为了使用回归模型，有必要对序列进行特殊的矩阵变换。对于单变量的情况，转换方案如下图所示(图5)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mu"><img src="../Images/bdf02a84da8e28c0f98f3abc7b58002a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hUPs3nNybUxiRUEJKRDxxQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图5。转换成单变量时间序列的滞后矩阵(图片由作者提供)</p></figure><p id="1309" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于多元时间序列，将获得下表(图6)。移动窗口大小和预测范围与上图相同。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/259e6746f969226339ee31eaf70d1028.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n7vTE28wthB9ugLeDhNs7A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图6。转换成多元时间序列的滞后矩阵(图片由作者提供)</p></figure><p id="e228" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">具有特征的结果表可以用作机器学习模型的训练样本，例如岭回归或随机森林，或者用于任何其他合适的算法。这样，模型将基于目标变量和外生时间序列的先前值生成预测。这个概念有两个缺点:</p><ul class=""><li id="de9b" class="mw mx iq kx b ky kz lb lc le my li mz lm na lq nb nc nd ne bi translated">同时用于所有时间序列的移动窗口的大小可能不是最佳的。对于其中一个系列来说，只通过5-10个元素“回顾过去”就足以成功地预测未来状态，而对于另一个系列来说，则需要数百个元素的滞后转换；</li><li id="a2c7" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated">不能保证外生时间序列与目标时间序列相关。</li></ul><p id="e122" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">解决这些问题是可能的。然后我们再考虑怎么做。现在，让我们专注于如何运行AutoML工具来解决多变量时间序列预测的问题。</p><h2 id="f7bb" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><strong class="ak">数据描述</strong></h2><p id="6f01" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">演示将使用来自模型<a class="ae mq" href="https://www.nemo-ocean.eu/" rel="noopener ugc nofollow" target="_blank"> NEMO </a>(欧洲海洋建模核心)的海平面数据。这个模型允许我们准备一个包含SSH(海面高度)测量值的数据集。我们收集了25个时间序列。它们在地图上的位置可以在下图中看到(图7)。</p><p id="104c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nk">数据集是合成的，由我们团队生成，即由</em> <a class="ae mq" href="https://github.com/ChrisLisbon" rel="noopener ugc nofollow" target="_blank"> <em class="nk">朱丽娅·鲍里索娃</em> </a> <em class="nk">。在</em><a class="ae mq" href="https://github.com/ITMO-NSS-team/pytsbe/blob/main/LICENSE.md" rel="noopener ugc nofollow" target="_blank"><em class="nk">BSD 3-Clause“New”或“Revised”License</em></a><em class="nk">:SSH数据集可以通过</em> <a class="ae mq" href="https://github.com/ITMO-NSS-team/pytsbe/blob/main/data/multivariate_ssh.csv" rel="noopener ugc nofollow" target="_blank"> <em class="nk">链接</em></a><em class="nk">【2】获得。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/f0a8e2f4eb63f54417885dc25c751488.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YHj9jMXerYHg4NHjuxs1bg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图7。海平面数据集的可视化(图片由作者提供)</p></figure><p id="805e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们感兴趣的时间序列在图中用一个正方形突出显示。这是我们将要预测的一个，使用这个点的参数的历史值和相邻点的历史值。预测展望期为50个要素。</p><p id="04f5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">整个数据集(名为SSH)以及运行它的代码可以在库<a class="ae mq" href="https://github.com/ITMO-NSS-team/pytsbe" rel="noopener ugc nofollow" target="_blank"> pytsbe </a>中找到。</p><h2 id="0ecb" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><strong class="ak">如何在FEDOT中预测这些行</strong></h2><p id="c6a7" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">让我们继续看代码示例。所以，任务是用25个时间序列来预测其中一个(目标)在未来的值。</p><p id="b67c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要运行这个例子，使用下面的代码(我们的时间序列是numpy数组，这里有一个启动<a class="ae mq" href="https://github.com/ITMO-NSS-team/pytsbe/tree/main/cases" rel="noopener ugc nofollow" target="_blank">的例子</a>，FEDOT版本为experiments — 0.6.0):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="cce7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们用时间序列形成一个字典，它将被用作模型中的特征。</p><h2 id="60b7" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><strong class="ak">简单介绍一下配置选项</strong></h2><p id="6799" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">如果出于某种原因，我们不想在模型中包含所有的时间序列，我们可以只包含那些需要的键-值对来形成一个字典。因此，如果有大量的时间序列，导致模型过于复杂，不适合长时间，那么一个可接受的解决方案可能是修剪特征空间。</p><p id="0ba2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果不需要运行AutoML算法，但是需要在有限的时间内建立至少简单的模型，我们可以使用fit方法中的参数predefined_model='auto '。正如<a class="ae mq" rel="noopener" target="_blank" href="/how-automl-helps-to-create-composite-ai-f09e05287563">你可能知道的</a>，FEDOT的AutoML内核是基于一种进化算法。并且进化算法在优化开始之前生成一个或多个流水线(初始假设)。这些初始假设被反复修改，从而得到越来越精确的解。</p><p id="2f5e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以，回到预定义的_model='auto '参数。AutoML算法将生成一个初始假设。但是，优化过程不会开始。该算法将只训练这一个自动生成的初始假设，并返回拟合的管道。这样做将允许我们在不运行AutoML算法的情况下快速准备模型。也就是说，我们使用预定义的管道配置(在这种情况下，由算法自动生成)，并且只训练它，不训练其他任何东西。自然，这个过程需要的时间比运行AutoML内核少得多。下面是代码中的一个示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="2737" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们回到进化(在这个实验中我们不使用predefined_model):经过一定数量的代后，得到了如下结果(图8)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/30acf8496ede359ae67e44f9eb628c7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R6b2LqQd_o4T1q9ecuKU5w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图8。获得的模型和发现的管道结构对多元时间序列预测的验证结果(图片由作者提供)</p></figure><p id="44ea" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">看起来不错。让我们试着弄清楚内部发生了什么。</p><h2 id="1610" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><strong class="ak">关于可视化的免责声明</strong></h2><p id="5c5b" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我们最近更新了可视化工具，因此当使用FEDOT framework 0 . 6 . 0版或更高版本时，图形(管道)的显示可能与本文中的图片不同。</p><h2 id="4690" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><strong class="ak">FEDOT如何预测这些行</strong></h2><p id="b7dd" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">让我们考虑寻找解决方案的过程。首先，算法需要一些东西来启动进化过程——一些有效的初始假设。这种初始假设是自动生成的，并且获得了以下管道—查看图9。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/ace1097b2bf4fe1cc8c1d693a0e59dab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WdqH_4-nsgXRfpmLiZBjIQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图9。多元时间序列预测任务的初始假设(图片由作者提供)</p></figure><p id="c6ff" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里发生了什么？—首先，时间序列被传递到每个“数据源”节点(1)。这些节点不会对它们的时间序列做任何事情，而是进一步传递它。</p><p id="409a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这样做是为了能够将新的数据源连接到管道。这也有助于理解哪些时间序列在管道中被转换(注意斜杠后面的名称，它们显示了时间序列的标签，因此我们可以识别它们)。因此，可以清楚地看出，滞后变换被应用于名为0的时间序列，并且它的副本被转移到GLM模型(2)。GLM是一种广义线性模型，可以直接处理时间序列，不需要滞后变换。然后将滞后变换的输出传递给岭回归模型(3)。</p><p id="1f2b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，来自两个模型(GLM和岭)的每个时间序列的预测被转移到岭回归模型(4)，在这种情况下，最终模型也是岭回归。不要担心大量的岭回归模型——这只是一个初始假设，进一步的进化会在节点中选择更多的最优模型。</p><p id="d507" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，基于该初始假设，通过使用变异来生成用于进化算法的初始流水线群体。在优化AutoML流水线结构的过程中，该算法可以改变节点中的操作(模型)，删除节点和边，添加新的节点和边，以及调整操作的超参数。这意味着可以获得以下结构(图10)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/c41e9a693fe48c95b0c8e41191aca9c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YzR2Xdxfsb8-JFNAKN7LNQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图10。优化过程中获得的可能管道结构(图片由作者提供)</p></figure><p id="ce84" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从图10中可以看出，如果有必要，我们可以删除节点和整个分支。因此，我们可以剔除与目标无关的时间序列。</p><p id="aa91" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在图形优化过程中，我们可以单独调整每个序列的移动窗口大小(由滞后变换中的超参数窗口大小调节)。它解决了模型中不具有代表性的外生预测序列的问题。</p><h2 id="78d2" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">这些“痛苦”是为了什么？</h2><p id="8bcd" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">显然，为了减少预测误差:)但是，严肃地说，这个问题真的很好——是时候检查实现的方法是否至少给出了一些优势。为了确定外生时间序列的使用确实会影响最终预测的误差，我们来进行一个实验。</p><p id="f223" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将使用算法自动生成的初始假设来预测时间序列。在这种情况下，我们将使用目标时间序列的历史值作为预测值，然后我们将迭代扩展附加时间序列的数量。对于目标时间序列的最后50个元素，我们将比较预测值和实际值。度量:平均绝对误差(MAE)。该测试的结果显示在下面的动画中:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/4c95d198d72b228565d39362ae41e6a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*SzyIuh74P6mJlqY_iSTA0w.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">动画。实验外生时间序列数量的迭代扩展(图片由作者提供)</p></figure><p id="028b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">图11显示了误差对来自系列数量的验证样本的依赖性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/c754c966c1dd4697bc550e9e68d0858d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xZKhyzdiF_6u1wVA5nsejw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图11。在模型中使用不同数量的时间序列获得的MAE值(图片由作者提供)</p></figure><p id="bfb9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从图中可以看出，模型中包含的时间序列数量影响误差值。注意:在这个实验中，我们没有调整管道的超参数，也没有使用进化算法修改初始结构。与简单模型相比，当模型使用大量时间序列时，有更多的机会来改进模型。因此，在超参数调整和其他优化程序之后，更复杂模型的优势可能会增加。</p><h2 id="fcce" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><strong class="ak">结论</strong></h2><p id="6e73" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在这篇文章中，我们考虑了预测多元时间序列的方法。我们讨论了如何用AutoML预测这样一个序列。然后，我们详细查看了AutoML工具FEDOT中用于多变量TS预测的所有内容是如何设计的。</p><blockquote class="nt nu nv"><p id="98fd" class="kv kw nk kx b ky kz jr la lb lc ju ld nw lf lg lh nx lj lk ll ny ln lo lp lq ij bi translated">预测时间序列，用FEDOT！</p></blockquote><p id="ce99" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nk">有用链接:</em></p><ul class=""><li id="89e1" class="mw mx iq kx b ky kz lb lc le my li mz lm na lq nb nc nd ne bi translated"><a class="ae mq" href="https://github.com/nccr-itmo/FEDOT" rel="noopener ugc nofollow" target="_blank">使用开源AutoML框架FEDOT的存储库</a></li><li id="3d5e" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated">用于启动时间序列预测算法和基准测试的开源工具— <a class="ae mq" href="https://github.com/ITMO-NSS-team/pytsbe" rel="noopener ugc nofollow" target="_blank"> pytsbe </a>(该模块相当新，因此如果您想参与其开源开发—请参与进来！)</li><li id="7c91" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated">我们关于时间序列预测的AutoML方法的新论文(在进化计算大会上发表)——<a class="ae mq" href="https://www.researchgate.net/publication/363326600_Evolutionary_Automated_Machine_Learning_for_Multi-Scale_Decomposition_and_Forecasting_of_Sensor_Time_Series" rel="noopener ugc nofollow" target="_blank">用于传感器时间序列多尺度分解和预测的进化自动机器学习</a></li></ul><p id="917d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nk">本帖中使用的数据集(&amp;许可证):</em></p><ol class=""><li id="c2d3" class="mw mx iq kx b ky kz lb lc le my li mz lm na lq nz nc nd ne bi translated">哥白尼“从卫星观测得到的海平面每日网格数据”。参考文献。致Taburet，g .，Sanchez-Roman，a .，Ballarotta，m .，Pujol，M.I .，Legeais，J.F .，Fournier，f .，Faugere，y .，Dibarboure，G.: Duacs dt2018: 25年的再加工海平面测高产品— 2019。<br/> <strong class="kx ir">链接到数据集</strong> — <a class="ae mq" href="https://cds.climate.copernicus.eu/cdsapp#!/dataset/satellite-sea-level-global?tab=overview" rel="noopener ugc nofollow" target="_blank">哥白尼数据集</a> <br/> <strong class="kx ir">许可</strong> — <a class="ae mq" href="https://cds.climate.copernicus.eu/api/v2/terms/static/licence-to-use-copernicus-products.pdf" rel="noopener ugc nofollow" target="_blank">许可协议</a> <br/>链接更新到2022年11月2日</li><li id="fc5e" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nz nc nd ne bi translated">海面高度(SSH)合成数据集。<br/> <strong class="kx ir">链接到数据集</strong> — <a class="ae mq" href="https://github.com/ITMO-NSS-team/pytsbe/blob/main/data/multivariate_ssh.csv" rel="noopener ugc nofollow" target="_blank"> SSH数据集</a> <br/> <strong class="kx ir">许可证</strong>—<a class="ae mq" href="https://github.com/ITMO-NSS-team/pytsbe/blob/main/LICENSE.md" rel="noopener ugc nofollow" target="_blank">BSD 3-条款“新的”或“修订的”许可证</a> <br/>链接到2022年11月2日是最新的</li></ol><p id="741b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如何预测多元时间序列的解释由<a class="ae mq" href="https://github.com/Dreamlone" rel="noopener ugc nofollow" target="_blank"> me(米哈伊尔·萨拉法诺夫)</a>和<a class="ae mq" href="https://itmo-nss-team.github.io/" rel="noopener ugc nofollow" target="_blank"> NSS实验室团队</a>准备</p></div></div>    
</body>
</html>