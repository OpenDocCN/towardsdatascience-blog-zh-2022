<html>
<head>
<title>Powerful One-liners in Pandas Every Data Scientist Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个数据科学家都应该知道的强大的一句话</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/powerful-one-liners-in-pandas-every-data-scientist-should-know-737e721b81b6#2022-07-12">https://towardsdatascience.com/powerful-one-liners-in-pandas-every-data-scientist-should-know-737e721b81b6#2022-07-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5ad6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用熊猫可以在一行中完成的事情</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/500a54b305da772338a55f9d9e7f36be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*npy63uZkFgDYzici"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@24k?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯汀玛丽</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3f18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">训练数据驱动的机器学习模型从未像今天这样简单。例如，假设你正在训练一个普通的神经网络。这里，针对隐藏层的数量及其维度调整架构、调整超参数或更改损失函数都可以通过对模型定义或其优化器进行轻微修改来完成。</p><p id="dcd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一方面，这是有利的，因为它减少了从零开始花费时间设计架构的繁重工作。然而，这往往导致机器学习从业者/研究人员忽视了数据可视化和分析的重要性——导致他们直接训练深度模型，而没有对他们的数据建立清晰的理解。</p><p id="dfbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，在这篇文章中，我想向您介绍一些专门针对使用Pandas的表格数据的重要而强大的一行程序，这将帮助您更好地理解您的数据，并最终(希望)帮助您设计和构建更好的机器学习模型。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="3366" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">资料组</h1><p id="3e1f" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在这篇文章中，我将使用一个由一千名员工组成的虚拟数据集进行实验，这个数据集是我自己用Python创建的。下图概述了我们正在试验的数据集。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/198124543f8cdece2d4946b80cb03b7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M8-VnXV0rdrBQdFcNfXr9Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">数据框的前五行(图片由作者提供)</p></figure><p id="63df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的代码块演示了我的实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="c3e7" class="lz ma iq bd mb mc mz me mf mg na mi mj jw nb jx ml jz nc ka mn kc nd kd mp mq bi translated">熊猫的俏皮话</h1><p id="1ea4" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">接下来，让我们讨论熊猫中可用的一些流行功能，以便对可用数据进行有意义的理解。</p><h2 id="21d7" class="ne ma iq bd mb nf ng dn mf nh ni dp mj lf nj nk ml lj nl nm mn ln nn no mp np bi translated"><strong class="ak"># 1n-系列中的最大值</strong></h2><p id="6902" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">假设我们想从找出这个数据集中薪酬最高的前n个角色开始。你可以在Pandas中使用<code class="fe nq nr ns nt b"><a class="ae kv" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.nlargest.html" rel="noopener ugc nofollow" target="_blank">nlargest()</a></code>方法来实现。该方法返回列中具有最大<strong class="ky ir">值的前<code class="fe nq nr ns nt b">n</code>行，按降序排序。</strong></p><p id="ec40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，<code class="fe nq nr ns nt b">nlargest()</code>返回整个数据帧，也就是说，该函数还返回未指定排序的列。但是，它们不用于对数据帧进行排序。下面的代码片段描述了在我们的数据帧上使用<code class="fe nq nr ns nt b">nlargest()</code>方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu my l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/33b943181ebd60edaef97e33a0f0665d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qhgdq8fTRKyhh2anE4yuug.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">nlargest方法的输出(图片由作者提供)</p></figure><p id="333c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当存在重复值时，我们需要指定在最终输出中需要哪些特定的行。这是使用<code class="fe nq nr ns nt b">keep</code>参数完成的，该参数可以取以下值:</p><ol class=""><li id="4c08" class="nw nx iq ky b kz la lc ld lf ny lj nz ln oa lr ob oc od oe bi translated"><code class="fe nq nr ns nt b">keep = "first"</code>:优先考虑第一个出现的<strong class="ky ir">。</strong></li><li id="09bf" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated"><code class="fe nq nr ns nt b">keep = "last"</code>:优先处理最后一次发生的<strong class="ky ir">。</strong></li><li id="9c5f" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated"><code class="fe nq nr ns nt b">keep = "all"</code>:不删除任何重复项，即使这意味着选择超过<em class="ok"> n </em>个项目(如上图所示)。</li></ol><p id="a644" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">人们经常误认为<code class="fe nq nr ns nt b">nlargest()</code>正好等同于使用如下的<code class="fe nq nr ns nt b">sort_values()</code>方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu my l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/05e0117179ddac8b9395a3c199882d99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*04pcR4te41YSgqEIyua9Jg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">sort_values方法的输出(图片由作者提供)</p></figure><p id="4a9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，<code class="fe nq nr ns nt b">nlargest()</code>中使用的<code class="fe nq nr ns nt b">keep</code>参数使一切都不同了。考虑到上面的例子，带有<code class="fe nq nr ns nt b">keep=”all"</code>的<code class="fe nq nr ns nt b">nlargest()</code>也会返回潜在的重复项。另一方面，这在<code class="fe nq nr ns nt b">sort_values()</code>方法的情况下是做不到的。</p><h2 id="9c81" class="ne ma iq bd mb nf ng dn mf nh ni dp mj lf nj nk ml lj nl nm mn ln nn no mp np bi translated"># 2n-系列中的最小值</h2><p id="c053" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">类似于上面讨论的<code class="fe nq nr ns nt b">nlargest()</code>方法，您可以在Pandas中使用<code class="fe nq nr ns nt b">nsmallest()</code>方法找到对应于最低n值的行。该方法返回列中具有最小<strong class="ky ir">值的前<code class="fe nq nr ns nt b">n</code>行，按升序排列。这里传递的参数与在<code class="fe nq nr ns nt b">nlargest()</code>方法中指定的参数相同。下面的代码片段描述了在我们的数据帧上使用<code class="fe nq nr ns nt b">nsmallest()</code>方法。</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu my l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/2cf747377571125d0da641d487248427.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ec28WpGrasiQmicYe3kFkg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">nsmallest方法的输出(图片由作者提供)</p></figure><h2 id="b810" class="ne ma iq bd mb nf ng dn mf nh ni dp mj lf nj nk ml lj nl nm mn ln nn no mp np bi translated">#3交叉表</h2><p id="0cc1" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Crosstab允许您计算两个(或更多)列/系列的交叉列表，并默认返回每个组合的频率。换句话说，<code class="fe nq nr ns nt b"><a class="ae kv" href="https://pandas.pydata.org/docs/reference/api/pandas.crosstab.html" rel="noopener ugc nofollow" target="_blank">crosstab()</a></code>接受一个列/列表，将其唯一值显示为索引，然后接受另一个列/列表，将其唯一值显示为列标题。单个单元格中的值是使用聚合函数计算的。默认情况下，它们表示同现频率。</p><p id="cbbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">比方说，我们希望计算每家公司内每个地点的员工人数。这可以通过以下方式完成:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om my l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/a57cc14c804fa934f75f0fac876f1bcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fUK_Qm8kT1dCMqPuKyZfXw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">计算共现频率的交叉表输出(图片由作者提供)</p></figure><p id="d694" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于很难解释交叉表中的数值(并使其更具视觉吸引力)，我们可以从如下所示的交叉表中生成一个热图:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu my l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/fe16b313a3131a95e24b5c667f679f7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*MKOa1F9iM6OgKRpvFdT8Qg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">描绘同现数据框架的热图(图片由作者提供)</p></figure><p id="c674" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您希望在组成索引和列标题的列之外的其他列上计算聚合，可以通过将聚合列传递给<code class="fe nq nr ns nt b">crosstab()</code>的<code class="fe nq nr ns nt b">values</code>参数来实现，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="op my l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/b690c552564c0498d9d5120b7430c96c.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*EpjNq4APAWX3ek4I6mna0g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">描述平均工资的热图(图片由作者提供)</p></figure><h2 id="a664" class="ne ma iq bd mb nf ng dn mf nh ni dp mj lf nj nk ml lj nl nm mn ln nn no mp np bi translated">#4数据透视表</h2><p id="5286" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">数据透视表是Excel中常用的数据分析工具。与上面讨论的交叉表类似，Pandas中的数据透视表提供了一种交叉制表的方法。</p><p id="377e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然它们有许多相似之处，并且在熊猫的上下文中概念上是相同的，但是有一些实现上的差异使它们不同(此处进一步阅读<a class="ae kv" href="https://stackoverflow.com/questions/36267745/how-is-a-pandas-crosstab-different-from-a-pandas-pivot-table" rel="noopener ugc nofollow" target="_blank"/>)。下面的代码片段演示了如何使用<code class="fe nq nr ns nt b"><a class="ae kv" href="https://pandas.pydata.org/docs/reference/api/pandas.pivot_table.html" rel="noopener ugc nofollow" target="_blank">pivot_table()</a></code>方法来查找“公司名称”和“位置”之间的共现频率:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="or my l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/3a1450aec0e1c9497a8377f50ca93395.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z0Uj_WIlumSUrsjTaBkAlg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">计算共现频率的数据透视表的输出(图片由作者提供)</p></figure><p id="1eff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与我们在Crosstab中所做的类似，我们可以创建一个热图，使其在视觉上更具吸引力，并且更容易理解。如代码片段所示，这可以生成以下热图:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ot my l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/3ef34c5946268aad7edccbc580d02743.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*2Ngm48uB3sQv1VDxCjYJgw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">描绘同现数据框架的热图(图片由作者提供)</p></figure><h2 id="5365" class="ne ma iq bd mb nf ng dn mf nh ni dp mj lf nj nk ml lj nl nm mn ln nn no mp np bi translated">#5处理重复数据</h2><p id="4762" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">除了常规的数据分析之外，适当地处理数据中的重复值在构建数据管道中也起着至关重要的作用。数据中有副本的一个主要警告是，它们会占用不必要的存储空间，并通过获取资源来降低计算速度。此外，重复数据会扭曲分析结果，导致我们得出错误的见解。因此，删除或处理数据中的重复项极其重要。</p><p id="1b98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们看看如何在数据帧中标记重复值。为此，我们将在熊猫身上使用<code class="fe nq nr ns nt b"><a class="ae kv" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.duplicated.html" rel="noopener ugc nofollow" target="_blank">duplicated()</a></code>方法。这将返回一个指示重复行的布尔序列。出于演示的目的，我将只使用10行原始salary数据集的随机样本，其中最后两行是有意复制的。下图显示了采样的行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/ed94d7819d02398d9d9afab4f7c8d4d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UJBTlPzlJ5-DI4tycsGMOA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">带有副本的数据帧(图片由作者提供)</p></figure><ul class=""><li id="2187" class="nw nx iq ky b kz la lc ld lf ny lj nz ln oa lr ow oc od oe bi translated"><strong class="ky ir">标记重复的行</strong></li></ul><p id="ccdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Pandas允许您根据重复的所有列(或列的子集)为行分配布尔标签。这可以使用熊猫的<code class="fe nq nr ns nt b"><a class="ae kv" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.duplicated.html" rel="noopener ugc nofollow" target="_blank">duplicated()</a></code>方法来完成，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox my l"/></div></figure><p id="a5f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当有重复值时，<code class="fe nq nr ns nt b">keep</code>用于指示标记哪些具体的重复值。</p><ol class=""><li id="fb1e" class="nw nx iq ky b kz la lc ld lf ny lj nz ln oa lr ob oc od oe bi translated"><code class="fe nq nr ns nt b">keep = "first"</code>:(默认)将所有重复标记为<code class="fe nq nr ns nt b">True</code>，第一个<strong class="ky ir">出现的</strong>除外。</li><li id="2eae" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated"><code class="fe nq nr ns nt b">keep = "last"</code>:将所有重复标记为<code class="fe nq nr ns nt b">True</code>，最后一个出现的<strong class="ky ir">除外。</strong></li><li id="af4e" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated"><code class="fe nq nr ns nt b">keep = False</code>:将所有重复标记为<code class="fe nq nr ns nt b">True</code>。</li></ol><p id="e351" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以过滤所有只出现一次的行，方法是将布尔序列作为过滤熊猫数据帧的标志，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om my l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/3c9f87982d3273661bc09c705ab3537b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q3H0p09M5KjkOt9ARnhqnQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">无重复的过滤数据帧(图片由作者提供)</p></figure><p id="bed1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要检查列子集上的重复项，请将列列表作为<code class="fe nq nr ns nt b">duplicated()</code>方法的<code class="fe nq nr ns nt b">subset</code>参数传递，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox my l"/></div></figure><p id="8157" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如下所示，使用上述布尔序列过滤数据帧，输出代码后的数据帧:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu my l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/4329d02566c88adf50c1ace2bbc7ac68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rXX-nYUl2v2CeTAmziPOzw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">考虑两列的重复数据的过滤数据帧(图片由作者提供)</p></figure><ul class=""><li id="0d68" class="nw nx iq ky b kz la lc ld lf ny lj nz ln oa lr ow oc od oe bi translated"><strong class="ky ir">删除重复项</strong></li></ul><p id="2f81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了使用上面讨论的布尔标签来标记潜在的重复之外，可能还需要去除重复。重申一下，我特别为“处理重复数据”一节引用的数据只有十行。如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/ed94d7819d02398d9d9afab4f7c8d4d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UJBTlPzlJ5-DI4tycsGMOA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">带有副本的数据帧(图片由作者提供)</p></figure><p id="3ada" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用如下所示的<code class="fe nq nr ns nt b">drop_duplicates()</code>方法，根据所有列中的值或列的子集来删除重复的行:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om my l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/40e7ed9b7c1f0dccb70fdcabff3bfd8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_c9Tl6rqKYvMOyyOjCsEGQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">删除重复行后的数据帧(作者图片)</p></figure><p id="12ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与<code class="fe nq nr ns nt b">duplicated()</code>类似，<code class="fe nq nr ns nt b">keep</code>参数用于指示您想要保留哪些特定的副本。</p><ol class=""><li id="1aff" class="nw nx iq ky b kz la lc ld lf ny lj nz ln oa lr ob oc od oe bi translated"><code class="fe nq nr ns nt b">keep = "first"</code>:(默认)删除除第一个出现的<strong class="ky ir">之外的所有重复。</strong></li><li id="7e08" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated"><code class="fe nq nr ns nt b">keep = "last"</code>:删除除最后一次出现的<strong class="ky ir">之外的所有重复。</strong></li><li id="525b" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated"><code class="fe nq nr ns nt b">keep = False</code>:删除所有重复项。</li></ol><p id="9de1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要根据列子集中的值删除重复项，请将列列表作为<code class="fe nq nr ns nt b">subset</code>参数传递给<code class="fe nq nr ns nt b">drop_duplicates()</code>方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om my l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/6a1d5aa577fe9060b8511d643a79e623.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mZ4jQzyr6ChoX8R0B9Iq4w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">删除重复行后的数据帧，考虑两列(图片由作者提供)</p></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="e087" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总之，在这篇文章中，我介绍了Pandas中一些流行的方法，用于表格数据的有效数据分析。虽然这篇文章将有助于您熟悉这些方法的语法，但我强烈建议您自己下载一个数据集，并在jupyter笔记本上进行实验。</p><p id="5300" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，没有比参考熊猫官方文件更好的地方了<a class="ae kv" href="https://pandas.pydata.org/docs/" rel="noopener ugc nofollow" target="_blank">这里</a>获得熊猫各种有效方法的基础和实用知识。Pandas的官方文档提供了一个函数接受的每个参数的详细解释，以及一个实际的例子，在我看来，这是获得初级和高级Pandas专业知识的一个很好的方法。</p><p id="8e85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">附注:我在这篇文章中只能介绍五种方法。我将很快在另一个帖子中发布下一组有效数据分析的Pandas方法:)。同时，如果你喜欢读这篇文章，我相信你也会喜欢下面的文章:</p><div class="oy oz gp gr pa pb"><a rel="noopener follow" target="_blank" href="/20-of-pandas-functions-that-data-scientists-use-80-of-the-time-a4ff1b694707"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd ir gy z fp pg fr fs ph fu fw ip bi translated">数据科学家80%的时间使用熊猫20%的功能</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">将帕累托法则运用于熊猫图书馆</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">towardsdatascience.com</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp kp pb"/></div></div></a></div><div class="oy oz gp gr pa pb"><a href="https://medium.com/@avi_chawla/top-ai-resources-you-must-follow-if-you-are-into-ai-19f657697c41" rel="noopener follow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd ir gy z fp pg fr fs ph fu fw ip bi translated">如果你对人工智能感兴趣，你必须关注的顶级人工智能资源</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">如何跟上最新的机器学习进展</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">medium.com</p></div></div><div class="pk l"><div class="pq l pm pn po pk pp kp pb"/></div></div></a></div><p id="c650" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>