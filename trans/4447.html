<html>
<head>
<title>Monte Carlo Simulation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">蒙特 卡罗模拟</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/monte-carlo-simulation-5e58f054bebb#2022-10-03">https://towardsdatascience.com/monte-carlo-simulation-5e58f054bebb#2022-10-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2e06" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">第四部分:回报率</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d76d3974d047307a23f32967f1691d12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3WiWxkPaTZ8SYpIw"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@theshubhamdhage?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> GuerrillaBuzz Crypto PR </a>拍摄的照片</p></figure><p id="0bf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">蒙特卡罗方法是一组基于重复随机抽样确定多种可能结果概率的数值技术<strong class="lb iu">。这是一个非常简单而有效的工具，用于解决工程、科学、商业和管理问题。<strong class="lb iu">蒙特卡罗模拟(MCS) </strong>是一种处理静态、离散、随机模型的特殊技术，试图解决优化问题。你可以阅读我以前的文章(<a class="ae ky" rel="noopener" target="_blank" href="/monte-carlo-simulation-2b24fc810683"> MCS第一部分</a>、<a class="ae ky" href="https://medium.com/p/8db846f3d8ed#09a4-6a25f853d2de" rel="noopener"> MCS第二部分、</a>、<a class="ae ky" rel="noopener" target="_blank" href="/monte-carlo-simulation-7c198d01c531"> MCS第三部分</a>)了解更多关于该技术的细节。</strong></p><p id="02eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了创建MCS，您必须执行以下三(或四)个基本步骤:</p><p id="26db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1.建立数学模型:定义将输入变量与输出变量相关联的适当公式或方程。习惯上，MCS涉及的数学模型从基本的商业公式到复杂的科学方程。</p><p id="d950" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.确定输入值:当我们处理随机变量时，我们必须确定它们的概率分布(将历史或经验数据拟合到相应的理论或经验分布)。</p><p id="e355" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.为每个随机输入变量创建一个非常大的数据集。<strong class="lb iu">如本文和之前文章所述，通过对算法进行适当编码，可以绕过</strong>这一步。</p><p id="971c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.使用大量随机输入数据复制模拟，以获得输出或结果变量的随机值。使用统计方法计算结果的一些描述性统计度量(均值、中值、置信区间、偏度、峰度)。使用图表库分析输出，特别是绘制直方图来显示随机输出的基本频率分布。</p><h1 id="d4e4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">根据收益率选择产品</strong></h1><p id="b3e0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">蒙特卡洛模拟的另一个实际应用包括根据不同产品相应的回报率在它们之间进行选择。回报率是特定投资在特定时期内的净收益或净损失。</p><p id="2092" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有可能只生产三种产品中的一种。我们知道每种产品的售价、年销售额和成本，以及各自的初始投资。</p><p id="6d3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是计算收益率(RoR)的经典公式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/422a7003cdeb1d1ed16d35be8b267b61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1KJpONwrnj38UhuYnAyrjQ.png"/></div></div></figure><p id="9771" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们知道我们的成本和销售预测并不准确；有一些随机组件可以修改它们的值。因此，在做出决策之前，开发一个蒙特卡罗模拟来帮助确定最佳解决方案是很方便的。</p><p id="7ed2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于历史数据，我们假设销售额正态分布，标准差等于预测年值的10%。我们还假设年度成本均匀分布在预测年度价值的+10%和-10%之间。</p><p id="dbbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以使用以下Python代码进行计算:</p><p id="ad30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们导入了几个Python库:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="e43e" class="my lw it mu b gy mz na l nb nc"><a class="ae ky" href="http://twitter.com/author" rel="noopener ugc nofollow" target="_blank">@author</a>: darwt<br/>"""</span><span id="14ac" class="my lw it mu b gy nd na l nb nc"># Import Modules<br/> <br/>import numpy  as np</span><span id="4840" class="my lw it mu b gy nd na l nb nc">from scipy import stats<br/>from scipy.stats import sem</span><span id="2a26" class="my lw it mu b gy nd na l nb nc">import matplotlib.pyplot as plt<br/>from matplotlib.patches import Rectangle<br/>from prettytable import PrettyTable<br/>  <br/>your_path = 'your_path'</span></pre><p id="e57f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在初始化模块中，我们指出了产品销售价格、预测的年销售额、预测的年成本以及相应的初始投资。我们还指出了正态分布和均匀分布的相应参数。基于几次试运行，我们决定对生产运行使用3000次复制。最终置信区间的置信水平为95%。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="1243" class="my lw it mu b gy mz na l nb nc"># initialization module<br/> <br/>Number_of_Prods = 3</span><span id="0f47" class="my lw it mu b gy nd na l nb nc">Prod_Text          = ["Prod. 1","Prod. 2", "Prod. 3"]<br/>Prod_Selling_Price = [54,12,5100] <br/>Prod_Yearly_Sales  = [10000, 500000, 200]<br/>Prod_Yearly_Cost   = [450000,5700000,750000] <br/>Prod_Init_Invest   = [960000,2400000,1500000]</span><span id="c4b8" class="my lw it mu b gy nd na l nb nc">Sales_std_dev = 0.1<br/>Cost_unif_scale = 0.2</span><span id="69a5" class="my lw it mu b gy nd na l nb nc">Number_of_Replications = 3000<br/>confidence = 0.95</span></pre><p id="f823" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MCS背后的逻辑在下面几行代码中描述。我们在这些方面发展了重复随机抽样。每个样品的回报率(<em class="ne"> ror </em>)用前面指出的公式计算。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="fca8" class="my lw it mu b gy mz na l nb nc">list_of_rors = []<br/>for j in range(Number_of_Prods):<br/>    list_of_rors.append([])<br/>    for run in range(Number_of_Replications):<br/>        cost = np.random.uniform(Prod_Yearly_Cost[j]*(1-Cost_unif_scale/2), Prod_Yearly_Cost[j]*(1+Cost_unif_scale/2), 1)<br/>        sale = np.random.normal(loc= Prod_Yearly_Sales[j], scale =Prod_Yearly_Sales[j]*Sales_std_dev, size =1)<br/>        ror  = round(float((Prod_Selling_Price[j] * sale - cost)/ Prod_Init_Invest[j]),4)<br/>        <br/>        list_of_rors[j].append(ror)</span></pre><p id="6acf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用NumPy和SciPy来计算经典的描述性统计量。然后，我们使用库<em class="ne"> PrettyTable </em>来打印每个产品的统计报告。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="1525" class="my lw it mu b gy mz na l nb nc">    media = round(float(np.mean(list_of_rors[j])),3)<br/>    stand = round(float(np.std(list_of_rors[j])),3)<br/>    var   = round(float(np.var(list_of_rors[j])),3) <br/>    std_error = round(float(sem(list_of_rors[j])),3)<br/>    <br/>    median = round(float(np.median(list_of_rors[j])),3)<br/>    skew   = round(float(stats.skew(list_of_rors[j])),4)<br/>    kurt   = round(float(stats.kurtosis(list_of_rors[j])),4)<br/>    <br/>    dof  = Number_of_Replications - 1    <br/>    t_crit = np.abs(stats.t.ppf((1-confidence)/2,dof))<br/>    <br/>    half_width=round(stand*t_crit/np.sqrt(Number_of_Replications),4)  <br/>    inf = media - half_width<br/>    sup = media + half_width  <br/>                          <br/>    inf = round(float(inf),4)<br/>    sup = round(float(sup),4)<br/>            <br/>    t = PrettyTable(['Statistic', 'Value'])<br/>    t.add_row(['Product', j+1])<br/>    t.add_row(['Mean', media])<br/>    t.add_row(['Median', median])<br/>    t.add_row(['Variance', var])<br/>    t.add_row(['Stand Dev', stand])<br/>    t.add_row(['Skewness', skew])<br/>    t.add_row(['Kurtosis', kurt])<br/>    t.add_row(['Half Width', half_width])<br/>    t.add_row(['CI inf', inf])<br/>    t.add_row(['CI sup', sup])<br/>     <br/>    print(t)</span></pre><p id="e75c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们用Matplotlib编码了一个<strong class="lb iu">重叠阶梯直方图</strong>，以显示三种产品的RoR的频率分布:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="fa23" class="my lw it mu b gy mz na l nb nc"># Overlapping Step Histograms</span><span id="8ee5" class="my lw it mu b gy nd na l nb nc">n_bins = 20<br/>list_of_colors = ['red', 'darkblue', 'green']</span><span id="316c" class="my lw it mu b gy nd na l nb nc">fig, ax = plt.subplots(figsize=(8, 6))<br/>ax.set_title('Frequency Chart')<br/>ax.set_ylabel('Counts')<br/>ax.set_xlabel('U$S')<br/>ax.grid(axis = 'y')</span><span id="3c78" class="my lw it mu b gy nd na l nb nc">for j in range(Number_of_Prods):<br/>    ax.hist(list_of_rors[j],  histtype ='step', <br/>            bins= n_bins, stacked = True, <br/>            fill = False, edgecolor= list_of_colors[j],<br/>            density = False)</span><span id="0aa0" class="my lw it mu b gy nd na l nb nc"># create legends<br/>cmap = plt.get_cmap('jet')<br/>low =  cmap(0.5)<br/>medium=cmap(0.25)<br/>high = cmap(0.8)</span><span id="e2a5" class="my lw it mu b gy nd na l nb nc">handles = [Rectangle((0,0),1,1,color=c,ec="k") for c in [low,medium,high]]<br/>labels  = Prod_Text<br/>plt.legend(handles, labels)<br/>         <br/>plt.savefig(your_path +'MC4',bbox_inches='tight', dpi=150)<br/>plt.show()</span></pre><h1 id="c675" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">输出分析</strong></h1><p id="8cfc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">每种产品我们复制了3000份。我们将为每个样本计算的RoR添加到列表<em class="ne"> list_of_rors[j] </em>中。然后，我们计算了经典的统计度量，并用相应的<em class="ne">统计报告显示出来:</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/820870b5635e4eeb5437007f2a76e137.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*0fMinwQ6hrk5Ynw-PGgqOA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者用PrettyTable做的。</p></figure><p id="d0df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">图1将每种产品的频率分布显示为重叠的阶梯直方图。请记住，重叠直方图用于比较连续变量在两个或更多类别中的频率分布。强烈建议使用阶跃直方图同时比较两个以上的频率分布，以避免图表混乱。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/84e5484574652420dadbdd911586005e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ea3ZKyXnvpv50vGbf0LG_Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1:作者用Matplotlib做的。</p></figure><p id="7b80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是你做决定的时候了:如果你是一个风险承受能力强的投资者，产品2为你提供了最高的正回报率，但也很有可能带来重大损失。另一方面，如果你是一个规避风险的投资者，产品1为你提供了一个相对较低的回报率，但物质损失的可能性最小。</p><p id="c941" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是如何使用蒙特卡罗模拟来预测具有随机组件的真实世界系统的可能结果范围的另一个例子。</p><p id="bfee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要忘记给小费，尤其是当你把文章添加到列表中的时候。</p></div></div>    
</body>
</html>