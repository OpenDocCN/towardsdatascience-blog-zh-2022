<html>
<head>
<title>Stop Hardcoding Your Unit Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止硬编码你的单元测试</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/stop-hardcoding-your-unit-tests-e6643dfd254b#2022-12-28">https://towardsdatascience.com/stop-hardcoding-your-unit-tests-e6643dfd254b#2022-12-28</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="9ba5" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/tag/unit-testing" rel="noopener">单元测试</a></h2><div class=""/><div class=""><h2 id="7027" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">使用假设在 Python 中进行基于属性的测试指南</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/10c68b026a9616695cc49b8e07f7775c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mJ9AWsCfUwzM5QWQ"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">照片由<a class="ae li" href="https://unsplash.com/@r3dmax?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔纳森派</a>在<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="47ad" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi mf translated">数据科学家的工作有很多方面:他们必须理解业务问题，知道他们的算法和统计数据，并编写记录良好和经过测试的代码，等等。这是一项艰巨的任务，考虑到你有限的时间，你经常要决定优先做什么。</p><p id="05bf" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">从我的经验来看，编码部分通常会被忽略一点——代码在一些笔记本中被原型化，然后在某个时候，它运行<em class="mo">足够好</em>，就是这样。这也发生在我身上。我甚至能理解这一点:记录东西一点也不好玩，但是没有它，没有人(包括你自己)能理解你的代码，它可能会在将来被重写，即使你写了有史以来最好的代码。所以，即使代码文档不是本文的重点，仍然要用<strong class="ll je">文档化你的代码</strong>！我现在比较感兴趣的是<strong class="ll je">代码测试</strong>位。</p><h1 id="982f" class="mp mq iu bd mr ms mt mu mv mw mx my mz kj na kk nb km nc kn nd kp ne kq nf ng bi translated">代码测试</h1><p id="55a1" class="pw-post-body-paragraph lj lk iu ll b lm nh ke lo lp ni kh lr ls nj lu lv lw nk ly lz ma nl mc md me in bi translated">您应该始终测试您的代码，以获得信心，确信它确实做了您所期望的事情。</p><blockquote class="nm"><p id="98e3" class="nn no iu bd np nq nr ns nt nu nv me dk translated">没有适当的测试，您的代码可能会做错事情，并且您的分析会给出误导性的结果。</p></blockquote><p id="10ae" class="pw-post-body-paragraph lj lk iu ll b lm nw ke lo lp nx kh lr ls ny lu lv lw nz ly lz ma oa mc md me in bi translated">那么，如何测试你的代码呢？很有可能你已经用<a class="ae li" href="https://docs.python.org/3/library/unittest.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ll je"> unittest </strong> </a>或者<a class="ae li" href="https://docs.pytest.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll je"> pytest </strong> </a>写过一些基本的测试。即使没有，也请继续读下去，因为我将使用一个小例子来解释它是如何工作的。然后，我们可以将这种传统的测试方法(基于实例的测试方法)与基于属性的测试方法进行比较，这是本文的重点。</p></div><div class="ab cl ob oc hy od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="in io ip iq ir"><p id="acd7" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">作为一个运行示例，让我们使用一个<strong class="ll je">时间训练测试分割</strong>的实现。它应该做到以下几点:鉴于…</p><ul class=""><li id="0e59" class="oi oj iu ll b lm ln lp lq ls ok lw ol ma om me on oo op oq bi translated">熊猫数据帧<code class="fe or os ot ou b">data</code>包含一个名为<em class="mo">日期</em>的列</li><li id="8f71" class="oi oj iu ll b lm ov lp ow ls ox lw oy ma oz me on oo op oq bi translated">一个字符串变量<code class="fe or os ot ou b">split_date</code></li></ul><p id="0f44" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">输出两个熊猫数据帧，</p><ul class=""><li id="e78d" class="oi oj iu ll b lm ln lp lq ls ok lw ol ma om me on oo op oq bi translated">包含部分<code class="fe or os ot ou b">data</code>的<strong class="ll je">列车</strong>数据帧，其中<em class="mo">日期</em>列中的值在 T1 之前<strong class="ll je"/></li><li id="2328" class="oi oj iu ll b lm ov lp ow ls ox lw oy ma oz me on oo op oq bi translated">一个<strong class="ll je">测试</strong>数据帧，包含<code class="fe or os ot ou b">data</code>的部分，其中<em class="mo">日期</em>列中的值在 T3 之后<strong class="ll je">到来。</strong></li></ul><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pa"><img src="../Images/13e6ba5478320e32fff93149d0253bc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nyHvUXGcGMaQF-ZUi8Zm7g.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">图片由作者提供。</p></figure><p id="240e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">很简单，对吧？现在，在测试该函数之前，我们必须首先实现它:</p><pre class="kt ku kv kw gu pb ou pc bn pd pe bi"><span id="8d35" class="pf mq iu ou b be pg ph l pi pj">def temporal_train_test_split(data, split_date):<br/>    train = data.query("date &lt; @split_date")<br/>    test = data.query("date &gt; @split_date")<br/><br/>    return train, test</span></pre><blockquote class="pk pl pm"><p id="8571" class="lj lk mo ll b lm ln ke lo lp lq kh lr pn lt lu lv po lx ly lz pp mb mc md me in bi translated"><strong class="ll je"> <em class="iu">注:</em> </strong> <em class="iu">代码中有错误，但我们姑且假装忽略了。</em></p></blockquote><h2 id="52d2" class="pq mq iu bd mr pr ps dn mv pt pu dp mz ls pv pw nb lw px py nd ma pz qa nf ja bi translated">基于实例的测试</h2><p id="10b3" class="pw-post-body-paragraph lj lk iu ll b lm nh ke lo lp ni kh lr ls nj lu lv lw nk ly lz ma nl mc md me in bi translated">为了测试代码，您通常会硬编码一些输入数据，对其应用函数，并用硬编码的预期输出来检查它。您可以像这样测试上图中的示例:</p><pre class="kt ku kv kw gu pb ou pc bn pd pe bi"><span id="5df1" class="pf mq iu ou b be pg ph l pi pj">import pandas as pd<br/><br/><br/>#function we want to test<br/>def temporal_train_test_split(data, split_date):<br/>    train = data.query("date &lt; @split_date")<br/>    test = data.query("date &gt; @split_date")<br/><br/>    return train, test<br/><br/># testing function<br/>def test_temporal_train_test_split():<br/>    data = pd.DataFrame(<br/>        {<br/>            "date": [<br/>                "1988-07-31",<br/>                "2022-12-24",<br/>                "2018-03-18",<br/>                "2018-03-19",<br/>                "1994-02-25",<br/>            ],<br/>            "x1": [12, -1, 1, 123, -7],<br/>            "x2": ["a", "d", "c", "a", "b"],<br/>        }<br/>    )<br/><br/>    split_date = "2000-01-01"<br/><br/>    expected_output_train = pd.DataFrame(<br/>        {<br/>            "date": ["1988-07-31", "1994-02-25"],<br/>            "x1": [12, -7],<br/>            "x2": ["a", "b"]<br/>        },<br/>        index=[0, 4],<br/>    )<br/><br/>    expected_output_test = pd.DataFrame(<br/>        {<br/>            "date": ["2022-12-24", "2018-03-18", "2018-03-19"],<br/>            "x1": [-1, 1, 123],<br/>            "x2": ["d", "c", "a"],<br/>        },<br/>        index=[1, 2, 3],<br/>    )<br/><br/>    train, test = temporal_train_test_split(data, split_date)<br/><br/>    assert train.equals(expected_output_train)<br/>    assert test.equals(expected_output_test)</span></pre><p id="94e7" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">通过<code class="fe or os ot ou b">pip install pytest</code>安装 pytest 后，将上述代码保存在<code class="fe or os ot ou b">test_temporal_train_test_split.py</code>等文件中，并通过<code class="fe or os ot ou b">pytest test_temporal_train_test_split.py</code>执行。pytest 随后将运行测试，并报告测试成功。很好，所以我们可以对我们的代码按预期工作更有信心了！</p></div><div class="ab cl ob oc hy od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="in io ip iq ir"><p id="acc7" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">但是，您可能已经注意到，这个测试并没有涵盖这个函数可能接收的各种输入。这只是一个偶然发生的情况。或许你还会错过一些<strong class="ll je">边缘情况</strong>，在那里你的代码可能会中断。</p><p id="02a9" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">你能做的下一件最好的事情是定义更多的输入/输出对来增加一点覆盖范围，但是这真的没有意思，因为你必须硬编码许多数据帧。因为基于实例的测试是如此乏味，如果你查看测试文件，通常你最多只能看到少数硬编码的例子。</p><p id="6bf3" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">不要误解我的意思，即使像这样的小测试也比没有测试要好，但是我们仍然可以使用基于属性的测试做得更好。</p><h2 id="4c27" class="pq mq iu bd mr pr ps dn mv pt pu dp mz ls pv pw nb lw px py nd ma pz qa nf ja bi translated">基于属性的测试</h2><p id="a6bd" class="pw-post-body-paragraph lj lk iu ll b lm nh ke lo lp ni kh lr ls nj lu lv lw nk ly lz ma nl mc md me in bi translated">如果你想做基于属性的测试，首先你必须花几分钟时间想想你想从输出中看到什么属性。有时这可能很难做到，但在我们的情况下，这很容易。输出<code class="fe or os ot ou b">train</code>和<code class="fe or os ot ou b">test</code>应具有以下属性:</p><ol class=""><li id="d883" class="oi oj iu ll b lm ln lp lq ls ok lw ol ma om me qb oo op oq bi translated"><code class="fe or os ot ou b">train</code>中的<em class="mo">日期</em>栏应始终小于或等于<code class="fe or os ot ou b">split_date</code>，并且<code class="fe or os ot ou b">test</code>中的<em class="mo">日期</em>栏应始终大于<code class="fe or os ot ou b">split_date</code>。</li><li id="d816" class="oi oj iu ll b lm ov lp ow ls ox lw oy ma oz me qb oo op oq bi translated">如果您连接<code class="fe or os ot ou b">train</code>和<code class="fe or os ot ou b">test</code>，您应该接收回输入数据帧，即没有行或列被添加或丢失，也没有单元格被更改。</li></ol><p id="2b30" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这实际上是时间训练测试分割的本质，定义属性，我们可以直接测试它。</p><pre class="kt ku kv kw gu pb ou pc bn pd pe bi"><span id="c2cf" class="pf mq iu ou b be pg ph l pi pj">def test_temporal_train_test_split_property():<br/>    data = pd.DataFrame(<br/>        {<br/>            "date": [<br/>                "1988-07-31",<br/>                "2022-12-24",<br/>                "2018-03-18",<br/>                "2018-03-19",<br/>                "1994-02-25",<br/>            ],<br/>            "x1": [12, -1, 1, 123, -7],<br/>            "x2": ["a", "d", "c", "a", "b"],<br/>        }<br/>    )<br/><br/>    split_date = "2000-01-01"<br/><br/>    train, test = temporal_train_test_split(data, split_date)<br/>    concatenated = (<br/>        pd.concat([train, test])<br/>        .sort_values(["date", "x1", "x2"]) # see note below<br/>        .reset_index(drop=True)<br/>    )<br/>    sorted_input = data.sort_values(["date", "x1", "x2"]).reset_index(drop=True) # see note below<br/><br/>    assert (train["date"] &lt;= split_date).all() # 1st property<br/>    assert (test["date"] &gt; split_date).all()   # 1st property<br/>    assert concatenated.equals(sorted_input)   # 2nd property</span></pre><blockquote class="pk pl pm"><p id="c24b" class="lj lk mo ll b lm ln ke lo lp lq kh lr pn lt lu lv po lx ly lz pp mb mc md me in bi translated"><strong class="ll je"> <em class="iu">注意:</em> </strong> <em class="iu">你必须对数据帧进行排序，因为将一个数据帧分割成训练和测试，再将它们放在一起可能会改变行的顺序。但即使在这种情况下，检查应该通过，顺序并不重要。</em></p></blockquote><p id="68c7" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这已经好得多了，因为你不再需要硬编码输出。您只需要定义一些输入数据，让属性来处理其余的事情。这甚至为另一个诡计打开了大门:</p><blockquote class="nm"><p id="1b97" class="nn no iu bd np nq nr ns nt nu nv me dk translated">生成一堆随机输入，然后运行属性检查，这不是很好吗？</p></blockquote><p id="d91f" class="pw-post-body-paragraph lj lk iu ll b lm nw ke lo lp nx kh lr ls ny lu lv lw nz ly lz ma oa mc md me in bi translated">这个想法很简单，我打赌你可以用一些自定义代码来实现。然而，我更愿意向您展示一个整洁的库，它可以帮助您实现这个想法，即使您将会看到在它的顶部有一个樱桃！它被称为<a class="ae li" href="https://hypothesis.readthedocs.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll je">假设</strong> </a>，我将在文章的其余部分向您展示它是如何工作的。</p><h1 id="59d8" class="mp mq iu bd mr ms mt mu mv mw mx my mz kj na kk nb km nc kn nd kp ne kq nf ng bi translated">基于假设的类固醇性质检验</h1><p id="bf98" class="pw-post-body-paragraph lj lk iu ll b lm nh ke lo lp ni kh lr ls nj lu lv lw nk ly lz ma nl mc md me in bi translated">首先，用一个简单的<code class="fe or os ot ou b">pip install hypothesis</code>安装这个库。在我们写测试之前，让我们先玩一会儿。假设有一点很棒，那就是产生随机数据。首先，让我们导入库:</p><pre class="kt ku kv kw gu pb ou pc bn pd pe bi"><span id="d155" class="pf mq iu ou b be pg ph l pi pj">import hypothesis.strategies as st</span></pre><h2 id="7def" class="pq mq iu bd mr pr ps dn mv pt pu dp mz ls pv pw nb lw px py nd ma pz qa nf ja bi translated">入门指南</h2><p id="0bf0" class="pw-post-body-paragraph lj lk iu ll b lm nh ke lo lp ni kh lr ls nj lu lv lw nk ly lz ma nl mc md me in bi translated">现在让我们做一个非常简单的任务:<strong class="ll je">“生成随机整数！”</strong>。</p><pre class="kt ku kv kw gu pb ou pc bn pd pe bi"><span id="4add" class="pf mq iu ou b be pg ph l pi pj">integer_strategy = st.integers()<br/><br/>for _ in range(5):<br/>    print(integer_strategy.example())<br/><br/># Example output:<br/># 26239<br/># -32170<br/># 8226<br/># 12448<br/># -25828</span></pre><p id="19dc" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这会给你一些随机的整数。好吧，但是<a class="ae li" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll je"> numpy </strong> </a>也可以这么做，何必呢？看看另一个例子:<strong class="ll je">“生成随机整数列表！”</strong>。</p><pre class="kt ku kv kw gu pb ou pc bn pd pe bi"><span id="4f8c" class="pf mq iu ou b be pg ph l pi pj">integer_list_strategy = st.lists(st.integers())<br/><br/>for _ in range(5):<br/>    print(integer_list_strategy.example())<br/><br/># Example output: <br/># [-14, -2189, 9898, 116]<br/># [115252802955829576656830209704323089026, 12850, -22, -23389, -37044854417799513209994526228023296414, 9033, -25431, 111, 1650017586, 2100275240795033860, 14027, 9549, 119, 32276, 3287]<br/># [867485840, -16288]<br/># [867485840, -16288]<br/># [23623, 18045420794467201802863702411254425247, 11413941429584508497211673000716218542, -35326783386759048949361175218368769135, 25, 18663, 85, 29311, -54]</span></pre><p id="90ba" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这个更有意思一点。不需要太多的努力，我们就可以生成一些随机列表，用来测试排序算法。</p><p id="acb0" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们可以结合更多的这些<em class="mo">策略</em>来做更疯狂的事情，比如:<strong class="ll je">“生成包含随机整数和布尔的元组列表！”</strong>。</p><pre class="kt ku kv kw gu pb ou pc bn pd pe bi"><span id="66db" class="pf mq iu ou b be pg ph l pi pj">strategy = st.lists(st.tuples(st.integers(), st.booleans()))<br/><br/>for _ in range(5):<br/>    print(strategy.example())<br/><br/># Example output:<br/># [(-28942, True), (39, True), (2034980965, True), (-633849778, False), (-111, False), (-25, True), (15592, True), (-6976, False), (-29086, True), (20529, False), (-28691, True), (-6358763519719057102, False)]<br/># [(-83, False), (0, True), (16, False), (-21, True), (32707, True), (-45239080, True), (115, False), (567947076, True), (-7363, False)]<br/># [(-100, False), (-14515, True), (32539, False), (-22134, True), (-1419424594, False), (-21631, False)]<br/># [(3401224866052712356, True), (-663846088058567152, True), (26848, False), (71, True), (-4004, True), (-84, True), (5403, True), (31368, False)]<br/># [(21237, False), (-29568, True), (978088832, False), (-1095376597, True)]</span></pre><p id="4774" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">天空是无限的！您可以将关键字传递给所有的策略，例如，限制整数的大小或列表长度。</p><pre class="kt ku kv kw gu pb ou pc bn pd pe bi"><span id="c007" class="pf mq iu ou b be pg ph l pi pj">strategy = st.lists(<br/>    st.tuples(<br/>        st.integers(min_value=0, max_value=5),<br/>        st.booleans()<br/>        ),<br/>    min_size=2, max_size=4<br/>    )<br/><br/>for _ in range(5):<br/>    print(strategy.example())<br/><br/># Example output:<br/># [(0, True), (0, True), (0, True), (0, True)]<br/># [(5, False), (3, True), (2, True), (5, True)]<br/># [(2, True), (4, True), (1, True), (2, False)]<br/># [(2, False), (2, True), (2, True), (2, True)]<br/># [(1, False), (5, False), (2, True)]</span></pre><p id="e6e2" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">还有更多的策略，我鼓励你阅读假设文档来了解更多的信息，但是现在让我们专注于我们的用例。</p><h2 id="7c44" class="pq mq iu bd mr pr ps dn mv pt pu dp mz ls pv pw nb lw px py nd ma pz qa nf ja bi translated">用假设测试我们的代码</h2><p id="c4d4" class="pw-post-body-paragraph lj lk iu ll b lm nh ke lo lp ni kh lr ls nj lu lv lw nk ly lz ma nl mc md me in bi translated">提醒一下，我们的时间训练测试分割有两个输入:</p><ul class=""><li id="4ec9" class="oi oj iu ll b lm ln lp lq ls ok lw ol ma om me on oo op oq bi translated">熊猫数据帧<code class="fe or os ot ou b">data</code>包含一个名为<em class="mo">的日期</em>的列</li><li id="cf70" class="oi oj iu ll b lm ov lp ow ls ox lw oy ma oz me on oo op oq bi translated">一个字符串变量<code class="fe or os ot ou b">split_date</code></li></ul><p id="68a6" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">让我们首先处理生成随机日期，因为这更容易。你可能已经猜到你可以这样做:</p><pre class="kt ku kv kw gu pb ou pc bn pd pe bi"><span id="bedd" class="pf mq iu ou b be pg ph l pi pj">date_strategy = st.dates()<br/><br/>for _ in range(5):<br/>    print(date_strategy.example())<br/><br/># Example output:<br/># 1479-03-03<br/># 3285-02-06<br/># 0715-06-28<br/># 6354-02-18<br/># 9276-08-08</span></pre><p id="65e2" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这种策略会产生 Python 日期对象，但是因为我们希望我们的函数以<strong class="ll je">字符串</strong>的形式获取日期，所以我们可以通过</p><pre class="kt ku kv kw gu pb ou pc bn pd pe bi"><span id="439a" class="pf mq iu ou b be pg ph l pi pj">st.dates().map(lambda d: d.strftime("%Y-%m-%d"))</span></pre></div><div class="ab cl ob oc hy od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="in io ip iq ir"><p id="2e05" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">数据框是一种更复杂的数据类型，但是假设让我们在这里有所了解。它提供了几种定义数据框的方法，但是我将使用<code class="fe or os ot ou b">composite</code>装饰器向您展示最通用的一种。</p><p id="04e6" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">以下代码片段</p><ol class=""><li id="728d" class="oi oj iu ll b lm ln lp lq ls ok lw ol ma om me qb oo op oq bi translated">创建随机数量的行，然后</li><li id="4f39" class="oi oj iu ll b lm ov lp ow ls ox lw oy ma oz me qb oo op oq bi translated">创建一定数量的包含日期、整数和字母 a、b、c、d 之一的行，然后</li><li id="3e06" class="oi oj iu ll b lm ov lp ow ls ox lw oy ma oz me qb oo op oq bi translated">用它制作一个熊猫数据框并输出。</li></ol><pre class="kt ku kv kw gu pb ou pc bn pd pe bi"><span id="927a" class="pf mq iu ou b be pg ph l pi pj">@st.composite<br/>def random_dataframe_with_a_date_column_strategy(draw):<br/>    n_rows = draw(st.integers(min_value=0, max_value=100))<br/><br/>    rows = [<br/>        (<br/>            draw(st.dates().map(lambda d: d.strftime("%Y-%m-%d"))),<br/>            draw(st.integers()),<br/>            draw(st.sampled_from(list("abcd"))),<br/>        )<br/>        for _ in range(n_rows)<br/>    ]<br/>    data = pd.DataFrame(rows, columns=["date", "x1", "x2"])<br/><br/>    return data</span></pre><p id="5915" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">注意<code class="fe or os ot ou b">draw</code>在那里的不同出现。你需要这样做，因为像<code class="fe or os ot ou b">range</code>这样的函数需要合适的整数。与任何其他策略一样，您可以</p><pre class="kt ku kv kw gu pb ou pc bn pd pe bi"><span id="c7a5" class="pf mq iu ou b be pg ph l pi pj">random_dataframe_with_a_date_column_strategy().example()</span></pre><p id="8fdb" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">现在来接收一个随机的例子。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj qc"><img src="../Images/e1f8846f15d0a4a5d7b0fb559b29d71f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*a4_83osOaSc4J1ab4shxUg.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">图片由作者提供。</p></figure><p id="a163" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">当然，你可以制作更通用的数据框。我们只是改变了这里的行数，但是您也可以</p><ul class=""><li id="c678" class="oi oj iu ll b lm ln lp lq ls ok lw ol ma om me on oo op oq bi translated">改变列数</li><li id="ef3f" class="oi oj iu ll b lm ov lp ow ls ox lw oy ma oz me on oo op oq bi translated">改变数据类型</li><li id="2332" class="oi oj iu ll b lm ov lp ow ls ox lw oy ma oz me on oo op oq bi translated">改变列名</li></ul><p id="eef5" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">除了别的以外。但我们先来了解一下这个更具体的策略。</p></div><div class="ab cl ob oc hy od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="in io ip iq ir"><p id="17fc" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">太好了，我们现在可以生成随机输入数据了！唯一剩下的事情就是以适当的方式把它输入到我们的测试函数中。幸运的是，假设使这变得非常容易。只需创建另一个名为<code class="fe or os ot ou b">test_temporal_train_test_split_hypothesis.py</code>的文件，然后粘贴以下内容:</p><pre class="kt ku kv kw gu pb ou pc bn pd pe bi"><span id="9d28" class="pf mq iu ou b be pg ph l pi pj">import pandas as pd<br/>from hypothesis import given, note<br/>import hypothesis.strategies as st<br/><br/># Function to test<br/>def temporal_train_test_split(data, split_date):<br/>    train = data.query("date &lt; @split_date")<br/>    test = data.query("date &gt; @split_date")<br/><br/>    return train, test<br/><br/><br/># Strategies<br/>split_date_strategy = st.dates().map(lambda d: d.strftime("%Y-%m-%d"))<br/><br/><br/>@st.composite<br/>def random_dataframe_with_a_date_column_strategy(draw):<br/>    n_rows = draw(st.integers(min_value=0, max_value=100))<br/><br/>    rows = [<br/>        (<br/>            draw(st.dates().map(lambda d: d.strftime("%Y-%m-%d"))),<br/>            draw(st.integers()),<br/>            draw(st.sampled_from(list("abcd"))),<br/>        )<br/>        for _ in range(n_rows)<br/>    ]<br/>    data = pd.DataFrame(rows, columns=["date", "x1", "x2"])<br/><br/>    return data<br/><br/># The actual test<br/>@given(<br/>    data=random_dataframe_with_a_date_column_strategy(), split_date=split_date_strategy<br/>)<br/>def test_temporal_train_test_split(data, split_date):<br/>    note(data) # basically a print function if a test fails<br/>    note(split_date) # basically a print function if a test fails<br/><br/>    train, test = temporal_train_test_split(data, split_date)<br/>    concatenated = (<br/>        pd.concat([train, test])<br/>        .sort_values(["date", "x1", "x2"])<br/>        .reset_index(drop=True)<br/>    )<br/>    sorted_input = data.sort_values(["date", "x1", "x2"]).reset_index(drop=True)<br/><br/>    assert (train["date"] &lt;= split_date).all()<br/>    assert (test["date"] &gt; split_date).all()<br/>    assert concatenated.equals(sorted_input)</span></pre><p id="c7b8" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">您已经知道了关于这段代码的大部分内容。首先，我们定义想要测试的函数以及随机输入的策略。然后我们可以使用来自假设的<code class="fe or os ot ou b">given</code>装饰器进行测试。已经这样了！我们可以让它再次运行</p><pre class="kt ku kv kw gu pb ou pc bn pd pe bi"><span id="dba8" class="pf mq iu ou b be pg ph l pi pj">pytest test_temporal_train_test_split_hypothesis.py</span></pre><blockquote class="nm"><p id="73fc" class="nn no iu bd np nq qd qe qf qg qh me dk translated">默认情况下，这将创建 100 个随机输入并检查属性。</p></blockquote><p id="90f9" class="pw-post-body-paragraph lj lk iu ll b lm nw ke lo lp nx kh lr ls ny lu lv lw nz ly lz ma oa mc md me in bi translated">您可能会看到类似这样的内容:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj qi"><img src="../Images/3b0b0e1e41af23e016106f9c8fab6e56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_AnCH2vjQEQSJxkKmNcZjQ.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">图片由作者提供。</p></figure><p id="4bcf" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">哎呀，我们的函数仍然包含一个错误！假设很好地告诉我们哪些输入产生了错误，因为我们在代码中使用了<code class="fe or os ot ou b">note(data)</code>和<code class="fe or os ot ou b">note(split_date)</code>。</p><h2 id="040a" class="pq mq iu bd mr pr ps dn mv pt pu dp mz ls pv pw nb lw px py nd ma pz qa nf ja bi translated">缩小示例</h2><p id="06c5" class="pw-post-body-paragraph lj lk iu ll b lm nh ke lo lp ni kh lr ls nj lu lv lw nk ly lz ma nl mc md me in bi translated">另一个值得注意的事情是，这个例子很好，很短，所以我们可以直接猜测错误可能是什么。<strong class="ll je">这绝不是巧合。</strong>每当 Hypothesis 发现一个破坏您的代码的例子——在我们的例子中可能是一个包含 98 行的数据帧——它试图简化这个例子，这样它<strong class="ll je">仍然破坏您的代码</strong>，但是从某种意义上说<strong class="ll je">比</strong>小。</p><p id="70ff" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这个过程被称为<strong class="ll je">收缩</strong>，它让人类更容易找到错误的来源。缩水通常让人感觉很自然:</p><ul class=""><li id="c511" class="oi oj iu ll b lm ln lp lq ls ok lw ol ma om me on oo op oq bi translated">缩小数字意味着让它们更接近零</li><li id="b741" class="oi oj iu ll b lm ov lp ow ls ox lw oy ma oz me on oo op oq bi translated">缩减列表意味着让它们更短</li><li id="b82a" class="oi oj iu ll b lm ov lp ow ls ox lw oy ma oz me on oo op oq bi translated">收缩字符串意味着让它们更短</li><li id="0272" class="oi oj iu ll b lm ov lp ow ls ox lw oy ma oz me on oo op oq bi">…</li></ul><p id="317b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">所以，让我们用错误信息来思考一下哪里出错了！</p><h2 id="8e13" class="pq mq iu bd mr pr ps dn mv pt pu dp mz ls pv pw nb lw px py nd ma pz qa nf ja bi translated">修复错误</h2><p id="5ddc" class="pw-post-body-paragraph lj lk iu ll b lm nh ke lo lp ni kh lr ls nj lu lv lw nk ly lz ma nl mc md me in bi translated">我们很容易看到，破坏我们代码的例子有一个<code class="fe or os ot ou b">split_date</code>等于<code class="fe or os ot ou b">data</code>中的日期值，这看起来真的很可疑。在这种情况下，我们的代码可能不起作用。让我们再来看一看:</p><pre class="kt ku kv kw gu pb ou pc bn pd pe bi"><span id="3d39" class="pf mq iu ou b be pg ph l pi pj">def temporal_train_test_split(data, split_date):<br/>    train = data.query("date &lt; @split_date")<br/>    test = data.query("date &gt; @split_date")<br/><br/>    return train, test</span></pre><p id="9dec" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">是的，有道理。我们使用<strong class="ll je"> &lt; </strong>和<strong class="ll je"> &gt; </strong>，但是等于<code class="fe or os ot ou b">split_date</code>的日期会发生什么情况呢？他们只是在我们的版本中被删除了。😖我们可以用一个简单的</p><pre class="kt ku kv kw gu pb ou pc bn pd pe bi"><span id="1b9e" class="pf mq iu ou b be pg ph l pi pj">def temporal_train_test_split(data, split_date):<br/>    train = data.query("date &lt;= @split_date") # fixed<br/>    test = data.query("date &gt; @split_date")<br/><br/>    return train, test</span></pre><p id="adca" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果我们让它再运行一次，现在测试就通过了，太棒了！</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj qj"><img src="../Images/f7122cb3c50216d395ea2e2f7f718421.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*un_k_e8096OksAilAf6uSw.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">图片由作者提供。</p></figure><p id="11d7" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">同样，我想强调的是，即使看起来像是运行了一个测试，实际上<strong class="ll je">运行了 100 个测试</strong>。</p><h2 id="d894" class="pq mq iu bd mr pr ps dn mv pt pu dp mz ls pv pw nb lw px py nd ma pz qa nf ja bi translated">更多功能</h2><p id="10cc" class="pw-post-body-paragraph lj lk iu ll b lm nh ke lo lp ni kh lr ls nj lu lv lw nk ly lz ma nl mc md me in bi translated">您也可以使用<code class="fe or os ot ou b">setting</code>装饰器来更改这个数字，例如:</p><pre class="kt ku kv kw gu pb ou pc bn pd pe bi"><span id="da82" class="pf mq iu ou b be pg ph l pi pj">from hypothesis import settings<br/><br/>@given(<br/>    data=random_dataframe_with_a_date_column_strategy(), split_date=split_date_strategy<br/>)<br/>@settings(max_examples=200) # number of random examples<br/>def test_temporal_train_test_split(data, split_date):<br/>    [...]</span></pre><p id="fe4d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">此外，有时你想确保一些对你来说非常重要的具体例子被覆盖，你不想让它碰运气。在这种情况下，您可以像这样使用<code class="fe or os ot ou b">example</code>装饰器:</p><pre class="kt ku kv kw gu pb ou pc bn pd pe bi"><span id="126f" class="pf mq iu ou b be pg ph l pi pj">from hypothesis import example<br/><br/>@given(<br/>    data=random_dataframe_with_a_date_column_strategy(), split_date=split_date_strategy<br/>)<br/>@example(data=pd.DataFrame(None, columns=["date", "x1", "x2"]), split_date="9999-12-31") # this example is always covered<br/>def test_temporal_train_test_split(data, split_date):<br/>    [...]</span></pre><p id="53ac" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">现在你知道了基于属性的假设测试的基本知识，你可以试着在你的项目中应用它了！</p><h1 id="0725" class="mp mq iu bd mr ms mt mu mv mw mx my mz kj na kk nb km nc kn nd kp ne kq nf ng bi translated">结论</h1><p id="132c" class="pw-post-body-paragraph lj lk iu ll b lm nh ke lo lp ni kh lr ls nj lu lv lw nk ly lz ma nl mc md me in bi translated">测试你的代码是一项单调乏味的任务，但是你仍然必须这样做来发现可能会破坏你的结果的错误。您可以通过提供输入/输出对(示例)来测试您的代码，但是人们倾向于最多只硬编码一小部分示例。这导致覆盖范围很小，您的代码可能仍然不能处理大部分输入，或者一些可能很重要的边缘情况。</p><p id="0ab0" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">基于属性的测试是增加覆盖率的一种便捷方式。它测试随机输入，假设库甚至可以为您提供破坏代码的简单示例，因此修复 bug 变得更加容易。缺点是你必须想出有意义的属性。有时候这很容易，就像我们的时态训练测试分割例子一样。对数字进行排序是基于属性的测试的另一个很好的用例。你只需要检查一下</p><ol class=""><li id="a5d6" class="oi oj iu ll b lm ln lp lq ls ok lw ol ma om me qb oo op oq bi translated">输出中的数字按升序排列</li><li id="7657" class="oi oj iu ll b lm ov lp ow ls ox lw oy ma oz me qb oo op oq bi translated">没有数字被添加或删除。</li></ol><p id="0d3d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><strong class="ll je">🚀尝试实现您选择的排序算法，并使用基于属性的测试来测试它！</strong></p><blockquote class="pk pl pm"><p id="4213" class="lj lk mo ll b lm ln ke lo lp lq kh lr pn lt lu lv po lx ly lz pp mb mc md me in bi translated">复杂性类 NP 中的每个问题实际上都是基于属性的测试的良好候选，因为验证解决方案可以有效地完成。</p></blockquote><p id="fb33" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">但有时可能很难弥补好的属性。有时你也只找到一些，但不是所有的定义属性。在这种情况下，您仍然可以检查您能想到的所有属性，并像在传统的基于示例的测试中一样提供一些手动示例。</p><blockquote class="nm"><p id="bfa8" class="nn no iu bd np nq nr ns nt nu nv me dk translated">没有什么能阻止你同时使用这两种方法！很多时候，这甚至是一件伟大的事情。</p></blockquote></div><div class="ab cl ob oc hy od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="in io ip iq ir"><p id="a981" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我希望你今天学到了新的、有趣的、有用的东西。感谢阅读！</p><p id="d656" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><strong class="ll je">作为最后一点，如果你</strong></p><ol class=""><li id="5148" class="oi oj iu ll b lm ln lp lq ls ok lw ol ma om me qb oo op oq bi translated"><strong class="ll je">想支持我多写点机器学习和</strong></li><li id="b818" class="oi oj iu ll b lm ov lp ow ls ox lw oy ma oz me qb oo op oq bi translated"><strong class="ll je">无论如何都计划获得一个中等订阅，</strong></li></ol><p id="ac0c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><strong class="ll je">为什么不做</strong> <a class="ae li" href="https://dr-robert-kuebler.medium.com/membership" rel="noopener"> <strong class="ll je">通过这个环节</strong> </a> <strong class="ll je">？这将对我帮助很大！😊</strong></p><p id="5e2f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><em class="mo">说白了，给你的价格不变，但大约一半的订阅费直接归我。</em></p><p id="bce3" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">非常感谢，如果你考虑支持我的话！</p><blockquote class="nm"><p id="bfae" class="nn no iu bd np nq nr ns nt nu nv me dk translated">如有任何问题，请在<a class="ae li" href="https://www.linkedin.com/in/dr-robert-k%C3%BCbler-983859150/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上给我写信！</p></blockquote></div></div>    
</body>
</html>