<html>
<head>
<title>Imputation of Missing Data in Tables with DataWig</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用DataWig对表中缺失数据的插补</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/imputation-of-missing-data-in-tables-with-datawig-2d7ab327ece2#2022-08-24">https://towardsdatascience.com/imputation-of-missing-data-in-tables-with-datawig-2d7ab327ece2#2022-08-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5a5c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Python实现Amazon的DataWig来估算表格数据中的缺失值</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a73983185e738e99b9232eb5deae0264.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UDAtYOTEL_y4LlAW"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">亨特·哈里特在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6ed4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现实世界数据集中的缺失值是一种常见现象，给所有数据从业者带来了重大挑战。当数据集包含异构数据类型时，这个问题甚至更具挑战性。</p><p id="afe1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将探讨DataWig如何帮助我们有效且高效地对表格数据中的缺失值进行插补。</p><h2 id="ec20" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">内容</h2><blockquote class="mo mp mq"><p id="f6c6" class="kz la mr lb b lc ld ju le lf lg jx lh ms lj lk ll mt ln lo lp mu lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it"> (1) </em> </strong> <a class="ae ky" href="#f928" rel="noopener ugc nofollow"> <em class="it">缺失数据的类型和插补技巧</em>(可选)</a><em class="it"><br/></em><strong class="lb iu"><em class="it">(2)</em></strong><a class="ae ky" href="#80ce" rel="noopener ugc nofollow"><em class="it">关于Data wig</em></a><em class="it"><br/></em><strong class="lb iu"><em class="it">(3)</em></strong><a class="ae ky" href="#8401" rel="noopener ugc nofollow"><em class="it">Data wig如何工作</em></a><em class="it"><em class="it"><br/></em></em></p></blockquote></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="f928" class="nc lw it bd lx nd ne nf ma ng nh ni md jz nj ka mg kc nk kd mj kf nl kg mm nm bi translated">(1)缺失数据的类型和插补技术</h1><blockquote class="mo mp mq"><p id="439a" class="kz la mr lb b lc ld ju le lf lg jx lh ms lj lk ll mt ln lo lp mu lr ls lt lu im bi translated">(可选底漆)</p></blockquote><p id="69c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始之前，最好了解缺失数据的类型和各种可用的插补技术。为了保持这篇文章的简短，我已经将底漆放在一篇单独的文章中。如果您已经熟悉这些概念，可以跳过这一部分。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="80ce" class="nc lw it bd lx nd ne nf ma ng nh ni md jz nj ka mg kc nk kd mj kf nl kg mm nm bi translated">(2)关于DataWig</h1><p id="c952" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/awslabs/datawig" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">data wig</strong></a><strong class="lb iu"/>由<a class="ae ky" href="https://www.amazon.science/" rel="noopener ugc nofollow" target="_blank"> Amazon Science </a>开发，是一个软件包，它将缺失值插补应用于包含<strong class="lb iu">异构</strong>数据类型的表格，即数字、分类和非结构化文本。</p><p id="8f55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目标是建立一个健壮的、可扩展的框架，允许用户在没有大量工程工作或机器学习背景的情况下估算缺失值。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="8401" class="nc lw it bd lx nd ne nf ma ng nh ni md jz nj ka mg kc nk kd mj kf nl kg mm nm bi translated">(DataWig的工作原理</h1><p id="f235" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">DataWig运行三个组件对异构数据进行插补:<strong class="lb iu">编码、特征器</strong>和<strong class="lb iu">插补器</strong>。</p><p id="4c0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过一个包含<strong class="lb iu">非数字</strong>数据的例子来了解DataWig是如何工作的。假设我们有一个3行的产品目录数据集，其中第三行的'<strong class="lb iu"> <em class="mr"> Color </em> </strong>'列缺少一个值。</p><p id="812b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，'<strong class="lb iu"> <em class="mr">颜色</em> </strong>'列是待估算列(又名<strong class="lb iu">输出</strong>列)，而其他列是<strong class="lb iu">输入</strong>列。</p><p id="7f6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目的是使用前两行(包含完整数据)来训练插补模型，并预测第三行中缺失的'<strong class="lb iu"> <em class="mr">、颜色</em> </strong>'值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/fe77aacec1bc8442e1048488152ae9bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qsl5jgy0CFY2-_NmacQL_Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">改编自<a class="ae ky" href="https://jmlr.org/papers/v20/18-753.html" rel="noopener ugc nofollow" target="_blank"> DataWig JMLR论文</a> |图片在CC-BY 4.0下使用</p></figure><ol class=""><li id="ba81" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated">首先使用<strong class="lb iu">试探法</strong>自动确定列的数据类型。例如，如果一个列的行数至少是唯一值的十倍，则该列被定义为分类而不是纯文本。</li><li id="4b9b" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">使用列编码器将特征转换成数字表示，例如，一键编码。</li><li id="b62c" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">数字格式的列被转换成特征向量。</li><li id="5f60" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">特征向量被连接成潜在的表示，以被解析成用于训练和预测的插补模型。</li></ol></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><p id="2da7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来探索这三个组件:</p><h2 id="5001" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">(一)编码器</h2><p id="d623" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><strong class="lb iu"><em class="mr">column encoder</em></strong>类将原始数据转换成数字表示。不同的数据类型有不同类型的编码器，例如:</p><ul class=""><li id="18a5" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu oh nz oa ob bi translated"><em class="mr">sequential encoder</em>—<strong class="lb iu">字符串</strong>符号(如字符)的序列</li><li id="572d" class="nt nu it lb b lc oc lf od li oe lm of lq og lu oh nz oa ob bi translated"><em class="mr"> BowEncoder </em> —将<strong class="lb iu">字符串</strong>表示为稀疏向量的单词包表示</li><li id="605b" class="nt nu it lb b lc oc lf od li oe lm of lq og lu oh nz oa ob bi translated"><em class="mr">分类编码器</em> —用于分类变量(<strong class="lb iu">一键</strong>编码)</li><li id="2986" class="nt nu it lb b lc oc lf od li oe lm of lq og lu oh nz oa ob bi translated"><em class="mr">数字编码器</em> —用于数值(<strong class="lb iu">数值归一化</strong>)</li></ul></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="4d8b" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">㈡特色化</h2><p id="f798" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">在编码成数字表示之后，下一步是使用特征化器将数据转换成特征向量。</p><p id="c94b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目的是将数据作为矢量表示输入插补模型的计算图，用于训练和预测。</p><p id="8eff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有不同类型的特征来迎合不同的数据类型:</p><ul class=""><li id="4b12" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu oh nz oa ob bi translated"><em class="mr">lstmfeaturer</em>—使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Long_short-term_memory" rel="noopener ugc nofollow" target="_blank"> LSTM </a>将输入序列映射成潜在向量</li><li id="248b" class="nt nu it lb b lc oc lf od li oe lm of lq og lu oh nz oa ob bi translated"><em class="mr">bow featurezer</em>—将字符串数据转换成稀疏向量</li><li id="4a5a" class="nt nu it lb b lc oc lf od li oe lm of lq og lu oh nz oa ob bi translated"><em class="mr">嵌入分类器</em> —将编码的分类数据映射成矢量表示(即嵌入)</li><li id="3a9c" class="nt nu it lb b lc oc lf od li oe lm of lq og lu oh nz oa ob bi translated"><em class="mr">数字分类器</em> —使用完全连接的层提取特征向量</li></ul></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="093e" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">㈢估算者</h2><p id="4dbf" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">最后一部分是创建<strong class="lb iu">插补</strong> <strong class="lb iu">模型</strong>，执行训练，并生成预测以填充缺失值。</p><p id="2235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DataWig采用<a class="ae ky" href="https://stats.stackexchange.com/a/421586/336914" rel="noopener ugc nofollow" target="_blank"> MICE </a>技术进行插补，内部使用的模型是用<a class="ae ky" href="https://mxnet.apache.org/versions/1.9.1/" rel="noopener ugc nofollow" target="_blank"> MXNet </a>在后端训练的神经网络。</p><p id="8608" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，深度学习模型使用包含有用信息的列来估算待估算列中的缺失值。</p><p id="58ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设将有不同的数据类型，适当的损失函数(例如，平方损失或交叉熵损失)也被自动选择。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="39b7" class="nc lw it bd lx nd ne nf ma ng nh ni md jz nj ka mg kc nk kd mj kf nl kg mm nm bi translated">(DataWig的插补性能</h1><p id="dbf6" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">亚马逊科学团队对DataWig进行了评估，将它与五种输入<strong class="lb iu">缺失数值</strong>的流行技术进行了比较。</p><p id="6f7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些其他插补技术包括均值插补、kNN、矩阵分解(MF)和<a class="ae ky" href="https://scikit-learn.org/stable/auto_examples/impute/plot_iterative_imputer_variants_comparison.html#sphx-glr-auto-examples-impute-plot-iterative-imputer-variants-comparison-py" rel="noopener ugc nofollow" target="_blank">迭代插补</a>(线性回归和随机森林)。这种比较是在具有不同数量的缺失数据和缺失类型的合成数据和真实数据之间进行的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/008bfc3ba977fb97636a70a3534c198a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cQsW1DJhcKevz-3WwiV-2Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">改编自<a class="ae ky" href="https://jmlr.org/papers/v20/18-753.html" rel="noopener ugc nofollow" target="_blank"> DataWig JMLR论文</a> |图片在CC-BY 4.0下使用</p></figure><p id="7bac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据<a class="ae ky" href="https://math.stackexchange.com/questions/488964/the-definition-of-nmse-normalized-mean-square-error" rel="noopener ugc nofollow" target="_blank">归一化均方误差</a>，DataWig优于其他方法，即使在困难的MNAR遗漏类型中。结果显示在上面的图中。</p><p id="dda5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">评估的更多细节(包括非结构化文本)可在<a class="ae ky" href="https://jmlr.org/papers/v20/18-753.html" rel="noopener ugc nofollow" target="_blank">研究论文</a>中找到。</p><p id="3277" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mr">作者的想法:鉴于DataWig在处理分类和文本特征方面据称的优势，我很惊讶研究论文的评估重点是缺失的数值。</em></p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="824e" class="nc lw it bd lx nd ne nf ma ng nh ni md jz nj ka mg kc nk kd mj kf nl kg mm nm bi translated">(5) Python的实现</h1><p id="8caa" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">为了展示DataWig的工作原理，我们将使用<a class="ae ky" href="https://archive.ics.uci.edu/ml/datasets/heart+disease" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">心脏病数据集</strong> </a>，因为它包含数字和分类数据类型。</p><p id="0f59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mr">注:你可以在这里</em> <a class="ae ky" href="https://github.com/kennethleungty/DataWig-Missing-Data-Imputation" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="mr">找到这个项目的GitHub回购</em> </strong> </a> <em class="mr">和完整的Jupyter笔记本演示</em> <a class="ae ky" href="https://github.com/kennethleungty/DataWig-Missing-Data-Imputation/blob/main/notebooks/DataWig-Example.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="mr">这里</em> </strong> </a> <em class="mr">。</em></p><p id="3061" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特别是，作为演示的一部分，我们将进行两次插补:</p><ol class=""><li id="6225" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated"><strong class="lb iu">数值插补</strong>:在数值<code class="fe oj ok ol om b"><strong class="lb iu">MaxHR</strong></code>栏填写缺失值(人达到的最大心率)</li><li id="2bfc" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated"><strong class="lb iu">分类插补</strong>:在分类<code class="fe oj ok ol om b"><strong class="lb iu">ChestPain</strong></code> <strong class="lb iu"> </strong>栏填写缺失值(遇到的胸痛类型)</li></ol><h2 id="c955" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">步骤1 —初始设置</h2><ul class=""><li id="3c32" class="nt nu it lb b lc nn lf no li on lm oo lq op lu oh nz oa ob bi translated">用Python版本3.7创建并激活一个新的<a class="ae ky" href="https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html" rel="noopener ugc nofollow" target="_blank"> <em class="mr"> conda </em>环境</a>。原因是DataWig目前支持3.7及以下版本。</li></ul><pre class="kj kk kl km gt oq om or os aw ot bi"><span id="3fdf" class="lv lw it om b gy ou ov l ow ox">conda create -n myenv python=3.7<br/>conda activate myenv</span></pre><ul class=""><li id="eb45" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu oh nz oa ob bi translated">通过pip安装DataWig</li></ul><pre class="kj kk kl km gt oq om or os aw ot bi"><span id="df3c" class="lv lw it om b gy ou ov l ow ox">pip install datawig</span></pre><ul class=""><li id="ef4e" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu oh nz oa ob bi translated">如果您希望环境出现在您的Jupyter笔记本中，您可以运行以下命令:</li></ul><pre class="kj kk kl km gt oq om or os aw ot bi"><span id="43c9" class="lv lw it om b gy ou ov l ow ox">python -m ipykernel install --user --name myenv --display-name "myenv"</span></pre><p id="6cea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mr">注意:确保pandas、NumPy和scikit-learn库更新到最新版本。</em></p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="5c79" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">步骤2 —数据预处理</h2><p id="e830" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">插补前有两个预处理步骤要做:</p><ul class=""><li id="f8d9" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu oh nz oa ob bi translated">执行随机洗牌训练-测试分割(80/20)</li><li id="cdec" class="nt nu it lb b lc oc lf od li oe lm of lq og lu oh nz oa ob bi translated">随机隐藏<strong class="lb iu">测试</strong>数据集中任意比例(如25%)的值，以模拟缺失数据。对于插补模型的训练，训练集将保持完全不缺失。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="8fe5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个测试集的例子，缺失的数据显示为<code class="fe oj ok ol om b">NaN</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/f264ed5264d9e391df2fe708fd63e6cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vwZdcv4U91cdXhK9H696JA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">测试集样本|作者图片</p></figure></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="a523" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">步骤3 —设置插补模型</h2><p id="f1d0" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">构建和部署插补模型的最简单方法是使用<code class="fe oj ok ol om b">SimpleImputer</code>类。它会自动检测列数据类型，并使用一组默认的编码器和特征，在各种数据集上产生良好的结果。</p><p id="3ecd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先定义一个输入列的列表，这些输入列对于预测待估算列中的缺失值非常有用。该列表基于<strong class="lb iu">用户的领域知识和批判性判断。</strong></p><p id="1a1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们创建两个<code class="fe oj ok ol om b">SimpleImputer</code>的实例，每个实例对应两个要估算的列(即<code class="fe oj ok ol om b"><strong class="lb iu">MaxHR</strong></code> <strong class="lb iu"> </strong>和<code class="fe oj ok ol om b"><strong class="lb iu">ChestPain</strong></code>)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="1821" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">步骤4 —拟合插补模型</h2><p id="25cd" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">准备好模型实例后，我们可以将它们放入我们的训练数据集。除了简单的模型拟合，我们还可以利用<code class="fe oj ok ol om b">SimpleImputer</code>的超参数优化(HPO) <code class="fe oj ok ol om b">fit_hpo</code>功能找到最佳插补模型。</p><p id="893e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">HPO函数在超参数(例如，学习率、批量大小、隐藏层数)的定制网格上使用随机搜索。</p><p id="44e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果不需要HPO，我们可以省略超参数搜索参数(如分类插补示例所示)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="2c08" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">步骤5-执行插补并生成预测</h2><p id="f042" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">下一步是通过对有缺失值的测试集运行经过训练的插补模型来生成预测。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="e18c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出是原始数据帧<strong class="lb iu">加上</strong>估算数据的新列。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/9a5130e3465336c9a6ad6ef0e6c81a2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7muzvxaWvAsu3gfxLzClow.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">输出预测数据框(红色框中的原始列和估算列)|作者图片</p></figure></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="8389" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">第6步—评估</h2><p id="f4ed" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">最后，让我们看看我们的插补模型如何处理这些评估指标:</p><ul class=""><li id="051e" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu oh nz oa ob bi translated">数值插补的均方误差(MSE)</li><li id="a131" class="nt nu it lb b lc oc lf od li oe lm of lq og lu oh nz oa ob bi translated">分类插补的马修相关系数(<a class="ae ky" href="https://bmcgenomics.biomedcentral.com/articles/10.1186/s12864-019-6413-7" rel="noopener ugc nofollow" target="_blank"> MCC </a>)</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="ee74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本次演示中，均方误差为<strong class="lb iu"> 342.4，</strong>MCC为<strong class="lb iu"> 0.22 </strong>。这些值构成了与其他插补技术进行比较的基准。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="33b6" class="nc lw it bd lx nd ne nf ma ng nh ni md jz nj ka mg kc nk kd mj kf nl kg mm nm bi translated">(6)高级功能</h1><p id="326e" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">除了前面描述的基本实现，我们还可以利用高级DataWig特性来满足我们特定的项目需求。</p><h2 id="0309" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">㈠估算者</h2><p id="6c13" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">如果我们希望对模型类型和插补模型中的预处理步骤有更多的控制，我们可以使用<code class="fe oj ok ol om b">Imputer</code>类。</p><p id="4ba9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与<code class="fe oj ok ol om b">SimpleImputer</code>中的默认设置相比，它为模型参数的定制规范(如特定的编码器和特征)提供了更大的灵活性。</p><p id="ed20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个例子，说明如何在<code class="fe oj ok ol om b">Imputer</code>中明确定义每一列的编码器和特征:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="101c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后可以使用<code class="fe oj ok ol om b">Imputer</code>实例来执行<code class="fe oj ok ol om b">.fit()</code>和<code class="fe oj ok ol om b">.predict()</code>。</p><p id="00b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mr">作者的想法:列类型的具体定义可能是有帮助的，因为自动编码和特征化可能并不总是完美地工作。例如，在该数据集中，</em> <code class="fe oj ok ol om b"><em class="mr">SimpleImputer</em></code> <em class="mr">将分类</em> <code class="fe oj ok ol om b"><em class="mr">Thal</em></code> <em class="mr">列误识别为文本列。</em></p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="9b1c" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">(ii)标签移位检测和校正</h2><p id="cf4b" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><code class="fe oj ok ol om b">SimpleImputer</code>类有一个方便的函数<code class="fe oj ok ol om b">check_for_label_shift</code>，帮助我们检测数据漂移的问题(特别是<a class="ae ky" href="https://datascience.stackexchange.com/questions/86350/what-is-label-shift" rel="noopener ugc nofollow" target="_blank">标签移位</a>)。</p><p id="c9e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当训练数据和真实数据之间的边际分布不同时，就会发生标签偏移。通过理解标签分布是如何变化的，我们可以解释插补的变化。</p><p id="8c79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oj ok ol om b">check_for_label_shift</code>函数记录偏移的严重程度，并返回标签的权重因子。下面是权重的输出示例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/ac61f4d278b4ba14aeb60f20685961f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cKLsDWU3yhSS7sOCgnPF3Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">标签移位检查|作者图片的输出</p></figure><p id="8f68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，当我们重新拟合插补模型以纠正偏移时，我们通过传递权重来重新训练具有加权似然性的模型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="94a2" class="nc lw it bd lx nd ne nf ma ng nh ni md jz nj ka mg kc nk kd mj kf nl kg mm nm bi translated">包装它</h1><p id="4e29" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我们已经介绍了如何使用DataWig有效地估算数据表中的缺失值。</p><p id="e080" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个重要的警告是，像DataWig这样的插补工具不是处理缺失数据的灵丹妙药。</p><p id="f0bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">处理缺失数据是一个具有挑战性的过程，需要适当的调查以及对数据和背景的深刻理解。本演示中展示了一个清晰的示例，其中用户需要决定将哪些输入要素输入到模型中，以准确估算输出列。</p><p id="104e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个项目的GitHub repo可以在<a class="ae ky" href="https://github.com/kennethleungty/DataWig-Missing-Data-Imputation" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">这里</strong> </a>找到。</p><h1 id="46fc" class="nc lw it bd lx nd pd nf ma ng pe ni md jz pf ka mg kc pg kd mj kf ph kg mm nm bi translated">在你走之前</h1><p id="7413" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">欢迎您<strong class="lb iu">加入我的数据科学学习之旅！</strong>点击此<a class="ae ky" href="https://kennethleungty.medium.com/" rel="noopener">媒体</a>页面，查看我的<a class="ae ky" href="https://github.com/kennethleungty" rel="noopener ugc nofollow" target="_blank"> GitHub </a>，了解更多精彩的数据科学内容。同时，享受用DataWig输入缺失值的乐趣吧！</p><div class="pi pj gp gr pk pl"><a rel="noopener follow" target="_blank" href="/feature-selection-with-simulated-annealing-in-python-clearly-explained-1808db14f8fa"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd iu gy z fp pq fr fs pr fu fw is bi translated">Python中模拟退火的特征选择，解释清楚</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">为建模选择最佳特征的全局搜索算法的概念和实现</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">towardsdatascience.com</p></div></div><div class="pu l"><div class="pv l pw px py pu pz ks pl"/></div></div></a></div><div class="pi pj gp gr pk pl"><a rel="noopener follow" target="_blank" href="/how-to-dockerize-machine-learning-applications-built-with-h2o-mlflow-fastapi-and-streamlit-a56221035eb5"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd iu gy z fp pq fr fs pr fu fw is bi translated">如何对接用H2O、MLflow、FastAPI和Streamlit构建的机器学习应用</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">用Docker容器化多服务ML应用的简单指南</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">towardsdatascience.com</p></div></div><div class="pu l"><div class="qa l pw px py pu pz ks pl"/></div></div></a></div><div class="pi pj gp gr pk pl"><a rel="noopener follow" target="_blank" href="/top-tips-to-google-search-like-a-data-science-pro-897599f4d9ae"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd iu gy z fp pq fr fs pr fu fw is bi translated">像经验丰富的数据科学家一样使用谷歌搜索的顶级技巧</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">了解高级Google搜索功能，提高您查找数据科学解决方案的效率</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">towardsdatascience.com</p></div></div><div class="pu l"><div class="qb l pw px py pu pz ks pl"/></div></div></a></div></div></div>    
</body>
</html>