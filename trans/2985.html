<html>
<head>
<title>3 Things You May Not Know About Python Tuples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于Python元组你可能不知道的3件事</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3-things-you-may-not-know-about-python-tuples-4ff414f351d6#2022-06-29">https://towardsdatascience.com/3-things-you-may-not-know-about-python-tuples-4ff414f351d6#2022-06-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="074e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">更好地使用元组</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5fc8022d132dbf1f7dc003bd355bb756.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ScL2y4N03GCrs0NZ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">奥斯卡·尼尔森在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="a2f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">元组是Python中一种重要的内置数据类型。像列表一样，我们经常使用元组将多个对象保存为一个数据容器。然而，使它们不同于列表的是它们的不变性——不可变的数据序列。下面的代码片段向您展示了元组的一些常见用法。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4879" class="ma mb it lw b gy mc md l me mf">response = (404, "Can't access website")</span><span id="e17e" class="ma mb it lw b gy mg md l me mf">response_code = response[0]<br/>response_data = response[1]</span><span id="36fd" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">assert</strong> response_code == 404<br/><strong class="lw iu">assert</strong> response_data == "Can't access website"</span></pre><p id="13ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的用法对你来说应该很直观。我们使用一对括号创建一个tuple对象，将元素括起来。当我们需要使用单个项目时，我们可以使用索引。</p><p id="21b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了这些基本用法，还有其他一些不太为人所知的用法。让我们在本文中回顾一下它们。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h2 id="58ff" class="ma mb it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">1.创建仅包含一个项目的元组</h2><p id="5351" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">我们提到，我们使用一对括号来创建一个元组对象。通常，一个tuple对象包含两个或更多项，我们使用逗号来分隔这些项。如果我们想创建一个单项式元组，应该怎么做？难道是<code class="fe nk nl nm lw b">(item)</code>？让我们试试:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0635" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; math_score = (95)<br/>&gt;&gt;&gt; math_score[0]<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>TypeError: 'int' object is not subscriptable<br/>&gt;&gt;&gt; type(math_score)<br/>&lt;class 'int'&gt;</span></pre><p id="82ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，<code class="fe nk nl nm lw b">(95)</code>并没有像你们中的一些人想的那样创建一个<code class="fe nk nl nm lw b">tuple</code>对象。相反，它创建了一个整数。解决方法是您需要在该项后面附加一个逗号:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="267a" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; math_score = (95,)<br/>&gt;&gt;&gt; math_score[0]<br/>95<br/>&gt;&gt;&gt; type(math_score)<br/>&lt;class 'tuple'&gt;</span></pre><p id="ce4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能想知道何时需要使用单项式元组。这里有一个关于熊猫的例子。当我们使用pandas时，我们经常使用<code class="fe nk nl nm lw b">apply</code>从现有列创建新数据。下面给你展示一个使用<code class="fe nk nl nm lw b">apply</code>的简单案例。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0df6" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; import pandas as pd<br/>&gt;&gt;&gt; df = pd.DataFrame({"a": range(1, 4), "b": range(4, 7)})<br/>&gt;&gt;&gt; df<br/>   a  b<br/>0  1  4<br/>1  2  5<br/>2  3  6<br/>&gt;&gt;&gt; def creating_exponents(x):<br/>...     return pow(x["b"], 2)<br/>... <br/>&gt;&gt;&gt; df.apply(creating_exponents, axis=1)<br/>0    16<br/>1    25<br/>2    36<br/>dtype: int64</span></pre><p id="3673" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在大多数情况下，我们在<code class="fe nk nl nm lw b">apply</code>中使用的映射函数只接受一个参数，即DataFrame的行(当<code class="fe nk nl nm lw b">axis</code>参数为1时，如果<code class="fe nk nl nm lw b">axis=0</code>为列)。我们可能有一个接受附加参数的映射函数，这样映射函数就更加灵活，并且可以通过不同地设置第二个参数来用于不同的DataFrame对象。在这种情况下，我们可以使用一个一项元组来传递第二个参数，如下所示。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3fc3" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; def creating_exponents(x, exp):<br/>...     return pow(x["b"], exp)<br/>... <br/>&gt;&gt;&gt; df.apply(creating_exponents, axis=1, args=(3,))<br/>0     64<br/>1    125<br/>2    216<br/>dtype: int64<br/>&gt;&gt;&gt; df.apply(creating_exponents, axis=1, args=(4,))<br/>0     256<br/>1     625<br/>2    1296<br/>dtype: int64</span></pre><p id="cc04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们对<code class="fe nk nl nm lw b">args</code>参数使用了一个单项式元组，它与行数据一起传递给映射函数。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h2 id="37f4" class="ma mb it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">2.使用下划线和*解包元组</h2><p id="7fca" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">虽然我们可以通过使用索引来访问一个元组的各个项，但更常见的是使用解包技术，如下所示:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1831" class="ma mb it lw b gy mc md l me mf">response = (404, "Can't access website")<br/>response_code, response_data = response</span></pre><p id="d063" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于解包，您定义了一些变量，这些变量的数量与元组的计数相匹配。元组的每个项被分配给各自的变量。</p><p id="d263" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不需要使用所有创建的变量，建议您使用下划线来表示它们没有被使用。例如，我们可能只对使用响应数据感兴趣，而对代码不感兴趣，我们可以这样做:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1462" class="ma mb it lw b gy mc md l me mf">_, response_data = response</span></pre><p id="3dcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，您就告诉了代码的读者，我们只对访问tuple对象的第二项感兴趣。</p><p id="4a51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个元组对象中有多个项目时，您可能希望访问多个连续的项目。您可以使用带星号的表达式:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b18b" class="ma mb it lw b gy mc md l me mf">scores = (98, 95, 95, 92, 91)</span><span id="7393" class="ma mb it lw b gy mg md l me mf">algebra, *others, zoology = scores</span><span id="0fed" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">assert</strong> others == [95, 95, 92]</span></pre><p id="bc09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，我们有一个tuple对象来保存按字母顺序排序的课程分数，我们知道第一门课程是代数，最后一门是动物学。在上面的例子中，我们得到了中间的三个分数。</p><p id="2056" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个特性(tuple解包中的星号表达式)在您不知道到底有多少到表达式时特别有用。所有的学生都学代数和动物学，但他们在其他课程上可能会有所不同。我们可以使用带星号的表达式来获得其他课程的分数，而不需要知道课程的数量。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b778" class="ma mb it lw b gy mc md l me mf">def extract_scores(scores):<br/>    algebra, *others, zoology = scores<br/>    return {"algebra": algebra, "zoology": zoology, "others": others}</span><span id="387c" class="ma mb it lw b gy mg md l me mf">scores1 = (98, 95, 92, 93, 91)<br/>scores2 = (97, 95, 95, 90)<br/>scores3 = (90, 90)</span><span id="6bfc" class="ma mb it lw b gy mg md l me mf">&gt;&gt;&gt; extract_scores(scores1)<br/>{'algebra': 98, 'zoology': 91, 'others': [95, 92, 93]}<br/>&gt;&gt;&gt; extract_scores(scores2)<br/>{'algebra': 97, 'zoology': 90, 'others': [95, 95]}<br/>&gt;&gt;&gt; extract_scores(scores3)<br/>{'algebra': 90, 'zoology': 90, 'others': []}</span></pre><p id="9f9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，这个带星号的表达式可以处理中间任意数量的元素，包括零个元素(在<code class="fe nk nl nm lw b">scores3</code>的情况下)。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h2 id="5724" class="ma mb it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">3.命名元组</h2><p id="0a26" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">您可以通过使用索引或解包元组来访问元组的各个项，以将这些项分配给单独的变量。有时候，这样做可能会很乏味。请参见以下示例:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ba05" class="ma mb it lw b gy mc md l me mf">location1 = (27.2, 7.5)<br/>location2 = (30.1, 8.4)<br/>location3 = (29.9, 7.7)</span><span id="3fb8" class="ma mb it lw b gy mg md l me mf">latitude1 = location1[0]<br/>longitude2 = location2[1]<br/>latitude3, longitude3 = location3</span></pre><p id="499d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有三个位置，显示了它们各自的坐标。当我们访问这些坐标的单个项目时，代码看起来不太清晰。虽然我们可以使用定制类来实现坐标的数据模型，但是定制类对于这个简单的数据模型来说可能是“沉重”的。相反，我们可以使用命名元组作为轻量级数据模型:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c1c9" class="ma mb it lw b gy mc md l me mf">from collections import namedtuple</span><span id="0083" class="ma mb it lw b gy mg md l me mf">Location = namedtuple("Location", ["latitude", "longitude"])</span><span id="67d2" class="ma mb it lw b gy mg md l me mf">location1 = Location(27.2, 7.5)<br/>location2 = Location(30.1, 8.4)<br/>location3 = Location(29.9, 7.7)</span><span id="4580" class="ma mb it lw b gy mg md l me mf">latitude1 = location1.latitude<br/>longitude2 = location2.longitude<br/>location3.latitude, location3.longitude</span></pre><p id="a86b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，我们调用<code class="fe nk nl nm lw b">namedtuple</code>通过指定类名及其属性来创建一个命名元组类。现在，我们可以调用该类的构造函数来创建命名元组类的实例。对于这些实例，我们可以使用点符号来访问它们的属性，这是常规元组对象所不具备的特性。</p><p id="bf55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，命名元组是一个简单而方便的类，它们也在熊猫中使用。当我们迭代DataFrame对象的行时，我们可以使用<code class="fe nk nl nm lw b">itertuples</code>方法，如下所示:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f521" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; df<br/>   a  b<br/>0  1  4<br/>1  2  5<br/>2  3  6</span><span id="afbd" class="ma mb it lw b gy mg md l me mf">&gt;&gt;&gt; for row in df.itertuples():<br/>...     print(row)<br/>... <br/>Pandas(Index=0, a=1, b=4)<br/>Pandas(Index=1, a=2, b=5)<br/>Pandas(Index=2, a=3, b=6)</span></pre><p id="37e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每一行都是一个有三个属性的命名元组:索引和两列的值。有了命名元组，您可以方便地访问列的数据，比如<code class="fe nk nl nm lw b">row.a</code>和<code class="fe nk nl nm lw b">row.b</code>。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h2 id="08bc" class="ma mb it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">结论</h2><p id="e1e8" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在本文中，我们回顾了Python中元组的三个特性。我们还使用了一些与使用pandas进行数据处理相关的例子。希望这篇文章对你有用。</p><p id="9098" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读这篇文章。通过<a class="ae ky" href="https://medium.com/subscribe/@yong.cui01" rel="noopener">注册我的简讯</a>保持联系。还不是中等会员？通过<a class="ae ky" href="https://medium.com/@yong.cui01/membership" rel="noopener">使用我的会员链接</a>支持我的写作(对你没有额外的费用，但是你的一部分会费作为奖励由Medium重新分配给我)。</p></div></div>    
</body>
</html>