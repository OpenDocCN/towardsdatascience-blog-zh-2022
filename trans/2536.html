<html>
<head>
<title>How To Improve Performance in a Hierarchical SQL Table Structure With Column Propagation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何通过列传播提高分层SQL表结构的性能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-improve-performance-in-a-hierarchical-sql-table-structure-with-column-propagation-3b8cacdc87a9#2022-06-01">https://towardsdatascience.com/how-to-improve-performance-in-a-hierarchical-sql-table-structure-with-column-propagation-3b8cacdc87a9#2022-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a0e6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">列传播作为分层表结构上缓慢查询的解决方案</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/881d22423949f157044428a8c45e20c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Vd3MlrU-sIoZMdiV"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">谢尔盖·佐尔金在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="fb2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将展示在处理分层数据结构时，列传播如何成为提高查询性能的一种简单方法。</p><p id="5f46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将通过一个基于数据驱动项目的真实场景来实现这一点，该项目涉及一个为体育行业的初创公司开发的实时数据网站。您将了解到作为分层SQL表结构中固有的性能问题的解决方案的列传播的所有知识。我们开始吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="68ba" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">语境</h1><p id="8fab" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我和我的团队最近为足球迷开发了一个有数百万页面的网站。该网站的理念是成为足球支持者的权威资源，尤其是在博彩方面。数据库和应用程序架构并不特别复杂。这是因为调度程序负责定期重新计算复杂数据并将其存储在表中，这样查询就不必涉及<a class="ae ky" href="https://arctype.com/blog/sql-aggregate-functions/" rel="noopener ugc nofollow" target="_blank"> SQL聚合</a>。所以，真正的挑战在于非功能性需求，比如性能和页面加载时间。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="98de" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">应用领域</h1><p id="12bc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">体育行业中有几家数据提供商，每一家都为其客户提供不同的数据集。具体来说，足球行业有四种类型的数据:</p><ol class=""><li id="407e" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">履历数据:身高、身高、年龄、效力过的球队、获得的奖杯、获得的个人奖项以及足球运动员和教练。</li><li id="549b" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><strong class="lb iu">历史数据</strong>:过去比赛的结果以及那些比赛中发生的事件，比如进球、助攻、黄牌、红牌、传球等。</li><li id="12e2" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><strong class="lb iu">当前和未来数据</strong>:当前赛季的比赛结果和这些比赛中发生的事件，以及未来比赛的表格。</li><li id="1117" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><strong class="lb iu">直播数据</strong>:正在进行的比赛的实时结果和直播事件。</li></ol><p id="02ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的网站涉及所有这些类型的数据，特别关注SEO原因的历史数据和支持投注的实时数据。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c794" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">分层表结构</h1><p id="d77b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我不能与你分享整个数据结构，因为我签署了一个NDA。与此同时，理解足球赛季的结构就足以理解这个现实世界的场景。</p><p id="ffd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">详细地说，足球提供商通常如下组织一个赛季中的比赛数据:</p><ul class=""><li id="0a36" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu nn nf ng nh bi translated">季节:有起止日期，一般持续一个日历年</li><li id="445a" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu nn nf ng nh bi translated"><strong class="lb iu">比赛</strong>:甲a比赛所属。一个竞争的例子存在于一个赛季中。在这里了解更多关于足球比赛如何运作的<a class="ae ky" href="https://en.wikipedia.org/wiki/List_of_association_football_competitions" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="b922" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu nn nf ng nh bi translated"><strong class="lb iu">阶段</strong>:与比赛相关的阶段(如资格赛阶段、淘汰赛阶段、决赛阶段)。每个比赛都有自己的规则，许多比赛只有一个阶段。</li><li id="f765" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu nn nf ng nh bi translated"><strong class="lb iu">组</strong>:与阶段相关联的组(例如，A组、B组、C组、…)。有些比赛，如世界杯，涉及不同的小组，每个小组都有自己的团队。大多数比赛只有一个普通组。</li><li id="45a6" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu nn nf ng nh bi translated"><strong class="lb iu">转</strong>:从逻辑角度对应一天的比赛。它通常持续一周，并涵盖一个小组中所有球队的比赛(例如，MLS有17场主场比赛和17场客场比赛；因此，它有34匝)。</li><li id="6bb3" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu nn nf ng nh bi translated">两个足球队之间的比赛。</li></ul><p id="b36e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如下面的<a class="ae ky" href="https://arctype.com/blog/erd-builder/" rel="noopener ugc nofollow" target="_blank"> ER模式</a>所示，这5个表代表一个分层数据结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/713b56b9ea79fa5f5facdff60548fae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/0*RAj5pqBsqMlCDBGm"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用于表示足球数据的分层数据结构的ER模式</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a096" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">技术、规格和性能要求</h1><p id="5f88" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们在Node.js中开发了后端，用<a class="ae ky" href="https://expressjs.com/en/changelog/4x.html#4.17.2" rel="noopener ugc nofollow" target="_blank"> Express 4.17.2 </a>和<a class="ae ky" href="https://sequelize.org/docs/v6/" rel="noopener ugc nofollow" target="_blank"> Sequelize 6.10 </a>作为ORM ( <a class="ae ky" href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping" rel="noopener ugc nofollow" target="_blank">对象关系映射</a>)。前端是一个用TypeScript开发的<a class="ae ky" href="https://nextjs.org/blog/next-12" rel="noopener ugc nofollow" target="_blank"> Next.js 12 </a>应用。至于数据库，我们决定选择AWS托管的Postgres服务器。</p><p id="5e46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该网站运行在AWS Elastic Beanstalk上，前端有12个实例，后端有8个实例，目前每天有1到5千人观看。我们客户的目标是在一年内达到6万的日浏览量。因此，网站必须准备好在不降低性能的情况下托管数百万的月用户。</p><p id="98e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该网站应该在性能，搜索引擎优化和可访问性在<a class="ae ky" href="https://developers.google.com/web/tools/lighthouse" rel="noopener ugc nofollow" target="_blank">谷歌灯塔</a>测试得分80+。此外，加载时间应该总是少于2秒，最好在几百毫秒的量级。真正的挑战在于此，因为该网站包含超过200万个页面，预渲染这些页面需要数周时间。此外，大多数页面上显示的内容不是静态的。因此，我们选择了<a class="ae ky" href="https://nextjs.org/docs/basic-features/data-fetching/incremental-static-regeneration" rel="noopener ugc nofollow" target="_blank">增量静态再生</a>方法。当一个访问者点击了一个从来没有人访问过的页面时，Next.js使用从后端公开的API中检索到的数据来生成这个页面。然后，Next.js根据页面的重要性缓存页面30秒或60秒。</p><p id="7040" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，后端必须以极快的速度为服务器端生成过程提供所需的数据。</p><h1 id="4b3f" class="mc md it bd me mf np mh mi mj nq ml mm jz nr ka mo kc ns kd mq kf nt kg ms mt bi translated">为什么查询层次表很慢</h1><p id="bfbf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在让我们来看看为什么分层表结构会对性能构成挑战。</p><h2 id="5df1" class="nu md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated">1.连接查询很慢</h2><p id="ec50" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">分层数据结构中的一个常见场景是，您希望根据与层次结构中更高层的对象相关联的参数来过滤树叶。例如，您可能希望检索某个特定赛季的所有比赛。在这种情况下，由于叶表<code class="fe og oh oi oj b">Game</code>没有直接连接到<code class="fe og oh oi oj b">Season</code>，所以您必须执行一个查询，该查询涉及的连接数量与层次结构中的元素数量一样多。</p><p id="8888" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，您可能最终会编写以下查询:</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="69a8" class="nu md it oj b gy oo op l oq or">SELECT GA.* FROM `Game` GA LEFT JOIN `Turn` T on GA.`turnId` = T.`id` LEFT JOIN `Group` G on T.`groupId` = G.`id` LEFT JOIN `Phase` P on G.`phaseId` = P.`id` LEFT JOIN `Competition` C on P.`competitionId` = C.`id` LEFT JOIN `Season` S on C.`seasonId` = S.`id` WHERE S.id = 5</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/ea4ba05001c244c24d52142a84a0cc15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-gO1S9d8HL7Z3WcQ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这个查询(显示在<a class="ae ky" href="https://arctype.com/blog/sql-hierarchy/arctype.com" rel="noopener ugc nofollow" target="_blank"> Arctype </a>中)的性能会很慢</p></figure><p id="4f0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样的查询很慢。每个连接执行一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Cartesian_product" rel="noopener ugc nofollow" target="_blank">笛卡尔积</a>操作，这需要时间并可能产生数千条记录。因此，层次数据结构越长，性能就越差。</p><p id="d146" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，如果您想检索所有数据，而不仅仅是<code class="fe og oh oi oj b">Game</code>表中的列，由于笛卡尔积的性质，您将不得不处理数千行数百列的数据。这可能会变得混乱，但这正是ORM发挥作用的地方。</p><h2 id="77fa" class="nu md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated">2.ORM数据解耦和转换需要时间</h2><p id="fccb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当通过ORM查询数据库时，您通常对检索应用程序级表示的数据感兴趣。原始数据库级表示在应用程序级可能没有用。因此，当大多数高级orm执行查询时，它们从数据库中检索所需的数据，并将其转换成应用程序级别的表示。这个过程包括两个步骤:数据解耦和数据转换。</p><p id="9e09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在后台，来自连接查询的原始数据首先被解耦，然后在应用程序级别被转换成各自的表示。因此，当处理所有数据时，具有数百列的数千条记录成为一个小型数据集，每条记录都具有在<a class="ae ky" href="https://sequelize.org/docs/v6/core-concepts/model-basics/" rel="noopener ugc nofollow" target="_blank">数据模型类</a>中定义的属性。因此，包含从数据库中提取的原始数据的数组将成为一组<code class="fe og oh oi oj b">Game</code>对象。每个<code class="fe og oh oi oj b">Game</code>对象将有一个包含其各自的<code class="fe og oh oi oj b">Turn</code>实例的转弯字段。然后，<code class="fe og oh oi oj b">Turn</code>对象将有一个组字段存储其各自的<code class="fe og oh oi oj b">Group</code>对象，依此类推。</p><p id="0baf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成这种转换后的数据是您愿意接受的开销。处理杂乱的原始数据具有挑战性，并且会导致代码味道。另一方面，这个在幕后发生的过程需要时间，你不能忽视它。当原始记录有数千行时尤其如此，因为处理存储数千个元素的数组总是很棘手。</p><p id="5892" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，层次表结构上的普通连接查询在数据库层和应用层都很慢。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="812f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">作为解决方案的列传播</h1><p id="83b9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">解决方案是在分层结构中将列从父列传播到子列，以避免这种性能问题。我们来了解一下原因。</p><h2 id="2df3" class="nu md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated">为什么应该在分层数据库中传播列</h2><p id="7931" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当分析上面的连接查询时，很明显问题在于对叶表<code class="fe og oh oi oj b">Game</code>应用过滤器。你必须经历整个层级。但是既然Game是层次结构中最重要的元素，为什么不直接添加<code class="fe og oh oi oj b">seasonId</code>、<code class="fe og oh oi oj b">competitionId</code>、<code class="fe og oh oi oj b">phaseId</code>和<code class="fe og oh oi oj b">groupId</code>列呢？这就是列传播的意义所在！</p><p id="d4e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过将外键列直接传播给子列，可以避免所有的连接。现在，您可以用下面的查询替换上面的查询:</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="fab3" class="nu md it oj b gy oo op l oq or">SELECT * FROM `Game` GA WHERE GA.seasonId = 5</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/39be821e4c8fc986d73a1e58573101d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NcksTd8m__Lf-LVW"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">更快的查询，如<a class="ae ky" href="https://arctype.com/blog/sql-hierarchy/arctype.com" rel="noopener ugc nofollow" target="_blank"> Arctype </a>所示</p></figure><p id="b7c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以想象，这个查询比原来的查询快得多。此外，它直接返回您感兴趣的内容。因此，您现在可以忽略ORM数据解耦和转换过程了。</p><p id="59ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，列传播涉及到数据复制，应该谨慎使用。但是在深入研究如何优雅地实现它之前，让我们看看应该传播哪些列。</p><h2 id="1529" class="nu md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated">如何选择要传播的列</h2><p id="f077" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您应该向下传播层次结构中较高的实体的每一列，这可能对筛选有用。例如，这涉及到外部键。此外，您可能希望传播用于过滤数据的<a class="ae ky" href="https://www.postgresql.org/docs/current/datatype-enum.html" rel="noopener ugc nofollow" target="_blank">枚举列</a>,或者使用来自父代的聚合数据生成列，以避免连接。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5e3a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">列传播的三大方法</h1><p id="742f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我的团队选择列传播方法时，我们考虑了三种不同的实现方法。下面我们来一一分析。</p><h2 id="34a3" class="nu md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated">1.创建实体化视图</h2><p id="b332" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们在层次表结构中实现列传播的第一个想法是创建一个包含所需列的<a class="ae ky" href="https://www.postgresql.org/docs/current/sql-creatematerializedview.html" rel="noopener ugc nofollow" target="_blank">物化视图</a>。物化视图存储查询的结果，并且它通常表示复杂查询(例如上面给出的连接查询)的行和/或列的子集。</p><p id="5ec9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于物化查询，您可以定义何时生成视图。然后，数据库会将它存储在磁盘上，并使它像普通表一样可用。尽管生成查询可能很慢，但您可以尽量少启动它。因此，物化视图代表了一种快速的解决方案。</p><p id="39ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，在处理动态数据时，物化视图并不是最好的方法。这是因为实例化视图可能不是最新的。它存储的数据取决于您决定何时生成视图或刷新视图。此外，包含大量数据的物化视图会占用大量的磁盘空间，这可能会带来问题，并增加存储成本。</p><h2 id="2da0" class="nu md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated">2.定义虚拟视图</h2><p id="42b4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">另一个可能的解决方案是使用<a class="ae ky" href="https://www.postgresql.org/docs/9.2/sql-createview.html" rel="noopener ugc nofollow" target="_blank">虚拟视图</a>。同样，虚拟视图是存储查询结果的表。实体化视图的不同之处在于，这次您的数据库不将查询结果存储在磁盘上，而是将其保存在内存中。因此，虚拟视图总是最新的，用实时数据解决问题。</p><p id="717b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，数据库必须在每次访问视图时执行生成查询。因此，如果生成查询需要时间，那么涉及视图的整个过程必然会很慢。虚拟视图是一个强大的工具，但是考虑到我们的性能目标，我们不得不寻找另一个解决方案。</p><h2 id="255c" class="nu md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated">3.使用触发器</h2><p id="d794" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://arctype.com/blog/learn-sql-triggers/" rel="noopener ugc nofollow" target="_blank"> SQL触发器</a>允许您在数据库中发生特定事件时自动启动查询。换句话说，触发器使您能够跨数据库同步数据。因此，通过在层次结构表中定义所需的列并让自定义触发器更新它们，您可以轻松地实现列传播。</p><p id="04af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以想象，触发器会增加性能开销。这是因为每次它们等待的事件发生时，您的数据库都会执行它们。但是执行查询需要时间和内存。所以，触发是有代价的。另一方面，这种成本通常可以忽略不计，尤其是与虚拟或物化视图的缺点相比。</p><p id="1cfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">触发器的问题是定义它们可能需要一些时间。同时，您可以只处理这个任务一次，并在需要时更新它们。因此，触发器允许您轻松优雅地实现列传播。此外，由于我们采用了列传播并使用触发器来实现它，我们已经设法满足了客户定义的性能需求。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8a32" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最后的想法</h1><p id="b17e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">层次结构在数据库中很常见，如果处理不当，可能会导致应用程序出现性能问题和效率低下。这是因为它们需要长连接查询和ORM数据处理，这既慢又耗时。幸运的是，您可以通过在层次中将列从父列传播到子列来避免这一切。我希望这个真实的案例研究能够帮助您构建更好更快的应用程序！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="2c00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ot">原载于2022年6月1日</em><a class="ae ky" href="https://arctype.com" rel="noopener ugc nofollow" target="_blank"><em class="ot"/></a><em class="ot">。</em></p></div></div>    
</body>
</html>