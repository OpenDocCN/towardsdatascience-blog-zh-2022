<html>
<head>
<title>Use Python to Create Two-Body Orbits</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Python 创建两体轨道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/use-python-to-create-two-body-orbits-a68aed78099c#2022-02-19">https://towardsdatascience.com/use-python-to-create-two-body-orbits-a68aed78099c#2022-02-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ac60" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何使用 Python 来确定航天器在较大物体重力影响下的运动</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/283463b42add1e5e0f043d4da43c3113.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*7IuUCSFbWi_7XmOvKLmyqw.gif"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">双体轨道动画[作者创作]</p></figure><p id="e753" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一般的两体问题包括求解两个在彼此引力影响下运动的质量的运动。在轨道力学中，通常认为其中一个质量可以忽略不计，因此对另一个质量没有影响。可忽略质量的运动是令人感兴趣的，也是要解决的问题。事实上，较小的质量确实对较大的质量有影响，但这种影响是如此之小，以至于实际上为零。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="266a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了在 Python 中创建两体轨道，首先需要推导感兴趣质量的运动方程(无论是卫星、小行星等)。).我在另一篇文章(见下文)中演示了如何做到这一点，所以我鼓励您去探索这一点，并真正理解方程背后的物理原理。但是，你会发现下面的运动方程。</p><div class="lx ly gp gr lz ma"><a href="https://medium.com/illumination/astrodynamics-two-body-problem-ec2c5e148184" rel="noopener follow" target="_blank"><div class="mb ab fo"><div class="mc ab md cl cj me"><h2 class="bd iu gy z fp mf fr fs mg fu fw is bi translated">如何解决两体问题</h2><div class="mh l"><h3 class="bd b gy z fp mf fr fs mg fu fw dk translated">通过推导两体系统的运动方程，学习轨道力学的基础知识</h3></div><div class="mi l"><p class="bd b dl z fp mf fr fs mg fu fw dk translated">medium.com</p></div></div><div class="mj l"><div class="mk l ml mm mn mj mo ko ma"/></div></div></a></div><p id="25bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">两体问题是一个很好的学习工具，可以作为非常接近大质量的轨道的第一近似，但一旦我们的轨道远离这个质量，其他引力就应该包括在内。即使在接近大质量时，也应包括大气阻力、<a class="ae mp" href="https://medium.com/illumination/deriving-the-effect-of-solar-radiation-pressure-on-orbits-150792f64d0b" rel="noopener">太阳辐射</a>和非球形物体的影响等干扰力。我们不会在这里讨论这些，但这是一件值得记住的事情。在较大质量的重力影响下，可忽略质量的运动方程如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/eba75957a8523ef4a3ae83dc7cfad636.png" data-original-src="https://miro.medium.com/v2/resize:fit:394/1*_idrxtL3uKFsxBmXkWH_WQ.gif"/></div></figure><p id="5ca5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们有了运动方程，我们需要把它们转换成可以数值积分的状态形式。状态形式包括某一时刻的位置和速度矢量。这是状态及其时间导数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/3872561e47685358e5bd638b8d310888.png" data-original-src="https://miro.medium.com/v2/resize:fit:332/1*vU3g0L5Hkz2vT6biMYAA6A.gif"/></div></figure><p id="363b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">状态时间导数将成为一个可以数值积分的函数。Python 有内置的数字积分器，我们可以利用它来完成这个任务。为了创建我们的轨道，我们将使用<em class="mw"> SciPy </em>包中的<code class="fe ms mt mu mv b">odeint</code>函数。让我们开始我们的代码，它将为地球轨道卫星生成一个图。</p><h2 id="6562" class="mx my it bd mz na nb dn nc nd ne dp nf ld ng nh ni lh nj nk nl ll nm nn no np bi translated"><strong class="ak">导入包</strong></h2><p id="a8d4" class="pw-post-body-paragraph ku kv it kw b kx nq ju kz la nr jx lc ld ns lf lg lh nt lj lk ll nu ln lo lp im bi translated">这段代码需要的重要包如下:</p><ul class=""><li id="5d56" class="nv nw it kw b kx ky la lb ld nx lh ny ll nz lp oa ob oc od bi translated"><em class="mw"> NumPy </em>用于创建数值数组和使用三角函数(为便于调用，定义为<em class="mw"> np </em>)</li><li id="151f" class="nv nw it kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated"><em class="mw"> SciPy </em>用于<code class="fe ms mt mu mv b">odeint</code>函数，该函数用于对我们的运动方程进行数值积分</li><li id="1fc7" class="nv nw it kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated"><code class="fe ms mt mu mv b">pyplot</code><em class="mw"/>from<em class="mw">matplotlib</em>用于显示我们在代码末尾的轨道</li></ul><pre class="kj kk kl km gt oj mv ok ol aw om bi"><span id="5e1b" class="mx my it mv b gy on oo l op oq"># Importing Packages<br/>import numpy as np<br/>from scipy.integrate import odeint<br/>import matplotlib.pyplot as plt</span></pre><h2 id="c8c9" class="mx my it bd mz na nb dn nc nd ne dp nf ld ng nh ni lh nj nk nl ll nm nn no np bi translated"><strong class="ak">创建数值积分函数</strong></h2><p id="fc09" class="pw-post-body-paragraph ku kv it kw b kx nq ju kz la nr jx lc ld ns lf lg lh nt lj lk ll nu ln lo lp im bi translated">下一步是创建一个由<code class="fe ms mt mu mv b">odeint</code>运行的函数，对我们的状态向量进行数值积分。该函数将包括每个<em class="mw"> x </em>、<em class="mw"> y </em>和<em class="mw"> z </em>的速度和加速度(如上定义)。该函数在创建时应该如下所示:</p><pre class="kj kk kl km gt oj mv ok ol aw om bi"><span id="617c" class="mx my it mv b gy on oo l op oq"># Earth Model<br/>def model_2BP(state, t):<br/>    mu = 3.986004418E+05  # Earth's gravitational parameter  <br/>                          # [km^3/s^2]<br/>    x = state[0]<br/>    y = state[1]<br/>    z = state[2]<br/>    x_dot = state[3]<br/>    y_dot = state[4]<br/>    z_dot = state[5]<br/>    x_ddot = -mu * x / (x ** 2 + y ** 2 + z ** 2) ** (3 / 2)<br/>    y_ddot = -mu * y / (x ** 2 + y ** 2 + z ** 2) ** (3 / 2)<br/>    z_ddot = -mu * z / (x ** 2 + y ** 2 + z ** 2) ** (3 / 2)<br/>    dstate_dt = [x_dot, y_dot, z_dot, x_ddot, y_ddot, z_ddot]<br/>    return dstate_dt</span></pre><h2 id="3f69" class="mx my it bd mz na nb dn nc nd ne dp nf ld ng nh ni lh nj nk nl ll nm nn no np bi translated"><strong class="ak">运行 ODE 解算器</strong></h2><p id="79e1" class="pw-post-body-paragraph ku kv it kw b kx nq ju kz la nr jx lc ld ns lf lg lh nt lj lk ll nu ln lo lp im bi translated">所选的 ODE 求解器需要三个输入来运行:要进行数值积分的函数、初始条件和时间数组。我们已经创建了这个函数，叫做<code class="fe ms mt mu mv b">model_2BP</code>。初始条件可以是任何东西(确保你在地球表面之外！).美国宇航局有一个<a class="ae mp" href="https://ssd.jpl.nasa.gov/horizons/app.html#/" rel="noopener ugc nofollow" target="_blank">应用</a>，如果你想查看特定卫星的轨道，它可以用来提取状态向量。可以使用<em class="mw"> NumPy </em>包创建时间数组(注意:确保包含足够的时间步长来创建平滑的轨道)。我们现在可以运行求解器，并将其设置为等于<code class="fe ms mt mu mv b">sol</code>(意为“解”)。</p><pre class="kj kk kl km gt oj mv ok ol aw om bi"><span id="19d5" class="mx my it mv b gy on oo l op oq"># Initial Conditions<br/>X_0 = -2500  # [km]<br/>Y_0 = -5500  # [km]<br/>Z_0 = 3400  # [km]<br/>VX_0 = 7.5  # [km/s]<br/>VY_0 = 0.0  # [km/s]<br/>VZ_0 = 4.0  # [km/s]<br/>state_0 = [X_0, Y_0, Z_0, VX_0, VY_0, VZ_0]<br/><br/># Time Array<br/>t = np.linspace(0, 6*3600, 200)  # Simulates for a time period of 6<br/>                                 # hours [s]<br/><br/># Solving ODE<br/>sol = odeint(model_2BP, state_0, t)<br/>X_Sat = sol[:, 0]  # X-coord [km] of satellite over time interval <br/>Y_Sat = sol[:, 1]  # Y-coord [km] of satellite over time interval<br/>Z_Sat = sol[:, 2]  # Z-coord [km] of satellite over time interval</span></pre><h2 id="6b4a" class="mx my it bd mz na nb dn nc nd ne dp nf ld ng nh ni lh nj nk nl ll nm nn no np bi translated"><strong class="ak">可视化数据</strong></h2><p id="e73c" class="pw-post-body-paragraph ku kv it kw b kx nq ju kz la nr jx lc ld ns lf lg lh nt lj lk ll nu ln lo lp im bi translated">最后，我们创建轨道的最终目标可以通过使用<em class="mw"> matplotlib </em>创建一个 3D 图形来完成。我们使用了来自<code class="fe ms mt mu mv b">sol</code>变量的<em class="mw"> x </em>、<em class="mw"> y </em>和<em class="mw"> z </em>时间历程，这些时间历程我们已经获得。为了增加视觉效果，我们还可以创建一个球体来代表我们的地球(地球的平均半径为 6378.14 公里)。我们将把我们的地球放在我们阴谋的起点。</p><pre class="kj kk kl km gt oj mv ok ol aw om bi"><span id="f7af" class="mx my it mv b gy on oo l op oq"># Setting up Spherical Earth to Plot<br/>N = 50<br/>phi = np.linspace(0, 2 * np.pi, N)<br/>theta = np.linspace(0, np.pi, N)<br/>theta, phi = np.meshgrid(theta, phi)<br/><br/>r_Earth = 6378.14  # Average radius of Earth [km]<br/>X_Earth = r_Earth * np.cos(phi) * np.sin(theta)<br/>Y_Earth = r_Earth * np.sin(phi) * np.sin(theta)<br/>Z_Earth = r_Earth * np.cos(theta)<br/><br/># Plotting Earth and Orbit<br/>fig = plt.figure()<br/>ax = plt.axes(projection='3d')<br/>ax.plot_surface(X_Earth, Y_Earth, Z_Earth, color='blue', alpha=0.7)<br/>ax.plot3D(X_Sat, Y_Sat, Z_Sat, 'black')<br/>ax.view_init(30, 145)  # Changing viewing angle (adjust as needed)<br/>plt.title('Two-Body Orbit')<br/>ax.set_xlabel('X [km]')<br/>ax.set_ylabel('Y [km]')<br/>ax.set_zlabel('Z [km]')</span></pre><p id="57b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们应该在我们的计划中增加一件事。在我们的课程中，我的教授们总是坚持让轴在轨道图上等距分布。这将给出物理空间中轨道的真实表示。我们可以用下面的代码来实现。</p><pre class="kj kk kl km gt oj mv ok ol aw om bi"><span id="b6d2" class="mx my it mv b gy on oo l op oq"># Make axes limits<br/>xyzlim = np.array([ax.get_xlim3d(), ax.get_ylim3d(),      <br/>                   ax.get_zlim3d()]).T<br/>XYZlim = np.asarray([min(xyzlim[0]), max(xyzlim[1])])<br/>ax.set_xlim3d(XYZlim)<br/>ax.set_ylim3d(XYZlim)<br/>ax.set_zlim3d(XYZlim * 3/4)<br/>plt.show()</span></pre><p id="e1c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">编译完所有代码并运行它之后，您应该会得到下面的轨道。还是那句话，这是个近似值，随着轨道的演化，它会开始偏离真实的轨道。为了得到一个更好的轨道模型，你应该包括扰动力，像月球的引力，太阳的引力，地球的非球形性质，太阳辐射，甚至大气阻力。我将在某个时候写一篇关于这个主题的文章，所以如果你感兴趣，给我一个关注，订阅我的电子邮件来保持更新。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/d39bb71175f7569a43c9a557ed05d5c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*-uG0iR2f9V-8OTjwVp6XYA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">二体轨道[作者创作]</p></figure><p id="2452" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">顺便说一句，如果您想要像本文开头那样制作动态观察的动画，您可以按照本文学习:</p><div class="lx ly gp gr lz ma"><a rel="noopener follow" target="_blank" href="/how-to-animate-plots-in-python-2512327c8263"><div class="mb ab fo"><div class="mc ab md cl cj me"><h2 class="bd iu gy z fp mf fr fs mg fu fw is bi translated">如何在 Python 中制作情节动画</h2><div class="mh l"><h3 class="bd b gy z fp mf fr fs mg fu fw dk translated">了解制作数据动画以创建动态视觉效果的基础知识</h3></div><div class="mi l"><p class="bd b dl z fp mf fr fs mg fu fw dk translated">towardsdatascience.com</p></div></div><div class="mj l"><div class="or l ml mm mn mj mo ko ma"/></div></div></a></div></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="1d66" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢您阅读文章！我将继续写容易理解的轨道力学文章，包括代码和推导，所以如果你感兴趣，请给我一个关注！有问题就评论！</p></div></div>    
</body>
</html>