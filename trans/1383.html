<html>
<head>
<title>Writing Clean Python Code for Data Scientists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为数据科学家编写简洁的Python代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/writing-clean-python-code-for-data-scientists-3448c162ac01#2022-04-06">https://towardsdatascience.com/writing-clean-python-code-for-data-scientists-3448c162ac01#2022-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="6e4d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你是数据科学家，想用Python写干净的代码吗？那你来对地方了。写出好的代码需要很多东西。作为一名数据科学家，您可能会做大量R&amp;D / PoC类型的工作，这需要您快速行动。因此，你在写好代码和快速前进之间走着一条微妙的路线。这种平衡是一种艺术形式，你必须为自己发展并适应你的情况。项目构思和部署之间有很大的灰色地带。但是随着你的项目变得越来越大，越来越接近部署，你就越想确保你写的是干净的、可持续的代码。这是我制作的一张图片，试图概括这种平衡。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/542e59bd2eeb400772ec345e03892220.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*OjhmNX-sGm-JEnHmQdVG5g.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">项目生命周期中干净代码的平衡</p></figure><p id="2e31" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是一个非常酷的图形，展示了编写好代码的各个层次。因为这篇文章的缘故，我将把重点放在这个金字塔的最上面两层，(单元)测试和代码风格。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi la"><img src="../Images/da8ba68ce418e34bf8e788464b61ddec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yKeB5zEsxlFTF_8soDd0iQ.png"/></div></div></figure><p id="ee43" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">TLDR，我将集中讨论你今天可以做的四件事来写更干净的代码。最后，我将谈谈如何实现这一过程的自动化，以及我个人如何在自己的工作中找到整洁和快速之间的平衡。</p><h1 id="915c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">格式化程序— autopep8</h1><ul class=""><li id="a0dc" class="md me it js b jt mf jx mg kb mh kf mi kj mj kn mk ml mm mn bi translated">格式化程序关心的是<em class="mo">样式和</em>是否符合PEP8定义的基本编码标准。</li><li id="e793" class="md me it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated">理想情况下，您应该知道编码标准并编写已经符合的代码。但是我们并不都是完美的，所以这就是格式化程序的作用。然而，如果你想在autopep警告你之前知道格式化你的代码的正确方法，请查看:【https://realpython.com/python-pep8/<a class="ae mu" href="https://realpython.com/python-pep8/" rel="noopener ugc nofollow" target="_blank"/></li><li id="0423" class="md me it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated">怎么跑？简单。通过“pip安装autopep8”安装</li><li id="c413" class="md me it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated">然后用“autopep 8-r-a-a-in-place<foldername>运行</foldername></li><li id="4dc2" class="md me it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated">r将在整个目录中递归运行。-a会让它变得有攻击性。—就地将就地更改文件。</li><li id="241f" class="md me it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated">最后一个技巧:您还可以设置vscode使用autopep8格式化程序并在保存时格式化！</li></ul><h1 id="be70" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">棉绒——皮林</h1><ul class=""><li id="225c" class="md me it js b jt mf jx mg kb mh kf mi kj mj kn mk ml mm mn bi translated">Linter就像一个更加固执己见的格式化程序。它也更聪明一点。linter可以捕捉潜在的错误，比如变量没有被定义，以及许多其他问题。</li><li id="a881" class="md me it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated">我为Python使用的linter是pylint。linter有很多规则和配置选项。您可以通过在项目目录中包含一个. pylintrc来自定义所有这些参数。而不是自己写。pylintrc，我推荐从大G自己做的一个开始:<a class="ae mu" href="https://raw.githubusercontent.com/google/seq2seq/master/pylintrc" rel="noopener ugc nofollow" target="_blank"> google pylintrc </a>。</li><li id="a3df" class="md me it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated">要安装，只需“pip install pylint”并运行“pylint <foldername>”</foldername></li><li id="d3c7" class="md me it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated">还可以设置vscode来使用pylint。只需使用热键ctrl+shift+p来打开命令pallete，并键入“Python: enable/disable林挺”来启用它。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi mv"><img src="../Images/df3e65e24261721db0d2da635de69a38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M96SYHP9Fvfy2ZJXauKyKg.png"/></div></div></figure><ul class=""><li id="84cf" class="md me it js b jt ju jx jy kb mw kf mx kj my kn mk ml mm mn bi translated">这里的最后一点是，您可以在任何一行使用“# pylint: disable=”来忽略下面一行，从而忽略pylint错误。只要把你想忽略的错误的名字放在等号后面。比如“missing-function-docstring”。您也可以将此注释放在文件的顶部，以忽略整个文件。</li></ul><h1 id="fad6" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">测试— pytest</h1><p id="c72c" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated">好了，开始测试的一个很好的地方就是为你的函数写很多断言语句。如果您还不想创建单独的测试文件，只需在文件底部的If语句子句中编写一些断言，如下所示:</p><p id="6079" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">if __name__ == "__main__ ":</p><p id="7063" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">断言my_function() == "预期输出"</p><p id="38a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">理想情况下，试着想出任何边缘情况并测试它们。你的目标是获得100%的覆盖率，这意味着在你所有的测试中，你写的每一行代码都会运行。我们很快会谈到更多关于覆盖率的内容。</p><p id="4bb3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">特别要注意的是你所有的“如果”语句，尽量确保你的测试会触发这些子句。</p><p id="9c25" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好了，现在你已经写好了你的断言语句，只是</p><ul class=""><li id="b0e9" class="md me it js b jt ju jx jy kb mw kf mx kj my kn mk ml mm mn bi translated">创建一个test.py文件(文件名无关紧要)</li><li id="6464" class="md me it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated">在该文件中，创建一个以“test_”开头的函数，例如“def test_my_function():”</li><li id="ed75" class="md me it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated">将您断言语句移到该函数中</li><li id="cb85" class="md me it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated">&gt; pip安装pytest</li><li id="a174" class="md me it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated">&gt; pytest test.py</li></ul><p id="1bda" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Pytest将在该文件中查找任何以“test_”开头的函数并运行它们。如果assert语句的计算结果不为true，pytest会让您知道。</p><h1 id="90cb" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Pytest —更多高级功能</h1><h2 id="8bde" class="nc lg it bd lh nd ne dn ll nf ng dp lp kb nh ni lt kf nj nk lx kj nl nm mb nn bi translated">固定装置</h2><p id="c92c" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated">如果您有一段代码需要一段时间才能运行，您可以使用“fixtures”来确保您只在测试中运行这段代码一次，然后在其他测试中重用结果。你只需要给函数添加一个装饰器，这需要一段时间来运行。见<a class="ae mu" href="https://www.tutorialspoint.com/pytest/pytest_fixtures.htm" rel="noopener ugc nofollow" target="_blank">这里</a>一个简单的例子。</p><h2 id="8ed6" class="nc lg it bd lh nd ne dn ll nf ng dp lp kb nh ni lt kf nj nk lx kj nl nm mb nn bi translated">嘲弄的</h2><p id="584b" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated">单元测试是关于测试代码的“单元”(与用于确保整个管道运行良好的集成测试相反)。如果你有一个API调用，DB调用或者其他一些你不想在你的单元测试中测试的外部依赖，但是你需要它们的输出来运行你的函数，你可以使用“嘲讽”。模仿是通过简单地包含一个</p><p id="3e08" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">" mocker . patch(' path . to . function . to . mock '，return_value=5)"</p><p id="3a45" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在调用调用该函数的代码之前，在测试函数中调用。</p><p id="b6c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里见简单教程<a class="ae mu" href="https://changhsinlee.com/pytest-mock/" rel="noopener ugc nofollow" target="_blank">。确保您首先“pip install pytest-mock”！</a></p><h2 id="5ce7" class="nc lg it bd lh nd ne dn ll nf ng dp lp kb nh ni lt kf nj nk lx kj nl nm mb nn bi translated">新闻报道</h2><p id="b14c" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated">&gt; pip安装pytest-cov</p><p id="92d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还记得我在上面说过要试着写一些在某个时候会用到/覆盖你所有代码的测试吗？嗯，有一种自动的方法可以知道我们覆盖了多少代码！超级简单。假设您正在构建一个名为my_package的python包，并且您有一个名为my_tests的测试文件夹。您可以在您的包上运行所有的测试，并使用下面的命令获得结果覆盖率(从0到100%)。</p><p id="eff5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">&gt; pytest — cov=my_package my_tests</p><p id="3399" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它会把你的结果打印到终端上。但是等等，还有呢！通过运行以下命令，您可以写出一个. xml文件，其中包含关于哪些行被覆盖和缺失的所有数据(注意，在双破折号之前应该有空格)。</p><p id="1842" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">&gt; pytest-cov = my _ package-cov-report = XML my _ tests</p><p id="7f55" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你使用的是vscode，你可以安装一个名为“Coverage Gutters”的扩展，并可视化哪些行被覆盖了！超级酷。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi no"><img src="../Images/a207d16417fc5c18b96c04ef8442d80c.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*NhFMxlJ35WQWcfhJ785dzg.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">“Coverage Gutters扩展”的演示。左边的红色高亮显示的是第180行没有经过测试。</p></figure><h1 id="fdb7" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">静态类型— mypy</h1><p id="5732" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated">我知道我们已经谈了很多，但我还有一个问题要告诉你。所以你知道python通常不使用类型。然而，类型提示不久前作为“更正式的注释”被引入。它们对代码的可读性非常有帮助。事实证明，它们不仅仅可以提高可读性。它们实际上有助于在运行前捕捉错误！</p><p id="1e2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">&gt; pip安装mypy</p><p id="7aff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">&gt; mypy my_package</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi np"><img src="../Images/af4c1a38510626b041da0e82fddd4ddd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uhBD5EX-aRj4kY6hR7VSeA.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">Splits应该带一个str，但是我们给它传递了一个int。这将导致引发TypeError运行时异常。使用mypy，我们能够提前发现这个错误！</p></figure><h1 id="3aaa" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">额外提示—目录结构</h1><p id="3dc9" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated">这最后一个技巧很简短。基本上，我只是想链接到另一篇关于好的<a class="ae mu" href="https://docs.python-guide.org/writing/structure/" rel="noopener ugc nofollow" target="_blank">目录结构</a>的文章。拥有一个好的结构会让你看起来像一个专家，让项目的新来者更容易知道在哪里找东西，并且让在你的计算机上设置路径变量变得更容易。</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="7900" class="lf lg it bd lh li nx lk ll lm ny lo lp lq nz ls lt lu oa lw lx ly ob ma mb mc bi translated">持续集成/开发(CI/CD)</h1><p id="7152" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated">我们已经讨论了很多了。为了使这个主题完整，我应该谈谈如何通过使用CI/CD工具(如Github actions)来自动化我们在这里讨论的一切。然而，这可能是(也确实是)一个值得单独写一篇文章的主题。所以暂时就这么说吧。只要适合你，我就会经常运行这4个命令，不会拖慢你的“速度”，但足够经常到你可以为你干净的代码感到自豪的程度。</p><p id="ded6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">&gt; autopep8 -a -a -r —就地my_package</p><p id="5671" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">&gt; pylint **/*。巴拉圭</p><p id="3914" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">&gt; mypy my_package</p><p id="6b8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">&gt; pytest—cov = my _ package—fail-on = 100 my _ tests</p><p id="d71f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对我来说，这意味着我要运行这四个命令，并确保它们在我提交PR之前都通过。我发现，如果我在尝试开发新功能的过程中过于担心样式、静态类型或测试，我可能会花太多时间来使代码变得漂亮，而我可能会扔掉这些时间。祝你的发展之旅好运！</p></div></div>    
</body>
</html>