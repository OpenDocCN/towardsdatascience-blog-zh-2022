<html>
<head>
<title>10-Minute Guide to Julia For Die-Hard Python Lovers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">给铁杆 Python 爱好者的 10 分钟 Julia 指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/10-minute-guide-to-julia-for-die-hard-python-lovers-a2fcf7dcb860#2022-02-07">https://towardsdatascience.com/10-minute-guide-to-julia-for-die-hard-python-lovers-a2fcf7dcb860#2022-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c96d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你不能再忽视她了，你不能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/74f957ec9dc7cf1194fedf8031507738.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qzgu9FC2oJqXmLLnwgZ5-Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">照片由</strong> <a class="ae kz" href="https://www.pexels.com/@emma-bauso-1183828?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> <strong class="bd ky">艾玛</strong> </a> <strong class="bd ky">上</strong> <a class="ae kz" href="https://www.pexels.com/photo/girl-wearing-white-dress-2253896/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> <strong class="bd ky">像素</strong> </a></p></figure><p id="1f1d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">不要误解我。我不是一个讨厌 Python 的人。我喜欢它，在事实改变之前，我的眉毛可能会变成蓝色。但是朱莉娅似乎好得不像真的。</p><p id="3e38" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">所有的编程语言在特定的任务上都很优秀，但在其他方面却很糟糕。Julia 的创造者很贪婪——他们想要最好的语言的所有超能力并创造一种超级语言。</p><p id="6551" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">他们做到了。正如创作者在《朱莉娅的贪婪》中所描述的那样，这种语言已经实现了他们 90%以上的宏伟梦想。</p><p id="b7ad" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">尽管 Julia 相对年轻，但它已经可以和 Python 一较高下了。考虑到 Python 花了很多年才成熟并被认真对待，Julia 正在以惊人的速度增长。在一个小得多的社区中，这种语言已经有了几乎任何可以用 Python 完成的任务的包和框架。</p><p id="3cde" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在本文中，您将了解核心语言，即使没有额外的模块，它也包含了令人敬畏的特性。</p><div class="lw lx gp gr ly lz"><a href="https://ibexorigin.medium.com/membership" rel="noopener follow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">通过我的推荐链接加入 Medium-BEXGBoost</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">获得独家访问我的所有⚡premium⚡内容和所有媒体没有限制。支持我的工作，给我买一个…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">ibexorigin.medium.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn ks lz"/></div></div></a></div><p id="f544" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">获得由强大的 AI-Alpha 信号选择和总结的最佳和最新的 ML 和 AI 论文:</p><div class="lw lx gp gr ly lz"><a href="https://alphasignal.ai/?referrer=Bex" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">阿尔法信号|机器学习的极品。艾总结的。</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">留在循环中，不用花无数时间浏览下一个突破；我们的算法识别…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">alphasignal.ai</p></div></div><div class="mi l"><div class="mo l mk ml mm mi mn ks lz"/></div></div></a></div></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="662b" class="mw mx it bd my mz na dn nb nc nd dp ne lj nf ng nh ln ni nj nk lr nl nm nn no bi translated">安装和设置</h2><p id="2fa8" class="pw-post-body-paragraph la lb it lc b ld np ju lf lg nq jx li lj nr ll lm ln ns lp lq lr nt lt lu lv im bi translated">安装 Julia 并将其添加到 JupyterLab 只需要几分钟的时间。从<a class="ae kz" href="https://julialang.org/downloads/" rel="noopener ugc nofollow" target="_blank">这里</a>下载安装程序，并勾选安装时将 Julia 添加到<code class="fe nu nv nw nx b">PATH</code>的选项。你甚至不需要重启你的机器。如果您在自己选择的 CLI 上键入<code class="fe nu nv nw nx b">julia</code>并得到以下输出，Julia 就正常了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/73c4297abd0a1117ced891effe0fa4d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*SK6_PwsHeR5wYaF9e9bODA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者 GIF</p></figure><p id="78ae" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于 IDE，你可以为 PyCharm 安装 Julia 插件。对于 VSCode，扩展市场已经覆盖了你。</p><p id="b293" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果你想试试 JupyterLab 里面的 Julia，输入<code class="fe nu nv nw nx b">julia</code>进入 REPL 模式后这两行应该就够了:</p><pre class="kj kk kl km gt nz nx oa ob aw oc bi"><span id="4a5b" class="mw mx it nx b gy od oe l of og">using Pkg<br/>Pkg.add("IJulia")</span></pre><p id="1af4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">只需记住重新启动任何正在运行的 JupyterLab 会话，以使更改生效。然后，你可以从开始菜单打开一个带有 Julia 内核的笔记本:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/00f4cea7cb718f166270ab8fd9a4cdca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*x9F0xOBBxJnIakT81BAZ9g.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者 GIF</p></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="ecb8" class="mw mx it bd my mz na dn nb nc nd dp ne lj nf ng nh ln ni nj nk lr nl nm nn no bi translated">变量</h2><p id="faa4" class="pw-post-body-paragraph la lb it lc b ld np ju lf lg nq jx li lj nr ll lm ln ns lp lq lr nt lt lu lv im bi translated">Python 和 Julia 之间有很多语法上的相似之处。两者读起来几乎都像自然英语。</p><p id="d25c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">假设您已经熟悉 Python，我将主要提到 Julia 中在基本编程原则方面与 Python 语法完全不同的部分。先说变量。</p><p id="0637" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">Julia 是一种动态类型语言，这意味着 Julia 和 Python 中的变量没有太大的区别。在这两种情况下，变量都区分大小写，没有语义含义，并且允许在创建时使用大多数 Unicode 符号。</p><p id="8823" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在<a class="ae kz" href="https://docs.julialang.org/en/v1/manual/variables/#Stylistic-Conventions" rel="noopener ugc nofollow" target="_blank">风格指南</a>中有一些小的不同:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/a13c64a1e8f5ff54674808790fd8bff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9iOfLJM9FClRqKNNeMMLZQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae kz" href="https://docs.julialang.org/en/v1/" rel="noopener ugc nofollow" target="_blank">茱莉亚文件</a>截图</p></figure><p id="a271" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">除此之外，Julia 中的一个变量可以替代它们的 Pythonic 对应物。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="fe58" class="mw mx it bd my mz na dn nb nc nd dp ne lj nf ng nh ln ni nj nk lr nl nm nn no bi translated">数字和数学</h2><p id="3b57" class="pw-post-body-paragraph la lb it lc b ld np ju lf lg nq jx li lj nr ll lm ln ns lp lq lr nt lt lu lv im bi translated">Julia 是一种科学语言，比 Python 更科学，它对数学计算有极好的、极快的支持。</p><p id="c4f0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">所有的数学运算符都是一样的，除了乘方运算符，在 Julia 中用<code class="fe nu nv nw nx b">^</code>表示，以及底除数，用<code class="fe nu nv nw nx b">÷</code>表示(我不知道你如何在键盘上用一个简单的击键产生它)。还有一个额外的运算符，用<em class="ol">反斜杠</em> ( <code class="fe nu nv nw nx b">\</code>)执行逆除法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="1e25" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">默认情况下，整数和浮点用 Int64 和 Float64 数据类型表示。Julia 非常重视正确的类型用法，因为它们对记忆有很大的影响:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="9f67" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">不幸的是，Julia 还不支持全局变量的类型声明:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="5035" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">无穷大和空值表示为<code class="fe nu nv nw nx b">Inf</code>和<code class="fe nu nv nw nx b">NaN</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="2a6c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">但是，奇怪的是，在 Julia 中没有零除法误差:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="7f5c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在，我们到了 Julia 开始觉得自己是一种真正的科学的、以数学为目的的语言的部分。Julia 允许你写出多项式的系数，而不用那些讨厌的乘法符号:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="d6e2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">然而，也有例外——像这样的东西是行不通的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="56a6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">尽管如此，允许数字紧接在变量之前，使得公式和表达式的编写更加简洁明了。</p><p id="196d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">Julia 还在全局范围内提供了广泛的标准函数，无需导入额外的模块:</p><pre class="kj kk kl km gt nz nx oa ob aw oc bi"><span id="91b2" class="mw mx it nx b gy od oe l of og">&gt;&gt;&gt; factorial(10)</span><span id="ff66" class="mw mx it nx b gy om oe l of og">3628800</span></pre><p id="bec3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">下面是除法函数的列表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/79907cb3bd5a2739c50fd82e92101914.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YaG1IabMlzDPGQEHvlDB_A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae kz" href="https://docs.julialang.org/en/v1/" rel="noopener ugc nofollow" target="_blank">茱莉亚文件</a>截图</p></figure><p id="c5ff" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">幂、对数和根函数的列表更加令人印象深刻:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/e71338307600479347be3f9137171c43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dgJegd-6SeeqvclAczG-XA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae kz" href="https://docs.julialang.org/en/v1/" rel="noopener ugc nofollow" target="_blank">茱莉亚文件</a>截图</p></figure><p id="ac3e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">也没有遗漏触发功能:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/46254affc4b8f92ca7fe65a96a992965.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wPOFaBaOjI0rXOhNtdPZMA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae kz" href="https://docs.julialang.org/en/v1/" rel="noopener ugc nofollow" target="_blank">朱莉娅文件的截图</a></p></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="0716" class="mw mx it bd my mz na dn nb nc nd dp ne lj nf ng nh ln ni nj nk lr nl nm nn no bi translated">条件式</h2><p id="91db" class="pw-post-body-paragraph la lb it lc b ld np ju lf lg nq jx li lj nr ll lm ln ns lp lq lr nt lt lu lv im bi translated">在 Julia 中，缩进是没有语义意义的(但是请大家为了大家的利益使用它，就像你在写 Python 一样)。因此，诸如条件、循环和函数等代码块应该以关键字<code class="fe nu nv nw nx b">end</code>结束。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="a2cc" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">条件关键字(if，else if(Python 中的 elif)，else)的逻辑是一样的。数字比较运算符也是如此:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/ba465e9553d40e00c57aca0e7e4a4aa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Ah1ZRJPW1nIMghPEEHqDQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae kz" href="https://docs.julialang.org/en/v1/" rel="noopener ugc nofollow" target="_blank">朱莉娅文件的截图</a></p></figure><p id="0554" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">复合语句的条件运算符略有不同:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="f9cf" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe nu nv nw nx b">&amp;&amp;</code>和<code class="fe nu nv nw nx b">||</code>操作人员称为短路<code class="fe nu nv nw nx b"><strong class="lc iu">and </strong></code>和<code class="fe nu nv nw nx b"><strong class="lc iu">or </strong></code>操作人员。我们只探索它们的标准功能；优秀的<a class="ae kz" href="https://docs.julialang.org/en/v1/manual/control-flow/#Short-Circuit-Evaluation" rel="noopener ugc nofollow" target="_blank">短路特性</a>将在文章结尾进行探讨。</p><p id="2145" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在 Julia 中还有严格的等式运算符— <code class="fe nu nv nw nx b">===</code>。这将检查值和数据类型是否相等:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="2a4e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">像任何现代语言一样，Julia 支持三元运算符:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="c41a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">不幸的是，与 Python 版本相比，这个版本<em class="ol">非常不可读</em>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="2a3b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">最后，Julia 中的值没有 Python 中的真值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="d86e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">所以，语法<code class="fe nu nv nw nx b">if value</code>在 Julia 中不起作用。为了完善这种奇怪性，Julia 中有四种类型的空值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="b9bf" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我特别喜欢<code class="fe nu nv nw nx b">nothing</code>。现在，我可以明确地在函数中不返回任何东西。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="cc9b" class="mw mx it bd my mz na dn nb nc nd dp ne lj nf ng nh ln ni nj nk lr nl nm nn no bi translated">复合表达式</h2><p id="004c" class="pw-post-body-paragraph la lb it lc b ld np ju lf lg nq jx li lj nr ll lm ln ns lp lq lr nt lt lu lv im bi translated">复合表达式在 Julia 中比在 Python 中成熟得多。</p><p id="895d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在 Python 中有很多这样的情况，一些代码行就宽度而言非常短，但仍然占据了一整行。Julia 中的复合表达式解决了这个问题，让你的代码更加紧凑。这里有一个简单的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="ac2d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">将多个表达式放在括号内并用分号分隔，就构成了一个复合表达式。此外，您不必将它们写成单行语句:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="59da" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在复合语句中创建的变量在语句结束后仍将留在它们的作用域内:</p><pre class="kj kk kl km gt nz nx oa ob aw oc bi"><span id="9a48" class="mw mx it nx b gy od oe l of og">&gt;&gt;&gt; println(x + y)</span><span id="f9db" class="mw mx it nx b gy om oe l of og">31</span></pre><p id="7093" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">您也可以使用<code class="fe nu nv nw nx b">begin</code> / <code class="fe nu nv nw nx b">end</code>语法创建复合表达式，这样可以避免分号:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="d48f" class="mw mx it bd my mz na dn nb nc nd dp ne lj nf ng nh ln ni nj nk lr nl nm nn no bi translated">用线串</h2><p id="388b" class="pw-post-body-paragraph la lb it lc b ld np ju lf lg nq jx li lj nr ll lm ln ns lp lq lr nt lt lu lv im bi translated">先简单说一下字符串:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="7418" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">尽管在数据类型方面很相似，但是在 Julia 和 Python 中字符串方法有很大的不同。例如，串联是用乘法符号非直觉地完成的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="b0de" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">或者是<code class="fe nu nv nw nx b">string</code>函数，它也将数字转换成字符串(如何转换...好玩):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="81f8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">分割字符串也有点不寻常。第一个字符不像 Python 中那样用<code class="fe nu nv nw nx b">0</code>索引，而是使用关键字<code class="fe nu nv nw nx b">begin</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="8a97" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">哦，没有负数的反向切片。相反，Julia 使用了<code class="fe nu nv nw nx b">end</code>关键字:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="e890" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">也可以用<code class="fe nu nv nw nx b">SubString</code>功能分割字符串:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="73a8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">使用<code class="fe nu nv nw nx b">$</code>符号进行字符串插值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="c356" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在 Julia 中没有针对字符串的<code class="fe nu nv nw nx b">in</code>关键字，所以您必须使用<code class="fe nu nv nw nx b">occursin</code>函数来检查子字符串:</p><pre class="kj kk kl km gt nz nx oa ob aw oc bi"><span id="dfae" class="mw mx it nx b gy od oe l of og">&gt;&gt;&gt; occursin("was", long_str)</span><span id="7781" class="mw mx it nx b gy om oe l of og">true</span></pre><p id="7599" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">重复一个字符串是通过电源符号或重复功能完成的:</p><pre class="kj kk kl km gt nz nx oa ob aw oc bi"><span id="7c6e" class="mw mx it nx b gy od oe l of og">&gt;&gt;&gt; str ^ 3</span><span id="4cf3" class="mw mx it nx b gy om oe l of og">"JuliaJuliaJulia"</span></pre><p id="6251" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">你可以从 Julia docs 的<a class="ae kz" href="https://docs.julialang.org/en/v1/base/strings/" rel="noopener ugc nofollow" target="_blank"> this </a>链接中找到标准字符串函数的列表，它包括了几乎所有你喜欢的 Python 字符串函数等等。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="205c" class="mw mx it bd my mz na dn nb nc nd dp ne lj nf ng nh ln ni nj nk lr nl nm nn no bi translated">环</h2><p id="e292" class="pw-post-body-paragraph la lb it lc b ld np ju lf lg nq jx li lj nr ll lm ln ns lp lq lr nt lt lu lv im bi translated">Julia 中的循环与 Python 相同，除了缺少冒号和在末尾添加了<code class="fe nu nv nw nx b">end</code>关键字:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="1265" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">您可以使用<code class="fe nu nv nw nx b">:</code>创建一个 iterable 对象，尽管 Julia 中也存在<code class="fe nu nv nw nx b">range</code>函数。</p><p id="3882" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">令人惊讶的是，您还可以使用<code class="fe nu nv nw nx b">=</code>符号来循环遍历一个 iterable:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="7107" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe nu nv nw nx b">break</code>、<code class="fe nu nv nw nx b">continue</code>逻辑按预期工作。<code class="fe nu nv nw nx b">zip</code>功能也是如此。</p><p id="47f8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于嵌套循环，Julia 提供了更紧凑的语法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="89d5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">每次在<code class="fe nu nv nw nx b">for</code>块中的逗号后添加 iterable 时，都会创建一个内部循环，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="06c1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe nu nv nw nx b">while</code>循环也几乎与 Python 的相同:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="5353" class="mw mx it bd my mz na dn nb nc nd dp ne lj nf ng nh ln ni nj nk lr nl nm nn no bi translated">功能</h2><p id="86da" class="pw-post-body-paragraph la lb it lc b ld np ju lf lg nq jx li lj nr ll lm ln ns lp lq lr nt lt lu lv im bi translated">函数用关键字<code class="fe nu nv nw nx b">function</code>定义，并以<code class="fe nu nv nw nx b">end</code>结束:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="2b4e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">类型声明用双分号书写(对于返回类型也是如此):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="bc86" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">Julia 还允许为上面这样的短函数定义单行函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="8ee1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">您也可以将函数分配给其他变量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="7918" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这是 Julia 的另一个特质——即使是操作符也是函数，因此可以被重新赋值(不要忘记分号):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="2b9a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这些类型的技巧也有效:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="9384" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">使用<code class="fe nu nv nw nx b">-&gt;</code>运算符对<code class="fe nu nv nw nx b">lambda</code>进行如下定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="5b4b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">要更全面地了解 Julia 中的函数，请查看<a class="ae kz" href="https://docs.julialang.org/en/v1/manual/functions/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="a388" class="mw mx it bd my mz na dn nb nc nd dp ne lj nf ng nh ln ni nj nk lr nl nm nn no bi translated">数组</h2><p id="bc82" class="pw-post-body-paragraph la lb it lc b ld np ju lf lg nq jx li lj nr ll lm ln ns lp lq lr nt lt lu lv im bi translated">创建基本数组的语法与 Python 类似:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="70ff" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">由于 Julia 是一种科学语言，基本数组被认为是向量。vector 中的元素不需要是相同的类型，就像 Python 中一样。</p><p id="8203" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">您可以使用<code class="fe nu nv nw nx b">collect</code>函数从迭代中创建向量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="7a97" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">或者使用熟悉的<code class="fe nu nv nw nx b">range</code>功能输入一系列数字:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="b5ea" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">Julia 还内置了对快速强大的 2D 和 3D 矩阵的支持。只要去掉元素之间的逗号，你就得到一个 2D 数组。记住用分号分隔各行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="36e0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">列表理解与 Python 中的相同:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="0ac5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">您也可以在生成器表达式上使用<code class="fe nu nv nw nx b">collect</code>函数来创建向量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="472e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">你可以阅读关于创建和操作向量和矩阵的所有方法的 Julia 文档，在这方面你可以学到很多东西。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="96d9" class="mw mx it bd my mz na dn nb nc nd dp ne lj nf ng nh ln ni nj nk lr nl nm nn no bi translated">字典</h2><p id="da78" class="pw-post-body-paragraph la lb it lc b ld np ju lf lg nq jx li lj nr ll lm ln ns lp lq lr nt lt lu lv im bi translated">创建字典需要与 Python 不同的语法，但逻辑是相同的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="471c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">不变性约束仍然有效——键应该只是不可变的类型，比如数字、字符串和元组。从字典中添加和检索值与 Python 中的相同。但是删除有点不同:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="1e78" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">令我高兴的是，字典中的理解在 Julia 中也有效:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="e265" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">要检查字典中是否存在关键字，使用<code class="fe nu nv nw nx b">haskey</code>功能:</p><pre class="kj kk kl km gt nz nx oa ob aw oc bi"><span id="e8a4" class="mw mx it nx b gy od oe l of og">haskey(dict1, "missing")</span><span id="eb7d" class="mw mx it nx b gy om oe l of og">false</span></pre><p id="ce7e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">获取所有的键和值都有各自的功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="7d85" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">不幸的是，没有像 Python 中那样的<code class="fe nu nv nw nx b">items</code>方法来获取键/值对。</p><p id="1b23" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">你可以阅读<a class="ae kz" href="https://docs.julialang.org/en/v1/base/collections/#Dictionaries" rel="noopener ugc nofollow" target="_blank">文档</a>来了解更多关于 Julia 中的字典。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="8e0a" class="mw mx it bd my mz na dn nb nc nd dp ne lj nf ng nh ln ni nj nk lr nl nm nn no bi translated">短路的魔力</h2><p id="e69e" class="pw-post-body-paragraph la lb it lc b ld np ju lf lg nq jx li lj nr ll lm ln ns lp lq lr nt lt lu lv im bi translated">在前面的部分中，我们简要地讨论了逻辑<code class="fe nu nv nw nx b">and</code>和<code class="fe nu nv nw nx b">or</code>如何具有短路行为。我们来细说一下。</p><p id="2a55" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">短路评估可用于替换短条件表达式。用逻辑<strong class="lc iu">和</strong>T9 来考虑这个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="51d9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">您可能会在以下条件下产生上述行为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="536e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">因此，如果条件为真，短路<code class="fe nu nv nw nx b">&amp;&amp;</code>可以用于我们想要评估表达式的情况。下面是一个总是执行的短路<code class="fe nu nv nw nx b">&amp;&amp;</code>表达式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="7dea" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">换句话说，如果短路表达式的左侧计算结果为<code class="fe nu nv nw nx b">true</code>，则执行右侧部分。</p><p id="1393" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">短路<code class="fe nu nv nw nx b">||</code>则相反。只有当左侧为<code class="fe nu nv nw nx b">false</code>时，<code class="fe nu nv nw nx b">||</code>的右侧才运行；</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="d99c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">短路可以清除许多繁琐的条件语句。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="862a" class="mw mx it bd my mz na dn nb nc nd dp ne lj nf ng nh ln ni nj nk lr nl nm nn no bi translated">结论</h2><p id="7982" class="pw-post-body-paragraph la lb it lc b ld np ju lf lg nq jx li lj nr ll lm ln ns lp lq lr nt lt lu lv im bi translated">我想 Julia 在使用方面接近 Python 还需要一段时间。Julia 可能比 Python 好几个数量级，但可能仍然无法说服许多长期的 Python 爱好者做出改变。</p><p id="300d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">你呢？你认为未来像数据科学、机器学习和人工智能这样的领域会由朱莉娅一个人统治吗？</p><p id="550a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">留下你的想法，感谢你的阅读！</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="4e7d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">您可以使用下面的链接成为高级媒体会员，并访问我的所有故事和数以千计的其他故事:</strong></p><div class="lw lx gp gr ly lz"><a href="https://ibexorigin.medium.com/membership" rel="noopener follow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">通过我的推荐链接加入 Medium。</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">ibexorigin.medium.com</p></div></div><div class="mi l"><div class="or l mk ml mm mi mn ks lz"/></div></div></a></div><p id="a8d7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">或者订阅我的邮件列表:</strong></p><div class="lw lx gp gr ly lz"><a href="https://ibexorigin.medium.com/subscribe" rel="noopener follow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">每当 Bex T .发布时收到电子邮件。</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">每当 Bex T .发布时收到电子邮件。注册后，如果您还没有中型帐户，您将创建一个…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">ibexorigin.medium.com</p></div></div><div class="mi l"><div class="os l mk ml mm mi mn ks lz"/></div></div></a></div></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="aba8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">你可以在</strong><a class="ae kz" href="https://www.linkedin.com/in/bextuychiev/" rel="noopener ugc nofollow" target="_blank"><strong class="lc iu">LinkedIn</strong></a><strong class="lc iu">或</strong><a class="ae kz" href="https://twitter.com/BexTuychiev" rel="noopener ugc nofollow" target="_blank"><strong class="lc iu">Twitter</strong></a><strong class="lc iu">上联系我，友好地聊一聊所有的事情数据。或者你可以读我的另一个故事。这些怎么样:</strong></p><div class="lw lx gp gr ly lz"><a rel="noopener follow" target="_blank" href="/good-bye-pandas-meet-terality-its-evil-twin-with-identical-syntax-455b42f33a6d"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">再见熊猫！遇见 Terality——它邪恶的孪生兄弟有着相同的语法</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">编辑描述</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">towardsdatascience.com</p></div></div><div class="mi l"><div class="ot l mk ml mm mi mn ks lz"/></div></div></a></div><div class="lw lx gp gr ly lz"><a rel="noopener follow" target="_blank" href="/github-copilot-crushes-data-science-and-ml-tasks-ultimate-review-c8bcbefb928a"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">GitHub Copilot 碾压数据科学和 ML 任务:终极回顾</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">编辑描述</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">towardsdatascience.com</p></div></div><div class="mi l"><div class="ou l mk ml mm mi mn ks lz"/></div></div></a></div><div class="lw lx gp gr ly lz"><a rel="noopener follow" target="_blank" href="/6-pandas-mistakes-that-silently-tell-you-are-a-rookie-b566a252e60d"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">6 个熊猫的错误，无声地告诉你是一个菜鸟</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">编辑描述</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">towardsdatascience.com</p></div></div><div class="mi l"><div class="ov l mk ml mm mi mn ks lz"/></div></div></a></div><div class="lw lx gp gr ly lz"><a rel="noopener follow" target="_blank" href="/8-booming-data-science-libraries-you-must-watch-out-in-2022-cec2dbb42437"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">2022 年你必须小心的 8 个蓬勃发展的数据科学图书馆</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">编辑描述</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">towardsdatascience.com</p></div></div><div class="mi l"><div class="ow l mk ml mm mi mn ks lz"/></div></div></a></div><div class="lw lx gp gr ly lz"><a rel="noopener follow" target="_blank" href="/7-cool-python-packages-kagglers-are-using-without-telling-you-e83298781cf4"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">Kagglers 正在使用的 7 个很酷的 Python 包</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">编辑描述</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">towardsdatascience.com</p></div></div><div class="mi l"><div class="ox l mk ml mm mi mn ks lz"/></div></div></a></div><div class="lw lx gp gr ly lz"><a rel="noopener follow" target="_blank" href="/22-2-built-in-python-libraries-you-didnt-know-existed-p-guarantee-8-275685dbdb99"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">22–2 个您不知道存在的内置 Python 库| P(保证)= .8</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">编辑描述</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">towardsdatascience.com</p></div></div><div class="mi l"><div class="oy l mk ml mm mi mn ks lz"/></div></div></a></div></div></div>    
</body>
</html>