<html>
<head>
<title>Exploring the Perceptron Algorithm, Using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python探索感知器算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/exploring-the-perceptron-algorithm-using-python-c1d3af53a7c7#2022-04-12">https://towardsdatascience.com/exploring-the-perceptron-algorithm-using-python-c1d3af53a7c7#2022-04-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d68a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从理论到实践，这里是你需要知道的关于这个简单而有趣又强大的方法的一切。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/95f97096c9a79553722f39131b2ab64b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UvlOyDsdIbPvTACqcLTffg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">弗拉季斯拉夫·巴比延科在<a class="ae kv" href="https://unsplash.com/s/photos/choice?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="a665" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，经典的机器学习情况。你有一个表格数据集，你必须对它进行分类。你是怎么做到的？</p><p id="1a54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，你需要非常了解你可能会用到的工具。你可以尝试使用的一个非常著名的算法是<strong class="ky ir">感知器。</strong></p><p id="4e19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从理论到实践，我们将从一个简短的理论介绍开始，然后展示一个实际的实现来检验这种机器学习方法。</p><p id="72b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇博文的最后，你将能够理解何时以及如何使用这种机器学习算法，对其所有的利弊有一个清晰的想法。</p><h1 id="3379" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1.该理论</h1><h2 id="4814" class="mk lt iq bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">1.1简介</h2><p id="2157" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">感知机有生物学上的理由存在。我们的神经元不断从其他神经元接收能量，但只有当它们接收的能量大于或等于一定量时，它们才决定被“激活”并发出自己的信号。</p><p id="6c60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">先说最终产品。最后，给定一个四维输入，这个输入用4个不同的权重处理，总和进入激活函数，你得到结果。没有比这更复杂的了。:)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/88fdf7ebc461ab06eb46a8ce16f72226.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0BjzIcuaGfaLjv33xJllVw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="6967" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们说得更清楚些。假设您有这个特性表(列)X1、X2、X3和X4。这些特征是表征数据集的单个实例(行)的4个不同值。</p><p id="b642" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个实例需要进行二进制<strong class="ky ir">分类，</strong>这样你将有一个额外的值t，这是<strong class="ky ir">目标，</strong>可以是-1或1。</p><p id="e4c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感知器算法<strong class="ky ir">将</strong> X1、X2、X3和X4乘以一组4个权重。出于这个原因，我们认为感知器是一个<strong class="ky ir">线性</strong>算法(稍后会详细介绍)。</p><p id="708c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，一个<strong class="ky ir">激活函数</strong>将被应用于该乘法的结果(同样，稍后将详细介绍激活函数)。</p><p id="8604" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个等式中的整个过程:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/66cde9630646cd26a11dedd91283f428.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fFar-xXAjdiHqqoESjOyag.png"/></div></div></figure><p id="6e2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中<strong class="ky ir"> a </strong>是所谓的激活功能。</p><p id="7590" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，输入可以是N维的(N不必是4)，因此您也可以使用N个权重+ 1个偏差。尽管如此，纯感知器算法意味着用于<strong class="ky ir">二进制</strong>分类(后面会有更多)。</p><p id="4d0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，y=a(w_1x_1+…+w_4x_4)的结果需要在-1和1之间。换句话说，在一天结束时，所谓的激活函数需要能够给你一个<strong class="ky ir">分类。</strong></p><p id="299e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么这个经常被讨论的<strong class="ky ir">激活功能</strong>是什么呢？嗯，无非是一个<strong class="ky ir">步进函数。</strong>什么意思？</p><p id="a9c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你的N维输入与N维权重的乘积会给你一个数字。那么如果这个数是<strong class="ky ir">大于0 </strong>你的算法会说<strong class="ky ir">“1”</strong>，否则会说<strong class="ky ir">-1”</strong>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/fac3c7359733a16297b3383db07b342c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*odM5_9cWnBqJuqSMYHKWNg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="7cd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是最终产品。这就是它的工作方式，这就是它做决定的方式。这里没什么真正神秘的:)。</p><p id="cc27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们继续吧。</p><h2 id="0b30" class="mk lt iq bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">1.2损失函数</h2><p id="ee6a" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">我们都知道机器学习算法带有一个<strong class="ky ir">损失函数</strong>。在这种情况下，损失函数不过是错误分类点的加权和。</p><p id="eff4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们把它变得简单些。假设你有一个没有很好分类的观点。这意味着，例如，将你的参数和你的输入相乘，你将得到-0.87的最终结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/c2f2fc6d5254041bdf01cab34cd32e6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*KprquAqFnzn470azpvl3sA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="cbc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，但重点还是那句，<strong class="ky ir">分类错误，</strong>还记得吗？所以这意味着对于那个点(t=1)，目标确实是“1”。这意味着如果你做这个乘法:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/b45d6741155879337c89994325f5e58a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qmvRst5hGy4nf8si0LKx0w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="0bce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你实际上得到了一个量，这个量告诉你<strong class="ky ir">你错了多少</strong>，你应该改变你的权重和偏差来做更好的分类工作。</p><p id="9b10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，损失函数是所有错误分类点的负和:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/ed8268fdeea92af5248fee7d5e484b8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DWBQqlA-FurQWXSCWv2dBQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="fa9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中S是错误分类点的集合。<br/>我们的想法是开始优化这个损失函数，当然我们希望最小化。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/45c307d233f772eb2e2646c3bf05d988.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*401y9T-m9iylzpQoLl7gRg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="e1bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你在上面看到的等式被称为<strong class="ky ir">梯度下降。</strong>这意味着我们沿着损耗达到最小值的方向，并沿着这个方向更新参数。</p><p id="5fbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于损失函数取决于错误分类点的数量，这意味着我们将慢慢开始校正实例，直到这样一个点，如果数据集是线性可分的(稍后将详细介绍)，将不再有“校正”的目标，并且我们的分类任务将是完美的。:)</p><h1 id="3476" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.实施</h1><p id="2645" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">当然，<a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Perceptron.html#sklearn.linear_model.Perceptron" rel="noopener ugc nofollow" target="_blank"> SkLearn感知器</a>是一个众所周知的现成实现。尽管如此，为了更好地理解它，让我们从头开始创建这个感知机。</p><p id="291e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从图书馆开始:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="bbba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们定义决策函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="a23f" class="mk lt iq bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">2.1线性可分离数据集</h2><p id="0991" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">让我们使用<a class="ae kv" href="https://scikit-learn.org/stable/datasets/toy_dataset.html" rel="noopener ugc nofollow" target="_blank"> SkLearn </a>创建一个线性可分的数据集。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="0844" class="mk lt iq bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">2.2感知器功能</h2><p id="6aa3" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">使用此功能，之前解释过的所有想法都可以实际实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="cd6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们可以使用以下代码绘制决策边界:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="114f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看玩具数据集中发生了什么:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="f3fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以看到，所有的点都被很好地分类了(甚至是红色的小三角形)。</p><p id="f42f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看损失函数图:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="4db6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着数据集现在已经完全分类了。</p><h2 id="1ae3" class="mk lt iq bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">2.2非线性可分离数据集</h2><p id="f9dc" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">让我们考虑一个更难被认为是“线性可分”的数据集。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="2d52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们运行算法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="af0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好的，现在我们可能需要一点工作来得到我们最好的分类。</p><p id="3a77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们运行不同数量的时期和不同的学习速率(所谓的超参数调整)来获得最佳版本的感知器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="6be6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些是最佳的时期数和学习率:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="58cb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3.更多考虑</h1><p id="7129" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">以下是一些需要考虑的事项:</p><ul class=""><li id="bddc" class="nk nl iq ky b kz la lc ld lf nm lj nn ln no lr np nq nr ns bi translated"><strong class="ky ir">感知器算法很快</strong>。其实无非就是线性乘法+阶跃函数应用。它超级简单易用。</li><li id="5a5e" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated"><strong class="ky ir">当数据集不是线性可分时，算法不会根据损失函数收敛。这意味着这个感知器只能(完美地)在线性可分离数据集上工作</strong>。尽管如此，我们可以对数据集应用转换，并对转换后的数据集应用感知器算法</li><li id="f32b" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">一个<strong class="ky ir">超参数调整部分</strong>可以显著提高算法的性能。</li></ul><h1 id="ecfa" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">4.结论</h1><p id="2b4d" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">如果你喜欢这篇文章，你想知道更多关于机器学习的知识，或者你只是想问我一些你可以问的问题:</p><p id="08dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">A.在<a class="ae kv" href="https://www.linkedin.com/in/pieropaialunga/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> Linkedin </strong> </a>上关注我，我在那里发布我所有的故事<br/> B .订阅我的<a class="ae kv" href="https://piero-paialunga.medium.com/subscribe" rel="noopener"> <strong class="ky ir">简讯</strong> </a>。这会让你了解新的故事，并给你机会发短信给我，让我收到你所有的更正或疑问。<br/> C .成为<a class="ae kv" href="https://piero-paialunga.medium.com/membership" rel="noopener"> <strong class="ky ir">推荐会员</strong> </a>，这样你就不会有任何“本月最大数量的故事”，你可以阅读我(以及成千上万其他机器学习和数据科学顶级作家)写的任何关于现有最新技术的文章。</p></div></div>    
</body>
</html>