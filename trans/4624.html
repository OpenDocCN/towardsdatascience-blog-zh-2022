<html>
<head>
<title>BigQuery SQL Optimization 2: WITH Temp Tables to Fast Results</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BigQuery SQL优化2:使用临时表快速获得结果</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/bigquery-sql-optimization-2-with-temp-tables-to-fast-results-41869b15fcff#2022-10-14">https://towardsdatascience.com/bigquery-sql-optimization-2-with-temp-tables-to-fast-results-41869b15fcff#2022-10-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="467b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">何时使用临时表而不是WITH</h2></div><p id="678d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">查询的最大性能杀手之一是在不应该使用<code class="fe le lf lg lh b">CREATE TEMP TABLE</code>的情况下使用<code class="fe le lf lg lh b">WITH</code>!在阐明了我们应该尽早使用<a class="ae li" rel="noopener" target="_blank" href="/bigquery-sql-optimization-1-filter-as-early-as-possible-60dfd65593ff"> <em class="lj">过滤器之后，让我们继续讨论何时使用或避免<code class="fe le lf lg lh b">WITH</code>。</em></a></p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lk"><img src="../Images/f576d79ce95e6f72e3f06f0965d2d13d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G_5KkJqpDSgURpizN3OZhw.jpeg"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">(作者供图)</p></figure><h1 id="6ba1" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">患有急性健忘症</h1><p id="6c23" class="pw-post-body-paragraph ki kj it kk b kl ms ju kn ko mt jx kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated"><code class="fe le lf lg lh b">WITH</code>语句也叫<em class="lj">常用表表达式</em> (CTE)。它们有助于消除查询的混乱，使查询更具可读性，因为它们将子查询从上下文中提取出来，并为它们命名。</p><p id="63b6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">即</p><pre class="ll lm ln lo gt mx lh my mz aw na bi"><span id="e30c" class="nb mb it lh b gy nc nd l ne nf">SELECT a, b, c<br/>FROM (SELECT x, y, z FROM ...)</span></pre><p id="17fa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">变成了</p><pre class="ll lm ln lo gt mx lh my mz aw na bi"><span id="47db" class="nb mb it lh b gy nc nd l ne nf">WITH my_CTE AS (SELECT x, y, z FROM ...)</span><span id="3e1d" class="nb mb it lh b gy ng nd l ne nf">SELECT a, b, c<br/>FROM my_CTE</span></pre><p id="44cb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">my_CTE</code>看起来像一张桌子，因为它在一个表单的后面——但它不是桌子。它更像是实时指令，无论何时调用它，都会在运行时动态创建一个结果表。</p><h1 id="34e6" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated"><em class="nh">每次你引用一个CTE，它就会被执行</em></h1><p id="c43d" class="pw-post-body-paragraph ki kj it kk b kl ms ju kn ko mt jx kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">太疯狂了，对吧？cte不会记住任何以前执行的结果！所以如果你这样做…</p><pre class="ll lm ln lo gt mx lh my mz aw na bi"><span id="c0d7" class="nb mb it lh b gy nc nd l ne nf">WITH <strong class="lh iu"><em class="lj">a</em></strong> AS (...)</span><span id="97e3" class="nb mb it lh b gy ng nd l ne nf">,a1 AS (SELECT aggr_1 FROM <strong class="lh iu"><em class="lj">a</em></strong>)</span><span id="5ae0" class="nb mb it lh b gy ng nd l ne nf">,a2 AS (SELECT aggr_2 FROM <strong class="lh iu"><em class="lj">a</em></strong>)<br/></span><span id="bd37" class="nb mb it lh b gy ng nd l ne nf">SELECT ... FROM a1 LEFT JOIN a2</span></pre><p id="e4fc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">…然后你需要在读完这篇文章后立即修改这个查询，因为你通过计算两次<code class="fe le lf lg lh b"><strong class="kk iu"><em class="lj">a</em></strong></code>给你的查询引擎和计算槽带来了很多<em class="lj">不必要的负载</em>！</p><h1 id="d53e" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">不要忘记:临时表</h1><p id="35dd" class="pw-post-body-paragraph ki kj it kk b kl ms ju kn ko mt jx kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">那么我们该怎么办呢？<code class="fe le lf lg lh b"><strong class="kk iu"><em class="lj">a</em></strong></code>应该是一个临时表，因为它们会记住结果——至少在查询运行期间。</p><p id="0f5a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之前的查询应该是这样的:</p><pre class="ll lm ln lo gt mx lh my mz aw na bi"><span id="593d" class="nb mb it lh b gy nc nd l ne nf">CREATE TEMP TABLE <strong class="lh iu"><em class="lj">a</em></strong> AS (...)</span><span id="9afa" class="nb mb it lh b gy ng nd l ne nf">WITH a1 AS (SELECT aggr_1 FROM <strong class="lh iu"><em class="lj">a</em></strong>)</span><span id="b08b" class="nb mb it lh b gy ng nd l ne nf">,a2 AS (SELECT aggr_2 FROM <strong class="lh iu"><em class="lj">a</em></strong>)<br/></span><span id="9d8d" class="nb mb it lh b gy ng nd l ne nf">SELECT ... FROM a1 LEFT JOIN a2</span></pre><p id="cff8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们只计算一次<code class="fe le lf lg lh b"><strong class="kk iu"><em class="lj">a</em></strong></code>，并将其用于<code class="fe le lf lg lh b">a1</code>和<code class="fe le lf lg lh b">a2</code>中的两个不同聚合。</p><p id="80bb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这和之前的例子没什么不同，对吧？但是它会执行得更好，因为我们省去了<code class="fe le lf lg lh b"><strong class="kk iu"><em class="lj">a</em></strong></code>的第二次计算。</p><p id="c648" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您也不需要担心在特定数据集中创建表或删除表——它将由BigQuery处理，并在您的SQL语句运行完毕后消失。</p><p id="d6c7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我见过CTE被引用超过5次的查询。至少可以说，将该表重构为临时表很有帮助。为了证明它有帮助，我们可以对几次运行进行采样:</p><ul class=""><li id="9849" class="ni nj it kk b kl km ko kp kr nk kv nl kz nm ld nn no np nq bi translated">准备好已优化和未优化的查询</li><li id="9b08" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">停用缓存</li><li id="d9bc" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">通过减少查询的数据量来保持合理的总工作量</li><li id="4648" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated">大约同时运行两个查询5次，比较它们的平均槽时间</li></ul><h1 id="1c81" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">如何在创建临时表时重构旧查询</h1><p id="afd9" class="pw-post-body-paragraph ki kj it kk b kl ms ju kn ko mt jx kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">除了上面显示的变化之外，您可能会遇到希望将cte与临时表混合的情况。如果您真的只需要运行一次CTE，那么它会比运行然后临时存储它稍微快一些。因此，如果我们可以跳过临时存储这一步，我们应该这样做。那么我们如何混合cte和临时表呢？</p><p id="06c6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以把<code class="fe le lf lg lh b">CREATE TEMP TABLE</code>看作是更根本的操作。为了一起使用它们，它将简单地包含CTE定义，因为它们只是使子查询更可读，但本质上与子查询是一样的:</p><pre class="ll lm ln lo gt mx lh my mz aw na bi"><span id="6c07" class="nb mb it lh b gy nc nd l ne nf">CREATE TEMP TABLE a AS (</span><span id="7d2b" class="nb mb it lh b gy ng nd l ne nf">  WITH x AS (...),<br/>  y as (...)</span><span id="c5c0" class="nb mb it lh b gy ng nd l ne nf">  SELECT ... FROM x LEFT JOIN y ON ...</span><span id="fd9a" class="nb mb it lh b gy ng nd l ne nf">)<br/></span><span id="a41c" class="nb mb it lh b gy ng nd l ne nf">SELECT ... FROM a ...</span></pre><p id="7725" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个查询将使用CTE <code class="fe le lf lg lh b">x</code>(在<code class="fe le lf lg lh b">a</code>的定义中定义)来创建临时表<code class="fe le lf lg lh b">a</code>。</p><p id="6f67" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">总结一下:使用cte整理您的SQL语句，使它们更具可读性。但是不要多次引用CTE，因为每次查询引擎都会重新计算结果。在这种情况下，请使用临时表——它们会给处理成本增加额外的存储步骤，但这(从临时表中读取)可能比重新计算整个查询更便宜。</p><p id="a6ca" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">别忘了尽早将这个最佳实践与<a class="ae li" rel="noopener" target="_blank" href="/bigquery-sql-optimization-1-filter-as-early-as-possible-60dfd65593ff">过滤结合起来</a>！</p><p id="dfc9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">重构快乐！</p></div></div>    
</body>
</html>