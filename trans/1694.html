<html>
<head>
<title>Do You Know the Logical Analysis of Data Methodology (LAD)?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你知道数据方法论的逻辑分析(LAD)吗？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/do-you-know-the-logical-analysis-of-data-methodology-lad-76365b33bc63#2022-04-21">https://towardsdatascience.com/do-you-know-the-logical-analysis-of-data-methodology-lad-76365b33bc63#2022-04-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f2ab" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们快速浏览一下</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/26dd1828f94b471b0019105d22b2092c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wCXLttpRWdjgFGS7qnVZLA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae kv" href="https://pixabay.com/fr/users/geralt-9301/" rel="noopener ugc nofollow" target="_blank"> geralt </a>来自<a class="ae kv" href="https://pixabay.com/fr/" rel="noopener ugc nofollow" target="_blank"> pixabay </a>。</p></figure><p id="a7f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我最近发现了一个数据分析领域，这个领域始于1986年彼得·l·哈默的工作，叫做<em class="ls">数据的逻辑分析</em> (LAD)。我问了一圈，没人听说过。所以我决定写一篇关于这种原始的数据分析方法的简介。本文是基于[1]的第三章和[2]的文章。</p><p id="6eb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">LAD是一种二元可解释分类方法，基于最优化、布尔函数和组合理论的混合。但是请放心，理解这个理论的基础不需要任何先决条件。这是一种具有竞争力的分类方法，用于分析由二元观测值组成的数据集，通过其<em class="ls">模式</em>的概念提供清晰的解释。</p><p id="e911" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">LAD从数据集中提取大量的模式集合，其中一些是具有肯定分类的观察结果的特征，而另一些是具有否定分类的观察结果的特征。然后对该集合进行过滤，以提取更小的、非冗余的模式集合。这种简化允许为每个分类提供可理解的解释。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="7078" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">介绍</h1><p id="0418" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">要理解什么是童子，我举个常见的例子。一位医生想找出哪些食物会导致他的病人头痛。为此，他的病人记录了一周的饮食，如下表所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/613f9084d0622860e2c7b69b9bca5bb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YS8HJoZVLIZsROpxDROxkA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">饮食记录。作者的表格。</p></figure><p id="0e01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">快速分析让医生得出两个结论。首先，他注意到病人在不头痛的日子里从不吃没有食物n 1的食物n 2，但是在他确实头痛的日子里吃了食物N2。他注意到没有食物n 6的食物n 4也有同样的模式。因此，他得出结论，他的病人的头痛可以用这两种模式来解释。</p><p id="1e66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在不知情的情况下，医生对饮食记录数据集执行了LAD。事实上，在他的分析过程中，他不得不回答以下三个问题:<br/><strong class="ky ir">【1】</strong>如何提取一个短的特征列表(即食物项目)足以对数据进行分类(即解释头痛的发生)？<br/> <strong class="ky ir"> (2) </strong>如何检测导致头痛的模式(即食物项目的组合)？<br/> <strong class="ky ir"> (3) </strong>如何建立解释每一次观察的理论(即模式集合)？<br/>这些问题总结了LAD方法。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="58e3" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">符号和定义。</h1><p id="ace0" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">数据的逻辑分析基于部分定义的布尔函数  (pdBf)和模式<strong class="ky ir"><em class="ls">的概念。</em></strong></p><p id="3abe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们设置<em class="ls"> B = {0，1} </em>。集合<em class="ls"> Bⁿ </em>，通常被命名为维数为<em class="ls"> n </em>的布尔超立方体，由所有可能的长度为<em class="ls"> n </em>的二进制序列组成。我们对<em class="ls"> Bⁿ </em>上的一个偏序<em class="ls"> ≤ </em>定义如下:<em class="ls">一个=(a₁，…，aₙ) ≤ b=(b₁，…，bₙ) </em>当且仅当<em class="ls"> aᵢ ≤ bᵢ </em>对于每个<em class="ls"> i=1，…，n </em>。</p><p id="c5b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个子集S ⊆ <em class="ls"> Bⁿ </em>被称为<em class="ls"> Bⁿ </em>的<strong class="ky ir">子立方体当且仅当<em class="ls"> |S|=2ᵏ </em> for <em class="ls"> k ≤ n </em>并且存在<em class="ls"> n-k </em>分量，其中<em class="ls"> S </em>的所有序列重合。例如<em class="ls"> S={(0，0，0)，(0，0，1)，(0，1，0)，(0，1，1)} </em>是<em class="ls"> B </em>对于<em class="ls"> k=2 </em>的子码</strong></p><h2 id="0e3e" class="my mb iq bd mc mz na dn mg nb nc dp mk lf nd ne mm lj nf ng mo ln nh ni mq nj bi translated">什么是<strong class="ak"> <em class="nk">部分定义的布尔函数</em> </strong>？</h2><p id="bede" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">一个<strong class="ky ir"> <em class="ls">布尔函数</em> </strong>，<em class="ls"> f </em>，是从<em class="ls"> Bⁿ </em>到<em class="ls"> B </em>的映射。还有2^(2ⁿ)可能的布尔函数。对于一个布尔函数<em class="ls"> f </em>，我们设<em class="ls"> T=T(f)={a ∈ Bⁿ </em>如<em class="ls"> f(a)=1} </em>和<em class="ls"> F=F(f)={a ∈ Bⁿ </em>如<em class="ls"> f(a)=0} </em>为<em class="ls"> f </em>的真点和的假点的集合一个<strong class="ky ir"> <em class="ls">部分定义的布尔函数</em> </strong> (pdBf)是一个布尔函数，使得<em class="ls"> T </em>和<em class="ls"> F </em>不相交，但是<em class="ls"> Bⁿ </em>的一些元素既不属于<em class="ls"> T </em>也不属于<em class="ls"> F </em>。我们可以将饮食记录表重写为pdBf，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/73488b5bd133e149dd9b7262e0b950cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LX89CREhYwuS8No265mRzw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一种部分定义的布尔函数。作者的表格。</p></figure><p id="e285" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此表中1、5、7点属于<em class="ls"> T </em>(真点)，2、3、4、6点属于<em class="ls"> F </em>(假点)。但是序列<em class="ls"> (1，1，1，1，1，1，1) </em>既不属于<em class="ls"> T </em>也不属于<em class="ls">f</em>能够预测它会很有趣。</p><h2 id="73a3" class="my mb iq bd mc mz na dn mg nb nc dp mk lf nd ne mm lj nf ng mo ln nh ni mq nj bi translated">什么是模式？</h2><p id="7254" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">为了定义模式，我必须引入<em class="ls">术语</em>的概念。我们把<em class="ls"> x ∈ B的<strong class="ky ir"> <em class="ls">补语</em> </strong> <em class="ls"> </em>定义为x⁻= 1-x .</em>a<em class="ls"/><strong class="ky ir"><em class="ls">项</em> </strong>是<em class="ls"> B </em>的元素及其补语的乘积。而一个项的<strong class="ky ir"> <em class="ls">度</em> </strong>就是其中的元素个数，命名为<strong class="ky ir"> <em class="ls">字面</em> </strong> s，例如，设<em class="ls"> t </em>为一个度为<em class="ls"> 3 </em>的项使得<em class="ls"> t=x⁻₁x₂x₃，</em>则<em class="ls"> t(0，0，1)=(1–0)×0×1 = 0。</em>需要注意的是<em class="ls"> t(a) </em>是为任何<em class="ls"> a ∈ Bⁿ </em>定义的，即使<em class="ls"> t </em>的次数小于<em class="ls"> n </em>，忽略不在该项中的值即可。<em class="ls"> </em>如果<em class="ls"> t=x₂x⁻₃ </em>那么<em class="ls"> t(0，0，1)= 0×(1–1)= 0。</em>如果<em class="ls"> t(a)=1 </em>我们说<em class="ls"> t </em> <strong class="ky ir"> <em class="ls">覆盖</em> </strong>点<em class="ls"> a </em>。</p><p id="2f8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">模式是LAD的核心元素。一个术语<em class="ls"> t </em>叫做一个pdBf的<strong class="ky ir"> <em class="ls">正</em> </strong> ( <strong class="ky ir"> <em class="ls">负</em> </strong> ) <strong class="ky ir"> <em class="ls">模式</em> </strong>，<em class="ls"> f，</em>当且仅当:<br/>1-<em class="ls">t(x)= 0∀</em><em class="ls">x 871<br/>例如，术语<em class="ls"> x⁻₁x₂ </em>等于<em class="ls"> 1 </em>当且仅当<em class="ls"> x₁=0 </em>和<em class="ls"> x₂=1.</em>所以，在前面的例子中，这一项只涵盖了点1和点7，它们在<em class="ls"> T(f)中。</em>这个术语叫做f的正型，可以注意到<em class="ls"> x₄x⁻₆ </em>也是<em class="ls"> f </em>的正型。在医生的分析中发现了这两种模式。分别地，<em class="ls"> F(f) </em>中覆盖点的项称为F的否定模式。</em></p><p id="7f9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了比较模式，我们需要引入一些合理的适合性标准:<em class="ls">简单性</em>，<em class="ls">选择性</em>，以及<em class="ls">证据</em>。这些标准定义了模式的一个简单的部分前序，称为<strong class="ky ir"> <em class="ls">偏好</em> </strong>。设<em class="ls"> P </em>为模式，<em class="ls"> f </em>为pdBf，则我们有:</p><p id="e44c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">简单性</strong>:考虑到<em class="ls"> P </em>的文字集，对<em class="ls"> P </em>的简单性进行评估。这就是σ偏好，我们定义<em class="ls"> P₂ ≤_σ P₁ </em>当且仅当<em class="ls"> P₁ </em>的文字集是<em class="ls"> P₂ </em>的子集。</p><p id="a5d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">选择性:</strong>考虑p的子立方体(即<em class="ls"> Bⁿ </em>被<em class="ls">p】</em>覆盖的点的子集)来评估<em class="ls"> P </em>的选择性。这是σ偏好，我们定义<em class="ls">p₂≤_σp₁</em>当且仅当<em class="ls"> P₁ </em>的子多维数据集是<em class="ls"> P₂ </em>的子多维数据集的子集。</p><p id="bc47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">证据:</strong>考虑到<em class="ls"> P </em>所覆盖的<em class="ls"> T(f) </em>的集合，对<em class="ls"> P </em>的证据进行评估。这是ϵ偏好，我们定义<em class="ls"> P₂ ≤_ϵ P₁ </em>当且仅当<em class="ls"> P₁ </em>覆盖的真点集是<em class="ls"> P₂ </em>覆盖的真点集的子集。</p><p id="74b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还可以使用交集∩和字典式细化|来组合偏好。设λ和γ是两个偏好，则我们有:</p><ul class=""><li id="9d2e" class="nm nn iq ky b kz la lc ld lf no lj np ln nq lr nr ns nt nu bi translated"><em class="ls"> P₁ </em> ≤_(λ ∩ γ) <em class="ls"> P₂ </em>当且仅当<em class="ls"> P₁ </em> ≤_λ <em class="ls"> P₂ </em> <strong class="ky ir">和</strong> <em class="ls"> P₁ </em> ≤_γ <em class="ls"> P₂ </em>。</li><li id="752c" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated"><em class="ls"> P₁ </em> ≤_(λ | γ) <em class="ls"> P₂ </em>当且仅当<em class="ls"> P₁ &lt; _λ P₂ </em>或<em class="ls"> (P₁ ≈_λ P₂ </em> <strong class="ky ir">和</strong> <em class="ls"> P₁ ≤_γ P₂) </em>。</li></ul><p id="899f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设λ为偏好，一个模式<em class="ls"> P </em>称为<strong class="ky ir"> <em class="ls">帕累托最优模式</em> </strong>当且仅当不存在模式<em class="ls">P’≠P</em>使得<em class="ls">P ≤_λP’。</em>不幸的是，<em class="ls">最优</em>模式的概念没有唯一的定义。我们总结了关于偏好和偏好组合的帕累托最优模式的性质。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/8e7244480420f2cb161dad1be4894572.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4KSnzV1rP73b22FZwYwAGw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">帕累托最优的类型。作者的表格。</p></figure><p id="5989" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在头痛的例子中，术语x₂x₅x₈是<em class="ls"> f </em>的正模式(它涵盖了第5点和第7点)。但不是<strong class="ky ir"> <em class="ls">小项</em> </strong>。事实上，x₂x₅也是一个阳性模式，x₂x₅x₈的亚立方体也包括在x₂x₅.的亚立方体中在这里，x₂x₅是一个短期的积极模式。</p><p id="acd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑到正模式<em class="ls"> x₂x₅x⁻₆x⁻₇x₈ </em>，我们可以说不存在<em class="ls"> i ∈ {1，3，4} </em>这样的<em class="ls"> x₂x₅x⁻₆x⁻₇x₈xᵢ </em>是一个模式。由此可见，<em class="ls"/>是一个<strong class="ky ir"> <em class="ls">质数</em> </strong>的正模式。</p><p id="0f5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而且，x₂x₅和<em class="ls"> x₂x₅x⁻₆x⁻₇x₈ </em>都是<strong class="ky ir"> <em class="ls">强</em> </strong>正格局<em class="ls">。</em>这是因为，没有模式覆盖的真点的例子。于是，x₂x₅是一个<strong class="ky ir"> <em class="ls">跨区</em> </strong>的正格局(mintern and strong)<em class="ls"/>是一个<strong class="ky ir"> <em class="ls">强素数</em> </strong>的正格局。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="a781" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">法律援助署的方法</h1><p id="c141" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">现在，我们已经准备好采用LAD的方法。LAD的主要目的是找到pdBF的扩展(如前所述)。但是有许多方法可以扩展这个功能。难点在于找到了<em class="ls">好的一个</em>，称之为<strong class="ky ir"> <em class="ls">论</em> </strong>。为此，LAD分三个主要步骤进行处理:<br/> 1-将数据集转化为pdBf。它被称为<strong class="ky ir"> <em class="ls">二值化</em> </strong>过程。<br/> 2-检测医生在介绍中提出的合适模式。<br/> 3-成型理论。这意味着提取关于所有检测模式的pdBf的最佳扩展。</p><h2 id="ce5f" class="my mb iq bd mc mz na dn mg nb nc dp mk lf nd ne mm lj nf ng mo ln nh ni mq nj bi translated">二值化。</h2><p id="9af8" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">第一步是数据的<strong class="ky ir"> <em class="ls">二值化</em> </strong>。许多真实数据集包含数值数据和名义数据。将标称数据二进制化的一种简单方法是使用一键编码技术。这是一种非常快速的技术，数据会按照预期进行转换。数字数据的二进制化稍微复杂一些。一种常见的方法是选择临界值或分界点，并使用指标特征。要么该特征的性质表明了切割点的选择(如医学中的身体质量指数)，要么它更复杂，仍有待改进。不幸的是，二值化过程通过添加许多特征增加了数据集的维度。因此，通过特征选择来减小尺寸是很重要的。</p><h2 id="b979" class="my mb iq bd mc mz na dn mg nb nc dp mk lf nd ne mm lj nf ng mo ln nh ni mq nj bi translated">检测模式。</h2><p id="15c4" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">可以想象，这部分过程仍然是一个开放的研究领域，选择什么样的算法来生成模式取决于你想找到什么样的模式。在这里，我将给出一个在[4]中介绍的算法，用于提取正的<strong class="ky ir"> <em class="ls">素数模式</em> </strong>。对于负图案，算法是相似的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/8f1980e7ae1f66d31d28a17038cbfcf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tm3CAnGNJgILb3uW9fITgA.png"/></div></div></figure><p id="d6f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个伪代码背后的想法很简单。目标是测试从1度到D度的术语，并且只保留那些具有正模式的术语。不考虑否定模式，包含正负两点的术语将作为下一个学位的候选项。</p><p id="edf5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有几种算法可以生成不同类型的合适模式。如果你想了解他们的情况，我建议你参考[2]和[3]。</p><h2 id="2219" class="my mb iq bd mc mz na dn mg nb nc dp mk lf nd ne mm lj nf ng mo ln nh ni mq nj bi translated">形成理论。</h2><p id="c9c0" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在这个阶段，我们有很多模式。当然太多了，无法创建一个可解释的模型，这是LAD的优势。因此，我们需要从生成的模式集中选择一组合适的模式。所选择的集合应该有合理数量的元素，但也有足够的元素来很好地区分积极和消极的观察。这个选择过程可以表示为一个优化问题。</p><p id="bf87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于每个积极的模式，<em class="ls"> pₖ </em>，我们分配一个二元变量<em class="ls"> yₖ </em>，使得<em class="ls"> yₖ=1 </em>当且仅当<em class="ls"> pₖ </em>被包括在最终模型中。并且对于每一个肯定的观察值<em class="ls"> tᵢ </em>，我们定义一个二元向量<em class="ls"> (tᵢ，tᵢ，…，tᵢᵖ) </em>，其中<em class="ls"> p </em>是肯定模式的数量，并且<em class="ls"> tᵢᵏ=1 </em>当且仅当<em class="ls"> pₖ </em>覆盖<em class="ls"> tᵢ </em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/7f225630591c6b7a88958402026e0e1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*1dYGwTDcGBwEfAIXK8S64Q.png"/></div></figure><p id="9037" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个优化问题可以很容易地适应你的需求，代价是小的变化。约束条件右侧的值<em class="ls"> 1 </em>可以增加，以确保一个决策至少有两个(或更多)模式。我们还可以在总和<em class="ls"> ∑ wₖyₖ.中的每个模式上添加一个权重<em class="ls"> wₖ </em></em>例如，这些权重可以通过每个模式的程度来索引，以促进具有更容易被人类解释的少量文字的模式。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="2890" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结论</h1><p id="2fa6" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">数据的逻辑分析是一种非常有趣的分类方法，仍然是一个活跃的研究领域。LAD基于模式的概念，模式是对新观察结果进行分类的工具，并为每个分类提供可理解的解释。</p><p id="aa07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">LAD在医学上有许多应用，如<a class="ae kv" href="https://pubmed.ncbi.nlm.nih.gov/16859500/" rel="noopener ugc nofollow" target="_blank">乳腺癌预后</a>、<a class="ae kv" href="https://pubmed.ncbi.nlm.nih.gov/14997498/" rel="noopener ugc nofollow" target="_blank">卵巢癌检测</a>、<a class="ae kv" href="https://pubmed.ncbi.nlm.nih.gov/18689833/" rel="noopener ugc nofollow" target="_blank">生存数据分析</a>等(概述见【2】)。我认为它也可以很容易地应用于许多其他领域。</p><p id="d50f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，LAD似乎缺乏知名度，我希望这篇短文能激发您的兴趣。这是一种生成可解释的分类模型的优雅方式，不同于通常的基于树的算法和基于规则的算法。随后将有一篇关于python应用程序的文章。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="d06d" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">参考</h1><p id="69a4" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">[1]奇卡洛夫、洛津、洛兹纳、莫什科夫、阮、斯科龙和杰洛斯科。<a class="ae kv" href="https://link.springer.com/book/10.1007/978-3-642-28667-4" rel="noopener ugc nofollow" target="_blank"> <em class="ls">数据分析的三种途径:测验理论、粗糙集和数据的逻辑分析</em> </a> <em class="ls"> </em> (2012)第41卷。施普林格科学&amp;商业媒体。</p><p id="5603" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[2]阿利克夏、阿利克夏、博纳特斯、科岗。<a class="ae kv" href="https://www.researchgate.net/profile/Gabriela-Alexe/publication/220642889_Logical_analysis_of_data_-_The_vision_of_Peter_L_Hammer/links/00b7d522251543608f000000/Logical-analysis-of-data-The-vision-of-Peter-L-Hammer.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="ls">数据的逻辑分析——彼得·l·哈默的愿景。</em> </a> (2007)《数学与人工智能年鉴》49卷，第1期:265–312页。</p><p id="1028" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[3] P.L .哈默、a .科岗、b .西默内、s .斯泽德马克<a class="ae kv" href="https://www.sciencedirect.com/science/article/pii/S0166218X04001878" rel="noopener ugc nofollow" target="_blank"> <em class="ls">数据逻辑分析中的帕累托最优模式</em> </a>。(2004)离散应用数学144，第1–2期:79–102。</p><p id="aaa0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[4]马约拉斯。<em class="ls">用于数据逻辑分析的C++工具</em>。(1995)鲁特科尔研究报告:1–95。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="e8b3" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">关于我们</h1><p id="f356" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated"><a class="ae kv" href="https://www.advestis.com/" rel="noopener ugc nofollow" target="_blank"> Advestis </a>是一家欧洲合同研究组织(CRO ),对统计学和可解释的机器学习技术有着深刻的理解和实践。Advestis的专长包括复杂系统的建模和时间现象的预测分析。</p><p id="9f59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">领英</em>:<a class="ae kv" href="https://www.linkedin.com/company/advestis/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/company/advestis/</a></p></div></div>    
</body>
</html>