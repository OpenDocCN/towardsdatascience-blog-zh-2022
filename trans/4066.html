<html>
<head>
<title>SQL Window Functions Interview Questions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL窗口函数面试问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sql-window-functions-interview-questions-d194c9e853d#2022-09-09">https://towardsdatascience.com/sql-window-functions-interview-questions-d194c9e853d#2022-09-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="172e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">这里有一篇文章可以帮助你回答需要了解SQL窗口函数的SQL面试问题</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/e7df7ff152db1409d7dedcb76fa71a0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U1DSdrpzB3AfAuQsrw2SAg.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">作者在<a class="ae kw" href="https://canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>上创建的图片</p></figure><p id="22a1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果你想从事数据科学工作——如果你不想，你就不会读这篇文章——你必须精通至少两个领域:SQL和工作面试。是的，两者都是需要练习的技能。</p><p id="e6e9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当我们说SQL时，这是一个非常广泛的领域，甚至它的创建者也可能不了解它的一切。没有必要告诉你应该学习“完整的”SQL来获得一份数据专业人员的工作。为什么？因为你不需要！去骑自行车，游泳，看书。盯着墙壁看油漆变干比学习“整个”SQL更有意义。</p><p id="fc29" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">你需要的是对<strong class="kz ir">一些</strong> SQL概念的深入了解。你在实践中会用到的。窗口函数就是其中之一。面试官喜欢他们，你也会喜欢他们，因为他们真的会让你的日常工作变得更容易。</p><p id="d19e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">工作面试呢？这算什么技能？这难道不是你找工作必须经历的可怕事件吗？是的，它是。但不仅如此！当我们谈到它是一项技能时，我们指的是有一个清晰的方法来回答SQL问题。</p><p id="7a32" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">编写正确的SQL代码很重要，不要误解我们。但是有一个解决面试问题的框架也同样重要。这不是一个委婉的说法。有一个好的框架，你会更容易写出完美的代码。即使你搞砸了，每个人有时都会这样，你也会因为你的过程和思考方式而得分。</p><h1 id="5f64" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">SQL窗口函数到底是什么？</h1><p id="5373" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">你还不知道吗？别担心，有一个<a class="ae kw" href="https://www.stratascratch.com/blog/the-ultimate-guide-to-sql-window-functions/?utm_source=blog&amp;utm_medium=click&amp;utm_campaign=medium" rel="noopener ugc nofollow" target="_blank"> SQL窗口函数</a>指南，在那里你会学到更多你想知道的东西。</p><p id="6a64" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">对于那些已经熟悉窗口函数的人来说，在我们开始解决SQL窗口函数面试问题之前，有一个简短的提醒。</p><p id="f40a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">窗口函数通常被视为SQL聚合函数<a class="ae kw" href="https://www.stratascratch.com/blog/the-ultimate-guide-to-sql-aggregate-functions/?utm_source=blog&amp;utm_medium=click&amp;utm_campaign=medium" rel="noopener ugc nofollow" target="_blank">的更豪华版本</a>。您已经知道，聚合函数从多行中获取值并返回一个值。没错，这就是数据聚合。最常用的聚合函数是SUM()、COUNT()、AVG()、MIN()和MAX()。</p><p id="0b1a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">它们通常用在GROUP BY子句中。这样，数据可以在多个列上聚合，这扩展了聚合函数的分析能力。</p><p id="83a5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">但是，它们仍然不保留作为聚合基础的单个行。窗口函数有，这是两者的主要区别！换句话说，SQL窗口函数允许您聚合数据并显示聚合背后的分析背景。</p><p id="4d68" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">但是，窗口的功能还不止这些。它们大致分为三类:</p><ul class=""><li id="e0d1" class="mq mr iq kz b la lb ld le lg ms lk mt lo mu ls mv mw mx my bi translated">聚合窗口函数</li><li id="ddd9" class="mq mr iq kz b la mz ld na lg nb lk nc lo nd ls mv mw mx my bi translated">排名窗口函数</li><li id="ef27" class="mq mr iq kz b la mz ld na lg nb lk nc lo nd ls mv mw mx my bi translated">值窗口函数</li></ul><p id="29a5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">你可以在上面的指南中读到所有关于它们的内容。我们是来给你看实际例子的，不是用理论把你烦死的。因此，让我们设置一下解决SQL窗口函数面试问题的方法，看看如何将其应用于测试您的窗口函数知识的问题。</p><h1 id="41b4" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">如何接近SQL窗口函数面试问题？</h1><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/9a9d93eaae799d55949e33b833cc8710.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K-4_DvHdXIw11wmp"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">作者在<a class="ae kw" href="https://canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>上创建的图像</p></figure><p id="a1f5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">构成解决问题的“正确”方法的唯一东西是使它结构化。所有其他事情都不太相关。方法因人而异，取决于你的思维方式和你觉得舒服的方法。</p><p id="c34f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们被证明是成功的方法包括以下步骤。</p><ol class=""><li id="dabd" class="mq mr iq kz b la lb ld le lg ms lk mt lo mu ls ne mw mx my bi translated">探索数据集</li><li id="d4da" class="mq mr iq kz b la mz ld na lg nb lk nc lo nd ls ne mw mx my bi translated">确定用于解决问题的列</li><li id="09d9" class="mq mr iq kz b la mz ld na lg nb lk nc lo nd ls ne mw mx my bi translated">写出代码逻辑</li><li id="4064" class="mq mr iq kz b la mz ld na lg nb lk nc lo nd ls ne mw mx my bi translated">编码</li></ol><h2 id="5a3f" class="nf lu iq bd lv ng nh dn lz ni nj dp md lg nk nl mf lk nm nn mh lo no np mj nq bi translated">1.探索数据集</h2><p id="7c61" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">面试问题通常有一个具体的数据集，你应该使用它来提出解决方案。</p><p id="2623" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">数据是以测试某些SQL概念的方式建立的。总是需要一些时间来了解数据类型，并检查数据是否有重复、空值或缺失值。这些都会影响你的代码和你必须使用的函数。</p><p id="0a92" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果有多个表，检查这些表是如何相互连接的，如何连接它们，以及应该使用哪种连接。</p><p id="8a70" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这并不总是可能的，但是如果可能的话，预览数据本身。这将有助于您获得一个更清晰的画面，并可能找到您仅通过查看列名和数据类型可能会遗漏的一些内容。</p><h2 id="3025" class="nf lu iq bd lv ng nh dn lz ni nj dp md lg nk nl mf lk nm nn mh lo no np mj nq bi translated">2.确定用于解决问题的列</h2><p id="a9af" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">少不是多，但通常足够了！大多数问题会给你比你需要写一个解决方案更多的数据。用这个步骤去掉你不需要的列，写下你需要的列。</p><h2 id="5b25" class="nf lu iq bd lv ng nh dn lz ni nj dp md lg nk nl mf lk nm nn mh lo no np mj nq bi translated">3.写出代码逻辑</h2><p id="04ce" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">顾名思义:将代码分成逻辑块，并按步骤写下来。通常，“逻辑”指的是你将要使用的功能。给步骤编号，写下函数，并简要描述你将如何以及为什么使用它。</p><p id="c5fc" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果您愿意，也可以编写一个伪代码，您只需用面试问题中的实际数据来填充它。</p><p id="04c6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当你写代码逻辑的时候，用这一步和面试官一起检查你是否朝着正确的方向前进。一旦你写出了代码逻辑，编码几乎就是一个技术问题。</p><h2 id="1d48" class="nf lu iq bd lv ng nh dn lz ni nj dp md lg nk nl mf lk nm nn mh lo no np mj nq bi translated">4.编码</h2><p id="26e1" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">大部分思考都是在前面的步骤中完成的。这将使代码编写容易得多，因为您已经想好了大部分问题。现在，您可以专注于编写高效的代码，并有更多的带宽来处理出现的任何问题。</p><h1 id="d37e" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">SQL面试问题中的窗口函数</h1><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/76eda42bd5ec6a09b3d29a14f53493a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CMBZneqkXHm_TCfI"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">作者在<a class="ae kw" href="https://canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>上创建的图像</p></figure><p id="b846" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在，你们一直在等待的事情:解决实际的SQL窗口函数面试问题！</p><h1 id="b2db" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">问题#1汇总窗口函数:平均工资</h1><p id="706e" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">创建一个类似于Salesforce所要求的分析是非常常见的，这是一个窗口函数与聚合函数相比有多么相似和不同的完美例子。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nr"><img src="../Images/59994e3c8741e99f0abc44ec2332537c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Rdf9NDM9RLp6_Mrl"/></div></div></figure><p id="6766" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果你想和我一起关注，这里有一个问题链接:【https://platform.stratascratch.com/coding/T2<a class="ae kw" href="https://platform.stratascratch.com/coding/9917-average-salaries?code_type=2" rel="noopener ugc nofollow" target="_blank">9917-平均工资</a></p><h2 id="2507" class="nf lu iq bd lv ng nh dn lz ni nj dp md lg nk nl mf lk nm nn mh lo no np mj nq bi translated">解决方法</h2><p id="3da3" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated"><strong class="kz ir"> 1。探索数据集</strong></p><p id="0f32" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">您得到了一个表<strong class="kz ir"> employee </strong>，它包含以下列和数据类型。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/4238f8099fd60cfcc90cc70cb30b2903.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*E5E6GAro-2xMfMT4F4JTtA.png"/></div></figure><p id="25ca" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这是一个相当标准的表格，其中有关于公司雇员的数据。我们最感兴趣的是他们的薪水，表格记录这些数据有两种可能性:</p><ol class=""><li id="a7cb" class="mq mr iq kz b la lb ld le lg ms lk mt lo mu ls ne mw mx my bi translated">显示历史工资</li><li id="9dcf" class="mq mr iq kz b la mz ld na lg nb lk nc lo nd ls ne mw mx my bi translated">显示最新的实际工资</li></ol><p id="563a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">第一种情况意味着雇员和所有其他数据可能是重复的，同一个雇员有不同的工资值。</p><p id="3e70" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">第二个选项是这里没有重复的雇员，即每个雇员只出现一次。</p><p id="ef4f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们不知道，但我们可以问面试官，或者更好的是，预览表格中的数据。</p><p id="e5ba" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">表:</strong>员工</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nt"><img src="../Images/bb3d2a2c59ab96f7174f27fcc77ca623.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4nsEqtDgcb74VpOW5V09mg.png"/></div></div></figure><p id="eb91" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这个预览只显示了前几行，但是请相信我，没有重复的。知道这一点很重要。我们现在知道，我们不必删除重复项来确保工资数据不会因为多次包含一名员工而失真。</p><p id="d180" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> 2。识别用于解决问题的列</strong></p><p id="8c1a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这个SQL窗口函数面试问题给出了关于应该输出哪些列的简单说明:</p><ul class=""><li id="8776" class="mq mr iq kz b la lb ld le lg ms lk mt lo mu ls mv mw mx my bi translated">部门</li><li id="d6b1" class="mq mr iq kz b la mz ld na lg nb lk nc lo nd ls mv mw mx my bi translated">名字</li><li id="34bc" class="mq mr iq kz b la mz ld na lg nb lk nc lo nd ls mv mw mx my bi translated">薪水</li></ul><p id="ef77" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">它还要求按部门显示平均工资。为此，我们将再次使用salary列。您可以忽略所有其他列。</p><p id="e2b3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> 3。写出代码逻辑</strong></p><p id="dd7d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">该解决方案可分为两步:</p><ol class=""><li id="337f" class="mq mr iq kz b la lb ld le lg ms lk mt lo mu ls ne mw mx my bi translated">从表<strong class="kz ir">雇员</strong> —部门，名字，薪水中选择列</li><li id="60b5" class="mq mr iq kz b la mz ld na lg nb lk nc lo nd ls ne mw mx my bi translated">AVG()作为窗口函数—获取各部门的平均工资</li></ol><p id="c81e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> 4。编码</strong></p><p id="82b9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">剩下要做的就是将这两个步骤翻译成SQL代码。</p><p id="77b8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="nu"> 1。选择列</em></p><pre class="kh ki kj kk gt nv nw nx ny aw nz bi"><span id="f55e" class="nf lu iq nw b gy oa ob l oc od">SELECT department,<br/>       first_name,<br/>       salary<br/>FROM employee;</span></pre><p id="0851" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="nu"> 2。AVG()窗口功能</em></p><p id="5a13" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">通过完成第二步，您得到了最终的代码。</p><pre class="kh ki kj kk gt nv nw nx ny aw nz bi"><span id="b3ad" class="nf lu iq nw b gy oa ob l oc od">SELECT department,<br/>       first_name,<br/>       salary,<br/>       AVG(salary) OVER (PARTITION BY department)<br/>FROM employee;</span></pre><p id="16cb" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">“薪金”列是AVG()函数中的一个参数。但是，我们想输出按部门的平均工资，这就需要窗口函数。</p><p id="ff31" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">窗口函数总是由OVER()子句调用。可选子句之一是PARTITION BY。它的目的是将数据分成我们希望窗口函数应用的子集。换句话说，如果数据按列department进行分区，那么window函数将返回按部门划分的平均工资。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nr"><img src="../Images/ec89f7e18fc25d107155c9aec4218e1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aFuM8BjdZbv0sJ0i"/></div></div></figure><p id="2be9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果只使用聚合函数，就无法同时显示分析数据和部门平均值。这就是窗口功能的威力！</p><p id="8a6f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这里，输出显示了每个雇员及其工资以及相应部门的平均工资。你甚至可以进一步分析哪些员工高于或低于部门或公司的平均水平。这样你就可以决定调整工资以使其更加公平。</p><h1 id="803a" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">问题#2排名窗口功能:最畅销的商品</h1><p id="7983" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">聚合窗口函数的功能与“常规”聚合函数相同，只是更加复杂。</p><p id="4e1a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然而，<a class="ae kw" href="https://www.stratascratch.com/blog/an-introduction-to-the-sql-rank-functions/?utm_source=blog&amp;utm_medium=click&amp;utm_campaign=medium" rel="noopener ugc nofollow" target="_blank"> SQL排名函数</a>比这更进一步。它们为您提供了对数据进行排序的可能性，这是聚合函数所做不到的。</p><p id="7978" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">处理数据意味着你要做很多排名。在业务中，创建显示诸如最高销售额、收入周期或最畅销商品等数据的报表几乎是每天的要求。</p><p id="4b33" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">亚马逊的问题反映了这一点。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nr"><img src="../Images/2ca7f8e7443fe46fe5a6b0d7f09306db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YatUttdq7kdwz_zR"/></div></div></figure><p id="149f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果你想和我一起关注，这里有一个问题链接:<a class="ae kw" href="https://platform.stratascratch.com/coding/10172-best-selling-item?utm_source=blog&amp;utm_medium=click&amp;utm_campaign=medium" rel="noopener ugc nofollow" target="_blank">https://platform . stratascratch . com/coding/10172-best-selling-item</a></p><h2 id="a54e" class="nf lu iq bd lv ng nh dn lz ni nj dp md lg nk nl mf lk nm nn mh lo no np mj nq bi translated">解决方法</h2><p id="aaed" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated"><strong class="kz ir"> 1。探索数据集</strong></p><p id="278f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">数据集同样只包含一个表:<strong class="kz ir"> online_retail </strong>。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/1ebf41ee11795a83f2c68d1037fe024b.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*HEh8ChUUrJhZUjNR9liehw.png"/></div></figure><p id="3a1a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">公平的假设是，这是一个在线订单列表。发票号码可能是唯一的，而其他数据可能是重复的。</p><p id="0cb2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">数据概览证实了这一点。</p><p id="a518" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">表:</strong>在线_零售</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi of"><img src="../Images/8dfd53233462965ea50c298d043ed743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lmBao8VA6Ir2EJFNl7j5_g.png"/></div></div></figure><p id="2fa3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果您看一下整个表，您会发现除了invoiceno之外的所有列都有重复的值。这是意料之中的，因为一个客户甚至可以在同一天下多个订单，而且是同一产品、相同数量和单价的订单。我们可以根据发票号这一栏来区分这些订单。</p><p id="1fb5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当然，也可能出现不同客户的几个不同订单是相同的情况。invoiceno和customerid列是用来区分它们的。</p><p id="30e9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">同样，最畅销的商品是通过数量乘以单价计算出来的。单价是一种浮点数据类型，这意味着我们在相乘之前不需要转换任何数据。</p><p id="ff9d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> 2。确定解决问题的列</strong></p><p id="e839" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">指令是输出项目描述和支付金额。</p><p id="3793" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们需要找到每月最畅销的商品。销售额是数量乘以价格。至于月份，我们有发票日期栏。</p><p id="573f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">所有这些意味着我们需要下面的专栏来解决问题。</p><ul class=""><li id="37fa" class="mq mr iq kz b la lb ld le lg ms lk mt lo mu ls mv mw mx my bi translated">描述</li><li id="5c3f" class="mq mr iq kz b la mz ld na lg nb lk nc lo nd ls mv mw mx my bi translated">单价</li><li id="d51d" class="mq mr iq kz b la mz ld na lg nb lk nc lo nd ls mv mw mx my bi translated">量</li><li id="200f" class="mq mr iq kz b la mz ld na lg nb lk nc lo nd ls mv mw mx my bi translated">发票日期</li></ul><p id="2bd1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> 3。写出代码逻辑</strong></p><p id="5534" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这是一个硬SQL窗口函数面试问题，需要比前一个问题更多的步骤。</p><ol class=""><li id="09d6" class="mq mr iq kz b la lb ld le lg ms lk mt lo mu ls ne mw mx my bi translated">从表中选择描述<strong class="kz ir">在线_零售</strong></li><li id="7769" class="mq mr iq kz b la mz ld na lg nb lk nc lo nd ls ne mw mx my bi translated">DATE_PART() —从invoicedate获取月份</li><li id="f38b" class="mq mr iq kz b la mz ld na lg nb lk nc lo nd ls ne mw mx my bi translated">SUM(单价*数量)—获取支付的总金额</li><li id="b1b4" class="mq mr iq kz b la mz ld na lg nb lk nc lo nd ls ne mw mx my bi translated">RANK()窗口函数—对每月支付的总金额进行排名</li><li id="e57d" class="mq mr iq kz b la mz ld na lg nb lk nc lo nd ls ne mw mx my bi translated">分组依据-按月份和项目描述获取数据</li><li id="45cc" class="mq mr iq kz b la mz ld na lg nb lk nc lo nd ls ne mw mx my bi translated">子查询-将其作为子查询写入FROM子句中</li><li id="7e60" class="mq mr iq kz b la mz ld na lg nb lk nc lo nd ls ne mw mx my bi translated">从子查询中选择月份、描述和支付金额</li><li id="fd91" class="mq mr iq kz b la mz ld na lg nb lk nc lo nd ls ne mw mx my bi translated">WHERE子句—仅显示每月的最佳销售额</li></ol><p id="45db" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> 4。编码</strong></p><p id="146b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="nu"> 1。从表</em>中选择描述</p><pre class="kh ki kj kk gt nv nw nx ny aw nz bi"><span id="1582" class="nf lu iq nw b gy oa ob l oc od">SELECT description<br/>FROM online_retail;</span></pre><p id="418b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="nu"> 2。日期_部分()</em></p><p id="6288" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">对invoicedate列使用DATE_PART()函数来显示月份。</p><pre class="kh ki kj kk gt nv nw nx ny aw nz bi"><span id="dd67" class="nf lu iq nw b gy oa ob l oc od">SELECT DATE_PART('month', invoicedate) AS month,<br/>       description<br/>FROM online_retail;</span></pre><p id="c5d0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="nu"> 3。SUM() </em></p><p id="1a3d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">将数量乘以商品价格，你将得到总销售额。然后合计同一个月同一商品的所有销售额。</p><pre class="kh ki kj kk gt nv nw nx ny aw nz bi"><span id="dff0" class="nf lu iq nw b gy oa ob l oc od">SELECT DATE_PART('month', invoicedate) AS MONTH,<br/>       description,<br/>       SUM(unitprice * quantity) AS total_paid<br/>FROM online_retail;</span></pre><p id="fc6f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="nu"> 4。RANK()窗口函数</em></p><p id="ae59" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">数据要按照月份排序。因为在这种情况下SQL不允许引用列别名，所以我们必须再次在PARTITION BY子句中使用DATE_PART()函数。</p><p id="85ec" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">OVER()中的另一个可选子句是ORDER BY。我们按total _ paid列对数据进行排序。这又是一个别名，所以我们需要使用整个公式。我们将分区内的数据从最高到最低的总付费金额进行排序。</p><pre class="kh ki kj kk gt nv nw nx ny aw nz bi"><span id="a5b5" class="nf lu iq nw b gy oa ob l oc od">SELECT DATE_PART('month', invoicedate) AS month,<br/>       description,<br/>       SUM(unitprice * quantity) AS total_paid,<br/>       RANK() OVER (PARTITION BY date_part('month', invoicedate)<br/>                    ORDER BY SUM(unitprice * quantity) DESC) AS rnk<br/>FROM online_retail;</span></pre><p id="4b26" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="nu"> 5。群组数据</em></p><p id="4300" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了让这部分代码工作，需要按照月份和描述对数据进行分组。</p><pre class="kh ki kj kk gt nv nw nx ny aw nz bi"><span id="788c" class="nf lu iq nw b gy oa ob l oc od">SELECT DATE_PART('month', invoicedate) AS month,<br/>       description,<br/>       SUM(unitprice * quantity) AS total_paid,<br/>       RANK() OVER (PARTITION BY date_part('month', invoicedate)<br/>                    ORDER BY SUM(unitprice * quantity) DESC) AS rnk<br/>FROM online_retail<br/>GROUP BY month,<br/>         description;</span></pre><p id="7bb7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了让您更容易理解这个查询做了什么，下面是它的输出。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nr"><img src="../Images/22227b2ccb20c619a5afc2eca9d7c4b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wOaCTmy1bx87yXv1"/></div></div></figure><p id="f0f5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="nu"> 6。使SELECT语句成为子查询</em></p><p id="d761" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在，这个查询结果必须在另一个SELECT语句中使用。因此，我们需要使它成为一个子查询。</p><pre class="kh ki kj kk gt nv nw nx ny aw nz bi"><span id="6f79" class="nf lu iq nw b gy oa ob l oc od">SELECT<br/>FROM<br/>  (SELECT DATE_PART('month', invoicedate) AS MONTH,<br/>          description,<br/>          SUM(unitprice * quantity) AS total_paid,<br/>          RANK() OVER (PARTITION BY date_part('month', invoicedate)<br/>                       ORDER BY SUM(unitprice * quantity) DESC) AS rnk<br/>   FROM online_retail<br/>   GROUP BY MONTH,<br/>            description) AS rnk;</span></pre><p id="b8a3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">子查询名为rnk，将被主SELECT语句用作FROM子句中的表。</p><p id="daa5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">7。从子查询中选择所需数据</p><p id="b0ed" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">输出必须显示月份、描述和销售额，所以我们必须在主选择中选择这些列。</p><pre class="kh ki kj kk gt nv nw nx ny aw nz bi"><span id="a155" class="nf lu iq nw b gy oa ob l oc od">SELECT month,<br/>       description,<br/>       total_paid<br/>FROM<br/>  (SELECT DATE_PART('month', invoicedate) AS MONTH,<br/>          description,<br/>          SUM(unitprice * quantity) AS total_paid,<br/>          RANK() OVER (PARTITION BY date_part('month', invoicedate)<br/>                       ORDER BY SUM(unitprice * quantity) DESC) AS rnk<br/>   FROM online_retail<br/>   GROUP BY MONTH,<br/>            description) AS rnk;</span></pre><p id="1c8f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">8。使用WHERE子句显示每月最畅销的产品</p><p id="1eb4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">一旦你过滤了数据，你就得到了问题的答案。</p><pre class="kh ki kj kk gt nv nw nx ny aw nz bi"><span id="610b" class="nf lu iq nw b gy oa ob l oc od">SELECT month,<br/>       description,<br/>       total_paid<br/>FROM<br/>  (SELECT DATE_PART('month', invoicedate) AS MONTH,<br/>          description,<br/>          SUM(unitprice * quantity) AS total_paid,<br/>          RANK() OVER (PARTITION BY date_part('month', invoicedate)<br/>                       ORDER BY SUM(unitprice * quantity) DESC) AS rnk<br/>   FROM online_retail<br/>   GROUP BY MONTH,<br/>            description) AS rnk<br/>WHERE rnk = 1;</span></pre><p id="7da9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">该解决方案给出了以下输出。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nr"><img src="../Images/607984a1bcc49fc1a6e78dfc153047dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*s8wO4LMgMM6U2Gp3"/></div></div></figure><h1 id="ff2a" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">问题3价值窗口函数:年复一年的流失</h1><p id="b1e5" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">值窗口函数为您提供了从其他行访问值的不同可能性。Lyft的问题恰恰验证了这一点。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nr"><img src="../Images/1a55aced495661360b5fbca4f26d90b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cxoWqI5J7EbomHbS"/></div></div></figure><p id="656e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果你想和我一起关注，这里有一个问题链接:<a class="ae kw" href="https://platform.stratascratch.com/coding/10017-year-over-year-churn?utm_source=blog&amp;utm_medium=click&amp;utm_campaign=medium" rel="noopener ugc nofollow" target="_blank">https://platform . stratascratch . com/coding/10017-over-year-over-year-churn</a></p><h2 id="06a1" class="nf lu iq bd lv ng nh dn lz ni nj dp md lg nk nl mf lk nm nn mh lo no np mj nq bi translated">解决方法</h2><p id="87fc" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated"><strong class="kz ir"> 1。探索数据集</strong></p><p id="df48" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这里你将使用的一个表格是<strong class="kz ir"> lyft_drivers </strong>。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi og"><img src="../Images/826aabfbdc116b3d35c79404c7e8d978.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/1*qHQLAqC5NvWZf9OK0JNWwQ.png"/></div></figure><p id="597e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这是Lyft驱动程序的列表。识别它们的唯一方法是列索引，所以它应该是唯一的。start_date不应为空，因为如果司机没有开始工作，他们就不会出现在列表中。但是，结束日期可能会有一些空值:如果为空，则司机仍在为Lyft工作。还有，每个司机都得有工资。</p><p id="f82b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们可以通过预览数据来证实我们的假设。</p><p id="0427" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">表格:</strong> lyft_drivers</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi oh"><img src="../Images/90e8b275057850ce8459fcb75a2698a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TST4VpT4yvM4w5owdP4bnw.png"/></div></div></figure><p id="87c0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">您会看到所有的索引值都是唯一的，所有的驱动程序都有开始日期和工资。这张预告图显示，从0到5的车手都还在，而6号车手已经在2018年8月6日离开。</p><p id="793d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> 2。识别用于解决问题的列</strong></p><p id="4716" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这个问题要求显示每年的数据，所以我们需要使用列end_date。这是我们必须显式使用来获得解决方案的唯一列。</p><p id="cbba" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> 3。写出代码逻辑</strong></p><p id="5901" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这就是代码分解的方式。</p><ol class=""><li id="13ab" class="mq mr iq kz b la lb ld le lg ms lk mt lo mu ls ne mw mx my bi translated">SELECT and DATE _ PART()-从结束日期获取年份</li><li id="da75" class="mq mr iq kz b la mz ld na lg nb lk nc lo nd ls ne mw mx my bi translated">WHERE子句-仅显示离开公司的驾驶员</li><li id="5a1f" class="mq mr iq kz b la mz ld na lg nb lk nc lo nd ls ne mw mx my bi translated">子查询-将其作为子查询写入FROM子句中</li><li id="412f" class="mq mr iq kz b la mz ld na lg nb lk nc lo nd ls ne mw mx my bi translated">从子查询中选择年份</li><li id="a987" class="mq mr iq kz b la mz ld na lg nb lk nc lo nd ls ne mw mx my bi translated">计数(*) —统计每年离开公司的驾驶员人数</li><li id="b70a" class="mq mr iq kz b la mz ld na lg nb lk nc lo nd ls ne mw mx my bi translated">LAG() —获取前一年离开公司的司机人数</li><li id="dc25" class="mq mr iq kz b la mz ld na lg nb lk nc lo nd ls ne mw mx my bi translated">分组依据—显示年度级别的数据</li><li id="65a3" class="mq mr iq kz b la mz ld na lg nb lk nc lo nd ls ne mw mx my bi translated">排序依据—从最早的年份到最新的年份对数据进行排序</li><li id="c684" class="mq mr iq kz b la mz ld na lg nb lk nc lo nd ls ne mw mx my bi translated">子查询和全选—也将它作为子查询写入FROM子句中，并从中选择所有列</li><li id="0fc0" class="mq mr iq kz b la mz ld na lg nb lk nc lo nd ls ne mw mx my bi translated">CASE语句—将输出列标记为“增加”、“减少”和“无变化”</li></ol><p id="64be" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> 4。编码</strong></p><p id="28b5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="nu"> 1。选择&amp;日期_部分()</em></p><p id="cbce" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">使用DATE_PART()函数中的列end_date从表<strong class="kz ir"> lyft_drivers </strong>中输出年份。</p><pre class="kh ki kj kk gt nv nw nx ny aw nz bi"><span id="3f05" class="nf lu iq nw b gy oa ob l oc od">SELECT DATE_PART('year', end_date::date) AS year_driver_churned<br/>FROM lyft_drivers;</span></pre><p id="ced2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">此外，将年份格式化为日期类型。</p><p id="b3f3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="nu"> 2。WHERE子句</em></p><p id="2650" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们将使用WHERE子句只显示那些离开公司的司机。通过检查可用数据，我们知道这些驱动因素在列end_date中具有非空值。</p><pre class="kh ki kj kk gt nv nw nx ny aw nz bi"><span id="6a14" class="nf lu iq nw b gy oa ob l oc od">SELECT DATE_PART('year', end_date::date) AS year_driver_churned<br/>FROM lyft_drivers<br/>WHERE end_date IS NOT NULL;</span></pre><p id="3b41" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在我们把它变成子查询之前，让我们看看这部分代码返回什么。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nr"><img src="../Images/2f0552aed6d0ca00a9e929a965cc2901.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hVNgTYwqCq46oFaz"/></div></div></figure><p id="9a17" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这是一个年份列表，每一年代表一个离开的车手。年份是重复的，因为那一年可能有不止一个车手离开。</p><p id="30d8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="nu"> 3。将SELECT写为子查询</em></p><p id="1864" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">该子查询必须出现在主查询的FROM子句中，因此它可以用作表。子查询的名称是base。</p><pre class="kh ki kj kk gt nv nw nx ny aw nz bi"><span id="eaec" class="nf lu iq nw b gy oa ob l oc od">SELECT<br/>FROM<br/>(SELECT DATE_PART('year', end_date::date) AS year_driver_churned<br/>      FROM lyft_drivers<br/>WHERE end_date IS NOT NULL) AS base;</span></pre><p id="79ae" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="nu"> 4。从子查询</em>中选择年份</p><p id="4026" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们需要选择的列是year_driver_churned。</p><pre class="kh ki kj kk gt nv nw nx ny aw nz bi"><span id="6e58" class="nf lu iq nw b gy oa ob l oc od">SELECT year_driver_churned<br/>FROM<br/>  (SELECT DATE_PART('year', end_date::date) AS year_driver_churned<br/>   FROM lyft_drivers<br/>   WHERE end_date IS NOT NULL) AS base;</span></pre><p id="cf17" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="nu"> 5。统计离开公司的司机人数</em></p><p id="e0cf" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们将使用COUNT(*)函数。它将计算行数，这等于驱动程序的数量。</p><pre class="kh ki kj kk gt nv nw nx ny aw nz bi"><span id="3ecb" class="nf lu iq nw b gy oa ob l oc od">SELECT year_driver_churned,<br/>       COUNT(*) AS n_churned<br/>FROM<br/>  (SELECT DATE_PART('year', end_date::date) AS year_driver_churned<br/>   FROM lyft_drivers<br/>   WHERE end_date IS NOT NULL) AS base;</span></pre><p id="a73e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="nu"> 6。使用LAG()窗口函数</em></p><p id="b4bf" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在有趣的部分来了！LAG()函数允许您从前面的行中访问数据。我们将使用它来查找前一年离职的司机人数。</p><pre class="kh ki kj kk gt nv nw nx ny aw nz bi"><span id="a109" class="nf lu iq nw b gy oa ob l oc od">SELECT year_driver_churned,<br/>       COUNT(*) AS n_churned,<br/>       LAG(COUNT(*), 1, '0') OVER (<br/>                                   ORDER BY year_driver_churned) AS n_churned_prev<br/>FROM<br/>  (SELECT DATE_PART('year', end_date::date) AS year_driver_churned<br/>   FROM lyft_drivers<br/>   WHERE end_date IS NOT NULL) AS base;</span></pre><p id="2c46" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">LAG()中的第一个参数是我们要返回的值，它是驱动程序的数量。</p><p id="193b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">整数1是我们想要返回的与当前行相关的行数。换句话说，后退一行意味着我们后退一年。</p><p id="e61c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">文本值“0”指定没有以前的值时要返回的值。这意味着，当我们显示第一个可用年份时，前一年的客户流失率将为零。如果省略该参数，默认值将为NULL。</p><p id="5191" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">OVER()子句中的数据按年份升序排序。这样，我们就按时间顺序对数据进行排序，因此前一行总是指前一年。</p><p id="eeea" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="nu"> 7。按年份分组</em></p><p id="4851" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这部分代码将把同一年离开的所有驱动程序组合在一起。</p><pre class="kh ki kj kk gt nv nw nx ny aw nz bi"><span id="32ff" class="nf lu iq nw b gy oa ob l oc od">SELECT year_driver_churned,<br/>       COUNT(*) AS n_churned,<br/>       LAG(COUNT(*), 1, '0') OVER (<br/>                                   ORDER BY year_driver_churned) AS n_churned_prev<br/>FROM<br/>  (SELECT DATE_PART('year', end_date::date) AS year_driver_churned<br/>   FROM lyft_drivers<br/>   WHERE end_date IS NOT NULL) base<br/>GROUP BY year_driver_churned;</span></pre><p id="5fdd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="nu"> 8。使用ORDER BY按时间顺序对输出进行排序</em></p><p id="680d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">输出按year_driver_churned列排序。</p><pre class="kh ki kj kk gt nv nw nx ny aw nz bi"><span id="e1fe" class="nf lu iq nw b gy oa ob l oc od">SELECT year_driver_churned,<br/>       COUNT(*) AS n_churned,<br/>       LAG(COUNT(*), 1, '0') OVER (<br/>                                   ORDER BY year_driver_churned) AS n_churned_prev<br/>FROM<br/>  (SELECT DATE_PART('year', end_date::date) AS year_driver_churned<br/>   FROM lyft_drivers<br/>   WHERE end_date IS NOT NULL) base<br/>GROUP BY year_driver_churned<br/>ORDER BY year_driver_churned ASC;</span></pre><p id="8fec" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这两个SELECT语句给出了这个输出。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nr"><img src="../Images/251ccd41a2d773329a53a6d4375364a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IyNfKX5JRbL67gVX"/></div></div></figure><p id="7b01" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">有2015年到2019年的数据。</p><p id="e634" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">数据告诉我们，2015年有5名司机被解雇，而前一年没有司机被解雇，因为没有2014年的数据。2016年，又有5名司机发生事故，与前一年持平。n_churned_prev列获取前一年的数据，并将其显示在当前年份的行中。</p><p id="a788" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="nu"> 9。编写第二个子查询并从中选择所有数据</em></p><p id="5d7c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">同样，第二个子查询出现在FROM子句中。</p><pre class="kh ki kj kk gt nv nw nx ny aw nz bi"><span id="f5b6" class="nf lu iq nw b gy oa ob l oc od">SELECT *<br/>FROM<br/>  (SELECT year_driver_churned,<br/>          COUNT(*) AS n_churned,<br/>          LAG(COUNT(*), 1, '0') OVER (<br/>                                      ORDER BY year_driver_churned) AS n_churned_prev<br/>   FROM<br/>     (SELECT DATE_PART('year', end_date::date) AS year_driver_churned<br/>      FROM lyft_drivers<br/>      WHERE end_date IS NOT NULL) base<br/>   GROUP BY year_driver_churned<br/>   ORDER BY year_driver_churned ASC) AS calc;</span></pre><p id="0984" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="nu"> 10。标签数据使用案例</em></p><p id="8ffd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">CASE语句将标记输出数据。如果产量高于上一年，这将意味着增加。如果更低，标签将是“减少”。当两者都不是时，它将被标记为没有变化。</p><p id="22b6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">通过编写CASE语句，您已经回答了这个SQL窗口函数面试问题。</p><pre class="kh ki kj kk gt nv nw nx ny aw nz bi"><span id="cb19" class="nf lu iq nw b gy oa ob l oc od">SELECT *,<br/>       CASE<br/>           WHEN n_churned &gt; n_churned_prev THEN 'increase'<br/>           WHEN n_churned &lt; n_churned_prev THEN 'decrease'<br/>           ELSE 'no change'<br/>       END<br/>FROM<br/>  (SELECT year_driver_churned,<br/>          COUNT(*) AS n_churned,<br/>          LAG(COUNT(*), 1, '0') OVER (<br/>                                      ORDER BY year_driver_churned) AS n_churned_prev<br/>   FROM<br/>     (SELECT DATE_PART('year', end_date::date) AS year_driver_churned<br/>      FROM lyft_drivers<br/>      WHERE end_date IS NOT NULL) base<br/>   GROUP BY year_driver_churned<br/>   ORDER BY year_driver_churned ASC) AS calc;</span></pre><p id="81e3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">至于产量，在这里。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nr"><img src="../Images/d346faeb77625347575417e9e39c4b6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dzP0zqXiQXtDq_hZ"/></div></div></figure><p id="e9c5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">和我们之前展示的一样，只是这个有标签。</p><h1 id="4385" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">摘要</h1><p id="e916" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">希望这三个例子向您展示了SQL窗口函数的强大功能。对于任何用SQL进行哪怕是非常有用的数据分析的人来说，它们都是必要的。</p><p id="f99a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当然，你可以期待窗口功能在工作面试中出现。正因为如此，你应该花些时间练习。如果你想尽可能高效地准备面试，看看我们根据面试中测试的最流行的SQL概念精选的<a class="ae kw" href="https://www.stratascratch.com/blog/top-30-sql-query-interview-questions/?utm_source=blog&amp;utm_medium=click&amp;utm_campaign=medium" rel="noopener ugc nofollow" target="_blank"> SQL查询面试问题</a>。</p></div></div>    
</body>
</html>