<html>
<head>
<title>Migrating from GitLab SaaS to Self-Hosted</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从SaaS git lab迁移到自托管</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/migrating-from-gitlab-saas-to-self-hosted-34b99bac0147#2022-10-05">https://towardsdatascience.com/migrating-from-gitlab-saas-to-self-hosted-34b99bac0147#2022-10-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bdfe" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用自动备份部署您自己的GitLab实例</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2e572982b7a8117ef7b1e89e09c6c345.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AhoGAfBcZiYXNFfy"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">茱莉亚·克莱斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="e623" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">几个月前，<a class="ae kv" href="https://about.gitlab.com/blog/2022/03/24/efficient-free-tier/" rel="noopener ugc nofollow" target="_blank"> GitLab宣布了对免费层</a>的修改，包括将私有名称空间限制为5个用户。由于我的团队将受到这些变化的影响，我们决定是时候尝试一下自托管了！更新将很快上线，所以我在这里分享一些关于我遵循的步骤的指导，收集和综合我使用的文档。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/1192bea899913f8f7cfd90613885de3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xEIWZv6o41eSdaagkFHkqA.png"/></div></div></figure><p id="e7ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本指南中，我将详细介绍如何:</p><ul class=""><li id="9996" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">使用Docker部署自托管GitLab实例</li><li id="e614" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">从SaaS git lab迁移到自托管实例</li><li id="9cca" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">迁移GitLab容器注册表</li><li id="ce29" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">配置上传到S3兼容存储的计划备份</li></ul><p id="2b38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实现相同配置所需的条件:</p><ul class=""><li id="2fa7" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">虚拟机实例</li><li id="0e92" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">一个<a class="ae kv" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> DockerHub </a>帐户(仅迁移您的容器注册中心)</li><li id="51a6" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">具有读写权限的S3存储桶(用于存储备份档案)</li><li id="4fb8" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">对Docker启动GitLab服务器的基本了解</li></ul><h1 id="dee5" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">评估你的需求</h1><p id="5d02" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">第一步是确定部署服务器所需的资源。你可以遵循GitLab的需求，这取决于你的用户数量、存储库存储以及容器存储等等。您可以选择将数据直接存储在虚拟机存储上以获得更快的数据传输速度，或者存储在基于云的存储上以获得可扩展性。</p><h1 id="552c" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">部署GitLab</h1><p id="3400" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">GitLab的官方文档为自托管服务器提供了多种部署方法。这里我选择了Docker方法，因为我熟悉Docker部署。其他方法包括Omnibus包，或Kubernetes集群的Helm，并且与本指南兼容。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/55d09b38192e0f202f222dd139613ac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QyTo9v6j87AAkerOIujg2w.png"/></div></div></figure><p id="ba70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，Docker部署实际上将Omnibus包部署在一个容器中，许多配置选项都是相似的。</p><h2 id="65f3" class="nf mi iq bd mj ng nh dn mn ni nj dp mr lf nk nl mt lj nm nn mv ln no np mx nq bi translated">配置您的虚拟机</h2><p id="93a2" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">如果您正在一台全新的机器上部署，您可能希望首先检查一些先决条件，尤其是对于初学者。</p><ol class=""><li id="8fb9" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr nr lz ma mb bi translated">SSH:一些提供商提供带有一组默认用户和密码的机器，更改它以保护您的服务器。你可以创建一个无密码的用户，例如用ssh密钥连接(见<a class="ae kv" href="https://docs.oracle.com/en/cloud/cloud-at-customer/occ-get-started/add-ssh-enabled-user.html" rel="noopener ugc nofollow" target="_blank">本教程</a>)。</li><li id="ca8d" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr nr lz ma mb bi translated">安装docker等工具:<a class="ae kv" href="https://docs.docker.com/engine/install/" rel="noopener ugc nofollow" target="_blank">选择适合你操作系统的服务器版本</a>。此时，您可能还想安装一个文本编辑器。</li></ol><h2 id="f8f3" class="nf mi iq bd mj ng nh dn mn ni nj dp mr lf nk nl mt lj nm nn mv ln no np mx nq bi translated">使用Docker compose部署</h2><p id="9bd6" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">GitLab文档提供了一个<a class="ae kv" href="https://docs.gitlab.com/ee/install/docker.html#install-gitlab-using-docker-compose" rel="noopener ugc nofollow" target="_blank">Docker组合配置示例</a>。在这里，我分享了我的版本，并做了一些修改，解释如下:</p><pre class="kg kh ki kj gt ns nt nu nv aw nw bi"><span id="a38e" class="nf mi iq nt b gy nx ny l nz oa">version: "3.6"<br/>services:<br/>  web:<br/>    container_name: gitlab<br/>    environment:<br/>      GITLAB_OMNIBUS_CONFIG: |<br/>        external_url 'https://X.X.X.X'<br/>        gitlab_rails['gitlab_shell_ssh_port'] = '2222'<br/>        gitlab_rails['omniauth_providers'] = {<br/>            name: "gitlab",<br/>            app_id: "###",<br/>            app_secret: "###"<br/>          }<br/>        gitlab_rails['backup_keep_time'] = '86400'<br/>        gitlab_rails['backup_upload_connection'] = {<br/>          provider: 'AWS',<br/>          region: '###',<br/>          aws_access_key_id: '###',<br/>          aws_secret_access_key: '###',<br/>          host: '###',<br/>          endpoint: '###',<br/>          path_style: '###',<br/>          aws_signature_version: '2'<br/>        }<br/>        gitlab_rails['backup_upload_remote_directory'] = 'backup/gitlab'<br/>image: gitlab/gitlab-ee:latest<br/>    ports:<br/>      - 2222:22/tcp<br/>      - 443:443/tcp<br/>      - 80:80/tcp<br/>    restart: always<br/>    volumes:<br/>      - $GITLAB_HOME/logs:/var/log/gitlab<br/>      - $GITLAB_HOME/data:/var/opt/gitlab<br/>      - $GITLAB_HOME/config:/etc/gitlab</span></pre><p id="5c75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大部分配置在GITLAB_OMNIBUS_CONFIG变量中提供，该变量可以包含任何gitlab.rb参数。这里我使用了:</p><ul class=""><li id="de70" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated"><code class="fe ob oc od nt b">gitlab_shell_ssh_port</code>:映射GitLab使用的端口，保持标准的SSH端口22空闲用于SSH连接。与对接器<em class="oe">端口</em>配置相匹配。</li><li id="82cf" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><code class="fe ob oc od nt b">omniauth_providers</code>:遵循<a class="ae kv" href="https://docs.gitlab.com/ee/integration/gitlab.html" rel="noopener ugc nofollow" target="_blank">此配置</a>以实现从GitLab.com的简单项目导入管理。</li><li id="049b" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><code class="fe ob oc od nt b">backup_*</code>:上传备份档案到S3，更多详情见下文备份部分。</li><li id="5aac" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><code class="fe ob oc od nt b">volumes</code>:访问并保存位于容器内的配置和数据目录。注意<code class="fe ob oc od nt b">$GITLAB_HOME</code>变量，指定虚拟机本地存储中卷的根文件夹。</li></ul><p id="91ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要启动，执行以下命令:<code class="fe ob oc od nt b">docker compose up -d</code></p><h2 id="57d6" class="nf mi iq bd mj ng nh dn mn ni nj dp mr lf nk nl mt lj nm nn mv ln no np mx nq bi translated">更新您的服务器</h2><p id="0101" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">您以后可能需要更改服务器的配置。为此，您可以编辑合成文件，然后删除容器以创建新的容器。</p><p id="ca2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您还可以通过修改<code class="fe ob oc od nt b">$GITLAB_HOME/config</code>文件夹中的配置文件将更改应用到当前服务器，并使用以下命令进行更新:<code class="fe ob oc od nt b">docker exec gitlab gitlab-ctl reconfigure</code>。这在名为<code class="fe ob oc od nt b">gitlab</code>的容器内执行<em class="oe">重新配置</em>命令。</p><h2 id="7646" class="nf mi iq bd mj ng nh dn mn ni nj dp mr lf nk nl mt lj nm nn mv ln no np mx nq bi translated">迁移您的项目</h2><p id="6b31" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">现在您的服务器已经准备好，应该在<code class="fe ob oc od nt b">https://&lt;your-host&gt;/</code>可用。要连接到<code class="fe ob oc od nt b">root</code>用户，您可以在文件<code class="fe ob oc od nt b">$GITLAB_HOME/config/initial_root_password</code>中检索密码并登录到您的服务器。现在，您可以开始用您想要迁移的所有数据填充您的服务器。</p><p id="300b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，您可以创建一个新的群组或从您的GitLab.com帐户导入现有的群组。请注意，导入组仅检索子组结构，项目将在下一步导入。<a class="ae kv" href="https://docs.gitlab.com/ee/user/group/import/#migrated-group-items" rel="noopener ugc nofollow" target="_blank">此处的</a>是通过组导入迁移的所有项目的列表。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/6a1d6bbdb157298426b9f1a464fe4927.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Ugm9xGyDIKNV0uI2kYtlA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">创建组</p></figure><p id="b25f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，您可以前往<code class="fe ob oc od nt b">create project</code>页面并选择您的导入方法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/f7b84ca5e16b929216bc54662971f722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9LS9xGtr-s-DrrL62mQFyQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">导入项目</p></figure><p id="d1fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您配置了<code class="fe ob oc od nt b">omniauth_providers</code>选项，您可以访问GitLab.com导入页面，轻松地一次导入多个项目，这是推荐的导入大量项目的方法，方法是指定目标组并一次对多个导入进行排队。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/b55f6c4142f9a707e4a0d78a9fff5498.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*mvMcDBpvVRHHYg5TCAvz4w.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从GitLab.com进口</p></figure><p id="bd24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，您也可以通过URL导入从GitLab.com导入项目。在此检查<a class="ae kv" href="https://docs.gitlab.com/ee/user/group/import/#migrated-project-items" rel="noopener ugc nofollow" target="_blank">随着项目导入而迁移的项目列表。</a></p><h1 id="bfa2" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">迁移容器注册表</h1><p id="1b07" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">如果您广泛使用GitLab.com容器注册中心，将映像迁移到您的自托管实例可能会占用大量空间，可能会超出您的虚拟机的处理能力。我个人选择用一个<a class="ae kv" href="https://www.docker.com/pricing/" rel="noopener ugc nofollow" target="_blank"> pro帐户</a>将我的图像迁移到DockerHub，以获得无限的私有存储库。无论您选择哪种解决方案，您都需要考虑以下几点:</p><ul class=""><li id="e8c8" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">图像需要被<em class="oe">推送到</em>新的容器注册表，</li><li id="cdc6" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">如果CI/CD管道推/拉映像，您需要更新它们。我建议使用GitLab变量来轻松地更改您的注册表url和登录名，</li><li id="fcda" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">您需要更新任何与注册表交互的服务:例如，Kubernetes的<em class="oe">docker-registry</em>secrets，或者您的服务器和开发人员计算机上的<em class="oe"> docker login </em>。</li></ul><h1 id="7259" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">配置备份</h1><p id="bf41" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">可靠部署的最后一步是确保您的数据是安全的，并且可以从存储故障中恢复。GitLab自托管版本提供<a class="ae kv" href="https://docs.gitlab.com/ee/raketasks/backup_gitlab.html" rel="noopener ugc nofollow" target="_blank">内置备份功能</a>来创建和上传服务器数据的档案。我使用这个功能自动对我的所有存储库进行每日备份，并将存档文件上传到S3兼容的存储中。</p><h2 id="f9be" class="nf mi iq bd mj ng nh dn mn ni nj dp mr lf nk nl mt lj nm nn mv ln no np mx nq bi translated">自动化备份</h2><p id="b237" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">GitLab提供了一个<a class="ae kv" href="https://docs.gitlab.com/ee/raketasks/backup_gitlab.html" rel="noopener ugc nofollow" target="_blank">内置函数</a>来创建服务器数据的档案(存储库、构建、工件……)。它还将生成的归档文件上传到docker-compose文件中指定的云存储中。我使用了以下配置:</p><pre class="kg kh ki kj gt ns nt nu nv aw nw bi"><span id="d466" class="nf mi iq nt b gy nx ny l nz oa">gitlab_rails['backup_keep_time'] = 86400<br/>gitlab_rails['backup_upload_connection'] = {<br/>    'provider' =&gt; 'AWS',<br/>    'region' =&gt; '###',<br/>    'aws_access_key_id' =&gt; '###',<br/>    'aws_secret_access_key' =&gt; '###',<br/>    'host' =&gt; '###',<br/>    'endpoint' =&gt; '###',<br/>    'path_style' =&gt; '###',<br/>    'aws_signature_version'=&gt; 2<br/>   }<br/> gitlab_rails['backup_upload_remote_directory'] = 'backup/gitlab'</span></pre><p id="299b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:</p><ul class=""><li id="0c30" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated"><code class="fe ob oc od nt b">backup_keep_time</code>:归档文件在虚拟机上保留的时间(秒)，超过此阈值的归档文件将在下次执行备份时被删除。它不处理上传到云存储上的归档。</li><li id="6e53" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">如果是S3兼容的存储，使用带有<code class="fe ob oc od nt b">endpoint</code>的<code class="fe ob oc od nt b">'provider'=&gt;'AWS'</code>作为您的服务的url，一些提供商需要<a class="ae kv" href="https://docs.gitlab.com/ee/raketasks/backup_gitlab.html#other-s3-providers" rel="noopener ugc nofollow" target="_blank">以下版本以兼容</a> <code class="fe ob oc od nt b">'aws_signature_version'=&gt;2</code>。</li></ul><p id="0ae8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是GitLab内置的备份功能并不备份配置文件，所以这里我分享一下用来备份我的服务器的bash脚本。它使用<a class="ae kv" href="https://min.io/docs/minio/linux/reference/minio-mc.html" rel="noopener ugc nofollow" target="_blank"> MinIO客户端</a>来保存内置函数中不包含的文件，并删除旧的档案，并假设S3兼容存储器的别名为<code class="fe ob oc od nt b">my-s3</code>。它只存储当前的配置，并将数据存档长达一周，然后通过邮件通知该脚本的输出。</p><pre class="kg kh ki kj gt ns nt nu nv aw nw bi"><span id="5f90" class="nf mi iq nt b gy nx ny l nz oa">#!/bin/bash<br/><br/># move old config files<br/>mc mv --recursive my-s3/backup/gitlab/config my-s3/backup/gitlab/old<br/><br/># copy files to s3<br/>{ mc cp <!-- -->$GITLAB_HOME<!-- -->/config/gitlab-secrets.json my-s3/backup/gitlab/config/gitlab-secrets.json ; \<br/>  mc cp <!-- -->$GITLAB_HOME<!-- -->/config/gitlab.rb my-s3/backup/gitlab/config/gitlab.rb ; \<br/>  mc cp --recursive <!-- -->$GITLAB_HOME<!-- -->/config/ssl my-s3/backup/gitlab/config/ssl ; \<br/>  mc cp --recursive <!-- -->$GITLAB_HOME<!-- -->/config/trusted-certs my-s3/backup/gitlab/config/trusted-certs ; \<br/>} 1&gt; /tmp/mc_logs.txt 2&gt;&amp;1<br/><br/># auto backup with gitlab<br/>if docker exec gitlab gitlab-backup create skip=builds,artifacts,registry CRON=1 1&gt; /tmp/backup_logs.txt 2&gt;&amp;1<br/>then<br/>  status="Success"<br/>  # remove old files<br/>  echo 'Removing old config files' <br/>  { mc rm --recursive --force my-s3/backup/gitlab/old ; \<br/>    mc rm --recursive --force my-s3/backup/gitlab/* --older-than 7d ; \<br/>  } 1&gt;&gt; /tmp/mc_logs.txt 2&gt;&amp;1<br/>else<br/>  status="Failed"<br/>fi<br/><br/>cat /tmp/mc_logs.txt | mail -s "GitLab Backup $status" my-mail@company.com -a FROM:backup@gitlab-server -A /tmp/backup_logs.txt</span></pre><p id="75aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意:</p><ul class=""><li id="5203" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">第一步是将当前保存在S3上的配置移动到一个<code class="fe ob oc od nt b">old</code>文件夹中，而不是在复制失败的情况下覆盖它，</li><li id="119c" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">mc步骤在列表中执行<a class="ae kv" href="https://unix.stackexchange.com/questions/64736/combine-the-output-of-two-commands-in-bash" rel="noopener ugc nofollow" target="_blank">，然后是<code class="fe ob oc od nt b">1&gt;&gt; /tmp/mc_logs.txt 2&gt;&amp;1</code>将日志保存在临时文件中，以便稍后在邮件通知中发送。在这里阅读更多关于UNIX重定向的信息，</a></li><li id="2b56" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">您可以从不存在的地址发送邮件通知，但是它可能会以垃圾邮件文件夹结束，尤其是带有附件的邮件。有<a class="ae kv" href="https://linuxhint.com/bash_script_send_email/" rel="noopener ugc nofollow" target="_blank">多种邮件客户端可供选择</a>，你可以向现有账户认证发件人，或者在收件箱中创建过滤器以防止通知被标记为垃圾邮件(Gmail 的<a class="ae kv" href="https://support.google.com/mail/answer/6579?hl=fr#zippy=%2Ccr%C3%A9er-un-filtre" rel="noopener ugc nofollow" target="_blank">示例)。</a></li></ul><p id="d3c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我选择每天早上用下面的cronjob作为CRON运行这个脚本:<code class="fe ob oc od nt b">0 7 * * 5 /bin/sh /home/admin/self-host/backup.sh</code>。点击阅读更多关于cronjobs <a class="ae kv" href="https://docs.gitlab.com/ee/raketasks/backup_gitlab.html#configuring-cron-to-make-daily-backups" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><h2 id="3bf3" class="nf mi iq bd mj ng nh dn mn ni nj dp mr lf nk nl mt lj nm nn mv ln no np mx nq bi translated">恢复您的数据</h2><p id="c336" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">GitLab在这里提供官方恢复指南<a class="ae kv" href="https://docs.gitlab.com/ee/raketasks/restore_gitlab.html" rel="noopener ugc nofollow" target="_blank">。但是，在执行恢复功能之前，我们需要从S3检索文件。以下脚本收集了下载备份文件、停止服务和启动恢复功能的所有步骤。</a></p><pre class="kg kh ki kj gt ns nt nu nv aw nw bi"><span id="9494" class="nf mi iq nt b gy nx ny l nz oa">#!/bin/bash<br/><br/>backup_name=$1_gitlab_backup.tar<br/><br/># download config files<br/>mc cp my-s3/backup/gitlab/config/gitlab-secrets.json ./config/gitlab-secrets.json<br/>mc cp my-s3/backup/gitlab/config/gitlab.rb ./config/gitlab.rb<br/>mc cp --recursive my-s3/backup/gitlab/config/ssl ./config/ssl<br/>mc cp --recursive my-s3/backup/gitlab/config/trusted-certs ./config/trusted-certs<br/><br/>sudo cp -r ./config <!-- -->$GITLAB_HOME<!-- -->/config<br/>sudo rm -rf ./config</span><span id="6915" class="nf mi iq nt b gy oi ny l nz oa"># download archive<br/>mc cp my-s3/backup/gitlab/$backup_name $backup_name<br/>sudo mv ./$backup_name <!-- -->$GITLAB_HOME<!-- -->/data/backups/$backup_name</span><span id="821c" class="nf mi iq nt b gy oi ny l nz oa"># auto backup with gitlab<br/>docker exec -it gitlab gitlab-ctl stop puma<br/>docker exec -it gitlab gitlab-ctl stop sidekiq<br/>docker exec -it gitlab gitlab-ctl status<br/><br/>docker exec -it gitlab gitlab-backup restore --force BACKUP=$1<br/><br/>docker restart gitlab<br/><br/>docker exec -it gitlab gitlab-rake gitlab:check SANITIZE=true</span></pre><p id="084b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用法:<code class="fe ob oc od nt b">./restore.sh &lt;BACKUP_NAME&gt;</code></p><p id="897d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意事项:</p><ul class=""><li id="f98f" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated"><code class="fe ob oc od nt b">BACKUP_NAME</code>是备份归档文件的名称，不带<code class="fe ob oc od nt b">_gitlab_backup.tar</code>扩展名。</li><li id="4126" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">MinIO将S3存储别名存储为依赖于用户的配置。虽然写入我的GitLab配置文件夹需要root权限，但是运行这个脚本需要sudo配置<code class="fe ob oc od nt b">root</code>的MinIO别名。我宁愿不使用sudo执行这个脚本，而是将下载操作分成两部分:首先下载到一个临时文件，然后<code class="fe ob oc od nt b">sudo</code>将文件移动到所需的路径。</li></ul><h1 id="b6d7" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">结论</h1><p id="22b3" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">在本教程结束时，您应该能够部署一个具有自动备份功能的GitLab自托管服务器。如果容器注册表占用太多空间，您还可以使用外部工具来管理它们，并在存储失败时恢复您的服务器。一旦您迁移了您的项目，您就可以通过在本地克隆您的存储库并邀请服务器上的其他用户来开始使用您的实例。</p><p id="5310" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你在设置你的服务器时有困难吗？你发现其他有用的方法了吗？不要犹豫分享任何反馈和快乐的编码！</p></div></div>    
</body>
</html>