<html>
<head>
<title>From ML Model to ML Pipeline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从ML模型到ML管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/from-ml-model-to-ml-pipeline-9f95c32c6512#2022-05-02">https://towardsdatascience.com/from-ml-model-to-ml-pipeline-9f95c32c6512#2022-05-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/56fb15a05459c622298a2d2b190eb220.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kTtzOIxW-AIUzS60"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://unsplash.com/@sodacheese?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">记者王</a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><h2 id="7068" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph">数据科学基础</h2><div class=""/><div class=""><h2 id="e588" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">使用Scikit-学习Python</h2></div><p id="0c56" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">建立机器学习模型不仅仅是选择正确的算法和调整其超参数。在模型实验开始之前，大量的时间花费在争论数据和特征工程上。这些预处理步骤很容易淹没你的工作流，变得难以跟踪。将注意力从ML模型转移到ML管道，并将预处理步骤视为构建模型不可或缺的一部分，有助于使您的工作流程更有条理。在这篇文章中，我们将首先看看预处理模型数据的错误方法，然后学习一种正确的方法和两种构建ML管道的方法。</p><figure class="md me mf mg gt iv gh gi paragraph-image"><div class="ab gu cl mh"><img src="../Images/7eeb009099206a47bcc411f58c29c727.png" data-original-src="https://miro.medium.com/v2/0*KgRQgsaa1N0BoRQ0"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@dayso?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> DaYsO </a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="9cac" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="mi"> ML管道根据上下文有多种定义。在本文中，ML管道被定义为预处理步骤和模型的集合。这意味着当原始数据被传递到ML管道时，它将数据预处理为正确的格式，使用模型对数据进行评分，并弹出预测得分。</em></p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="853e" class="mq mr jj bd ms mt mu mv mw mx my mz na ky nb kz nc lb nd lc ne le nf lf ng nh bi translated">📦 0.设置</h1><p id="3e3d" class="pw-post-body-paragraph lh li jj lj b lk ni kt lm ln nj kw lp lq nk ls lt lu nl lw lx ly nm ma mb mc im bi translated">让我们导入库和一个样本数据:titanic数据集的子集。</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="md me mf mg gt iv gh gi paragraph-image"><div class="gh gi np"><img src="../Images/db99458fcf3583fc69b0a2a9bfd69f89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/0*IGy4qWra-0-mx51C.png"/></div></figure><p id="53c7" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们现在将定义常用变量，以便稍后轻松引用:</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="md me mf mg gt iv gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/a2ed83336cc7b7088b6ec53d51dd3189.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/0*CjL9shFjpnd8ET9n.png"/></div></figure><p id="47cc" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">是时候看看第一种方法了。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="5b31" class="mq mr jj bd ms mt mu mv mw mx my mz na ky nb kz nc lb nd lc ne le nf lf ng nh bi translated">❌ 1.错误的方法</h1><p id="3325" class="pw-post-body-paragraph lh li jj lj b lk ni kt lm ln nj kw lp lq nk ls lt lu nl lw lx ly nm ma mb mc im bi translated">在预处理时，像这样使用pandas方法并不少见:</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="md me mf mg gt iv gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/2178234a5ec3509099d7bcfeca5e1ba7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/0*9fr9Zk_J1NGMqlUm.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">仅部分输出</p></figure><p id="bf41" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们估算缺失值，在0到1之间缩放数值变量和一个热编码分类变量。预处理后，数据被分区并拟合模型:</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="md me mf mg gt iv gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/6db157846cca7cd35091fca8dc4c19e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/format:webp/0*XWCJW2LiOKoo1SlD.png"/></div></figure><p id="fa25" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">好的，让我们分析一下这种方法有什么问题:<br/> ◼️ <strong class="lj jt">插补:</strong>数值变量应该用训练数据而不是整个数据的平均值进行插补。<br/> ◼️ <strong class="lj jt">缩放:</strong>最小值和最大值应根据训练数据计算得出。<br/> ◼️ <strong class="lj jt">编码:</strong>类别应该从训练数据中推断出来。此外，即使在预处理之前对数据进行了分区，使用<code class="fe nt nu nv nw b">pd.get_dummies(X_train)</code>和<code class="fe nt nu nv nw b">pd.get_dummies(X_test)</code>进行一次热编码也会导致不一致的训练和测试数据(即，列可能会根据两个数据集中的类别而变化)。因此，在为模型准备数据时，<code class="fe nt nu nv nw b">pd.get_dummies()</code>不应用于一次性编码。</p><blockquote class="nx ny nz"><p id="e98f" class="lh li mi lj b lk ll kt lm ln lo kw lp oa lr ls lt ob lv lw lx oc lz ma mb mc im bi translated"><strong class="lj jt">💡</strong>测试数据应在预处理前搁置。用于预处理的任何统计数据，例如平均值、最小值和最大值，都应该从训练数据中导出。否则会出现数据泄露问题。</p></blockquote><p id="e73f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，让我们评估模型。我们将使用ROC-AUC来评估模型。我们将创建一个计算ROC-AUC的函数，因为它将有助于评估后续方法:</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="md me mf mg gt iv gh gi paragraph-image"><div class="gh gi od"><img src="../Images/b52f8644e7d2b7570969496bce3cf8f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:436/format:webp/0*_d6jp5eTefUckSMt.png"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="7d86" class="mq mr jj bd ms mt mu mv mw mx my mz na ky nb kz nc lb nd lc ne le nf lf ng nh bi translated">❔ 2.正确的方法，但是…</h1><p id="48a0" class="pw-post-body-paragraph lh li jj lj b lk ni kt lm ln nj kw lp lq nk ls lt lu nl lw lx ly nm ma mb mc im bi translated">我们将首先对数据进行分区，并使用Scikit-learn的转换器对数据进行预处理，以通过正确的预处理来防止数据泄漏:</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="md me mf mg gt iv gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/f9d019580779e36959b37e1306548f2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/0*iSQLKXBGmhTGn99A.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">仅部分输出</p></figure><p id="85a6" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">很好，我们现在可以拟合模型了:</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="md me mf mg gt iv gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/03fe3cf03c02ff78e79763e70d40a810.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/format:webp/0*iohkplIbmBORcOgp.png"/></div></figure><p id="80af" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在评估之前，我们需要以同样的方式预处理测试数据集:</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="md me mf mg gt iv gh gi paragraph-image"><div class="gh gi of"><img src="../Images/1d8cd4475e7b63a840e426670eb9dba3.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/0*GVdNgn6tqoqkRuMV.png"/></div></figure><p id="b569" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">太棒了，这次方法是正确的。但是写好代码并不仅仅停留在正确上。对于每个预处理步骤，我们存储了训练和测试数据集的中间输出。当预处理步骤的数量增加时，这将很快变得非常乏味，因此很容易出现错误，比如在预处理测试数据时遗漏了一个步骤。这些代码可以变得更有条理、更简洁、更易读。这就是我们将在下一节中做的事情。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="af50" class="mq mr jj bd ms mt mu mv mw mx my mz na ky nb kz nc lb nd lc ne le nf lf ng nh bi translated">✔️ 3.优雅的方法#1</h1><p id="059b" class="pw-post-body-paragraph lh li jj lj b lk ni kt lm ln nj kw lp lq nk ls lt lu nl lw lx ly nm ma mb mc im bi translated">让我们使用Scikit-learn的<code class="fe nt nu nv nw b">Pipeline</code>和<code class="fe nt nu nv nw b">ColumnTransformer</code>来简化前面的代码。如果你不熟悉它们，<a class="ae jg" rel="noopener" target="_blank" href="/pipeline-columntransformer-and-featureunion-explained-f5491f815f">这篇文章</a>简明地解释了它们。</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="md me mf mg gt iv gh gi paragraph-image"><div class="gh gi og"><img src="../Images/202a50ae07bd22edc259313d85140926.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/0*QdlWg2MnZgqDrgrC.png"/></div></figure><p id="a0b6" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">管道:<br/> ◼️将输入数据分成数字组和分类组<br/> ◼️并行预处理这两组数据<br/> ◼️连接来自两组的预处理数据<br/> ◼️将预处理数据传递给模型</p><p id="d76b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当原始数据被传递到经过训练的管道时，它将进行预处理并做出预测。这意味着我们不再需要存储训练和测试数据集的中间结果。给看不见的数据打分就像<code class="fe nt nu nv nw b">pipe.predict()</code>一样简单。那很优雅，不是吗？现在，让我们评估模型的性能:</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="md me mf mg gt iv gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/03f874c7e2c962f31d236fe33c3ba78e.png" data-original-src="https://miro.medium.com/v2/resize:fit:414/format:webp/0*V77wFe-RYVNl1glq.png"/></div></figure><p id="a877" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">很高兴看到它与以前的方法的性能相匹配，因为转换完全相同，只是以更优雅的方式编写。对于我们的小例子来说，这是本文展示的四种方法中最好的方法。</p><p id="cd26" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Scikit-learn的开箱即用的变压器如<code class="fe nt nu nv nw b">OneHotEncoder</code>和<code class="fe nt nu nv nw b">SimpleImputer</code>快速高效。然而，这些预构建的转换器可能并不总是满足我们独特的预处理需求。在这种情况下，熟悉下一种方法可以让我们更好地控制定制的预处理方式。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="946f" class="mq mr jj bd ms mt mu mv mw mx my mz na ky nb kz nc lb nd lc ne le nf lf ng nh bi translated">✔️ 4.优雅的方法#2</h1><p id="fdbb" class="pw-post-body-paragraph lh li jj lj b lk ni kt lm ln nj kw lp lq nk ls lt lu nl lw lx ly nm ma mb mc im bi translated">在这种方法中，我们将使用Scikit-learn创建定制的变压器。看到我们熟悉的相同预处理步骤如何转化为定制的转换器，有望帮助您掌握构建它们的主要思想。如果你对定制变形金刚的用例感兴趣，请查看<a class="ae jg" href="https://github.com/zluvsand/ml_pipeline" rel="noopener ugc nofollow" target="_blank">GitHub库</a>。</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="md me mf mg gt iv gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/00b6515616637af40778a4b37ec69001.png" data-original-src="https://miro.medium.com/v2/resize:fit:410/format:webp/0*MKd0yHKJkYPfSiES.png"/></div></figure><p id="b74b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">与以前不同，这些步骤是按顺序一个接一个完成的，每个步骤都将其输出作为输入传递给下一个步骤。是时候对模型进行评估了:</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="md me mf mg gt iv gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/6e9f545272db6f77083a363fc2da6e1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:414/format:webp/0*rDLVJAtROuQ-CVad.png"/></div></figure><p id="6573" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">耶，我们刚刚学会了另一种优雅的方式来达到和以前一样的效果。虽然我们在第三种方法中只使用了预构建的转换器，在第四种方法中只使用了定制的转换器，但是它们可以一起使用，只要定制的转换器被定义为与开箱即用的转换器一致地工作。</p><p id="3223" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这就是这篇文章的全部内容！当使用后两种方法时，一个好处是超参数调整可以在整个管道上进行，而不仅仅是在模型上。我希望你已经学会了开始使用ML管道的实用方法。✨</p><figure class="md me mf mg gt iv gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/4daa89caee4fc5bb71d67b8cc401b47d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gCMoEuqtq-l73V7t"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">迈克尔·泽兹奇在<a class="ae jg" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="a1c8" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="mi">您想访问更多这样的内容吗？媒体会员可以无限制地访问媒体上的任何文章。如果您使用</em> <a class="ae jg" href="https://zluvsand.medium.com/membership" rel="noopener"> <em class="mi">我的推荐链接</em></a><em class="mi">成为会员，您的一部分会费将直接用于支持我。</em></p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="abe7" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">谢谢你看我的帖子。如果你感兴趣，这里有我的一些帖子的链接:<br/> ◼️️ <a class="ae jg" rel="noopener" target="_blank" href="/pipeline-columntransformer-and-featureunion-explained-f5491f815f?source=your_stories_page-------------------------------------">管道，ColumnTransformer和FeatureUnion解释</a> <br/> ◼️️ <a class="ae jg" rel="noopener" target="_blank" href="/featureunion-columntransformer-pipeline-for-preprocessing-text-data-9dcb233dbcb6"> FeatureUnion，ColumnTransformer &amp;管道用于预处理文本数据</a> <br/> ◼️️ <a class="ae jg" rel="noopener" target="_blank" href="/two-ways-to-create-custom-transformers-with-scikit-learn-b9089acacd37">用</a> <br/>的两种方法创建自定义变压器◼️ <a class="ae jg" rel="noopener" target="_blank" href="/enrich-your-jupyter-notebook-with-these-tips-55c8ead25255">用这些技巧丰富你的Jupyter笔记本</a> <br/> ◼️ <a class="ae jg" rel="noopener" target="_blank" href="/organise-your-jupyter-notebook-with-these-tips-d164d5dcd51f">用这些技巧组织你的Jupyter笔记本</a> <br/> ◼️ <a class="ae jg" rel="noopener" target="_blank" href="/explaining-scikit-learn-models-with-shap-61daff21b12a">解释scikit-1</a></p><p id="54e2" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">再见🏃💨</p></div></div>    
</body>
</html>