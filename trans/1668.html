<html>
<head>
<title>Postgres Fuzzy Search With pg_trgm: Smart Database Guesses What You Want and Returns “Cat Food” When “Pet Food” Not Found</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有pg_trgm的Postgres模糊搜索:智能数据库猜测你想要什么，当没有找到“宠物食品”时返回“猫粮”</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/postgres-fuzzy-search-with-pg-trgm-smart-database-guesses-what-you-want-and-returns-cat-food-4b174d9bede8#2022-04-20">https://towardsdatascience.com/postgres-fuzzy-search-with-pg-trgm-smart-database-guesses-what-you-want-and-returns-cat-food-4b174d9bede8#2022-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4a9c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Postgres中基于pg_trgm和Levenshtein距离的智能搜索</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7ae307dc0b3943ad7c30e569a16319d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*de7mGw4BS4TfcQHw5N-6lQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">文章中的所有图片均由作者提供</p></figure><p id="1246" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在数据库搜索中，有三种常见的场景超出了传统通配符查询的能力。</p><p id="5f12" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，当用户搜索“宠物食品”但在您的数据库中没有找到名为“宠物食品”的产品时，数据库会智能地返回“猫粮”或“狗粮”来代替吗？</p><p id="fec0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第二，用户将“chocolate”拼错为“chacolate”，数据库能否尝试猜测用户想要什么并返回最接近的匹配？</p><p id="97b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第三，词序不同的词仍然可以指代同一事物，如“芒果蛋糕”、“芒果蛋糕”。当单词顺序不同时，数据库能够将搜索字符串与产品名称配对吗？</p><p id="167f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在传统数据库中，通配符搜索“咖啡机”不会得到“咖啡机”，查找“羊角面包”(拼写错误)不会找到“羊角面包”，查询“洗涤剂手盘”不会返回“手盘洗涤剂”。但是通过Postgres中的模糊匹配，pg_trgm模块支持对相似字符串的快速搜索，并实现了灵活和智能的搜索性能。一些查询结果的对比可以在下图中找到。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lu"><img src="../Images/73af6d1b426a795de4347b0341f284f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DS0oLpR7A3C1HcDeGFddGA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">搜索“宠物食品”的比较</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/324d4b3ad9189d14b274397f496488c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gnloiIhX5Mhv5c8--mpcTw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">搜索“洗涤剂手盘”的比较</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/d02b2578dd5ec820b52baba30ecc339d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JYMZfM3CWFtvi4xJbioWyg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">拼写错误的单词“chacolate”的搜索比较</p></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="6c31" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">大纲</h1><ul class=""><li id="b9e2" class="mw mx it la b lb my le mz lh na ll nb lp nc lt nd ne nf ng bi translated"><strong class="la iu">什么是pg_trgm和三元模型</strong></li><li id="65f6" class="mw mx it la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated"><strong class="la iu">用pg_trgm进行模糊搜索</strong></li><li id="4ac2" class="mw mx it la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated"><strong class="la iu">Postgres中的Levenshtein距离</strong></li><li id="3b99" class="mw mx it la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated"><strong class="la iu">Postgres中的模糊搜索有什么局限性</strong></li></ul></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="c91a" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">什么是pg_trgm</h1><p id="eac0" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">Postgres的<code class="fe np nq nr ns b">pg_trgm</code>模块基于三元组匹配搜索相似的字符串。pg_trgm中的三元组是忽略非单词字符的三个字符的组。两个给定字符串的相似性可以通过它们共享多少三元组来表示。</p><h1 id="2f79" class="me mf it bd mg mh nt mj mk ml nu mn mo jz nv ka mq kc nw kd ms kf nx kg mu mv bi translated">给定字符串中的三元模型</h1><p id="fb06" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">用例子来理解一个概念总是比较容易的。字符串“mango”中的三元组是</p><pre class="kj kk kl km gt ny ns nz oa aw ob bi"><span id="5954" class="oc mf it ns b gy od oe l of og">m, ma, man, ang, ngo, go</span></pre><p id="d5c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">“show_trgm”函数返回给定字符串中的所有三元组，它通常用于实际调试。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/bd2c65af1430759b9935ef46a826a056.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*RCbagZJ9RCmKqoVyDp2NxQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">show_trgm '函数</p></figure><p id="baf6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在另一个示例“the|bay”中，我们可以看到只考虑字母数字文本，它们是</p><pre class="kj kk kl km gt ny ns nz oa aw ob bi"><span id="0513" class="oc mf it ns b gy od oe l of og">t, th, the, he, b, ba, bay, ay</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/9d3a29aec8506badce54a0983d10d1de.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*YqkJWALn9RE196e61q5yRg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">仅考虑字母数字文本</p></figure><h1 id="84f2" class="me mf it bd mg mh nt mj mk ml nu mn mo jz nv ka mq kc nw kd ms kf nx kg mu mv bi translated">pg_trgm相似性评分</h1><p id="c5e8" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">两个给定字符串的相似性得分可以通过它们共享的三元模型的数量来衡量。例如，“<strong class="la iu"> <em class="oj">【芒果蛋糕】</em> </strong>和一串不同顺序的“<strong class="la iu"> <em class="oj">芒果蛋糕”</em> </strong>之间的<code class="fe np nq nr ns b">similarity</code>得分为0.68，“<strong class="la iu"> <em class="oj">猫粮“</em> </strong>”和“<strong class="la iu"> <em class="oj">宠物粮“</em> </strong>”得分为0.38，“<strong class="la iu"> <em class="oj">椰子“</em> 【T21”以及拼错的单词“<strong class="la iu"> <em class="oj"> ciconuts</em></strong></strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/38ef0362bc1e807d2788928247380454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*fIVgzk7L3mX1iQnJstN3Xg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">功能<code class="fe np nq nr ns b">similarity</code></p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/b006dbc89ef44843a036725e3390e644.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*zdNjBYtBz2S_Iwe8z3gB0A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">相似的字符串</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/17d8600b10dc02d85cf4f9d9cc35b810.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*C7o8WEDVPVeVZmOhiZVPww.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">拼写错误的单词</p></figure><h1 id="b18e" class="me mf it bd mg mh nt mj mk ml nu mn mo jz nv ka mq kc nw kd ms kf nx kg mu mv bi translated">pg_gram模糊搜索</h1><p id="4ec3" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">首先，为pg_trgm创建一个扩展，如果它还没有被加载的话。然后搜索与“咖啡机”相似的目标，并根据相似性得分对结果进行降序排序。如下图截图所示，‘咖啡机’是与‘咖啡机’最相似的产品。</p><pre class="kj kk kl km gt ny ns nz oa aw ob bi"><span id="9a12" class="oc mf it ns b gy od oe l of og"><strong class="ns iu">CREATE EXTENSION IF NOT EXISTS pg_trgm;</strong> <br/>select distinct product_sub_species, <br/><strong class="ns iu">similarity</strong>(product_sub_species, 'coffee machine') as score from <br/>ct where product_sub_species % 'coffee machine'<br/>order by score desc;<br/></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/30529a5165d5f0849ae5cf0510d11186.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*ZdWxNXrNc4aj3O29AsoEJA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">pg_trgm模糊搜索</p></figure><p id="4281" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看另一个在查询目标中有拼写错误的例子。用户想要搜索“砧板”,但却输入了“<strong class="la iu">切肉</strong>板”。我们可以看到pg_trgm搜索能够返回“切菜板”作为最接近的匹配，这正是用户想要的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/38b984ede2f6a2fd32f6379cfd0962f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*crmscSebiOEhj3nhSd41ww.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">pg_trgm模糊搜索</p></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="6718" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">Postgres中的Levenshtein距离</h1><p id="cb68" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">与pg_trgm不同，Levenshtein距离通过查看两个字符串的差异来衡量相似性。正如<a class="ae op" href="https://en.wikipedia.org/wiki/Levenshtein_distance#:~:text=Informally%2C%20the%20Levenshtein%20distance%20between,considered%20this%20distance%20in%201965." rel="noopener ugc nofollow" target="_blank">维基百科</a>、<em class="oj">中所定义的，“非正式地，两个单词之间的Levenshtein距离是将一个单词变成另一个单词所需的单个字符编辑(插入、删除或替换)的最小数量。”</em></p><p id="3e3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Levenshtein距离越小，两个字符串越相似。以下示例显示“猫玩具”和“宠物玩具”之间的Levenshtein距离为4，这表明“猫玩具”比“狗玩具”更接近匹配。</p><pre class="kj kk kl km gt ny ns nz oa aw ob bi"><span id="b223" class="oc mf it ns b gy od oe l of og"><strong class="ns iu">CREATE EXTENSION IF NOT EXISTS fuzzystrmatch;</strong><br/>SELECT distinct<br/> product_sub_species,<br/>    <strong class="ns iu">LEVENSHTEIN</strong>(product_sub_species, 'pet toy')<br/>FROM ct<br/>ORDER BY LEVENSHTEIN(product_sub_species, 'pet toy') ASC</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/07b997bbb3cfc459cde23bd2a19c6c90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*GPvYVbPSUQvGt7Ohi4Cmgg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">“猫玩具”是具有最小Levenshtein距离的最接近匹配。</p></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="d04f" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">Postgres中模糊搜索的局限性是什么</h1><p id="2701" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">Postgres的模糊搜索方法有两个主要的局限性。首先，Postgres中的字符串匹配不是基于语义的方法。pg_trgm和Levenshtein distance，或soundex，metaphone都是字符级的比较。例如，SQL查询搜索“狗咀嚼物”将不会找到“宠物零食”,因为缺少常见的三元模型。</p><p id="4c74" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其次，Postgres中的模糊匹配不能应用于监督学习场景。例如，有两个数据集具有一些公共列:“雇员姓名”、“电子邮件”和“地址”。我们需要将这些数据集中的雇员配对，以加入关于同一个人的信息。典型的解决方案是计算每一列的相似性得分，然后运行随机森林或其他分类器来学习潜在的规则，以从不同的数据集中检测同一个人。这超出了Postgres。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="ffb7" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">结论</h1><p id="edc0" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">在某些情况下，智能数据库搜索应该表现得像一个搜索引擎，而不是命令行工具。模糊数据库搜索不是向用户抛出“未找到”，而是试图猜测用户想要什么，并返回最接近的匹配。</p><p id="3773" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们通过使用相似的字符串、不同顺序的字符串和拼写错误的字符串进行数据库搜索的例子，讨论了pg_trgm和Levenshtein距离方法。此外，我们还讨论了模糊匹配在Postgres中的局限性。请将这项技术应用到您的项目中，如果您有任何问题，请随时联系我们。🐸 🐣 🐼</p><p id="6733" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">参考资料:</p><ul class=""><li id="875e" class="mw mx it la b lb lc le lf lh or ll os lp ot lt nd ne nf ng bi translated"><a class="ae op" href="https://www.postgresql.org/docs/current/pgtrgm.html" rel="noopener ugc nofollow" target="_blank"> F.33. pg_trgm </a></li><li id="af1a" class="mw mx it la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated"><a class="ae op" href="https://www.postgresql.org/docs/14/fuzzystrmatch.html#id-1.11.7.24.7" rel="noopener ugc nofollow" target="_blank"> F.15 .模糊strmatch </a></li><li id="f69b" class="mw mx it la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated"><a class="ae op" rel="noopener" target="_blank" href="/fuzzy-string-match-with-python-on-large-dataset-and-why-you-should-not-use-fuzzywuzzy-4ec9f0defcd">在大型数据集上使用Python进行模糊字符串匹配，以及为什么不应该使用FuzzyWuzzy </a></li></ul><p id="6b7c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="oj">特别感谢</em><a class="ae op" href="https://www.linkedin.com/in/faizan-qazi-3b031456" rel="noopener ugc nofollow" target="_blank"><em class="oj">faiz an Qazi</em></a><em class="oj">进行校对。🔆 ✔️ 🐳</em></p></div></div>    
</body>
</html>