<html>
<head>
<title>Random Sampling using SciPy and NumPy: Part III</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SciPy和NumPy的随机抽样:第三部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/random-sampling-with-scipy-and-numpy-part-iii-8daa212ce554#2022-04-22">https://towardsdatascience.com/random-sampling-with-scipy-and-numpy-part-iii-8daa212ce554#2022-04-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/9885a3cb60c5479f06ab7e4748a20876.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KhjpKuKrHDsiJRkr1d0vtg.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">由<a class="ae jd" href="https://unsplash.com/@rocinante_11?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">米克·豪普特</a>在<a class="ae jd" href="https://unsplash.com/s/photos/numbers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><div class=""/><div class=""><h2 id="abe3" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">在SciPy中实现自定义分布采样</h2></div><p id="1127" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在前两部分(<a class="ae jd" rel="noopener" target="_blank" href="/random-sampling-using-scipy-and-numpy-part-i-f3ce8c78812e">第一部分</a>、<a class="ae jd" rel="noopener" target="_blank" href="/random-sampling-with-scipy-and-numpy-part-ii-234c2385828a">第二部分</a>)中，我们快速介绍了采样需要什么，然后深入研究了NumPy和SciPy的源代码，以准确理解这在现代python库中是如何实现的。</p><p id="601e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们通常不关心底层过程时，所有这些看起来都是多余的——我们很高兴智能体操由巧妙构建的导入库来处理，并让我们专注于利用输出来完成更有洞察力的任务(如蒙特卡洛模拟)。</p><p id="1afd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，有时我们会遇到标准库不太适合的用例。下面是一个这样的例子，提供了一个理解这两者的例子:</p><ul class=""><li id="802b" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">采样(尤其是逆变换采样)背后的理论思想</li><li id="17ab" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">这种采样过程的程序实现</li></ul><p id="a1ec" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">可以在一个不可行的缓慢实现和一个几乎可以与NumPy和SciPy背后的聪明人的优化工作相媲美的实现之间做出区别。</p><h2 id="8529" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">为什么我需要从自定义分布中取样？</h2><p id="3b0b" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">在很多场合。而在正常情况下(请原谅这个双关语),默认的做法是:</p><ul class=""><li id="fa2a" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">收集数据并绘制直方图</li><li id="3ac0" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">得出数据大致正常的结论(即呈钟形)</li><li id="1547" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">拟合一个合适的正态分布并完成它</li></ul><p id="cbe3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在有些情况下，这并不能完全解决问题。下面是我的特例，但可以推广到任何一个预先打包的发行版，不管参数化得多好，都不够好。</p><h2 id="6415" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">“保方差尾肥”</h2><p id="0776" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">这听起来比实际上要美好得多。<a class="ae jd" href="https://en.wikipedia.org/wiki/Geometric_Brownian_motion" rel="noopener ugc nofollow" target="_blank">几何布朗运动(GBM) </a>由以下方程定义:</p><figure class="nd ne nf ng gt is gh gi paragraph-image"><div class="ab gu cl nh"><img src="../Images/d7c46f37790c50f9773a4ed639ed69d2.png" data-original-src="https://miro.medium.com/v2/format:webp/1*4DMvZsEzzTkzdfgf6Gqr7w.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="693e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">简而言之，在某个时间增量<code class="fe ni nj nk nl b">dt</code>内，我们的过程值<code class="fe ni nj nk nl b">S</code>的变化由两部分组成:</p><ul class=""><li id="cc4e" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">一些常数确定性漂移项</li><li id="c6ac" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">一些随机项</li></ul><p id="e381" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">重要的是，GBM的特点是随机元素呈正态分布——<code class="fe ni nj nk nl b">dW</code>元素被称为<a class="ae jd" href="https://en.wikipedia.org/wiki/Wiener_process" rel="noopener ugc nofollow" target="_blank">维纳过程</a>或更常见的“随机游走”。我的问题如下——我想模拟这些“随机路径”的负载，但我不想从正态分布中取样我的随机变化。</p><p id="c5b2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">相反，我想创建自己的“定制”分布——特别是我想要一个方差保持变换(即方差仍然是标准正态的<code class="fe ni nj nk nl b">1</code>),但该分布有着丰富的尾部(过度峰度)。那么问题就变成了:</p><h2 id="aac4" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">我如何在SciPy/NumPy框架中做到这一点？</h2><p id="7888" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">在开始之前，让我们先快速了解一下以下pdf之间的区别:</p><ul class=""><li id="7962" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">标准正态分布</li><li id="1bc2" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">我希望从中取样的分布</li></ul><p id="1b67" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了创建我想要的厚尾分布，我将利用<a class="ae jd" href="https://en.wikipedia.org/wiki/Jensen's_inequality" rel="noopener ugc nofollow" target="_blank">詹森不等式</a>。具体来说，我将利用这样一个事实，即如果我们取两个平均方差为<code class="fe ni nj nk nl b">1</code>的正态分布的平均密度，那么我们将得到一个“身材更高”和“尾部更胖”的分布，即峰度更大，但仍保持像标准正态分布一样的方差<code class="fe ni nj nk nl b">1</code>。</p><p id="3b6e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">更清楚地说，我们的厚尾分布将是通过平均得到的pdf:</p><ul class=""><li id="c25c" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">有方差的正态分布<code class="fe ni nj nk nl b">1 + e</code></li><li id="c6bb" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">方差为正态分布<code class="fe ni nj nk nl b">1 - e</code></li></ul><p id="d8b6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其中<code class="fe ni nj nk nl b">e</code>被限制在<code class="fe ni nj nk nl b">[0,1]</code>之间。让我们画出这个图，这样我们就可以看到当我们改变<code class="fe ni nj nk nl b">e</code>与标准正态分布相比时，这些分布是什么样子。</p><figure class="nd ne nf ng gt is"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="nd ne nf ng gt is gh gi paragraph-image"><div class="ab gu cl nh"><img src="../Images/f08077a00e56c25045fcd2aa7e5767d9.png" data-original-src="https://miro.medium.com/v2/format:webp/1*4vnGk9FdEg5KZjPRXl0VqA.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="11bd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如上所述，我们的平均分布显示了更高的身体和更胖的尾巴。特别是，我们看到所有的定制分布在几乎相同的点上与标准正态分布交叉——肩部大约为+/-0.66，尾部大约为+/-2.13。事实上，我们可以用这个特性来定义当我们谈论“尾部”时，我们实际上指的是概率分布的哪一部分，而不仅仅是一个抽象的概念。</p><p id="769f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">更专业地说，尾部是由凸方差概率分布的密度定义的。简单来说，一旦我们改变方差(而不是一个常数<code class="fe ni nj nk nl b">1</code>)，在上面的分布中+/-2.13之外的密度增加了。</p><p id="9f9b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这与通常流传的关于厚尾分布如何与峰度相关的观点非常吻合——因为峰度只是四阶矩，或者换句话说，是方差的方差。改变方差(通过我们上面的分布平均),我们开始得到厚尾的pdf。</p><p id="a6e2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们知道了我们要实现的发行版，让我们来实现它。</p><h2 id="2499" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">尝试1:简单，幼稚但缓慢(真的很慢)</h2><p id="00e4" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">尽管这种方法太慢了，根本不能成为真正的解决方案，但SciPy内置了所有这些功能，这还是很了不起的。方法是这样的:</p><ul class=""><li id="31f3" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">创建一个从<code class="fe ni nj nk nl b">rv_continuous</code> SciPy类继承的定制分发类</li><li id="4208" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">只需定义反映我们所追求的定制发行版pdf的<code class="fe ni nj nk nl b">_pdf</code>方法</li><li id="77ac" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">SciPy做了所有其他事情来允许我们从这个定制发行版中进行采样</li></ul><p id="5320" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要快速回顾一下什么是<code class="fe ni nj nk nl b">rv_continuous</code>类或者SciPy的分布结构，那么最好<a class="ae jd" rel="noopener" target="_blank" href="/random-sampling-with-scipy-and-numpy-part-ii-234c2385828a">跳回第二部分</a>快速回顾一下<code class="fe ni nj nk nl b">rv_continuous</code>是如何继承<code class="fe ni nj nk nl b">rv_generic</code>的。否则，让我们继续写我们天真的实现，<code class="fe ni nj nk nl b">naive_cust_dist</code>:</p><figure class="nd ne nf ng gt is"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="1896" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们已经定义了它，让我们做两件事:</p><ul class=""><li id="58fb" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">从中抽取样本，检查我们从这些样本中生成的直方图是否与我们定义的pdf一致</li><li id="8f6d" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">快速测试我们抽取这些样本并与SciPy的嵌入式正态分布采样进行比较需要多长时间</li></ul><figure class="nd ne nf ng gt is"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="nd ne nf ng gt is gh gi paragraph-image"><div class="ab gu cl nh"><img src="../Images/6932a258db08d3362167018df1889152.png" data-original-src="https://miro.medium.com/v2/format:webp/1*dhbpYdr42hFlfP6CKlLnsA.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="8ffa" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面显示了从我们的自定义类<code class="fe ni nj nk nl b">naive_cust_dist</code>中采样<code class="fe ni nj nk nl b">1,000</code>数字得到的直方图，该自定义类实现了我们想要从中采样的pdf。正如我们所见，直方图很大程度上与理论pdf(绿线)一致，这与标绘的标准正态pdf明显不同。</p><p id="9822" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以理论上就是这样。我们已经实现了自定义采样，只定义了<code class="fe ni nj nk nl b">_pdf</code>方法，其余的由SciPy完成。</p><h2 id="23bd" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">“其余的”是什么？</h2><p id="7106" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">正如在第一部分中提到的，有许多不同的方法从一个分布中抽取样本。然而，它们都没有单独将pdf作为输入，并使用它来生成随机数，如果我们将它们绘制成直方图(如上)，我们将恢复相同的pdf。相反，我们需要:</p><ul class=""><li id="6eaf" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">巧妙的算法(例如，像金字形神算法这样的拒绝采样算法)</li><li id="622d" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">利用逆变换采样的逆累积分布函数(cdf)</li></ul><p id="1193" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">算法可以是特定于发行版的，当实现定制发行版时，SciPy使用逆变换采样，这需要后者:逆cdf。因此，“其余”包括:</p><ul class=""><li id="3f0b" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">根据给定的<code class="fe ni nj nk nl b">_pdf</code>计算<code class="fe ni nj nk nl b">_cdf</code></li><li id="025b" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">从cdf计算【SciPy给逆向cdf起的名字——“百分点函数”)</li><li id="8fb5" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">使用该<code class="fe ni nj nk nl b">_ppf</code>函数通过使用PRNG生成均匀分布的随机数并使用逆变换采样来产生样本</li></ul><p id="9cda" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">问题如下:</p><h2 id="dde1" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">做“其余的”是极其缓慢的</h2><p id="37c7" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">下面显示了速度有多慢——从我们的定制发行版中计算一个仅仅是<code class="fe ni nj nk nl b">1,000</code>的样本就需要花费超过<code class="fe ni nj nk nl b">30s</code>的时间。</p><pre class="nd ne nf ng gt no nl np nq aw nr bi"><span id="0161" class="mf mg jg nl b gy ns nt l nu nv">%timeit naive_dist.rvs(size=n)</span><span id="7beb" class="mf mg jg nl b gy nw nt l nu nv">32.6 s ± 4.57 s per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="9232" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以将其与使用SciPy从正态分布中采样的<code class="fe ni nj nk nl b">1,000</code>数字进行比较。</p><pre class="nd ne nf ng gt no nl np nq aw nr bi"><span id="5c9e" class="mf mg jg nl b gy ns nt l nu nv">%timeit stats.norm.rvs(size=n)</span><span id="b53b" class="mf mg jg nl b gy nw nt l nu nv">168 µs ± 29.1 µs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)</span></pre><p id="da59" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以要明确的是，我们几乎比内置的SciPy采样方法慢<code class="fe ni nj nk nl b">200,000x</code>。然而，有问题的不仅仅是速度有多慢的相对性质——从绝对意义上来说，仅用<code class="fe ni nj nk nl b">30s</code>来采样<code class="fe ni nj nk nl b">1,000</code>数字是不可行的，特别是如果我们想要做一些类似于采样<code class="fe ni nj nk nl b">10,000</code>路径的事情，其中每条路径都由<code class="fe ni nj nk nl b">1,000</code>步骤组成。我们不能每次想运行模拟都等<code class="fe ni nj nk nl b">3.5</code>天。</p><h2 id="40b8" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">为什么这么慢？</h2><p id="4c5f" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">在使用我们从第一部分和第二部分中学到的知识来创建一个更好的解决方案之前，让我们快速找出为什么内置的SciPy功能如此之慢。要回答这个问题，我们需要深入研究SciPy源代码，找到<code class="fe ni nj nk nl b">_ppf</code>方法——特别是它调用的<code class="fe ni nj nk nl b">_ppf_single</code>方法(像NumPy这样命名SciPy是为了便于快速计算数字集合)。下面是代码片段，但是如果你喜欢自己阅读Github源代码，你可以点击这里:</p><figure class="nd ne nf ng gt is"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c87a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">换句话说，以上是逆变换采样的实现，其利用求根算法(<a class="ae jd" href="https://en.wikipedia.org/wiki/Brent's_method" rel="noopener ugc nofollow" target="_blank"> Brent的方法</a>)来将给定随机数<code class="fe ni nj nk nl b">q</code>从均匀分布转换成来自我们选择的定制分布的数。即使不深入算法的本质，这个过程也需要:</p><ul class=""><li id="a1f6" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">两个<code class="fe ni nj nk nl b">while</code>循环</li><li id="a991" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">数值积分函数</li></ul><p id="7db4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">应该表明这种功能的速度可能不足。相反，我们想避开这个过程，实现我们自己的<code class="fe ni nj nk nl b">_ppf</code>。换句话说，让我们把在第一部分中创建的逆向cdf放到SciPy发行框架中。</p><h2 id="2f19" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">尝试2:可行的解决方案</h2><p id="285f" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">所以我们将返回到创建我们自己的分发类，它继承了SciPy中的通用<code class="fe ni nj nk nl b">rv_continuous</code>类。然而，除了定义一个<code class="fe ni nj nk nl b">_pdf</code>方法，我们还要定义一个<code class="fe ni nj nk nl b">_ppf</code>方法。</p><p id="7f15" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">怎么会？我们将实现第一部分中的反变换采样方法。这意味着当我们实例化我们的类时，我们需要做更多的工作。更具体地说，我们需要通过以下方式创建<code class="fe ni nj nk nl b">ppf</code>:</p><ul class=""><li id="2936" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">首先通过对<code class="fe ni nj nk nl b">pdf</code>进行累积求和来创建<code class="fe ni nj nk nl b">cdf</code></li><li id="22e5" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">使用SciPy的内置<code class="fe ni nj nk nl b">interp1d</code>函数来反转它，最后得到我们的反转<code class="fe ni nj nk nl b">cdf</code></li></ul><p id="2eab" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦我们有了它，我们就可以将它设置为我们的<code class="fe ni nj nk nl b">_ppf</code>方法，以防止SciPy从方法1开始进行数学体操，这使得它慢得不可行。</p><figure class="nd ne nf ng gt is"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="3715" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们已经定义了它，让我们试一试。就像之前一样，让我们检查它是否生成了与我们定义的<code class="fe ni nj nk nl b">pdf</code>一致的样本，然后我们可以检查我们是否得到了速度方面的可行解决方案。</p><figure class="nd ne nf ng gt is"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="nd ne nf ng gt is gh gi paragraph-image"><div class="ab gu cl nh"><img src="../Images/c7799bb7db252276b37eca8d269ebc39.png" data-original-src="https://miro.medium.com/v2/format:webp/1*4UeAW3aLj5rw_SXEuoJ-jg.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="57dc" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我们似乎又一次实现了期望的采样分布。现在让我们来看看额外的代码和复杂性在加速方面是否值得。</p><pre class="nd ne nf ng gt no nl np nq aw nr bi"><span id="48f5" class="mf mg jg nl b gy ns nt l nu nv">%timeit my_dist.rvs(size=1000)</span><span id="f27f" class="mf mg jg nl b gy nw nt l nu nv">1.84 ms ± 512 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</span><span id="f28a" class="mf mg jg nl b gy nw nt l nu nv">%timeit stats.norm.rvs(size=1000)</span><span id="c61d" class="mf mg jg nl b gy nw nt l nu nv">116 µs ± 5.21 µs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)</span><span id="b0dc" class="mf mg jg nl b gy nw nt l nu nv">%timeit my_dist.rvs(size=10000000)</span><span id="1ad1" class="mf mg jg nl b gy nw nt l nu nv">12.8 s ± 1.62 s per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="e095" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我们仍然比SciPy慢得多(大约在<code class="fe ni nj nk nl b">15x</code>)，但这比我们以前的<code class="fe ni nj nk nl b">200,00x</code>方法有了巨大的改进。我们现在有了一个解决方案，可以在<code class="fe ni nj nk nl b">15s</code>多一点的时间内产生<code class="fe ni nj nk nl b">10,000,000</code>个随机数——与我们之前实现的<code class="fe ni nj nk nl b">3.5</code>天相比，这个时间要合理得多。</p><h2 id="47a7" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">结论</h2><p id="9f48" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">SciPy提供了广泛的打包发行版，可以快速采样。这种采样是特定于发行版的，是为了利用C语言的速度、优化的python代码和最有效的采样过程而编写的。虽然这是一个无价的资源，在大多数情况下将提供一个充分的解决方案，但确实有需要定制分布采样的时候。</p><p id="a0d2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">更深入地了解SciPy的分发体系结构，特别是它如何依赖于NumPy，如上所示，可以决定一个精确但不可行的缓慢解决方案和一个与SciPy的超高速实现相差不远的解决方案。</p></div></div>    
</body>
</html>