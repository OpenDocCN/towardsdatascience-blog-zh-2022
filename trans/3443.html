<html>
<head>
<title>Don’t use Apply in Python, follow these Best Practices!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要在Python中使用Apply，遵循这些最佳实践！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dont-use-apply-in-python-there-are-better-alternatives-dc6364968f44#2022-07-30">https://towardsdatascience.com/dont-use-apply-in-python-there-are-better-alternatives-dc6364968f44#2022-07-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f4ee" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">应用功能的替代方案，可将性能提高700倍</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4ebb381bed09ba1fec41a7618d285d9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xJknqmZzptRvuQRZp_nFCg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:Unsplash</p></figure><h2 id="b921" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">什么是应用功能——如果你还不知道的话！</strong></h2><p id="3183" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">Apply函数是一个单行函数，可用于在数据帧的所有元素上或跨数据帧的行或列应用操作。</p><h2 id="e457" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">简介</strong></h2><p id="1fa1" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">数据科学家/分析师经常使用Apply函数来执行数据操作任务<strong class="lw iu">，但是当您的数据有太多行时使用它真的是最佳选择吗？</strong></p><p id="65f4" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated"><strong class="lw iu">不尽然！</strong></p><p id="ccf4" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">在这篇博客中，我们将看看下面3个非常有用的替代方法，你可以用它们来代替Apply函数，尤其是当你有大量的行时:</p><ol class=""><li id="1f7b" class="ms mt it lw b lx mn ma mo lh mu ll mv lp mw mm mx my mz na bi translated"><em class="nb">并行化</em></li><li id="b70f" class="ms mt it lw b lx nc ma nd lh ne ll nf lp ng mm mx my mz na bi translated"><em class="nb"> Loops(是的，可以更快！)</em></li><li id="13db" class="ms mt it lw b lx nc ma nd lh ne ll nf lp ng mm mx my mz na bi translated"><em class="nb">矢量化(最佳实践！)</em></li></ol><p id="e7d0" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">但是首先，让我们来看看apply函数在大型数据集上的执行时间。</p><p id="5d38" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated"><strong class="lw iu">创建数据集</strong></p><p id="def9" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">我们将创建一个具有5百万行和4列的数据集。每列可以有一个从0到50的整数值。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="f2f6" class="ky kz it ni b gy nm nn l no np">import numpy as np<br/>import pandas as pd</span><span id="7a14" class="ky kz it ni b gy nq nn l no np">df = pd.DataFrame(np.random.randint(0, 50, size=(5000000, 4)), columns=('a','b','c','d'))</span><span id="fda5" class="ky kz it ni b gy nq nn l no np">df.shape<br/># (5000000, 5)</span><span id="47fa" class="ky kz it ni b gy nq nn l no np">df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/3103add0a5c75370031dabfc994c1027.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*UyU55MoAQx1uixWn2qzVpA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数据框(图片由作者提供)</p></figure><p id="c7de" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated"><strong class="lw iu">定义功能</strong></p><p id="c414" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">现在，让我们定义我们的函数，该函数基于dataframe/input变量的现有列中的值返回一些值。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="3e6f" class="ky kz it ni b gy nm nn l no np">def infer(a,b,c,d):<br/>    if a==0:<br/>        return d<br/>    elif a &lt;= 25 &amp; a&gt;0:<br/>        return b-c<br/>    else:<br/>        return b+c</span></pre><p id="b4ba" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated"><strong class="lw iu">应用功能</strong></p><p id="cfaf" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">现在，我们将使用“应用”函数来调用上一步中定义的推断函数。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="c334" class="ky kz it ni b gy nm nn l no np">import time</span><span id="5e00" class="ky kz it ni b gy nq nn l no np">start = time.time()<br/>df['e'] = df.apply(lambda x: infer(x['a'], x['b'], x['c'], x['d']), axis = 1)<br/>end = time.time()<br/>print(end - start)</span><span id="c131" class="ky kz it ni b gy nq nn l no np">### Time taken: 200 seconds</span></pre><p id="4810" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">应用功能大约需要<strong class="lw iu"> 200秒</strong>才能得到结果。</p><p id="509d" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">让我们来看看替代方法:</p><h2 id="b23f" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">选项1:并行化</h2><p id="cd4a" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">并行化是通过将大数据块划分为较小的数据块来实现的，这些较小的数据块使用多个CPU和内核的能力来并行处理。</p><p id="3476" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">有几个包，比如<em class="nb"> Swifter </em>和<em class="nb"> Dask </em>，我们可以使用它们实现并行化。在这篇博客中，我们将看看swifter，因为它非常容易使用，并且在某些情况下可以达到几乎相同的结果或更好的结果。</p><p id="f912" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">我们可以简单地在dataframe之后调用swifter包，然后继续应用函数。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="0d3e" class="ky kz it ni b gy nm nn l no np">## install the package<br/>!pip install swifter</span><span id="7d75" class="ky kz it ni b gy nq nn l no np">## import the package <br/>import swifter</span><span id="17d6" class="ky kz it ni b gy nq nn l no np">## use the swifter package<br/>start = time.time()<br/>df['e'] = df.swifter.apply(lambda x: infer(x['a'], x['b'], x['c'], x['d']), axis = 1)</span><span id="a437" class="ky kz it ni b gy nq nn l no np">end = time.time()<br/>print(end - start)</span><span id="48ae" class="ky kz it ni b gy nq nn l no np">## Time taken: 60 seconds</span></pre><p id="35d5" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">因此，使用Swifter包，我们可以将执行时间减少3倍以上，对于简单添加包名来说，这已经不错了。</p><p id="ed0c" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">Swifter试图以最好的方式实现apply函数，要么在后端使用Dask将其矢量化或并行化，要么在数据集很小的情况下简单地使用pandas apply。T29】</p><h2 id="4738" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">选项2:循环</h2><p id="c7e0" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">我知道这听起来令人震惊，但如果你有一个没有太多列的数据集，那么这种技术可以方便地获得比swifter包更好的结果。</p><p id="995c" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">诀窍是首先将dataframe转换成默认的light数据结构，比如数组或字典，然后遍历这些行来操作数据集。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="2a88" class="ky kz it ni b gy nm nn l no np">start = time.time()</span><span id="b34a" class="ky kz it ni b gy nq nn l no np">## empty list <br/>list2 = []</span><span id="fa0b" class="ky kz it ni b gy nq nn l no np">## adding 'e' column with default 0<br/>df['e'] = 0</span><span id="7150" class="ky kz it ni b gy nq nn l no np">## convert dataframe into array <br/>for row in df.values:<br/>    if row[0] == 0:<br/>        row[4] = row[3]<br/>    <br/>    elif row[0] &lt;= 25 &amp; row[0] &gt; 0:<br/>        row[4] = row[1]-row[2]<br/>    else:<br/>        row[4] = row[1] + row[2]<br/>    list2.append(row)<br/>    <br/>df2 = pd.DataFrame(list2, columns=['a', 'b', 'c', 'd','e'])</span><span id="dda5" class="ky kz it ni b gy nq nn l no np">end = time.time()<br/>print(end - start)</span><span id="66fa" class="ky kz it ni b gy nq nn l no np">## Time taken: 20 seconds</span></pre><p id="cfc2" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">因此，使用for循环遍历数组，我们能够将执行时间减少到20秒，比apply函数提高了10倍。</p><h2 id="dd0c" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">选项3:矢量化</h2><p id="3c94" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">矢量化是在数据集上实现数组操作的技术。在后台，它一次将操作应用于数组或序列的所有元素(不像for循环一次处理一行)。</p><p id="545f" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">对python代码进行矢量化是实现最佳性能的最佳实践。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="3223" class="ky kz it ni b gy nm nn l no np"># using vectorization <br/>start = time.time()</span><span id="0216" class="ky kz it ni b gy nq nn l no np"><br/>df['e'] = df['b'] + df['c']<br/>df.loc[df['a'] &lt;= 25, 'e'] = df['b'] -df['c']<br/>df.loc[df['a']==0, 'e'] = df['d']</span><span id="601a" class="ky kz it ni b gy nq nn l no np">end = time.time()<br/>print(end - start)<br/>## 0.28007707595825195 sec</span></pre><p id="43eb" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">因此，我们能够将运行时间减少到0.28秒，比应用函数的运行时间快700倍。</p><h1 id="a0cf" class="ns kz it bd la nt nu nv ld nw nx ny lg jz nz ka lk kc oa kd lo kf ob kg ls oc bi translated">摘要</h1><ul class=""><li id="b508" class="ms mt it lw b lx ly ma mb lh od ll oe lp of mm og my mz na bi translated">我们研究了python中Apply函数的3种替代方法，尤其是当数据集包含大量行时。</li><li id="0394" class="ms mt it lw b lx nc ma nd lh ne ll nf lp ng mm og my mz na bi translated">我们了解了swifter软件包的并行处理能力。</li><li id="978b" class="ms mt it lw b lx nc ma nd lh ne ll nf lp ng mm og my mz na bi translated">我们发现，如果聪明地使用，python中的循环并没有那么糟糕。</li><li id="cad0" class="ms mt it lw b lx nc ma nd lh ne ll nf lp ng mm og my mz na bi translated">对于一个大型数据集，代码的矢量化带来了最佳的性能提升，大约是apply函数的700倍。因此，使用矢量化处理大型数据集是最佳实践。</li></ul></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><p id="b06b" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">我希望你从这篇文章中学到了一些新的东西。</p><p id="565c" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">你可以在收件箱里收到我的帖子。 <a class="ae oo" href="https://anmol3015.medium.com/subscribe" rel="noopener"> <strong class="lw iu"> <em class="nb">做到这里</em> </strong> <em class="nb">！</em> </a> <em class="nb"> <br/>如果你喜欢体验媒介的自己，可以考虑通过</em> <a class="ae oo" href="https://anmol3015.medium.com/membership" rel="noopener"> <strong class="lw iu"> <em class="nb">报名会员来支持我和其他成千上万的作家。它每个月只需要5美元，它极大地支持了我们，作家，而且你也有机会通过你的写作赚钱。</em></strong></a></p></div></div>    
</body>
</html>