<html>
<head>
<title>Introduction to Linear Programming in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的线性编程简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-linear-programming-in-python-9261e7eb44b#2022-04-04">https://towardsdatascience.com/introduction-to-linear-programming-in-python-9261e7eb44b#2022-04-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c9ea" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用谷歌或工具进行数学优化的指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bc1a149a1e2774a91349840032802893.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Epu8_DseKreL6x_vp-uQyQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由作者提供，表情符号由<a class="ae kv" href="https://openmoji.org/" rel="noopener ugc nofollow" target="_blank">open moji</a>(<a class="ae kv" href="https://creativecommons.org/licenses/by-sa/4.0/#" rel="noopener ugc nofollow" target="_blank">CC BY-SA 4.0</a>)</p></figure><p id="75a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">线性规划是一种技术<strong class="ky ir">优化任何问题</strong>与多个变量和约束。这是一个简单但强大的工具，每个数据科学家都应该掌握。</p><p id="108f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想象你是一名<strong class="ky ir">军师</strong>正在招募一支<strong class="ky ir">军队</strong>。你有:</p><ul class=""><li id="8c1f" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky ir">三种资源</strong>:🌾<strong class="ky ir">粮食</strong>，🪵 <strong class="ky ir">木材</strong>，🪙 <strong class="ky ir">黄金</strong></li><li id="82bd" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">三个单位</strong> : 🗡️ <strong class="ky ir">剑士</strong>，🏹<strong class="ky ir">弓手</strong>，以及🐎<strong class="ky ir">骑兵</strong>。</li></ul><p id="2c8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">骑兵比弓箭手强壮，弓箭手又比剑士强壮。下表提供了每个装置的成本和功率:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mg"><img src="../Images/20b944db923da83b921873cc4a023776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dtvvedKDJWpB9zgnMoIYhQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="74d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有1200个🌾食物，800 🪵wood，600 🪙gold.考虑到这些资源，我们应该如何最大化我们军队的力量？</p><p id="46e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以简单地找到具有最佳功率/成本比的单元，尽可能多地采用它们，并对其他两个单元重复该过程。但是这种“猜测和检查”的解决方案可能甚至不是最佳的</p><p id="3b4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在想象我们有<strong class="ky ir">百万台，资源</strong>:之前的贪婪策略很可能完全错过最优解。可以使用机器学习算法(例如，遗传算法)来解决这个问题，但是我们也不能保证解决方案是最优的。</p><p id="25c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对我们来说幸运的是，有一种方法可以用最优的方式解决我们的问题:<strong class="ky ir">线性规划</strong>(或者线性优化)，这是<a class="ae kv" href="https://en.wikipedia.org/wiki/Operations_research" rel="noopener ugc nofollow" target="_blank">运筹学</a>(或者)领域的一部分。在这篇文章中，我们将使用它来寻找最佳数量的剑士、弓箭手和骑兵，以建立可能拥有最高力量的<strong class="ky ir">军队。</strong></p><p id="7b5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以用下面的<a class="ae kv" href="https://colab.research.google.com/drive/1dbrFJwFv80kgUi13MfPO3KyumG-SVIHG?usp=sharing" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> Google Colab笔记本</strong> </a>运行本教程的代码。</p><h1 id="41d8" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">🧠一世:解决者</h1><p id="b5aa" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">在Python中，有不同的线性编程库，比如多用途的<strong class="ky ir"> SciPy </strong>，初学者友好的<strong class="ky ir"> PuLP </strong>，详尽的<strong class="ky ir"> Pyomo </strong>等等。</p><p id="c168" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，我们将使用<a class="ae kv" href="https://developers.google.com/optimization" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">谷歌或-Tools </strong> </a>，它非常用户友好，带有几个预打包的解算器，并且在<a class="ae kv" href="https://github.com/google/or-tools" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上拥有迄今为止最多的明星。</p><p id="62be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果安装不成功，请重启内核并重试:它有时会失败。\_(ツ)_/</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="3eeb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有这些库都有一个隐藏的好处:它们充当到<strong class="ky ir">的<strong class="ky ir">接口，使用相同的模型和不同的解算器</strong>。像<a class="ae kv" href="https://www.gurobi.com/" rel="noopener ugc nofollow" target="_blank"> Gurobi </a>、<a class="ae kv" href="https://www.ibm.com/analytics/cplex-optimizer" rel="noopener ugc nofollow" target="_blank"> Cplex </a>或<a class="ae kv" href="https://www.scipopt.org/" rel="noopener ugc nofollow" target="_blank"> SCIP </a>这样的解算器有它们自己的API，但是它们创建的模型被绑定到一个特定的解算器。</strong></p><p id="a387" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">OR-Tools允许我们使用一种抽象的(相当pythonic化的)方式来建模我们的问题。<strong class="ky ir"> </strong>然后我们可以选择<strong class="ky ir">一个或几个求解器</strong>来找到一个最优解。因此，我们构建的模型是高度可重用的！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/28ae1ab4493ca97e96b6a9060721c11c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*RcFaacJfUxkLQu9ZJLxSMQ.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="0d67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">OR-Tools自带线性规划求解器，名为<strong class="ky ir"> GLOP </strong>(谷歌线性优化包)。它是由Google的运筹学团队创建的开源项目，用C++编写。</p><p id="b60e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其他解算器也可用，如<strong class="ky ir"> SCIP </strong>，这是一个优秀的非商业解算器，创建于2005年，并更新和维护至今。我们也可以使用流行的商业选项，如Gurobi和Cplex。然而，我们需要将它们安装在OR-Tools之上，并获得适当的许可证(这可能相当昂贵)。现在，让我们试试GLOP。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="bf5f" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">🧮二世。变量</h1><p id="9383" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">我们使用GLOP创建了一个OR-Tools解算器的实例。现在，如何使用线性规划？我们首先要定义的是我们要优化的<strong class="ky ir">变量</strong>。</p><p id="feb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，我们有三个变量:🗡️swordsmen的数量，🏹弓手，和🐎军队中的骑兵。OR-Tools接受三种类型的变量:</p><ul class=""><li id="eedc" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe nh ni nj nk b">NumVar</code>为<strong class="ky ir">连续的</strong>变量；</li><li id="2047" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nh ni nj nk b">IntVar</code>为<strong class="ky ir">整数</strong>变量；</li><li id="592d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nh ni nj nk b">BoolVar</code>为<strong class="ky ir">布尔</strong>变量。</li></ul><p id="d552" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们正在寻找<strong class="ky ir">单位的整数</strong>，所以我们选择<code class="fe nh ni nj nk b">IntVar</code>。然后，我们需要为这些变量指定下限和上限。我们想要至少0个单位，但是我们没有上限。所以我们可以说我们的上限是无穷大(或者任何我们永远达不到的大数字)。它可以写成:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/0925315cff44c0e889554a029fc4f59f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xToxV636Fi3RCssVbLl5og.png"/></div></div></figure><p id="bf28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们把它翻译成代码。在OR-Tools中无穷大被替换为<code class="fe nh ni nj nk b">solver.infinity()</code>。除此之外，语法<strong class="ky ir">非常简单</strong>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="1d8d" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">⛓️三世。限制</h1><p id="7e3e" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">我们定义了变量，但是<strong class="ky ir">约束</strong>同样重要。</p><p id="c147" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也许与直觉相反，添加更多约束有助于求解器<strong class="ky ir">更快地找到最优解</strong>。为什么会这样呢？把求解器想象成一棵树:约束帮助它修剪树枝，减少搜索空间。</p><p id="40d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，我们可以用来生产单位的资源数量有限。换句话说，<strong class="ky ir">我们不能花费比我们拥有的</strong>更多的资源。例如，在🌾招募单位花费的食物不能高于1200。🪵wood (800)和🪙gold (600)也是如此。</p><p id="484d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据我们的表格，单位成本如下:</p><ul class=""><li id="b963" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">1 <strong class="ky ir">剑客</strong> =🌾60 + 🪵20;</li><li id="7301" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">1 <strong class="ky ir">鲍曼</strong> =🌾80 + 🪵10 + 🪙40;</li><li id="6112" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">1 <strong class="ky ir">骑士</strong> =🌾140 + 🪙100.</li></ul><p id="7b38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以为每个资源编写一个约束，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/b36c4b732cc23d730865bdd52e941f79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JicTldXKGcvpf5QT0U1-1Q.png"/></div></div></figure><p id="fca5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在OR-Tools中，我们简单地用<code class="fe nh ni nj nk b">solver.Add()</code>将约束添加到我们的求解器实例中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="d67b" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">🎯四。目标</h1><p id="b0cd" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">现在我们有了变量和约束，我们想要<strong class="ky ir">定义我们的目标</strong>(或者目标函数)。</p><p id="3490" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在线性编程中，这个函数<strong class="ky ir">必须是线性的</strong>(像约束一样)，所以形式为<em class="nm"> ax + by + cz + d </em>。在我们的例子中，目标非常明确:我们希望招募拥有最高权力的军队。该表给出了以下功率值:</p><ul class=""><li id="a6cf" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">1 <strong class="ky ir">剑客</strong> =💪70;</li><li id="8c2c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">1 <strong class="ky ir">鲍曼</strong> =💪95;</li><li id="c87e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">1 <strong class="ky ir">骑士</strong> =💪230.</li></ul><p id="fdde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最大化陆军的力量相当于<strong class="ky ir">最大化各部队力量的总和</strong>。我们的目标函数可以写成:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/4252bf4afc1c6ebdf9338c2360673ff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*slJgmPIL6LMNEaZovY5KDA.png"/></div></div></figure><p id="7873" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一般来说，目标函数只有两种:<strong class="ky ir">最大化</strong>或<strong class="ky ir">最小化</strong>。在OR-Tools中，我们用<code class="fe nh ni nj nk b"><a class="ae kv" href="https://google.github.io/or-tools/python/ortools/linear_solver/pywraplp.html#Solver.Maximize" rel="noopener ugc nofollow" target="_blank">solver.Maximize()</a></code>或<code class="fe nh ni nj nk b"><a class="ae kv" href="https://google.github.io/or-tools/python/ortools/linear_solver/pywraplp.html#Solver.Minimize" rel="noopener ugc nofollow" target="_blank">solver.Minimize()</a></code>来声明这个目标。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="bd12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们完事了。对任何线性优化问题建模有三个步骤:</p><ol class=""><li id="30b6" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nn ly lz ma bi translated">声明<strong class="ky ir">变量</strong>用下限和上限进行优化；</li><li id="938e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nn ly lz ma bi translated">将<strong class="ky ir">约束</strong>添加到这些变量中；</li><li id="9812" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nn ly lz ma bi translated">定义<strong class="ky ir">目标函数</strong>最大化或最小化。</li></ol><p id="76b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在很清楚了，我们可以要求求解器为我们找到一个最优解。</p><h1 id="65fe" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">🥇五、优化！</h1><p id="bf0b" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">用<code class="fe nh ni nj nk b"><a class="ae kv" href="https://google.github.io/or-tools/python/ortools/linear_solver/pywraplp.html#Solver.Solve" rel="noopener ugc nofollow" target="_blank">solver.Solve(</a>)</code>计算最优解。该函数返回一个状态，可用于<strong class="ky ir">检查解决方案是否确实是最优的</strong>。</p><p id="8a80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们用最好的陆军配置打印出我们能得到的最高总功率。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><pre class="kg kh ki kj gt no nk np nq aw nr bi"><span id="d51d" class="ns mi iq nk b gy nt nu l nv nw">================= Solution =================<br/>Solved in 87.00 milliseconds in 2 iterations<br/><br/><strong class="nk ir">Optimal power</strong> = 1800.0 💪power<br/>Army:<br/> - 🗡️<strong class="nk ir">Swordsmen </strong>= 6.0000000000000036<br/> - 🏹<strong class="nk ir">Bowmen </strong>= 0.0<br/> - 🐎<strong class="nk ir">Horsemen </strong>= 5.999999999999999</span></pre><p id="c22f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太好了！求解器找到了一个最优解:我军的总兵力为💪1800 带6个🗡️swordsmen和6个🐎骑兵(对不起弓箭手！).</p><p id="eaea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们解开这个结果:</p><ul class=""><li id="8706" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">求解器决定采用<strong class="ky ir">的最大数量🐎骑士</strong> (6，因为我们只有🪙600，他们每个人都花了🪙100)；</li><li id="3c5d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">剩下的资源都花在🗡️ <strong class="ky ir">剑士</strong>身上:我们有1200–6 * 140 = 360🌾食物剩余，这就是为什么求解器选择6 🗡️swordsmen；</li><li id="eb43" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我们可以推断出骑兵是最好的单位，弓手是最差的单位，因为他们根本没有被选中。</li></ul><p id="1d28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，但是有一点很奇怪:这些数字不是圆的，尽管我们指定我们想要的是整数。发生了什么事？</p><p id="112a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，回答这个问题需要深入研究线性编程…为了在这个介绍中保持简单，让我们说是因为GLOP。解算器有我们必须考虑的特征，GLOP不处理整数。这是构建可重用模型不仅仅是方便的另一个证明。</p><p id="5a7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将在<a class="ae kv" rel="noopener" target="_blank" href="/integer-programming-vs-linear-programming-in-python-f1be5bb4e60e">更高级的教程</a>中解释为什么GLOP会有这种奇怪的行为以及<strong class="ky ir">如何修复它</strong>。</p><h1 id="7457" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">结论</h1><p id="fece" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">通过这个例子，我们看到了任何线性优化问题的<strong class="ky ir">五个主要步骤</strong>:</p><ol class=""><li id="24f7" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nn ly lz ma bi translated">选择求解器:在我们的例子中，为了方便起见，我们选择了GLOP。</li><li id="d143" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nn ly lz ma bi translated"><strong class="ky ir">声明变量</strong>:要优化的参数是剑士、弓手和骑兵的数量。</li><li id="9da1" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nn ly lz ma bi translated"><strong class="ky ir">声明约束</strong>:这些单元中的每一个都有成本。总费用不能超过我们有限的资源。</li><li id="4c81" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nn ly lz ma bi translated"><strong class="ky ir">定义目标:</strong>最大化的标准是这支军队的总实力。也可能是其他东西，比如单位的数量。</li><li id="ca2c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nn ly lz ma bi translated"><strong class="ky ir">优化</strong> : GLOP不到一秒钟就找到了这个问题的最优解。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/423b2b994d50f5516f53a928e074ecae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yqPZN-DYul-rGaWPlYYMzg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="9fce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是线性规划的主要好处:算法给我们一个<strong class="ky ir">保证，即找到的解是</strong> <strong class="ky ir">最优</strong>(有一定误差)。这种保证是强有力的，但也是有代价的:模型可能非常复杂，以至于求解者需要数年(或更长时间)才能找到最优解。在这种情况下，我们有两种选择:</p><ul class=""><li id="2454" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">我们可以在一段时间后<strong class="ky ir">停止求解器</strong>(并可能获得一个次优答案)；</li><li id="8abb" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我们可以使用类似遗传算法的元启发式算法在短时间内计算出一个优秀的解决方案。</li></ul><p id="6d97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下一篇文章中，我们将讨论不同类型的优化问题，并将我们的方法推广到一整类优化问题。</p><p id="fd27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢这个介绍！欢迎分享，传播关于线性优化的知识。别忘了查看我的博客 和<a class="ae kv" href="https://twitter.com/maximelabonne" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">在Twitter </strong> </a>上关注我，我会在那里发布这些文章的摘要。干杯！</p><h1 id="a67a" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">相关文章</h1><div class="ny nz gp gr oa ob"><a rel="noopener follow" target="_blank" href="/integer-programming-vs-linear-programming-in-python-f1be5bb4e60e"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">第2部分:Python中的整数与线性编程</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">识别和解决任何优化问题的指南</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">towardsdatascience.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op kp ob"/></div></div></a></div><div class="ny nz gp gr oa ob"><a rel="noopener follow" target="_blank" href="/constraint-programming-67ac16fa0c81"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">第3部分:Python中的约束编程</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">在8，080，104个候选项中找出一个解决方案的编程范例</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">towardsdatascience.com</p></div></div><div class="ok l"><div class="oq l om on oo ok op kp ob"/></div></div></a></div></div></div>    
</body>
</html>