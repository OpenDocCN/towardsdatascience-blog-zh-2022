<html>
<head>
<title>Building a Data Pipeline for my own Strava Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为我自己的Strava数据构建数据管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-data-pipeline-for-my-strava-data-98ea8b2b0767#2022-06-21">https://towardsdatascience.com/building-a-data-pipeline-for-my-strava-data-98ea8b2b0767#2022-06-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="498b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Strava API、MySQL、Python、S3、Redshift和Airflow对我自己的Strava数据进行EtLT</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9679dac89a2a40f1acf50b94090e2fb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yhQG-EKFSs_UZ-bY"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马库斯·温克勒在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="91e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我构建了一个EtLT管道，从Strava API获取我的<a class="ae kv" href="https://www.strava.com/athletes/5028644" rel="noopener ugc nofollow" target="_blank"> Strava数据</a>，并将其加载到一个<a class="ae kv" href="https://aws.amazon.com/redshift/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">红移</strong> </a>数据仓库中。然后，使用<a class="ae kv" href="https://airflow.apache.org" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">气流</strong> </a>每周运行一次该管道，以提取任何新的活动数据。最终目标是使用这个数据仓库在<strong class="ky ir"> Tableau </strong>中构建一个自动更新的仪表板，并触发我的<a class="ae kv" href="https://github.com/jackmleitch/StravaKudos" rel="noopener ugc nofollow" target="_blank"> Strava Kudos预测模型</a>的自动重新训练。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/9f7a2fa7229de3a3a53fe6d510bf3fe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hKLoX6ySf0XKxf75nfi_PQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">系统架构(图片由作者提供)</p></figure><h1 id="70a4" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><a class="ae kv" href="https://github.com/jackmleitch/StravaDataPipline/blob/master/src/extract_strava_data.py" rel="noopener ugc nofollow" target="_blank">数据提取</a></h1><p id="2329" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我的个人Strava活动数据首先使用<a class="ae kv" href="https://developers.strava.com" rel="noopener ugc nofollow" target="_blank"> Strava API </a>被增量<strong class="ky ir">摄取</strong>并被加载到<strong class="ky ir"> S3桶</strong>中。在每次摄取运行时，我们查询MySQL数据库以获得最后一次提取的日期:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="ac6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们使用<code class="fe ms mt mu mv b">requests</code>库重复调用REST API，直到获得从现在到<code class="fe ms mt mu mv b">last_updated_warehosue</code>之间的所有活动数据。我们包含了一个<code class="fe ms mt mu mv b">time.sleep()</code>命令来遵守Strava设置的100个请求/15分钟的速率限制。我们还包含了<code class="fe ms mt mu mv b">try: except:</code>块，以防止<br/>丢失某些活动的数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="cdbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在将数据本地导出到由竖线分隔的<code class="fe ms mt mu mv b">.csv</code>文件之前，我们执行一些小的转换，比如格式化日期和时区列。因此EtLT中的小t！在我们保存数据之后，它将被上传到一个S3存储桶中，以便以后加载到数据仓库中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="99dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们执行一个查询，在最后的提取日期更新MySQL数据库。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="6bce" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><a class="ae kv" href="https://github.com/jackmleitch/StravaDataPipline/blob/master/src/copy_to_redshift_staging.py" rel="noopener ugc nofollow" target="_blank">数据加载</a></h1><p id="197a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">一旦数据被加载到S3数据湖，它就会被加载到我们的<strong class="ky ir">红移</strong>数据仓库。我们分两部分加载数据:</p><ul class=""><li id="7c74" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">我们首先将数据从S3存储桶装载到一个临时表中，该表的模式与我们的生产表相同</li><li id="63f5" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">然后，我们在临时表和生产表之间执行验证测试(参见数据验证部分)。如果所有关键测试都通过了，那么我们首先从生产表中删除两个表之间的所有重复项。然后，临时表中的数据被完全插入到生产表中。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="99c1" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><a class="ae kv" href="https://github.com/jackmleitch/StravaDataPipline/blob/master/src/validator.py" rel="noopener ugc nofollow" target="_blank">数据验证</a></h1><p id="381c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们用python实现了一个简单的框架，用于在我们的数据管道中执行基于SQL的数据验证检查。尽管它缺少我们期望在生产环境中看到的许多功能，但这是一个良好的开端，并为我们如何改进基础设施提供了一些见解。</p><p id="902c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ms mt mu mv b">validator.py</code>脚本对红移执行一对SQL脚本，并基于比较操作符(&gt;、&lt;、=)比较这两个脚本。然后，根据两个执行脚本的结果，测试通过或失败。在将新获取的数据上传到staging表之后，但在将该表插入到production表之前，我们执行这个验证步骤。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="b2d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我实现了检查重复项的检查，将staging表中总活动的分布(Airflow设置为在每周结束时执行)与平均历史周活动计数进行比较，并使用z分数将Kudos计数指标的分布与历史分布进行比较。换句话说，最后两个查询检查这些值是否在基于历史的预期值的90%置信区间内。例如，以下查询计算给定周内上载的所有活动的z得分(在staging表中找到)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="870f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过跑步</p><pre class="kg kh ki kj gt nk mv nl nm aw nn bi"><span id="6764" class="no lu iq mv b gy np nq l nr ns">python src/validator.py sql/validation/weekly_activity_count_zscore.sql sql/validation/zscore_90_twosided.sql greater_equals warn</span></pre><p id="26ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在终端中，我们将在之前的查询中找到的z分数与90%置信区间z分数<code class="fe ms mt mu mv b">SELECT 1.645;</code>进行比较。命令末尾的“warn”告诉脚本不要出错退出，而是警告我们。另一方面，如果我们在结尾加上' halt ',脚本将会退出并显示一个错误代码，并暂停所有后续任务。</p><p id="bebf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还实现了一个系统，通过验证测试结果向给定的松弛通道发送通知，这个验证系统是受James Densmore的优秀数据管道一书的管道中的数据验证一章的启发。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="5473" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们将所有的测试组合到一个shell脚本<code class="fe ms mt mu mv b">validate_load_data.sh</code>中，在将数据从S3存储桶加载到暂存表之后，在将数据插入到生产表之前，运行这个脚本。对上周的数据运行此管道会得到以下输出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/edbf8e182a063b42eab968898c538785.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FtOKGE0mWcPD7LqjdcrnRA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">松弛消息(图片由作者提供)</p></figure><p id="4985" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很高兴看到我们的第二次测试失败了，因为上周我没有像往常一样跑那么多！</p><p id="cac0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这个验证框架非常基础，但是它是一个很好的基础，可以在以后的日子里进行构建。</p><h1 id="05eb" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><a class="ae kv" href="https://github.com/jackmleitch/StravaDataPipline/blob/master/src/build_data_model.py" rel="noopener ugc nofollow" target="_blank">数据转换</a></h1><p id="7ef7" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">现在数据已经被接收到数据仓库中，管道中的下一步是数据转换。在这种情况下，数据转换既包括数据的非上下文操作，也包括考虑上下文和逻辑的数据建模。在这种情况下，使用ELT方法而不是ETL框架的好处是，它给我们，即最终用户，以我们需要的方式转换数据的自由，而不是拥有一个我们不能改变的固定数据模型(或者至少不能没有麻烦地改变)。在我的例子中，我将我的红移数据仓库连接到Tableau，构建一个仪表板。例如，我们可以构建一个数据模型来提取每月统计数据:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="10d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还可以建立更复杂的数据模型。例如，我们可以获得按锻炼类型细分的每周总kudos的每周百分比变化:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="94dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更进一步的方向是利用第三方工具，如<a class="ae kv" href="https://www.getdbt.com" rel="noopener ugc nofollow" target="_blank"> dbt </a>来实现数据建模。</p><h1 id="3658" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><a class="ae kv" href="https://github.com/jackmleitch/StravaDataPipline/blob/master/airflow/dags/elt_strava_pipeline.py" rel="noopener ugc nofollow" target="_blank">用气流把它们组合在一起</a></h1><p id="e342" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们创建一个DAG来协调我们的数据管道。我们将管道设置为每周运行，这意味着它将在每周周日上午的午夜运行一次。如下图所示，我们的DAG将:</p><ul class=""><li id="e0ff" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">首先，使用Strava API提取最近的数据，并将其上传到S3存储桶</li><li id="cbd9" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">然后，它会将这些数据加载到我们的红移集群中的临时表中</li><li id="d097" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">然后将执行3个验证测试，并将结果通知我们的Slack channel</li><li id="744b" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">然后，临时表将被插入到生产表中，删除流程中的任何重复项</li><li id="dd64" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">最后，将在一个新表<code class="fe ms mt mu mv b">activity_summary_monthly</code>中创建一个月度聚合数据模型</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/e72ae4e6ef6696ed9e727f382a76ed04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DGBS6z3MJqmvmA5L8VBbWA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">DAG图(图片由作者提供)</p></figure><h1 id="8246" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">数据可视化</h1><p id="1f96" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">完成数据转换后，我们就能够使用Tableau构建一个交互式仪表板，当新数据被接收到数据仓库时，它会自动更新，每周更新一次。我创建的仪表板是为了调查我的Strava活动的声望如何随着时间和地点的变化而变化。在建立这个项目后，我关闭了红移服务器，以避免任何费用，但下面可以看到仪表板的截图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/70fbe3f935480d4e61e4ca2bd3615fd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oIkltRtBTi5i98kxW6-AWg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Kudos仪表板(图片由作者提供)</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/bae65712f0ffa92e8716b87a7dddc299.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pux9KNVMYMzvYdPAUYvMVg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">互动地图(图片由作者提供)</p></figure><h1 id="cbcb" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><a class="ae kv" href="https://github.com/jackmleitch/StravaDataPipline/tree/master/tests" rel="noopener ugc nofollow" target="_blank">单元测试</a></h1><p id="766e" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">单元测试是使用PyTest执行的，所有测试都可以在tests目录中找到。例如，下面我们看到一个测试<code class="fe ms mt mu mv b">make_strava_api_request</code>函数的单元测试。它断言收到了一个字典响应，并且该响应包含一个整数的“id”键。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="fd91" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">进一步的方向和考虑</h1><ul class=""><li id="7524" class="mw mx iq ky b kz ml lc mm lf nx lj ny ln nz lr nb nc nd ne bi translated"><strong class="ky ir">用docker </strong>改善气流:我本可以使用气流的Docker图像来运行Docker容器中的管道，这会使事情更加健壮。这也将使大规模部署管道更加容易！</li><li id="b1a6" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><strong class="ky ir">实现更多的验证测试</strong>:对于一个真实的生产管道，我会在整个管道中实现更多的验证测试。例如，我可以使用像<a class="ae kv" href="https://greatexpectations.io/" rel="noopener ugc nofollow" target="_blank">远大前程</a>这样的开源工具。</li><li id="9e4f" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">简化流程:管道可能会以更简单的方式运行。另一种方法是使用Cron进行编排，使用PostgreSQL或SQLite进行存储。</li><li id="5b35" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><strong class="ky ir">数据流</strong>:为了保持仪表盘持续更新，我们可以从类似<a class="ae kv" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank"> Kafka </a>的东西中受益。</li></ul><h1 id="d029" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">结束语</h1><p id="28dd" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">最后，我构建了一个数据管道来自动提取、加载和转换我的Strava数据。该管道每周运行一次，并自动更新交互式仪表板。</p><p id="6954" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢它！</p></div></div>    
</body>
</html>