<html>
<head>
<title>Introduction to Simulation with SimPy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SimPy仿真简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-simulation-with-simpy-5656bb4aafbe#2022-05-31">https://towardsdatascience.com/introduction-to-simulation-with-simpy-5656bb4aafbe#2022-05-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c65d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">第6部分:多项绩效指标</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4a09ad8e51afa41d76ae618acb4bc8cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1d-daA2jQkvuNWjE"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安特·罗泽茨基在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="cc99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如副标题所示，这是与使用<strong class="lb iu"> SimPy </strong>的<strong class="lb iu">模拟技术</strong>应用相关的系列中的第<strong class="lb iu">篇，SimPy </strong>是基于Python的基于流程、面向对象、离散事件模拟框架。</p><p id="ad85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之前的文章都发表在<strong class="lb iu">走向数据科学</strong>以下是对应链接:<a class="ae ky" rel="noopener" target="_blank" href="/introduction-to-simulation-with-simpy-b04c2ddf1900">第一篇</a>；<a class="ae ky" rel="noopener" target="_blank" href="/introduction-to-simulation-with-simpy-322606d4ba0c">第二条</a>；<a class="ae ky" rel="noopener" target="_blank" href="/introduction-to-simulation-with-simpy-8d744c82dc80">第三条</a>；<a class="ae ky" rel="noopener" target="_blank" href="/introduction-to-simulation-with-simpy-8e7187c6eb82">第四条</a>；<a class="ae ky" rel="noopener" target="_blank" href="/introduction-to-simulation-with-simpy-e27cd7b1ff47">第五条。</a></p><p id="9586" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第4篇文章中，我们指出模拟研究是基于计算机的统计抽样实验[1]。我们建立现实世界问题的数学或逻辑模型，并对其进行实验，直到获得足够的知识来解决预定义的决策问题。</p><p id="2ee2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，现实世界的系统在数据中表现出很大的随机性。因此，统计和概率对仿真分析至关重要。</p><p id="3a7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第4篇文章中，我们使用了一个名为<strong class="lb iu">固定样本量程序</strong>的统计程序来进行<strong class="lb iu">终止模拟</strong>的输出数据分析。我们计算了<strong class="lb iu">置信区间</strong> ( <strong class="lb iu"> CIs </strong>)，因为<strong class="lb iu">绩效指标</strong>的样本均值总是有一些误差。这种方法的缺点是我们不能确定这些置信区间的大小。</p><p id="74c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在第5篇文章中，我们使用了一个<strong class="lb iu">顺序程序</strong>，使我们能够获得一个具有预定义水平<strong class="lb iu">绝对或相对精度</strong>的置信区间。这个程序的缺点与<em class="lv"> </em> <strong class="lb iu">覆盖概率</strong>(区间包含真均值的实际概率)有关。分析员必须始终意识到使用顺序程序时<strong class="lb iu">在覆盖范围内严重损失的可能性</strong>。</p><p id="9fd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将开发一个同时分析几个性能指标<strong class="lb iu">的程序。</strong></p><h1 id="668f" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated"><strong class="ak">多项绩效指标</strong></h1><p id="5fb0" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">第4条和第5条中描述的程序分别说明了达到几个置信度<strong class="lb iu">的置信区间所需的运行次数</strong>。但是通常的做法是在执行模拟研究时计算多个性能度量。因此，我们需要一个过程来同时为<strong class="lb iu"/><strong class="lb iu"/>的多个绩效指标达到指定的置信水平<strong class="lb iu"> </strong>。</p><p id="20fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种情况在统计文献中被称为<strong class="lb iu">多重比较问题</strong>。用<strong class="lb iu"> Bonferroni不等式描述:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/a907e8e205f638c053db0bafd3330bf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IhWU6oNKrGkJjgZrWWTd4A.png"/></div></div></figure><p id="7685" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Bonferroni不等式用于多重统计推断，以设定总体置信水平的上限。所有同时包含其相应性能指标的配置项必须满足Bonferroni不等式的概率。</p><p id="0e40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<strong class="lb iu">少量测量值</strong>进行模拟研究的惯例如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/e8feccdf9502556466400dff6eeb8f8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GBaekaCq5lGeRNsft7nuSg.png"/></div></div></figure><p id="1c31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个非常保守的程序，但它不需要概率分布假设，并且<strong class="lb iu">允许单独定义每个性能测量的置信水平。</strong></p><p id="2292" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，有了三个性能指标和总体90%的置信区间，我们可以在三个96.667%的置信区间(0.0333+0.0333+0.0333 = 0.1 =<em class="lv">α</em>)或一个95%和两个97.5%的置信区间(0.05+0.025+0.025 = 0.1 =<em class="lv">α</em>)之间进行选择</p><p id="1255" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用SimPy来说明这个过程。</p><h1 id="a7e7" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated"><strong class="ak">用SimPy </strong>模拟机器的故障和维修</h1><p id="1e23" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们用SimPy对一家工厂的机器故障进行编码，并由三名维修人员进行相应的维修。</p><p id="6f73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正在研究的系统是一个<strong class="lb iu">排队系统</strong>，其中机器是随机发生故障的<strong class="lb iu">客户</strong>，由<strong class="lb iu"> </strong>三个修理工(<strong class="lb iu">服务器</strong>)随机花费<strong class="lb iu"> </strong>时间修理<strong class="lb iu">。</strong>每台机器平均每10分钟故障一次，机器故障间隔时间呈指数级。服务时间(以分钟为单位)不遵循已知的概率分布，由下表表示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/69adca89d94e95157e60046115f7494f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*aNwMK7NL1rcCSKBxcJRq5g.png"/></div></figure><p id="380a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的Python代码允许我们应用一个顺序过程来获得三个性能指标的总体置信度为90%的<strong class="lb iu"/>。</p><p id="92d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们导入了熊猫库作为<em class="lv"> pd，</em> Numpy作为<em class="lv"> np </em>，<em class="lv"> RandomState </em>模块，模拟框架<em class="lv"> SimPy。</em>我们需要<em class="lv"> scipy.stats </em>模块，它包含了再现服从均匀和指数分布的随机数序列的方法。最后，我们导入matplotlib作为最终输出的<em class="lv"> plt </em>。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="2db8" class="nb lx it mx b gy nc nd l ne nf">import pandas as pd<br/>import numpy  as np<br/>from numpy.random import RandomState</span><span id="c4d5" class="nb lx it mx b gy ng nd l ne nf">import simpy</span><span id="06ec" class="nb lx it mx b gy ng nd l ne nf">from scipy import stats<br/>from scipy.stats import expon<br/>from scipy.stats import uniform</span><span id="3b75" class="nb lx it mx b gy ng nd l ne nf">import matplotlib.pyplot as plt</span><span id="da1d" class="nb lx it mx b gy ng nd l ne nf">your_path = # type your particular path</span></pre><p id="aeb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在初始化模块中，我们指出了与机器故障间隔时间和维修人员数量相关的指数分布的参数。我们设置一个数据帧(<em class="lv"> df_service </em>)用于函数<em class="lv">修复</em>以及从均匀分布获得的随机变量，以确定修复时间值。第3条<a class="ae ky" rel="noopener" target="_blank" href="/introduction-to-simulation-with-simpy-8d744c82dc80">中使用了类似的逻辑。</a></p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="c04e" class="nb lx it mx b gy nc nd l ne nf"># initialization module</span><span id="a78a" class="nb lx it mx b gy ng nd l ne nf">MACHINE_FAILURE_MEAN  = 10<br/>NUMBER_REPAIR_PERSONS = 3</span><span id="2705" class="nb lx it mx b gy ng nd l ne nf">## times in repairing<br/>list_of_minutes = [15,  30,  40,  50]</span><span id="29b7" class="nb lx it mx b gy ng nd l ne nf"># discrete probabilities for times in repairing<br/>prob1, prob2, prob3, prob4 = 0.1, 0.3, 0.4, 0.2</span><span id="3818" class="nb lx it mx b gy ng nd l ne nf">prob1 = round(prob1, 4)<br/>prob2 = round(prob1 + prob2,4)<br/>prob3 = round(prob2 + prob3,4)<br/>prob4 = round(prob3 + prob4,4)<br/>list_of_probs = [prob1, prob2, prob3, prob4]</span><span id="ea84" class="nb lx it mx b gy ng nd l ne nf">df1 = pd.DataFrame(list_of_minutes, columns = ['minutes'])<br/>df2 = pd.DataFrame(list_of_probs,   columns = ['range'])</span><span id="e093" class="nb lx it mx b gy ng nd l ne nf">df_service = pd.concat([df1, df2], axis = 1)</span></pre><p id="cc03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面两个生成器函数(<em class="lv"> def machine_failure(env，number_repair)</em>&amp;<em class="lv">def repair(env，number _ repair，failure_number，time_of_failure) </em>背后的逻辑也在第3条中进行了描述。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="8bbe" class="nb lx it mx b gy nc nd l ne nf">def machine_failure(env, number_repair):</span><span id="fb0d" class="nb lx it mx b gy ng nd l ne nf">   # counter of failures<br/>   failure_number = 0</span><span id="7dcf" class="nb lx it mx b gy ng nd l ne nf">   while True:<br/>       ## exponential distribution for failures<br/>       next_failure = expon.rvs(scale = MACHINE_FAILURE_MEAN, <br/>                                size = 1)</span><span id="2d87" class="nb lx it mx b gy ng nd l ne nf">       # Wait for the failure<br/>       yield env.timeout(next_failure)<br/>       time_of_failure = env.now<br/>       failures.append(time_of_failure)<br/>       failure_number += 1<br/>       print('failure %3d occurs at %.2f' % <br/>            (failure_number, env.now))</span><span id="23e8" class="nb lx it mx b gy ng nd l ne nf">       env.process(repairing(env, number_repair, <br/>                   failure_number, time_of_failure))</span><span id="4229" class="nb lx it mx b gy ng nd l ne nf">#...................................................................<br/>def repairing(env, number_repair, failure_number, time_of_failure):</span><span id="5f7c" class="nb lx it mx b gy ng nd l ne nf">    with repair_persons.request() as req:<br/>         print('%3d enters the queue at %.2f' % <br/>               (failure_number, env.now))<br/>         queue_in = env.now<br/>         length   = len(repair_persons.queue)<br/>         tme_in_queue.append(queue_in)<br/>         len_in_queue.append(length)</span><span id="8f25" class="nb lx it mx b gy ng nd l ne nf">         yield req<br/>         print('%3d leaves the queue at %.2f' % <br/>               (failure_number, env.now))<br/>         <br/>         queue_out = env.now<br/>         length    = len(repair_persons.queue)<br/>         tme_in_queue.append(queue_out)<br/>         len_in_queue.append(length)<br/>         <br/>         # uniform distribution for the repairing process<br/>         r_v = uniform.rvs(size=1)<br/>         print(r_v)</span><span id="4915" class="nb lx it mx b gy ng nd l ne nf">         for i,row in df_service.iterrows():<br/>             probab = df_service.loc[i, 'range']<br/>             if r_v &lt; probab:<br/>                time_service = df_service.loc[i, 'minutes']<br/>                break</span><span id="035d" class="nb lx it mx b gy ng nd l ne nf">         yield env.timeout(time_service)<br/>         print('%3d stays at service %.2f' %     <br/>               (failure_number,time_service))  </span><span id="3087" class="nb lx it mx b gy ng nd l ne nf">         time_repaired = env.now<br/>         repaired.append(time_repaired)</span><span id="074b" class="nb lx it mx b gy ng nd l ne nf">         time_out_system = time_repaired - time_of_failure<br/>         out_system.append(time_out_system)  </span><span id="6211" class="nb lx it mx b gy ng nd l ne nf">         time_in_queue = queue_out - queue_in<br/>         in_queue.append(time_in_queue)</span><span id="1fa2" class="nb lx it mx b gy ng nd l ne nf">         time_in_service = time_service<br/>         in_service.append(time_in_service)<br/>#..................................................................</span></pre><p id="ebab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们编写了两个函数(<em class="lv">def avg _ line(df _ length)</em>&amp;<em class="lv">def calc _ measures()</em>)，用于计算队列中故障机器的平均数量、队列中的平均延迟、机器被修复的平均时间以及机器离开系统的平均时间。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="ab4a" class="nb lx it mx b gy nc nd l ne nf">def avg_line(df_length):</span><span id="d1f8" class="nb lx it mx b gy ng nd l ne nf">   # finds the time weighted average of the queue length<br/>   # use the next row to figure out how long the queue was at that length</span><span id="a5d0" class="nb lx it mx b gy ng nd l ne nf">   df_length['delta_time'] = df_length['time'].shift(-1) <br/>                           - df_length['time']</span><span id="e502" class="nb lx it mx b gy ng nd l ne nf">   # drop the last row because it would have an infinite time span<br/>   df_length = df_length[0:-1]<br/>   avg = np.average(df_length['len'],<br/>                    weights = df_length['delta_time'])</span><span id="eb8f" class="nb lx it mx b gy ng nd l ne nf">   return avg<br/>#..................................................................</span><span id="e829" class="nb lx it mx b gy ng nd l ne nf">def calc_measures():</span><span id="1b14" class="nb lx it mx b gy ng nd l ne nf">    df3 = pd.DataFrame(tme_in_queue, columns = ['time'])<br/>    df4 = pd.DataFrame(len_in_queue, columns = ['len'])<br/>    global df_length<br/>    df_length = pd.concat([df3, df4], axis = 1)</span><span id="1e7e" class="nb lx it mx b gy ng nd l ne nf">    avg_length = avg_line(df_length)<br/>    avg_delay  = np.mean(in_queue)<br/>    avg_in_service = np.mean(in_service)<br/>    avg_out_system = np.mean(out_system)</span><span id="aa8d" class="nb lx it mx b gy ng nd l ne nf">    print('Number of Run: %1d' %(run+1))<br/>    print('The average delay in queue is %.2f'  % (avg_delay))<br/>    print('The average number of machines in queue is %.2f' % (avg_length))<br/>    print('The average time machines were being repaired is %.2f' % (avg_in_service))<br/>    print('The average time machines out of system is %.2f' % (avg_out_system))</span><span id="bc2b" class="nb lx it mx b gy ng nd l ne nf"># list and dataframe for final output</span><span id="5075" class="nb lx it mx b gy ng nd l ne nf">    listoflists = []<br/>    listoflists.append(round(avg_delay,2))<br/>    listoflists.append(avg_in_service)<br/>    listoflists.append(avg_out_system)<br/>    listoflists.append(avg_length)<br/>    df.loc[len(df)] = listoflists</span></pre><p id="197d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数<em class="lv"> calc_ICs() </em>允许我们使用<a class="ae ky" rel="noopener" target="_blank" href="/introduction-to-simulation-with-simpy-e27cd7b1ff47">文章5 </a>中描述的公式计算置信区间。我们使用了自由度为<em class="lv">k1</em>的T33<strong class="lb iu">的四个不同分位数</strong> <strong class="lb iu">，每个分位数对应一个特定的置信水平。当每个选择的性能测量的置信区间</strong> ( <em class="lv"> hwic </em>)的<strong class="lb iu">半宽度小于先前定义的绝对精度时，我们将布尔变量(<em class="lv"> l_end </em>)设置为真。</strong></p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="372f" class="nb lx it mx b gy nc nd l ne nf">def calc_ICs():</span><span id="89b4" class="nb lx it mx b gy ng nd l ne nf">  ## confidence intervals<br/>  ## define 3 global variables<br/>  global df_output, hwic, l_end</span><span id="2c53" class="nb lx it mx b gy ng nd l ne nf">  mean = round(df.mean(),2)<br/>  sigma= round(df.std(ddof=1),2)<br/>  dof  = len(df)-1</span><span id="40d3" class="nb lx it mx b gy ng nd l ne nf">  for i in range(4):<br/>      t_crit = np.abs(stats.t.ppf((1-confidence[i])/2,dof))<br/>      print(round(t_crit,3))</span><span id="fe5c" class="nb lx it mx b gy ng nd l ne nf">  inf, sup = (mean - sigma*t_crit/np.sqrt(len(df)), <br/>              mean + sigma*t_crit/np.sqrt(len(df)))</span><span id="8cc2" class="nb lx it mx b gy ng nd l ne nf">  inf = round(inf,2)<br/>  sup = round(sup,2)</span><span id="682d" class="nb lx it mx b gy ng nd l ne nf">  df_output = pd.concat([mean, sigma, inf, sup], axis=1)<br/>  print(df_output)</span><span id="4781" class="nb lx it mx b gy ng nd l ne nf">  hwic= (sup - inf)/2<br/>  if (hwic[0]&lt;=abs_err[0]) and (hwic[1]&lt;=abs_err[1]) <br/>      and (hwic[3]&lt;=abs_err[3]):<br/>      l_end = True</span><span id="7695" class="nb lx it mx b gy ng nd l ne nf">  print('')<br/>  print(round(hwic,2),abs_err, l_end )</span></pre><p id="cc6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数<em class="lv"> print_output() </em>打印输出数据表，显示每个绩效指标的样本均值、标准偏差以及CIs的<strong class="lb iu">下限和上限</strong>。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="beb0" class="nb lx it mx b gy nc nd l ne nf">def print_output():</span><span id="4318" class="nb lx it mx b gy ng nd l ne nf">   col_labels = ["Mean", "Std. Dev.", "Lower bound", "Upper Bound"]</span><span id="6654" class="nb lx it mx b gy ng nd l ne nf">   row_labels = ["Delay in Queue","In Repair",<br/>                 "Out of System","Machines in Queue"]</span><span id="1b30" class="nb lx it mx b gy ng nd l ne nf">   fig, ax = plt.subplots(1,1)<br/>   ax.axis('tight')<br/>   ax.axis('off') </span><span id="363e" class="nb lx it mx b gy ng nd l ne nf">   output_table = ax.table(cellText = df_output.values,<br/>                  colLabels = col_labels, rowLabels = row_labels,<br/>                  rowColours =["skyblue"]*5, colColours =["cyan"]*4,<br/>                  cellLoc='center', loc="center")<br/>   ax.set_title("Output data for %i independent runs" %(run+1),  <br/>                 fontsize=18, y= 0.8 , pad = 4)</span><span id="de2c" class="nb lx it mx b gy ng nd l ne nf">   output_table.auto_set_font_size(False)<br/>   output_table.set_fontsize(8)<br/>   plt.savefig(your_path +'output_perf_measures.png',<br/>               bbox_inches='tight', dpi=150)</span><span id="d83b" class="nb lx it mx b gy ng nd l ne nf">   plt.show()</span></pre><p id="bdf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们基于三个96.667%的IC(0.0333+0.0333+0.0333 = 0.1)，以及队列中平均延迟为3.0、机器被修理的平均时间为2.0以及队列中故障机器的平均数量为2.0的绝对精度(<em class="lv"> abs_err </em>，为模拟算法的中央核心编写了90%的总体置信水平(<em class="lv"> α </em>)。在10次初始运行后计算第一批ICs(如果运行&gt; = 10: )，即<em class="lv">。我们使用2345作为随机数序列的种子值。规定每次运行时间长度的预定义事件(<em class="lv"> SIM_TIME </em>)是30天* 24小时/天。</em></p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="c83b" class="nb lx it mx b gy nc nd l ne nf">#...................................................................confidence = [0.96667, 0.96667, 0.9, 0.96667]<br/>abs_err    = [3.00, 2.00, 3.00, 2.00]<br/>l_end = False</span><span id="f1b2" class="nb lx it mx b gy ng nd l ne nf">max_numb_of_runs = 1000<br/>numb_of_runs = max_numb_of_runs</span><span id="4eb9" class="nb lx it mx b gy ng nd l ne nf">seed_value = 2345<br/>prbnumgen  = RandomState(seed_value)</span><span id="a5d5" class="nb lx it mx b gy ng nd l ne nf">SIM_TIME = 30 * 24<br/>stop_arrivals = 720           ## for the verification step</span><span id="433f" class="nb lx it mx b gy ng nd l ne nf">global df<br/>column_labels = ["Delay in Queue","In Repair",<br/>                 "Out of System","Machines in Queue"]<br/>df = pd.DataFrame(columns=column_labels)</span><span id="72fb" class="nb lx it mx b gy ng nd l ne nf">for run in range(numb_of_runs):</span><span id="3637" class="nb lx it mx b gy ng nd l ne nf">    failures, repaired    = [],[]<br/>    in_queue, in_service  = [],[]<br/>    out_system = []<br/>    tme_in_queue, len_in_queue = [],[]</span><span id="9581" class="nb lx it mx b gy ng nd l ne nf">    #Set up the simulation environment<br/>    env = simpy.Environment()</span><span id="6bf1" class="nb lx it mx b gy ng nd l ne nf">    repair_persons=simpy.Resource(env,<br/>                 capacity = NUMBER_REPAIR_PERSONS)</span><span id="51bb" class="nb lx it mx b gy ng nd l ne nf">    env.process(machine_failure(env, repair_persons))<br/>    env.run(until = SIM_TIME)<br/>    calc_measures()</span><span id="8de8" class="nb lx it mx b gy ng nd l ne nf">    if run &gt;= 10:<br/>        calc_ICs()</span><span id="86f7" class="nb lx it mx b gy ng nd l ne nf">    if l_end == True:<br/>       print_output()<br/>       break</span></pre><h1 id="7bf6" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated"><strong class="ak">分析</strong></h1><p id="79b1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在第4篇文章中，我们描述了为一个特定的性能测量建立一个置信区间的固定样本量程序。在第5篇文章中，我们描述了一个为特定的性能度量建立置信区间的连续过程。在本文中，我们将前面的想法扩展到同时分析多个性能指标。</p><p id="4298" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">表1总结了输出数据:在489次独立运行后，我们可以以大约90%的置信度声称，队列中的平均延迟包含在96.667%置信区间[67.1，73.1]分钟内，平均修复时间包含在96.667%置信区间[36.26，36.52]分钟内，队列中故障机器的平均数量同时包含在96.667%置信区间[7.48，8.26]内。我们还计算了机器离开系统的平均时间(90%的置信度)。从概念上讲，这个值必须大约是平均排队延迟加上平均修复时间之和。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/b85c1871b62b9ccf37de7c88d5bbbdaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*xNdl9RZAAi34po6SpctmAw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表1，作者用Matplotlib做的。</p></figure><p id="8bd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">表2恢复了一个95%和两个97.5% IC的相同输出数据(0.05+0.025+0.025 = 0.1 =<em class="lv">α</em>)和相同的绝对误差。表格之间性能测量的微小差异完全是由于<strong class="lb iu">模拟输出的随机性。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/069a17e51cfaa9ed3e164246dfdb495e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*Nhwxbk1DGN60HlctxIbiFw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者用Matplotlib做的表2。</p></figure><p id="9dca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，良好的概率和统计知识对于每个离散事件模拟研究都是至关重要的。</p><p id="d3e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[1]: Law，A.M. &amp; Kelton，W.D. (2000)模拟建模与分析。波士顿麦格劳希尔公司。</p></div></div>    
</body>
</html>