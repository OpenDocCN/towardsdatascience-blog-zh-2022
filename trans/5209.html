<html>
<head>
<title>How To Read/Write DataFrames From/To SQL over HTTP with FastAPI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用 FastAPI 通过 HTTP 从/向 SQL 读取/写入数据帧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-read-write-dataframes-from-to-sql-over-http-with-fastapi-e48ab91e6a83#2022-11-22">https://towardsdatascience.com/how-to-read-write-dataframes-from-to-sql-over-http-with-fastapi-e48ab91e6a83#2022-11-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e12d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不到 10 分钟</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/42aa1662a4a66effba9767947f6e4494.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x60czqSrqkSsMmUBAspk9Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片感谢来自<a class="ae ky" href="https://unsplash.com/photos/GSiEeoHcNTQ" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>的<a class="ae ky" href="https://unsplash.com/@growtika" rel="noopener ugc nofollow" target="_blank"> growtika </a>。</p></figure><p id="62f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在工业中处理数据是一件痛苦的事情。这是因为数据可以分散在多个项目中，以不同的格式存储，并以不同的程度维护。通常，这导致不同的团队开发不同的内部工具来处理他们的数据。由于没有标准的读写数据的方法，整个事情变得一团糟。</p><p id="783a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个解决方案是开发数据摄取微服务。本质上，这些应用程序支持通过 HTTP 或 RPC 调用进行数据传输。他们试图提供一种统一的格式来读取和写入不同的数据源(例如 Google BigQuery、Postgres 等)。这个想法是，其他应用程序(比如仪表板)将使用数据摄取应用程序来加载数据。下图描述了一个简单的用例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/fd9b04224e24dcc6753d77db0693dba9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_KFFC2cwY8ortecic4AsrQ.png"/></div></div></figure><p id="2869" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，我将描述开发一个简单的数据摄取应用程序的过程，该应用程序使用 FastAPI 读取和写入任何 Postgres 数据库。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="f287" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">应用端点</h1><h2 id="391e" class="mv me it bd mf mw mx dn mj my mz dp mn li na nb mp lm nc nd mr lq ne nf mt ng bi translated">摄取数据</h2><p id="19a8" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">接收端点将用于读取数据。为此，我们需要连接到数据库的参数。这些将是<strong class="lb iu"> db_user </strong>、<strong class="lb iu"> db_password </strong>、<strong class="lb iu"> db_port </strong>、<strong class="lb iu"> db_name </strong>和<strong class="lb iu"> db_host </strong>。我们还需要一种查询数据库的方法，在这种情况下，它可以只是一个字符串<strong class="lb iu"> sql_query </strong>。</p><p id="30b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用<code class="fe nm nn no np b">fastapi</code>定义我们的应用程序，并开始构建端点:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="558c" class="nu me it np b be nv nw l nx ny">from fastapi import FastAPI<br/>from pydantic import BaseModel<br/><br/># initialise app<br/>app = FastAPI()<br/># pydantic class for collecting our parameters into a json object<br/>class IngestionParams(BaseModel):<br/>  sql_query: str<br/>  username: str<br/>  password: str<br/>  port: int<br/>  host: str<br/>  database_name: str<br/># define POST endpoint "ingest"<br/>@app.post("/ingest")<br/>def ingest(<br/>  ingestion_params: IngestionParams<br/>):<br/>  # retrieve ingestion params as dictionary<br/>  ingestion_params = ingestion_params.dict()<br/>  db_user = ingestion_params['username']<br/>  db_password = ingestion_params['password']<br/>  db_host = ingestion_params['host']<br/>  db_port = ingestion_params['port']<br/>  db_name = ingestion_params['database_name']<br/>  sql_query = ingestion_params['sql_query']</span></pre><blockquote class="nz oa ob"><p id="7639" class="kz la oc lb b lc ld ju le lf lg jx lh od lj lk ll oe ln lo lp of lr ls lt lu im bi translated"><strong class="lb iu">重要提示:</strong>根据 REST API 设计模式，在<strong class="lb iu"> get </strong>和<strong class="lb iu"> post </strong>请求之间应该有所区别。通常，<strong class="lb iu"> get </strong>用于读取数据，<strong class="lb iu"> post </strong>用于发送数据。然而，在这种情况下，最好使用<strong class="lb iu"> post </strong>来获取，因为:1)浏览器日志通常包含 URL 历史记录(这意味着敏感参数(如 DB 凭证)会被暴露)，2)URL 长度有限制[ <a class="ae ky" href="https://stackoverflow.com/questions/19637459/rest-api-using-post-instead-of-get" rel="noopener ugc nofollow" target="_blank"> 1 </a> ]</p></blockquote><p id="214d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们需要连接到我们的客户机并执行查询。为此，我们可以使用<code class="fe nm nn no np b">sqlalchemy</code>:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="a7f3" class="nu me it np b be nv nw l nx ny">import sqlalchemy as db<br/>import pandas as pd<br/><br/># connect to db<br/>db_uri = f'postgresql+psycopg2://{db_user}:{db_password}@{db_host}:{db_port}/{db_name}'<br/>engine = db.create_engine(db_uri)<br/>con = engine.connect()<br/># query db<br/>query_result = con.execute(sql_query)<br/>data = query_result.fetchall()<br/># convert to dataframe<br/>columns = query_result.keys()<br/>df = pd.DataFrame(data, columns=columns)</span></pre><p id="af56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">剩下的最后一件事是我们如何通过 HTTP 请求发送回数据帧。有多种方法可以做到这一点，但是为了保留 dtype，我们将 DataFrame 转换为一个 Parquet 文件，并使用内容类型<code class="fe nm nn no np b">application/octer-stream</code>将其作为二进制文件发送。</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="8cf0" class="nu me it np b be nv nw l nx ny"># added import<br/>from fastapi import Response<br/>def ingest(<br/>  response: Response, # add response parameter<br/>  ingestion_params: IngestionParams<br/>)<br/><br/>...<br/># return parquet file in Response object<br/>return Response(df.to_parquet(engine='pyarrow', index=False), media_type='application/octet-stream')</span></pre><h2 id="b91f" class="mv me it bd mf mw mx dn mj my mz dp mn li na nb mp lm nc nd mr lq ne nf mt ng bi translated">插入数据</h2><p id="d97f" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">为了插入数据，我们需要和以前一样的参数来连接数据库。然而，我们还需要<strong class="lb iu"> table_name </strong>、<strong class="lb iu"> dataset_name </strong>和<strong class="lb iu">conflict _ resolution _ strategy</strong>。</p><p id="05e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要一个<strong class="lb iu">文件</strong>参数来发送数据。这样，我们开始设计插入端点:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="120e" class="nu me it np b be nv nw l nx ny">from fastapi import File, UploadFile<br/>from pydantic import Json<br/># pydantic class for collecting our parameters into a json object<br/>class InsertionParams(BaseModel):<br/>  username: str<br/>  password: str<br/>  port: int = 5432<br/>  host: str<br/>  database_name: str<br/>  table_name: str<br/>  conflict_resolution_strategy: str = 'replace'  # default value<br/><br/># define POST endpoint "insert" using async<br/>@app.post("/insert")<br/>async def insert(<br/>  response: Response, # for returning the dataframe that we insert<br/>  insertion_params: Json[InsertionParams],<br/>  file: UploadFile = File(...)<br/>):<br/>  # retrieve insertion params as dictionary<br/>  insertion_params = insertion_params.dict()<br/>  db_user = insertion_params['username']<br/>  db_password = insertion_params['password']<br/>  db_host = insertion_params['host']<br/>  db_port = insertion_params['port']<br/>  db_name = insertion_params['database_name']<br/>  table_name = insertion_params['table_name']<br/>  conflict_resolution_strategy = insertion_params['conflict_resolution_strategy']<br/>  dataset_name = insertion_params.get('dataset_name', None)<br/>  content = await file.read()</span></pre><p id="48a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们想要设计我们的 API 来支持不同的文件类型作为输入。我们可以使用 file 对象的 content_type 属性来确定文件类型，然后适当地读取它。</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="2ab3" class="nu me it np b be nv nw l nx ny">import io<br/>with io.BytesIO(content) as data:<br/>    if 'csv' in file.content_type:<br/>        df = pd.read_csv(data)<br/>    if file.content_type == 'text/tab-separated-values':<br/>        df = pd.read_csv(data, delimiter='\t')<br/>    if file.content_type == 'application/octet-stream': # TODO can you have other 'octet-stream'?<br/>        df = pd.read_parquet(data, engine='pyarrow')</span></pre><p id="e0a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与之前类似，我们通过初始化客户端连接到数据库，然后使用来自<code class="fe nm nn no np b">pandas</code>的<code class="fe nm nn no np b">.to_sql</code>方法写入 postgres。但是，我们必须确保在使用该方法时传递数据类型，否则您的表将会被不正确地填充。因此:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="6f23" class="nu me it np b be nv nw l nx ny"># import types<br/>from sqlalchemy import INTEGER, FLOAT, TIMESTAMP, VARCHAR, BOOLEAN<br/>from pandas.api.types import is_datetime64tz_dtype<br/># connect to database<br/>... <br/>DTYPE_MAP = {<br/>        'int64': INTEGER,<br/>        'float64': FLOAT,<br/>        'datetime64[ns]': TIMESTAMP,<br/>        'datetime64[ns, UTC]': TIMESTAMP(timezone=True),<br/>        'bool': BOOLEAN,<br/>        'object': VARCHAR<br/>    }<br/>def _get_pg_datatypes(df):<br/>    dtypes = {}<br/>    for col, dtype in df.dtypes.items():<br/>        if is_datetime64tz_dtype(dtype):<br/>            dtypes[col] = DTYPE_MAP['datetime64[ns, UTC]']<br/>        else:<br/>            dtypes[col] = DTYPE_MAP[str(dtype)]<br/>    return dtypes<br/>dtypes = _get_pg_datatypes(df)<br/>df.to_sql(table_name, con, schema=dataset_name, if_exists=conflict_resolution_strategy, index=False, method='multi', dtype=dtypes)<br/>response.status_code = 201<br/>return "Created table"</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="ec7e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">运行应用程序</h1><p id="fa13" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">总的来说，代码应该如下所示:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="caf0" class="nu me it np b be nv nw l nx ny">from fastapi import FastAPI, Response, File, UploadFile<br/>from pydantic import BaseModel, Json<br/>import sqlalchemy as db<br/>import pandas as pd<br/>import io<br/>from sqlalchemy import INTEGER, FLOAT, TIMESTAMP, VARCHAR, BOOLEAN<br/>from pandas.api.types import is_datetime64tz_dtype<br/># initialise app<br/>app = FastAPI()<br/># pydantic class for collecting our parameters into a json object<br/>class IngestionParams(BaseModel):<br/>  sql_query: str<br/>  username: str<br/>  password: str<br/>  port: int<br/>  host: str<br/>  database_name: str<br/>class InsertionParams(BaseModel):<br/>  username: str<br/>  password: str<br/>  port: int = 5432<br/>  host: str<br/>  database_name: str<br/>  table_name: str<br/>  conflict_resolution_strategy: str = 'replace'  # default value<br/>def _connect_to_db(user, password, host, port, name):<br/>    db_uri = f'postgresql+psycopg2://{user}:{password}@{host}:{port}/{name}'<br/>    engine = db.create_engine(db_uri)<br/>    con = engine.connect()<br/>    return con<br/># define POST endpoint "ingest"<br/>@app.post("/ingest")<br/>def ingest(<br/>  response: Response,<br/>  ingestion_params: IngestionParams<br/>):<br/>  # retrieve ingestion params as dictionary<br/>  ingestion_params = ingestion_params.dict()<br/>  db_user = ingestion_params['username']<br/>  db_password = ingestion_params['password']<br/>  db_host = ingestion_params['host']<br/>  db_port = ingestion_params['port']<br/>  db_name = ingestion_params['database_name']<br/>  sql_query = ingestion_params['sql_query']<br/>  # connect to db<br/>  con = _connect_to_db(db_user, db_password, db_host, db_port, db_name)<br/>  # query db<br/>  query_result = con.execute(sql_query)<br/>  data = query_result.fetchall()<br/>  # convert to dataframe<br/>  columns = query_result.keys()<br/>  df = pd.DataFrame(data, columns=columns)<br/>  # return parquet file in Response object<br/>  return Response(df.to_parquet(engine='pyarrow', index=False), media_type='application/octet-stream')<br/><br/># define POST endpoint "insert" using async<br/>@app.post("/insert")<br/>async def insert(<br/>  response: Response, # for returning the dataframe that we insert<br/>  insertion_params: Json[InsertionParams],<br/>  file: UploadFile = File(...)<br/>):<br/>  # retrieve insertion params as dictionary<br/>  insertion_params = insertion_params.dict()<br/>  db_user = insertion_params['username']<br/>  db_password = insertion_params['password']<br/>  db_host = insertion_params['host']<br/>  db_port = insertion_params['port']<br/>  db_name = insertion_params['database_name']<br/>  table_name = insertion_params['table_name']<br/>  conflict_resolution_strategy = insertion_params['conflict_resolution_strategy']<br/>  dataset_name = insertion_params.get('dataset_name', None)<br/>  content = await file.read()<br/><br/>  with io.BytesIO(content) as data:<br/>      if 'csv' in file.content_type:<br/>          df = pd.read_csv(data)<br/>      if file.content_type == 'text/tab-separated-values':<br/>          df = pd.read_csv(data, delimiter='\t')<br/>      if file.content_type == 'application/octet-stream':  # TODO can you have other 'octet-stream'?<br/>          df = pd.read_parquet(data, engine='pyarrow')<br/>  DTYPE_MAP = {<br/>        'int64': INTEGER,<br/>        'float64': FLOAT,<br/>        'datetime64[ns]': TIMESTAMP,<br/>        'datetime64[ns, UTC]': TIMESTAMP(timezone=True),<br/>        'bool': BOOLEAN,<br/>        'object': VARCHAR<br/>    }<br/>  def _get_pg_datatypes(df):<br/>    dtypes = {}<br/>    for col, dtype in df.dtypes.items():<br/>        if is_datetime64tz_dtype(dtype):<br/>            dtypes[col] = DTYPE_MAP['datetime64[ns, UTC]']<br/>        else:<br/>            dtypes[col] = DTYPE_MAP[str(dtype)]<br/>    return dtypes<br/>  dtypes = _get_pg_datatypes(df)<br/>  # connect to db<br/>  con = _connect_to_db(db_user, db_password, db_host, db_port, db_name)<br/>  df.to_sql(table_name, con, schema=dataset_name, if_exists=conflict_resolution_strategy, index=False, method='multi', dtype=dtypes)<br/>  response.status_code = 201<br/>  return "Created table"</span></pre><blockquote class="nz oa ob"><p id="3364" class="kz la oc lb b lc ld ju le lf lg jx lh od lj lk ll oe ln lo lp of lr ls lt lu im bi translated">请注意，我们已经清理了一些东西！</p></blockquote><p id="ecf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以将其保存到一个名为<code class="fe nm nn no np b">main.py</code>的文件中，然后在终端中运行以下命令:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="beef" class="nu me it np b be nv nw l nx ny">uvicorn main:app --reload</span></pre><p id="91f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您应该可以通过访问以下 url 在浏览器中看到该应用程序:</p><blockquote class="og"><p id="6fe1" class="oh oi it bd oj ok ol om on oo op lu dk translated"><code class="fe nm nn no np b">localhost:8000/docs</code></p></blockquote><figure class="or os ot ou ov kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/1ba5c2aa5dee431ae86572985fd67cc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Ej973l92T8_Q7MOTSK6qg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这是您应该在 localhost:8000/docs 上看到的内容</p></figure><h2 id="1c66" class="mv me it bd mf mw mx dn mj my mz dp mn li na nb mp lm nc nd mr lq ne nf mt ng bi translated">设置</h2><p id="fcd7" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">为了测试我们的应用程序是否正常工作，我们需要一个 postgres 实例来测试。出于本文的目的，我们将使用 Docker Postgres 实例(尽管您可以随意使用)。</p><p id="32ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，您需要安装 docker。然后，您可以在终端中运行以下命令:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="6983" class="nu me it np b be nv nw l nx ny">docker run -p 5432:5432 -e POSTGRES_PASSWORD=postgres -d postgres</span></pre><p id="1cb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您现在应该有一个本地运行的 postgres 实例，并在 5432 端口上有一个连接。您可以使用数据库查看软件来查看。在我的例子中，我使用 DBeaver [ <a class="ae ky" href="https://dbeaver.io/" rel="noopener ugc nofollow" target="_blank"> 2 </a> ]。</p><p id="3dc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据库的连接参数是:</p><ul class=""><li id="4996" class="ow ox it lb b lc ld lf lg li oy lm oz lq pa lu pb pc pd pe bi translated"><strong class="lb iu">用户名:</strong> postgres</li><li id="2f3b" class="ow ox it lb b lc pf lf pg li ph lm pi lq pj lu pb pc pd pe bi translated"><strong class="lb iu">主机:</strong>本地主机</li><li id="9ebc" class="ow ox it lb b lc pf lf pg li ph lm pi lq pj lu pb pc pd pe bi translated">港口: 5432</li><li id="229c" class="ow ox it lb b lc pf lf pg li ph lm pi lq pj lu pb pc pd pe bi translated"><strong class="lb iu">密码:</strong> postgres</li><li id="15eb" class="ow ox it lb b lc pf lf pg li ph lm pi lq pj lu pb pc pd pe bi translated"><strong class="lb iu">数据库名称:</strong> postgres</li></ul><h2 id="21d3" class="mv me it bd mf mw mx dn mj my mz dp mn li na nb mp lm nc nd mr lq ne nf mt ng bi translated">使用请求读取文件</h2><p id="a62f" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">使用 UI 来读/写数据是相对直观的。当您想从 Python 内部调用端点时，这就不那么重要了。为此，我们使用<code class="fe nm nn no np b">requests</code>模块。</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="9534" class="nu me it np b be nv nw l nx ny">import io<br/>import pandas as pd<br/>import requests<br/>BASE_URL = 'http://localhost:8000' # url for app comprised of host and port<br/># headers for request<br/>headers = {<br/>        'Content-Type': 'application/json',<br/>        'Accept': 'application/octet-stream'<br/>}<br/># function for validating successful request<br/>def _is_status_code_valid(status_code):<br/>    if str(status_code).startswith('2'):<br/>        return True<br/>def read_data(<br/>        ingestion_param,<br/>):<br/>    #<br/>    url = f'{BASE_URL}/ingest'<br/>    <br/>    resp = requests.post(url, json=ingestion_param, headers=headers)<br/>    status_code = resp.status_code<br/>    if _is_status_code_valid(status_code):<br/>        df = pd.read_parquet(io.BytesIO(resp.content), engine='pyarrow')<br/>        return df, status_code</span></pre><p id="b768" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的关键方面是，我们以字节为单位读取响应，但我们需要数据作为数据帧。因此，在将响应内容作为 parquet 读取之前，我们将它转换为 BytesIO 对象。我们保存 dtype，因为 parquet 文件包含表 dtype 信息。</p><h2 id="0355" class="mv me it bd mf mw mx dn mj my mz dp mn li na nb mp lm nc nd mr lq ne nf mt ng bi translated">使用请求发送文件</h2><p id="2986" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">发送文件比阅读文件稍微复杂一些。这是因为 post 请求的请求参数并不简单，我们必须想办法将数据帧转换成可接受的格式。</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="a4cf" class="nu me it np b be nv nw l nx ny">import io<br/>import json<br/>import requests<br/><br/>BASE_URL = 'http://localhost:8000' # url for app comprised of host and port<br/>def write_data(<br/>        database_name,<br/>        table_name,<br/>        database_type='pg',<br/>        df=pd.DataFrame(),<br/>        content_type='csv',<br/>        conflict_resolution_strategy='fail',<br/>        username='postgres',<br/>        password='postgres',<br/>        port=5432,<br/>        host='localhost',<br/>   ):<br/>    url = f'{BASE_URL}/insert'<br/>      <br/>    # in principle, it is possible to add converters for any content_type<br/>    if content_type == 'parquet':<br/>        memory_buffer = io.BytesIO()<br/>        df.to_parquet(<br/>            memory_buffer,<br/>            engine='pyarrow'<br/>        )<br/>        memory_buffer.seek(0)<br/>    # need to encode parameters as json string<br/>    data = {<br/>        'insertion_params': json.dumps(dict(<br/>        username=username,<br/>        password=password,<br/>        port=port,<br/>        database_name=database_name,<br/>        table_name=table_name,<br/>        conflict_resolution_strategy=conflict_resolution_strategy,<br/>        host=host<br/>    ))<br/>    }<br/>    # need to send files separately<br/>    files = {<br/>        'file': ('Test', memory_buffer, 'application/octet-stream')<br/>    }<br/>    resp = requests.post(url, data=data, files=files)<br/>    return resp.text, resp.status_code</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="4a27" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结束语</h1><p id="fefc" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">在本文中，我们使用 FastAPI for Postgres 设计了一个数据摄取应用程序。以下是关键要点的快速总结:</p><ul class=""><li id="f59d" class="ow ox it lb b lc ld lf lg li oy lm oz lq pa lu pb pc pd pe bi translated">数据摄取应用程序比在单独的项目中构建摄取功能更可取，因为它是标准化的，更易于维护，并能适应变化</li><li id="3b73" class="ow ox it lb b lc pf lf pg li ph lm pi lq pj lu pb pc pd pe bi translated">将数据帧转换成 Parquet 对于通过 HTTP 发送它们很有用，因为我们保留了数据类型信息</li><li id="27dd" class="ow ox it lb b lc pf lf pg li ph lm pi lq pj lu pb pc pd pe bi translated">目前的应用程序可以很容易地扩展到支持其他数据源，如 BigQuery，Google Drive 等…</li></ul><h2 id="3381" class="mv me it bd mf mw mx dn mj my mz dp mn li na nb mp lm nc nd mr lq ne nf mt ng bi translated">限制</h2><ul class=""><li id="8cdb" class="ow ox it lb b lc nh lf ni li pk lm pl lq pm lu pb pc pd pe bi translated">仅支持 postgres</li><li id="acdd" class="ow ox it lb b lc pf lf pg li ph lm pi lq pj lu pb pc pd pe bi translated">目前，使用<code class="fe nm nn no np b">.to_sql</code>的方法不支持上插功能</li></ul><p id="b1ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文使用的全部代码可以在下面的存储库中找到:<a class="ae ky" href="https://github.com/namiyousef/in-n-out" rel="noopener ugc nofollow" target="_blank">https://github.com/namiyousef/in-n-out</a>。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="a096" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">引用表</h1><p id="3605" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">[1]<a class="ae ky" href="https://stackoverflow.com/questions/19637459/rest-api-using-post-instead-of-get" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/19637459/rest-API-using-post-inst-of-get</a></p><p id="7bf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2]<a class="ae ky" href="https://dbeaver.io/" rel="noopener ugc nofollow" target="_blank">https://dbeaver.io/</a></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="ae15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oc">以上所有图片和代码均为作者所有，除非另有说明</em></p></div></div>    
</body>
</html>