<html>
<head>
<title>Introduction to Simulation with SimPy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SimPy仿真简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-simulation-with-simpy-8e7187c6eb82#2022-04-19">https://towardsdatascience.com/introduction-to-simulation-with-simpy-8e7187c6eb82#2022-04-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8901" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">第4部分:终止模拟的输出数据分析</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/24e7a0e58b1a6fb6aa7aec66610914bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hyrYBT1wdw_wJDN6"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@jonasmorgner?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔纳斯·莫格纳</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3aff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文是与使用SimPy的<strong class="lb iu">离散事件模拟(DES) </strong>技术应用相关的系列文章的第四篇。</p><p id="c0fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/towards-data-science/introduction-to-simulation-with-simpy-b04c2ddf1900" rel="noopener">第1篇:</a>我们介绍了DES的一些基本概念，描述了一些在仿真应用中经常用到的概率分布函数。</p><p id="fa43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/towards-data-science/introduction-to-simulation-with-simpy-322606d4ba0c" rel="noopener">第2篇</a>:我们描述了表征<strong class="lb iu">排队系统</strong>(等待线系统)的组件及其最常见的<strong class="lb iu">性能度量。</strong></p><p id="c483" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/towards-data-science/introduction-to-simulation-with-simpy-8d744c82dc80" rel="noopener">第3条:</a>我们描述了用于分类排队模型的<strong class="lb iu"> Kendall符号</strong>，并使用SimPy来模拟工厂运营中机器的随机故障，以帮助管理层决定减少机器停工时间的修理工数量。</p><p id="cfd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上一篇文章中，我们指出了用Simpy进行的许多模拟研究中的两个常见错误:1)任意选择最终模拟时间；2)进行单次模拟运行，并使用输出作为最终结果。</p><p id="9b60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将开始分析模拟研究的输出数据，以指出避免犯这些概念性错误的方法。</p><h1 id="adb3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">模拟类型</strong></h1><p id="1eef" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">关于<strong class="lb iu">输出数据分析</strong>，我们区分两种类型的模拟:1)终止模拟；2)非终止模拟。</p><p id="3960" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<strong class="lb iu">终止模拟</strong>是一个有预定义事件的模拟，该事件规定了每次运行的长度。该终端事件可能是与时间相关的<strong class="lb iu">；例如:一家零售商店，营业时间为上午9点至下午5点。我们希望通过运行模拟研究来评估一些绩效指标，因为终止模拟的最终事件是8小时的模拟时间已经过去，商店是空的[1]。终端事件也可以是与系统被清空或清空的预定义状态相关的<strong class="lb iu">；</strong>例如:一家制造商收到一份订单，要求生产500件特定设计的产品。他决定模拟几种制造配置，以选择一种能保证他以最低成本满足最后期限的配置。在这种情况下，终端事件是已经制造了500件[1]。</strong></p><p id="d6d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开始模拟运行之前，必须完全定义终端事件，其发生时间可以是随机变量。系统的初始条件也必须事先明确定义，因为它们通常会影响运行结束时计算的性能指标。</p><p id="6971" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，<strong class="lb iu">非终止模拟</strong>是一种没有指定运行长度的预定义事件的模拟。从概念上讲，模拟理论上可以无限期地进行下去；在实践中，分析师确定运行模型的合适时间长度。无终止模拟的一个经典例子是一家制造公司，它有24/7的活动和相当可预测的需求。我们希望估计一些稳态性能指标，以便更好地理解这种复杂系统的动态特性。</p><p id="a949" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将模拟研究分类为终点或非终点<strong class="lb iu">的决定不仅取决于系统的性质，还取决于研究的目标</strong>。如果目标是确定被研究系统的<strong class="lb iu">短期动态行为</strong>，我们将开发一个终止模拟。另一方面，如果目标是确定其<strong class="lb iu">稳态行为</strong>，我们将开发一个非终止模拟。</p><p id="16cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在模拟运行的早期阶段，性能指标在稳定之前会有明显的波动。这段时间称为<strong class="lb iu">瞬态</strong>，终端模拟的输出数据可能包括瞬态的大量值。这就是为什么<strong class="lb iu">在终止模拟中非常仔细地选择初始条件是至关重要的</strong>。在非终止模拟(非常长的运行)中，瞬态的影响被稀释，并且通常在计算性能度量时被消除。</p><h1 id="8c17" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">终止模拟的输出数据分析</strong></h1><p id="97fc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">模拟是基于计算机的统计抽样实验[1]。因此，我们需要统计技术来分析模拟实验。</p><p id="99bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们借助<strong class="lb iu">中心极限定理</strong> ( <strong class="lb iu"> C.L.T. </strong>)来处理样本数据。它指出样本均值的分布将接近正态分布，均值等于总体均值，方差等于<em class="ms"> S2/n，</em>其中<em class="ms"> S2 </em>是总体方差，<em class="ms"> n </em>是数据中的观察次数。</p><p id="78e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们转到<strong class="lb iu">置信区间(CI)。</strong>我们需要计算模拟输出数据的置信区间，因为样本均值总会有一些误差。基于中心极限定理，置信区间表示这种误差的大小。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/7ed456e63ecacf5d2e0e99aa975c2f8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*rBmjDiputLmA878ixBWFGQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1，资料来源:<a class="ae ky" href="http://mlwiki.org/index.php/Confidence_Intervals_for_Means" rel="noopener ugc nofollow" target="_blank">http://mlwiki.org/index.php/Confidence_Intervals_for_Means</a></p></figure><p id="75c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用前面的公式，我们至少需要30次观察。t分布(图2)用于较小的样本量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/34fed7326d82569b9e6e855aca8fa3e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*D0eynzyp0BbMkQXtUaShrQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图2，来源:<a class="ae ky" href="http://mlwiki.org/index.php/Confidence_Intervals_for_Means" rel="noopener ugc nofollow" target="_blank">http://mlwiki.org/index.php/Confidence_Intervals_for_Means</a></p></figure><p id="1c50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果我们想模拟一个被归类为终结系统的系统，我们必须:</p><p id="92e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">a)定义终端事件；</p><p id="1c01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">b)确定初始条件；</p><p id="e9f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">c)进行<em class="ms"> n </em>独立复制(<strong class="lb iu">运行</strong>)。每次运行的独立性通过<strong class="lb iu">在每次运行中使用不同的随机数流</strong>来实现。每次复制必须以相同的初始条件开始；</p><p id="4a01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">d)计算每个性能测量的点估计和置信区间。</p><p id="c2d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们和SimPy一起做。</p><h1 id="9bd9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">用SimPy进行模拟</strong></h1><p id="1879" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">一个小作坊专门生产艺术品。到货量呈泊松分布，平均每10小时有1个工作。该车间有两个工作站，每台机器配备一名操作员，所有工作都需要在这两种机器上进行处理。假设每个工作站的加工时间分别以7和5为均值呈指数分布。这家商店按照先进先出的原则安排工作。</p><p id="a706" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">公司的所有者计划进行某些改进以增加公司的产量。作为第一步，他们决定对当前系统进行模拟研究，获得一些性能度量，然后将它们与提议的改进进行比较。</p><p id="bb19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">获取当前系统性能度量的代码如下:</p><p id="5cdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们导入Pandas作为<em class="ms"> pd，</em> Numpy作为<em class="ms"> np </em>，Simpy和<em class="ms"> scipy </em>用于统计计算和生成具有指数分布的浮动随机数。最后，我们导入matplotlib作为<em class="ms"> plt </em>用于制图。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="2497" class="na lw it mw b gy nb nc l nd ne">import pandas as pd<br/>import numpy  as np<br/>from numpy.random import RandomState</span><span id="a03b" class="na lw it mw b gy nf nc l nd ne">import simpy</span><span id="cc19" class="na lw it mw b gy nf nc l nd ne">from scipy import stats<br/>from scipy.stats import expon</span><span id="7a42" class="na lw it mw b gy nf nc l nd ne">import matplotlib<br/>import matplotlib.pyplot as plt</span></pre><p id="3b13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">包括一个初始化模块，其中我们指出了工件到达率、表征加工时间的指数分布的参数以及工作站的数量。我们创建了一个数据框架，用于存储中间结果。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="54d8" class="na lw it mw b gy nb nc l nd ne">JOBS_ARRIVAL_RATE  = 1/10</span><span id="32ba" class="na lw it mw b gy nf nc l nd ne">WORK_STATION1_MEAN = 7<br/>WORK_STATION2_MEAN = 5</span><span id="f169" class="na lw it mw b gy nf nc l nd ne">NUMBER_WORK_STATION1 = 1<br/>NUMBER_WORK_STATION2 = 1</span><span id="6259" class="na lw it mw b gy nf nc l nd ne">column_labels = ["Delay WK1","Delay WK2",<br/>                 "Util. WK1","Util. WK2", "Avg Length WK1"]<br/>df = pd.DataFrame(columns=column_labels)</span></pre><p id="2207" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们编写了两个<a class="ae ky" href="https://docs.python.org/3/reference/expressions.html#yieldexpr" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">生成器函数</strong></a>(<em class="ms">generate _ jobs</em>&amp;<em class="ms">process _ jobs)</em>来模拟作业的到达和处理:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="d2d7" class="na lw it mw b gy nb nc l nd ne">def generate_jobs(env, arrival_stream, arrival_rate, <br/>                  inital_delay = 0,<br/>                  stoptime = simpy.core.Infinity, <br/>                  prng = RandomState(0)):</span><span id="be5f" class="na lw it mw b gy nf nc l nd ne">    number_of_job = 0<br/>    yield env.timeout(inital_delay)     #Yield the initial delay</span><span id="9f30" class="na lw it mw b gy nf nc l nd ne">    while (env.now &lt;stoptime):<br/>        inter_arrival_time = prng.exponential(1.0 / arrival_rate)<br/>        los_station1 = prng.exponential(WORK_STATION1_MEAN)<br/>        los_station2 = prng.exponential(WORK_STATION2_MEAN)</span><span id="1f7b" class="na lw it mw b gy nf nc l nd ne">        number_of_job += 1<br/>        jobpr = process_jobs(env, <br/>                            'Job number:{}'.format(number_of_job), <br/>                             number_of_job,los_st1 = los_station1,<br/>                             los_st2 = los_station2)</span><span id="0c0d" class="na lw it mw b gy nf nc l nd ne">        env.process(jobpr)<br/>        yield env.timeout(inter_arrival_time)</span><span id="cdf5" class="na lw it mw b gy nf nc l nd ne">#.........................................................</span><span id="1e67" class="na lw it mw b gy nf nc l nd ne">def process_jobs(env, number_of_job, job_number, los_st1, los_st2):</span><span id="f925" class="na lw it mw b gy nf nc l nd ne">    # First Work Station<br/>    print("{} is scheduled for workstation 1 at hour   {:.4f}".format(number_of_job, env.now))</span><span id="dd52" class="na lw it mw b gy nf nc l nd ne">    workstation1_schedule_list.append(job_number)<br/>    time_workstation1_schedule_list.append(env.now)<br/>    jobwk1_request_time = env.now<br/>    jobwk1_request = work_station1.request()<br/>    workstation1_length_list.append(len(work_station1.queue))<br/>    workstation1_timeth_list.append(env.now)</span><span id="95f6" class="na lw it mw b gy nf nc l nd ne">    yield jobwk1_request</span><span id="e16b" class="na lw it mw b gy nf nc l nd ne">    print("{} enters to workstation 1 at hour  {:.4f}".format(job_number, env.now))</span><span id="9b21" class="na lw it mw b gy nf nc l nd ne">    workstation1_operation_list.append(job_number)<br/>    time_workstation1_operation_list.append(env.now)<br/>    workstation1_length_list.append(len(work_station1.queue))<br/>    workstation1_timeth_list.append(env.now)</span><span id="97f0" class="na lw it mw b gy nf nc l nd ne">    if (env.now &gt; jobwk1_request_time):<br/>        print("{} has to wait {:.4f}hours".format(job_number, env.now - jobwk1_request_time))</span><span id="1497" class="na lw it mw b gy nf nc l nd ne">    yield env.timeout(los_st1)<br/>    work_station1.release(jobwk1_request)<br/>    workstation1_release_list.append(job_number)<br/>    time_workstation1_release_list.append(env.now)</span><span id="bf55" class="na lw it mw b gy nf nc l nd ne">    # Second Work Station<br/>    print("{} is scheduled for workstation 2 at hour {:.4f}".format(job_number, env.now))</span><span id="a530" class="na lw it mw b gy nf nc l nd ne">    workstation2_schedule_list.append(job_number)<br/>    time_workstation2_schedule_list.append(env.now)<br/>    jobwk2_request_time = env.now<br/>    jobwk2_request = work_station2.request()</span><span id="79ef" class="na lw it mw b gy nf nc l nd ne">    yield jobwk2_request</span><span id="24b4" class="na lw it mw b gy nf nc l nd ne">    print("{} enters to workstation 2 at hour  {:.4f}".format(job_number, env.now))</span><span id="0ada" class="na lw it mw b gy nf nc l nd ne">    workstation2_operation_list.append(job_number)<br/>    time_workstation2_operation_list.append(env.now)</span><span id="8ee5" class="na lw it mw b gy nf nc l nd ne">    if (env.now &gt; jobwk2_request_time): <br/>        print("{} has to wait {:.4f} hours".format(job_number, env.now-jobwk2_request_time))</span><span id="0e56" class="na lw it mw b gy nf nc l nd ne">    yield env.timeout(los_st2)<br/>    work_station2.release(jobwk2_request)<br/>    workstation2_release_list.append(job_number)<br/>    time_workstation2_release_list.append(env.now)</span></pre><p id="a8bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，描述用于计算队列中的平均延迟、服务器的利用率和工作站1的时间加权长度的函数(<em class="ms"> calc_measures() </em>)。我们将每次运行的结果附加到函数代码最后一行的数据帧中。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="21d0" class="na lw it mw b gy nb nc l nd ne">def calc_measures():</span><span id="4304" class="na lw it mw b gy nf nc l nd ne">    # Construct dataframes prior to calculations<br/>    df_wk1_schdl['Job Number']   = workstation1_schedule_list<br/>    df_wk1_schdl['Job Time Sc1'] = time_workstation1_schedule_list<br/>    df_wk2_schdl['Job Number']   = workstation2_schedule_list<br/>    df_wk2_schdl['Job Time Sc2'] = time_workstation2_schedule_list <br/>    df_wk1_opert['Job Number']   = workstation1_operation_list<br/>    df_wk1_opert['Job Time Op1'] = time_workstation1_operation_list<br/>    df_wk2_opert['Job Number']   = workstation2_operation_list<br/>    df_wk2_opert['Job Time Op2'] = time_workstation2_operation_list<br/>    df_wk1_reles['Job Number']   = workstation1_release_list<br/>    df_wk1_reles['Job Time Rl1'] = time_workstation1_release_list<br/>    df_wk2_reles['Job Number']   = workstation2_release_list<br/>    df_wk2_reles['Job Time Rl2'] = time_workstation2_release_list </span><span id="6605" class="na lw it mw b gy nf nc l nd ne">    df_merge = pd.merge(df_wk1_schdl, df_wk1_opert, <br/>                        on='Job Number', how='left')<br/>    df_merge = pd.merge(df_merge, df_wk1_reles, <br/>                        on='Job Number', how='left')<br/>    df_merge = pd.merge(df_merge, df_wk2_schdl,<br/>                        on='Job Number', how='left')<br/>    df_merge = pd.merge(df_merge, df_wk2_opert, <br/>                        on='Job Number', how='left')<br/>    df_merge = pd.merge(df_merge, df_wk2_reles, <br/>                        on='Job Number', how='left')</span><span id="e7c3" class="na lw it mw b gy nf nc l nd ne">#.......................................<br/>    # Computing measures of performance<br/>    # Average Delay in Queues</span><span id="c608" class="na lw it mw b gy nf nc l nd ne">    df_merge['Delay Wk1'] = df_merge['Job Time Op1'] - df_merge['Job Time Sc1']<br/>    df_merge['Delay Wk2'] = df_merge['Job Time Op2'] - df_merge['Job Time Sc2']</span><span id="3266" class="na lw it mw b gy nf nc l nd ne">    mean_delay_wk1 = df_merge['Delay Wk1'].mean()<br/>    mean_delay_wk2 = df_merge['Delay Wk2'].mean()<br/>    print('  ')<br/>    print('Measures of Performance for Run: %1d' %(run))<br/>    print('The average delay in queue for workstation 1 is %.2f hours' % (mean_delay_wk1))<br/>    print('The average delay in queue for workstation 2 is %.2f hours' % (mean_delay_wk2))</span><span id="a131" class="na lw it mw b gy nf nc l nd ne">#..........................................<br/>    # Utilization of the Servers<br/>    for i in range(0, len(df_merge)-1):<br/>         workstation1_utilization_list.append(df_merge['Job Time Op1'][i+1] - df_merge['Job Time Rl1'][i])<br/>         workstation2_utilization_list.append(df_merge['Job Time Op2'][i+1] - df_merge['Job Time Rl2'][i])</span><span id="5ec3" class="na lw it mw b gy nf nc l nd ne">    wk1_sum_idle = sum(workstation1_utilization_list)<br/>    wk2_sum_idle = sum(workstation2_utilization_list)</span><span id="9481" class="na lw it mw b gy nf nc l nd ne">    utilization_wk1 = round((1 - wk1_sum_idle / stop_arrivals) * 100, 2)<br/>    utilization_wk2 = round((1 - wk2_sum_idle / stop_arrivals) * 100, 2)</span><span id="d287" class="na lw it mw b gy nf nc l nd ne">    print('The utlization of the workstation 1 is %.2f%%'  % (utilization_wk1))<br/>    print('The utlization of the workstation 2 is %.2f%%'  % (utilization_wk2))</span><span id="5e58" class="na lw it mw b gy nf nc l nd ne">#...............................................<br/>    # Time weighted average of the queue length </span><span id="35ea" class="na lw it mw b gy nf nc l nd ne">    df_l1 = pd.DataFrame(workstation1_length_list, columns = ['len'])<br/>    df_t1 = pd.DataFrame(workstation1_timeth_list, columns = ['time'])<br/>    df_qlength1 = pd.concat([df_l1, df_t1], axis = 1)</span><span id="5d6b" class="na lw it mw b gy nf nc l nd ne">    # use the next row to figure out how long the queue <br/>      was at that length<br/>    df_qlength1['delta_time'] = df_qlength1['time'].shift(-1) - df_qlength1['time']</span><span id="a3fe" class="na lw it mw b gy nf nc l nd ne">    # drop the last row because it would have an infinite time span<br/>    df_qlength1 = df_qlength1[0:-1]</span><span id="79f8" class="na lw it mw b gy nf nc l nd ne">    len_avg_wk1 = np.average(df_qlength1['len'], <br/>                             weights = df_qlength1['delta_time'])</span><span id="aab2" class="na lw it mw b gy nf nc l nd ne">    print('The time weighted length of the workstation 1 is %.2f'  % (len_avg_wk1))</span><span id="b05b" class="na lw it mw b gy nf nc l nd ne">#.....................................................<br/>    # list and dataframe for final output</span><span id="8113" class="na lw it mw b gy nf nc l nd ne">    listoflists = []<br/>    listoflists.append(round(mean_delay_wk1,2))<br/>    listoflists.append(round(mean_delay_wk2,2))<br/>    listoflists.append(utilization_wk1)<br/>    listoflists.append(utilization_wk2)<br/>    listoflists.append(round(len_avg_wk1,2))</span><span id="2246" class="na lw it mw b gy nf nc l nd ne">    df.loc[len(df)] = listoflists</span></pre><p id="ad6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们构建了两个表:1)表示每个独立运行的性能测量的表；2)显示每个绩效测量的样本均值、样本标准偏差以及置信区间的<strong class="lb iu">下限和上限</strong>的汇总表:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="0333" class="na lw it mw b gy nb nc l nd ne">def print_output():<br/>    # measures of performance for 10 independent runs<br/>    row_labels = ['Run' + str(i+1) for i in range(10)]<br/>    <br/>    fig, ax = plt.subplots(1,1)<br/>    ax.axis('tight')<br/>    ax.axis('off')</span><span id="57cc" class="na lw it mw b gy nf nc l nd ne">    runs_table = ax.table(cellText = df.values,<br/>                          colLabels = df.columns, <br/>                          rowLabels = row_labels,<br/>                          rowColours =["skyblue"]*numb_of_runs,<br/>                          colColours =["cyan"]*5,<br/>                          cellLoc ='center', loc ="center")</span><span id="5124" class="na lw it mw b gy nf nc l nd ne">    ax.set_title("Measures of Performance", <br/>                 fontsize=18, y= 0.8 , pad = 4)</span><span id="e36f" class="na lw it mw b gy nf nc l nd ne">    runs_table.auto_set_font_size(False)<br/>    runs_table.set_fontsize(8)<br/>    plt.savefig(your_path +'twoWKs_perf_measures.png',<br/>                bbox_inches='tight', dpi=150)</span><span id="15e4" class="na lw it mw b gy nf nc l nd ne">    plt.show()<br/>#.....................................................<br/>    ## confidence intervals<br/>    mean = round(df.mean(),2)  <br/>    sigma= round(df.std(ddof=1),2)<br/>    dof = len(df) -1 <br/>    confidence = 0.90         ## Level of confidence</span><span id="30e3" class="na lw it mw b gy nf nc l nd ne">    t_crit = np.abs(stats.t.ppf((1-confidence)/2,dof))<br/>    inf, sup = (mean-sigma*t_crit/np.sqrt(len(df)),<br/>                mean+sigma*t_crit/np.sqrt(len(df)))<br/>    inf = round(inf,2)<br/>    sup = round(sup,2)</span><span id="f4bc" class="na lw it mw b gy nf nc l nd ne">    df_output = pd.concat([mean, sigma, inf, sup], axis=1)</span><span id="2696" class="na lw it mw b gy nf nc l nd ne">    row_labels = ["Delay WK1","Delay WK2","Util. WK1",<br/>                  "Util. WK2", "Avg Length WK1"]<br/>    col_labels = ["Mean", "Std. Dev.", "Lower bound", "Upper Bound"]</span><span id="cd8e" class="na lw it mw b gy nf nc l nd ne">    fig, ax = plt.subplots(1,1)<br/>    ax.axis('tight')<br/>    ax.axis('off')</span><span id="0f1f" class="na lw it mw b gy nf nc l nd ne">    output_table = ax.table(cellText = df_output.values,<br/>                            colLabels = col_labels, <br/>                            rowLabels = row_labels,<br/>                            rowColours =["skyblue"]*5, <br/>                            colColours =["cyan"]*4,<br/>                            cellLoc ='center', loc ="center")</span><span id="adfb" class="na lw it mw b gy nf nc l nd ne">    ax.set_title("Output Data", fontsize=18, y= 0.8 , pad = 4)</span><span id="cfd4" class="na lw it mw b gy nf nc l nd ne">    output_table.auto_set_font_size(False)<br/>    output_table.set_fontsize(8)<br/>    plt.savefig(your_path +'twoWKs_output_perf_measures.png',<br/>                bbox_inches='tight', dpi=150)<br/>    plt.show()</span></pre><p id="0436" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SimPy算法的核心是:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="946a" class="na lw it mw b gy nb nc l nd ne">numb_of_runs = 10<br/>seed_value = 2345<br/>prbnumgen  = RandomState(seed_value)</span><span id="9217" class="na lw it mw b gy nf nc l nd ne">hours_run_sim = 30 * 24<br/>stop_arrivals = 400            ## for the verification step</span><span id="07d8" class="na lw it mw b gy nf nc l nd ne">for run in range(10):</span><span id="4694" class="na lw it mw b gy nf nc l nd ne">    workstation1_schedule_list, workstation2_schedule_list = [],[]<br/>    workstation1_operation_list,workstation2_operation_list= [],[]<br/>    workstation1_release_list,  workstation2_release_list  = [],[]</span><span id="9a7b" class="na lw it mw b gy nf nc l nd ne">    time_workstation1_schedule_list, time_workstation2_schedule_list  = [],[]    <br/>   time_workstation1_operation_list,time_workstation2_operation_list = [],[]<br/>    time_workstation1_release_list,  time_workstation2_release_list   = [],[]</span><span id="9cff" class="na lw it mw b gy nf nc l nd ne">    workstation1_length_list, workstation1_utilization_list = [],[]<br/>    workstation1_timeth_list, workstation2_utilization_list = [],[]</span><span id="87f3" class="na lw it mw b gy nf nc l nd ne">    mean_delay_wk1,  mean_delay_wk2  = [],[]<br/>    utilization_wk1, utilization_wk2 = [],[]<br/>    len_avg_wk1,     len_avg_wk2     = [],[]</span><span id="7011" class="na lw it mw b gy nf nc l nd ne">    listoflists = []</span><span id="878f" class="na lw it mw b gy nf nc l nd ne">    df_wk1_schdl = pd.DataFrame(columns = ['Job Number', 'Job Time Sc1'])<br/>    df_wk2_schdl = pd.DataFrame(columns = ['Job Number', 'Job Time Sc2'])<br/>    df_wk1_opert = pd.DataFrame(columns = ['Job Number', 'Job Time Op1'])<br/>    df_wk2_opert = pd.DataFrame(columns = ['Job Number', 'Job Time Op2'])<br/>    df_wk1_reles = pd.DataFrame(columns = ['Job Number', 'Job Time Rl1'])<br/>    df_wk2_reles = pd.DataFrame(columns = ['Job Number', 'Job Time Rl2'])</span><span id="adb7" class="na lw it mw b gy nf nc l nd ne">    #Set up the simulation environment<br/>    env = simpy.Environment()</span><span id="3856" class="na lw it mw b gy nf nc l nd ne">    work_station1 = simpy.Resource(env, NUMBER_WORK_STATION1)<br/>    work_station2 = simpy.Resource(env, NUMBER_WORK_STATION2)</span><span id="8985" class="na lw it mw b gy nf nc l nd ne">    env.process(generate_jobs(env, "Type1", JOBS_ARRIVAL_RATE,0,<br/>                              stop_arrivals, prbnumgen)) <br/>    env.run(until = hours_run_sim)</span><span id="8bdd" class="na lw it mw b gy nf nc l nd ne">    calc_measures()</span><span id="869f" class="na lw it mw b gy nf nc l nd ne">print_output()</span></pre><h1 id="6e5d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">分析</strong></h1><p id="3b07" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">公司所有者对系统的短期行为感兴趣。商店有一个<strong class="lb iu">月可预测需求</strong>，所以他们决定用30*24 = <strong class="lb iu"> 720小时的模拟时间作为终端事件。</strong></p><p id="655c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于初始条件，模型开始时两个工作站都处于空闲状态，但有一个任务准备开始(<em class="ms"> inital_delay = 0) </em>。</p><p id="cf2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该研究涉及指数到达间隔时间和指数工作站操作时间<em class="ms"> (inter_arrival_time，los_station1，los_station2 </em>)。</p><p id="c528" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦确定了到达和服务的概率分布并建立了初始条件，就必须执行数据验证过程来检查模型编码是否正确。模拟研究中的这一重要步骤称为<strong class="lb iu">模型验证</strong>。为此，我们执行较短的测试运行(<em class="ms">stop _ arrives = 400</em>)，使用大量<em class="ms"> Print </em>指令来跟踪系统中的作业流程。通过修改输入参数中的一些值并检查输出是否相应地变化，也可以方便地进行测试。模型验证步骤的目标是在继续生产运行之前检测编程错误。</p><p id="2eca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在模型验证步骤之后，我们必须继续进行<strong class="lb iu">模型验证</strong>步骤。这个问题将在后续文章中描述。</p><p id="3f33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们进行了10次独立的重复试验。如前所述，每次运行的独立性通过在每次运行中使用不同的随机数流来实现。<strong class="lb iu">我们将循环 </strong>的<em class="ms">外的种子值设置在算法的中央核心，以实现跨运行的统计独立性。</em></p><p id="f895" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生产运行将值720 (30*24)设置为变量<em class="ms">hours _ run _ sim&amp;stop _ arrives。</em></p><p id="eee6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">表1显示了两个工作站的平均排队延迟值、它们忙碌的时间百分比以及工作站1前面的平均时间长度。显然，可以看出<strong class="lb iu">模拟输出</strong>的随机性质以及计算每个性能测量的置信区间的需要。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/67e79016a99b3940397042a916cbf5f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*5nL7BChyxtEqZz3HgoPm7Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表1，由作者用Matplotlib制作</p></figure><p id="dd85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">表2显示了每个性能度量的样本均值、样本标准差以及置信区间的下限和上限。我们可以以大约90%的置信度宣称，工作站1中的延迟包含在区间[8.24，11.9]小时内，工作站2中的延迟包含在区间[2.26，5.88]小时内。此外，我们声称(具有大约90%的置信度)工作站1在60.67%到69.29%的操作时间内是忙碌的，工作站2在43.85%到51.55%的操作时间内是忙碌的。最后，工作站1前面的队列长度总是围绕值1振荡。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/32605cf1f7aad4c349677af294d9256b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*wQdFuiknd22Wdf_3WjLM7g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表2，由作者用Matplotlib制作</p></figure><p id="999e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前面描述的计算表2所示置信区间的程序称为<strong class="lb iu">固定样本量程序</strong>。该程序包括预先确定要进行的重复次数。它有一个严重的缺点:我们无法控制置信区间的宽度。业主认为延迟WK1，Util。WK1和Util。WK2 <strong class="lb iu"> IC宽度</strong>过大。他们更希望规模小一些，这样可以更准确地评估提议的变更的影响。</p><p id="e905" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一篇文章中，我们将描述一个程序，以确定获得具有预定义精度水平的置信区间所需的重复次数。我们还将指出基于特定的性能度量来比较两个系统的过程。</p><p id="6922" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[1]: Law，A.M .和Kelton，W.D. (2000)模拟建模与分析。波士顿麦格劳希尔公司。</p></div></div>    
</body>
</html>