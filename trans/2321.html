<html>
<head>
<title>Cython for absolute beginners: 30x faster code in two simple steps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向绝对初学者的Cython:通过简单的两步将代码速度提高30倍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/cython-for-absolute-beginners-30x-faster-code-in-two-simple-steps-bbb6c10d06ad#2022-05-22">https://towardsdatascience.com/cython-for-absolute-beginners-30x-faster-code-in-two-simple-steps-bbb6c10d06ad#2022-05-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b18a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为速度惊人的应用程序轻松编译Python代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/feee58cf58ab0b86ac966dce5d1d473a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JpKZoj5rRdgGEFud"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">让我们加速我们的代码(图片由<a class="ae ky" href="https://unsplash.com/@abedismail" rel="noopener ugc nofollow" target="_blank"> Abed Ismail </a>在<a class="ae ky" href="https://unsplash.com/photos/pBUMdQ3Q_C8" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上提供)</p></figure><p id="d70d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python非常容易使用；清晰的语法、解释器和鸭式输入让你可以快速开发。但也有一些缺点:如果你不必遵守严格的语法，那么Python必须做一些额外的工作来让你的代码运行，导致一些函数执行非常慢，因为它必须一次又一次地做所有这些检查。</p><blockquote class="lv"><p id="e294" class="lw lx it bd ly lz ma mb mc md me lu dk translated">将Python开发的便捷性和速度与C语言的速度结合起来:两全其美</p></blockquote><p id="923f" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">在本文中，我们将从一个普通的Python项目中提取一个“慢”函数，并使其速度提高30倍。我们通过使用一个名为Cython的包来做到这一点，该包会将我们的Python代码转换为一段经过编译的超高速C代码，我们可以再次直接将其导入到我们的项目中。</p><p id="f728" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个名为<strong class="lb iu"> CythonBuilder </strong>的包<strong class="lb iu">会在仅仅两步</strong>中为我们<strong class="lb iu">自动生成Python代码</strong>。使用CythonBuilder，我们将Cythonize下面定义的示例项目中的一个函数。我们来编码吧！</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="ad05" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">但是首先..</h1><p id="7e93" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">对于那些不熟悉Cython和CythonBuilder的人，我们将回答一些探索性的问题。然后我们将定义我们的示例项目。我们将使用命令行，如果您不熟悉，请仔细阅读:</p><div class="no np gp gr nq nr"><a rel="noopener follow" target="_blank" href="/terminals-consoles-command-line-for-absolute-beginners-de7853c7f5e8"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">面向绝对初学者的终端/控制台/命令行</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">命令行使用简介</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">towardsdatascience.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of ks nr"/></div></div></a></div><h2 id="52f0" class="og ms it bd mt oh oi dn mx oj ok dp nb li ol om nd lm on oo nf lq op oq nh or bi translated">什么是Cython /为什么使用Cython？</h2><p id="e925" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">Cython将Python代码转换成包含CPU指令的文件。Python解释器不再需要对这个文件进行任何检查；它可以运行它。这导致了性能的显著提高。查看下面的文章，了解关于Python如何工作以及它与C语言相比如何的更多详细信息:</p><div class="no np gp gr nq nr"><a rel="noopener follow" target="_blank" href="/why-is-python-so-slow-and-how-to-speed-it-up-485b5a84154e"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">Python为什么这么慢，如何加速</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">看看Python的瓶颈在哪里</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">towardsdatascience.com</p></div></div><div class="oa l"><div class="os l oc od oe oa of ks nr"/></div></div></a></div><p id="931e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你把一段代码变成Cythonize时，你就给你的代码添加了额外的信息；定义类型，例如，然后编译代码，这样Python就不必执行额外的检查。同样，查看上面的文章可以获得更深入的分析。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="e513" class="og ms it bd mt oh oi dn mx oj ok dp nb li ol om nd lm on oo nf lq op oq nh or bi translated">Cython是如何工作的</h2><p id="50ae" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">就像你在一个<code class="fe ot ou ov ow b">.py</code>文件中写Python代码一样，你在一个<code class="fe ot ou ov ow b">.pyx </code>文件中写Cython代码。然后，Cython会将这些文件转换为. so文件或. pyd文件(取决于您的操作系统)。这些文件可以再次直接导入到python项目中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/a189ea2414ed78bf32ca8714d5ce5b3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*uuCWlMCB3KLBjUm9r-IiOw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Cythonizing一个pyx文件(作者图片)</p></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="04f2" class="og ms it bd mt oh oi dn mx oj ok dp nb li ol om nd lm on oo nf lq op oq nh or bi translated">所有代码都可以通过编译来优化吗？</h2><p id="f49a" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">并不是所有的代码都是编译好的。例如，在C包中等待API的响应并不会更快。简而言之:我们专注于需要大量计算的CPU密集型任务。在下面的文章中阅读更多，以获得更清晰的区别。</p><div class="no np gp gr nq nr"><a rel="noopener follow" target="_blank" href="/multi-tasking-in-python-speed-up-your-program-10x-by-executing-things-simultaneously-4b4fc7ee71e"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">Python中的多任务处理:通过同时执行，将程序速度提高10倍</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">应用线程和进程加速代码的分步指南</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">towardsdatascience.com</p></div></div><div class="oa l"><div class="oy l oc od oe oa of ks nr"/></div></div></a></div></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="ebed" class="og ms it bd mt oh oi dn mx oj ok dp nb li ol om nd lm on oo nf lq op oq nh or bi translated">CythonBuilder —自动化Cythonizing</h2><p id="44d2" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">你是如何将你的<code class="fe ot ou ov ow b">.pyx</code>文件有效化的？这个过程相当复杂；您必须创建一个<code class="fe ot ou ov ow b">setup.py</code>，定义所有的包，然后运行一些命令(参见下面的文章)。相反，我们将使用<a class="ae ky" href="https://pypi.org/project/cythonbuilder/" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">CythonBuilder</strong></a><strong class="lb iu">:</strong>一个<strong class="lb iu">为我们自动化一切的包</strong>:在一个命令中构建你的<code class="fe ot ou ov ow b">.pyx</code>文件！</p><div class="no np gp gr nq nr"><a rel="noopener follow" target="_blank" href="/getting-started-with-cython-how-to-perform-1-7-billion-calculations-per-second-in-python-b83374cfcf77"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">Cython入门:如何在Python中每秒执行超过17亿次计算</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">结合Python的易用性和C的速度</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">towardsdatascience.com</p></div></div><div class="oa l"><div class="oz l oc od oe oa of ks nr"/></div></div></a></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7c2d9fcaeac0c35abeca7964411c94e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VRlReq8TVagcGlN0"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">你的代码经过了两步(图片由<a class="ae ky" href="https://unsplash.com/@vr2ysl" rel="noopener ugc nofollow" target="_blank"> Sammy Wong </a>上的<a class="ae ky" href="https://unsplash.com/photos/lFMIQ6AiiW8" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><h1 id="94ce" class="mr ms it bd mt mu pa mw mx my pb na nb jz pc ka nd kc pd kd nf kf pe kg nh ni bi translated">示例项目</h1><p id="b7ec" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们的项目包含一个函数，出于某种原因，计算一些素数。这个函数需要大量的计算，我们可以优化。<br/>首先安装带有<code class="fe ot ou ov ow b">pip install cythonbuilder</code>的cythonbuilder，然后定义常规的质数计算函数</p><h2 id="e41b" class="og ms it bd mt oh oi dn mx oj ok dp nb li ol om nd lm on oo nf lq op oq nh or bi translated">准备-普通Python质数计算函数</h2><p id="99f0" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">这个函数非常简单:我们将传递一个数给这个函数，它返回0和目标数之间的质数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pf pg l"/></div></figure><p id="6016" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数是纯Python的。它可以再优化一点，但目标是有一个执行大量计算的函数。让我们来看看这个函数需要多长时间来找到0到100.000之间的素数:</p><pre class="kj kk kl km gt ph ow pi pj aw pk bi"><span id="d57c" class="og ms it ow b gy pl pm l pn po">PurePython: 29.4883812 seconds</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="0d91" class="og ms it bd mt oh oi dn mx oj ok dp nb li ol om nd lm on oo nf lq op oq nh or bi translated">第一步。—糖化</h2><p id="2942" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在这一部分，我们将介绍Cython。我们将复制我们函数的代码，并将其保存到一个名为<code class="fe ot ou ov ow b">cy_count_primes.pyx</code>的文件中(注意<code class="fe ot ou ov ow b">.pyx</code>)。</p><p id="0b3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来我们<code class="fe ot ou ov ow b">cd projectfolder</code>并调用<code class="fe ot ou ov ow b">cythonbuilder build</code>。这将在projectfolder中找到所有的pyx文件并编译它们。结果是Windows上的一个<code class="fe ot ou ov ow b">.pyd</code>文件或Linux上的一个<code class="fe ot ou ov ow b">.so</code>文件。这个文件是我们的Python函数的编译版本，我们可以将它直接导入到我们的项目中:</p><pre class="kj kk kl km gt ph ow pi pj aw pk bi"><span id="5068" class="og ms it ow b gy pl pm l pn po">from someplace.cy_count_primes import count_primes<br/>print(count_primes(100_000))</span></pre><p id="9b97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看它的表现如何:</p><pre class="kj kk kl km gt ph ow pi pj aw pk bi"><span id="f086" class="og ms it ow b gy pl pm l pn po">PurePython: 29.4883812 seconds<br/>CyPython  : 14.0540504 seconds (2.0982 faster than PurePython</span></pre><p id="9fe7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">已经快了两倍多！请注意，我们实际上没有对Python代码做任何更改。让我们优化代码。</p><p id="2fe9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="pp">接口:<br/>您会注意到，即使是您的IDE也可以检查导入的文件。即使文件被编译，它也知道哪些函数存在，哪些参数是必需的。这是可能的，因为CythonBuilder也构建。pyi文件；这些接口文件为ide提供了关于pyd文件的信息。</em></p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="adbd" class="og ms it bd mt oh oi dn mx oj ok dp nb li ol om nd lm on oo nf lq op oq nh or bi translated">步骤2 —添加类型</h2><p id="5a3d" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在这一部分中，我们将类型添加到<code class="fe ot ou ov ow b">cy_count_primes.pyx</code>文件中，然后再次构建它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pf pg l"/></div></figure><p id="8e18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，我们用<code class="fe ot ou ov ow b">cpdef</code>(c和p(ython)都可以访问)定义了我们的函数，告诉它返回一个<code class="fe ot ou ov ow b">int</code>(在<code class="fe ot ou ov ow b">count_primes</code>之前)，并且它期望一个<code class="fe ot ou ov ow b">limit</code>参数是一个<code class="fe ot ou ov ow b">int</code>。</p><p id="ee93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，在第2、3和4行，我们为循环中使用的一些变量定义了类型；没什么特别的。</p><p id="88ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以再次<code class="fe ot ou ov ow b">cythonbuilder build</code>并再次计时我们的函数:</p><pre class="kj kk kl km gt ph ow pi pj aw pk bi"><span id="09ba" class="og ms it ow b gy pl pm l pn po">PurePython: 29.4883812 seconds<br/>CyPython  : 14.0540504 seconds (2.0982 faster than PurePython<br/>Cy+Types  :  1.1600970 seconds (25.419 faster than PurePython</span></pre><p id="6882" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个非常令人印象深刻的加速！<br/>速度如此之快的原因不在本文的讨论范围之内，但这与Python在内存中存储变量的方式有关。与C相比，它的效率相当低，所以我们的C编译代码可以运行得更快。查看本文 深入探究Python和C之间的不同之处(以及为什么C要快得多)。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="3a12" class="og ms it bd mt oh oi dn mx oj ok dp nb li ol om nd lm on oo nf lq op oq nh or bi translated">附加—编译选项</h2><p id="ca69" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们已经将代码执行速度提高了25倍，但我认为我们还可以再提高一点。我们将用编译器指令来做这件事。这些需要一点解释:</p><p id="62a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为Python是一种解释语言，所以它必须在运行时执行大量检查，例如，如果你的程序被零除。在编译语言C中，这些检查发生在编译时；编译时会发现这些错误。好处是你的程序可以更有效地运行，因为它不需要在运行时执行这些检查。</p><p id="ba57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用编译器指令，我们可以禁用所有这些检查，但前提是我们知道我们不需要它们。在下面的例子中，我们用4个装饰器升级了我们之前的代码:</p><ul class=""><li id="3cd8" class="pq pr it lb b lc ld lf lg li ps lm pt lq pu lu pv pw px py bi translated">阻止对ZeroDivisionError的检查</li><li id="25ac" class="pq pr it lb b lc pz lf qa li qb lm qc lq qd lu pv pw px py bi translated">阻止对IndexErrors的检查(当列表只包含3个项目时调用myList[5])</li><li id="0c82" class="pq pr it lb b lc pz lf qa li qb lm qc lq qd lu pv pw px py bi translated">阻止对isNone的检查</li><li id="32bf" class="pq pr it lb b lc pz lf qa li qb lm qc lq qd lu pv pw px py bi translated">防止绕回；防止调用相对于末尾的列表(如mylist[-5])所需的额外检查</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pf pg l"/></div></figure><p id="f03f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们再次重新构建我们的代码(<code class="fe ot ou ov ow b">cythonbuilder build</code>)，看看跳过所有这些检查能节省多少时间</p><pre class="kj kk kl km gt ph ow pi pj aw pk bi"><span id="48f3" class="og ms it ow b gy pl pm l pn po">PurePython: 29.4883812 seconds<br/>CyPython  : 14.0540504 seconds (2.0982 faster than PurePython<br/>Cy+Types  :  1.1600970 seconds (25.419 faster than PurePython<br/>Cy+Options:  0.9562186 seconds (30.838 faster than PurePython</span></pre><p id="2c4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们又缩短了0.2秒！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qe"><img src="../Images/0f293495bc4900341cf8bc06aa5587ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cefQ7eRlhK7RD_k5EINkrg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">最终结果(越低越好)(图片由作者提供)</p></figure><h2 id="1fd4" class="og ms it bd mt oh oi dn mx oj ok dp nb li ol om nd lm on oo nf lq op oq nh or bi translated">甚至更快？</h2><p id="4fd9" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">通过利用我们的多核处理器，我们有可能进一步加速我们的代码。查看下面的文章，了解如何在Python程序中应用多处理和线程。另请查看<strong class="lb iu"> </strong> <a class="ae ky" href="https://mikehuls.medium.com/getting-started-with-cython-how-to-perform-1-7-billion-calculations-per-second-in-python-b83374cfcf77" rel="noopener"> <strong class="lb iu">这篇文章</strong>向您展示了如何对Cython代码</a>进行多进程处理，并解释了Cython的注释文件:图形化概述了您的代码的哪些部分可以进一步优化。非常方便！</p><div class="no np gp gr nq nr"><a rel="noopener follow" target="_blank" href="/advanced-multi-tasking-in-python-applying-and-benchmarking-threadpools-and-processpools-90452e0f7d40"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">Python中的高级多任务处理:应用和基准测试线程池和进程池在6…</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">安全轻松地对您的代码应用多任务处理</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">towardsdatascience.com</p></div></div><div class="oa l"><div class="qf l oc od oe oa of ks nr"/></div></div></a></div><h1 id="5157" class="mr ms it bd mt mu pa mw mx my pb na nb jz pc ka nd kc pd kd nf kf pe kg nh ni bi translated">结论</h1><p id="1d64" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">CythonBuilder使得使用Cython加速我们的Python代码变得很容易。<br/>正如我们所看到的，复制我们的Python代码并构建会使执行速度翻倍！最大的速度提升是通过增加类型；相对于普通Python，速度提高了25倍。</p><p id="ae08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望一切都像我希望的那样清楚，但如果不是这样，请让我知道我能做些什么来进一步澄清。同时，请查看我的关于各种编程相关主题的其他文章:</p><ul class=""><li id="247e" class="pq pr it lb b lc ld lf lg li ps lm pt lq pu lu pv pw px py bi translated"><a class="ae ky" href="https://mikehuls.medium.com/why-is-python-so-slow-and-how-to-speed-it-up-485b5a84154e" rel="noopener">Python为什么这么慢，如何加速</a></li><li id="3e31" class="pq pr it lb b lc pz lf qa li qb lm qc lq qd lu pv pw px py bi translated"><a class="ae ky" href="https://mikehuls.medium.com/git-for-absolute-beginners-understanding-git-with-the-help-of-a-video-game-88826054459a" rel="noopener"> Git绝对初学者:借助视频游戏理解Git</a></li><li id="661e" class="pq pr it lb b lc pz lf qa li qb lm qc lq qd lu pv pw px py bi translated"><a class="ae ky" href="https://mikehuls.medium.com/docker-for-absolute-beginners-the-difference-between-an-image-and-a-container-7e07d4c0c01d" rel="noopener"> Docker:图像和容器的区别</a></li><li id="4cd7" class="pq pr it lb b lc pz lf qa li qb lm qc lq qd lu pv pw px py bi translated"><a class="ae ky" href="https://mikehuls.medium.com/docker-for-absolute-beginners-what-is-docker-and-how-to-use-it-examples-3d3b11efd830" rel="noopener"> Docker对于绝对初学者——什么是Docker以及如何使用它(+示例)</a></li><li id="0016" class="pq pr it lb b lc pz lf qa li qb lm qc lq qd lu pv pw px py bi translated"><a class="ae ky" href="https://mikehuls.medium.com/virtual-environments-for-absolute-beginners-what-is-it-and-how-to-create-one-examples-a48da8982d4b" rel="noopener">绝对初学者的虚拟环境——什么是虚拟环境，如何创建虚拟环境(+示例</a>)</li><li id="6e13" class="pq pr it lb b lc pz lf qa li qb lm qc lq qd lu pv pw px py bi translated"><a class="ae ky" href="https://mikehuls.medium.com/create-and-publish-your-own-python-package-ea45bee41cdc" rel="noopener">创建并发布自己的Python包</a></li><li id="78b9" class="pq pr it lb b lc pz lf qa li qb lm qc lq qd lu pv pw px py bi translated"><a class="ae ky" href="https://mikehuls.medium.com/create-your-custom-python-package-that-you-can-pip-install-from-your-git-repository-f90465867893" rel="noopener">创建你定制的私有Python包，你可以从你的Git库PIP安装这个包</a></li><li id="6ab8" class="pq pr it lb b lc pz lf qa li qb lm qc lq qd lu pv pw px py bi translated"><a class="ae ky" href="https://mikehuls.medium.com/create-a-fast-auto-documented-maintainable-and-easy-to-use-python-api-in-5-lines-of-code-with-4e574c00f70e" rel="noopener">用FastAPI用5行代码创建一个快速自动记录、可维护且易于使用的Python API</a></li><li id="3e9c" class="pq pr it lb b lc pz lf qa li qb lm qc lq qd lu pv pw px py bi translated"><a class="ae ky" href="https://mikehuls.medium.com/dramatically-improve-your-database-inserts-with-a-simple-upgrade-6dfa672f1424" rel="noopener">通过简单的升级大大提高您的数据库插入速度</a></li></ul><p id="ba6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p><p id="5fa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">—迈克</p><p id="c759" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="pp">又及:喜欢我正在做的事吗？</em> <a class="ae ky" href="https://mikehuls.medium.com/membership" rel="noopener"> <em class="pp">跟我来！</em>T9】</a></p><div class="no np gp gr nq nr"><a href="https://mikehuls.medium.com/membership" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">通过我的推荐链接加入媒体-迈克·赫斯</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">mikehuls.medium.com</p></div></div><div class="oa l"><div class="qg l oc od oe oa of ks nr"/></div></div></a></div></div></div>    
</body>
</html>