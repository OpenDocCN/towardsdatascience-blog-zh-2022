<html>
<head>
<title>Are you using Cloud Functions for event based processing?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您是否使用云函数进行基于事件的处理？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/are-you-using-cloud-functions-for-event-based-processing-adb3ef35aba6#2022-04-05">https://towardsdatascience.com/are-you-using-cloud-functions-for-event-based-processing-adb3ef35aba6#2022-04-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4ddf" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">阿帕奇气流的强大替代变化</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4da47af515d1c68b9050c5903abb00a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dI1_4wEoQHNSz1MJ"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">贾斯汀·威尔肯斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="1d5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一名数据或软件工程师，我们经常需要在事件发生时触发一些代码的运行。这被称为基于<strong class="ky ir">事件的处理</strong>。一个非常常见的事件是在数据库中插入一些数据。另一个流行的事件是文件到达服务器或存储服务。</p><p id="5f57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章主要是为了展示为什么我认为Apache Airflow是在<a class="ae kv" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌云平台</a> (GCP)中基于事件处理的最佳工具。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="c16e" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated"><strong class="ak">任务:在文件到达时删除它们</strong></h2><p id="57a7" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">假设我们有一个<a class="ae kv" href="https://cloud.google.com/storage" rel="noopener ugc nofollow" target="_blank">云存储桶</a>，合作伙伴或客户在其中上传文件。我们的任务是近乎实时地处理这些文件，即尽可能快地处理。为了简单起见，这里的处理只是删除文件。</p><p id="020a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在GCP，传统的做法是使用云功能(后台功能)</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="746a" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated"><strong class="ak">使用云功能删除到达的文件</strong></h2><p id="8980" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">云函数(在撰写本文时只有第一代函数)本身支持观察一个定义的桶，并在文件上传时触发。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/a38ddb9c7c3525969de21cd530a9cac5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0GpHU93vFsUWVCx7jnGG5A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">当文件到达桶中时删除它们，按作者排列图像</p></figure><p id="4343" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我曾经大量使用这个特性，如果用例符合以下4个约束，它会工作得很好。实际上:</p><ul class=""><li id="da94" class="my mz iq ky b kz la lc ld lf na lj nb ln nc lr nd ne nf ng bi translated"><strong class="ky ir">约束1 </strong>:不能看一个以上的桶。你将不得不定义许多函数，也就是你想观察的每个桶的一个函数。</li><li id="b10b" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated"><strong class="ky ir">约束二</strong>:不能只看一个桶里面的文件夹。对于bucket的每个文件夹中的每个文件上载，该函数必然会触发。</li><li id="19ce" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated"><strong class="ky ir">约束3 </strong> : <strong class="ky ir"> </strong>你不能看一个位于不同GCP项目的桶，而不是一个拥有云功能的桶。</li><li id="4284" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">约束4 :你的处理过程不应该超过几分钟(写这篇文章的时候是9分钟)。</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="1bc1" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated"><strong class="ak"> Apache Airflow是云功能的强大替代方案</strong></h2><p id="a32b" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">Apache Airflow是一个复杂的开源作业调度器和协调器，在GCP通过T2的Cloud Composer提供。它提供了一种特殊类型的工作，称为传感器，能够监视服务器、数据库、队列等，等待某个事件发生。</p><p id="1d4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我们的特定场景，即监控文件上传的云存储桶，我们需要一个传感器作业，它会不时地检查这个桶，然后在有文件上传时发出警报。气流2中有两个传感器可以完成这一任务:</p><ol class=""><li id="a28f" class="my mz iq ky b kz la lc ld lf na lj nb ln nc lr nm ne nf ng bi translated"><a class="ae kv" href="https://github.com/apache/airflow/blob/main/airflow/providers/google/cloud/sensors/gcs.py#L34" rel="noopener ugc nofollow" target="_blank">gcsobjectexistencesisensor</a>:它监视一个云存储桶进行文件上传。如果你说云功能也可以做到这一点，你几乎是对的。实际上，云函数也可以做同样的事情，只要桶和云函数位于同一个GCP项目中(约束3)。</li><li id="7a64" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nm ne nf ng bi translated"><a class="ae kv" href="https://github.com/apache/airflow/blob/4ffd4f09532fceb67675fce4c1f5cd383eff992e/airflow/providers/google/cloud/sensors/gcs.py#L165" rel="noopener ugc nofollow" target="_blank">gcsobjectswithprefixexintensesensor</a>:它监视一个云存储文件夹进行文件上传(约束2)。在这里，我们可以开始看到Apache Airflow的威力，因为它允许您做您无法使用云功能做的事情。</li></ol><p id="9882" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">气流真正赢得这场战斗(也赢得这场战争)的地方在于，它赋予我们轻松构建自己的定制传感器的能力。例如，我们可以编写一个能够监控许多桶的传感器(约束1)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/0a4bf3fee39f3c0694b7fe8a3ffb0a84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ov5TVt_fCnziiX4405ccQA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">删除文件，因为他们到达许多桶，由作者图像</p></figure><p id="cd3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">构建多个云存储桶传感器</strong></p><p id="138d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我说过，编写我们自己的策划传感器很容易，这不是谎言。这里我只需要创建一个继承自<a class="ae kv" href="https://github.com/apache/airflow/blob/main/airflow/sensors/base.py#L76" rel="noopener ugc nofollow" target="_blank">基本传感器类</a>的类，并覆盖2个方法:</p><ul class=""><li id="7539" class="my mz iq ky b kz la lc ld lf na lj nb ln nc lr nd ne nf ng bi translated"><em class="no">戳</em>:这是你告诉Airflow你想监控一个文件上传的云存储桶列表的地方。注意该方法返回一个布尔值，表明传感器正在监视的事件是否已经发生。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">覆盖基本传感器的戳方法，图片由作者提供</p></figure><ul class=""><li id="4975" class="my mz iq ky b kz la lc ld lf na lj nb ln nc lr nd ne nf ng bi translated"><em class="no">执行</em>:我们覆盖了基础传感器的执行方法，通过<a class="ae kv" href="https://airflow.apache.org/docs/apache-airflow/stable/concepts/xcoms.html" rel="noopener ugc nofollow" target="_blank">气流xcoms </a>将上传的文件传递给传感器任务下游的任务。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">覆盖基本传感器的执行方法，由作者生成图像</p></figure><p id="39aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">构建Dag以在文件到达时删除文件</strong></p><p id="2ac8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们的自定义传感器创建完成，我们就将其用作从多个存储桶中实时删除文件的<a class="ae kv" href="https://airflow.apache.org/docs/apache-airflow/stable/concepts/dags.html" rel="noopener ugc nofollow" target="_blank">气流DAG </a>的第一步。这对应于下面代码片段中的对象<em class="no"> wait_for_objects_task </em>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">当文件到达时，按作者删除图像的Dag</p></figure><p id="32f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们将文件删除代码嵌入到一个<a class="ae kv" href="https://github.com/apache/airflow/blob/main/airflow/operators/python.py#L77" rel="noopener ugc nofollow" target="_blank"> Python操作符</a>(<em class="no">process _ objects _ task</em>)中。最后，我们使用一个<a class="ae kv" href="https://github.com/apache/airflow/blob/main/airflow/operators/trigger_dagrun.py#L64" rel="noopener ugc nofollow" target="_blank"> Trigger Dag运行操作符</a>(<em class="no">Trigger _ files _ processor _ Dag</em>)在上传的文件被删除后再次启动传感器。通过这种方式，我们能够持续监控新文件上传的云存储空间。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/c9e0364fe07b75fddfcfc68ea188fd91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HFelPXdeSaTdQsjCDKhZNA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">运行dag，在文件到达时按作者删除图像</p></figure><p id="41c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，我们的传感器(所有气流传感器都是如此)并不真正提供实时容量。而是每分钟列出桶的内容，看看里面是否有文件。它戳桶的频率由参数<em class="no"> poke_interval </em>控制。虽然您应该避免非常频繁的戳，但是如果您需要实时处理，您应该将该参数设置为一个较低的值。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="b2f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">结束注释</strong></p><p id="967b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了给它应有的荣誉，让我确认一下，除了前面提到的4个限制，我认为云函数是基于事件处理的一个有吸引力的解决方案，因为它们通常可以快速构建并且具有成本效益。</p><p id="acbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，尽管我一直在说气流传感器的优点，但它们有一个重要的缺点:它们可以运行很长时间，这意味着在气流装置中运行许多传感器会导致资源匮乏。<a class="ae kv" href="https://airflow.apache.org/docs/apache-airflow/stable/concepts/deferring.html" rel="noopener ugc nofollow" target="_blank">为了解决这个问题，Airflow 2.2中引入了可推迟操作符</a>。</p><p id="a8a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，你同意我的观点，气流传感器是云功能的强大而灵活的替代品吗？</p><p id="2903" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">非常感谢你的时间。请在这里找到完整的代码<a class="ae kv" href="https://gitlab.com/marcdjoh/event-based-processing-with-apache-airflow" rel="noopener ugc nofollow" target="_blank"/>。直到下一次写作，拜拜。</p></div></div>    
</body>
</html>