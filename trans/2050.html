<html>
<head>
<title>In the Power BI whirlpool — understanding circular dependencies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Power BI漩涡中——理解循环依赖</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/in-the-power-bi-whirlpool-understanding-circular-dependencies-316d7f664d94#2022-05-09">https://towardsdatascience.com/in-the-power-bi-whirlpool-understanding-circular-dependencies-316d7f664d94#2022-05-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8605" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">循环依赖错误是Power BI数据建模中最讨厌的事情之一！了解为什么会发生这种情况以及如何避免</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/39dabf7f88f5222b43200007669de1ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FUXn7YttictDMCHfgYHYTA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="f34c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过阅读我以前的文章，您可能已经理解了，创建星型模式并不一定意味着您的数据建模任务已经完成。还有很多方面需要注意——虽然你可以偷偷摸摸地不去微调每一个细节——但其中一些“细节”当然更重要，需要更好地理解。</p><p id="d9f7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中一个很容易把你拉入“漩涡”的“细节”，叫做——循环依赖！我很确定我们所有人至少有一次(希望只有一次)对这个消息感到恼火:“检测到一个循环依赖…”</p><p id="d063" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，在我们继续解释什么是循环依赖以及为什么您应该关注它之前，让我们首先了解…</p><h1 id="7f42" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">依赖到底是什么…</h1><p id="6631" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated"><strong class="la iu"> <em class="mr">依存性顾名思义就是一个事实，一个事物(或事件)依赖于另一个事物的行为。</em>T3】</strong></p><p id="2b60" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我给你举个简单的例子:比如说，除了其他因素外，公共汽车票价取决于燃料价格。这意味着，如果燃油价格发生变化，公共汽车票价也将发生变化。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="3385" class="mx lv it mt b gy my mz l na nb">Bus Ticket Price = [Fuel Price] + [Factor A] + [Factor B] + ... [Factor N]</span></pre><p id="e150" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是所谓的规则依赖，它存在于每一种编程语言中(也存在于日常生活中)。但是，如果公交车票价格发生变化会怎么样呢？这是否一定意味着燃料价格也会改变？不要！公交票价取决于燃油价格，而不是相反！</p><p id="7f97" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我为什么问这个？因为在某些情况下，两个事实或事件之间可能存在相互依存关系。</p><p id="5b2b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设您想要降低燃料桶的运输成本。实现这一目标的一个潜在步骤是降低燃料成本(因为燃料成本会影响整体运输成本)。因此，为了降低运输成本，我们需要降低燃料成本。同时，为了降低燃料成本，我们需要降低燃料的运输成本。这就是循环依赖…</p><h1 id="723f" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">如果事实A依赖于事实B，而同时事实B也依赖于事实A，我们说的就是循环依赖！</h1><p id="b94f" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">好了，现在我们知道了什么是循环依赖，让我们研究一下为什么它会出现在Power BI中，以及我们如何消除它。正如您可能会想到的，Marco和Alberto已经写了一篇关于DAX中循环依赖内部的<a class="ae nc" href="https://www.sqlbi.com/articles/understanding-circular-dependencies/" rel="noopener ugc nofollow" target="_blank">优秀文章</a>，所以我鼓励您去阅读它，以便更好地理解这个“特性”。</p><p id="4fa9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们运行一个非常基本的用例，在CALCULATE()函数的帮助下，在我们的数据模型中创建一个计算列。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/7d4677fd81314ac54617449c25c53fbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QGVFurFrcIjgHInx-J7z8A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="3055" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如您可能在上面的插图中看到的，我有一个简单的数据模型，由两个表组成:事实表Bets，它存储关于我们的客户所下赌注的数据；以及保存竞争属性的竞争维度表。</p><p id="3b08" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我想用额外的computed列来丰富我的数据模型，它将只计算比赛英超联赛的下注额。简单的工作！</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="c1b2" class="mx lv it mt b gy my mz l na nb">Bets Premier League = <br/>        CALCULATE(<br/>            SUM(Bets[Amount]),<br/>            Competition[Competition Name] = "Premier League"<br/>        )</span></pre><p id="d80d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">应用后，我的下注表看起来是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/c16c1d3155a9c40587a50fb9e835cebd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1EUfeKf7r9Wc5HDjLIMszg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="f712" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很酷，对吧？我们确信这是可行的，所以让我们尝试创建另一个相同的列:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a3129772f368a2e1f6d5524e865ddb99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7-VqPCkprnXHI1MCbrd0Jg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="f48b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">等等，什么？！这不是一分钟前完美运行的公式吗？</p><p id="7a52" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们从数据模型中删除这两个新列，切换到DAX Studio，并尝试理解<a class="ae nc" rel="noopener" target="_blank" href="/how-to-reduce-your-power-bi-model-size-by-90-76d7c4377f2d">公式引擎</a>生成的查询计划:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/00c0b7c8ca95b411a9d06f701590e9c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*phNLNYCaKEg8rHvwkD62NQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="2780" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意逻辑查询计划的第1行，它告诉我们新列依赖于Bets表中所有现有的列！我们期望新的列Bets Premier League依赖于CompetitionID，这是我们的竞争表的外键，我们在这里应用我们的过滤。但是，事实并非如此。为什么会这样？！</p><p id="b582" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们创建一个计算列时，我们的表达式被逐行计算(行上下文)。当我们在行上下文中使用CALCULATE时，该函数应用一个上下文转换，因此我们在范围内的所有列上都有一个过滤器！</p><p id="d42f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">简单来说，这是我们计算的伪代码:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="3a40" class="mx lv it mt b gy my mz l na nb">Calculation: Bet Amount<br/>--Filters<br/>Bets[Bet ID] = 333<br/>Bets[Bet Date] = 2021-11-06<br/>Bets[Customer ID] = 2<br/>Bets[Competition ID] = 789<br/>Bets[Amount] = 200</span></pre><p id="c2ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如你可能已经看到的那样，这很好。但是，当我们想用相同的公式创建另一列时，会发生什么呢:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/0727e21be19299dda44b9c0e4ef89c94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ye-bqq58X1SpTzt9LAICvg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="3b09" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">和前面的例子一样，新列依赖于Bets表中的所有原始列，但是，它还依赖于我们之前创建的Bets Premier League列！由于该列是在刷新时计算的，Power BI无法解决这种依赖性，并抱怨循环依赖性。</p><p id="0453" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">简单地说，如果您能够在数据模型中创建这两列，那么一旦您刷新数据集，就会发生以下情况:</p><p id="6aab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mr">栏目投注英超将依赖于所有来源栏目+投注英超新栏目。另一方面，Bets英超联赛新列将依赖于所有源列+Bets英超联赛列。这就是Power BI拒绝创建这样一个模型的原因，它在两个计算列之间有循环依赖。</em></p><p id="0796" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过扩展原始列表达式并使用REMOVEFILTERS函数删除所有由于上下文转换而应用的过滤器，可以很容易地解决这个问题:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="1e6b" class="mx lv it mt b gy my mz l na nb">Bets Premier League NEW = <br/>        CALCULATE(<br/>            SUM(Bets[Amount]),<br/>            Competition[Competition Name] = "Premier League",<br/>            REMOVEFILTERS(Bets[Bets Premier League])<br/>            )</span></pre><p id="a590" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦应用，Power BI不再抱怨循环依赖，新列成为数据模型的一部分:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/635a2a47a86dc1fae2a8f030a7e78cd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KNSAOyZFb_Rj3_zkw-xcvQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b529" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好的，我们解决了这个难题，但是让我向您展示如果我尝试在维度表中而不是在事实表中用相同的公式创建一个计算列会发生什么。</p><p id="5596" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将转到“竞赛”表，并粘贴“下注英超联赛”计算列的代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/448f062b0e6f0ea4c737891703d75547.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IEMpy60PQ7rDchvXqCWYeA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者形象</p></figure><p id="d161" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里到底发生了什么？！以前导致“循环依赖”错误的相同代码，现在工作起来像一个符咒！</p><p id="171c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">问题在于，当表中有一列具有唯一值时(在我们的例子中，竞争ID是竞争表的主键)，上下文转换被优化以避免过滤除具有唯一值的列之外的所有其他列。在竞争表(位于关系的一侧)和下注表之间建立1:M关系时，引擎确认了该列的唯一性。</p><p id="31d1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，正如在SQL BI的本文<a class="ae nc" href="https://www.sqlbi.com/articles/understanding-circular-dependencies/" rel="noopener ugc nofollow" target="_blank"/>中所解释的，这种在维度表中创建计算列以避免循环依赖问题的“技术”不是推荐的做法，因此应该尽可能避免。</p><h1 id="8056" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">结论</h1><p id="bf7c" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">循环依赖是Power BI数据建模过程中最恼人的事情之一！每当您创建两个相互依赖的对象时，您都有遇到此问题的风险。有时，确定根本原因可能是一项简单的任务，但在某些情况下，有必要了解DAX做事方式的细微差别。</p><p id="a228" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">谢谢你的阅读！</p><p id="ad44" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae nc" href="https://datamozart.medium.com/membership" rel="noopener">不要错过媒体上的任何故事！</a></p></div></div>    
</body>
</html>