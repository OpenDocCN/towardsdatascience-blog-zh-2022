<html>
<head>
<title>GRU Recurrent Neural Networks — A Smart Way to Predict Sequences in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GRU 递归神经网络——预测 Python 中序列的一种智能方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/gru-recurrent-neural-networks-a-smart-way-to-predict-sequences-in-python-80864e4fe9f6#2022-02-21">https://towardsdatascience.com/gru-recurrent-neural-networks-a-smart-way-to-predict-sequences-in-python-80864e4fe9f6#2022-02-21</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="0869" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph">神经网络</h2><div class=""/><div class=""><h2 id="b420" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">门控循环单元的直观解释，包括用于现实生活数据预测的端到端 Python 示例</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/99172eb180373aeb2febf89aef77a162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LfH52lSd1mq-UrWuejzO8g.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">门控循环单元(GRU)。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><h1 id="5b81" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">介绍</h1><p id="4fd3" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated"><strong class="md je">门控递归单元(GRU) </strong>和<a class="ae li" rel="noopener" target="_blank" href="/lstm-recurrent-neural-networks-how-to-teach-a-network-to-remember-the-past-55e54c2ff22e"> <strong class="md je">长短期记忆(LSTM) </strong> </a> <strong class="md je"> </strong>已经被引入来处理标准<a class="ae li" rel="noopener" target="_blank" href="/rnn-recurrent-neural-networks-how-to-successfully-model-sequential-data-in-python-5a0b9e494f92">递归神经网络(RNNs) </a>中消失/爆炸梯度的问题。</p><p id="666e" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">在本文中，我将向您概述<strong class="md je"> GRU </strong>架构，并为您提供一个详细的 Python 示例，您可以使用它来构建自己的 GRU 模型。</p><h1 id="f226" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">内容</h1><ul class=""><li id="397c" class="nc nd iu md b me mf mh mi mk ne mo nf ms ng mw nh ni nj nk bi translated">GRU 在机器学习领域的地位</li><li id="ce02" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated">GRU 是如何建造的，它与标准的 RNN 和 LSTM 有什么不同？</li><li id="b409" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated">用 Keras 和 Tensorflow 库构建 GRU 神经网络的完整 Python 示例</li></ul><h1 id="0868" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">GRU 在机器学习领域的地位</h1><p id="179e" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">下面的图表是我对最常见的机器学习算法进行分类的尝试。</p><p id="6ca7" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">虽然我们经常以监督的方式使用带有标签的训练数据的神经网络，但我觉得它们独特的机器学习方法值得单独归类。</p><p id="b029" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">因此，我的图表显示了从机器学习宇宙的核心分支出来的神经网络。递归神经网络占据 NNs 的一个子分支，并且包含诸如标准 RNNs、LSTMs 和 GRUs 的算法。</p><p id="7f3a" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">下图是<strong class="md je">交互式的，</strong>所以请点击不同的类别来<strong class="md je">放大并展示更多的</strong>👇。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="nq nr l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">机器学习算法分类。由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>创建的互动图表。</p></figure><p id="2184" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated"><strong class="md je"> <em class="ns">如果你喜欢数据科学和机器学习</em> </strong> <em class="ns">，请</em> <a class="ae li" href="https://solclover.com/subscribe" rel="noopener ugc nofollow" target="_blank"> <em class="ns">订阅</em> </a> <em class="ns">获取我的新文章的电子邮件。</em></p><h1 id="51a3" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">GRU 是如何建造的，它与标准的 RNN 和 LSTM 有什么不同？</h1><p id="f49c" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">让我们提醒自己典型的 RNN 结构，它包含输入层、隐藏层和输出层。请注意，您可以拥有任意数量的节点，下面的 2–3–2 设计仅用于说明。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj nt"><img src="../Images/52219d7e4585900c9695f3205af6e827.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*88v6lf17GqXSIPnQNA5ktQ.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">标准递归神经网络结构。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="43e4" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">与<a class="ae li" rel="noopener" target="_blank" href="/feed-forward-neural-networks-how-to-successfully-build-them-in-python-74503409d99a">前馈神经网络</a>不同，RNNs 在其隐藏层包含<strong class="md je">递归单元</strong>，这允许算法处理<strong class="md je">序列数据</strong>。这是通过循环传递先前<strong class="md je">时间步长</strong>的隐藏状态并将它们与当前时间步长的输入相结合来实现的。</p><blockquote class="nu"><p id="d40f" class="nv nw iu bd nx ny nz oa ob oc od mw dk translated">时间步长—通过递归单元对输入进行的单一处理。时间步长的数量等于序列的长度。</p></blockquote><h2 id="bdb2" class="oe lk iu bd ll of og dn lp oh oi dp lt mk oj ok lv mo ol om lx ms on oo lz ja bi translated">标准 RNN 和 LSTM 内部的循环单元建筑</h2><p id="eab8" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">我们知道，RNN 利用<strong class="md je">循环单元</strong>从序列数据中学习，这对于所有三种类型都是正确的——标准 RNN、LSTM 和 GRU</p><p id="23f7" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">然而，在循环单元内部发生的事情在它们之间是非常不同的。</p><p id="afdc" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">例如，标准 RNN 使用隐藏状态来记忆信息。同时，LSTM 和 GRU 引入了盖茨来控制在更新隐藏状态之前记住什么和忘记什么。除此之外，LSTM 还有一种细胞状态，它可以作为长期记忆。</p><p id="0337" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">以下是标准 RNN 和 LSTM 的简化循环单位图(未显示权重和偏差)。看看他们是如何相互比较的。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj op"><img src="../Images/0ea4ea8283516166bc59587fefa44c2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BKhOGqwgEboS-V0PraRo_A.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">标准循环单位与 LSTM 循环单位。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="cf81" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">注意，在这两种情况下，在时间步长 t 计算隐藏状态(以及 LSTM 的单元状态)之后，它们被<strong class="md je">传递回递归单元</strong>并与时间步长 t+1 的输入组合，以计算时间步长 t+1 的新隐藏状态(以及单元状态)。对 t+2、t+3、…、t+n 重复该过程，直到达到预定数量(n)的时间步长。</p><h2 id="5916" class="oe lk iu bd ll of oq dn lp oh or dp lt mk os ok lv mo ot om lx ms ou oo lz ja bi translated">GRU 是如何工作的？</h2><p id="1250" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">GRU 与 LSTM 相似，但它的大门更少。此外，它只依赖于一个隐藏状态在循环单元之间进行内存转移，因此没有单独的单元状态。让我们详细分析这个简化的 GRU 图(未显示权重和偏差)。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ov"><img src="../Images/35d47f9c39abeef5612913e272782405.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3a8HnDUlzhhKcSpQzOyiCQ.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">GRU 循环股。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="eaf7" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated"><strong class="md je">1–2 复位门</strong> —先前的隐藏状态(h_t-1)和当前输入(x_t)被组合(乘以各自的权重并加上偏置)并通过复位门。由于 sigmoid 函数的范围在 0 和 1 之间，第一步设置哪些值应该被丢弃(0)、记住(1)或部分保留(0 和 1 之间)。第二步重置先前的隐藏状态，将其与第一步的输出相乘。</p><p id="bb92" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated"><strong class="md je">3–4–5 更新门</strong> —第三步可能看起来类似于第一步，但请记住，用于缩放这些向量的权重和偏差是不同的，从而提供不同的 sigmoid 输出。因此，在通过 sigmoid 函数传递一个组合向量后，我们从一个包含全 1 的向量中减去它(步骤四)，然后乘以先前的隐藏状态(步骤五)。这是用新信息更新隐藏状态的一部分。</p><p id="3e34" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated"><strong class="md je">6–7–8 隐藏状态候选</strong> —在第二步中重置之前的隐藏状态后，输出与新输入(x_t)组合，将它们乘以各自的权重，并在通过双曲正切激活函数之前添加偏差(第六步)。然后，隐藏状态候选被乘以更新门的结果(步骤七)，并被加到先前修改的 h_t-1，以形成新的隐藏状态 h_t</p><p id="a463" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">接下来，该过程重复时间步长 t+1，等等。，直到递归单元处理整个序列。</p><div class="kt ku kv kw gu ab cb"><figure class="ow kx ox oy oz pa pb paragraph-image"><a href="https://solclover.com/membership"><img src="../Images/63320331b74bd98eea6402472b4209ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*qkXay39OnVc2IosW6rkxtw.png"/></a></figure><figure class="ow kx ox oy oz pa pb paragraph-image"><a href="https://www.linkedin.com/in/saulius-dobilas/"><img src="../Images/60fb21d1cb2701bfb6b71f61c99403e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*vabxOXtQ4T034N_mscHSmQ.png"/></a></figure></div><h1 id="7927" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">用 Keras 和 Tensorflow 库构建 GRU 神经网络的 Python 示例</h1><p id="f7e8" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">现在，我们将使用 GRU 创建一个<strong class="md je">多对多</strong>预测模型，这意味着使用一个值序列来预测下面的序列。注意，GRU 也可以用于一对一(不推荐，因为它不是序列数据)、多对一和一对多设置。</p><h2 id="e1e5" class="oe lk iu bd ll of oq dn lp oh or dp lt mk os ok lv mo ot om lx ms ou oo lz ja bi translated">数据准备</h2><p id="ad18" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">首先，我们需要获得以下数据和库:</p><ul class=""><li id="a014" class="nc nd iu md b me mx mh my mk pc mo pd ms pe mw nh ni nj nk bi translated"><a class="ae li" href="https://www.kaggle.com/jsphyg/weather-dataset-rattle-package" rel="noopener ugc nofollow" target="_blank">澳大利亚天气数据来自 Kaggle </a>(许可:<a class="ae li" href="http://www.bom.gov.au/other/copyright.shtml?ref=ftr" rel="noopener ugc nofollow" target="_blank"> Creative Commons </a>，数据原始来源:<a class="ae li" href="http://www.bom.gov.au/climate/data/" rel="noopener ugc nofollow" target="_blank">澳大利亚联邦气象局</a>)。</li><li id="2992" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated">用于数据操作的<a class="ae li" href="https://pandas.pydata.org/docs/" rel="noopener ugc nofollow" target="_blank">熊猫</a>和<a class="ae li" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank"> Numpy </a></li><li id="b5ed" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated"><a class="ae li" href="https://plotly.com/python/" rel="noopener ugc nofollow" target="_blank"> Plotly </a>用于数据可视化</li><li id="5489" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated"><a class="ae li" href="https://www.tensorflow.org/api_docs/python/tf" rel="noopener ugc nofollow" target="_blank">用于 GRU 神经网络的 Tensorflow/Keras </a></li><li id="8c25" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated"><a class="ae li" href="https://scikit-learn.org/stable/index.html" rel="noopener ugc nofollow" target="_blank">Scikit-学习库</a>用于数据缩放(<a class="ae li" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html" rel="noopener ugc nofollow" target="_blank"> MinMaxScaler </a>)</li></ul><p id="c2c1" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">让我们导入所有库:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pf nr l"/></div></figure><p id="2662" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">上面的代码打印了我在这个例子中使用的包版本:</p><pre class="kt ku kv kw gu pg ph pi pj aw pk bi"><span id="4d47" class="oe lk iu ph b gz pl pm l pn po">Tensorflow/Keras: 2.7.0<br/>pandas: 1.3.4<br/>numpy: 1.21.4<br/>sklearn: 1.0.1<br/>plotly: 5.4.0</span></pre><p id="b75a" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">接下来，下载并摄取澳大利亚的天气数据(来源:<a class="ae li" href="https://www.kaggle.com/jsphyg/weather-dataset-rattle-package" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>)。我们只接收列的子集，因为我们的模型不需要整个数据集。</p><p id="5c72" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">此外，我们执行一些简单的数据操作，并得出几个新的变量:年月和中值温度。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pf nr l"/></div></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pp"><img src="../Images/51553fff5c401cb5d25a40a9451b0c0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J3SjpNjBXB7NLLcuXl2ekw.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">一小段<a class="ae li" href="https://www.kaggle.com/jsphyg/weather-dataset-rattle-package" rel="noopener ugc nofollow" target="_blank"> Kaggle 的澳大利亚天气数据</a>做了一些修改。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="2aea" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">目前，我们对每个地点和日期都有一个中值温度记录。然而，每天的温度波动很大，使得预测更加困难。因此，让我们计算月平均值，并将数据转置为以地点为行，以年月为列。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pf nr l"/></div></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pq"><img src="../Images/a68debe4b9ff65df3fe6ae7c453cc47b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wSGmRfPhVwvsA9Rlg7cU8g.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">按地点和月份划分的月平均温度。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="8d5e" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">由于我们使用的是现实生活中的数据，我们注意到三个月(2011 年 4 月、2012 年 12 月和 2013 年 2 月)完全从数据框架中消失了。因此，我们通过取前一个月和后一个月的平均值来估算缺失月份的值。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pf nr l"/></div></figure><p id="daf7" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">最后，我们可以在图表上绘制数据。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pf nr l"/></div></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pr"><img src="../Images/bae72e7911dc51105d179fd77087bdc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zzdrzJqY5VvRGefjV6MX7A.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">月平均气温。图片作者<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>。</p></figure><p id="3d1b" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">该图最初显示了所有地点，但我选择了其中的五个(凯恩斯、堪培拉、达尔文、黄金海岸和吉尼火山)显示在上图中。</p><p id="a456" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">请注意不同地点的平均温度以及温度变化是如何不同的。我们可以训练一个特定位置的模型来获得更高的精度，也可以训练一个通用模型来预测每个区域的温度。</p><p id="bdd4" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">在本例中，我将创建一个通用模型<strong class="md je">，在所有位置</strong>进行训练。<em class="ns">注意，您可以在我的</em> <a class="ae li" rel="noopener" target="_blank" href="/lstm-recurrent-neural-networks-how-to-teach-a-network-to-remember-the-past-55e54c2ff22e"> <em class="ns"> LSTM 文章</em> </a> <em class="ns">中找到具体位置的型号代码。</em></p><h2 id="bea3" class="oe lk iu bd ll of oq dn lp oh or dp lt mk os ok lv mo ot om lx ms ou oo lz ja bi translated">训练和评估 GRU 模型</h2><p id="2079" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">在我们开始之前，这里有一些需要强调的事情。</p><ul class=""><li id="1ede" class="nc nd iu md b me mx mh my mk pc mo pd ms pe mw nh ni nj nk bi translated">我们将使用 18 个月的序列来预测未来 18 个月的平均气温。您可以根据自己的喜好进行调整，但要注意，对于长度超过 23 个月的序列，将没有足够的数据。</li><li id="7cda" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated">我们将把数据分成两个独立的数据帧，一个用于训练，另一个用于验证(<strong class="md je">超时</strong>验证)。</li><li id="e803" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated">由于我们正在创建一个<strong class="md je">多对多</strong>预测模型，我们需要使用一个稍微复杂一点的<strong class="md je">编码器-解码器</strong>配置。编码器和解码器都是隐藏的 GRU 层，信息通过一个<strong class="md je">重复向量</strong>层从一个传递到另一个。</li><li id="25a7" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated">当我们想要有不同长度的序列时，例如，一个 18 个月的序列来预测接下来的 12 个月，一个<strong class="md je">重复向量</strong>是必要的。它确保我们为解码器层提供正确的形状。然而，如果您的输入和输出序列的长度与我的示例中的长度相同，那么您也可以选择在编码器层中设置<em class="ns"> return_sequences=True </em>并移除重复向量。</li><li id="ebe2" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated">注意，我们给 GRU 层添加了一个双向<strong class="md je">包装器。它允许我们在两个方向上训练模型，这有时会产生更好的结果。但是，它的用途是<strong class="md je">可选的<em class="ns">。</em>T15】</strong></strong></li><li id="3487" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated">此外，我们需要在输出层使用一个<strong class="md je">时间分布</strong>包装器来单独预测每个时间步长的输出。</li><li id="a77d" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated">最后，我在这个例子中使用了<strong class="md je"> MinMaxScaling </strong>，因为它产生了比未缩放版本更好的结果。你可以在我的 GitHub 库<em class="ns">(文章末尾有链接)</em>的 Jupyter 笔记本中找到缩放和未缩放的设置。</li></ul><p id="719f" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">首先，让我们定义一个 helper 函数，将数据整形为 GRU 所需的 3D 数组。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pf nr l"/></div></figure><p id="caa9" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">接下来，我们在 50 个时期内训练 GRU 神经网络，并显示带有评估指标的模型概要。您可以按照我在代码中的注释来理解每一步。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pf nr l"/></div></figure><p id="ab42" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">上述代码为我们的 GRU 神经网络打印了以下摘要和评估指标(注意，由于神经网络训练的随机性，您的结果可能会有所不同):</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ps"><img src="../Images/eab54fd16ed5cd0c62e15c0fe0570677.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zkW6gJE0ra1kLoZjLdS1Uw.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">GRU 神经网络性能。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="b993" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">现在，让我们重新生成之前选择的 5 个位置的预测，并将结果绘制在图表上，以比较实际值和预测值。</p><p id="55d2" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated"><strong class="md je"> <em class="ns">预测</em> </strong></p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pf nr l"/></div></figure><p id="340e" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated"><strong class="md je"> <em class="ns">剧情</em> </strong></p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pf nr l"/></div></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pt"><img src="../Images/7695b3e030ddf4c9e8931bd717712a81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yjeguxLxxBRW3kBU0WGtbQ.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">GRU 神经网络预测与实际。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="7b5d" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">看起来我们的 GRU 模型在捕捉每个地点的温度趋势方面做得相当不错！</p><h1 id="273e" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">结束语</h1><p id="10e1" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">GRU 和 LSTM 不仅在建筑上相似，而且在预测能力上也相似。因此，在选择你最喜欢的之前，你可以尝试这两种方法。</p><p id="2d1b" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">如果你想要完整的 Python 代码，你可以在我的<a class="ae li" href="https://github.com/SolClover/Art045_NN_GRU" rel="noopener ugc nofollow" target="_blank"> GitHub 库</a>中找到 Jupyter Notebook。</p><p id="c020" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">感谢您的阅读，如果您有任何问题或建议，请随时联系我们。</p><p id="cb16" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">干杯！<br/> <strong class="md je">索尔·多比拉斯</strong></p></div><div class="ab cl pu pv hy pw" role="separator"><span class="px bw bk py pz qa"/><span class="px bw bk py pz qa"/><span class="px bw bk py pz"/></div><div class="in io ip iq ir"><p id="a1fc" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated"><strong class="md je"> <em class="ns">如果你已经花光了这个月的学习预算，下次请记得我。</em> </strong> <em class="ns">我的个性化链接加入媒介:</em></p><div class="qb qc gq gs qd qe"><a href="https://solclover.com/membership" rel="noopener  ugc nofollow" target="_blank"><div class="qf ab fp"><div class="qg ab qh cl cj qi"><h2 class="bd je gz z fq qj fs ft qk fv fx jd bi translated">通过我的推荐链接——索尔·多比拉斯加入 Medium</h2><div class="ql l"><h3 class="bd b gz z fq qj fs ft qk fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="qm l"><p class="bd b dl z fq qj fs ft qk fv fx dk translated">solclover.com</p></div></div><div class="qn l"><div class="qo l qp qq qr qn qs lc qe"/></div></div></a></div></div><div class="ab cl pu pv hy pw" role="separator"><span class="px bw bk py pz qa"/><span class="px bw bk py pz qa"/><span class="px bw bk py pz"/></div><div class="in io ip iq ir"><p id="9f4a" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">您可能感兴趣的其他文章:</p><div class="qb qc gq gs qd qe"><a rel="noopener follow" target="_blank" href="/rnn-recurrent-neural-networks-how-to-successfully-model-sequential-data-in-python-5a0b9e494f92"><div class="qf ab fp"><div class="qg ab qh cl cj qi"><h2 class="bd je gz z fq qj fs ft qk fv fx jd bi translated">RNN:递归神经网络——如何在 Python 中成功地对序列数据建模</h2><div class="ql l"><h3 class="bd b gz z fq qj fs ft qk fv fx dk translated">rnn 的可视化解释和使用 Keras 和 Tensorflow Python 库构建它们的逐步指南</h3></div><div class="qm l"><p class="bd b dl z fq qj fs ft qk fv fx dk translated">towardsdatascience.com</p></div></div><div class="qn l"><div class="qt l qp qq qr qn qs lc qe"/></div></div></a></div><div class="qb qc gq gs qd qe"><a rel="noopener follow" target="_blank" href="/feed-forward-neural-networks-how-to-successfully-build-them-in-python-74503409d99a"><div class="qf ab fp"><div class="qg ab qh cl cj qi"><h2 class="bd je gz z fq qj fs ft qk fv fx jd bi translated">前馈神经网络——如何在 Python 中成功构建它们</h2><div class="ql l"><h3 class="bd b gz z fq qj fs ft qk fv fx dk translated">使用真实数据的 Python 示例对神经网络进行了详细的图形说明</h3></div><div class="qm l"><p class="bd b dl z fq qj fs ft qk fv fx dk translated">towardsdatascience.com</p></div></div><div class="qn l"><div class="qu l qp qq qr qn qs lc qe"/></div></div></a></div><div class="qb qc gq gs qd qe"><a rel="noopener follow" target="_blank" href="/deep-feed-forward-neural-networks-and-the-advantage-of-relu-activation-function-ff881e58a635"><div class="qf ab fp"><div class="qg ab qh cl cj qi"><h2 class="bd je gz z fq qj fs ft qk fv fx jd bi translated">深度前馈神经网络及其再激活函数的优势</h2><div class="ql l"><h3 class="bd b gz z fq qj fs ft qk fv fx dk translated">如何使用 Tensorflow Keras API 在 Python 中构建深度前馈(DFF)神经网络，以及如何在…</h3></div><div class="qm l"><p class="bd b dl z fq qj fs ft qk fv fx dk translated">towardsdatascience.com</p></div></div><div class="qn l"><div class="qv l qp qq qr qn qs lc qe"/></div></div></a></div></div></div>    
</body>
</html>