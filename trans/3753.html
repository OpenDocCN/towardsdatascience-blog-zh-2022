<html>
<head>
<title>A Simple Guide to Inplace Operations in Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大熊猫就地手术简单指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-simple-guide-to-inplace-operations-in-pandas-7a1d97ecce24#2022-08-21">https://towardsdatascience.com/a-simple-guide-to-inplace-operations-in-pandas-7a1d97ecce24#2022-08-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c50c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">介绍熊猫的原位手术，探索普遍支持的方法和常见的误解</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/433204cee99f2ebc53189505cde0783c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KjIdjT-_rx3YgUj1"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="ab62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在转换熊猫数据帧时，就地赋值操作非常普遍。顾名思义，原地赋值背后的核心思想是避免每次连续修改都创建新的数据帧对象，而是对原始数据帧本身进行更改。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/e8a4323d987d1320f21e613742554b2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zzjwTgzpXTieLnhZ_ysYeQ.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">原地和标准赋值操作(图片由作者提供)</p></figure><p id="ad69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就地赋值操作在内存极度受限的应用程序中特别有用。这是因为对现有数据帧(或源数据帧)进行了修改，而没有创建任何中间数据帧。</p><p id="b020" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章是对就地操作的介绍，特别是对熊猫数据帧的介绍。我们将讨论就地运算与标准的赋值运算有何不同。最后，我将介绍一些最常用的支持熊猫原地赋值的方法。</p><p id="a3d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">文章的亮点如下:</p><p id="8412" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="#fbf8" rel="noopener ugc nofollow"> <strong class="ky ir">在位赋值简介</strong> </a> <strong class="ky ir"> <br/> </strong> <a class="ae kv" href="#5266" rel="noopener ugc nofollow"> <strong class="ky ir">在位赋值的常见误解</strong></a><strong class="ky ir"><br/></strong><a class="ae kv" href="#0b7b" rel="noopener ugc nofollow"><strong class="ky ir">支持在位赋值的常用函数</strong></a><strong class="ky ir"><br/></strong><a class="ae kv" href="#c5cc" rel="noopener ugc nofollow"><strong class="ky ir">运行时比较</strong></a><strong class="ky ir"><br/></strong><a class="ae kv" href="#379f" rel="noopener ugc nofollow"><strong class="ky ir">结论</strong></a></p><p id="f076" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们开始吧🚀！</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="fbf8" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">就地分配简介</h1><p id="ad6a" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">一旦我们将数据帧加载到Python环境中，我们通常会对该数据帧执行大范围的转换，不是吗？这些包括添加新列、重命名标题、删除列、改变单元格值、替换NaN值等等。</p><p id="5f1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常可以通过两种方式执行这些操作，如下图所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/638977affba0aa6a497f255f8a0feca8.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*WFoKYyUij8bnxnsXl36sDg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">熊猫数据帧操作的分类(图片由作者提供)。</p></figure><h2 id="1556" class="my mb iq bd mc mz na dn mg nb nc dp mk lf nd ne mm lj nf ng mo ln nh ni mq nj bi translated">标准分配</h2><p id="972c" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">如果应用的转换返回数据帧的新副本，在Pandas中它被称为<strong class="ky ir">“非就地”</strong>或<strong class="ky ir">“标准赋值”</strong>操作。</p><p id="9d00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认情况下，Pandas总是求助于标准赋值并返回数据帧的修改副本，而不改变原始数据帧。</p><p id="5736" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能已经猜到，这实际上会占用额外的内存空间，最终会导致内存限制。下图演示了标准的赋值操作，并在下图后面的代码块中实现:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/a6d97db5592727757301c3a0e6d58418.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wtmh1KAZnu4x7ocME7aWnQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从给定的数据帧创建新的数据帧(图片由作者提供)。</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="1c23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为上面显示的填充NaN值的标准赋值操作的结果，两个不同的熊猫对象将存在于程序的范围内— <code class="fe nn no np nq b">df</code>和<code class="fe nn no np nq b">df_copy</code>。</p><h2 id="a2e3" class="my mb iq bd mc mz na dn mg nb nc dp mk lf nd ne mm lj nf ng mo ln nh ni mq nj bi translated">就地分配</h2><p id="35f5" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">与标准/传统赋值相反，如果生成的中间数据帧(如上面的<code class="fe nn no np nq b">df_copy</code>)对你没有用，执行<strong class="ky ir">就地赋值</strong>是继续的理想方式。下面演示了这一点:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/36e59390f3b6d0d8ce18e2468f3adc14.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/1*I9h9LAeTs9oMwwml7T5e9Q.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">执行就地操作(Gif由作者提供)</p></figure><blockquote class="ns nt nu"><p id="97ef" class="kw kx nv ky b kz la jr lb lc ld ju le nw lg lh li nx lk ll lm ny lo lp lq lr ij bi translated">另一方面，你应该知道，在熊猫之外的许多功能中也存在就地分配。例如，当您使用<code class="fe nn no np nq b">append()</code>方法将一个元素添加到Python列表中时，这是一个就地操作，因为该元素被添加到源列表中。类似地，Python列表上的<code class="fe nn no np nq b">sort()</code>方法也执行就地排序。</p></blockquote><p id="b07b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Pandas中的就地操作要求将<code class="fe nn no np nq b">inplace</code>参数作为<code class="fe nn no np nq b">True</code>传递给被调用的方法。例如，我们可以用上述数据帧<em class="nv">中的<code class="fe nn no np nq b">0</code>代替</em>中的NaN值，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz nm l"/></div></figure><h1 id="5266" class="ma mb iq bd mc md oa mf mg mh ob mj mk jw oc jx mm jz od ka mo kc oe kd mq mr bi translated">关于就地分配的常见误解</h1><p id="9e3c" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">这里，有人可能会说，我们可以通过将新数据帧重新分配给原始数据帧的名称来优化内存，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz nm l"/></div></figure><p id="34b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管上述赋值操作在语法上没有问题，但是您应该理解，采用这种方法不可避免地会在赋值操作期间创建一个新的数据帧，从而导致内存利用率暂时增加。</p><p id="c7c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用Python中的<code class="fe nn no np nq b">id()</code>方法验证新DataFrame对象的创建，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of nm l"/></div></figure><p id="c99f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">源数据帧的ID(或地址)和新数据帧的ID(或地址)是不同的，这意味着创建了熊猫数据帧的新实例。</p><p id="32a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，如果您用<code class="fe nn no np nq b">inplace=True</code>参数执行一个就地操作，它不会创建一个新的数据帧。对原始数据帧本身进行修改。这可以通过以下方式验证:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of nm l"/></div></figure><h1 id="0b7b" class="ma mb iq bd mc md oa mf mg mh ob mj mk jw oc jx mm jz od ka mo kc oe kd mq mr bi translated">支持就地赋值的常用函数</h1><p id="95d2" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在熊猫身上有一些方法与就地操作是内在兼容的。下面展示了一些最常用的函数:</p><h2 id="7e6f" class="my mb iq bd mc mz na dn mg nb nc dp mk lf nd ne mm lj nf ng mo ln nh ni mq nj bi translated">#1重命名数据帧标题</h2><p id="45f6" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">每个列都有一个特定的列标题，用于定义列的名称。您可以更改部分/全部列的名称，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/a2a81074e36fd1f5c4fceffa57f3af95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*1H1k9BVX0kbXu_ogwsS63w.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">重命名数据帧的标题(图片由作者提供)</p></figure><p id="3fbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要重命名数据帧的列，可以在Pandas中使用<code class="fe nn no np nq b"><a class="ae kv" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.rename.html" rel="noopener ugc nofollow" target="_blank">rename()</a></code>方法，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh nm l"/></div></figure><p id="1dc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">标准赋值返回一个新的数据帧。因此，您必须将它赋给一个变量。但是，由于就地赋值修改了源数据帧本身，因此它不会返回任何内容。</p><h2 id="ceb5" class="my mb iq bd mc mz na dn mg nb nc dp mk lf nd ne mm lj nf ng mo ln nh ni mq nj bi translated">#2删除列</h2><p id="2481" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">假设您想要从现有数据框架中移除不需要的列，如下图所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/18201f39ba16a43effe96c59293e7365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*JOgJ5p9R4gazfmbBZ1X98g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从数据帧中删除列(图片由作者提供)</p></figure><p id="d4e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要删除数据帧的列，可以在Pandas中使用<code class="fe nn no np nq b"><a class="ae kv" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.drop.html" rel="noopener ugc nofollow" target="_blank">drop()</a></code>方法，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi nm l"/></div></figure><p id="dfd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您应该将想要删除的列作为列名列表传递给<code class="fe nn no np nq b">drop()</code>方法的<code class="fe nn no np nq b">columns</code>参数。</p><h2 id="63be" class="my mb iq bd mc mz na dn mg nb nc dp mk lf nd ne mm lj nf ng mo ln nh ni mq nj bi translated">#3排序数据帧</h2><p id="b358" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">分类操作是熊猫广泛使用的另一种方法。顾名思义，这里的想法是根据一列或多列中的值对数据帧进行排序，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/7fde5bf890c417cc7766f66976cdb995.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*DZo4J9NgmYvDVX4xAsoBsg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">对数据帧排序(按作者排序的图像)</p></figure><p id="dfb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用<code class="fe nn no np nq b"><a class="ae kv" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sort_values.html" rel="noopener ugc nofollow" target="_blank">sort_values()</a></code>方法对数据帧进行排序，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi nm l"/></div></figure><h2 id="efa7" class="my mb iq bd mc mz na dn mg nb nc dp mk lf nd ne mm lj nf ng mo ln nh ni mq nj bi translated">#4替换NaN值</h2><p id="9a5f" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在现实世界的数据集中，缺失值的存在是不可避免的。对于Pandas，您有一系列方法来处理丢失的数据并用确定的值替换它们，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/09346cfa503bf062f47bffd6dd957a0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*VkPJpSj6DpVfo96egCUxyg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">替换数据帧中的NaN值(图片由作者提供)</p></figure><p id="6f45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要替换NaN值，使用如下所示的<code class="fe nn no np nq b"><a class="ae kv" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.fillna.html" rel="noopener ugc nofollow" target="_blank">fillna()</a></code>方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi nm l"/></div></figure><h2 id="ae89" class="my mb iq bd mc mz na dn mg nb nc dp mk lf nd ne mm lj nf ng mo ln nh ni mq nj bi translated">#5重置索引，等等。</h2><p id="12c6" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">如果您想重置DataFrame的索引值，您可以在Pandas中使用<code class="fe nn no np nq b"><a class="ae kv" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.reset_index.html" rel="noopener ugc nofollow" target="_blank">reset_index()</a></code>方法。下图演示了这一操作:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/197d29cc8ec5ec8851be18d6b5a63047.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*j0OsAhMQmDNjxW4OjqR3Aw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">重置数据帧的索引(图片由作者提供)</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi nm l"/></div></figure><h1 id="c5cc" class="ma mb iq bd mc md oa mf mg mh ob mj mk jw oc jx mm jz od ka mo kc oe kd mq mr bi translated">运行时比较</h1><p id="096c" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">接下来，我们将在上面讨论的五个熊猫函数— <code class="fe nn no np nq b">drop()</code>、<code class="fe nn no np nq b">rename()</code>、<code class="fe nn no np nq b">fillna()</code>、<code class="fe nn no np nq b">reset_index()</code>和<code class="fe nn no np nq b">sort_values()</code>上实验性地比较标准和就地赋值操作的运行时性能。</p><p id="7cf0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的代码块演示了我测量运行时间的实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok nm l"/></div></figure><p id="bfc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了给你一个要点，上面的实现通过在虚拟数据帧<code class="fe nn no np nq b">df</code>上迭代执行这些操作，找到了标准赋值和就地赋值的平均运行时间。</p><p id="32bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要查找其他方法的运行时性能，我们可以用感兴趣的方法(<code class="fe nn no np nq b">drop()</code>、<code class="fe nn no np nq b">rename()</code>、<code class="fe nn no np nq b">fillna()</code>和<code class="fe nn no np nq b">sort_values()</code>)来替换<code class="fe nn no np nq b">reset_index()</code>方法。</p><p id="9693" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的柱状图描述了获得的结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/6c45cdf4cba9128c0b3f3256e4262e6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*XDRlWh4jc4sDJu6TfgdXKg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">标准赋值和就地赋值的运行时比较(图片由作者提供)</p></figure><p id="e698" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的条形图中，我将标准分配作为参考点，并相应地调整了就地分配的性能。换句话说，如果标准赋值用了100秒来执行，那么上面的每个黄色条代表与就地赋值方法相对应的缩放运行时间。</p><p id="5d9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总的来说，原地赋值操作总是比标准操作执行得更好。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="379f" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结论</h1><p id="1130" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">总之，在这篇文章中，我们讨论了熊猫原地行动背后的核心思想，以及它们与标准任务行动的不同之处。此外，我还介绍了一些最常用的支持熊猫原位赋值的方法。</p><p id="442a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然就地手术在熊猫中很受欢迎，但你应该知道与它们相关的利弊。由于时间关系，我没有在这篇文章中讨论它们，我将很快发布另一篇博客！</p><p id="cc5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">感谢阅读！</strong></p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="8553" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://subscribepage.io/450q" rel="noopener ugc nofollow" target="_blank"> 🧑‍💻<strong class="ky ir">成为数据科学专家！获取包含450多个熊猫、NumPy和SQL问题的免费数据科学掌握工具包。</strong> </a></p><p id="ce54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">✉️ <a class="ae kv" href="https://medium.com/subscribe/@avi_chawla" rel="noopener"> <strong class="ky ir">注册我的电子邮件列表</strong> </a>不要错过另一篇关于数据科学指南、技巧和提示、机器学习、SQL、Python等的文章。Medium会将我的下一篇文章直接发送到你的收件箱。</p></div></div>    
</body>
</html>