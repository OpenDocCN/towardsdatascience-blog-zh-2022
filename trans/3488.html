<html>
<head>
<title>How to Level Up Your Terminal Game</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何升级你的终端游戏</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-level-up-your-terminal-game-db7b44e31e65#2022-08-02">https://towardsdatascience.com/how-to-level-up-your-terminal-game-db7b44e31e65#2022-08-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="74bf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">提高效率的6个命令行实用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/25d379761de5e646913e8995815fbc77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cz9VcKmWm6ivmpK5zZvY9A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="c198" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于许多新开发人员来说，使用终端或命令行可能会显得低效甚至过时。然而，<em class="lu"> shell </em>是任何开发人员可用的最有用的工具之一。在这篇文章中，我将向你展示六个有用的工具来升级你的终端游戏！</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0924" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu"><em class="lu">Table of Contents</em></strong></span><span id="f7e5" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">1. xclip<br/>2. croc<br/>3. zoxide<br/>4. htop<br/>5. entr<br/>6. fzf </strong></span></pre><h1 id="141d" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">1.复制/粘贴</h1><p id="f493" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">当我说“复制/粘贴”时，您可能会立即想到Ctrl-C和Ctrl-V，但是您知道吗，您还可以使用命令行以编程方式将数据复制/粘贴到系统的剪贴板，而无需使用任何键盘快捷键。</p><p id="80b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您使用的是基于Linux的操作系统(或Windows上的WSL)，您可以使用xclip实用程序从命令行与剪贴板进行交互。你可以使用你系统的包管理器来安装xclip(比如Ubuntu上的<code class="fe nd ne nf lw b">apt</code>，或者Arch上的<code class="fe nd ne nf lw b">pacman</code>)。</p><p id="5ec0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行<code class="fe nd ne nf lw b">xclip -o</code>将会显示你剪贴板的当前内容，你可以把它导入另一个程序，重定向到一个文件，等等。</p><p id="d184" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同时，通过管道将文本输入到命令<code class="fe nd ne nf lw b">xclip</code>中会导致文本被复制到您的剪贴板中。(旁注:xclip旨在与X11窗口系统一起使用。如果你用的是Wayland，你应该安装<code class="fe nd ne nf lw b">wl-clipboard</code>，它提供<code class="fe nd ne nf lw b">wl-copy</code>和<code class="fe nd ne nf lw b">wl-paste</code>。</p><p id="fa97" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你在MacOS上，你可以使用相应的<code class="fe nd ne nf lw b">pbcopy</code>和<code class="fe nd ne nf lw b">pbpaste</code>命令来代替。在Windows上，如果您没有使用WSL，您可以使用<code class="fe nd ne nf lw b">clip.exe</code>(对应于<code class="fe nd ne nf lw b">copy</code>)和/或Powershell命令<code class="fe nd ne nf lw b">Get-Clipboard</code>和<code class="fe nd ne nf lw b">Set-Clipboard</code>。</p><p id="e73d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">无论您使用什么操作系统，我都建议您在shell配置文件中使用别名复制/粘贴命令，如下例所示。如果您正在使用bash，您可能希望将您的别名添加到<code class="fe nd ne nf lw b">~/.bashrc</code>(或者对于zsh，添加到<code class="fe nd ne nf lw b">~/.zshrc</code>)。您可以通过运行<code class="fe nd ne nf lw b">echo $SHELL</code>来检查您当前使用的是什么shell。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1506" class="ma mb it lw b gy mc md l me mf"># Example copy/paste alias for Linux<br/>alias paste='xclip -o'<br/>alias copy='xclip -c'</span><span id="c2a7" class="ma mb it lw b gy mg md l me mf"># Example copy/paste alias for MacOS<br/>alias paste=pbpaste<br/>alias copy=pbcopy</span></pre><p id="83ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，您可以运行如下命令:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="716e" class="ma mb it lw b gy mc md l me mf">paste &gt; file        # paste clipboard into a file<br/>cat file | copy     # copy file contents to clipboard<br/>paste | croc send  # send clipboard contents using croc</span></pre><h1 id="bc81" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">2.鳄鱼</h1><p id="87fa" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">Croc是一个有用的跨平台工具，可以在两台计算机之间安全地传输数据(比如文件或文本)。不用再发送zip文件或者摆弄Dropbox——如果你需要发送文件给某人，在大多数情况下，croc更简单(可能)更快。</p><p id="11f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">唯一的要求是发送方和接收方的系统上都安装了croc。Croc可能可以从您最喜欢的包管理器获得——更具体的安装说明可以在项目的<a class="ae ng" href="https://github.com/schollz/croc" rel="noopener ugc nofollow" target="_blank"> github页面</a>上找到。</p><p id="af0b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是Croc的使用示例:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2ec5" class="ma mb it lw b gy mc md l me mf">$ croc send file.dat<br/>Sending 'file.dat' (0 B)<br/>Code is: &lt;code-phrase&gt;</span></pre><p id="eb01" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第二台计算机上，键入<code class="fe nd ne nf lw b">croc &lt;code-phrase&gt;</code>将提示您接受传输的数据，如下所示:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5198" class="ma mb it lw b gy mc md l me mf">Accept 'file.dat' (0 B)? (Y/n)</span></pre><p id="e6c9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用croc发送文本同样简单——您可以通过管道将文本输入到croc中，也可以手动键入文本，如下所示:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8eeb" class="ma mb it lw b gy mc md l me mf">$ echo "Hello from croc!" | croc send<br/># or<br/>$ croc send --text "Hello from croc!"</span></pre><p id="0f04" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果这还不够，croc允许支持多种加密/哈希算法、可恢复传输和代理！在我看来，croc是一个非常有用的工具，可以放在你的工具箱里。</p><h1 id="952b" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">3.佐西德</h1><p id="75f2" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">Zoxide与我之前提到的其他工具有所不同。它旨在通过帮助您更快地遍历文件系统来改善命令行体验。</p><p id="6c58" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Zoxide允许你进入一个目录而不用给出完整的路径。相反，Zoxide会考虑你过去的历史，并根据你提供的名字来判断你想去哪里。本质上，佐希德只是一个“更聪明的”<code class="fe nd ne nf lw b">cd</code>。</p><p id="636b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Zoxide支持所有主要的shells，并且可能从您最喜欢的包管理器中获得。你可以在它的<a class="ae ng" href="https://github.com/ajeetdsouza/zoxide" rel="noopener ugc nofollow" target="_blank"> Github页面</a>上找到安装说明和更高级的使用技巧。</p><p id="ae05" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有一个如何使用Zoxide的例子。注意:Zoxide提供了命令<code class="fe nd ne nf lw b">z</code>，但是由于肌肉记忆，我更喜欢别名它而不是<code class="fe nd ne nf lw b">cd</code>。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e4ce" class="ma mb it lw b gy mc md l me mf">$ z /opt/local/lib  # changes your directory like normal<br/>$ z ~               # jumps to home directory like normal<br/>$ z lib             # will automatically jump /opt/local/lib<br/>$ z ..              # go up one directory<br/>$ z l               # may also jump to /opt/local/lib</span></pre><p id="0a12" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用Zoxide时，运行<code class="fe nd ne nf lw b">z &lt;something&gt;</code>会根据Zoxide的匹配算法将目录更改为排名最高的选择。Zoxide既考虑了一个目录被访问的频率，也考虑了它上次被访问的时间。</p><p id="6257" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">比如多次进入目录<code class="fe nd ne nf lw b">/opt/local/lib</code>，就会增加它的“分数”。现在，如果你从你的主目录运行<code class="fe nd ne nf lw b">z lib</code>，Zoxide会直接把你带到<code class="fe nd ne nf lw b">/opt/local/lib</code>。事实上，你甚至不需要完全输入<code class="fe nd ne nf lw b">lib</code>。Zoxide使用模糊字符串匹配，所以即使运行<code class="fe nd ne nf lw b">z l</code>也能把你带到正确的地方。</p><p id="0b42" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我个人认为Zoxide很有用，因为它允许我跳转到不同项目的目录，而不必记住它们在我系统中的确切位置。只要我知道一个目录的名称(或者它的前3个字符)，我就可以到达那里。</p><h1 id="3a61" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">4.htop</h1><p id="2ea7" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">Htop是终端的资源监视器和进程管理器。</p><p id="bd53" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Htop可以使用你最喜欢的软件包管理器来安装。最新版本和源代码可以在它的<a class="ae ng" href="https://github.com/htop-dev/htop" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/e446423381d9ee668b18d691212af70c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IWiw_Ks36ZURR__37RttwA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ng" href="https://htop.dev/screenshots.html" rel="noopener ugc nofollow" target="_blank">https://htop.dev/screenshots.html</a>的htop官方截图</p></figure><p id="63d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是htop允许您做的事情的快速列表:</p><ul class=""><li id="36f4" class="ni nj it la b lb lc le lf lh nk ll nl lp nm lt nn no np nq bi translated">查看每个内核的CPU负载、内存使用情况(包括交换)、正常运行时间等</li><li id="a952" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">显示哪些进程使用了最高数量的CPU/内存</li><li id="ecd3" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">按名称或PID搜索流程</li><li id="a836" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">用你选择的中断终止进程(比如SIGINT，SIGKILL，SIGTERM等)</li></ul><p id="0420" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Htop同时支持键盘和鼠标——如果你不需要的话，就不必学习快捷键。此外，通过树形视图，您可以看到哪些进程是其他进程的子进程，这非常有趣。我主要使用htop来监控系统负载和杀死行为不当的进程(在我自己的系统和远程服务器上)。</p><h1 id="d6ae" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">5.引入线</h1><p id="01e2" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">Entr是一个实用程序，允许您在每次文件更改时重新运行命令。这允许您用一个简单的终端命令实现自己的ad-hoc实时重载服务器。Entr应该可以从你最喜欢的包管理器中获得(或者如果你想手动安装它，请看它的主页<a class="ae ng" href="https://eradman.com/entrproject/" rel="noopener ugc nofollow" target="_blank">这里</a>)。</p><p id="f574" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用entr的方法是在标准输入中提供一个文件名列表，以及每当这些文件之一发生变化时运行的命令。举例来说，假设我们有一个简单的Python项目，我们想在源代码发生变化时重新运行该程序。</p><p id="bdbc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这可以用一行代码来完成:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5b3c" class="ma mb it lw b gy mc md l me mf">$ find . -name *.py | entr python main.py</span></pre><p id="d251" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如上所述，<code class="fe nd ne nf lw b">find</code>命令用于生成当前目录中扩展名为<code class="fe nd ne nf lw b">py</code>的所有文件的列表，然后该列表通过管道传输到<code class="fe nd ne nf lw b">entr</code>，每当检测到其中一个文件发生变化时，它就会重新运行<code class="fe nd ne nf lw b">main.py</code>。</p><p id="97cd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们需要更复杂的行为，我们可以简单地添加一个Makefile并告诉entr要构建哪个目标。例如，给定一个假设的C项目，我们可能希望运行下面的代码，让Make处理重新编译C文件的复杂性。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1137" class="ma mb it lw b gy mc md l me mf">$ find src/ | entr make</span></pre><p id="542f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Entr还允许您在命令中使用已更改文件的名称。例如，运行<code class="fe nd ne nf lw b">ls | entr echo /_</code>将监控当前目录中的每个文件，并在检测到变化时打印出文件的路径。</p><p id="4086" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想了解更多关于entr的知识，可以查看主页<a class="ae ng" href="https://ls *.rb | entr -r ruby main.rb" rel="noopener ugc nofollow" target="_blank">这里</a>。您将找到更多的例子，以及特殊命令行标志的文档。</p><h1 id="48d1" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">6.fzf</h1><p id="6be3" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">我将用一个伟大的交互式实用程序来结束这篇文章。Fzf是一个模糊查找器，允许您从列表中交互式地选择一个选项。它还具有很好的外壳集成和可配置性。</p><p id="6f03" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Fzf可以从几乎所有的包管理器中获得，但是你也可以用git安装它(指令<a class="ae ng" href="https://github.com/junegunn/fzf" rel="noopener ugc nofollow" target="_blank">在这里</a>)。</p><p id="84e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">默认情况下，运行<code class="fe nd ne nf lw b">fzf</code>将为位于当前目录或其子目录中的每个文件显示一个交互式选择器(相当于<code class="fe nd ne nf lw b">find .</code>)。这本身就很有用——如果你想交互式地选择一个文件进行编辑，只需运行<code class="fe nd ne nf lw b">vim $(fzf)</code>。通过输入搜索词，可以缩小fzf提供的选择范围。然后，你可以按&lt;回车&gt;来选择选项。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/b1d213f5b2a4a963d845c04b5abed8f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*c2T2hNT7dy4-MdsyF6TslQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用fzf选择要编辑的文件</p></figure><p id="7178" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以使用fzf从任何列表中选择一个项目。使用fzf，您可以轻松地编写shell脚本，以交互方式检查git提交、选择要终止的进程、选择要安装的包等。可能性是无穷的，你可以在网上找到很多有用的脚本。</p><p id="e151" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面显示了来自<a class="ae ng" href="https://github.com/junegunn/fzf/wiki/examples#git" rel="noopener ugc nofollow" target="_blank"> fzf示例wiki </a>的<code class="fe nd ne nf lw b">fcoc</code>脚本。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/2bf2710a719a6c4109a9467acaa29fce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kdH-ddm_zkskn4chId738w.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用fzf检验git提交</p></figure><p id="062a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更不用说，fzf还有许多更高级的特性，比如命令的shell完成、预览窗口、vim/tmux集成等等。关于这些信息，我建议通读该项目的Github。</p><h1 id="4ecb" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">Git仓库</h1><div class="nx ny gp gr nz oa"><a href="https://github.com/schollz/croc" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">GitHub - schollz/croc:轻松安全地将东西从一台计算机发送到另一台计算机</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">这个项目得到了Github赞助商的支持。croc是一个工具，可以让任何两台计算机简单而安全地…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">github.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo ks oa"/></div></div></a></div><div class="nx ny gp gr nz oa"><a href="https://github.com/ajeetdsouza/zoxide" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">GitHub - ajeetdsouza/zoxide:更智能的cd命令。支持所有主要外壳。</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">zoxide是一个更智能的cd命令，灵感来自z和autojump。它会记住你最常使用的目录，所以…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">github.com</p></div></div><div class="oj l"><div class="op l ol om on oj oo ks oa"/></div></div></a></div><div class="nx ny gp gr nz oa"><a href="https://github.com/htop-dev/htop" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">GitHub - htop-dev/htop: htop -交互式流程查看器</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">htop是一个跨平台的交互式流程查看器。htop允许垂直滚动进程列表…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">github.com</p></div></div><div class="oj l"><div class="oq l ol om on oj oo ks oa"/></div></div></a></div><div class="nx ny gp gr nz oa"><a href="https://github.com/eradman/entr" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">GitHub - eradman/entr:当文件改变时运行任意命令</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">当文件改变时运行任意命令的工具。使用kqueue(2)或inotify(7)来避免轮询。主菜是…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">github.com</p></div></div><div class="oj l"><div class="or l ol om on oj oo ks oa"/></div></div></a></div><div class="nx ny gp gr nz oa"><a href="https://github.com/junegunn/fzf" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">GitHub - junegunn/fzf:命令行模糊查找器</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">fzf是一个通用的命令行模糊查找器。这是一个用于命令行的交互式Unix过滤器，可用于…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">github.com</p></div></div><div class="oj l"><div class="os l ol om on oj oo ks oa"/></div></div></a></div><h1 id="6c4a" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="2350" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">不要小看终端！命令行是一些最简单但最有用的工具的家园！</p></div></div>    
</body>
</html>