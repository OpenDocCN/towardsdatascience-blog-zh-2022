<html>
<head>
<title>Canonical Decomposition — A Forgotten Method for Time Series Cointegration and Beyond</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">典范分解——一种被遗忘的时间序列协整方法及其他</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/canonical-decomposition-a-forgotten-method-for-time-series-cointegration-and-beyond-4d1213396da1#2022-03-21">https://towardsdatascience.com/canonical-decomposition-a-forgotten-method-for-time-series-cointegration-and-beyond-4d1213396da1#2022-03-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="27ea" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将多个时间序列分解为静态和趋势关系。从头开始完整的 Python 代码。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e796e34008e620537acd2ce1b1b87664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F0oEOmfyrchHwvA_Ot7BhQ@2x.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4ab7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在处理多个非平稳时间序列时，协整是最重要的概念之一。对于那些不熟悉协整的人来说，简单来说，两个或多个时间序列的协整意味着它们之间存在一个平稳的线性组合。</p><p id="4ad4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">非平稳时间序列的问题是我们不能直接应用大多数统计工具，因为这些工具是为平稳数据设计的。然而，当存在协整时，我们拥有所有的统计机器来制作有意义的模型，并从我们的数据中获得进一步的见解。</p><p id="81c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">两个著名的协整方法是 Engle-Granger 方法和 Johansen 方法。在这两种方法中，实践中最常用的是 Johansen 方法。原因是恩格尔-格兰杰方法往往会产生虚假回归，但这超出了目前的故事。可以说 Johansen 方法是大多数统计软件包中最常用的协整方法。</p><p id="a5d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，在 Johansen 的第一篇关于协整的开创性论文(1988)之前 11 年，Box 和 Tiao 提出了一种称为规范分解的方法，我们将简称为 BTCD。这种方法很有趣，因为它不仅能发现协整关系，还能发现时间序列之间的趋势关系。事实上，有研究表明 BTCD 比约翰森方法更稳定，然而 BTCD 似乎已经被遗忘了。</p><p id="d973" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个故事中，我将解释 BTCD 背后的基本数学，并用 Python(从头开始)编写一个库，供你在下一个时间系列项目中使用。希望我们能让 BTCD 在协整方法中恢复其应有的地位。</p><h2 id="7b54" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">问题设置</h2><p id="d031" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我们要找到一个权重向量<em class="ms"> w </em>来形成多个时间序列的线性组合，得到的时间序列<em class="ms"> S </em>应该是平稳的。设<em class="ms"> p </em>为一个<em class="ms"> n </em>维向量，表示一个<em class="ms"> n </em>维时间序列(聚合多个 1D 时间序列)，形式上:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/740532105c5718a35d3399a800375190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*WcJ_OU7Hb1yB785bQZQ_pA@2x.jpeg"/></div></figure><h2 id="83b9" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">基础数学</h2><p id="f37f" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">BTCD 的基础是 Box 和 Tiao 定义的可预测性的概念。为了说明这个概念，让我们考虑一维时间序列<em class="ms"> p </em>的情况。考虑一个模型<em class="ms"> q </em>在时间<em class="ms"> t: </em>预测<em class="ms"> p </em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/dd7183dd5ec59a3fb7373c31ca5bd5d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/1*IB6iDAWcunuF9MiJHcLJfQ@2x.jpeg"/></div></figure><p id="b93b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中，ε是均值为零的 i.i.d。模型<em class="ms"> q </em>具有来自<em class="ms"> k </em>先前滞后、<em class="ms"> t </em> -1、<em class="ms"> t </em> -2、…、<em class="ms"> t </em> - <em class="ms"> k </em>的信息，即</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/5f1f8429ff1228c07604593773103a4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0NEl8IrZLAmc0eTl-XJ0Og@2x.jpeg"/></div></div></figure><p id="118f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在最简单的情况下，模型<em class="ms"> q </em>是使用 AR(1)规范构建的，这是一个线性模型，其中<em class="ms"> k </em> =1。但是保留<em class="ms"> q </em>作为<em class="ms"> p </em>的抽象模型更方便。</p><p id="3c6b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对第一个等式的两边求平方，并取我们得到的期望值:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/7ef2d6c85ec6725d4e28693c3efc5e86.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*80wD1zqjAPpkC4oanhmEOg@2x.jpeg"/></div></figure><p id="d198" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Box 和 Tiao 将可预测性定义为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/fc29d8c9e72a8c0543cf088356be0986.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*Kk2OISqpKgaK_8_YYSeoYQ@2x.jpeg"/></div></figure><p id="e935" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到，当可预测性较大时<em class="ms"> p </em>优于ε，这意味着模型<em class="ms"> q </em>和<em class="ms"> p </em>之间的残余噪声较小，因此<em class="ms"> p </em>是可预测的。当可预测性较小时，ε支配<em class="ms"> p，</em>意味着<em class="ms"> p </em>几乎是具有平稳均值和方差的纯噪声。</p><p id="4d9d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们转向<em class="ms"> n </em>维情况，其中<em class="ms"> p </em>、<em class="ms"> q </em>和ε现在是<em class="ms"> n </em>维向量。类似于一维情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/5db66f87a182d3b141f264b5d87fb93b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*VwfXPNBPDV3MIP61NAkeow@2x.jpeg"/></div></figure><p id="9aed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中<em class="ms"> T </em>上标表示转置，注意以上等式中的所有项都是矩阵。</p><p id="300f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了获得分解关系，我们使用权重向量<em class="ms"> w </em>将可预测性表示为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/d750c4d9e6f243378114c8e21731a681.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*L3otd0-jXFmfRT_SIt6OvQ@2x.jpeg"/></div></figure><p id="c9fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用矩阵:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/afb22b552bd6f378ec92eda52d9aa7ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*hRb8iGLHBjQ_CVmAFQzMDA@2x.jpeg"/></div></figure><p id="ea54" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在的问题是找到<em class="ms"> w </em>使得可预测性λ最小/最大。</p><p id="70e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了解决优化问题，我们引入了一个巧妙的变量变化:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/c7244ec718f0589b26bc7c5b459093ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*70pZzjFnhgLMqzhnoxWQww@2x.jpeg"/></div></figure><p id="875e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">(最后一个等式来自于 B 的平方根是对称的这一事实)并且</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/f3a99319970e99f8fbbf837672bab84c.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*tvj_QNBSzEIgAu3vY7nptQ@2x.jpeg"/></div></figure><p id="0dcf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在此变量变化下，我们的权重向量为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/d9b1cf847ef7c016121f3c51d861d9a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/format:webp/1*D3amUQTkJNTdUjwqdArAqA@2x.jpeg"/></div></figure><p id="b83e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以将可预测性表示为标准瑞利商:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/91e7c9b8b633fb53979af9fc4e1cb66f.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*qIX7cQWntWvVCdmhsT6QDA@2x.jpeg"/></div></figure><p id="5c83" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这很好，因为优化问题现在是矩阵<em class="ms"> D </em>的特征值问题。对应于最小/最大特征值的特征向量最小化/最大化λ。</p><p id="939c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实上，如果我们将所有特征值从最小到最大排序，它们相应的特征向量(乘以“V”的平方根倒数)将生成从最不可预测(平稳)到最可预测(趋势)的时间序列。这就是为什么 Box 和 Tiao 把这种方法命名为“规范分解”。</p><h2 id="c761" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">编码规范分解</h2><p id="d53b" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我们需要解决的第一件事是如何计算二元乘积的期望值，因为矩阵<em class="ms"> A </em>和<em class="ms"> B </em>将需要这个。设<em class="ms"> v </em>为一个<em class="ms"> n </em>维向量(1D 数组)如果有<em class="ms"> v </em>的<em class="ms"> t </em>个观测值，这个数据可以表示为一个矩阵<em class="ms"> V </em> (2D 数组)，其中每行代表一个观测值，即形状为(<em class="ms"> t </em>，<em class="ms"> n </em>)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/9b59f6a2726d392331e88cf5f2e380da.png" data-original-src="https://miro.medium.com/v2/resize:fit:414/format:webp/1*iF-sJOoJleqf-W_g22mPHw@2x.jpeg"/></div></figure><p id="e813" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么二元乘积的期望值可以从样本中估计出来，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/99fcada484d6f14f553085721ec2dcc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*4mLbu3NSYPWW044Koy3SYQ@2x.jpeg"/></div></figure><p id="594b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对此进行编码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="a797" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们可以求解<em class="ms"> B </em>的平方根的倒数，其中“p_mat”是向量<em class="ms"> p </em>的观测值矩阵。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="0505" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们需要计算出<em class="ms"> A </em>，为此我们需要建立模型的方式<em class="ms"/>q .【Box】和 Tiao 使用普通最小二乘(OLS)回归。然而，我们在这里允许一些灵活性，并且只为这样的模型建立一个接口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="a8eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你仔细看看这个接口，它正是我们都喜欢的 Scikit-learn 的接口，由 Scikit-learn 和许多其他库的所有回归模型实现。如果您想使用具有不同接口的不同库，您可以用 fit 和 predict 方法将它包装在一个类中，效果也一样。</p><p id="13a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接口而非具体实现背后的想法是能够以灵活的方式切换回归模型，而无需对 BTCD 的实际代码进行任何更改。Box 和 Tiao 使用了 OLS，但也可以尝试一些不同的东西，比如弹性网，甚至是非线性模型？这取决于你的实验。</p><p id="50a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下面的代码中，为了可读性，参数<em class="ms"> k </em>将被重命名为“max_lag”。</p><p id="c4a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了得到模型<em class="ms"> q </em>，我们需要使用所有时间序列的滞后版本(直到“max_lag”)来预测每个时间序列的下一步。换句话说，对于每个时间序列(“p_mat”的每一列)，我们需要形成一个包含滞后时间序列的特征向量“X”，然后形成由 X 的 T-max _ 滞后观测值组成的矩阵 X，X 的形状为(T-max _ 滞后，最大 _ 滞后* n)。回归 y 的目标只是去掉了第一个“最大滞后”值的时间序列，所以它的形状是(T-max 滞后)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="3651" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在求特征值问题的解</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="af4d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，将实现我们刚刚编码的所有内容的函数，即，将被调用来进行实际分解的函数，以及用于规范分解结果的<em class="ms">数据类</em>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="7af7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们为 BTCD 把它放在一个干净的图书馆里。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="8a72" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">合成时间序列示例</h2><p id="1cc9" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">让我们生成<em class="ms"> n 个</em>离散采样的相关布朗运动，以生成我们的“p_mat”用于演示目的。要生成此类数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="9a18" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们生成数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/2de1a57d7f1c6bfa6205840d5e9cf2ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OB4OT2q-9Ri6ujtP2cU3Qg@2x.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b9ed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">给定“p_mat ”,其中每一列是一个时间序列，我们的权重向量<em class="ms"> w </em>,结果时间序列<em class="ms"> S </em>可以用以下公式计算:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="f26a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后是使用 Sklearn OLS 实现“RegressionModel”接口的规范分解的例子，没有截距，max_lag=1</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/edf7e130783f7334b487eb17c83f52b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tisHGU9Ol1clJxFn8yGZlQ@2x.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="9cdd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了说明使用另一种类型的回归是多么容易，现在让我们使用 Sklearn 的 elastic net 并将 max_lag 设置为 9。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/58a8310a3aa6089f0dc9aa0f361803b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nN4wvs681Kqrb-6ZUxHS-w@2x.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="e47a" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">最后的话</h2><p id="171f" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我们已经成功地为 BTCD 编码了一个库，在我看来，它填补了大多数时间序列统计库中的一个空白。现在你除了 Engle-Granger 和 Johansen，又多了一个协整分析的工具。</p><p id="4073" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为回归模型创建接口而不是直接对其进行编码的主要目的是让您使用和微调最适合您的数据的回归模型。然而，如果不想修补这一点，那么使用 OLS 作为框和条原本打算。</p><p id="e9cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">协整方法和 BTCD 的主要问题是它们容易过度拟合。这就是为什么对数据使用合适的回归模型很重要。如果你没有注意到我们使用相关随机行走(离散布朗运动)作为例子，事实上，这种数据的分解是过度拟合的证明。任何布朗运动的非平凡线性组合(即使它们是相关的)都是一个重新标度的布朗运动，它既不是平稳的，也不是趋势性的，因此这种组合不存在协整。这是非常重要的，尤其是当协整被用来做预测时，比如在统计套利交易应用中。遗憾的是，这些方法中的大多数会过度拟合数据，但是希望你能找到最适合你的回归模型。</p><p id="1aa3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可预测性值λ依赖于回归模型，因此在用不同回归模型计算的λ之间没有有意义的比较，因此它不是一个绝对的度量，仅在使用相同回归模型时对比较有意义。</p><h2 id="02d5" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">参考</h2><p id="447e" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">[1] G. E. P. Box 和 G. C. Tiao，<a class="ae nk" href="http://..." rel="noopener ugc nofollow" target="_blank">对多个时间序列的规范分析</a> (1977 年)，Biometrika 64，2，第 355-65 页</p><p id="9506" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[2] R .，D. Orden，M. Yang 和 L. Fisher，【VEC 协整向量的 Box-Tiao 和 Johansen 规范估计量的比较(1)模型 (1994)，计量经济学杂志 64，3–27</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="b71b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望这个故事对你有用。如果我错过了什么，请让我知道。如果你想知道更多这样的故事，请关注我的<a class="ae nk" href="https://medium.com/@diego-barba" rel="noopener">媒体</a>。</p><div class="ns nt gp gr nu nv"><a href="https://medium.com/subscribe/@diego-barba" rel="noopener follow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">每当迭戈·巴尔巴出版时，就收到一封电子邮件。</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">每当迭戈·巴尔巴出版时，就收到一封电子邮件。注册后，如果您还没有，您将创建一个中型帐户…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">medium.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj ks nv"/></div></div></a></div><p id="d625" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">喜欢这个故事吗？通过我的推荐链接成为媒体会员，可以无限制地访问我的故事和许多其他内容。</p><div class="ns nt gp gr nu nv"><a href="https://medium.com/@diego-barba/membership" rel="noopener follow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">通过我的推荐链接加入 Medium-Diego Barba</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">medium.com</p></div></div><div class="oe l"><div class="ok l og oh oi oe oj ks nv"/></div></div></a></div></div></div>    
</body>
</html>