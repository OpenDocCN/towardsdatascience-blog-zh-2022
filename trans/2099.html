<html>
<head>
<title>An In-Depth Tutorial to Python Decorators That You Can Actually Use</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个深入的Python装饰者教程，你可以实际使用</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/an-in-depth-tutorial-to-python-decorators-that-you-can-actually-use-1e34d3d2d305#2022-05-11">https://towardsdatascience.com/an-in-depth-tutorial-to-python-decorators-that-you-can-actually-use-1e34d3d2d305#2022-05-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6782" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入Python的内部</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5ddd0ddaf96e73aa0d0e919d9a646291.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w6t1OO4Owzi8Ttk3bE45Qw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/photo/colorful-abstract-wallpaper-5022849/" rel="noopener ugc nofollow" target="_blank">菲奥娜艺术</a></p></figure><h2 id="6339" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">介绍</h2><p id="9960" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">使用Python和许多其他语言可以做的一件神奇的事情是修饰函数。装饰者可以修改函数的输入、输出以及函数本身的行为。最棒的是，您只需一行代码就可以完成所有这些操作，根本不需要修改函数语法！</p><p id="c409" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">要了解decoratorss如何工作以及如何为自己创建一个decorator，您需要了解一些重要的Python概念。</p><p id="c4f3" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">因此，在我们开始编写decorators之前，我们将深入学习一些Python的内部知识，比如作用域和闭包。如果你熟悉这些概念，请跳过它们，到第5部分，所有的乐趣开始了！</p><div class="mt mu gp gr mv mw"><a href="https://ibexorigin.medium.com/membership" rel="noopener follow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">通过我的推荐链接加入Medium-BEXGBoost</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">获得独家访问我的所有⚡premium⚡内容和所有媒体没有限制。支持我的工作，给我买一个…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">ibexorigin.medium.com</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk ks mw"/></div></div></a></div><p id="e09d" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">获得由强大的AI-Alpha信号选择和总结的最佳和最新的ML和AI论文:</p><div class="mt mu gp gr mv mw"><a href="https://alphasignal.ai/?referrer=Bex" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">阿尔法信号|机器学习的极品。艾总结的。</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">留在循环中，不用花无数时间浏览下一个突破；我们的算法识别…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">alphasignal.ai</p></div></div><div class="nf l"><div class="nl l nh ni nj nf nk ks mw"/></div></div></a></div></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h2 id="a3ee" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">函数是对象</h2><p id="afb8" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">您喜欢Python的一个原因是它能够将任何东西表示为对象，函数也不例外。对于第一次阅读这篇文章的人来说，将一个函数作为参数传递给另一个函数可能看起来很奇怪，但是这样做是完全合法的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="5803" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">作为对象，函数与以下内容完全相同:</p><ul class=""><li id="e16e" class="nv nw it lx b ly mo mb mp li nx lm ny lq nz mn oa ob oc od bi translated">用线串</li><li id="17cb" class="nv nw it lx b ly oe mb of li og lm oh lq oi mn oa ob oc od bi translated">整数和浮点数</li><li id="b0e2" class="nv nw it lx b ly oe mb of li og lm oh lq oi mn oa ob oc od bi translated">熊猫数据帧</li><li id="7bc0" class="nv nw it lx b ly oe mb of li og lm oh lq oi mn oa ob oc od bi translated">列表、元组、字典</li><li id="89ee" class="nv nw it lx b ly oe mb of li og lm oh lq oi mn oa ob oc od bi translated">像<code class="fe oj ok ol om b">os</code>、<code class="fe oj ok ol om b">datatime</code>、<code class="fe oj ok ol om b">numpy</code>这样的模块</li></ul><p id="41ed" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">您可以将函数赋给新变量，并使用它来调用函数:</p><pre class="kj kk kl km gt on om oo op aw oq bi"><span id="fec0" class="kz la it om b gy or os l ot ou">&gt;&gt;&gt; new_func = my_func<br/>&gt;&gt;&gt; new_func()<br/>Printing the function's argument</span></pre><p id="786c" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">现在这个变量也包含了函数的属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="4fc0" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">您还可以将每个函数存储在其他对象中，如列表和字典，并调用它们:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h2 id="d4fe" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">范围</h2><p id="88e8" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">考虑鲍勃和约伯之间的对话:</p><ul class=""><li id="399f" class="nv nw it lx b ly mo mb mp li nx lm ny lq nz mn oa ob oc od bi translated">鲍勃:“乔恩，你昨天为什么没来上课？”</li><li id="f906" class="nv nw it lx b ly oe mb of li og lm oh lq oi mn oa ob oc od bi translated">乔恩:“我感冒了……”</li></ul><p id="ee87" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">不是最好的故事，但当鲍勃问乔恩昨天缺席的原因时，我们知道他指的是站在他旁边的乔恩，而不是某个在另一个国家的随机乔恩。作为人类不难注意到这一点，但是编程语言使用一种叫做<strong class="lx iu"> scope </strong>的东西来告诉我们在程序中引用的是哪个名字。</p><p id="3d91" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在Python中，名字可以是变量、函数、模块名等。</p><p id="e4ce" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">考虑这两个变量:</p><pre class="kj kk kl km gt on om oo op aw oq bi"><span id="37a8" class="kz la it om b gy or os l ot ou">&gt;&gt;&gt; a = 24<br/>&gt;&gt;&gt; b = 42<br/>&gt;&gt;&gt; print(a)<br/>24</span></pre><p id="b7a3" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在这里，<code class="fe oj ok ol om b">print</code>毫不费力地告诉我们，我们指的是我们刚刚定义的<code class="fe oj ok ol om b">a</code>。现在考虑一下这个:</p><pre class="kj kk kl km gt on om oo op aw oq bi"><span id="6fb4" class="kz la it om b gy or os l ot ou">&gt;&gt;&gt; def foo():<br/>...     a = 100<br/>... <!-- -->    print(a)</span></pre><p id="7418" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">如果我们运行<code class="fe oj ok ol om b">foo</code>，你认为会发生什么？它会印24张还是100张？</p><pre class="kj kk kl km gt on om oo op aw oq bi"><span id="3c20" class="kz la it om b gy or os l ot ou">&gt;&gt;&gt; foo()<br/>100</span></pre><p id="0ac1" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">Python如何区分我们在函数开头定义的<code class="fe oj ok ol om b">a</code>？这就是作用域变得有趣的地方，因为我们引入了不同的作用域层:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/a85c94d89f8f259361033ee713aeb342.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*UEQJyMQ3zOONJcaXqz65lQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="2459" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">上图显示了这个小脚本的范围:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="8586" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">全局范围是您的脚本/程序的整体范围。与<code class="fe oj ok ol om b">a</code>和<code class="fe oj ok ol om b">b</code>具有相同缩进级别的变量、函数、模块将在全局范围内。例如，<code class="fe oj ok ol om b">foo</code>函数在全局范围内，但是它的变量<code class="fe oj ok ol om b">a</code>在<code class="fe oj ok ol om b">foo</code>的局部范围内。</p><p id="2b50" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在一个全局范围内，可以有许多局部范围。例如,<code class="fe oj ok ol om b">for</code>循环和列表理解和函数中的变量在它们的代码块中是局部的，不能从全局范围访问。</p><p id="9b78" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在<code class="fe oj ok ol om b">global</code>之外还有一个更大的范围级别:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/b3592ba265db3fb6607c659fd74b32a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MC0f-coWkUv0BgTWZNU6OQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="2aa4" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">内置范围包含您用<code class="fe oj ok ol om b">Python</code>、<code class="fe oj ok ol om b">pip</code>或<code class="fe oj ok ol om b">conda</code>安装的所有模块和包。</p><p id="8a02" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">现在，让我们探讨另一种情况。在我们的<code class="fe oj ok ol om b">foo</code>函数中，我们想要修改全局<code class="fe oj ok ol om b">a</code>的值。我们希望它是一个字符串，但是如果我们在<code class="fe oj ok ol om b">foo</code>里面写<code class="fe oj ok ol om b">a = 'some text'</code>，Python将会创建一个新的变量而不改变全局<code class="fe oj ok ol om b">a</code>。</p><p id="bc00" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">Python为我们提供了一个关键字，让我们指定我们引用的是<code class="fe oj ok ol om b">global</code>范围内的名称:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="cca1" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">编写<code class="fe oj ok ol om b">global &lt;name&gt;</code>将让我们修改<code class="fe oj ok ol om b">global</code>范围内名称的值。</p><p id="0a62" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">顺便说一句，坏消息😁上图中，我省略了一个级别的范围。在<code class="fe oj ok ol om b">global</code>和<code class="fe oj ok ol om b">local</code>之间，还有一层我们没有覆盖:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/81892735bd198004afc69fd4471928d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*8Ob5okJsYSqT2Q4ukbGaCQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="2413" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">当我们有嵌套函数时，作用域开始发挥作用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="e782" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在嵌套函数<code class="fe oj ok ol om b">outer</code>中，我们首先创建一个名为<code class="fe oj ok ol om b">my_var</code>的变量，并将其赋给字符串<code class="fe oj ok ol om b">Python</code>。然后我们决定创建一个新的<code class="fe oj ok ol om b">inner</code>函数，并想给<code class="fe oj ok ol om b">my_var</code>赋一个新值——<code class="fe oj ok ol om b">Data Science</code>，并打印出来。但是如果我们运行它，我们会看到<code class="fe oj ok ol om b">my_var</code>仍然被分配给‘Python’。我们不能使用<code class="fe oj ok ol om b">global</code>关键字，因为<code class="fe oj ok ol om b">my_var</code>不在全局范围内。</p><p id="8ca5" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">对于这种情况，您可以使用<code class="fe oj ok ol om b">nonlocal</code>关键字来访问外部函数(非本地)范围内的所有名称，而不是<code class="fe oj ok ol om b">global</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="65ff" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">总之，作用域告诉Python解释器在程序中何处寻找名字。在单个脚本/程序中可以有四个级别的范围:</p><ul class=""><li id="c5ae" class="nv nw it lx b ly mo mb mp li nx lm ny lq nz mn oa ob oc od bi translated">内置:Python安装的所有包名，<code class="fe oj ok ol om b">pip</code>和<code class="fe oj ok ol om b">conda</code></li><li id="422f" class="nv nw it lx b ly oe mb of li og lm oh lq oi mn oa ob oc od bi translated">全局:一般范围，脚本中没有缩进的所有名称</li><li id="bca5" class="nv nw it lx b ly oe mb of li og lm oh lq oi mn oa ob oc od bi translated">Local:包含代码块中的局部变量，如函数、循环、列表理解等。</li><li id="51dc" class="nv nw it lx b ly oe mb of li og lm oh lq oi mn oa ob oc od bi translated">非局部:在嵌套函数的情况下，在<code class="fe oj ok ol om b">global</code>和<code class="fe oj ok ol om b">local</code>之间的一个额外的范围级别</li></ul></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h2 id="79ca" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">关闭</h2><p id="02e9" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在我解释装饰者是如何工作的之前，我们还需要谈谈闭包。让我们从一个例子开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="b768" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们在<code class="fe oj ok ol om b">foo</code>中创建一个嵌套函数<code class="fe oj ok ol om b">bar</code>并返回它。<code class="fe oj ok ol om b">bar</code>尝试打印数值<code class="fe oj ok ol om b">of</code> x:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="ad4e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">当我们写<code class="fe oj ok ol om b">var = foo()</code>的时候，我们把<code class="fe oj ok ol om b">bar</code>的功能分配给了<code class="fe oj ok ol om b">var</code>。现在<code class="fe oj ok ol om b">var</code>可以用来调用<code class="fe oj ok ol om b">bar</code>。当我们调用它时，它打印出42。</p><pre class="kj kk kl km gt on om oo op aw oq bi"><span id="7d9c" class="kz la it om b gy or os l ot ou">&gt;&gt;&gt; var()<br/>42</span></pre><p id="7cd3" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">但是等一下，<code class="fe oj ok ol om b">var</code>怎么会知道<code class="fe oj ok ol om b">x</code>的事情呢？<code class="fe oj ok ol om b">x</code>是定义在<code class="fe oj ok ol om b">foo</code>的范围内，而不是<code class="fe oj ok ol om b">bar</code>的范围内，你会认为<code class="fe oj ok ol om b">x</code>在<code class="fe oj ok ol om b">foo</code>的范围外是无法访问的。这就是闭包的由来。</p><blockquote class="oy oz pa"><p id="3fc4" class="lv lw pb lx b ly mo ju ma mb mp jx md pc mq mf mg pd mr mi mj pe ms ml mm mn im bi translated">闭包是一个函数的内置内存，它包含函数运行所需的所有非本地名称(在一个元组中)!</p></blockquote><p id="fc9a" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">所以，当<code class="fe oj ok ol om b">foo</code>返回<code class="fe oj ok ol om b">bar</code>时，它附加了所有非本地变量<code class="fe oj ok ol om b">bar</code>需要在<code class="fe oj ok ol om b">foo</code>的范围之外运行。您可以使用<code class="fe oj ok ol om b">.__closure__</code>属性访问函数的闭包:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="be56" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">一旦您以元组的形式访问函数的闭包，它将包含名为<code class="fe oj ok ol om b">cells</code>的元素，该元素具有单个非局部参数的值。闭包内可以有函数需要的任意多个单元格:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="559d" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在上面的例子中，变量<code class="fe oj ok ol om b">x, y, z</code>是<code class="fe oj ok ol om b">child</code>的非局部变量，所以它们被添加到函数的闭包中。任何其他名字如<code class="fe oj ok ol om b">value</code>和<code class="fe oj ok ol om b">outside</code>都不在闭包中，因为它们不在非局部范围内。</p><p id="a2b2" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">现在，考虑这个更棘手的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="c198" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们创建一个<code class="fe oj ok ol om b">parent</code>函数，它接受一个参数和一个嵌套函数<code class="fe oj ok ol om b">child</code>，后者打印传递给<code class="fe oj ok ol om b">parent</code>的任何值。我们用<code class="fe oj ok ol om b">var</code>(‘dummy’)调用<code class="fe oj ok ol om b">parent</code>，并将结果赋给<code class="fe oj ok ol om b">func</code>。如果我们称之为:</p><pre class="kj kk kl km gt on om oo op aw oq bi"><span id="0dc5" class="kz la it om b gy or os l ot ou">&gt;&gt;&gt; func()<br/>dummy</span></pre><p id="22b6" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">不出所料，它打印出了‘dummy’。现在让我们删除<code class="fe oj ok ol om b">var</code>并再次调用<code class="fe oj ok ol om b">func</code>:</p><pre class="kj kk kl km gt on om oo op aw oq bi"><span id="6f58" class="kz la it om b gy or os l ot ou">&gt;&gt;&gt; # Delete 'var'<br/>&gt;&gt;&gt; del var</span><span id="5deb" class="kz la it om b gy pf os l ot ou">&gt;&gt;&gt; # call func again<br/>&gt;&gt;&gt; func()<br/>dummy</span></pre><p id="c23e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">它仍然打印出“dummy”。为什么？</p><p id="27e4" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">你猜对了，它被添加到闭包里了！因此，当一个来自作用域外层的值被添加到闭包时，它将保持不变，即使我们删除了原始值！</p><pre class="kj kk kl km gt on om oo op aw oq bi"><span id="f907" class="kz la it om b gy or os l ot ou">&gt;&gt;&gt; func.__closure__[0].cell_contents</span><span id="1541" class="kz la it om b gy pf os l ot ou">‘dummy’</span></pre><p id="7ac2" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">如果我们不删除<code class="fe oj ok ol om b">var</code>并改变它的值，闭包仍将包含它的旧值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="f3df" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">当我们在下一节讨论装饰者时，这个概念将会很重要。</p><p id="1562" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">让我们回顾一些概念，以确保您理解:</p><ul class=""><li id="66cc" class="nv nw it lx b ly mo mb mp li nx lm ny lq nz mn oa ob oc od bi translated">闭包是嵌套函数的内部内存，它包含存储在元组中的所有非局部变量。</li><li id="f234" class="nv nw it lx b ly oe mb of li og lm oh lq oi mn oa ob oc od bi translated">一旦一个值存储在闭包中，它就可以被访问，但是如果原始值被删除或修改，它就不能被覆盖</li><li id="a32e" class="nv nw it lx b ly oe mb of li og lm oh lq oi mn oa ob oc od bi translated">嵌套函数是在另一个函数中定义的函数，遵循以下一般模式:</li></ul><pre class="kj kk kl km gt on om oo op aw oq bi"><span id="d085" class="kz la it om b gy or os l ot ou">&gt;&gt;&gt; def parent(arg):<br/>    <br/>...     def child():<br/>...        print(arg)<br/>...    <br/>...    return child</span></pre></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h2 id="99a3" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">最后，装修工</h2><blockquote class="oy oz pa"><p id="398b" class="lv lw pb lx b ly mo ju ma mb mp jx md pc mq mf mg pd mr mi mj pe ms ml mm mn im bi translated">装饰器是修改另一个函数的函数。他们可以改变函数的输入、输出甚至行为。</p></blockquote><p id="8bb8" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">让我们从一个非常简单的装饰开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="f1dc" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">现在，我们创建一个函数，它对传递的任何参数求平方，我们用<code class="fe oj ok ol om b">add_one</code>来修饰它。<code class="fe oj ok ol om b">add_one</code>将传递函数的参数加1:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="cfae" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">要将函数用作装饰器，只需将<code class="fe oj ok ol om b">@ symbol</code>放在函数定义的正上方，后面跟着装饰函数的名称。当我们将5传递给修饰过的<code class="fe oj ok ol om b">square</code>函数时，它没有返回25，而是产生了36，因为<code class="fe oj ok ol om b">add_one</code>接受了<code class="fe oj ok ol om b">square</code>的参数，即5，并给它加1，然后将其插回<code class="fe oj ok ol om b">square</code>:</p><pre class="kj kk kl km gt on om oo op aw oq bi"><span id="546d" class="kz la it om b gy or os l ot ou">&gt;&gt;&gt; square(10)<br/>121</span></pre><p id="d35a" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">现在，让我们仔细看看<code class="fe oj ok ol om b">add_one.</code></p><p id="e1c4" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">首先，让我们从<code class="fe oj ok ol om b">add_one</code>开始，它只返回传递给它的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="fe18" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">为了让我们的装饰器返回一个修改过的函数，定义一个嵌套函数来返回通常是有帮助的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="d047" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们的装潢师仍然无所事事。在<code class="fe oj ok ol om b">add_one</code>内部，我们定义了一个嵌套的<code class="fe oj ok ol om b">child</code>函数。<code class="fe oj ok ol om b">child</code>只接受一个参数并调用传递给<code class="fe oj ok ol om b">add_one</code>的任何函数。然后，<code class="fe oj ok ol om b">add_one</code>返回<code class="fe oj ok ol om b">child</code>。</p><blockquote class="oy oz pa"><p id="3ca2" class="lv lw pb lx b ly mo ju ma mb mp jx md pc mq mf mg pd mr mi mj pe ms ml mm mn im bi translated">在这个嵌套的<code class="fe oj ok ol om b"><em class="it">child</em></code>函数的例子中，我们假设传递给<code class="fe oj ok ol om b"><em class="it">add_one</em></code>的<code class="fe oj ok ol om b"><em class="it">func</em></code>与<code class="fe oj ok ol om b"><em class="it">child</em></code>的参数数量完全相同。</p></blockquote><p id="d531" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">现在，我们可以让所有的魔法都发生在<code class="fe oj ok ol om b">child</code>函数内部。我们不是简单地调用<code class="fe oj ok ol om b">func</code>，而是想修改它的参数，给它们加1:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="835d" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">通知<code class="fe oj ok ol om b">func(a + 1)</code>？它调用传递给<code class="fe oj ok ol om b">add_one</code>的任何参数，并在参数中加1。这一次，我们将覆盖<code class="fe oj ok ol om b">square</code>，而不是创建一个新变量来存储<code class="fe oj ok ol om b">child</code>:</p><pre class="kj kk kl km gt on om oo op aw oq bi"><span id="bf19" class="kz la it om b gy or os l ot ou">&gt;&gt;&gt; square = add_one(square)<br/>&gt;&gt;&gt; square(5)<br/>36</span></pre><p id="6935" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">现在，当我们经过5时，它返回36而不是25。</p><p id="417a" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">即使我们覆盖了它，它如何使用<code class="fe oj ok ol om b">square</code>功能？好在我们学习了闭包，因为旧的<code class="fe oj ok ol om b">square</code>现在在<code class="fe oj ok ol om b">child</code>的闭包里面:</p><pre class="kj kk kl km gt on om oo op aw oq bi"><span id="bcd7" class="kz la it om b gy or os l ot ou">&gt;&gt;&gt; square.__closure__[0].cell_contents<br/>&lt;function __main__.square(a)&gt;</span></pre><p id="ab5a" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">至此，我们的<code class="fe oj ok ol om b">add_one</code>函数已经可以用作装饰器了。我们可以把<code class="fe oj ok ol om b">@add_one</code>放在<code class="fe oj ok ol om b">square</code>的正上方，看看神奇的事情发生了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h2 id="0153" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">装饰者的真实例子</h2><p id="4528" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">我想如果我不向你展示如何创建一个<code class="fe oj ok ol om b">timer</code>装饰器，那将是一个遗憾:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="2bf2" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这一次，注意我们是如何使用<code class="fe oj ok ol om b">*args</code>和<code class="fe oj ok ol om b">**kwargs</code>的。当我们不知道函数中位置参数和关键字参数的确切数目时，就使用它们，这种情况下很好，因为我们可以在任何类型的函数上使用<code class="fe oj ok ol om b">timer</code>。</p><p id="f8fd" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">现在，您可以在任何函数上使用这个装饰器来确定它运行多长时间。无重码！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="a3ad" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">下一个非常有用的装饰器是缓存装饰器。缓存装饰器对于计算量大的函数非常有用，你可能会用相同的参数多次调用这些函数。缓存闭包中每个函数调用的结果将使我们能够在修饰函数被调用时立即返回结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="b02f" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在main，<code class="fe oj ok ol om b">cache</code>函数中，我们希望创建一个字典，将元组中的所有参数存储为键及其结果。缓存字典将如下所示:</p><pre class="kj kk kl km gt on om oo op aw oq bi"><span id="a5d1" class="kz la it om b gy or os l ot ou">cache = {<br/>    (arg1, arg2, arg3): func(arg1, arg2, arg3)<br/>}</span></pre><p id="6122" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们可以使用参数元组作为键，因为元组是不可变的对象。</p><p id="8481" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">现在，让我们看看如果我们用<code class="fe oj ok ol om b">cache</code>和<code class="fe oj ok ol om b">timer</code>装饰我们的睡眠功能会发生什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="169e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">首先，让我们试着睡10秒钟:</p><pre class="kj kk kl km gt on om oo op aw oq bi"><span id="8a3f" class="kz la it om b gy or os l ot ou">&gt;&gt;&gt; sleep(10)<br/>sleep took 10.0001 seconds to run!</span></pre><p id="3e89" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">不出所料，运行了10秒。现在，如果我们再次以10作为参数运行<code class="fe oj ok ol om b">sleep</code>,你认为会发生什么:</p><pre class="kj kk kl km gt on om oo op aw oq bi"><span id="5972" class="kz la it om b gy or os l ot ou">&gt;&gt;&gt; sleep(10)<br/>sleep took 0.0 seconds to run!</span></pre><p id="9653" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">用了0秒！我们的缓存装饰工程！</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h2 id="7575" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">接受参数的装饰者</h2><p id="1db0" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">到目前为止，我们对装饰师的了解相当扎实。然而，当你让装饰者接受参数时，他们的真正力量就来了。</p><p id="2e23" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">考虑这个装饰器，它检查函数的结果是否是类型<code class="fe oj ok ol om b">str</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="0f4e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们在一个虚拟函数上调用它来检查它是否工作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="f926" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">它正在工作。然而，如果我们有办法检查任何数据类型的函数的返回类型，这不是很酷吗？来，看看这个:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="55f3" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">使用这种类型的修饰器，您可以为所有的函数编写数据类型检查。让我们一起从头开始建造它。</p><p id="5815" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">首先，让我们创建一个简单的装饰器，它调用传递给它的任何函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="bb80" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们如何调整这段代码，使它也接受自定义数据类型并对<code class="fe oj ok ol om b">func</code>的结果进行检查？我们不能添加额外的参数<code class="fe oj ok ol om b">decorator</code>,因为decorators应该只接受一个函数作为参数。</p><p id="e070" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们定义了一个更大的父函数，它返回一个<strong class="lx iu">装饰器来解决这个问题</strong>。这样，我们可以将任何参数传递给父函数，而父函数又可以在装饰器中使用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="8590" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">注意我们是如何将装饰器包装在一个更大的父函数中的？它将一个数据类型作为参数，传递给我们的装饰器，然后返回它。在<code class="fe oj ok ol om b">wrapper</code>中，我们写了<code class="fe oj ok ol om b">type(result) == dtype</code>，不管数据类型是否匹配，它都计算为<code class="fe oj ok ol om b">True</code>或<code class="fe oj ok ol om b">False</code>。现在，您可以使用此函数对任何函数执行类型检查:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h2 id="fa2c" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">保留修饰函数的元数据</h2><p id="5b6f" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在这之前，我们从来没有检查过一件事——被修饰的函数是否以所有方式被保留？例如，让我们回到我们的<code class="fe oj ok ol om b">sleep</code>函数，我们用<code class="fe oj ok ol om b">timer</code>来修饰它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="68e4" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">让我们调用它并检查它的元数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="064b" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们检查函数的三个元数据属性。前两个回归了<code class="fe oj ok ol om b">None</code>，不过应该是出了点什么。我的意思是，<code class="fe oj ok ol om b">sleep</code>有一个长docstring和一个等于5的默认参数。他们去哪里了？我们在调用<code class="fe oj ok ol om b">__name__</code>得到函数名<code class="fe oj ok ol om b">wrapper</code>时得到了答案。</p><p id="2eb6" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">如果我们研究一下<code class="fe oj ok ol om b">timer</code>的定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="3af3" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们可以看到，我们实际上并没有返回传递的函数，而是在<code class="fe oj ok ol om b">wrapper</code>内部返回它。显然<code class="fe oj ok ol om b">wrapper</code>没有docstring或者任何默认参数，这就是为什么我们得到了上面的<code class="fe oj ok ol om b">None</code>。</p><p id="b155" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">为了解决这个问题，Python为我们提供了一个来自<code class="fe oj ok ol om b">functools</code>模块的有用函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="98c8" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在<code class="fe oj ok ol om b">wrapper</code>函数上使用<code class="fe oj ok ol om b">wraps</code>让我们保留所有附加到<code class="fe oj ok ol om b">func</code>的元数据。注意我们是如何在函数定义上方将<code class="fe oj ok ol om b">func</code>传递给<code class="fe oj ok ol om b">wraps</code>的。</p><p id="59b3" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">如果我们使用<code class="fe oj ok ol om b">timer</code>的这个修改版本，我们会看到它如预期的那样工作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="0c99" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">使用<code class="fe oj ok ol om b">wraps(func)</code>对于编写装饰者来说是一个很好的实践，所以把它添加到我们今天定义的所有装饰者中吧！</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h2 id="23f9" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h2><p id="9466" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">看完这个帖子，你对打造装修工有了很强的认识。更重要的是，你知道它们是如何工作的，以及它们工作的方式。</p><p id="8dd4" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">作为最后一点，我建议每当你有重复的代码在你的函数上执行类似的任务时，就使用decorators。装饰者可以是使你的代码变得枯燥的另一个步骤(不要重复你自己)。</p><p id="9dfe" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">感谢您的阅读！</p><div class="mt mu gp gr mv mw"><a href="https://ibexorigin.medium.com/membership" rel="noopener follow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">通过我的推荐链接加入Medium-Bex t。</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">ibexorigin.medium.com</p></div></div><div class="nf l"><div class="pg l nh ni nj nf nk ks mw"/></div></div></a></div><div class="mt mu gp gr mv mw"><a href="https://ibexorigin.medium.com/subscribe" rel="noopener follow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">每当Bex T .发布时收到电子邮件。</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">每当Bex T .发布时收到电子邮件。注册后，如果您还没有中型帐户，您将创建一个…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">ibexorigin.medium.com</p></div></div><div class="nf l"><div class="ph l nh ni nj nf nk ks mw"/></div></div></a></div></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="f44a" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">阅读更多我的故事:</p><div class="mt mu gp gr mv mw"><a href="https://ibexorigin.medium.com/6-sklearn-mistakes-that-silently-tell-you-are-rookie-f1fe44779a4d" rel="noopener follow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">6 Sklearn默默告诉你是菜鸟的错误</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">没有错误消息——这就是它们的微妙之处</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">ibexorigin.medium.com</p></div></div><div class="nf l"><div class="pi l nh ni nj nf nk ks mw"/></div></div></a></div><div class="mt mu gp gr mv mw"><a rel="noopener follow" target="_blank" href="/comprehensive-guide-to-writing-python-functions-others-can-use-2fa186c6be71"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">编写其他人可以使用的Python函数的综合指南</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">函数编写是一项技能——迈出掌握它的第一步</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">towardsdatascience.com</p></div></div><div class="nf l"><div class="pj l nh ni nj nf nk ks mw"/></div></div></a></div><div class="mt mu gp gr mv mw"><a rel="noopener follow" target="_blank" href="/the-easiest-way-to-deploy-your-ml-dl-models-in-2022-streamlit-bentoml-dagshub-ccf29c901dac"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">2022年部署你的机器学习模型最简单的方法:Streamlit + BentoML + DagsHub</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">将模型部署为具有用户友好界面的轻量级API</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">towardsdatascience.com</p></div></div><div class="nf l"><div class="pk l nh ni nj nf nk ks mw"/></div></div></a></div><div class="mt mu gp gr mv mw"><a rel="noopener follow" target="_blank" href="/complete-guide-to-experiment-tracking-with-mlflow-and-dagshub-a0439479e0b9"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">使用MLFlow和DagsHub进行实验跟踪的完整指南</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">创建可重复且灵活的ML项目</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">towardsdatascience.com</p></div></div><div class="nf l"><div class="pl l nh ni nj nf nk ks mw"/></div></div></a></div></div></div>    
</body>
</html>