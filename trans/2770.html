<html>
<head>
<title>Testing if two graphs are isomorphic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试两个图是否同构</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/testing-if-two-graphs-are-isomorphic-cf6c44ab551e#2022-06-15">https://towardsdatascience.com/testing-if-two-graphs-are-isomorphic-cf6c44ab551e#2022-06-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b22c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Python中图同构及其变体的Weisfeiler-Lehman检验</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b07bfe6dc3fdab8f40eb14f5e9824f34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CtLpeLYl23Y7jiBs"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">奥马尔·弗洛雷斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="232b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用图作为数据结构并不新鲜，近年来，在图的深度学习领域取得了一些进展，这创造了一个新的研究领域，并产生了非常积极的结果。</p><p id="be65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些深度学习方法通常采用图形神经网络(GNNs)的形式。然而，对这些gnn的理论理解仍然是初期的，并且对于不了解最新研究的从业者来说基本上是未知的。</p><p id="749a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于GNNs的一个有趣的理论发现表明，消息传递网络(本质上大多数架构都是这样实现的)的表达能力受到Weisfeiler-Lehman同构测试(WL测试)[1]的限制。这有一些非常有趣的含义。</p><p id="0313" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了更好地理解GNNs的这种局限性，这篇文章将探讨WL测试，它与GNNs的关系，如何扩展测试使其更具表现力，以及如何在Python中实现这些测试。</p><p id="3922" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有这篇文章代码的笔记本可以在<a class="ae kv" href="https://www.kaggle.com/tiagotoledojr/the-weisfeiler-lehman-isomorphism-test" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>和我的<a class="ae kv" href="https://github.com/TNanukem/paper_implementations/blob/main/Weisfeiler%20Lehman%20Isomorphism%20Test.ipynb" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。</p><h1 id="f878" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">图同构</h1><p id="bea1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">第一步是了解什么是图同构，因为WL测试，顾名思义，是一个测试，以确定两个图是否同构。</p><p id="08ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看待同构问题的一种方式是如下分析:两个图是同构的，如果在它们的节点之间有一个映射，在这个映射中我们可以得出结论，这两个图实际上是相同的。</p><p id="2411" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，在更数学的意义上，我们可以说两个图H和G是同构的当且仅当，对于H中相邻的任意一对节点<em class="mp"> u </em>和<em class="mp"> v </em>，存在一个变换<em class="mp"> f </em>其中<em class="mp"> f(u) </em>与G中的<em class="mp"> f(v) </em>相邻。</p><p id="2d9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是同构图形的示例:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/37e1299a93bc911ac6ef52ed0f57789e.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*cDiZb06og_4hhgj_l9CCEA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">两个同构的图。来源:维基百科</p></figure><p id="1822" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">众所周知，这个问题很难解决。直到今天还没有多项式时间的解决方案，这个问题也可以被认为是NP完全的。</p><h1 id="3821" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">魏斯费勒-雷曼测试</h1><p id="8d29" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">WL测试是一种快速测试两个图是否同构的测试。因为这个问题是NP完全的，这个测试在几种情况下会失败。测试的解释如下:</p><ul class=""><li id="3e87" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated">如果测试返回假，那么这两个图<strong class="ky ir">肯定</strong>不是同构的</li><li id="279e" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">如果测试返回真，那么两个图<strong class="ky ir">可能是</strong>同构的</li></ul><p id="7e70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该测试在节点着色方案中工作，工作方式如下:</p><ul class=""><li id="4373" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated">我们首先为图上的每个节点设置一个初始值。就说‘1’吧。</li><li id="1e26" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">对于每个节点，我们获取每个邻居的值，并将其与节点值连接在一起</li><li id="b36d" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">我们用这个值的散列来设置节点的新值</li><li id="233f" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">我们重复这个过程，直到值的分布不再有变化(不是值本身)</li></ul><p id="7b8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果两个图形的值的分布相同，我们将为测试返回true。请注意，我们可以并行运行两种着色算法，因为两个图形的计算是独立的。</p><p id="9276" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果两个图的值的分布是相同的，我们说对于H中的每一个节点，就其连接而言，G中有一个等价的节点，所以这两个图可能是同构的。</p><h2 id="0614" class="nf lt iq bd lu ng nh dn ly ni nj dp mc lf nk nl me lj nm nn mg ln no np mi nq bi translated">与GNNs的关系</h2><p id="0cb9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">但是它和GNNs有什么关系呢？嗯，对于了解消息传递框架的人来说，WL测试背后的策略显然遵循类似的模式:邻居信息聚合。</p><p id="53b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这种方式,[1]证明了gnn至多(这意味着它们可能更糟)在判断两个图是否同构的能力上与WL测试一样强大。</p><p id="1db9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着，对于GNN来说，将两个不同的图放入空间中两个不同的嵌入点的能力，受到区分这两个图的WL测试能力的限制。</p><h2 id="4ead" class="nf lt iq bd lu ng nh dn ly ni nj dp mc lf nk nl me lj nm nn mg ln no np mi nq bi translated">WL测试失败的一些例子</h2><p id="aef0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">下图向我们展示了两个非同构图形的示例，这两个图形无法通过WL测试进行区分，因此在应用于GNN时会收到相同的嵌入。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/59590db160ad3ff64945213977be7dac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TP46IZ80lmvvA1occrfL5w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">两个不同构的图。由作者开发。</p></figure><p id="457c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还要注意，这种考虑只考虑了图的拓扑结构。当我们在GNN上使用特征矩阵<em class="mp"> X </em>时，如果它们的特征不同，它可能能够区分这些图。这将等同于用节点特征的散列来初始化WL测试，而不是对每个节点使用相同的值。</p><h2 id="cff7" class="nf lt iq bd lu ng nh dn ly ni nj dp mc lf nk nl me lj nm nn mg ln no np mi nq bi translated">Python实现</h2><p id="d9d6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于这个实现，我们将创建一个基础方法，它将接收不同的方法来构造WL测试，然后是k-WL测试。</p><p id="bf2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你会发现这两种方法的基本区别是:</p><ul class=""><li id="643b" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated">我们如何定义将要处理的节点“集合”</li><li id="f8e6" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">我们如何开始给它们上色</li><li id="570b" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">我们如何定义集合中每个元素的邻域</li></ul><p id="0b4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这些代码，我们需要一些库:</p><pre class="kg kh ki kj gt ns nt nu nv aw nw bi"><span id="a57b" class="nf lt iq nt b gy nx ny l nz oa">import copy<br/>import pprint<br/>import itertools<br/>import hashlib<br/>import networkx as nx</span><span id="f47b" class="nf lt iq nt b gy ob ny l nz oa">from collections import Counter</span></pre><p id="d813" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们创建一个base_WL方法，它将为我们完成大部分繁重的工作:</p><pre class="kg kh ki kj gt ns nt nu nv aw nw bi"><span id="6be1" class="nf lt iq nt b gy nx ny l nz oa">def base_WL(G_, k, verbose, n_set, initial_colors_func, find_neighbors_func):    <br/>    G, n = n_set(G_)<br/>    colors = initial_colors_func(n)</span><span id="be53" class="nf lt iq nt b gy ob ny l nz oa">old_colors = copy.deepcopy(colors)</span><span id="e328" class="nf lt iq nt b gy ob ny l nz oa">for i in range(len(n)):<br/>        for node in n:<br/>            neigh_colors = "".join([colors[i][0] for i in find_neighbors_func(G, n, node)])<br/>            <br/>            colors[node].extend([neigh_colors])<br/>            colors[node].sort()</span><span id="9367" class="nf lt iq nt b gy ob ny l nz oa"># Update with the hash<br/>        colors = {i: [hashlib.sha224("".join(colors[i]).encode('utf-8')).hexdigest()] for i in colors}<br/>        <br/>        if list(Counter([item for sublist in colors.values() for item in sublist]).values()) == list(Counter([item for sublist in old_colors.values() for item in sublist]).values()) and i != 0:<br/>            if verbose:<br/>                print(f'Converged at iteration {i}!')<br/>            break<br/>        <br/>        old_colors = copy.deepcopy(colors)</span><span id="a28c" class="nf lt iq nt b gy ob ny l nz oa">canonical_form = sorted(Counter([item for sublist in colors.values() for item in sublist]).items())<br/>    if verbose:<br/>        print(f'Canonical Form Found: \n {canonical_form} \n')</span><span id="4756" class="nf lt iq nt b gy ob ny l nz oa">return canonical_form</span></pre><p id="6def" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个函数接收一个计算元素集合的函数、一个开始颜色的函数和一个返回给定集合元素的邻居的函数。</p><p id="2d37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，它将基于其相邻元素迭代地更新每个元素的颜色，直到值的直方图(或分布)停止变化，此时我们说找到了规范形式。</p><p id="5ee6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们实现将生成WL测试的方法:</p><pre class="kg kh ki kj gt ns nt nu nv aw nw bi"><span id="36e5" class="nf lt iq nt b gy nx ny l nz oa">def WL(G, k=2, verbose=False):<br/>    def n_set(G):<br/>        G = nx.convert_node_labels_to_integers(G)<br/>        return G, list(G.nodes())<br/>    <br/>    def set_initial_colors(n):<br/>        return {i: [hashlib.sha224("1".encode('utf-8')).hexdigest()] for i in n}<br/>    <br/>    def find_neighbors(G, n, node):<br/>        return G.neighbors(node)<br/>    <br/>    return base_WL(G, k, verbose, n_set, set_initial_colors, find_neighbors)</span></pre><p id="df33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们所见，对于WL测试，元素集是图的节点。每个人的初始颜色都是一样的，只有“1”字符串，最后，它的邻域只有与感兴趣的节点相连的节点。</p><p id="c6db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意k参数。它只是为了与我们接下来要实现的k-WL方法保持一致。</p><h1 id="a9e7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">k-魏斯费勒-雷曼检验</h1><p id="4eb5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">k-WL测试是WL测试的高阶版本，旨在提高其表达能力，换句话说，旨在使其比原始版本更强大。它的代价是任务过程中计算复杂性的增长。这意味着算法更慢。</p><p id="a588" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">k-WL测试背后的思想是避免使用网络的拓扑结构，而是在着色算法期间使用k-元组节点的思想。</p><p id="5daa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其工作原理如下。给定网络K，设[K]是来自K的节点。现在设K是由来自[K]的节点的每个排列组成的大小为2的元组的集合。</p><p id="7b34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个想法是，我们将重复传统WL测试的算法，但是用这些2元组代替节点。</p><p id="c1f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是在这种情况下，我们如何定义邻域呢？我们认为它是仅在一个位置上不同于原始元组的每个元组的集合。在数学术语中，我们有等式1:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/1d5edad2a4cce3d01b51950cc4019713.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*JgKJZ9UV1fzhkudwHNjmpA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">k-WL检验的邻域定义。出自[2]。</p></figure><p id="2689" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，此描述来自双WL测试。对于任何k值，都有它的变体，想法是一样的，只是元组的大小改变了。</p><p id="ffc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种实现比WL测试更有效。然而，它仍然不能完全解决图的同构问题。</p><h2 id="b4b4" class="nf lt iq bd lu ng nh dn ly ni nj dp mc lf nk nl me lj nm nn mg ln no np mi nq bi translated">Python实现</h2><pre class="kg kh ki kj gt ns nt nu nv aw nw bi"><span id="f3a6" class="nf lt iq nt b gy nx ny l nz oa">def kWL(G, k, verbose=False):<br/>    def n_set(G):<br/>        G = nx.convert_node_labels_to_integers(G)<br/>        V = list(G.nodes())<br/>        V_k = [comb for comb in itertools.combinations(V, k)]<br/>        return G, V_k</span><span id="df00" class="nf lt iq nt b gy ob ny l nz oa">def set_initial_colors(n):<br/>        return {i: [hashlib.sha224(str(i).encode('utf-8')).hexdigest()] for i in n}</span><span id="fd23" class="nf lt iq nt b gy ob ny l nz oa">def find_neighbors(G, V_k, node):<br/>        return [n for n in V_k if len(set(n) - set(V_k[V_k.index(node)])) == 1]</span><span id="f65a" class="nf lt iq nt b gy ob ny l nz oa">return base_WL(G, k, verbose, n_set, set_initial_colors, find_neighbors)</span></pre><p id="3929" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，正如我们所看到的，我们与WL测试有以下不同之处:</p><ul class=""><li id="3026" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated">这组元素是基于V^k的，而不是v。</li><li id="038c" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">每个节点的初始颜色并不相同，现在它取决于组成元素的节点</li><li id="292f" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">每个元素的邻域根据等式1来定义。</li></ul><h1 id="643e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="08cf" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">了解当前流行的GNNs架构的局限性可能有助于从业者在开发过程中避免常见的陷阱，也有助于研究人员寻找改进这一令人兴奋的新知识领域的新机会。</p><p id="a254" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我们探讨了WL测试和k-WL测试的变体，以及测试和通常应用于GNNs的消息传递框架之间的关系。</p><p id="80b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[1]K. Xu等<a class="ae kv" href="https://arxiv.org/abs/1810.00826" rel="noopener ugc nofollow" target="_blank">图神经网络到底有多强大？</a> (2019)。继续。ICLR。</p><p id="c14b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[2] N. T. Huang和S. Villar，“关于Weisfeiler-Lehman测试及其变体的简短教程”，ICASSP 2021–2021 IEEE声学、语音和信号处理国际会议(ICA ssp)，2021，第8533–8537页，doi:10.1109/ICA ssp 39728 . 23636736</p></div></div>    
</body>
</html>