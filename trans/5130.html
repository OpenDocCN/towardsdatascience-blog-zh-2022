<html>
<head>
<title>How to Make Your Data Models Modular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使您的数据模型模块化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-make-your-data-models-modular-71b21cdf5208#2022-11-16">https://towardsdatascience.com/how-to-make-your-data-models-modular-71b21cdf5208#2022-11-16</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""/><div class=""><h2 id="dc3a" class="pw-subtitle-paragraph js iu iv bd b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj dk translated">通过这些步骤避免高度耦合的系统和意外的生产错误</h2></div><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/f99214efb05e464aa4943ce01ab938b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qCkfMPOk3u-Ioo-qA_gqfA.jpeg"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">照片由<a class="ae la" href="https://unsplash.com/@tjbreshears?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> T.J. Breshears </a>在<a class="ae la" href="https://unsplash.com/s/photos/puzzle-piece?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="db2b" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">发现生产中的某些东西坏了，这是每个工程师最可怕的噩梦。更糟糕的是，当一个简单的变化打破了一切。当这种情况发生时，很有可能你的系统是高度交织在一起的，这里的一个调整可能会引起那边的多米诺骨牌效应。</p><p id="86e0" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">没有改变是安全的！你永远不知道它最终会影响到什么。</p><p id="8c32" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这正是我们在构建数据模型时想要避免的。您不希望它们紧密耦合，这样您就可以在不破坏整个管道的情况下，在必要时轻松地进行调试和更改。</p><p id="b871" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在头脑中用<strong class="ld iw">模块化</strong>构建你的数据模型是这个问题的解决方案。模块化数据模型彼此独立存在。它们就像一个更大的拼图中的几块。这些部分共同创造了一些美丽的东西，并向您展示了全貌。然而，每个拼图块仍然可以被拉出并独立存在，而不会破坏整个图像。</p><p id="c435" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我们希望我们的数据模型是拼图块，可以轻松地移除、更改和添加，而不会对数据管道产生任何性能影响。</p><p id="2dd0" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我们如何做到这一点？它从重新评估您当前的数据模型以及如何重写它们以使其更加模块化开始。</p><h1 id="dab5" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">为每个原始数据源创建基本模型。</h1><p id="75a9" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">任何数据模型都不应该直接引用原始数据。<strong class="ld iw">您总是希望在您的数据仓库中保留一份原始数据的副本。这样，万一您的数据遭到破坏，您可以随时恢复到原始副本。</strong></p><p id="edba" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">基础模型的存在是为了保护您的原始数据不被以任何方式转换。它们通常是数据仓库中位于原始数据源之上的视图，因此它们不占用任何存储空间。他们引用原始数据，但也改变其基本特征，使其更清晰，便于分析工程师使用。</p><p id="89a3" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">基本型号包括:</p><ul class=""><li id="e1c3" class="mu mv iv ld b le lf lh li lk mw lo mx ls my lw mz na nb nc bi translated">数据类型转换</li><li id="d52c" class="mu mv iv ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated">列名更改</li><li id="96b9" class="mu mv iv ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated">时区转换</li><li id="3b44" class="mu mv iv ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated">简单 case when 语句</li></ul><p id="fff0" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">基本模型不应该包括任何花哨的计算、连接或聚合。它们只是原始数据的标准化版本，便于您在下游的数据模型中引用。</p><p id="2e76" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">例如，假设您有一个原始数据源，如下所示:</p><pre class="kl km kn ko gt ni nj nk bn nl nm bi"><span id="c697" class="nn ly iv nj b be no np l nq nr">select <br/>  id,<br/>  user_id, <br/>  created_date,<br/>  source<br/>from web_traffic.first_visits</span></pre><p id="d5d4" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">为了在我的下游模型中更容易理解和引用，我将使用<a class="ae la" rel="noopener" target="_blank" href="/what-is-dbt-a0d91109f7d0"> dbt </a>为其编写一个基本模型，如下所示:</p><pre class="kl km kn ko gt ni nj nk bn nl nm bi"><span id="5927" class="nn ly iv nj b be no np l nq nr">select <br/>  id AS first_visit_id,<br/>  user_id, <br/>  CAST(created_date AS date) AS created_date,<br/>  created_date::timestamp_ntz AS created_at,<br/>  source AS referrer_source<br/>from {{ source('web_traffic', 'first_visits') }}</span></pre><p id="4c68" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我指定<code class="fe ns nt nu nj b">id</code>也引用表名，以便将来的连接更容易阅读。</p><p id="2499" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我将<code class="fe ns nt nu nj b">created_date</code>转换为一个实际的日期，并使用该列将其转换为正确的时间戳类型并重命名。</p><p id="aa77" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">最后，我更改了<code class="fe ns nt nu nj b">source</code>列的名称，使其更具描述性。</p><h1 id="6efa" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">识别数据模型之间的公共代码。</h1><p id="6e15" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">现在，您已经为每个原始数据源创建了一个基本模型，您希望更深入地研究已经存在的更复杂的数据模型。如果您没有使用像<a class="ae la" href="https://medium.com/geekculture/4-things-you-need-to-know-about-dbt-e54c016f338c" rel="noopener"> dbt </a>这样的转换工具，那么您有可能为每个模型编写了很长的 SQL 代码文件。仔细阅读每一个文件，看看是否能找到在多个不同文件中重复的代码。</p><p id="2f2d" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这种重复的代码可能是多次使用的货币换算计算、映射代码或频繁连接在一起的表。</p><p id="2d0b" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我们来看两个独立的模型。</p><p id="34a1" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">第一个是寻找 10 月份纽约州的所有促销订单。</p><pre class="kl km kn ko gt ni nj nk bn nl nm bi"><span id="506f" class="nn ly iv nj b be no np l nq nr"># model looking for all promo orders to the state of New York in the month of October <br/>with order_information_joined AS (<br/>  select<br/>    orders.order_id,<br/>    orders.ordered_at, <br/>    order_types.order_type_name, <br/>    order_addresses.city, <br/>    states.state_name<br/>  from orders <br/>  left join order_types <br/>    on orders.order_type_id = order_types.order_type_id <br/>  left join order_addresses <br/>    on orders.order_address_id = order_addresses on order_address_id <br/>  left join states <br/>    on order_addresses.state_id = states.state_id <br/>) <br/><br/>select <br/>  order_id <br/>from order_information_joined <br/>where '10-01-2022' &lt;= CAST(ordered_at AS date) &lt;= '10-31-2022' <br/>  and order_type_name = 'promo' <br/>  and state_name = 'New York'</span></pre><p id="bb11" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">第二个是查找 2022 年的订购单数量。</p><pre class="kl km kn ko gt ni nj nk bn nl nm bi"><span id="8a03" class="nn ly iv nj b be no np l nq nr"># model finding the number of subscription orders placed in 2022<br/>with subscription_orders AS (<br/>  select * <br/>  from orders <br/>  where order_type_id=1<br/>),<br/><br/>order_information_joined AS (<br/>  select<br/>    orders.order_id,<br/>    orders.ordered_at, <br/>    order_types.order_type_name, <br/>    order_addresses.city, <br/>    states.state_name<br/>  from subscription_orders <br/>  left join order_types <br/>    on orders.order_type_id = order_types.order_type_id <br/>  left join order_addresses <br/>    on orders.order_address_id = order_addresses on order_address_id <br/>  left join states <br/>    on order_addresses.state_id = states.state_id <br/>)<br/><br/>select count(*) from order_information_joined where YEAR(ordered_at)=2022</span></pre><p id="b027" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这些模型有什么共同点？两者一起加入<code class="fe ns nt nu nj b">orders</code>、<code class="fe ns nt nu nj b">order_types</code>、<code class="fe ns nt nu nj b">order_addresses</code>和<code class="fe ns nt nu nj b">states</code>表。因为这段代码至少使用了两次，所以将它作为自己的模型编写可能是一个有用的查询。这样，无论何时需要它，它都可以简单地在某人正在编写的另一个模型中被引用。</p><p id="aa9a" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">另外，请注意第二个模型在将订单表<em class="nv">连接到其他表之前是如何过滤订单表</em>的。在我们的新模型中，我们不想这样做，因为这样会限制我们使用模型的范围。相反，当引用新模型时，您将能够过滤<code class="fe ns nt nu nj b">order_type_id</code>。</p><h1 id="a6d6" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">将此代码编写为它自己的数据模型。</h1><p id="4666" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">既然您已经确定了在多个数据模型中重复的代码，那么您想要将它转换成它自己的<em class="nv">数据模型。这就是为什么你的模型是模块化的！</em></p><p id="304f" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">通过将重复的代码转换成自己的模型，您可以节省计算成本和运行时间。这样写的话，你的模型会运行得更快！您不再多次运行相同的代码，而是只运行一次，然后在不同的模型中引用它的输出。</p><p id="c835" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated"><strong class="ld iw">确保取出任何特定于某个数据模型的代码片段。</strong>例如，您可能会为新用户筛选一个模型，但所有其他模型都会查看所有用户。不要在这个模块化数据模型中包含过滤器，而是将它添加到引用模块化模型的特定模型的代码中。</p><p id="d056" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated"><strong class="ld iw">我们的目标是让这些片段变得不特定和可重用。当你再次引用时，总会有空间添加细节。</strong></p><p id="7d4e" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">另一件需要注意的事情——确保给模型起一个描述性的名字。您希望其他人能够阅读模型的名称并知道它是做什么的。这样，他们也可以在他们的代码中引用它，而不是重新编写代码。编写模块化数据模型的一大好处是减少了数据团队工作之间的冗余。模块化模型使得使用你的队友已经写好的代码变得容易，节省了你的时间和精力！</p><p id="7d8d" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">如果我们看上面的例子，我会把数据模型叫做<code class="fe ns nt nu nj b">order_details_joined_location</code>。这意味着我将不同的订单相关表连接到位置相关表。该模型将如下所示:</p><pre class="kl km kn ko gt ni nj nk bn nl nm bi"><span id="1c28" class="nn ly iv nj b be no np l nq nr">select<br/>    orders.order_id,<br/>    orders.user_id, <br/>    orders.product_quantity,<br/>    orders.ordered_at, <br/>    order_types.order_type_id, <br/>    order_types.order_type_name, <br/>    order_address.street_line_1, <br/>    order_address.street_line_2, <br/>    order_addresses.city,<br/>    order_address.zipcode,<br/>    order_address.country,<br/>    states.state_id,<br/>    states.state_name<br/>  from orders <br/>  left join order_types <br/>    on orders.order_type_id = order_types.order_type_id <br/>  left join order_addresses <br/>    on orders.order_address_id = order_addresses on order_address_id <br/>  left join states <br/>    on order_addresses.state_id = states.state_id</span></pre><p id="2c12" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">请注意，我是如何包含每个表中的所有列，而不仅仅是之前使用的特定模型中的列。这为模型的使用提供了更大的灵活性。</p><h1 id="45c8" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">在其他模型中引用此模型。</h1><p id="13de" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">现在，在您取出共享代码并使其成为自己的数据模型之后，您可以在原来的两个模型中引用这个新模型。<a class="ae la" href="https://medium.com/geekculture/the-ultimate-guide-to-using-dbt-with-snowflake-2d4bfc37b2fc" rel="noopener"> dbt </a>通过允许您使用一个简单的<code class="fe ns nt nu nj b">{{ ref() }}</code>函数来调用其他数据模型，使这变得很容易。</p><p id="c7da" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">重写第一个模型以引用我们的新<code class="fe ns nt nu nj b">order_details_joined_location </code>模型，如下所示:</p><pre class="kl km kn ko gt ni nj nk bn nl nm bi"><span id="958c" class="nn ly iv nj b be no np l nq nr">select <br/>  order_id <br/>from {{ ref('order_details_joined_location') }}<br/>where '10-01-2022' &lt;= CAST(ordered_at AS date) &lt;= '10-31-2022' <br/>  and order_type_name = 'promo' <br/>  and state_name = 'New York'</span></pre><p id="3f74" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">第二个应该是这样的:</p><pre class="kl km kn ko gt ni nj nk bn nl nm bi"><span id="bf52" class="nn ly iv nj b be no np l nq nr">select <br/>  count(*)<br/>from {{ ref('order_details_joined_location') }}<br/>  where order_type_id=1<br/>  and YEAR(ordered_at)=2022</span></pre><p id="f601" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">现在我们有了两个简单的模型，它们产生与以前相同的输出，但是引用了另一个模型，该模型现在可以用于许多其他模型。</p><h1 id="cc7d" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">结论</h1><p id="2625" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">模块化是一组能够经受时间考验的数据模型的关键特征。当数据模型模块化时，您可以降低计算成本，减少运行整个管道所需的时间，并通过创建协作编码流程使您的团队生活更轻松。数据建模的未来是模块化。<a class="ae la" rel="noopener" target="_blank" href="/what-is-dbt-a0d91109f7d0"> dbt </a>成为如此流行的数据转换工具是有原因的！他们了解这种需求，并能很好地解决问题。</p><p id="4f6c" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">关于<a class="ae la" href="https://madisonmae.substack.com/" rel="noopener ugc nofollow" target="_blank">分析工程</a>的更多信息，请订阅我的免费每周简讯，在那里我分享学习资源、教程、最佳实践等等。</p><p id="9c11" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">看看我的第一本电子书，<a class="ae la" href="https://madisonmae.gumroad.com/l/learnanalyticsengineering" rel="noopener ugc nofollow" target="_blank">分析工程基础知识</a>，一本全方位的分析工程入门指南。</p></div></div>    
</body>
</html>