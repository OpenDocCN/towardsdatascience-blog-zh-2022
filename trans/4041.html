<html>
<head>
<title>Learning Kubernetes, the Easy Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习Kubernetes，简单的方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/learn-kubernetes-the-easy-way-d1cfa460c013#2022-09-08">https://towardsdatascience.com/learn-kubernetes-the-easy-way-d1cfa460c013#2022-09-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="860a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在本教程中，我们将了解Kubernetes以及如何使用它来编排容器化的应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bbf8869d6740330c324feba10a521c9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X3AABEFth1rc-laDlwhHmA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">汉斯-彼得·高斯特在<a class="ae ky" href="https://unsplash.com/s/photos/puzzle?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="beb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你是一名软件开发人员，你可能几乎每天都会听说Kubernetes。Kubernetes已经成为业界领先的容器编排工具。</p><blockquote class="lv lw lx"><p id="06a8" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">本教程中的所有图像都是由珀西·博尔梅勒创作的</p></blockquote><p id="e0e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我开始学习Kubernetes时，它很难，有太多的术语，我几乎很快就放弃了。出于这个原因，我将在本教程中尝试以简洁易懂的方式慢慢地、彻底地走完Kubernetes的每一步。</p><p id="9405" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢视频格式，你可以在YouTube上观看相同的教程。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我浏览教程的YouTube视频</p></figure><p id="bb2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将构建一个运行API和数据库的简单应用程序。本教程旨在帮助您熟悉Kubernetes，并希望学习一些基础知识。本教程不会涵盖如何将应用程序部署到生产环境中，这是一个本身需要一整篇文章的主题。</p><p id="8fce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开始编码之前，让我们先了解一些信息。</p><blockquote class="lv lw lx"><p id="4cf1" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">你可以在我的<a class="ae ky" href="https://github.com/percybolmer/kubedemo" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到这个教程的完整代码</p></blockquote><h2 id="72b7" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">什么是Kubernetes</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/2fa72622e4aabb4ca2559ec8f4863165.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CYI0erpRI6DaL9IMqm4yPg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">库伯内特建筑形象化</p></figure><p id="b405" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes是一个管理和控制容器化应用程序的工具。如果不熟悉容器和Docker，可以阅读<a class="ae ky" href="https://medium.com/@programmingpercy/learning-docker-52b7bdec5e86" rel="noopener">学习Docker </a>。</p><blockquote class="my"><p id="9185" class="mz na it bd nb nc nd ne nf ng nh lu dk translated">Kubernetes ，也称为K8S，是一个用于自动化部署、扩展和管理容器化应用程序的开源系统。</p></blockquote><p id="3e10" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Kubernetes旨在解决整个基础设施中多个容器的部署和控制。Kubernetes是谷歌开发的开源软件。</p><p id="4645" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会发现Kubernetes的一些特点是</p><ul class=""><li id="bab1" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><strong class="lb iu">服务发现</strong> —通过DNS公开您的容器，并使发现正在运行的服务成为可能。</li><li id="8739" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><strong class="lb iu">负载平衡</strong> —如果您的一个容器流量过大，它可以将流量分配给另一个已部署的容器。</li><li id="d10e" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><strong class="lb iu">自我修复</strong> —可配置为在需要时重启/移除并启动新容器。</li><li id="39a5" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><strong class="lb iu">机密&amp;配置</strong> —这使得为您的部署存储和管理机密变得容易。</li><li id="cecf" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><strong class="lb iu">监控</strong> —应用程序的内置监控</li></ul><p id="326d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让我们了解所有这些特性，Kubernetes运行了许多协同工作的组件，我们将简要概述Kubernetes组件，这样我们就知道什么是基础。</p><p id="9e2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行中的K8集群由一个<a class="ae ky" href="https://kubernetes.io/docs/concepts/overview/components/" rel="noopener ugc nofollow" target="_blank">控制平面</a>组成。控制平面负责公开一个API来控制集群和容器生命周期的管理。在控制平面内，我们发现一些重要的节点有不同的职责。</p><ul class=""><li id="d92b" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><strong class="lb iu">API</strong>—kube-API server用于连接集群，并允许我们与集群对话。</li><li id="9b4f" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><a class="ae ky" href="https://etcd.io/docs/" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">Etcd</strong></a>—K8用来维护集群数据的键值存储解决方案</li><li id="0e87" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><strong class="lb iu">调度器</strong> —检查没有分配节点(工作机)的新容器(运行容器)，并分配它们。</li><li id="fcf6" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><strong class="lb iu">控制器管理器</strong> —负责管理控制器的组件。</li></ul><p id="ee3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们有与控制平面通信的工作节点。控制平面与工作节点对话，以便它们知道该做什么。worker节点用于运行pod(一组容器)。</p><p id="d432" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个worker节点都有一个<code class="fe ob oc od oe b"><a class="ae ky" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/" rel="noopener ugc nofollow" target="_blank">kubelet</a></code>正在运行，它负责接受来自控制平面的关于它应该运行什么的指令。Kubelets通常被称为节点代理。</p><p id="cc28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，我们有一个控制平面在运行，多个kubelets (worker nodes)可以连接到它。这是对Kubernetes整个基础设施如何工作的一个非常基本的解释，你应该再一次熟悉所有的东西，探索文档以了解更多关于确切的内部工作方式。</p><p id="1649" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们进入了Kubelet，了解它们可以运行的不同资源是很有好处的。</p><p id="aa77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一些和K8一起工作时很好理解的词。</p><ul class=""><li id="e659" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><strong class="lb iu">pod</strong>—您的集群中的一组运行容器，将pod视为在K8内工作的最小单位。通常，每个pod使用一个容器，但也可以是多个容器。</li><li id="9bf1" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><strong class="lb iu">节点</strong> —集群中的一台工作机</li><li id="3bbb" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><strong class="lb iu">控制器</strong>——一个检查集群某个状态并试图调节它的回路。</li><li id="bf84" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><strong class="lb iu">复制集</strong> —用于确保始终有设定数量的pod运行。</li><li id="9fa7" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><strong class="lb iu">部署</strong> —提供副本集和单元的更新</li><li id="58f6" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><strong class="lb iu">作业</strong> —由pod执行的流程，将创建Pod并执行流程，然后关闭。</li><li id="07bf" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><strong class="lb iu">服务</strong> —通过在内部公开端口，允许pod与集群中的其他pod进行通信。</li></ul><p id="4776" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我试着把单词列表保持得很小，我知道要记住它们可能会很难，但是不要担心，当我们把它们添加到我们的应用程序中时，我们会一点一点地介绍它们。</p><h2 id="ed7b" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">安装Kubernetes、Minikube、Docker和Go</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/683d6b01121f5ee1ba47205ba32d981e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lCRBkLR5EAv8aJMp3cN1kQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">本教程的要求— Kubernetes、Minikube、Docker、Go</p></figure><p id="5357" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始使用K8S之前，我们需要下载并安装它，以及本教程中使用的一些其他工具。</p><div class="of og gp gr oh oi"><a href="https://kubernetes.io/releases/download/" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">下载Kubernetes</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">核心Kubernetes组件在CHANGELOG文件中找到下载Kubernetes组件(及其校验和)的链接…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">kubernetes.io</p></div></div><div class="or l"><div class="os l ot ou ov or ow ks oi"/></div></div></a></div><p id="adfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遵循Kubernetes自己提供的安装指南。如果你用的是Linux，这就是我们需要做的。</p><p id="c203" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先使用curl获取Kubernetes并安装下载的二进制文件。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="1011" class="me mf it oe b gy pb pc l pd pe">curl -LO "https://dl.k8s.io/release/<strong class="oe iu">$(</strong>curl -L -s https://dl.k8s.io/release/stable.txt<strong class="oe iu">)</strong>/bin/linux/amd64/kubectl"<!-- --> </span><span id="1a13" class="me mf it oe b gy pf pc l pd pe">sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl</span></pre><p id="5049" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过运行以下命令来确保安装工作正常</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="c9e6" class="me mf it oe b gy pb pc l pd pe">kubectl version</span></pre><p id="1474" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二步是安装Minikube。Minikube是一个本地Kubernetes节点，可以用来学习和测试Kubernetes。基本上，它在您的计算机上设置一个虚拟机，该虚拟机运行一个具有单个节点的集群。</p><p id="b6c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要安装Minikube，请遵循<a class="ae ky" href="https://minikube.sigs.k8s.io/docs/start/" rel="noopener ugc nofollow" target="_blank">说明</a>。对我来说，运行Linux，就像跑步一样简单</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="dfcf" class="me mf it oe b gy pb pc l pd pe">curl -LO <a class="ae ky" href="https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64" rel="noopener ugc nofollow" target="_blank">https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64</a></span><span id="f1ce" class="me mf it oe b gy pf pc l pd pe">sudo install minikube-linux-amd64 /usr/local/bin/minikube</span></pre><p id="8f6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你运行的是Windows，请不要在WSL里面安装Minikube，同时也要确保你已经安装了<a class="ae ky" href="https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v" rel="noopener ugc nofollow" target="_blank"> Hyper-V </a>。避免WSL的原因是因为在写这个教程的时候，让它工作是非常复杂的。</p><p id="9978" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过运行<code class="fe ob oc od oe b">minikube version</code>命令来验证您的安装。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/ffd81243f658a2929a08b4f406a712e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*LFErQKGU6sp3WZcoWns7FQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Minikube版本打印版本</p></figure><p id="ebac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你需要的第三个软件是Docker，因为我们将使用它来构建我们的容器。</p><p id="a95c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在他们的<a class="ae ky" href="https://docs.docker.com/engine/install/ubuntu/" rel="noopener ugc nofollow" target="_blank">网站</a>上找到如何安装Docker的说明。我不会详细介绍如何安装它，因为在<a class="ae ky" href="https://medium.com/@programmingpercy/learning-docker-52b7bdec5e86" rel="noopener">Learning Docker-The Easy Way</a>中已经介绍过了。</p><p id="c1a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第四个需求是<a class="ae ky" href="https://go.dev/learn/" rel="noopener ugc nofollow" target="_blank"> Go </a>，可以通过访问他们的<a class="ae ky" href="https://go.dev/dl/" rel="noopener ugc nofollow" target="_blank">网站</a>进行安装。在本教程中，我使用Go来实现一个简单的服务，这个服务并不复杂，对于新开发人员来说应该非常容易理解。</p><h2 id="7853" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">让我们为库伯内特探险做准备</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/c391b4488e3add646cda868214d643ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PB5McSHq0GYRgQDm8xW03w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将我们的Go应用程序封装到Minikubes Docker环境中</p></figure><p id="401c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦一切就绪并开始运行，是时候开始熟悉Kubernetes的实际用法了。在使用Kubernetes之前，我们需要在一个由Minikube创建的节点上运行应用程序。</p><p id="9f8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行<code class="fe ob oc od oe b">minikube start</code>使Kubernetes在运行应用程序时使用Minikube。这一点很重要，因为我们只有一台计算机来运行它。这可能需要一些时间来运行，去喝杯咖啡。</p><blockquote class="lv lw lx"><p id="068e" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">请注意，如果您使用的是另一个虚拟机驱动程序而不是windows上的Hyper-V，例如Docker，您需要将其添加到start <code class="fe ob oc od oe b">minikube start --driver=docker</code></p></blockquote><p id="0cc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过运行Kubectl命令行工具来列出可用节点，可以确保一切正常。在您的终端中运行<code class="fe ob oc od oe b">kubectl get nodes</code>，您应该看到<code class="fe ob oc od oe b">Minikube</code>被列为一个节点。当您想要查看集群上的节点时，此命令非常有用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/e82e6ea5dc358edc03341d5a71e3d099.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*FpflJMz6xHXI7D3CBKvFxw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">获取节点应该列出minikube节点。</p></figure><p id="a02e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将需要建立一个docker图像，我们可以使用它在Kubernetes内部运行。我用Go准备了一个超级简单的HTTP服务器和一个构建它的docker文件。创建一个<code class="fe ob oc od oe b">main.go</code>文件，用下面的要点填充它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pi md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">main . Go——Go中一个超级简单的HTTP服务器</p></figure><p id="69d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要创建一个<code class="fe ob oc od oe b">dockerfile</code>，我不会详细介绍Docker是如何归档的，如果你需要了解Docker，可以看看我的<a class="ae ky" href="https://medium.com/@programmingpercy/learning-docker-52b7bdec5e86" rel="noopener">学习Docker </a>文章。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pi md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">dockerfile —构建HTTP服务器，并将其设置为在容器启动时启动</p></figure><p id="b52c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们能够构建docker之前，我们需要确保两件事情是有序的。第一个是我们需要在项目根目录中初始化一个go模块。</p><p id="adc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b">go mod init programmingpercy/hellogopher</code></p><p id="7a7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要确保通过运行<code class="fe ob oc od oe b">eval $(minikube docker-env)</code>来使用Minikubes docker环境。<strong class="lb iu"> <em class="ly">这是每个终端重启所需要的。</em> </strong>如果您使用的是Windows，请改为运行命令。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="364a" class="me mf it oe b gy pb pc l pd pe">minikube -p minikube docker-env | Invoke-Expression</span></pre><p id="fb54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请不要跳过上述命令，如果你这样做，你将面临的问题，寻找docker镜像安装在您的计算机上，因为你使用了错误的docker环境！</p><p id="3c88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是时候建立我们想要使用的图像了</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="1a94" class="me mf it oe b gy pb pc l pd pe">docker build -t programmingpercy/hellogopher:1.0 .</span></pre><h2 id="5e3f" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">准备好Kube！</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/4924d7e9db110dbcb3f72e266acbeeb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L-sImMYAh6ov36WNQalTWA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Kubernetes对象是在Yaml文件中定义的</p></figure><p id="17e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在有了我们需要的一切，我们有Kubernetes，Minikube，还有一个Docker映像中的惊人的HTTP服务器可以运行。让我们创建我们的第一个Kubernetes资源。</p><p id="0dad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Kubernetes中，我们使用YAML文件来定义<a class="ae ky" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/" rel="noopener ugc nofollow" target="_blank">对象</a>，应用程序的所有部分都被称为对象。在YAML中有大量的东西需要定义，但是我们将从简单开始。</p><p id="a427" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个名为<code class="fe ob oc od oe b">hellogopher.yml</code>的新文件，它将维护与API相关的对象。</p><p id="b028" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将一步一步填充YAML文件，看看每一行的意思。我们从一些必需的缺省值开始。我们在YAML中定义的是一个<a class="ae ky" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/" rel="noopener ugc nofollow" target="_blank"> Kubernetes对象</a>，每个对象都需要这些字段。</p><ul class=""><li id="11e6" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><strong class="lb iu"> apiVersion </strong>是一个描述您将使用哪个版本的Kubernetes API的字段。</li><li id="e21f" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><strong class="lb iu">种类</strong>是我们正在创建的对象的种类。</li><li id="b764" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><strong class="lb iu">元数据</strong>是关于对象的信息，可用于跟踪和识别对象。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pi md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">hellogopher.yml第1–4行包含默认字段</p></figure><p id="351e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将定义<code class="fe ob oc od oe b">spec</code>，spec是YAML中的一个字段，它定义了对象将处于的状态。规范中需要提供哪些信息取决于您创建的对象的类型。</p><p id="432e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们正在创建一个<strong class="lb iu">部署</strong>对象，一个<a class="ae ky" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank">部署</a>用于指定运行API的Pod的期望状态。这可以是关于环境变量的设置、要创建多少个副本以及关于正在运行的pod的默认设置。我们将首先添加三个字段。</p><ul class=""><li id="9ef9" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><strong class="lb iu">选择器— </strong>部署应该用来查找相关pod的标签。这很重要，因为我们可以让其他对象使用这个选择器来引用它，并在以后使用kubectl命令找到它。</li><li id="d1f0" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><strong class="lb iu">副本— </strong>要启动多少个副本，一个副本是一个相同的容器。如果我们将其设置为1，我们将启动1个容器，如果我们将其设置为3，将启动3个容器。</li><li id="5430" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><strong class="lb iu">模板— </strong>定义新创建的pod应该如何设置的模板，请注意，模板是一个对象，包含自己的spec字段。</li></ul><p id="eace" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模板字段包含自己的规范，因为它是一个对象。在该规范中，我们定义了pod都应该运行我们构建的docker映像。我们还指定应该公开端口8080，它不应该从DockerHub获取图像，我们只在本地构建它。</p><p id="b0a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对任何领域有疑问，想要更多的信息，请随时查看官方文件。我已经对每个领域做了评论。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pi md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">hellogopher.yml —添加了部署规范</p></figure><p id="82ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了创建和运行这个新资源，我们将运行以下命令</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="d525" class="me mf it oe b gy pb pc l pd pe">kubectl create -f hellogopher.yml</span></pre><p id="41b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b">kutebectl create</code>用于创建资源，<code class="fe ob oc od oe b">-f</code>标志用于指向某个文件。</p><p id="1b12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在可以运行<code class="fe ob oc od oe b">kubectl get all</code>来列出所有名称空间中的所有资源。我们可以在Kubernetes中使用名称空间来分离资源，稍后会详细介绍。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/4978aa878878643329ba1db57c1e55f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L_X0gxd4JOjkQNDl0FsOog.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ErrImagePull —如果您忘记评估Minikubes docker env并在其中构建docker映像</p></figure><p id="e3be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您看到Status ErrImagePull，很可能是您忘记了使用Minikubes docker的eval the docker环境。</p><p id="2a63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，每次重启终端时都需要进行评估。另一个常见的错误是，首先在计算机的docker env中构建docker映像，然后是eval。</p><p id="cd60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有任何其他错误，您可以通过使用下面的命令获得关于部署的详细信息。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="63b7" class="me mf it oe b gy pb pc l pd pe">kubectl get deployment/hellogopher -o yaml</span></pre><p id="b0c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要访问应用程序，您需要公开一个节点端口。在go HTTP服务器内部，我们已经对要公开的端口8080进行了硬编码，但是这也需要为Kubernetes进行配置。我们可以使用<code class="fe ob oc od oe b">expose deployment</code>命令来做到这一点，该命令接受资源的名称和要公开的类型。在我们的例子中，我们希望公开一个节点端口，这是公开服务端口的一种方式，如果您希望从部署外部访问服务，这是必需的。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="3296" class="me mf it oe b gy pb pc l pd pe">kubectl expose deployment hellogopher --type=NodePort --port=8080</span></pre><p id="16cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在检查资源的状态(提示:<em class="ly"> kubectl get all </em>)，您应该会看到节点端口。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/3924fb80793291446d48f158fde6b725.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0F-59gKulyDuqoi8OYSpcQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Kubectl get all —输出显示我们现在将hellogopher服务的端口8080公开到主机的30012端口。</p></figure><p id="522d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经注意到，您机器上正在使用的端口是为我动态分配的(30012)。很高兴，Minikube提供了一组命令来帮助我们访问部署，这样我们就不需要跟踪分配的端口。</p><p id="acd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过运行<code class="fe ob oc od oe b">minikube service hellogopher</code>来访问该服务。该命令将打开您的网络浏览器，显示<code class="fe ob oc od oe b">hello gopher</code>消息。</p><p id="f1c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们练习一下，我们想删除部署，因为我们现在已经完成了。你可以使用<code class="fe ob oc od oe b">delete deployment</code>命令来完成。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="7f18" class="me mf it oe b gy pb pc l pd pe">kubectl delete deployment hellogopher</span></pre><h2 id="cb6d" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">标签和选择器</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/87ea15ad4213c548eca9442474562286.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SrjyPluFXLMfXVFTo8pBAQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">标签和选择器允许我们指定目标对象</p></figure><p id="8fb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与Kubernetes合作时，您会遇到术语<code class="fe ob oc od oe b">labels</code>。标签<a class="ae ky" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/" rel="noopener ugc nofollow" target="_blank">是一个键/值对，可以分配给资源。标签通常用于在资源上附加信息，但也用于在大型环境中区分它们。您可以使用标签来定位特定的资源，这些资源使用kubectl命令的匹配标签进行标记，这在您想要删除多个包含相同标签的资源时非常有用。</a></p><p id="6a41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在运行时或在YAML配置中添加标签。让我们尝试一下，以便更好地理解，我们将在pod中添加一个标签运行时。</p><p id="5b18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您注意到了，我们在YAML配置中创建了一个名为<code class="fe ob oc od oe b">app</code>的标签。您可以通过添加<code class="fe ob oc od oe b">--show-labels</code>来查看标签，这是大多数获取资源的kubectl命令的一个参数。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="cecb" class="me mf it oe b gy pb pc l pd pe">kubectl get all --show-labels<br/>kubectl get pods --show-labels</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/2f31f2f56e46e5057f8c85b14bcf0e93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ncNz7AXuGN_mhqD70SWyaA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">显示标签的kubectl命令输出</p></figure><p id="5415" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们为pod创建一个名为author的新标签。请记住，您可以向所有资源添加标签，因此当我们添加标签时，我们将在名称前面使用<code class="fe ob oc od oe b">po</code>，这告诉命令这是一个Pod资源。我们使用<code class="fe ob oc od oe b">kubectl label</code>,后跟资源的名称，带标签的<code class="fe ob oc od oe b">key=value</code>。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="9aaa" class="me mf it oe b gy pb pc l pd pe">kubectl label po/hellogopher-f76b49f9-95v4p author=percy</span></pre><p id="6a54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">获取pod现在应该显示您已经添加了一个作者标签。</p><p id="b280" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时您可能想要更新一个现有的标签，它可能是一个版本标签，或者可能是作者已经更改。在这种情况下，您需要在命令中添加<code class="fe ob oc od oe b">--overwrite</code>参数。我们把作者换成钢铁侠吧。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="afd1" class="me mf it oe b gy pb pc l pd pe">kubectl label po/hellogopher-56d8758b6b-2rb4d author=ironman --overwrite</span></pre><p id="263f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，我们可能想要删除标签，这只是通过使用相同的命令来完成，但是我们使用的是<code class="fe ob oc od oe b">key-</code>命令，而不是<code class="fe ob oc od oe b">key=value</code>。我们再来去掉作者标签。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="19f9" class="me mf it oe b gy pb pc l pd pe">kubectl label po/hellogopher-56d8758b6b-2rb4d author-</span></pre><p id="74d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果您再次使用<code class="fe ob oc od oe b">--show-labels</code>获得pod，它应该不再包含作者标签。</p><p id="d656" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以添加和删除标签非常简单，让我们看看如何使用它们来选择某些资源。</p><p id="26d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用标签来定位资源被称为<code class="fe ob oc od oe b">Selector</code>。大多数kubectl命令接受<code class="fe ob oc od oe b">--selector</code>标志，该标志使用它们的<code class="fe ob oc od oe b">key=value</code>语法接受多个标签。您可以通过逗号分隔来指定多个选择器。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="cd02" class="me mf it oe b gy pb pc l pd pe">kubectl get pods --selector app=hellogopher</span></pre><p id="1786" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以通过在等号前添加一个<code class="fe ob oc od oe b">!</code>来使用负值。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="1c6e" class="me mf it oe b gy pb pc l pd pe">kubectl get pods --selector app!=hellogopher</span></pre><p id="e7a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，基于标签获取资源是很好的，但是想象一下，你有一个巨大的资源集群，这时标签就变得非常重要了。此外，在管理资源时，它们非常方便，并且您需要用同一个命令定位多个实例。让我们尝试删除所有标有app=hellogopher的pod。这里我使用了<code class="fe ob oc od oe b">-l</code>，它是<code class="fe ob oc od oe b">--selector</code>的简写。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="0581" class="me mf it oe b gy pb pc l pd pe">kubectl delete pods -l app=hellogopher</span></pre><p id="3f50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该会看到一条消息，提示pod已被删除，但是如果您尝试获取所有pod，则会出现一个新的pod。</p><p id="efc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，部署中说我们希望1个pod一直运行，Kubernetes会为您处理这个问题。所以，当旧的被删除时，一个新的被创建，不要感到惊讶。这就是我们想要的，如果你想删除一切，你必须删除部署。</p><h2 id="9703" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">活动、就绪和启动探测</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/48d26fad8ef8e94936de1ace81898de7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5L4vBM3xai35VP_HzZ8Xug.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Kubernetes允许我们探测pod的状态</p></figure><p id="516e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes的卖点之一是应用程序监控。我们可以使用探针来监控我们的应用程序，探针用于监控端点、TCP套接字或gRPC端点等的状态。</p><p id="6e18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有三个探测器</p><ul class=""><li id="0287" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><strong class="lb iu">活跃度</strong> —检查容器是否正常运行，如果不是，它将尝试重启该容器。</li><li id="5d24" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><strong class="lb iu"> Readiness </strong> —检查容器是否按预期启动，以及何时准备好供其他服务使用。</li><li id="0d52" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><strong class="lb iu">启动</strong> —该探针将禁用活性和就绪性探针，这是有充分理由的。想象一下，如果容器启动缓慢，并且在启动之前需要运行缓慢的进程，那么并发地，活性探测检查端点是否是活动的，并且它返回500，然后活性探测重新启动。在启动最终完成后，启动将启用活跃度和就绪性。</li></ul><p id="6dcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将从了解如何轻松创建一个简单的就绪性探针开始。我们将添加一个探测错误端口的探测器，该端口是pod不会暴露的。然后，我们将继续检查我们如何能看到为什么吊舱从未准备好。</p><p id="edb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们添加一个需要定义的探针来检查Kubernetes的状态时，有一些不同的探针，最简单的一个是HTTP探针，它发送一个HTTP请求并期望一个200响应。您可以找到可以添加到<a class="ae ky" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/" rel="noopener ugc nofollow" target="_blank">文档</a>中的所有探头类型和配置。</p><p id="b5a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更新<code class="fe ob oc od oe b">hellogopher.yml</code>来定义readinessprobe，注意我们使用了错误的端口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pi md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">hellogopher.yml —检查容器是否就绪的就绪探测器</p></figure><p id="6193" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">删除旧的部署，并重新部署它(如果您不记得本文中如何回溯)。</p><p id="4462" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重新部署部署后，让我们看看如何找出问题所在。</p><p id="f6fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行<code class="fe ob oc od oe b">kubectl get all</code>获取关于部署和pod的信息。获取pod名称，我们将使用该名称来描述它。描述是Kubernetes中获取资源详细信息的一种方式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/07932f58f3d08cfc03f94fd02cc42a5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DaBgZpvuwLJcDb91WcqCDQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ku bectl—pod未准备好(0/1)</p></figure><p id="6baf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">复制名称并描述它。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="31ab" class="me mf it oe b gy pb pc l pd pe">kubectl describe pod/hellogopher-df787c4d5-gbv66</span></pre><p id="cbe7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，它将打印关于pod的大量日志信息。最后，有一个名为<code class="fe ob oc od oe b">Events</code>的部分显示了发生的所有事情。</p><p id="bb78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在event部分，您应该看到失败原因，这应该是准备就绪探测。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/dec8349cff387f22e5023b1793872b55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6zxlckV7Zgk-_GuaRi1sNQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">kubectl describe —显示失败的事件</p></figure><p id="ac2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以将在<code class="fe ob oc od oe b">hellogopher.yml</code>中定义的端口切换到8080，并重新部署，看看它是否工作。</p><p id="eadc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一下活性探测，它的工作方式与就绪探测相同。该探测器一直运行，以检查启动后容器是否在工作。</p><p id="d597" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了测试这一点，我们需要添加探针并更新go HTTP服务器，以便在10秒钟后返回一个失败。然后，我们将更新旧的部署，而不是删除它。</p><p id="ae19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">活性探测器YAML看起来与就绪探测器完全一样，但是多了一个名为<code class="fe ob oc od oe b">failureThreshold</code>的字段，它表示在重启之前允许容器失败的次数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pi md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">hellogopher.yml —更新了活性探测</p></figure><p id="eb25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更改YAML后，我们将更新<code class="fe ob oc od oe b">main.go</code>然后重建docker映像，并更新部署以使用新的映像版本。</p><p id="1646" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在此之前，我想确保我们删除了旧的部署和创建的任何服务</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="baeb" class="me mf it oe b gy pb pc l pd pe">kubectl delete service/hellogopher<br/>kubectl delete deployment hellogopher</span></pre><p id="c6af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将让它在运行10秒钟后开始返回HTTP状态500。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pi md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">main . go-10秒后失败的HTTP服务器版本2</p></figure><p id="6a78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用2.0的新标签重建图像。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="b9c0" class="me mf it oe b gy pb pc l pd pe">docker build -t programmingpercy/hellogopher:2.0 .</span></pre><p id="3ea0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了新的映像，让我们用版本1运行部署，并在运行时更新它，看看会发生什么。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="3284" class="me mf it oe b gy pb pc l pd pe">kubectl create -f hellogopher.yml</span></pre><p id="5e4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您现在用<code class="fe ob oc od oe b">kubectl get all</code>检查，您将看到它已经启动并运行，但它使用的是YAML文件中指定的我们映像的1.0版本。让我们通过使用<code class="fe ob oc od oe b">set image</code>来更新docker图像。第一个参数是部署名称，然后是YAML中定义的pod名称，在我们的例子中是hellogopher。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="1c6c" class="me mf it oe b gy pb pc l pd pe">kubectl set image deployment/hellogopher hellogopher=programmingpercy/hellogopher:2.0</span></pre><p id="0fc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您运行<code class="fe ob oc od oe b">kubectl get all</code>，您可以看到新的pod是如何首先创建的，一旦它准备好了，旧的pod就会被删除。</p><p id="5551" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以通过修改<code class="fe ob oc od oe b">hellogopher.yml</code>文件，然后运行<code class="fe ob oc od oe b">kubectl apply</code>命令来更新集群。您可以通过更改配置中的docker映像版本标签，然后运行它来尝试一下。应用非常有用，因为您不必手动删除资源。它将检测任何需要进行的更改并执行它们。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="e5f6" class="me mf it oe b gy pb pc l pd pe">kubectl apply -f hellogopher.yml</span></pre><p id="3748" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，您可以继续运行状态检查，并看到重启计数在pod上缓慢上升，现在每次在10秒钟后，当容器响应3次失败的探测尝试时，就会发生这种情况。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/22d2d49550df9eecebea9ad923e4deac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y40IObydDgFx12fF6B-Vzw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">显示pod正在重新启动的事件</p></figure><p id="0130" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了，我们有办法在应用程序出现问题时重启它。我们都知道修复所有失败软件的秘诀是重启。</p><p id="ba25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里所做的只是触及了您可以用探针做的事情的表面，但是因为我们处于学习阶段，所以让我们保持简单。</p><h2 id="6bd1" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">调试Pod</h2><p id="0a5a" class="pw-post-body-paragraph kz la it lb b lc pp ju le lf pq jx lh li pr lk ll lm ps lo lp lq pt ls lt lu im bi translated">当我们的软件失败时，重启可能会解决问题，但通常有一个潜在的原因。在K8，调试并找出pod内部发生了什么是相当容易的。</p><p id="f23e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最常见的方法是深入日志，您可以通过使用<code class="fe ob oc od oe b">kubectl logs</code>后跟pod名称来找到pod的日志。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pu"><img src="../Images/3aa12e59935965efd5fa81ae27a2faee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UiC9egadZBZOTa0SIItQ2w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">kubectl日志显示了pod的标准输出</p></figure><p id="7c16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在K8调试时需要学习的另一件非常重要的事情是带着终端进入pod。现在，如果你按照前面的步骤，我们的分离舱会一直崩溃，所以进入会很困难。</p><p id="6309" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我建议你创建一个docker镜像版本3.0，要么增加<code class="fe ob oc od oe b">main.go</code>中的超时限制，要么你必须非常快速地工作。我将通过将代码修改为100秒来快速增加我的时间，用一个新的标记重新构建docker映像，并像以前一样在运行时设置映像。我不会涵盖如何做所有这些，你现在应该能够，或回溯，看看我们以前是如何做的。</p><blockquote class="lv lw lx"><p id="d81e" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">您可以设置一个大于100秒的超时限制，或者现在完全删除它，因为我们已经完成了活动探测，这可能会避免您在测试教程的其余部分时出现崩溃的容器</p></blockquote><p id="56ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从pod内部打开终端很简单，你需要在docker上安装一个终端，bash或ash或其他。</p><p id="0b57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<code class="fe ob oc od oe b">kubectl exec</code>从pod执行命令。我们将添加一面代表互动的旗帜<code class="fe ob oc od oe b">-it</code>。然后指定pod名称，后跟一个<code class="fe ob oc od oe b">--</code>，它将本地命令与pod内部的命令分开，因此在<code class="fe ob oc od oe b">--</code>之后是在pod内部运行的命令。</p><p id="e964" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们想把它连接到终端，所以我们插入到ash的路径。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="bd70" class="me mf it oe b gy pb pc l pd pe">kubectl exec -it pod/hellogopher-79d5bfdfbd-bnhkf -- /bin/sh</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pv"><img src="../Images/13e8355c34d1622f074415ef644b45f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hdZy8pkGFYFYQ4qzHWYexQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">吊舱内部的终端</p></figure><p id="74d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在pod内部并能够运行命令使得调试变得容易得多。</p><p id="b42b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes中一个非常常见的错误是<code class="fe ob oc od oe b">oomkiller</code>，也称为错误代码137。这是应用程序内存不足时发生的错误。这可能是因为节点没有足够的内存，或者应用程序超出了其使用资源的限制。</p><p id="e330" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的应用程序超过了分配给它的内存限制，它将重新启动，如果它仍然超过限制，继续重新启动。因此，重启可以避免常规的内存泄漏，但是如果应用程序使用的内存真的超过了允许的范围，它就会反复杀死容器。</p><h2 id="d940" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">可视化集群</h2><p id="8e2e" class="pw-post-body-paragraph kz la it lb b lc pp ju le lf pq jx lh li pr lk ll lm ps lo lp lq pt ls lt lu im bi translated">关于调试这个话题，很多人想要一个UI来查看正在发生的事情。幸运的是，我们可以通过K8实现这一点，有一个管理控制面板可用于可视化集群。</p><p id="f7e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仪表板可以通过跟随<a class="ae ky" href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/" rel="noopener ugc nofollow" target="_blank">官方文件</a>来使用，或者因为我们使用的是Minikube，它有很多插件，我们可以简单地通过运行来启用仪表板</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="a817" class="me mf it oe b gy pb pc l pd pe">minikube addons enable dashboard<br/>minikube addons enable metrics-server </span></pre><p id="3130" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过运行<code class="fe ob oc od oe b">minikube addons list</code>查看所有minikube插件。</p><p id="f880" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过运行以下命令打开仪表板。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="1e43" class="me mf it oe b gy pb pc l pd pe">minikube dashboard</span></pre><p id="dbe7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将看到一个令人惊叹的控制面板，它为您呈现了群集，该控制面板在监控群集时非常有用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pw"><img src="../Images/5cf54bc14fac0990e538b305874b9586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xgqhvH2MVOQ7h2eFl8HmZg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Kubernetes仪表板—可视化集群</p></figure><p id="7750" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们使用Minikube运行仪表板，您也可以单独运行它，Minikube只是使它在您的开发环境中更容易。请参阅K8文档，了解如何在没有Minikube的情况下运行它。</p><p id="ade1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在UI中，您可以查看工作负载、资源使用情况以及存在哪些资源。</p><p id="be6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以查看日志并在pod中执行。如果您访问pod部分，您还可以看到pod事件以及我们之前通过终端看到的所有内容。</p><h2 id="5e48" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">多个pod、服务和命名空间</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/748615da104a6b8dff6502a7f76b10b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*76qt1GXKxHVxX6xwblUCqA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">服务允许pod之间的通信</p></figure><p id="4e8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们正在运行一个具有单个部署单元的集群。大多数情况下，整个应用程序会有多个部署。</p><p id="750f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过添加一个运行的MySQL数据库来获得一些实际操作，我们的hellogopher应用程序可以连接到这个数据库。</p><p id="3a06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将一步一步来，这样我们就可以探索K8内部的<code class="fe ob oc od oe b">services</code>。<a class="ae ky" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank">服务</a>用于向集群中的其他pod公开pod。</p><p id="08dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一步是添加运行MySQL容器的部署。现在，我们将通过硬编码的环境配置使它变得非常简单，现在不要担心这个。</p><p id="1551" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢分离，所以我建议我们创建一个名为<code class="fe ob oc od oe b">database.yml</code>的新文件，其中包含所有与数据库相关的K8对象。有几种不同的方法来解决这个问题，有时你会在同一个文件中看到许多Kubernetes对象，这可以通过用一个<code class="fe ob oc od oe b">---</code>来分隔文件来实现，它告诉Kubernetes下面的行是一个新对象。</p><p id="adb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，创建一个名为<code class="fe ob oc od oe b">kubernetes</code>的文件夹来存储我们所有的YAML文件可能会比较好。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi px"><img src="../Images/a53d877528e94441174de479f7775a19.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/1*pR9t2tnJ3WLPxLdyv_xbsQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">清理文件夹结构</p></figure><p id="b966" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用一个部署对象填充<code class="fe ob oc od oe b">database.yml</code>。这将用于创建一个简单的MySQL数据库容器和一个值为<code class="fe ob oc od oe b">password</code>的root密码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pi md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">database.yml —使用硬编码密码部署MySQL</p></figure><p id="1b09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们将YAML文件移动到它们自己的文件夹中，让我们用<code class="fe ob oc od oe b">kubectl apply</code>更新正在运行的集群。Apply将检查任何更改并应用这些更改，而保留未更改的资源。它接受一个<code class="fe ob oc od oe b">-f</code>标志，这是文件夹的缩写，你甚至可以用<code class="fe ob oc od oe b">-R</code>让它递归。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="992d" class="me mf it oe b gy pb pc l pd pe">kubectl apply -f kubernetes/</span></pre><p id="23ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在应用之后，您应该看到两个部署启动并运行，hellogopher和MySQL。运行<code class="fe ob oc od oe b">kubectl get all</code>查看集群或访问仪表板。</p><p id="4227" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过在容器中执行来尝试轻松登录MySQL。获取MySQL pod的名称，并使用<code class="fe ob oc od oe b">bash</code>作为命令执行它。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="9919" class="me mf it oe b gy pb pc l pd pe">kubectl exec pod/mysql-77bd8d464d-8vd2w -it -- bash<br/># You are now inside the pod terminal<br/>mysql --user=root --password=$MYSQL_ROOT_PASSWORD</span></pre><p id="d43a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你应该登录一个MySQL，我们还没有做任何事情，所以你可以输入<code class="fe ob oc od oe b">exit</code>离开终端。</p><p id="f027" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在当前设置的一个问题是第一个hellogopher pod不能到达MySQL pod。为了实现这一点，我们必须使用<code class="fe ob oc od oe b">service</code>、<a class="ae ky" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank">服务</a>来允许pod之间或外部世界的访问。K8将负责为pod设置IP地址和DNS名称。您甚至可以包括负载平衡。</p><p id="cef2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决两个pod之间连接的第一步是将它们放在同一个<a class="ae ky" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/" rel="noopener ugc nofollow" target="_blank">名称空间</a>中。命名空间用于将资源或资源组隔离到同一个群集中。默认情况下，使用<code class="fe ob oc od oe b">default</code>名称空间。因此，现在我们的pod在同一个名称空间中，但是我们希望控制名称空间，提到名称空间是很重要的，因为资源使用的名称空间是DNS名称的一部分。</p><p id="1e82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Kubernetes文件夹中创建一个名为<code class="fe ob oc od oe b">00_namespace.yml</code>的新文件。Kubernetes使用前缀<code class="fe ob oc od oe b">00</code>来知道创建资源的顺序，这很重要，因为我们的资源需要首先创建名称空间。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pi md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">00_namespace.yml —将创建的第一个对象</p></figure><p id="72d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将把<code class="fe ob oc od oe b">database.yml</code>重命名为<code class="fe ob oc od oe b">01_database.yml</code>，这样数据库就是创建的第二个项目。我们将在文件中添加一个<code class="fe ob oc od oe b">---</code>,如前所述，这告诉Kubeternetes在同一个文件中出现了一个新对象。在三连破折号之后，我们将创建服务，注意我们没有告诉K8服务连接到哪个资源，但是我们设置了一个选择器。</p><p id="3e8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是服务如何通过应用到选择器匹配的所有其他对象来知道要公开哪些部署。所以在我们的例子中，任何带有标签<code class="fe ob oc od oe b">app: mysql</code>的资源都将被暴露。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pi md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">01 _ database.yml添加了服务的新数据库YAML文件</p></figure><p id="471b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我已经在每个对象上添加了<code class="fe ob oc od oe b">namespace: hellogopher</code>标签作为元数据。这是一种方法，另一种方法是使用<code class="fe ob oc od oe b">use-context</code>改变默认使用的名称空间。我们不会在这里讨论如何建立多个使用环境，你可以在<a class="ae ky" href="https://kubernetes.io/docs/tasks/administer-cluster/namespaces-walkthrough/" rel="noopener ugc nofollow" target="_blank">文档</a>中读到它们。</p><p id="6114" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">确保在<code class="fe ob oc od oe b">hellogopher.yml</code>文件中也添加了名称空间。然后从默认名称空间中删除任何现有的部署和服务，然后重新部署。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="b15a" class="me mf it oe b gy pb pc l pd pe">kubectl apply -f kubernetes</span></pre><p id="46d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尝试使用<code class="fe ob oc od oe b">kubectl get all</code>获取资源，您会注意到没有资源。这是因为该命令使用默认的名称空间，我们可以通过在当前上下文中设置名称空间来将其设置为默认名称空间。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="a406" class="me mf it oe b gy pb pc l pd pe">kubectl config set-context --current --namespace=my-namespace</span></pre><p id="ce34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在当你获取资源时，你应该可以看到所有的资源。您可以跳过在YAML文件中指定名称空间，但是如果在同一个部署中有多个名称空间，这将非常有用。</p><p id="4c5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了一个部署，它将为我们设置Pod和ReplicaSet，这是一个公开数据库的服务，我们已经将它们包含在它们自己的名称空间中。</p><p id="3e71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，要访问hellogopher服务，您需要在以后使用<code class="fe ob oc od oe b">-n</code>将名称空间应用到minikube命令。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="18a5" class="me mf it oe b gy pb pc l pd pe">minikube service hellogopher -n hellogopher</span></pre><h2 id="6a08" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">连接到数据库</h2><p id="2d33" class="pw-post-body-paragraph kz la it lb b lc pp ju le lf pq jx lh li pr lk ll lm ps lo lp lq pt ls lt lu im bi translated">现在我们有两个pod，一个运行我们的软件，一个运行MySQL。我们需要连接到MySQL one，它在一个服务的后面。</p><p id="e589" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Kubernetes中有两种方法可以找到需要的服务信息，比如IP和端口。你可以在这里阅读更多关于它们的细节<a class="ae ky" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="11e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一种，也是首选的生产方式是使用DNS。Kubernetes允许我们安装一个可以使用的CoreDNS插件。如果你安装了一个DNS，你可以使用它的名字来引用服务，就像你在docker-compose中做的一样。</p><p id="1997" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二种方法是使用内置的发现。创建的每个pod都将获得一组为同一名称空间中的每个服务设置的环境变量。这要求首先创建服务，然后创建pod。我们使用<code class="fe ob oc od oe b">00_</code>和<code class="fe ob oc od oe b">01_</code>名称前缀解决了这个问题。</p><p id="de00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">环境变量将被命名为<code class="fe ob oc od oe b">{SERVICENAME}</code>作为前缀。在我们的例子中，我们将服务命名为<code class="fe ob oc od oe b">mysql</code>。因此，在我们的服务之后创建的所有pod都将设置以下变量。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="36a2" class="me mf it oe b gy pb pc l pd pe">MYSQL_SERVICE_HOST=10.0.0.11<br/>MYSQL_SERVICE_PORT=3306<br/>MYSQL_PORT=tcp://10.0.0.11:3306<br/>MYSQL_PORT_3306_TCP=tcp://10.0.0.11:3306<br/>MYSQL_PORT_3306_TCP_PROTO=tcp<br/>MYSQL_PORT_3306_TCP_PORT=3306<br/>MYSQL_PORT_3306_TCP_ADDR=10.0.0.11</span></pre><p id="d930" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以尝试在HelloGopher pod中执行并打印变量来进行测试。</p><p id="458c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们更新Go代码来连接数据库，以确保一切正常。我将创建一个名为<code class="fe ob oc od oe b">mysql.go</code>的新文件，其中包含数据库代码，因为我们在本教程中没有关注Go，所以我不会详细解释。代码将使用与我们的服务相关的环境变量连接到数据库，如果数据库不存在，它将创建它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pi md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">mysql.go —使用服务变量连接到数据库</p></figure><p id="3e0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加之后，我们需要从主函数执行连接。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pi md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">main.go添加了要执行的数据库连接</p></figure><p id="e8c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了，连接数据库的代码准备好了。我们需要重新构建docker并更新我们的集群以使用新版本，我将用版本<code class="fe ob oc od oe b">5.0</code>标记它。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="a59c" class="me mf it oe b gy pb pc l pd pe">docker build -t programmingpercy/hellogopher:5.0 .</span></pre><p id="c0fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们需要更新集群以使用这个版本的代码，您可以在运行时通过更改docker映像，或者更新YAML并应用。由于我们还需要添加一些不会自动生成的环境变量，比如<code class="fe ob oc od oe b">DATABASE_USERNAME</code>、<code class="fe ob oc od oe b">DATABASE_PASSWORD</code>、<code class="fe ob oc od oe b">DATABASE_NAME</code>，我建议我们更新<code class="fe ob oc od oe b">hellogopher.yml</code>。我们可以使用<code class="fe ob oc od oe b">env</code>字段添加这些变量，并为每个变量设置<code class="fe ob oc od oe b">name</code>和<code class="fe ob oc od oe b">value</code>。</p><p id="041b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还将确保将文件重命名为<code class="fe ob oc od oe b">02_hellogopher.yml</code>。因为我们希望它在MySQL服务之后创建。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pi md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">02 _ hellogopher.yml更新的yml，带有数据库的环境变量</p></figure><p id="91a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了测试这一点，您可以应用新的配置，然后执行MySQL pod并查看可用的数据库，您应该会看到一个名为<code class="fe ob oc od oe b">test</code>的数据库。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="df1b" class="me mf it oe b gy pb pc l pd pe">mv kubernetes/hellogopher.yml kubernetes/02_hellogopher.yml<br/>kubectl apply -f kubernetes/<br/>kubectl exec pod/mysql-77bd8d464d-n5fx5 -it -- sh<br/>#: mysql -p<br/>show databases;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi py"><img src="../Images/5ec6016c74f0b7944de2f92e47ee267b.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/1*gkhobkSCHUIb6aEVpKA2Iw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数据库显示在SQL窗格上，HelloGopher窗格成功创建了测试</p></figure><p id="bdc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了，现在我们的豆荚连在一起了！</p><h2 id="b858" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">配置映射和机密</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/f3d418817febdb432883f1ddd2f369cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*15L8g-2ccL-TsBvBv5LUWw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">配置映射和秘密在Kubernetes中用于配置应用程序</p></figure><p id="d01f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能已经注意到，现在我们在YAML的文件中有明文的硬编码密码。正如您所猜测的，这不是一个好的做法。</p><p id="21e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes允许我们使用<code class="fe ob oc od oe b">configmap</code>和<code class="fe ob oc od oe b">secrets</code>来处理配置和秘密。您可以在<a class="ae ky" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/" rel="noopener ugc nofollow" target="_blank">文档</a>中找到详细信息。</p><p id="da76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您有非机密值时，应该使用配置映射，当您有敏感值(如密码)时，应该使用secret。</p><p id="4a51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用适当的解决方案代替环境变量。我们将把<code class="fe ob oc od oe b">DATABASE_NAME</code>和<code class="fe ob oc od oe b">DATABASE_USER</code>存储在一个配置图中，但是密码是保密的。</p><p id="f0f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从创建Configmap开始，您可以从字面量(基本上是将值设置为字符串)开始创建。您也可以使用使用换行符作为分隔符的文件。因为你通常有多个环境变量，我更喜欢使用一个文件。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="a3b9" class="me mf it oe b gy pb pc l pd pe"># Using Literal <br/>kubectl create configmap myConfigMap --from-literal=log_level=debug<br/># Using a file<br/>kubectl create configmap myConfigMap --from-env-file=path/to/file</span></pre><p id="d393" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从试验开始。创建一个名为<code class="fe ob oc od oe b">dbConfig.properties</code>的新文件，并将以下值插入其中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pi md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">dbConfig.properties —我们的非机密数据库属性</p></figure><p id="ac31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以使用<code class="fe ob oc od oe b">create configmap</code>命令创建这个配置图。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="a36f" class="me mf it oe b gy pb pc l pd pe">kubectl create configmap database-configs --from-env-file=dbConfig.properties </span></pre><p id="d577" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，您可以通过指定要自省的配置映射的名称来查看配置映射或有关配置映射的详细信息。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="e39a" class="me mf it oe b gy pb pc l pd pe">kubectl get configmaps</span><span id="363f" class="me mf it oe b gy pf pc l pd pe">kubectl get configmap/myConfigMap -o yaml</span></pre><p id="715b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要更新<code class="fe ob oc od oe b">02_hellogopher.yml</code>来开始使用配置图。为了使用configmap，我们将用<code class="fe ob oc od oe b">valueFrom</code>替换每个环境变量的<code class="fe ob oc od oe b">value</code>字段。这个属性接受一个对象，我们将在<code class="fe ob oc od oe b">configMapKeyRef</code>中传递这个对象。这是Kubernetes引用同一名称空间中某个配置映射的一种方式，使用<code class="fe ob oc od oe b">name</code>表示配置映射，使用<code class="fe ob oc od oe b">key</code>表示我们想要的特定值。</p><p id="7125" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是YAML的更新版本，它使用我们的新配置图获取值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pi md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">02_hellogopher.yml —我们用valueFrom替换value字段</p></figure><p id="0b9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过应用新的更改，然后获取日志来查看一切是否仍然工作，来尝试这种方法。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="9dfd" class="me mf it oe b gy pb pc l pd pe">kubectl apply -f kubernetes/</span></pre><p id="54cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在这是一个很大的改进，我们仍然有密码，但我们会先看看。在我们这样做之前，我想解决当前configmap方法的一个问题，如果您有许多环境变量，正如您可能理解的那样，这将成为在YAML中配置的大量文本。</p><p id="5348" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，您可以应用整个configmap，而无需专门分配每个键值。我们可以通过添加一个<code class="fe ob oc od oe b">envFrom</code>字段来做到这一点，该字段接受YAML内容器上的配置图的名称。这将使所有的配置键作为环境变量出现在pod中。</p><p id="d968" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是我们这样做的要点，注意我不再需要分配<code class="fe ob oc od oe b">DATABASE_NAME</code>或<code class="fe ob oc od oe b">DATABASE_USER</code>，因为它们在配置图中有定义。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pi md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">02 _ hellogopher.yml改为使用configMapRef应用整个ConfigMap。</p></figure><p id="8b86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想确保它仍然工作，可以继续并重试部署。</p><p id="4226" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们已经创建了一个部署使用的ConfigMap，但是我们也向这个configmap引入了一个很小的奇怪的依赖项。没有手动创建它的人将无法部署，因为他们没有它，而我们不能拥有它。</p><p id="3a6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个非常简单的解决方案是添加一个新的Kubernetes对象来创建configmap。由于这与数据库有关，所以我将它添加到<code class="fe ob oc od oe b">01_database.yml</code>文件中。再次，一个新的对象，所以我们需要通过在新的一行上添加<code class="fe ob oc od oe b">---</code>来划定它的界限。因为这是一个常规的配置，没有秘密，我们可以简单地预置一个默认值。</p><p id="60fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将移动<code class="fe ob oc od oe b">dbConfig.properties</code>中的所有设置，以便您可以删除该文件。请记住，我们将它添加在<code class="fe ob oc od oe b">01_database.yml</code>文件的底部。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pi md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">01 _ database.yml将其添加到文件的底部</p></figure><p id="0f20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">删除旧的手动创建的配置映射并重新应用集群。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="3b45" class="me mf it oe b gy pb pc l pd pe">kubectl delete configmap database-configs<br/>kubectl apply -f kubernetes/</span></pre><p id="603c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看创建的配置图，查看日志，并确保一切仍在运行。到目前为止，您应该已经熟悉了。</p><p id="b8bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是时候处理最后一块了，秘密密码。许多应用程序都需要存储机密。对我们来说幸运的是，这几乎和ConfigMap完全一样，只是一个SecretMap</p><p id="2ae1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将从对我们的秘密值进行base64编码开始，所有的秘密都应该以base64格式存储。请记住，这是不安全的。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="dc99" class="me mf it oe b gy pb pc l pd pe">percy@pc038:~/private/kubernetes/hellogopher$ echo -n "password" | base64<br/>cGFzc3dvcmQ=</span></pre><p id="3e6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将获取输出的值，并将其放入清单文件<code class="fe ob oc od oe b">01_database.yml</code>。正如configmap一样，我们将创建一个秘密对象，用于存储我们可以引用的秘密。</p><p id="465e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe ob oc od oe b">01_database.yml</code>中，在底部添加以下要点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pi md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">01 _ database.yml在底部添加了一个秘密对象映射</p></figure><p id="60df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要更改<code class="fe ob oc od oe b">02_hellogopher.yml</code>来使用这个秘密。用以下要点替换环境变量<code class="fe ob oc od oe b">DATABASE_PASSWORD</code>。正如我们使用<code class="fe ob oc od oe b">configMapRef</code>一样，我们现在将使用<code class="fe ob oc od oe b">secretKeyRef</code>。语法是一样的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pi md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">02_hellogopher.yml —密钥被引用</p></figure><p id="33c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用更改，并看到它创建了秘密。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="614f" class="me mf it oe b gy pb pc l pd pe">kubectl apply -f kubernetes/</span></pre><p id="ca60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您现在可以通过运行以下命令列出所有存在的秘密</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="4be1" class="me mf it oe b gy pb pc l pd pe">kubectl get secrets</span></pre><p id="2272" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后选择要反省的名称，并通过提供它们的名称来显示关于某些秘密的更详细的信息。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="d865" class="me mf it oe b gy pb pc l pd pe">kubectl get secrets database-secrets -o yaml</span></pre><p id="f87e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想确定，从pod中获取日志以确保它工作。</p><p id="0f71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你可能会想，嘿，我们仍然有“明文”密码，因为base64没有增加任何保护。幸运的是，我们可以用Kubernetes patch命令替换这些值。这太棒了，因为我们可以在CI/CD中自动进行秘密修补。</p><p id="b9eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用的命令是<code class="fe ob oc od oe b">patch secret</code>，后跟秘密对象的名称。然后我们指定JSON，因为我们希望补丁请求使用JSON格式。</p><p id="2e56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该命令的输入作为有效负载<code class="fe ob oc od oe b">-p</code>标志发送，它接受一组要应用的更改。<code class="fe ob oc od oe b">op</code>代表操作，是我们想要执行的操作，在我们的例子中是替换。<code class="fe ob oc od oe b">path</code>是秘密的完整路径，通常是/data/your-secret-name，然后是值。记住该值应该是base64编码的。</p><pre class="kj kk kl km gt ox oe oy oz aw pa bi"><span id="b61e" class="me mf it oe b gy pb pc l pd pe">kubectl patch secret database-secrets --type='json' -p='[{"op" : "replace" ,"path" : "/data/DATABASE_PASSWORD" ,"value" : "test"}]'</span></pre><p id="5363" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">替换密码后，尝试重新应用更改并获取日志来验证数据库连接是否失败。</p><h2 id="2aac" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">资源有限</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/fc56d751a8b02852f7c8521f0ac35416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wPkGUuZK7H3wAubc3HO6fw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">吊舱失控旋转，在无限量的内存中旋转</p></figure><p id="1ae9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们结束本教程之前，我想说明一个我们还没有触及的重要方面。现在，我们创建的资源已经设置好了，一切都如我们所期望的那样工作，但是pod可以自由地使用他们想要的计算机上的任何资源。</p><p id="c275" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种类型的设置你需要熟悉<code class="fe ob oc od oe b">limit</code>和<code class="fe ob oc od oe b">request</code>。</p><p id="3889" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">请求— </strong>是节点需要提供的最小可用资源，以便在其上创建pod。<br/> <strong class="lb iu">限制— </strong>是允许您的pod使用的最大资源量。除非指定，否则pod可以在节点上使用无限量的资源。</p><p id="5855" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<code class="fe ob oc od oe b">top</code>命令查看您当前的pods正在使用多少资源。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pz"><img src="../Images/b181e45cc6368f5bc26cbbad658179f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*J99eC9h0zxcDs0BA-5HqSg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Pod资源资源用量</p></figure><p id="b78d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在图中，您可以看到我们列出了CPU内核和已用内存，这是两种最常见的资源。</p><p id="f080" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们为hellogopher pod添加资源限制，然后您可以尝试自己限制MySQL。</p><p id="40da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">hellogopher是一个超级简单的API，它不需要一个完整的CPU内核，所以我们首先将它限制在0.1个内核，通常你会看到一个数字，如代表0.5个CPU内核的<code class="fe ob oc od oe b">500m</code>。所以要得到0.1核，我们需要把极限设为<code class="fe ob oc od oe b">100m</code>。</p><blockquote class="my"><p id="6d59" class="mz na it bd nb nc nd ne nf ng nh lu dk translated">对于CPU资源单位，<a class="ae ky" href="https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/quantity/" rel="noopener ugc nofollow" target="_blank">数量</a>表达式<code class="fe ob oc od oe b">0.1</code>等价于表达式<code class="fe ob oc od oe b">100m</code>，可以读作“一百毫CPU”——<a class="ae ky" href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/" rel="noopener ugc nofollow" target="_blank">Kubernetes资源文档</a></p></blockquote><p id="0839" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">该服务不需要太多内存，因为它是一个超级简单的API。我们将它限制在<code class="fe ob oc od oe b">10Mi</code>，你可以在<a class="ae ky" href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/" rel="noopener ugc nofollow" target="_blank">内存文档</a>中阅读更多关于所有可用单元的信息。</p><p id="6f70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住，要求是最低的，限制是最高的。让我们将它应用到我们的配置中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pi md l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">hellogopher.yml更新了资源限制</p></figure><p id="9397" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设置限制很好，因为它可以使您的部署更便宜，避免使用不必要的资源。不要把它设置得太低，内存不足很可能会导致你的pod崩溃。</p><p id="722f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以继续并重新应用配置以确保其工作，并尝试在数据库上设置资源。</p><h2 id="6a17" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">结论</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/cd22da474bb3f2b6d5f009144a812357.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0HZXtQcyCW3ELJ-Z8KUwqg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这条路并没有到此为止，在掌握Kubernetes之前还有很多东西要学</p></figure><p id="e0fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，我们介绍了如何配置一个简单的Kubernetes应用程序，以及如何使用Minikube在本地节点上运行它。我们只是触及了基础，在成为Kubernetes大师之前还有很多要学的。希望我已经帮助你开始走上这条路。</p><p id="09e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本教程的最终代码可以在<a class="ae ky" href="https://github.com/percybolmer/kubedemo" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><p id="fe79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望您对Kubernetes中使用的组件有了更多的了解。我可以推荐《Kubernetes the hard way 》( Kubernetes the hard way )( T16 ),这是凯尔西·海托华(Kelsey Hightower)的一个更深入的教程，但也更难。</p><p id="538f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将Kubernetes部署到生产环境中本身就是一个完整的教程。我建议在<code class="fe ob oc od oe b">kubeadm</code>和<code class="fe ob oc od oe b">kops</code>上搜索，以熟悉用于部署的工具。轻松部署Kubernetes的一种方式是在AWS、Google或Azure上使用托管服务。它们让您可以非常轻松地进行部署，而不是自己设置一切。</p><p id="919c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubeadm 是一个无需任何麻烦的设置就能轻松建立新集群的工具。</p><p id="6ec8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/kubernetes/kops" rel="noopener ugc nofollow" target="_blank"> Kops </a>是一个在AWS上创建和维护生产级集群的工具。</p><p id="86c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我建议查看一下<a class="ae ky" href="https://kubernetes.io/docs/tasks/administer-cluster/namespaces-walkthrough/" rel="noopener ugc nofollow" target="_blank">的配置环境</a>，这样你就可以在开发和生产环境之间切换，在生产环境中，我建议添加更多的标签。</p><p id="4837" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我推荐另外两个工具，它们可能会有所帮助，希望我很快会创建关于这些工具的教程。</p><p id="af4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用于从docker-compose创建Kubernetes配置的工具。</p><p id="2a48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank"> Helm </a> —简化Kubernetes应用程序的安装和管理。可以把它看作是Kubernetes应用程序的包管理器。</p><p id="cabe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢它，随时联系任何问题、反馈或未来文章的提示。</p></div></div>    
</body>
</html>