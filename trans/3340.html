<html>
<head>
<title>Stream Graphs Basics with Python's Matplotlib</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python Matplotlib的流图基础</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/stream-graphs-basics-with-pythons-matplotlib-5165828359a5#2022-07-25">https://towardsdatascience.com/stream-graphs-basics-with-pythons-matplotlib-5165828359a5#2022-07-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="256a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">堆积面积图的漂亮表亲</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0ef504fef3f3ccf44a13c2d81c4cab4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XpLxl8Uv2FhNXQUJVez8Pw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">流图—按作者分类的图像</p></figure><p id="1593" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管看起来有点吓人，但流图非常容易绘制。</p><p id="817d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它们几乎和堆积面积图一样，只是底部没有固定的轴。这个小小的改变可以减少陡峭的角度，让图表更加流畅，通常是以牺牲准确性为代价。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lu"><img src="../Images/dccb927e6a2bd9b461a1bff2483918d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gO9YZn6LauEoD-d-L196Nw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">流图—按作者分类的图像</p></figure><p id="ab40" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管如此，这种可视化效果非常好，显示了组成中的模式、趋势和变化。总的来说，流图的独特形式使它们更有吸引力，在我看来，也更具美感。</p><p id="2ed2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文将介绍使用Matplotlib绘制流图的基础知识，从折线图和面积图到流。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="258e" class="mc md it bd me mf mg dn mh mi mj dp mk lh ml mm mn ll mo mp mq lp mr ms mt mu bi translated">安装</h2><p id="4db7" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">对于下面的例子，我们需要Pandas、Matplotlib和一个虚拟数据集。我们的数据框有一列是年份，一列是值，最后一列是类别。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="ea3b" class="mc md it nb b gy nf ng l nh ni">import matplotlib.pyplot as plt<br/>import pandas as pd</span><span id="abb5" class="mc md it nb b gy nj ng l nh ni">url = '<a class="ae nk" href="https://gist.githubusercontent.com/Thiagobc23/6cbe0f2ae9fe39032b6c3e623817a8ff/raw/4ad9f5eb8998f2d548b371b7c5e91f36098b87b0/dummy_stack.csv'" rel="noopener ugc nofollow" target="_blank">https://gist.githubusercontent.com/Thiagobc23/6cbe0f2ae9fe39032b6c3e623817a8ff/raw/4ad9f5eb8998f2d548b371b7c5e91f36098b87b0/dummy_stack.csv'</a><br/>df = pd.read_csv(url)<br/>channels = df.Channel.unique()</span><span id="0afc" class="mc md it nb b gy nj ng l nh ni">df.groupby('Channel').describe()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/0fd0542c6be889142d3c2f7924ce6ed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:472/format:webp/1*hvfpxcn6i82Nz-ZXoGVpNg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数据框-按作者分类的图像</p></figure><h2 id="e2c1" class="mc md it bd me mf mg dn mh mi mj dp mk lh ml mm mn ll mo mp mq lp mr ms mt mu bi translated">线</h2><p id="f24f" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">我们将从简单的折线图开始，遍历一个类别列表并分别绘制每条线。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="a5a6" class="mc md it nb b gy nf ng l nh ni">fig, ax = plt.subplots(1, figsize=(16,4))</span><span id="732f" class="mc md it nb b gy nj ng l nh ni">for c in channels:<br/>    temp = df[df['Channel'] == c]<br/>    plt.plot(temp.Date, temp.Value)</span><span id="672a" class="mc md it nb b gy nj ng l nh ni">plt.legend(channels)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/04d1d653499613ceebd60a7b39d31e95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d4W9cfNx1ZZgP7oDde4vQQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">折线图—按作者分类的图像</p></figure><p id="bf0b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">折线图对于可视化这些数据来说还不错；这让我们对正在发生的事情有了一个很好的了解。但是我们不能在这里比较总值，这是折线图和堆积面积图或流图的关键区别。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="ddef" class="mc md it bd me mf mg dn mh mi mj dp mk lh ml mm mn ll mo mp mq lp mr ms mt mu bi translated">区域</h2><p id="0bf6" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">在我们转向流图之前，我们先画一个面积图。为了绘制它，我们将合计每条线的值，并将其用作下一条线的基线。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="74e6" class="mc md it nb b gy nf ng l nh ni">fig, ax = plt.subplots(1, figsize=(16,4))</span><span id="c29e" class="mc md it nb b gy nj ng l nh ni">stack = 0<br/>for c in channels:<br/>    temp = df[df['Channel'] == c]<br/>    stack = stack + temp['Value'].values<br/>    plt.plot(temp.Date, stack)</span><span id="6e1d" class="mc md it nb b gy nj ng l nh ni">plt.legend(channels)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/f62749540b6db9438cea585ffbef4869.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RZDaahxF0g1wGSDNS-U03g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">未填充区域图—作者提供的图像</p></figure><p id="1f82" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们可以用颜色填充每个类别的区域；为此，我们将使用<code class="fe no np nq nb b">fill_between</code>函数。</p><p id="1992" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该函数需要三个参数x、y1和y2，其中y1定义区域的底部，y2定义区域的顶部。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="fb3f" class="mc md it nb b gy nf ng l nh ni">fig, ax = plt.subplots(1, figsize=(16,4))</span><span id="b23f" class="mc md it nb b gy nj ng l nh ni">stack = 0<br/>for c in channels:<br/>    temp = df[df['Channel'] == c]<br/>    stack = stack + temp['Value'].values<br/>    plt.fill_between(temp.Date, stack - temp['Value'].values, stack)</span><span id="abaf" class="mc md it nb b gy nj ng l nh ni">plt.legend(channels)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/f46f190d85a0d4e50724e0f954e66c25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*50lqf-9vYBah_hwtOuvbaw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">堆积面积图-按作者分类的图像</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="7c0a" class="mc md it bd me mf mg dn mh mi mj dp mk lh ml mm mn ll mo mp mq lp mr ms mt mu bi translated">流</h2><p id="6306" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">绘制流图有不同的方法。我们将保持简单，使我们的基线正好在中心。</p><p id="226b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了找到中心，我们需要所有类别的总和，按天，除以2。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="108d" class="mc md it nb b gy nf ng l nh ni">adjust = df.groupby('Date').sum().Value.values / 2</span><span id="e3a8" class="mc md it nb b gy nj ng l nh ni">fig, ax = plt.subplots(1, figsize=(16,4))</span><span id="c652" class="mc md it nb b gy nj ng l nh ni">stack = 0<br/>for c in channels:<br/>    temp = df[df['Channel'] == c]<br/>    stack = stack + temp['Value'].values<br/>    plt.fill_between(temp.Date, stack - temp['Value'].values - adjust, stack-adjust)</span><span id="a441" class="mc md it nb b gy nj ng l nh ni">plt.legend(channels)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/1afcc4f601813d55c483ccad2f5eb4e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zh82iQPsah-MbkhpsO4X0A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">流图—按作者分类的图像</p></figure><p id="f1c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是我们的流图。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="0ef1" class="mc md it bd me mf mg dn mh mi mj dp mk lh ml mm mn ll mo mp mq lp mr ms mt mu bi translated">更进一步</h2><p id="2f35" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">尽管绘制流图非常简单，但是很难做出一个好的流图。许多因素会改变人们对数据的看法。</p><p id="5e0a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，<a class="ae nk" href="http://www.yunhaiwang.net/infoVis2020/sinestream/index.html" rel="noopener ugc nofollow" target="_blank">本文</a>探讨了定义基线和类别顺序的不同算法和方式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/857b01981febf8d327a604d883384576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HoGhtS54P5Ito7BKyAgERA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">资料来源:传布，张全杰，，，迈克尔·塞德梅尔，奥利弗·杜森，——<strong class="bd nt">正弦:通过最小化正弦错觉效应提高流图的可读性</strong>——<strong class="bd nt"/>IEEE可视化与计算机图形学汇刊(Proc。InfoVis 2020)，2021。<a class="ae nk" href="http://www.yunhaiwang.net/infoVis2020/sinestream/index.html" rel="noopener ugc nofollow" target="_blank"><strong class="bd nt">http://www.yunhaiwang.net/infoVis2020/sinestream/index.html</strong></a></p></figure><p id="c896" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下也是最后一个示例探索了数据集的不同形状、一些插值和对基线的轻微调整。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="6b4f" class="mc md it nb b gy nf ng l nh ni">import matplotlib.pyplot as plt<br/>import numpy as np<br/>import pandas as pd<br/>from scipy.interpolate import pchip</span><span id="d5b5" class="mc md it nb b gy nj ng l nh ni">url = '<a class="ae nk" href="https://gist.githubusercontent.com/Thiagobc23/6cbe0f2ae9fe39032b6c3e623817a8ff/raw/4ad9f5eb8998f2d548b371b7c5e91f36098b87b0/dummy_stack.csv'" rel="noopener ugc nofollow" target="_blank">https://gist.githubusercontent.com/Thiagobc23/6cbe0f2ae9fe39032b6c3e623817a8ff/raw/4ad9f5eb8998f2d548b371b7c5e91f36098b87b0/dummy_stack.csv'</a><br/>df = pd.read_csv(url)<br/>channels = df.Channel.unique()<br/>yrs = df.Date.unique()</span><span id="ae51" class="mc md it nb b gy nj ng l nh ni"># reshape the df, one column for each category / "Channel"<br/>df = pd.pivot_table(df, values='Value', index='Date',<br/>                    columns='Channel', aggfunc=np.sum).reset_index()</span><span id="2212" class="mc md it nb b gy nj ng l nh ni"># create the df with the new x<br/>df2 = pd.DataFrame(np.linspace(0, len(df)-1, num=len(df)*4))<br/>df2.columns = ['x']</span><span id="bdee" class="mc md it nb b gy nj ng l nh ni"># interpolate each line<br/>for c in channels:<br/>    x = np.arange(0,len(df))<br/>    y = df[c]<br/>    f2 = pchip(x, y) <br/>    <br/>    xnew = np.linspace(0, len(df)-1, num=len(df)*4)<br/>    df2[c] = f2(xnew)</span><span id="c285" class="mc md it nb b gy nj ng l nh ni">#########    </span><span id="958d" class="mc md it nb b gy nj ng l nh ni">fig, ax = plt.subplots(1, figsize=(160,40), facecolor='#2C2C2C')<br/>ax.set_facecolor('#2C2C2C')</span><span id="3be2" class="mc md it nb b gy nj ng l nh ni">colors = ['#DB504A', '#FC9F5B', '#7DCFB6', '#FFF275', '#63B0CD']</span><span id="ff6d" class="mc md it nb b gy nj ng l nh ni"># get the center value for each date<br/>adjust = df2[channels].sum(axis=1)/2<br/># adjust the adjust :)<br/>adjust = adjust * 0.3</span><span id="c91f" class="mc md it nb b gy nj ng l nh ni">stack = np.zeros(len(df2))<br/>for i, c in enumerate(channels):<br/>    # y1 is the bottom line of each category<br/>    y1 = stack-adjust<br/>    <br/>    # plot<br/>    plt.fill_between(df2.x, y1, y1+df2[c], edgecolor='w', lw=0, color=colors[i])<br/>    <br/>    # stack is the cummulative value of the bottom categories<br/>    stack = stack + df2[c]</span><span id="89cf" class="mc md it nb b gy nj ng l nh ni"># ticks<br/>plt.xticks(np.arange(0, len(yrs)), yrs, color='lightgrey', fontsize=80)<br/>plt.yticks([])</span><span id="3627" class="mc md it nb b gy nj ng l nh ni"># remove spines<br/>ax.spines['right'].set_visible(False)<br/>ax.spines['left'].set_visible(False)<br/>ax.spines['top'].set_visible(False)<br/>ax.spines['bottom'].set_visible(False)</span><span id="084a" class="mc md it nb b gy nj ng l nh ni"># grid<br/>ax.set_axisbelow(True)<br/>ax.xaxis.grid(color='lightgrey', linestyle='dashed', alpha=1, lw=5)</span><span id="5557" class="mc md it nb b gy nj ng l nh ni">#plt.legend(channels)<br/>plt.savefig('stream.svg')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lu"><img src="../Images/dccb927e6a2bd9b461a1bff2483918d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gO9YZn6LauEoD-d-L196Nw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">*导出图表后添加的标题和注释。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="219f" class="mc md it bd me mf mg dn mh mi mj dp mk lh ml mm mn ll mo mp mq lp mr ms mt mu bi translated">结论</h2><p id="1498" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">流图可以相当宽容，因为我们并不关注精确的数据表示，但这并不意味着我们应该粗心大意。</p><p id="9bca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在设计和展示流图时，我们必须谨慎。良好的做法，如明确告知我们的观众视觉的重点和图表打算回答什么问题，可以走很长的路。</p><p id="68ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总的来说，我认为图表有两个决定性的优势:它足够独特，可以抓住人们的注意力；它足够准确，可以展示一个简单的模式或趋势，特别是如果我们注释了值，并且清楚地知道我们试图展示什么。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="f9cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读我的文章！点击查看更多我的Python数据可视化教程<a class="ae nk" href="https://linktr.ee/thiagobc23" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="b578" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">参考文献和更多资源<br/> </strong> <a class="ae nk" href="http://www.yunhaiwang.net/infoVis2020/sinestream/index.html" rel="noopener ugc nofollow" target="_blank">正弦流:通过最小化正弦错觉效应来提高流图的可读性</a>；<br/><a class="ae nk" href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.fill_between.html" rel="noopener ugc nofollow" target="_blank">Matplotlib Fill _ between</a>；<br/> <a class="ae nk" href="https://datavizcatalogue.com/methods/stream_graph.html" rel="noopener ugc nofollow" target="_blank">流图—数据目录</a>；<br/> <a class="ae nk" href="https://ieeexplore.ieee.org/document/4658136" rel="noopener ugc nofollow" target="_blank">堆积图——几何与美学</a>；</p></div></div>    
</body>
</html>