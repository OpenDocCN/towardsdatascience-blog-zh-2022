<html>
<head>
<title>Feature Engineering for Time Series Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间序列数据的特征工程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/feature-engineering-for-time-series-data-f0cb1c1265d3#2022-03-29">https://towardsdatascience.com/feature-engineering-for-time-series-data-f0cb1c1265d3#2022-03-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9b18" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">现代数据堆栈上的时间序列聚合</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9a6d337ee183b0fa121b36dba4148c32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*poHa_4Zaq_gkKJNv"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图为<a class="ae kv" href="https://unsplash.com/@donaldwuid?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">唐纳德·吴</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="29a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在许多商业数据科学问题中，具有时间序列特征的数据(例如，交易、传感器读数等)。)必须汇总到个人(例如，客户、设备等)。)水平。在现代机器学习环境中这样做可能会带来麻烦，因为传统的训练测试和交叉验证分割将会失败。这是因为在训练集和测试集之间随机拆分观察结果几乎总是会在这两个集之间拆分相关的(因此也是相关的)观察结果。更有问题的是，观察将被分割，以便一些训练观察可以在测试观察之后进行。换句话说，模型将学习从未来预测过去。这通常会导致模型在投入生产时失败。</p><p id="cb11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有许多方法可以处理这个问题，我在这里讨论了我的首选方法<a class="ae kv" href="https://www.rasgoml.com/post/selecting-the-right-data-for-your-ml-model" rel="noopener ugc nofollow" target="_blank"/>。一种常用的方法是对每个人进行一次观察。这可以通过为每个人随机选择一个观察值或选择一个日期并仅使用该日期的观察值来实现。</p><p id="fa27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将集中精力为给定日期的每个观察创建一个单独的记录。在本例中，我们将使用天气数据并对其进行汇总，以显示多个时间段内县级的平均高温。在熊猫身上做到这一点可能很有挑战性，但我们将展示在 Rasgo 的现代数据堆栈上做到这一点是多么容易。</p><h2 id="1d34" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">熊猫的单矩聚集</h2><p id="cee1" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">给定包含县代码<em class="mu"> FIPS </em>、日期<em class="mu">日期</em>和某个县在日期<em class="mu">高温</em>、<code class="fe mq mr ms mt b">rolling</code>和<code class="fe mq mr ms mt b">groupby</code>的数据帧<code class="fe mq mr ms mt b">df</code>，可以使用它们来创建所有日期的滚动平均值。在这种情况下，将创建一周、两周和四周的滚动平均值。</p><p id="05bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，应该创建滚动窗口</p><pre class="kg kh ki kj gt mv mt mw mx aw my bi"><span id="9a27" class="ls lt iq mt b gy mz na l nb nc">df['HIGH_TEMP_AVG_7D'] = df.sort_values(<br/>                              by=['FIPS', <br/>                                 'DATE']).set_index(<br/>                                 'DATE').groupby(<br/>                                 'FIPS')[<br/>                                 "HIGH_TEMP"].rolling('7D',             <br/>                                 closed='both').mean()<br/>df['HIGH_TEMP_AVG_14D'] = df.sort_values(<br/>                              by=['FIPS', <br/>                                 'DATE']).set_index(<br/>                                 'DATE').groupby(<br/>                                 'FIPS')[<br/>                                 "HIGH_TEMP"].rolling('14D',             <br/>                                 closed='both').mean()<br/>df['HIGH_TEMP_AVG_28D'] = df.sort_values(<br/>                              by=['FIPS', <br/>                                 'DATE']).set_index(<br/>                                 'DATE').groupby(<br/>                                 'FIPS')[<br/>                                 "HIGH_TEMP"].rolling('28D',             <br/>                                 closed='both').mean()</span></pre><p id="e8d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以重置索引以将县代码和日期返回到数据帧中的简单列。</p><pre class="kg kh ki kj gt mv mt mw mx aw my bi"><span id="6cd8" class="ls lt iq mt b gy mz na l nb nc">df.reset_index(inplace=True)</span></pre><p id="bcb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法有几个问题。首先，如果数据量很大，将数据下载到工作站并进行处理会非常耗时。虽然这可以通过仅下载所讨论的日期所需的数据来加速，但是仍然要对数据中的所有日期执行额外的计算。更重要的是，生产工作流只需要聚合到当前日期，并且应该生成聚合。</p><h2 id="6a06" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">RasgoQL 和现代数据栈方法</h2><p id="6fa4" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在现代数据栈上，开源包 RasgoQL 以几种方式解决了这两个问题。首先，处理保存在云数据仓库中，因此没有数据被移动到工作站。其次，RasgoQL 转换<code class="fe mq mr ms mt b">timeseries_agg</code>利用数据仓库的能力处理比工作站上可能处理的数据量大得多的数据。</p><p id="98fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，获取对数据仓库中保存天气数据的表的引用。</p><pre class="kg kh ki kj gt mv mt mw mx aw my bi"><span id="ba17" class="ls lt iq mt b gy mz na l nb nc">dataset = rql.dataset('WEATHER_TABLE_NAME')</span></pre><p id="3946" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每天的滚动平均值可以通过调用转换来生成。</p><pre class="kg kh ki kj gt mv mt mw mx aw my bi"><span id="2d94" class="ls lt iq mt b gy mz na l nb nc">tsagg = dataset.timeseries_agg(aggregations={<br/>                                'DAILY_HIGH_TEMP': ['AVG']<br/>                               },<br/>                               group_by=['FIPS'],<br/>                               date='DATE'<br/>                               offsets=[7, 14, 28],<br/>                               date_part='day')</span></pre><p id="604f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些数据可以通过调用<code class="fe mq mr ms mt b">tsagg</code>上的<code class="fe mq mr ms mt b">to_df</code>来下载，以获得熊猫数据帧进行进一步处理。</p><pre class="kg kh ki kj gt mv mt mw mx aw my bi"><span id="5d00" class="ls lt iq mt b gy mz na l nb nc">tsagg_df = tsagg.to_df()</span></pre><p id="7c49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，可以将这些数据发布回云数据仓库，以创建一个视图，其他人可以在 RasgoQL 中使用该视图，也可以通过 SQL 直接从数据仓库中使用该视图。</p><pre class="kg kh ki kj gt mv mt mw mx aw my bi"><span id="9c97" class="ls lt iq mt b gy mz na l nb nc">tsagg.save(table_name="ROLLING_WEATHER_SNAPSHOT")</span></pre><p id="3d84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在现代数据栈上使用开源 Python 包 RasgoQL 的转换使得创建这种滚动窗口比在 pandas 中创建要简单得多。该包创建一个在数据库中执行的 SQL 调用，并且可以将结果保存回数据库，以便将来在现有项目或需要相同数据的其他项目中引用。通过使用 SQL，处理的数据量可能会大得多。最后，使用 pandas，使用 aggregate 函数可以允许在多个列上同时进行多个聚合。除了在每个步骤中只能考虑一个时间窗口(例如七天或十四天)。这意味着要创建 7 天、14 天和 28 天的平均值，需要三种不同的 Python 语句。在 RasgoQL 中，一个 SQL 调用可以同时生成所有三个。</p><p id="7af1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想查看 RasgoQL，文档可以在这里找到<a class="ae kv" href="https://docs.rasgoql.com/" rel="noopener ugc nofollow" target="_blank">，在这里</a>找到库<a class="ae kv" href="https://github.com/rasgointelligence/RasgoQL" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>