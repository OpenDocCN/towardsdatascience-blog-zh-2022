<html>
<head>
<title>Pythonflow: From Eager to Graph Python Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pythonflow:从渴望到图形 Python 编程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pythonflow-from-eager-to-graph-python-programming-6ee51fb9779f#2022-03-27">https://towardsdatascience.com/pythonflow-from-eager-to-graph-python-programming-6ee51fb9779f#2022-03-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="716e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Spotify 库概述</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/43aa38a5a3a3cac1afcc3611a57a34cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qsYPBG1yB1fye_GE"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@clemhlrdt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Clément Hélardot </a>拍摄</p></figure><p id="b838" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如开发者在官方<a class="ae ky" href="https://pythonflow.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank">文档</a>、<strong class="lb iu">中所报道的，Pythonflow </strong>是一个数据流编程的 Python 库，其语法与<strong class="lb iu"> Tensorflow </strong>在图形类型上非常相似。这个库，简单但在我看来极其强大，是为人工智能模型预处理流程(管道)而设计的。在最初的目标中，出现了:</p><ul class=""><li id="d64d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">✅ <strong class="lb iu">管理</strong>特别繁重的逻辑和数学运算链</li><li id="49ba" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">✅能够执行图中包含的子操作，具有强大的<strong class="lb iu">调试</strong>和计算优化潜力</li><li id="10b0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">✅并行化、<strong class="lb iu">分布式计算</strong>，以及跨多台机器的工作负载分割</li></ul><p id="3f07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是让我们后退一步，理解我是如何以及为什么会遇到这个工具的。</p><h2 id="b9bd" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">图形执行和数据流编程:为什么</h2><p id="1138" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我遇到这个工具是一种需要的结果。作为一名 Python/AI 工程师和开发人员，经常需要优化自己的工作流程。</p><p id="e5bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在为工程界开发人工智能算法的过程中，肯定会遇到一些这样的问题:</p><ul class=""><li id="bdd4" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">⏰<strong class="lb iu">优化</strong>开发计算时间</li><li id="d019" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">💻保存过去完成的工作，并在新的问题上利用它</li><li id="8c6a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">🎯<strong class="lb iu">管理源自点云、视频流、图像的大型数据集</strong></li></ul><p id="e4e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工作流水线可以被解释为一系列相互连接的连续操作，其中每个操作都是独立的，能够读取输入数据流并输出多个输出。从脚本优化的角度来看，数据流编程允许轻松地将工作管道从一个项目转移到另一个项目，只改变一些输入参数(我称之为<strong class="lb iu">占位符</strong>和<strong class="lb iu">常量</strong>)或链的一个或多个操作。</p><p id="fd87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就<strong class="lb iu">开发时间</strong>而言，处理大量数据可能是一个大问题，这个问题在初始开发阶段最为明显，在此期间，在远程机器或云上启动我们的批处理工作管道之前，操作将被一个接一个地调试以验证其有效性。使用图形，我们可以完全简化编程、导出和整个图形，并仅在需要时部分或完全执行它。</p><p id="1c69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，<strong class="lb iu">连接多个图形</strong>的可能性成倍地增加了这种编程的通用性。</p><blockquote class="nh ni nj"><p id="25d2" class="kz la nk lb b lc ld ju le lf lg jx lh nl lj lk ll nm ln lo lp nn lr ls lt lu im bi translated">目标是开发<strong class="lb iu">我的管道</strong>，通过一次编程，然后在未来的新项目中重用它们，简单地使用过去制作的子图组装一个新的整体图，旨在作为一系列工作的、独立的和互连的操作。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/1169ed4d40e9fa0bfc223ec3ed6a9387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a1btZrAZ2-H_alhk"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@thibaultpenin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Thibault Penin </a>拍摄</p></figure><p id="0acb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法，正如我们将看到的，非常简单，但我认为这个库的真正有效性可能来自它的图形包装(我正在研究，将来会告诉你)。它的脚本使用被开发人员变得非常简单和直观，但是对于复杂工作流的参数化实现来说，语法往往变得沉重和乏味，特别是如果像我一样，您需要连接几十个不同的图形。</p><h2 id="1ebe" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">Pythonflow 库:主要特性</h2><p id="5d91" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">安装非常简单:作为 pip 上的一个包，准备好我们的 python/conda 环境(或 Colab 笔记本)就足够了。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="4fa5" class="mj mk it nq b gy nu nv l nw nx">(venv) &gt;&gt;&gt; pip install pythonflow</span></pre><p id="363a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我预料到了我基于数据流进行 python 编程的原因。但是，这涉及到编程模式的改变，可以总结为两个步骤:</p><ul class=""><li id="d0ba" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">📈定义定义我们工作流的操作的<strong class="lb iu"> DAG </strong>(直接非循环图)</li><li id="cb08" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">🏃🏼‍♂️ <strong class="lb iu">通过给占位符赋值来评估图形。</strong></li></ul><p id="0d9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">图(<strong class="lb iu"> DAG </strong>)由一系列用边连接的节点(操作)组成。</p><div class="ny nz gp gr oa ob"><a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph#/media/File:Tred-G.svg" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">有向无环图-维基百科</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">在数学中，特别是图论和计算机科学中，有向无环图(dag 或 DAG)是一个有向无环图。</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">en.wikipedia.org</p></div></div><div class="ok l"><div class="ol l om on oo ok op ks ob"/></div></div></a></div><blockquote class="nh ni nj"><p id="5c68" class="kz la nk lb b lc ld ju le lf lg jx lh nl lj lk ll nm ln lo lp nn lr ls lt lu im bi translated">当 Pythonflow 对一个操作求值时，它会检查当前的<code class="fe oq or os nq b">context</code>是否为该操作提供了一个值，如果可能就立即返回。如果当前的<code class="fe oq or os nq b">context</code>没有为操作提供值，Pythonflow 将评估操作的依赖关系，评估感兴趣的操作，将计算出的值存储在上下文中，并返回该值。</p></blockquote><p id="81b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在该图中，可以实例化<strong class="lb iu">操作</strong>、<strong class="lb iu">占位符、</strong>或<strong class="lb iu">常量</strong>，每一个都用唯一自动生成的标识符或我们指定的名称进行唯一标识。</p><blockquote class="nh ni nj"><p id="6517" class="kz la nk lb b lc ld ju le lf lg jx lh nl lj lk ll nm ln lo lp nn lr ls lt lu im bi translated">Pythonflow 将强制要求名称确实是唯一的。</p></blockquote><ul class=""><li id="eba1" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">⚖️ A <strong class="lb iu">常量</strong>是我们图形中的一个参数，我们不希望通过外部调用以任何方式改变它</li><li id="73a9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">💡一个<strong class="lb iu">占位符</strong>是一个我们希望在调用我们的图形时动态变化的参数</li><li id="65b9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">🐍一个<strong class="lb iu">操作</strong>是任何 Python 函数、语句、类...</li></ul><p id="749b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这最后一点在我看来是最有趣的。可以执行简单的 Python 构建，也可以包装任何库(甚至是人工智能库，如 Tensorflow 或 Pytorch ),并创建复杂的类和宏来组成我们的图。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><h2 id="cacb" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">Pythonflow 的多功能性</h2><p id="938e" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">该库允许我们用三种不同的复杂程度包装 python 代码。</p><blockquote class="nh ni nj"><p id="fb3a" class="kz la nk lb b lc ld ju le lf lg jx lh nl lj lk ll nm ln lo lp nn lr ls lt lu im bi translated">我们可以使用<code class="fe oq or os nq b">pf.func_op</code>类从一个可调用对象创建一个操作。</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="daab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">必须考虑的一个方面是，操作只执行一次，然后保存在缓存中。这一方面极大地优化了我们的代码，尤其是在运算量很大的情况下。</p><p id="4f8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同时，如果我们需要包装我们的一个函数，可以使用一个<a class="ae ky" href="https://peps.python.org/pep-0318/" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"/></a><strong class="lb iu"/>。<code class="fe oq or os nq b">opmethod<em class="nk"> </em></code>的参数不是强制性的:指定<code class="fe oq or os nq b">length</code>参数可以解包操作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="9fcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为这是这个库的真正潜力，也就是将我们的图形片段组合成一系列复杂静态操作的可能性。为此，我们需要执行 pf.operation 类的子类化，如下例所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="4dd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个简单的例子中，我创建了一个操作，将来自<strong class="lb iu"> TensorFlow 的模板作为参数传递。Keras.models.Model </strong>，然后用指定的设置进行编译。</p><p id="881e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在工作流程的开发中，根据我们指定的参数(占位符)，可能需要执行图形的一部分或另一部分。Pythonflow 允许您使用<em class="nk"> pf.conditional </em>处理条件操作，只执行您需要完成的那部分图形。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="cd01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像在我们的日常代码中一样，我们将需要<strong class="lb iu">处理异常</strong>，并且只在某些部分执行失败时才执行部分代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="0ebd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所述，该库自动且有效地定义了要执行的操作序列。然而，在某些情况下，指定依赖链可能是有用的。例如，官方文档中的示例显示了如何使用该功能进行调试。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="99b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来谈谈<strong class="lb iu">断言:</strong>你要确保一切都按预期运行。让我们再次检查一下官方文档示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="4977" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我来说，执行代码的一个关键方面是监控执行时间和瓶颈。为此，该库实现了几个方便的分析系统。这些回调(上下文管理器)必须接受两个参数:被分析的操作和上下文。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><h1 id="8671" class="ov mk it bd ml ow ox oy mo oz pa pb mr jz pc ka mu kc pd kd mx kf pe kg na pf bi translated">创建管道:使用 Tensorflow 进行培训</h1><p id="a9e9" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在这一节中，我提出了一个非常简单的例子，这个例子是我为我们的人工智能管道应用 Pythonflow 而做的，展示了我认为的优势。</p><p id="633e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这里找到完整的示例代码<a class="ae ky" href="https://github.com/GitMarco27/TMML/blob/main/Notebooks/012_pythonflow.ipynb" rel="noopener ugc nofollow" target="_blank"/>。目标是展示如何创建一个简单的 DAG(带有一些额外的功能)专门用于人工智能，生成一个参数序列模型，并使用 Keras Functional API 对一些简单数据进行训练。</p><div class="ny nz gp gr oa ob"><a href="https://github.com/GitMarco27/TMML/blob/main/Notebooks/012_pythonflow.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">TMML/012_pythonflow.ipynb 在主 GitMarco27/TMML</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">3 分钟机器学习。通过在 GitHub 上创建帐户，为 GitMarco27/TMML 的发展做出贡献。</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">github.com</p></div></div><div class="ok l"><div class="pg l om on oo ok op ks ob"/></div></div></a></div><p id="86ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和往常一样，我使用 Google Colab 创建简短的代码和示例。默认情况下不会安装 Pythonflow，所以您需要安装这个依赖项。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><h2 id="69fc" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">定制模块化张量流运算</h2><p id="8eb1" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">如上所述，利用 Pythonflow 开发者提供的不同语法，有可能以几种方式实现我们的直接非循环操作图。在这个例子中，我使用了 pf 的继承。操作类来实现我的工作流链中的三个基本操作:</p><ul class=""><li id="0ab4" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">创建参数化 Keras 模型(带有密集层)</li><li id="d3c6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">编译模型</li><li id="f3ca" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">对一系列时期的(虚拟)数据进行训练</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="54b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，需要多次指定我们自定义操作的参数:在<strong class="lb iu"> __init__ </strong>中，在<strong class="lb iu"> super、</strong>中，然后在<strong class="lb iu"> _evaluate </strong>函数中。然而，在后者中，可以用我们熟悉的 Python 语法指定任何操作链。</p><ul class=""><li id="cc95" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第一个函数允许将一个<a class="ae ky" href="https://keras.io/api/layers/core_layers/dense/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">密集</strong> </a>层添加到传入的通用模型中，具有指定数量的神经元和激活函数。</li><li id="a9bf" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第二个类<strong class="lb iu">用默认参数编译</strong>我们的模型:优化器(Adam)和损失函数(mse)。</li><li id="fbd0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">最后一个以参数化的方式执行通用模型的<strong class="lb iu">训练</strong>:它读入特征、标签、训练时间和批量。</li></ul><p id="a56c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个琐碎的例子是可以优化改进的，但是在我看来，一个致胜的理念浮现出来了:e <strong class="lb iu">非常定制的操作，做好了就是独立。它读取一组输入(依赖项)并返回一组输出，在几个工作链中变得可重用。</strong></p><h2 id="cdbd" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">图形生成</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="c810" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<strong class="lb iu"> DAG </strong>的生成，有必要定义一组占位符、操作、常量以及它们之间的交互。显然，没有必要为占位符指定一个值，因为只有在执行图形时才会给它们赋值。</p><p id="0592" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<em class="nk"> pf.func_op </em>，输入层被实例化，这是一种特别方便包装单个可调用程序的语法，而 Tensorflow 模型(Keras)的生成、编译和训练的剩余部分是通过前面介绍的自定义操作来执行的。</p><p id="fe92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个简单的例子中，数据是在图中生成的(使用 numpy 随机生成输入/输出集)。</p><blockquote class="nh ni nj"><p id="7d04" class="kz la nk lb b lc ld ju le lf lg jx lh nl lj lk ll nm ln lo lp nn lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:一个优点是可以生成整个图，但是调用图内的任何中间对象总是可以的。Pythonflow 将确定依赖关系链，并且在计算上只高效地执行获得该值所必需的操作。</p></blockquote><h2 id="0d08" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated"><strong class="ak"> Extra n 1 </strong>:嵌套图。</h2><p id="ea98" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在给出的代码中，输入数据的大小是通过<strong class="lb iu">另一个图</strong>指定的:这允许我展示如何以一种<strong class="lb iu">递归方式</strong>链接操作图，释放与我们工作链的模块化相关的大量潜力。</p><h2 id="0786" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">运行我们的图表</h2><p id="9cce" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">要执行该图，必须指定要提取的值(通过在图生成期间指定的名称)、依赖链中所需占位符的值以及任何分析器和回调。</p><p id="350f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查一下模型摘要:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="563d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者开始虚拟数据的训练:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><h2 id="2f7c" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">额外的 n 2: pickle 并重新加载图表</h2><p id="ed83" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">这个库使得使用<strong class="lb iu"> pickle </strong>导出我们的图形变得容易。</p><div class="ny nz gp gr oa ob"><a href="https://docs.python.org/3/library/pickle.html" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">pickle - Python 对象序列化- Python 3.10.4 文档</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">编辑描述</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">docs.python.org</p></div></div></div></a></div><p id="0989" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现这非常有用:例如，让我们考虑在我们的本地机器上创建一个复杂的模块化操作图:我们可以<strong class="lb iu">导出图</strong>并且<strong class="lb iu">使用简单的命令在<strong class="lb iu">远程机器</strong>上执行</strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><h2 id="5a2a" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">额外的 n 3:在单独的线程上运行</h2><p id="1693" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">Pythonflow 允许您在一个<strong class="lb iu">外部线程</strong>上运行您的图形，从而允许您利用进程<strong class="lb iu">并行化</strong>和<strong class="lb iu">避免在运行长工作链时冻结</strong>我们的应用程序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="8b9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们在一个单独的线程上运行简单的基于密集的模型的生成、编译和简单训练，监视进程的数量。如果需要，我们可以存储进程的 PID 来处理它。</p><h1 id="92a3" class="ov mk it bd ml ow ox oy mo oz pa pb mr jz pc ka mu kc pd kd mx kf pe kg na pf bi translated">总结</h1><p id="e7c0" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在本文中，我们已经讨论了<strong class="lb iu"> Pythonflow </strong>，它的潜力，语法，并且我们已经从官方文档中看到了一些例子。然后，我们看到了一个生成人工智能工作流的简单示例和一些在我们日常工作中有用的额外功能。</p><p id="252b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">📚在我的<a class="ae ky" href="https://marcosanguineti.medium.com/" rel="noopener">个人资料</a>上阅读更多文章</p><p id="7949" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">📨成为电子邮件订阅者，了解最新动态</p><p id="1534" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">💻加入媒体没有阅读限制</p><p id="77a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">✏️对疑点或新内容的评论</p><p id="3bf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下次见，马可</p></div></div>    
</body>
</html>