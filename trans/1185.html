<html>
<head>
<title>Master Python Comprehensions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握 Python 理解</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/master-python-comprehensions-4ef1c66b452d#2022-03-27">https://towardsdatascience.com/master-python-comprehensions-4ef1c66b452d#2022-03-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4213" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以简单性和可读性为目标编写代码</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f36b423d800c0efa89fccd3c482d5b7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yuXOTbRj0cTSsZYTlRt4YQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由 Unsplash 的 Ksenia Makagonova 拍摄。</p></figure><p id="a07c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python 最显著的优势之一是它是一种高度表达的语言。没有太多的样板文件，开发人员可以想出优雅的解决方案，如果结构良好，读起来就像一个故事。</p><p id="f552" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是语言之美，在 Python 的<a class="ae kv" href="https://peps.python.org/pep-0020/" rel="noopener ugc nofollow" target="_blank">禅</a>中得到了很好的展现。如果我必须强调其中的一句话，那就是“简单胜于复杂”。我们应该尽可能地坚持这样一条黄金法则，即代码被阅读的次数要比它被编写的次数多得多，无论是被作者、同事还是外部贡献者阅读。因此，直截了当，避免华丽的辞藻，帮助你的队友和未来享受你今天写的东西。</p><p id="b5da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章将遵循这一思想，通过一系列例子介绍处理数据时最常见的任务之一:转换列表，重点关注简单性和可读性。</p><h1 id="ff3c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">环</h1><p id="8227" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">语句是 Python 的控制流工具之一，可以帮助我们迭代序列中的项目。在每一步中，我们都拥有原始数据中的一个元素。</p><p id="4cda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个示例是将一系列数字中的偶数元素加 1。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="e559" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这是一个相对简单的问题，但我们需要执行多个操作:</p><ol class=""><li id="6b8e" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated">实例化一个空列表。</li><li id="61fa" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">迭代<code class="fe mp mq mr ms b">data</code>的每个元素。</li><li id="b9cb" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">检查元素是否是偶数。</li><li id="eee8" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">在每一步更新<code class="fe mp mq mr ms b">added</code>对象。</li></ol><p id="de31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它完成了工作，但是我们可以使代码更紧凑，更容易理解。我们的主要目标是通过浏览代码来传达我们的意图。</p><h1 id="8e10" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">地图和过滤器</h1><p id="b230" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><strong class="ky ir">高阶函数</strong>接受函数作为参数或者返回函数作为结果。这有点拗口，但是利用 Python 允许我们像对待任何其他对象一样对待函数是很重要的。</p><p id="ed32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">map</code>将帮助我们在序列的每个元素上运行一个函数，而<code class="fe mp mq mr ms b">filter</code>添加了跳过某些项目的逻辑。为了简单起见，我们将使用<code class="fe mp mq mr ms b">lambda</code>来编写我们的函数，但是这个例子也将使用命名定义。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="dca5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从这个片段中重要的是，能够编写一行程序并不意味着我们应该这样做。</p><p id="df6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意理解最后几行中发生的事情是多么容易，以及编写有意义的名称<strong class="ky ir">的重要性。人们可能不理解<code class="fe mp mq mr ms b">filter</code>是做什么的，但是通过使用名称<code class="fe mp mq mr ms b">even</code>,我们帮助我们的读者继续下去，而不要跳到任何实现细节。按照这个逻辑，我应该在这里做得更好，并且在 lambda 表达式中使用<code class="fe mp mq mr ms b">num</code>而不是<code class="fe mp mq mr ms b">x</code>。</strong></p><h1 id="8f6c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">列表理解</h1><p id="44af" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Python 中我最喜欢的特性之一是<strong class="ky ir">理解</strong>。它们在简单直接地表达转换方面非常出色，开发人员可以通过使用不同的符号将这些转换应用于列表、集合、字典和生成器。</p><p id="b9c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以定义集合，并通过函数和条件动态地构建它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="d74f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，阅读这段代码时主要关注的是实际的逻辑。一眼就能看出代码的<strong class="ky ir">目的</strong>是什么。然后，我们可以包装这个逻辑，将<code class="fe mp mq mr ms b">data</code>对象转换成不同的结构。</p><p id="86f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我发现自己在理解中反复使用的一个小技巧是从一个列表中提取一个元素，如果它存在的话。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3e80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个要点提取理解逻辑，并把它变成一个<em class="nj">迭代器</em>。在内部，Python 使用<code class="fe mp mq mr ms b">next</code>从迭代器中的一个元素跳到另一个元素。因此，我们可以应用我们的过滤逻辑，返回我们感兴趣的元素，或者获取它，或者如果它不存在，获取<code class="fe mp mq mr ms b">None</code>。这种方法让我们可以在代码的后面优雅地处理类型提示和条件。</p><p id="5b8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到理解。这是否意味着我们应该为循环 <strong class="ky ir"> <em class="nj"> </em> </strong>或更高阶的函数抛弃<em class="nj">？一点也不。开发人员需要评估不同方法的逻辑有多复杂。每种工具都有它的位置，有了经验，人们就会知道哪种设计变得<strong class="ky ir">更容易维护。</strong></em></p><h1 id="eb08" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">三元运算符</h1><p id="a8d6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们已经看到了如何使用条件来过滤掉元素。然而，另一种典型的做法是将条件直接应用于每个元素，作为转换的一种方式。三元运算符有助于我们做到这一点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6d84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过检查每个元素，我们已经根据项目的属性将数字列表转换为字符串列表。这种情况可能看起来过于简单，但是将这种逻辑与过滤和数据描述符(如<a class="ae kv" rel="noopener" target="_blank" href="/how-to-make-the-most-of-pydantic-aa374d5c12d"> Pydantic </a>)组合在一起就成了一个极好的方法。</p><p id="47fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可读性强、直截了当的永远是赢家。在这种情况下，它比其他选择更优雅。不是因为它更短，而是因为它更好地传递了代码的目的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="42c6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">赋值表达式</h1><p id="2c0d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们将以一个来自<a class="ae kv" href="https://peps.python.org/pep-0572/" rel="noopener ugc nofollow" target="_blank"> PEP 572 </a>的精彩附加节目来结束这个节目。Python 3.8 中提供的赋值表达式允许开发人员为表达式结果命名(赋值变量)，这在处理理解时特别有用。</p><p id="4d75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们想象一个函数，它可能为一些输入返回<code class="fe mp mq mr ms b">None</code>。然后，我们需要将该函数应用于给定的列表，并过滤掉缺失的值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="d45d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单的方法意味着运行该函数两次:</p><ol class=""><li id="acf9" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated">首先，检查输出是否为用于滤波的<code class="fe mp mq mr ms b">None</code>,以及</li><li id="24ad" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">然后，存储有效的返回值。</li></ol><p id="2621" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果函数需要很长时间来运行或者需要一些外部组件，我们应该完全避免这种方法，因为执行两次这个过程是不可能的。</p><p id="d860" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，使用赋值表达式(又名 walrus 操作符)，我们可以获得理解的所有好处，而不会牺牲函数方面的任何性能。该函数只执行一次，我们可以在本地使用<code class="fe mp mq mr ms b">res</code>变量来构建结果列表。</p><h1 id="fb63" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="3f32" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Python 是一种非常灵活的语言:有很多途径可以达到相同的结果。因此，了解可供我们选择的方案至关重要。否则，<a class="ae kv" href="https://en.wiktionary.org/wiki/if_all_you_have_is_a_hammer,_everything_looks_like_a_nail" rel="noopener ugc nofollow" target="_blank">如果你有锤子，一切看起来都像钉子</a>。</p><p id="a20c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我们看到了如何使用以下方法过滤和转换数据的不同选择:</p><ul class=""><li id="5df4" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr nk nb nc nd bi translated">对于循环，</li><li id="91f3" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr nk nb nc nd bi translated">映射和过滤，以及</li><li id="5cd2" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr nk nb nc nd bi translated">三元运算符和赋值表达式的理解。</li></ul><p id="1b9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">难的是没有金科玉律。我们需要找到传达我们意图的最佳方式。这不是聪明的问题，而是清晰的问题。</p></div></div>    
</body>
</html>