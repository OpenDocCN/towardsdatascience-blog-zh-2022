<html>
<head>
<title>Predicting Diabetes with Random Forest Classifier</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用随机森林分类器预测糖尿病</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/predicting-diabetes-with-random-forest-classifier-c62f2e319c6e#2022-03-04">https://towardsdatascience.com/predicting-diabetes-with-random-forest-classifier-c62f2e319c6e#2022-03-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1bcf" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">建立机器学习模型，预测患者是否患有糖尿病。</em></h2></div><p id="cf4a" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">医疗诊断对于医疗专业人员来说是一个非常重要和关键的方面。特别是，糖尿病患者的分类非常复杂。糖尿病的早期识别对控制糖尿病非常重要。患者必须经过几次测试，之后专业人员很难在诊断过程中跟踪多个因素，这可能导致不准确的结果，使得检测非常具有挑战性。由于最先进的技术，尤其是机器学习算法，非常有利于在医疗保健行业快速准确地预测疾病。</p><p id="1348" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><strong class="ki ir"> <em class="lc">来自《走向数据科学》编辑的提示:</em> </strong> <em class="lc">虽然我们允许独立作者根据我们的</em> <a class="ae ld" rel="noopener" target="_blank" href="/questions-96667b06af5"> <em class="lc">规则和指导方针</em> </a> <em class="lc">发表文章，但我们不认可每个作者的贡献。你不应该在没有寻求专业建议的情况下依赖一个作者的作品。详见我们的</em> <a class="ae ld" rel="noopener" target="_blank" href="/readers-terms-b5d780a700a4"> <em class="lc">读者术语</em> </a> <em class="lc">。</em></p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/3d1db7d14d50f39e753664ec3297fce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HJSd7Z2HiHALzMpP_sDa0Q.jpeg"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">照片由<a class="ae ld" href="https://unsplash.com/@dmoruzzi?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">大卫·莫鲁齐</a>在<a class="ae ld" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="49a7" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">概观</h1><blockquote class="mm mn mo"><p id="b178" class="kg kh lc ki b kj kk jr kl km kn ju ko mp kq kr ks mq ku kv kw mr ky kz la lb ij bi translated">该数据集最初由“国家糖尿病、消化和肾脏疾病研究所”收集和传播，该数据集可在 Kaggle 以<a class="ae ld" href="https://www.kaggle.com/uciml/pima-indians-diabetes-database" rel="noopener ugc nofollow" target="_blank"> <strong class="ki ir">皮马印第安人糖尿病数据库</strong> </a>的名称获得。主要目的是基于在数据库中收集的诊断测量来预测患者是否患有糖尿病。所有患者都属于皮马印第安遗产，并且是 21 岁以上的女性。</p></blockquote><p id="56f8" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我们首先将<a class="ae ld" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/10min.html" rel="noopener ugc nofollow" target="_blank"> Pandas </a>和<a class="ae ld" href="https://numpy.org/doc/stable/user/absolute_beginners.html" rel="noopener ugc nofollow" target="_blank"> NumPy </a>导入到我们的 python 环境中，并将<a class="ae ld" href="https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ki ir">加载一个. csv 数据集</strong> </a> <strong class="ki ir"> </strong>到名为<strong class="ki ir"> df </strong>的 pandas dataframe 中。为了查看数据集中的前五条记录，我们使用 pandas<a class="ae ld" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.head.html" rel="noopener ugc nofollow" target="_blank"><strong class="ki ir">df . head()</strong></a>函数。我们还将使用<a class="ae ld" href="https://seaborn.pydata.org/" rel="noopener ugc nofollow" target="_blank"> seaborn </a>和<a class="ae ld" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> matplotlib </a>进行可视化。本文中的每一个例子都在<a class="ae ld" href="https://jupyter.org/" rel="noopener ugc nofollow" target="_blank"> Jupyter 笔记本</a>上得到验证。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="e91c" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">该数据集包含 768 个可观测值，其中有八个特征变量和一个目标变量。在开始分析数据并得出任何结论之前，有必要了解任何数据集中是否存在缺失值。要做到这一点，最简单的方法是使用<a class="ae ld" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.info.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ki ir"> df.info() </strong> </a>函数，该函数将为我们提供列名以及每列中非空值的数量。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="7594" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">根据输出，我们没有观察到任何空值。但是有五个特征如葡萄糖、血压、皮肤厚度、胰岛素和身体质量指数包含零值，这在医学史上是不可能的。我们将这些值视为缺失值。我们将把零值替换为 NaN，然后用它们的平均值估算它们。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="20fb" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">数据可视化</h1><p id="9bfa" class="pw-post-body-paragraph kg kh iq ki b kj mu jr kl km mv ju ko kp mw kr ks kt mx kv kw kx my kz la lb ij bi translated">每个列之间的关联使用热图可视化。从输出来看，颜色越浅表示相关性越强。我们注意到成对特征之间的相关性，比如年龄和怀孕，或者身体质量指数和皮肤厚度等。</p><blockquote class="mm mn mo"><p id="6fa5" class="kg kh lc ki b kj kk jr kl km kn ju ko mp kq kr ks mq ku kv kw mr ky kz la lb ij bi translated">sns.heatmap(df.corr())</p></blockquote><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/3ec0472471b04969661288df1ce6ad72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*IvE-o99Z2RMfCA64raqLwA.png"/></div></figure><p id="268e" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">为了在数据集中绘制成对关系，我们使用<a class="ae ld" href="https://seaborn.pydata.org/generated/seaborn.pairplot.html" rel="noopener ugc nofollow" target="_blank"> sns.pairplot() </a>函数，并根据目标变量类标记数据点..</p><blockquote class="mm mn mo"><p id="839a" class="kg kh lc ki b kj kk jr kl km kn ju ko mp kq kr ks mq ku kv kw mr ky kz la lb ij bi translated">sns.pairplot(df，hue='Outcome ')</p></blockquote><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi na"><img src="../Images/a50fd525b4be5484ae0858f06d50cbe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5YVxMVPlw2roOvh2priMQw.png"/></div></div></figure><h1 id="5e19" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">分类</h1><p id="5d5e" class="pw-post-body-paragraph kg kh iq ki b kj mu jr kl km mv ju ko kp mw kr ks kt mx kv kw kx my kz la lb ij bi translated">我们需要将数据集分成特征和目标变量。按照流行的惯例，我们称带有特征变量的数据帧为 X，带有目标变量的数据帧为 y。</p><pre class="lf lg lh li gt nb nc nd ne aw nf bi"><span id="6021" class="ng lv iq nc b gy nh ni l nj nk">X=df.drop('Outcome',axis=1)<br/>y=df['Outcome']</span></pre><p id="e1a0" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">让我们将目标变量可视化，看看数据集中有多少人患有糖尿病，有多少人没有。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/b83fb26b462e4664b099b8fcb38df93e.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*NVrRj6Yq7XZM9UXzZeE_5A.png"/></div></figure><p id="9949" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">使用 sklearn 的 train_test_split，我们将特征(X)和目标(y)数据帧分成训练集(80%)和测试集(20%)。训练集用于建立分类模型，测试集用于评估模型的性能。</p><pre class="lf lg lh li gt nb nc nd ne aw nf bi"><span id="291e" class="ng lv iq nc b gy nh ni l nj nk">from sklearn.model_selection import train_test_split<br/>X_train, X_test, y_train, y_test = train_test_split(X, y,test_size=0.2,random_state=0)</span></pre><p id="7172" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在实现分类算法之前，我们使用 sklearn 的<a class="ae ld" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ki ir"> StandardScaler() </strong> </a>函数缩放我们数据集的特征变量。该函数通过移除平均值并缩放至单位方差来标准化特征。</p><pre class="lf lg lh li gt nb nc nd ne aw nf bi"><span id="fe18" class="ng lv iq nc b gy nh ni l nj nk">from sklearn.preprocessing import StandardScaler<br/>scaling_x=StandardScaler()<br/>X_train=scaling_x.fit_transform(X_train)<br/>X_test=scaling_x.transform(X_test)</span></pre><h1 id="0ac3" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">培训和评估模型</h1><p id="5030" class="pw-post-body-paragraph kg kh iq ki b kj mu jr kl km mv ju ko kp mw kr ks kt mx kv kw kx my kz la lb ij bi translated">我们将使用一个名为<a class="ae ld" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ki ir"> <em class="lc">随机森林分类器</em> </strong> </a>的机器简单学习模型。我们使用训练数据集用标准参数训练模型。训练好的模型保存为“<strong class="ki ir">RCF”</strong>。我们使用测试数据集来评估我们的模型的性能。我们的模型有 80.5%的分类准确率。</p><pre class="lf lg lh li gt nb nc nd ne aw nf bi"><span id="95a9" class="ng lv iq nc b gy nh ni l nj nk"><strong class="nc ir">from</strong> sklearn.ensemble <strong class="nc ir">import</strong> RandomForestClassifier<br/>rfc <strong class="nc ir">=</strong> RandomForestClassifier()<br/>rfc<strong class="nc ir">.</strong>fit(X_train, y_train)<br/>rfc<strong class="nc ir">.</strong>predict(X_test)<br/>rfc<strong class="nc ir">.</strong>score(X_test, y_test)</span></pre><p id="58ba" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">输出:</p><pre class="lf lg lh li gt nb nc nd ne aw nf bi"><span id="7e48" class="ng lv iq nc b gy nh ni l nj nk">0.8051948051948052</span></pre><p id="cd59" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><strong class="ki ir">绘制决策边界</strong></p><p id="4b50" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">决策边界图仅适用于两个要素。我们的数据有八个特征，但我们仍然可以通过选择使用哪些特征来绘制决策边界。我们为每两个可能的特征绘制决策边界，并观察模型对患者的分类效果。</p><pre class="lf lg lh li gt nb nc nd ne aw nf bi"><span id="4b49" class="ng lv iq nc b gy nh ni l nj nk"><strong class="nc ir">from</strong> mlxtend.plotting <strong class="nc ir">import</strong> plot_decision_regions<br/><strong class="nc ir">def</strong> classify_with_rfc(X,Y):<br/>    x <strong class="nc ir">=</strong> df[[X,Y]]<strong class="nc ir">.</strong>values<br/>    y <strong class="nc ir">=</strong> df['Outcome']<strong class="nc ir">.</strong>astype(int)<strong class="nc ir">.</strong>values<br/>    rfc <strong class="nc ir">=</strong> RandomForestClassifier()<br/>    rfc<strong class="nc ir">.</strong>fit(x,y)<br/>    <em class="lc"># Plotting decision region</em><br/>    plot_decision_regions(x, y, clf<strong class="nc ir">=</strong>rfc, legend<strong class="nc ir">=</strong>2)<br/>    <em class="lc"># Adding axes annotations</em><br/>    plt<strong class="nc ir">.</strong>xlabel(X)<br/>    plt<strong class="nc ir">.</strong>ylabel(Y)<br/>    plt<strong class="nc ir">.</strong>show()<br/>    <br/>feat <strong class="nc ir">=</strong> ['Pregnancies', 'Glucose', 'BloodPressure', 'SkinThickness', 'Insulin','BMI', 'DiabetesPedigreeFunction', 'Age']<br/>size <strong class="nc ir">=</strong> len(feat)<br/><strong class="nc ir">for</strong> i <strong class="nc ir">in</strong> range(0,size):<br/>    <strong class="nc ir">for</strong> j <strong class="nc ir">in</strong> range(i<strong class="nc ir">+</strong>1,size):<br/>        classify_with_rfc(feat[i],feat[j])</span></pre><p id="1235" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">注意:<em class="lc"> </em> <code class="fe nm nn no nc b">0 — Non Diabetic and 1 — Diabetic</code></p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi np"><img src="../Images/6623dc97e37d905ed4009e965385b9b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gFWR4lQIA3euK2Z-k7VZ3A.jpeg"/></div></div></figure><p id="a51b" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">分布显示我们的模型对病人的分类非常好。为了详细评估我们的模型，我们看一下<a class="ae ld" href="https://www.sciencedirect.com/topics/engineering/confusion-matrix" rel="noopener ugc nofollow" target="_blank"> <strong class="ki ir">混淆矩阵</strong> </a>。</p><pre class="lf lg lh li gt nb nc nd ne aw nf bi"><span id="56cd" class="ng lv iq nc b gy nh ni l nj nk"><strong class="nc ir">from</strong> sklearn.metrics <strong class="nc ir">import</strong> confusion_matrix<br/>mat <strong class="nc ir">=</strong> confusion_matrix(y_test, y_pred)<br/>plt<strong class="nc ir">.</strong>figure(figsize<strong class="nc ir">=</strong>(7, 5))<br/>sns<strong class="nc ir">.</strong>heatmap(mat, annot<strong class="nc ir">=True</strong>)</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/e51468aeb241f7484c9bf2c332fc326b.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*T9gP6e-BbUpKa6pj_n9jxA.png"/></div></figure><pre class="lf lg lh li gt nb nc nd ne aw nf bi"><span id="515c" class="ng lv iq nc b gy nh ni l nj nk"><strong class="nc ir">from</strong> sklearn.metrics <strong class="nc ir">import</strong> classification_report<br/>target_names <strong class="nc ir">=</strong> ['Diabetes', 'Normal']<br/>print(classification_report(y_test, y_pred, target_names<strong class="nc ir">=</strong>target_names))</span><span id="fe47" class="ng lv iq nc b gy nr ni l nj nk"><strong class="nc ir">Output</strong>:</span><span id="6e84" class="ng lv iq nc b gy nr ni l nj nk">              precision    recall  f1-score   support<br/><br/>    Diabetes       0.86      0.86      0.86       107<br/>      Normal       0.68      0.68      0.68        47<br/><br/>    accuracy                           0.81       154<br/>   macro avg       0.77      0.77      0.77       154<br/>weighted avg       0.81      0.81      0.81       154</span></pre><p id="3190" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><strong class="ki ir"> ROC 曲线</strong></p><pre class="lf lg lh li gt nb nc nd ne aw nf bi"><span id="319a" class="ng lv iq nc b gy nh ni l nj nk"><strong class="nc ir">from</strong> sklearn.metrics <strong class="nc ir">import</strong> roc_curve<br/>y_pred_proba <strong class="nc ir">=</strong> rfc<strong class="nc ir">.</strong>predict_proba(X_test)[:,1]<br/>fpr, tpr, thresholds <strong class="nc ir">=</strong> roc_curve(y_test, y_pred_proba</span><span id="5014" class="ng lv iq nc b gy nr ni l nj nk">plt<strong class="nc ir">.</strong>plot([0,1],[0,1],'k-')<br/>plt<strong class="nc ir">.</strong>plot(fpr,tpr, label<strong class="nc ir">=</strong>'Knn')<br/>plt<strong class="nc ir">.</strong>xlabel('fpr')<br/>plt<strong class="nc ir">.</strong>ylabel('tpr')<br/>plt<strong class="nc ir">.</strong>title('ROC curve')<br/>plt<strong class="nc ir">.</strong>show()</span><span id="dc6e" class="ng lv iq nc b gy nr ni l nj nk"><strong class="nc ir">Output</strong>:</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/2e440f286edf7ca72fb9954ac2328250.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*AKG7UV0VQ-8ChFL4SnDApQ.png"/></div></figure><pre class="lf lg lh li gt nb nc nd ne aw nf bi"><span id="a398" class="ng lv iq nc b gy nh ni l nj nk"><strong class="nc ir">from</strong> sklearn.metrics <strong class="nc ir">import</strong> roc_auc_score<br/>roc_auc_score(y_test,y_pred_proba)</span><span id="e198" class="ng lv iq nc b gy nr ni l nj nk"><strong class="nc ir">Output:</strong><br/>0.8535494134022669</span></pre><p id="9c83" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">对于我们的模型，受试者工作特征曲线(<strong class="ki ir"> ROC AUC </strong>)得分下的面积为 85%。这意味着分类模型足够好来检测糖尿病患者。</p><p id="5ece" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><strong class="ki ir">真实值与预测值:</strong></p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nt"><img src="../Images/c1fe3db2c540131b332bd785f747c633.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pnrt4JIqDWPtadheNXOP2w.png"/></div></div></figure><h1 id="94c9" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">摘要</h1><ul class=""><li id="4b83" class="nu nv iq ki b kj mu km mv kp nw kt nx kx ny lb nz oa ob oc bi translated">我们建立了一个基于机器学习的分类器，根据数据库中提供的信息预测患者是否患有糖尿病。</li><li id="90e1" class="nu nv iq ki b kj od km oe kp of kt og kx oh lb nz oa ob oc bi translated">构建此预测器时，我们了解了常见的预处理步骤，如要素缩放和输入缺失值。关于在 python 中处理缺失值的更多详细解释，请参考我的文章<a class="ae ld" href="https://medium.com/nerd-for-tech/dealing-with-missing-data-using-python-3fd785b77a05" rel="noopener">这里</a>。</li><li id="33a8" class="nu nv iq ki b kj od km oe kp of kt og kx oh lb nz oa ob oc bi translated">我们实现了随机森林算法，使用准确度分数评估了性能，比较了训练和测试数据之间的性能。您还可以调整参数，并尝试提高准确性得分 AUC。</li><li id="6f07" class="nu nv iq ki b kj od km oe kp of kt og kx oh lb nz oa ob oc bi translated">完整的 python 脚本可以在<a class="ae ld" href="https://github.com/lophy95/diabetics_prediction/blob/main/diabetics-prediction-rf.ipynb" rel="noopener ugc nofollow" target="_blank"> Github </a>中找到。</li></ul><p id="6f01" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这就把我们带到了本文的结尾。感谢您通读这篇文章。如果你有任何疑问，欢迎在评论区留言。</p></div></div>    
</body>
</html>