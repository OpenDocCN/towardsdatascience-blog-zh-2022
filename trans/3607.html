<html>
<head>
<title>A Guide To R Objects Indexing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R对象索引指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-guide-to-r-objects-indexing-936a4adcb38b#2022-08-10">https://towardsdatascience.com/a-guide-to-r-objects-indexing-936a4adcb38b#2022-08-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1f5a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们学习如何操作不同的R对象并从中检索数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b8fc2f1917c8716d828a7703a0a329f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7eUH5rVoRS6CxiFN"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@qwitka" rel="noopener ugc nofollow" target="_blank">mak sym Kaharlytskyi</a>@ unsplash . com拍摄</p></figure><p id="b70e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">【免责声明:此帖子包含一些我的Udemy课程的附属链接】</em></p><p id="0ab9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lw translated">当你学习一门语言时，特别是当它们是为处理数据而定制的时候，你很容易对你将要学习的所有新的数据结构和复杂性感到困惑。学习如何处理每种语言的对象可能会非常令人沮丧——特别是如果您正在从另一个框架迁移，这可能是一个很大的挑战，因为您可能会有某些习惯不适合您正在学习的新语言。</p><p id="f4bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于R，如果您以前从未使用过数据框结构，或者您没有使用过专门为数据分析而设计的编程语言，那么索引对象和检索您想要的数据一开始可能看起来有点令人生畏，特别是因为在这种语言中有大量关于维度和类型的对象。</p><p id="a0a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我想带你了解一些关于R中索引的最重要的概念——在文章的最后，你将能够:</p><ul class=""><li id="9a9d" class="mf mg it lb b lc ld lf lg li mh lm mi lq mj lu mk ml mm mn bi translated">在R的上下文中区分单维和多维对象；</li><li id="d9db" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">随心所欲地查询数据框；</li><li id="06f3" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">现在，如何从R语言中最重要的对象中提取任何元素的子集。</li></ul><p id="c1fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，在这篇文章的最后，你应该会对不同的R对象非常熟悉，我希望这会给你的R之旅带来巨大的推动。</p><p id="9b57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开始吧！</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="d3ca" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">向量索引</h1><p id="f7ac" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">向量是一维的，单一类型的对象，我们可以在语言中找到。它们被认为是最基本的元素，也是最不容易混淆的。</p><p id="b5ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们考虑包含一年中12个不同月份的特定区域的平均温度的向量:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="d86d" class="oc nb it ny b gy od oe l of og">temperatures &lt;- c(12.9, 13.2, 15.0, 19.2, 21.4, 24.5, 29.5, 24.2, 20.5, 14.5, 10.2, 9.8)</span></pre><p id="9f25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是时候介绍R中最简单的索引方法了——<strong class="lb iu">数字索引！</strong></p><p id="45df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是在R对象中索引元素的最著名的方法之一——如果您是通过Python学习这种语言，R索引从1开始，这是一个显著的不同。</p><p id="5882" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想要获得数字<code class="fe oh oi oj ny b">12.9</code>，在我们的<code class="fe oh oi oj ny b">temperatures</code>向量中可用的第一个<code class="fe oh oi oj ny b">temperature</code>。我们如何做到这一点？</p><p id="a2f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="6d3b" class="oc nb it ny b gy od oe l of og">temperatures[1]</span></pre><p id="d173" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oh oi oj ny b">[]</code>是我们的索引锚。通过在R中的任何对象附近使用它们，我们打开了索引的可能性，并让R知道我们想要从我们的对象中提取某些元素。</p><p id="f8a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码将产生<code class="fe oh oi oj ny b">12.9</code>，这是我们在<code class="fe oh oi oj ny b">temperatures</code>获得的第一个温度。这非常简单，因为我们使用<code class="fe oh oi oj ny b">[]</code>让R知道我们想要索引我们的对象，并且我们在方括号内传递一个<code class="fe oh oi oj ny b">1</code>来检索第一个元素。</p><p id="dbff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们只能做到这一点，R语言将会变得极其乏味。如果我们想要多个温度呢？</p><p id="57b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有两种选择——使用<em class="lv">切片</em>或<em class="lv">向索引提供一个向量</em>。</p><p id="865b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从切片开始，我们可以传递一个格式为<code class="fe oh oi oj ny b">i:j</code>的索引，从元素<code class="fe oh oi oj ny b">i</code>到元素<code class="fe oh oi oj ny b">j</code>进行索引。</p><p id="2645" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的，让我来分解一下——例如，假设我们希望在向量中包含第二、第三和第四个月的温度，我们可以使用:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="f557" class="oc nb it ny b gy od oe l of og">temperatures[2:4]</span></pre><p id="555f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将产生<code class="fe oh oi oj ny b">13.2, 15.0, 19.2</code>，这是我们试图达到的三个温度。同样，我们传递方括号内的数字(格式为<code class="fe oh oi oj ny b">i:j</code>)。这些方括号将成为r中大多数索引的标准。</p><p id="93ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以对于<code class="fe oh oi oj ny b">temperatures[2:4]</code>，我们实际上是在问R:请给我检索一下<code class="fe oh oi oj ny b">temperatures</code>向量中从第二个到第四个元素的元素。</p><p id="b7e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">切片只适用于连续的元素(即相邻的元素)。如果我们想要提取某些单独的元素，例如第一、第三和第八个元素，该怎么办？</p><p id="0cac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们可以将向量直接传递到方括号中:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="2f9e" class="oc nb it ny b gy od oe l of og">temperatures[c(1,3,8)]</span></pre><p id="0a44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的索引中传递一个<code class="fe oh oi oj ny b">c(1,3,8)</code>，我们从<code class="fe oh oi oj ny b">temperatures</code>向量中选取第一、第三和第八个元素，即值<code class="fe oh oi oj ny b">12.9, 15.0, 24.2</code>。使用向量来索引是最灵活的方式来索引我们想要的任何向量中的元素——对我们想要选取的元素的数量没有限制，也没有像切片中那样的额外限制。</p><p id="adf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，唯一的挫折是，如果我们通过一个不存在的位置，例如，请求第1、第3和第20个元素:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="5227" class="oc nb it ny b gy od oe l of og">temperatures[c(1,3,20)]</span></pre><p id="7bc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该代码的结果元素是:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="983e" class="oc nb it ny b gy od oe l of og">12.9 15.0   NA</span></pre><p id="b28f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于没有第20个位置(我们的向量只有12个元素)，R将返回给我们<code class="fe oh oi oj ny b">NA</code>(不可用)信息。请注意，R不会抛出任何错误，它只是通过结果让你知道这个元素在向量中根本不存在。</p><p id="f6a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了数字索引，我们还有命名索引。这很重要，因为我们通常不知道对象中的数据在什么位置。例如，如果我们有一个包含1000个客户年龄的向量，我怀疑没有人能记住哪个客户属于哪个年龄。</p><p id="3ae8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然在我们的<code class="fe oh oi oj ny b">temperatures</code>例子中，我们知道，根据常识，我们向量的第一个月是一月，第二个月是二月，等等。</p><p id="5264" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果我们想在向量中明确地说明这一点，有什么方法可以做到吗？</p><p id="226c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是啊！我们只需用每个职位的名称值给<code class="fe oh oi oj ny b">temperatures</code>分配一个名称属性:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="d363" class="oc nb it ny b gy od oe l of og">names(temperatures) &lt;- c('Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec')</span></pre><p id="577a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就索引而言，这打开了一个可能性的新世界！现在，我们能够依靠名称来检索元素—例如，检查一月的温度非常简单:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="7411" class="oc nb it ny b gy od oe l of og">temperatures['Jan']</span></pre><p id="ed62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将输出一月份的温度信息:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="ed36" class="oc nb it ny b gy od oe l of og">Jan <br/>12.9</span></pre><p id="896b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，就指数而言，有一个主题是反复出现的。尽管我们使用名字来索引对象，T2仍然存在！</p><p id="960a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您能猜到我们如何使用命名版本索引多个元素吗？</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="26bf" class="oc nb it ny b gy od oe l of og">temperatures[c('Jan','Mar')]</span></pre><p id="3fb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需将向量中可用的两个值传递给我们的索引，我们就能够使用多索引来提取信息:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="86bf" class="oc nb it ny b gy od oe l of og">Jan  Mar <br/>12.9 15.0</span></pre><p id="aeea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">爽！让我们把这个变得更有趣一点。我们已经了解了索引向量的基础知识，以及如何索引一个只包含一个维度的对象。</strong></p><p id="d92c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果我们有一个包含不止一个维度(例如行和列)的对象呢？</p><p id="c2c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们学习如何索引多维对象！</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="3bb6" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">矩阵索引</h1><p id="57c2" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">让我创建一个两行两列的简单矩阵:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="7721" class="oc nb it ny b gy od oe l of og">matrix_example &lt;- matrix(<br/>  data = c(1000,122,-500,-15),<br/>  nrow = 2,<br/>  ncol = 2<br/>)</span></pre><p id="a956" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们的矩阵是完全无名的(意味着行和列没有名称属性):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/b7bb47cbeee073983ae5b71d843dc6e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/format:webp/1*mcUq2jznZupetwBgljybqA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">示例矩阵—作者图片</p></figure><p id="ac94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以任意值为例，我们如何从上面的矩阵中获取值1000？我们可以利用我们在这篇文章的前一部分学到的知识吗？</p><p id="aef6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以，但是我们必须深入研究如何使用多索引对象。</p><p id="52b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">索引这些对象实际上很简单——我们依靠逗号向我们著名的<code class="fe oh oi oj ny b">[]</code>添加一个新的位置元素。</p><p id="eea1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我用代码解释一下:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="252a" class="oc nb it ny b gy od oe l of og">matrix_example[1,1]</span></pre><p id="fa2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">上面的代码选择矩阵的第一行和第一列。</strong></p><p id="7c76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在逗号的左侧，我们有一个行索引器，它从第一维度(行)中选择数据—如果我们只有左侧的数据，那么我们是在处理一个维对象！</p><p id="3a1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在逗号的右侧，我们有第二维度的索引位置(在本例中是列)。根据这个解释，你能猜出我们如何索引第一行第二列吗？</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="247a" class="oc nb it ny b gy od oe l of og">matrix_example[1,2]</span></pre><p id="d43b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没错，只需在逗号的右边提供索引2，我们就可以索引第二列，在本例中是值<code class="fe oh oi oj ny b">-500</code>。</p><p id="5513" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们能够用这种逻辑提取某些元素，是否有可能从一个维度中选择所有元素——例如，从第一列中选择所有行？</p><p id="e33e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，就像将“维度”留空一样简单！在上面的例子中，如果我们想从第一个<strong class="lb iu">列中选择<strong class="lb iu">所有</strong>行，我们需要将行索引器留空:</strong></p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="d6d3" class="oc nb it ny b gy od oe l of og">matrix_example[,1]</span></pre><p id="ece1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这实际上与我们描述过的句子相吻合:</p><ul class=""><li id="0be4" class="mf mg it lb b lc ld lf lg li mh lm mi lq mj lu mk ml mm mn bi translated">所有行-&gt;索引器在第一维上都保持空白。</li><li id="a838" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">第一列的-&gt;索引器在第二维度上为1。</li></ul><p id="48e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将输出两个值，<code class="fe oh oi oj ny b">1000</code>和<code class="fe oh oi oj ny b">122</code>，所有值都来自第一列。</p><p id="6b2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想要相反的，第1行的所有列呢？你能猜出我们如何做这件事吗？</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="4086" class="oc nb it ny b gy od oe l of og">matrix_example[1,]</span></pre><p id="2e39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，我们只是镜像我们的索引！</p><p id="0649" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将输出第1行两列的值<code class="fe oh oi oj ny b">1000</code>和<code class="fe oh oi oj ny b">-500</code>。</p><p id="fc9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与单维对象一样，在处理多维时，我们也有命名的索引版本。</p><p id="d387" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设上面的数据与两个人的<code class="fe oh oi oj ny b">income</code>和<code class="fe oh oi oj ny b">expenses</code>有关。根据这个想法命名我们的维度:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="4f9b" class="oc nb it ny b gy od oe l of og">rownames(matrix_example) &lt;- c('John','May')<br/>colnames(matrix_example) &lt;- c('Income','Expenses')</span></pre><p id="115e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的矩阵现在有如下外观:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/09f3f7ec99eb87d7eb3a8f023a436095.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/1*ZH5iyqABUzTxVbdQKOlFog.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有姓名的示例矩阵—按作者分类的图片</p></figure><p id="b255" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过名字索引是可能的，甚至在多维度的水平上！例如，如果我想要约翰的收入，我只需键入:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="1786" class="oc nb it ny b gy od oe l of og">matrix_example['John','Income']</span></pre><p id="c668" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Thsi输出<code class="fe oh oi oj ny b">1000</code>，约翰的收入值！所以基本上，逻辑是一样的:</p><ul class=""><li id="e878" class="mf mg it lb b lc ld lf lg li mh lm mi lq mj lu mk ml mm mn bi translated">我想要检索的行名是<code class="fe oh oi oj ny b">John</code>，所以我将该名称传递到逗号的左侧，即第一维度。</li><li id="ef34" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">我想要检索的列名是<code class="fe oh oi oj ny b">Income</code>，所以我将这个名称传递给逗号右边的第二维。</li></ul><p id="9aaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想要费用，那很简单:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="fdd5" class="oc nb it ny b gy od oe l of og">matrix_example['John','Expenses']</span></pre><p id="f9d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是..如果我们想要约翰和梅的收入呢？因为我们只有两个人，所以可以将行索引器留空。但是，如果矩阵中有更多的个体，我们将使用以前使用过的相同策略—传递一个向量来索引多个元素:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="59e1" class="oc nb it ny b gy od oe l of og">matrix_example[c('John','May'),'Income']</span></pre><p id="8091" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将输出以下内容:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="f6f5" class="oc nb it ny b gy od oe l of og">John  May <br/>1000  122</span></pre><p id="89c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">酷！我们能够毫无问题地索引多个元素。仅仅通过扩展我们的向量索引知识，我们就能够从一个看起来更复杂的对象中提取数据。</p><p id="ca58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">矩阵实际上是数组的一个子集——一种只有二维的特殊类型。</p><p id="c820" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是..数组可以不止是2D，我们可以用同样的逻辑索引它们吗？接下来看看吧！</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="7e9b" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">数组索引</h1><p id="37f1" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">数组可以将我们的数据扩展到二维以上，进入张量领域。</p><p id="0de8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最酷的是我们索引背后的逻辑保持不变！让我创建一个三维数组，扩展我们上面看到的数据:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="99cb" class="oc nb it ny b gy od oe l of og">array_example &lt;- array(<br/>  data = c(1000,122,-500,-15, 200,250,-200,-30),<br/>  dim = c(2,2,2)<br/>)</span></pre><p id="624b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们打印<code class="fe oh oi oj ny b">array_example</code>，我们将在控制台上看到以下数组:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="464f" class="oc nb it ny b gy od oe l of og">, , 1</span><span id="217a" class="oc nb it ny b gy om oe l of og">[,1] [,2]<br/>[1,] 1000 -500<br/>[2,]  122  -15</span><span id="b6a3" class="oc nb it ny b gy om oe l of og">, , 2</span><span id="d96d" class="oc nb it ny b gy om oe l of og">[,1] [,2]<br/>[1,]  200 -200<br/>[2,]  250  -30</span></pre><p id="a509" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么现在，我们如何从上面的数组中获得值<code class="fe oh oi oj ny b">-200</code>?</p><p id="4da8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">良好的..应用同样的逻辑！谁说我们必须使用单个逗号？我们可以用另一个逗号来扩展索引器！</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="06ce" class="oc nb it ny b gy od oe l of og">array_example[1, 2, 2]</span></pre><p id="b671" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以基本上，我们要说的是:</p><ul class=""><li id="a7cf" class="mf mg it lb b lc ld lf lg li mh lm mi lq mj lu mk ml mm mn bi translated">在第一个逗号的左侧，我们有行索引器，第一维。</li><li id="72e0" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">在逗号之间，我们有列索引器，第二维。</li><li id="c7cb" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">在第二个逗号的右边，我们有“矩阵”索引器，第三维。</li></ul><p id="6a4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，随着我们维度数量的增加，这开始变得有点混乱和难以想象。</p><p id="9aa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，上面的代码将输出<code class="fe oh oi oj ny b">-200</code>，来自第一行，第二列，第二个矩阵的值。</p><p id="beb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于任何<em class="lv"> n维</em>数组，逻辑将继续是这样的(使用逗号打开新的维度)。到目前为止，我们所学的一切(空索引、传递向量)也适用于数组。</p><p id="cde6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我们也可以向数组中添加名称—例如，让我们假设第三个维度与John和May两个不同月份的收入和支出相关:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="c734" class="oc nb it ny b gy od oe l of og">dimnames(array_example) &lt;- list(<br/>  c('John','May'),<br/>  c('Income','Expenses'),<br/>  c('Jan2022','Feb2022')<br/>)</span></pre><p id="266e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打印我们的<code class="fe oh oi oj ny b">array_example</code>会给我们以下内容:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="8731" class="oc nb it ny b gy od oe l of og">, , Jan2022</span><span id="4f3c" class="oc nb it ny b gy om oe l of og">     Income Expenses<br/>John   1000     -500<br/>May     122      -15</span><span id="7ca7" class="oc nb it ny b gy om oe l of og">, , Feb2022</span><span id="31af" class="oc nb it ny b gy om oe l of og">     Income Expenses<br/>John    200     -200<br/>May     250      -30</span></pre><p id="42e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，按名称索引这些对象也与我们看到的其他对象相似。如果我们想要约翰2022年1月的收入:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="85d9" class="oc nb it ny b gy od oe l of og">array_example['John','Income','Jan2022']</span></pre><p id="82f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码将输出<code class="fe oh oi oj ny b">1000</code>，期望值。该指数的工作方式如下:</p><ul class=""><li id="042b" class="mf mg it lb b lc ld lf lg li mh lm mi lq mj lu mk ml mm mn bi translated"><code class="fe oh oi oj ny b">John</code>被用作第一维度的行索引器。</li><li id="fea1" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated"><code class="fe oh oi oj ny b">Income</code>被用作第二维度的列索引器。</li><li id="0536" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated"><code class="fe oh oi oj ny b">Jan2022</code>被用作矩阵索引器，第三维度。</li></ul><p id="ced4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你能猜出如何获得2022年2月May的费用吗？</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="20f7" class="oc nb it ny b gy od oe l of og">array_example[‘May’,’Expenses’,’Feb2022']</span></pre><p id="6c99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">超级容易！</p><p id="3f9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们只处理过当时接受单一类型的对象。例如，对于向量、矩阵或数组，我们不能在同一个对象中混合整数和字符串元素——这是数据分析的一大缺点。</p><p id="dc23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要做到这一点，我们需要依靠其他对象，如列表或数据框——它们非常强大，也在索引方面开辟了新的可能性，接下来让我们来探索它们！</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="b096" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">列表索引</h1><p id="5014" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">让我们首先创建一个包含与一个虚构学生<code class="fe oh oi oj ny b">Anne</code>相关的数据的列表:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="e24f" class="oc nb it ny b gy od oe l of og">list_example &lt;- list(<br/> name = ‘Anne’,<br/> grades = c(‘A’,’C’,’C’,’A’),<br/> GPA = 3.2<br/>)</span></pre><p id="d9d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的列表包含三个不同的对象:</p><ul class=""><li id="a075" class="mf mg it lb b lc ld lf lg li mh lm mi lq mj lu mk ml mm mn bi translated">包含值<code class="fe oh oi oj ny b">Anne</code>的名为<code class="fe oh oi oj ny b">name</code>的字符元素</li><li id="5df6" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">一个名为<code class="fe oh oi oj ny b">grades</code>的字符向量，包含值<code class="fe oh oi oj ny b">A,C,C,A</code></li><li id="28b4" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">名为<code class="fe oh oi oj ny b">GPA</code>的数值元素，包含值<code class="fe oh oi oj ny b">3.2</code></li></ul><p id="c7e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">索引这些元素可以使用我们的旧的<code class="fe oh oi oj ny b">[]</code>(尽管有很大的挫折)——假设我们想要访问第二个对象<code class="fe oh oi oj ny b">grades</code>，我们可以在这里使用数字索引:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="078c" class="oc nb it ny b gy od oe l of og">list_example[2]</span></pre><p id="b698" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">命名索引在这里也可以使用——当我们创建列表时，我们会自动将元素分配给我们的名称，因此我们可以使用:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="9206" class="oc nb it ny b gy od oe l of og">list_example['grades']</span></pre><p id="ec8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">不过，这些指数存在一个问题。</strong>如果我们看到上面两条指令的输出，我们会看到:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="6f35" class="oc nb it ny b gy od oe l of og">$grades<br/>[1] "A" "C" "C" "A"</span></pre><p id="19af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看到输出上面的<code class="fe oh oi oj ny b">$grades</code>了吗？这意味着我们只访问这个对象的“表示”,而不是对象本身。我知道这看起来有点奇怪，但是这将阻止我们访问底层元素(大多数情况下，这是您想要做的)。</p><p id="e25a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设我想通过使用一个法向量索引来访问第一级(<code class="fe oh oi oj ny b">A</code>)——在尝试新的索引之前，我将把检索到的元素(<code class="fe oh oi oj ny b">grades</code>)保存到一个名为<code class="fe oh oi oj ny b">grades_vector</code>的新对象中:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="9602" class="oc nb it ny b gy od oe l of og">grades_vector = list_example['grades']</span></pre><p id="d4b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们从<code class="fe oh oi oj ny b">list_example</code>中检索一个向量到<code class="fe oh oi oj ny b">grades_vector</code>中，我应该能够使用我们已经学过的索引来访问该对象中的元素，对吗？毕竟这是一个向量！</p><p id="9b4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="a6b7" class="oc nb it ny b gy od oe l of og">grades_vector[1]</span></pre><p id="249e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将输出:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="9a41" class="oc nb it ny b gy od oe l of og">$grades<br/>[1] "A" "C" "C" "A"</span></pre><p id="cd14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯..很奇怪，对吧？我们期望只检索到<code class="fe oh oi oj ny b">grades_vector</code>的第一个元素。发生了什么事？</p><p id="6145" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这与我之前所说的有关，<strong class="lb iu">在列表索引上使用</strong> <code class="fe oh oi oj ny b"><strong class="lb iu">[]</strong></code> <strong class="lb iu">只会检索底层对象的一个<em class="lv"> meta </em>表示。要访问对象本身，我们有两种方法——使用双方括号或美元符号符号！让我们看看两者，从双方括号开始:</strong></p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="2edd" class="oc nb it ny b gy od oe l of og">grades_vector = list_example[['grades']]</span></pre><p id="ae75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，事情有点不同了。让我们再次尝试索引我们的<code class="fe oh oi oj ny b">grades_vector</code>:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="5c72" class="oc nb it ny b gy od oe l of og">grades_vector[1]</span></pre><p id="bd89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在输出<code class="fe oh oi oj ny b">A</code>！双方括号符号对数字索引和命名索引都有效。请记住，这是索引<code class="fe oh oi oj ny b">list</code>类型对象的特殊情况，与我们到目前为止所学的其他对象无关！</p><p id="2750" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们还可以使用美元符号符号从列表中检索元素:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="2c20" class="oc nb it ny b gy od oe l of og">list_example$grades</span></pre><p id="f78b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将输出:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="bef4" class="oc nb it ny b gy od oe l of og">[1] "A" "C" "C" "A"</span></pre><p id="2542" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">美元符号符号只适用于列表索引的命名版本。使用美元符号符号，访问对象的一个<em class="lv">元</em>表示的问题不会发生。</p><p id="6b98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于列表的灵活性和强大功能，当涉及到索引时，列表也有其自身的复杂性——简而言之:</p><ul class=""><li id="0fa0" class="mf mg it lb b lc ld lf lg li mh lm mi lq mj lu mk ml mm mn bi translated">使用<code class="fe oh oi oj ny b">[]</code>只会访问对象的一个表示，阻止我们访问底层元素。</li><li id="0e56" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">使用<code class="fe oh oi oj ny b">[[]]</code>可以让我们访问列表对象中的底层元素。</li><li id="467e" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">使用<code class="fe oh oi oj ny b">$</code>是我们可以在列表对象上使用的索引器的一个特例，但是它只对我们的索引的命名版本起作用。</li></ul><p id="c04f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还要学习另一个对象，也可以说是最著名的R对象——R数据框。</p><p id="4e9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在底层，R将数据帧存储为列表，但它们也是二维对象(类似于矩阵)。该组合将在其索引中表示出来！让我们看看，下一个。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="281c" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">数据帧索引</h1><p id="2667" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">由于它们是二维对象，数据框在索引时实际上类似于矩阵。它们比后者有优势，因为它们可以保存多种数据类型。</p><p id="f3e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们以<code class="fe oh oi oj ny b">iris</code>数据帧为例，我将在我的环境中将其保存为<code class="fe oh oi oj ny b">iris_df</code>:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="9ed6" class="oc nb it ny b gy od oe l of og">iris_df &lt;- iris</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/6305ad87ab0b3f6460d3e65c7b4d3982.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*-ggcYBO1Slf4ZODaYxQ1kw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Iris_Df预览—作者图片</p></figure><p id="24a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想要选取第一行第三列，其中包含值<code class="fe oh oi oj ny b">1.4</code>——使用我们从矩阵中获得的知识:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="d06d" class="oc nb it ny b gy od oe l of og">iris_df[1,3]</span></pre><p id="aabf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在矩阵中看到的规则同样适用于这里。但是..这似乎不是处理数据框的最实用的方式。</p><p id="b96b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，还记得美元符号吗？在数据框中，它们可用于选择整列，例如:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="13a0" class="oc nb it ny b gy od oe l of og">iris_df$Species</span></pre><p id="2ca5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码输出数据框中这一列的所有值。就这么简单！由于数据帧(底层)是一个<code class="fe oh oi oj ny b">list</code>元素的集合，使用<code class="fe oh oi oj ny b">$</code>就好像我们在处理一个包含多个向量的列表。</p><p id="99e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于索引数据框，仍然缺少一些东西。通常，当我们索引类似于表的对象时，我们希望执行某种类型的过滤或列子集，对吗？—如果您曾经使用过SQL，您会非常清楚我在说什么！</p><p id="22f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你认为我们如何索引上面数据框中的所有<code class="fe oh oi oj ny b">Species</code>集合？下面是一个例子:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="5114" class="oc nb it ny b gy od oe l of og">iris_df[iris_df$Species == 'setosa',]</span></pre><p id="0954" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们慢慢来看最后一条指令，因为它包含了我们到目前为止还没见过的新概念。</p><ul class=""><li id="9176" class="mf mg it lb b lc ld lf lg li mh lm mi lq mj lu mk ml mm mn bi translated">在上面的代码中，我们仍然通过使用一个<code class="fe oh oi oj ny b">,</code>来维护第一和第二维索引的逻辑。</li><li id="9238" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">专注于<code class="fe oh oi oj ny b">iris_df$Species == 'setosa'</code>，我们到底在这里做什么？我们使用<code class="fe oh oi oj ny b">$</code>从<code class="fe oh oi oj ny b">Species</code>获取所有值，并检查这些值是否等于<code class="fe oh oi oj ny b">setosa</code>。在这段代码中，R将输出一个包含<code class="fe oh oi oj ny b">TRUE</code>或<code class="fe oh oi oj ny b">FALSE</code>的向量，这取决于该植物是否为<code class="fe oh oi oj ny b">setosa</code>。</li><li id="2c03" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">接下来，进入一个我们从未见过的很酷的魔术。如果我们将向量<code class="fe oh oi oj ny b">TRUE</code>和<code class="fe oh oi oj ny b">FALSE</code>传递给索引器，R将只选择找到<code class="fe oh oi oj ny b">TRUE</code>的元素——在上面的例子中，我们实际上是在声明“请检索所有<code class="fe oh oi oj ny b">Species</code>等于<code class="fe oh oi oj ny b">setosa</code>的索引”。</li><li id="2fc1" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">我们在哪里应用这个条件？看看我们如何在逗号前应用它，这意味着我们在过滤行索引(第一维)。</li><li id="31a2" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">因为逗号的右边是空白的，我们从第二维度带来了什么元素呢？良好的..所有人！</li></ul><p id="463c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行上面的代码将返回一个有50行的新dataframe我们原来的<code class="fe oh oi oj ny b">iris_df</code>中的<code class="fe oh oi oj ny b">setosas</code>的数量！</p><p id="2b31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你能猜到我是如何在应用上述条件的同时只选择<code class="fe oh oi oj ny b">Sepal.Width</code>的吗？</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="6eac" class="oc nb it ny b gy od oe l of og">iris_df[iris_df$Species == 'setosa','Sepal.Width']</span></pre><p id="44dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没错——只需将该名称添加到第二维索引中即可！如果我想要两个子集<code class="fe oh oi oj ny b">Sepal.Width</code>和<code class="fe oh oi oj ny b">Sepal.Length</code>呢？一个载体来救援！</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="a2db" class="oc nb it ny b gy od oe l of og">iris_df[iris_df$Species == ‘setosa’,c(‘Sepal.Width’, ‘Sepal.Length’)]</span></pre><p id="5016" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，数据框索引融合了我们在这篇文章中学到的一些概念。在我们离开之前，让我向您展示我们如何在索引上使用更多的条件，假设我想检索<code class="fe oh oi oj ny b">setosa</code>和<code class="fe oh oi oj ny b">virginica</code>花:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="9339" class="oc nb it ny b gy od oe l of og">iris_df[(iris_df$Species == 'setosa') | (iris_df$Species == 'virginica'),]</span></pre><p id="15f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我现在使用的是r中的OR运算符<code class="fe oh oi oj ny b">|</code>，这个<code class="fe oh oi oj ny b">|</code>使我能够访问更高级的属性，比如选择所有属于<code class="fe oh oi oj ny b">setosa</code>或<code class="fe oh oi oj ny b">virginica</code>的花。注意我是如何在索引器中的逗号前做所有事情的！这是为什么呢？因为，在这种情况下，我们总是在行上工作！</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><p id="3459" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢你花时间阅读这篇文章！我希望我已经澄清了您关于R索引的一些问题，并且您现在能够更有效地使用不同的R对象。</p><p id="3099" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经详细描述了R中关于索引的最重要的元素，但是有几个概念我没有提到，特别是关于库的。例如，作为这篇文章的后续，我提出的一个建议是自己研究如何索引<code class="fe oh oi oj ny b">dplyr</code>包中的对象，这是最重要的数据争论R包之一。</p><p id="1b9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">我在Udemy上建立了一个</em></strong><a class="ae ky" href="https://www.udemy.com/course/r-for-absolute-beginners/?couponCode=IVOSTUDENTSAUGUST" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"><em class="lv">R</em></strong></a><strong class="lb iu"><em class="lv">入门和一个</em> </strong> <a class="ae ky" href="https://www.udemy.com/course/r-for-data-science-first-step-data-scientist/?referralCode=IVOSTUDENTSJUNE" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="lv">数据科学学习训练营</em> </strong> </a> <strong class="lb iu"> <em class="lv">。这两个课程都是为初学者量身定做的，我希望你能在我身边！</em>T24】</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/448b5abcd3b81aa4ffd9bbe8d6684d50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hFKOMT3AxxBJid2HwIOvnQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">绝对初学者的R编程课程 —图片由作者提供</p></figure><div class="op oq gp gr or os"><a href="https://medium.com/membership/@ivopbernardo" rel="noopener follow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">通过我的推荐链接加入Medium-Ivo Bernardo</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">阅读我在Medium上的所有故事，了解更多关于数据科学和分析的信息。加入中级会员，您将…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">medium.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg ks os"/></div></div></a></div></div></div>    
</body>
</html>