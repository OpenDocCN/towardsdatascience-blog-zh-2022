<html>
<head>
<title>Python Decorators in 10 minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">10分钟后Python Decorators</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-decorators-in-10-minutes-c8bca1020235#2022-02-14">https://towardsdatascience.com/python-decorators-in-10-minutes-c8bca1020235#2022-02-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="087f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">装饰速成课程，包含流行的现实生活中的使用示例</h2></div><p id="9d4f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可能已经注意到在函数的正上方添加了<code class="fe le lf lg lh b">@&lt;something&gt;</code>的代码，比如在类方法的正上方添加了<code class="fe le lf lg lh b">@staticmethod</code>、<code class="fe le lf lg lh b">@classmethod</code>，这些实际上是Python的装饰器。Decorators允许在不修改源代码的情况下扩展现有的函数。</p><p id="069f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将通过理解装饰器的结构、探索高级行为(如克服装饰器的缺点、多嵌套装饰器、堆叠装饰器)以及一些实际应用来编写我们自己的Python装饰器。</p><p id="1854" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="li">更新</em> </strong> <em class="li">:本文是系列文章的一部分。查看其他“10分钟内”话题</em> <a class="ae lj" href="https://medium.com/@kayjanwong/list/in-10-minutes-eeaa9aa67055" rel="noopener"> <em class="li">此处</em> </a> <em class="li">！</em></p><h1 id="3bfd" class="lk ll it bd lm ln lo lp lq lr ls lt lu jz lv ka lw kc lx kd ly kf lz kg ma mb bi translated">目录</h1><ul class=""><li id="895b" class="mc md it kk b kl me ko mf kr mg kv mh kz mi ld mj mk ml mm bi translated"><a class="ae lj" href="https://medium.com/p/c8bca1020235/#90bf" rel="noopener">装饰器的结构</a></li><li id="4685" class="mc md it kk b kl mn ko mo kr mp kv mq kz mr ld mj mk ml mm bi translated"><a class="ae lj" href="https://medium.com/p/c8bca1020235/#4807" rel="noopener">装修工的先进行为</a></li><li id="5923" class="mc md it kk b kl mn ko mo kr mp kv mq kz mr ld mj mk ml mm bi translated"><a class="ae lj" href="https://medium.com/p/c8bca1020235/#be80" rel="noopener">用途:测量执行时间</a></li><li id="464e" class="mc md it kk b kl mn ko mo kr mp kv mq kz mr ld mj mk ml mm bi translated"><a class="ae lj" href="https://medium.com/p/c8bca1020235/#1664" rel="noopener">用途:带测井调试</a></li><li id="e328" class="mc md it kk b kl mn ko mo kr mp kv mq kz mr ld mj mk ml mm bi translated"><a class="ae lj" href="https://medium.com/p/c8bca1020235/#583f" rel="noopener">用法:创建单例类</a></li></ul></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="90bf" class="lk ll it bd lm ln mz lp lq lr na lt lu jz nb ka lw kc nc kd ly kf nd kg ma mb bi translated">装饰者的结构</h1><p id="a5fc" class="pw-post-body-paragraph ki kj it kk b kl me ju kn ko mf jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">Decorators可以被认为是一个函数包装器，这意味着它接受一个函数作为参数，并返回该函数的修改版本——向其添加扩展或功能。</p><pre class="nh ni nj nk gt nl lh nm bn nn no bi"><span id="22c1" class="np ll it lh b be nq nr l ns nt">def sample_decorator(func):<br/>    def wrapper(*args, **kwargs):<br/>        # do something before function execution<br/>        result = func(*args, **kwargs)<br/>        # do something after function execution<br/>        return result<br/>    return wrapper</span></pre><p id="6091" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从上面显示的结构中，我们可以看到函数执行发生在第4行，但是我们可以修改函数执行之前、期间甚至之后发生的事情。装饰者有可能改变函数的输入、输出或行为，但是最好以不降低它所包装的函数的可理解性的方式来实现它。</p><blockquote class="nu"><p id="bb5b" class="nv nw it bd nx ny nz oa ob oc od ld dk translated">装饰者最适合用来向多个函数添加公共行为，而不用手动修改每个函数</p></blockquote><h1 id="4807" class="lk ll it bd lm ln lo lp lq lr ls lt lu jz oe ka lw kc of kd ly kf og kg ma mb bi translated">装饰者的高级行为</h1><h2 id="20c2" class="oh ll it bd lm oi oj dn lq ok ol dp lu kr om on lw kv oo op ly kz oq or ma os bi translated">保留包装函数的元数据</h2><p id="fd66" class="pw-post-body-paragraph ki kj it kk b kl me ju kn ko mf jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">使用decorator的一个警告是，函数的元数据会被decorator隐藏。在上一节的代码片段中，我们返回了一个<code class="fe le lf lg lh b">wrapper</code>函数，而不是原始函数，这意味着任何修饰过的函数都将把它们的<code class="fe le lf lg lh b">__name__</code>元数据覆盖到<code class="fe le lf lg lh b">wrapper</code>。</p><pre class="nh ni nj nk gt nl lh nm bn nn no bi"><span id="2a08" class="np ll it lh b be nq nr l ns nt">@sample_decorator<br/>def func_add(a, b):<br/>    return a + b<br/><br/>print(func_add.__name__)<br/># wrapper</span></pre><p id="241c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从技术角度来说，这不会影响函数或装饰器的预期执行，但这仍然是避免使用装饰器的任何意外后果的最佳实践。这可以通过为<code class="fe le lf lg lh b">wrapper</code>函数添加一个<code class="fe le lf lg lh b">@wraps</code>装饰器来轻松完成，如下所示。装饰器可以以同样的方式使用，但是包装函数的元数据现在不会被覆盖。</p><pre class="nh ni nj nk gt nl lh nm bn nn no bi"><span id="4d97" class="np ll it lh b be nq nr l ns nt">from functools import wraps<br/><br/><br/>def sample_decorator(func):<br/>    @wraps(func)<br/>    def wrapper(*args, **kwargs):<br/>        # do something before function execution<br/>        result = func(*args, **kwargs)<br/>        # do something after function execution<br/>        return result<br/>    return wrapper</span></pre><h2 id="fd2e" class="oh ll it bd lm oi oj dn lq ok ol dp lu kr om on lw kv oo op ly kz oq or ma os bi translated">接受参数的装饰者</h2><p id="efe3" class="pw-post-body-paragraph ki kj it kk b kl me ju kn ko mf jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">装饰器本质上是一个函数(包装另一个函数),应该能够接受参数。我发现传入一个布尔变量很有用，这样我就可以切换装饰器的行为，比如当我想进入或退出调试模式时打开或关闭打印。这可以通过用另一个函数包装器包装装饰器来实现。</p><p id="2730" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的例子中，我有一个装饰器<code class="fe le lf lg lh b">debug_decorator</code>，它可以接受参数并返回一个<code class="fe le lf lg lh b">decorator</code>装饰器，该装饰器将原始函数包装在<code class="fe le lf lg lh b">wrapper</code>中。由于多个嵌套函数，这一开始看起来相当复杂。建议首先编写原始的装饰器，最后包装它以接受参数。</p><pre class="nh ni nj nk gt nl lh nm bn nn no bi"><span id="45bd" class="np ll it lh b be nq nr l ns nt">from functools import wraps<br/><br/>debug_mode = True<br/><br/><br/>def debug_decorator(debug_mode):<br/>    """Example: Passing arguments to a decorator"""<br/>    def decorator(func):<br/>        @wraps(func)<br/>        def wrapper(*args, **kwargs):<br/>            if debug_mode:<br/>                print(f"Function called: {func.__name__}")<br/>            result = func(*args, **kwargs)<br/>            return result<br/>        return wrapper<br/>    return decorator<br/><br/><br/>@debug_decorator(debug_mode)<br/>def func_add(a, b):<br/>    return a + b<br/><br/><br/>func_add(1, 2)<br/># Function called: func_add<br/># 3</span></pre><h2 id="618e" class="oh ll it bd lm oi oj dn lq ok ol dp lu kr om on lw kv oo op ly kz oq or ma os bi translated">堆叠装饰者</h2><p id="3e66" class="pw-post-body-paragraph ki kj it kk b kl me ju kn ko mf jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">如前所述，decorators允许扩展现有的功能。可以在一个函数上堆叠多个decorators来添加更多的扩展。执行的顺序将遵循装饰器的堆叠顺序。</p><p id="2419" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">需要注意的一点是，时间敏感的decorators如果是堆叠的，应该最后添加。比如，衡量一个函数执行时间的decorator应该是最后执行的，这样才能准确反映执行时间，不受其他decorator的影响。</p><p id="fecb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们已经理解了装饰器的结构和它的高级行为，我们可以深入到它们的实际应用中去了！</p><h1 id="be80" class="lk ll it bd lm ln lo lp lq lr ls lt lu jz lv ka lw kc lx kd ly kf lz kg ma mb bi translated">用法:测量执行时间</h1><p id="2bfd" class="pw-post-body-paragraph ki kj it kk b kl me ju kn ko mf jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated"><code class="fe le lf lg lh b">timer</code> decorator可以通过记录函数执行的开始时间和结束时间并将结果打印到控制台来测量包装函数的执行时间。</p><p id="2736" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的代码片段中，我们测量了函数执行前后的<code class="fe le lf lg lh b">start_time</code>和<code class="fe le lf lg lh b">end_time</code>。</p><pre class="nh ni nj nk gt nl lh nm bn nn no bi"><span id="af14" class="np ll it lh b be nq nr l ns nt">import time<br/><br/>from functools import wraps<br/><br/><br/>def timer(func):<br/>    """Example: Measure execution time of function"""<br/>    @wraps(func)<br/>    def wrapper(*args, **kwargs):<br/>        start_time = time.time()<br/>        result = func(*args, **kwargs)<br/>        end_time = time.time()<br/>        print(f"Execution time: {round(end_time - start_time, 4)}")<br/>        return result<br/>    return wrapper<br/><br/><br/>@timer<br/>def func_add(a, b):<br/>    time.sleep(2)<br/>    return a + b<br/><br/><br/>func_add(1, 2)<br/># Execution time: 2.0064</span></pre><h1 id="1664" class="lk ll it bd lm ln lo lp lq lr ls lt lu jz lv ka lw kc lx kd ly kf lz kg ma mb bi translated">用法:使用日志调试</h1><p id="e07f" class="pw-post-body-paragraph ki kj it kk b kl me ju kn ko mf jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated"><code class="fe le lf lg lh b">logging</code>装饰器可用于将信息记录到控制台或日志文件中，对于调试非常有用。在下面的代码片段中，我们将使用<code class="fe le lf lg lh b">logging</code> python包来执行日志记录。</p><pre class="nh ni nj nk gt nl lh nm bn nn no bi"><span id="8f19" class="np ll it lh b be nq nr l ns nt">import logging<br/><br/>from datetime import datetime<br/>from functools import wraps<br/><br/>logging.basicConfig(level=logging.INFO)<br/>logger = logging.getLogger(__name__)<br/><br/><br/>def logging(func):<br/>    """Example: Logging with decorator"""<br/><br/>    @wraps(func)<br/>    def wrapper(*args, **kwargs):<br/>        log_time = datetime.today().strftime("%Y-%m-%d %H:%M:%S")<br/>        logger.info(f"{log_time}: {func.__name__} called")<br/>        result = func(*args, **kwargs)<br/>        return result<br/>    return wrapper</span></pre><h1 id="583f" class="lk ll it bd lm ln lo lp lq lr ls lt lu jz lv ka lw kc lx kd ly kf lz kg ma mb bi translated">用法:创建单例类</h1><p id="53e0" class="pw-post-body-paragraph ki kj it kk b kl me ju kn ko mf jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated"><code class="fe le lf lg lh b">singleton</code>装饰器可以用来创建一个单例类。Singleton是一种创造性的设计模式，它限制一个类只能有一个实例。这在对共享资源的并发访问或资源的全局访问点有限制的情况下很有用，例如对数据库的并发访问或数据库的单点访问施加限制。</p><p id="b5af" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">单例类可以专门编码以确保单个实例化。然而，如果有多个单独的类，使用decorators是为多个类重用代码的好方法。</p><pre class="nh ni nj nk gt nl lh nm bn nn no bi"><span id="68b1" class="np ll it lh b be nq nr l ns nt">from functools import wraps<br/><br/><br/>def singleton(cls):<br/>    """Example: Create singleton class with decorator"""<br/>    instances = {}<br/><br/>    @wraps(cls)<br/>    def wrapper(*args, **kwargs):<br/>        if cls not in instances:<br/>            instances[cls] = cls(*args, **kwargs)<br/>        return instances[cls]<br/>    return wrapper<br/><br/><br/>@singleton<br/>class SampleClass:<br/>    def __init__(self):<br/>        pass<br/><br/><br/>singleton_class = SampleClass()<br/>singleton_class2 = SampleClass()<br/>print(singleton_class == singleton_class2)<br/># True</span></pre></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><p id="8f06" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">希望你已经学会了装修工的基础知识，有用的小技巧，以及装修工的实际例子。还有其他的用法，比如使用decorators进行超时操作、记忆和缓存。那些decorator更高级，最好使用内置的Python decorators或者Python包中的decorator，而不是自己实现。</p><p id="56fa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">感谢您的阅读！</strong>如果你喜欢这篇文章，请随意分享。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="f125" class="lk ll it bd lm ln mz lp lq lr na lt lu jz nb ka lw kc nc kd ly kf nd kg ma mb bi translated">相关链接</h1><p id="146a" class="pw-post-body-paragraph ki kj it kk b kl me ju kn ko mf jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">伐木文件:<a class="ae lj" href="https://docs.python.org/3/howto/logging.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/howto/logging.html</a></p><p id="d137" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">超时装饰:<a class="ae lj" href="https://pypi.org/project/timeout-decorator/" rel="noopener ugc nofollow" target="_blank">https://pypi.org/project/timeout-decorator/</a></p><p id="077f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">缓存文档:<a class="ae lj" href="https://docs.python.org/3/library/functools.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/functools.html</a></p></div></div>    
</body>
</html>