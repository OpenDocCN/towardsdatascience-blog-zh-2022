<html>
<head>
<title>Data Science: Write Robust Python With Static Typing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学:用静态类型编写健壮的Python</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-science-write-robust-python-with-static-typing-c71b9c9c8044#2022-07-27">https://towardsdatascience.com/data-science-write-robust-python-with-static-typing-c71b9c9c8044#2022-07-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="ac15" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">针对Python 3.10进行了更新</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/4c4a8446261a14016b3d95248329da83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rbiDe7yU1Za0dq1X"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated"><a class="ae le" href="https://unsplash.com/@umby?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">翁贝托</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="b502" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编程语言有两种:<strong class="js iu">静态类型</strong>和<strong class="js iu">动态类型</strong>语言。</p><p id="a9f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Python是一种动态类型语言。您不必显式指定变量的数据类型。函数也是如此:您不必指定参数的类型或函数的返回类型。</p><p id="51b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">换句话说，没有代码编译—<strong class="js iu">Python解释器在运行时执行类型检查— </strong>在代码执行期间。</p><p id="c224" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，在静态类型语言中(比如<strong class="js iu"> Java </strong>)，必须声明每个变量的数据类型。因此，类型检查在编译时完成。这就是为什么静态类型语言通常更快，但更冗长。</p><p id="f0a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了<strong class="js iu"> PEP 3107 </strong>和<strong class="js iu"> PEP 484 </strong>，我们就可以使用Python中的<strong class="js iu"> <em class="lf">类型注释</em> </strong>来注释数据类型。然而，Python仍将是一种动态语言。类型提示的作用是帮助您编写干净和健壮的代码。</p><p id="b32e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有两种主要类型的注释:</p><ul class=""><li id="7856" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn ll lm ln lo bi translated"><strong class="js iu">变量注释</strong></li><li id="b95a" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated"><strong class="js iu">功能注释</strong></li></ul><p id="41ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是首先，让我们演示一个案例，说明为什么类型注释是有益的。</p><h1 id="c434" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated"><strong class="ak">迷你示例</strong></h1><p id="7950" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">假设我们有一个简单的<em class="lf">熊猫</em>数据框架和电影评论。我们希望执行一些基本的预处理，然后将结果存储在一个新的变量中:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f037" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mz na nb nc b">reviews_cleaned</code>变量现在是一个<em class="lf">系列</em>而不是一个<em class="lf">数据帧。因为<code class="fe mz na nb nc b">reviews</code> <em class="lf">数据帧</em>只有一列，所以很容易忽略这一点。</em></p><p id="475a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看是否可以使用类型注释来提高Python代码的可读性。</p><h1 id="d066" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">可变注释</h1><p id="4c0d" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">我们在声明变量时使用它们。在变量后，添加一个分号，后跟一个空格(<strong class="js iu"> PEP </strong> standard)和变量的类型:例如:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="4135" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还可以注释<strong class="js iu">非原语</strong>变量，比如<strong class="js iu"> <em class="lf">列表</em> </strong>、<strong class="js iu"> <em class="lf">元组、</em> </strong>和<strong class="js iu"> <em class="lf">字典</em> </strong>:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="3566" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，我们可以标注<strong class="js iu">数据科学相关的</strong>模块如<strong class="js iu"> <em class="lf">熊猫</em> </strong>和<em class="lf"/><strong class="js iu"><em class="lf">NumPy</em></strong><em class="lf">:</em></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="6c8c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注:</strong>如果导入别名不是<code class="fe mz na nb nc b">pd</code>和<code class="fe mz na nb nc b">np</code>的<em class="lf">熊猫</em>和<em class="lf"> numpy </em>，则相应更改注释。</p><h1 id="92fd" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">函数注释</h1><p id="e7cf" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">我们还可以注释函数/方法参数及其返回类型。让我们看一个例子:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="cb0b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">函数<code class="fe mz na nb nc b">sum_2_numbers</code>计算两个数的和。然而，因为<code class="fe mz na nb nc b">+</code>操作符是重载的，所以它的行为有所不同:对于整数/浮点数，该函数计算它们的总和。对于字符串，函数<code class="fe mz na nb nc b">sum_2_numbers</code>输出它们的连接。</p><p id="67d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以通过为参数和返回值添加<em class="lf">类型注释</em>来使函数<code class="fe mz na nb nc b">sum_2_numbers</code>更加清晰。我们使用以下格式(<strong class="js iu">粗体</strong>显示我们添加的注释):</p><p id="6713" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mz na nb nc b"><em class="lf">function_name (argument_name</em><strong class="js iu">: argument_type</strong><em class="lf">) </em><strong class="js iu">-&gt; return_type:</strong></code></p><p id="25b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用注释，函数<code class="fe mz na nb nc b">sum_2_numbers</code>就变成了:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c956" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该函数接受两个整数作为输入，并输出一个整数。</p><blockquote class="nd ne nf"><p id="cd37" class="jq jr lf js b jt ju jv jw jx jy jz ka ng kc kd ke nh kg kh ki ni kk kl km kn im bi translated"><strong class="js iu">注意:</strong>用户仍然可以传递float和string数据类型——注释只是提示而不是要求。</p></blockquote><p id="33e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，我们可以使用一个工具来强制进行类型检查。</p><h1 id="4d61" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">输入Mypy:在运行时强制类型检查</h1><p id="bd7b" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">2012年，当时的博士生Jukka Lehtosalo开始了一个被称为<strong class="js iu"> <em class="lf"> Mypy </em>的兼职项目。</strong></p><p id="89e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Mypy 最初被设想为Python的一个变种，具有无缝的动态和静态类型。最初，它是作为一门独立的语言开始的。然后，它被重写为一个外部库，与Python兼容。</p><p id="4af7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，安装库:</p><pre class="kp kq kr ks gt nj nc nk nl aw nm bi"><span id="810c" class="nn lv it nc b gy no np l nq nr">$ pip install mypy</span></pre><p id="184d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们编写以下脚本来演示<em class="lf"> Mypy </em> <strong class="js iu"> </strong>如何工作:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="6af7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，使用<em class="lf"> Mypy </em>运行脚本。您应该会看到以下输出:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/84f115632dc320a8bf87c4b57087cd00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*NjW186xpvef-ja9UgEcofA.png"/></div></figure><p id="5f95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们故意创建一个错误来检查<em class="lf"> Mypy的行为。</em>将变量<code class="fe mz na nb nc b">age</code> <em class="lf"> </em>的类型从<strong class="js iu"> int </strong>改为<strong class="js iu"> str </strong>并运行脚本。您应该看到以下内容:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nt"><img src="../Images/c74a71ea00ec911249c326b44751c1b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*wlz2WgFnhpix-pXAotvPbg.png"/></div></div></figure><p id="9e4c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Mypy 已经成功检测到<code class="fe mz na nb nc b">age</code>应该是类型<strong class="js iu"> str。</strong>感受<strong class="js iu"> </strong>自由进行你的实验，检查<em class="lf"> Mypy </em>如何工作。</p><h1 id="77f2" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">高级注释</h1><p id="a10e" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">到目前为止，我们已经了解了Python中类型注释的基本工作原理。Python <code class="fe mz na nb nc b">Typing</code>模块包含许多不常用的注释类型。让我们来看看其中的几个:</p><h2 id="45a1" class="nn lv it bd lw nu nv dn ma nw nx dp me kb ny nz mi kf oa ob mm kj oc od mq oe bi translated"><strong class="ak">可调用</strong></h2><p id="1234" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">在Python中，<strong class="js iu"> <em class="lf"> Callables </em> </strong>既可以是函数也可以是类(如果它们实现了<code class="fe mz na nb nc b">__call__</code>方法)。</p><p id="e255" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，我们将重点讨论函数。当一个函数是另一个函数的参数时，我们使用来自<code class="fe mz na nb nc b">Typing</code>模块的<em class="lf">可调用</em>提示。让我们看一个例子:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7bbf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们得到以下输出:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi of"><img src="../Images/598c280d05a0cb215beb550f77796b89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*S-hNYVEZ9gD7oEaRxfmaHQ.png"/></div></figure><h2 id="d241" class="nn lv it bd lw nu nv dn ma nw nx dp me kb ny nz mi kf oa ob mm kj oc od mq oe bi translated">联盟</h2><p id="9cd3" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">当一个变量可以有多种类型时，我们使用联合。</p><p id="ba64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在前面的例子中，<code class="fe mz na nb nc b">square</code>函数被注释为只接受整数。实际上，我们也可以计算浮点数的平方。我们可以使用<strong class="js iu"> Union </strong>注释来添加这个功能:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="2358" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出与之前相同。<code class="fe mz na nb nc b">square</code>函数现在可以接受整数或浮点数。</p><p id="5b7e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Python 3.10 ( <strong class="js iu"> PEP 604 </strong>)中，我们可以用管道运算符代替<strong class="js iu"> Union。</strong>我们可以将<code class="fe mz na nb nc b">square</code>函数重写如下:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><h2 id="0652" class="nn lv it bd lw nu nv dn ma nw nx dp me kb ny nz mi kf oa ob mm kj oc od mq oe bi translated">没有人</h2><p id="8b71" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">没有返回值的函数怎么办？在静态类型语言中，我们通常使用特定的关键字。比如在<em class="lf"> Java </em>中，我们使用<strong class="js iu"> void </strong>关键字。</p><p id="ac8c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Python中，我们可以使用常规的<strong class="js iu"> None </strong>关键字:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="c77c" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">任何的</h1><p id="f82b" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">另一方面，我们可能希望让变量不受约束——与每种类型兼容。我们可以使用<strong class="js iu"> Any </strong>注释来实现这一点:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c10a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">大多数开发人员避免使用<strong class="js iu"> Any </strong>注释<strong class="js iu"> </strong>，因为它没有贡献任何价值——我们还不如完全跳过注释。</p><p id="25d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们以后会看到更好的选择。</p><h2 id="e760" class="nn lv it bd lw nu nv dn ma nw nx dp me kb ny nz mi kf oa ob mm kj oc od mq oe bi translated">顺序</h2><p id="a7a2" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">在某些情况下，我们的函数可能期望某种类型的序列，并不真正关心输入是一个<em class="lf">列表</em>还是一个<em class="lf">元组</em>。一般来说，<strong class="js iu"> <em class="lf">序列</em> </strong>是实现<code class="fe mz na nb nc b">__getitem__()</code>方法的任何东西。</p><p id="16e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看一个如何使用来自<code class="fe mz na nb nc b">Typing</code>模块的<em class="lf">序列</em> <strong class="js iu"> </strong>注释的例子:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="9929" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们得到以下输出:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi of"><img src="../Images/c2c84357f9be4377228192159941105e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*yexRehLN2wmkahBVTRHJJA.png"/></div></figure><p id="7e1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们也可以使用<em class="lf"> Mypy </em>来验证类型检查:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi of"><img src="../Images/3b0a1523b4043b481bc85aea3f4ac99f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*PIJbNrzIizxbC71x3fZz3Q.png"/></div></figure><h2 id="89c3" class="nn lv it bd lw nu nv dn ma nw nx dp me kb ny nz mi kf oa ob mm kj oc od mq oe bi translated">TypeVar —泛型简介</h2><p id="e408" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">在前面的脚本中，我们的序列可以处理任何类型的变量，因为我们使用了<strong class="js iu"> Any </strong>注释。然而，这使得我们的代码有点模糊。</p><p id="2d4d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在许多情况下，我们希望对函数可以接受的变量类型加以限制。</p><p id="f801" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们希望<strong class="js iu"> script2.py </strong>到<strong class="js iu"> </strong>中的<code class="fe mz na nb nc b">iteration</code>函数只接受带有<strong class="js iu"> str </strong>或<strong class="js iu"> int </strong>值的序列。我们可以使用<code class="fe mz na nb nc b">TypeVar</code> <strong class="js iu"> </strong>变量——一个<strong class="js iu">类型变量</strong>,让我们声明一个<strong class="js iu">泛型</strong>类型:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="92ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们声明了一个名为<code class="fe mz na nb nc b">numeric_var</code>的新类型变量，它接受<em class="lf">字符串</em>和<em class="lf">整数。</em>因此，<code class="fe mz na nb nc b">iteration</code>函数现在接受包含<strong class="js iu">整数</strong>或<strong class="js iu">字符串</strong>的<strong class="js iu">序列</strong>，但不是两者都包含。</p><p id="11a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还使用了<em class="lf"> Mypy </em>的<code class="fe mz na nb nc b">reveal_type</code>功能。这个函数告诉我们Mypy如何解释我们的类型提示。</p><p id="b22c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们使用<em class="lf"> Mypy </em>运行脚本。我们得到以下输出:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi og"><img src="../Images/f43f682a19e81c9f7157dc59142c54a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hnJnzPwDhZXCZFqwWTxTMw.png"/></div></div></figure><p id="4a14" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Mypy 发现了2个错误，这是我们预料到的。问题出在<code class="fe mz na nb nc b">l2</code>和<code class="fe mz na nb nc b">t2</code>变量上。具体来说，<code class="fe mz na nb nc b">l2</code>列表包含浮点，而<code class="fe mz na nb nc b">t2</code>元组包含整数和字符串。</p><p id="5ad9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要解决这个问题，注释掉<code class="fe mz na nb nc b">t2</code>和<code class="fe mz na nb nc b">l2</code>变量并再次运行:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi og"><img src="../Images/ba3289a868999b0673bbe39f884a9930.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PBcqOgemQjsbqERViZe6Nw.png"/></div></div></figure><p id="9a5e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，类型检查没有发现任何错误。<em class="lf"> Mypy </em>找到了两个变量，一个包含<em class="lf">整数</em>的<em class="lf">列表</em>和一个包含<em class="lf">字符串的<em class="lf">元组</em>。</em></p><h1 id="bb20" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">Python 3.9中的变化</h1><p id="c31a" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">从Python 3.9开始(特别是<a class="ae le" href="https://www.python.org/dev/peps/pep-0585/" rel="noopener ugc nofollow" target="_blank"> PEP 585 </a>)，一些类如<code class="fe mz na nb nc b">tuple</code>和<code class="fe mz na nb nc b">list</code>现在是泛型类型。因此，使用类型类本身代替<code class="fe mz na nb nc b">Typing</code>模块现在是首选。例如:</p><p id="5d5c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Python 3.8之前使用<code class="fe mz na nb nc b">Typing</code>模块的注释语法(也适用于Python 3.9以上版本):</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f6e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Python 3.9+中，我们还可以编写:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="77f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们进行导入，有一个在Python 3.8中运行上述代码的变通方法:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="624c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就我个人而言，我仍然对<code class="fe mz na nb nc b">Typing</code>模块使用注释语法，因为许多项目仍然这样做。兼容性第一。</p><h1 id="3ba1" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated"><strong class="ak">回到我们的例子</strong></h1><p id="133f" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">现在，我们准备向初始的<code class="fe mz na nb nc b">annotation_demo</code>脚本添加注释。然后，脚本变成:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="a5f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本质上，我改变了两件事:</p><ol class=""><li id="ee27" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn oh lm ln lo bi translated">对<code class="fe mz na nb nc b">preprocessing</code>函数进行了修改，以接受带注释的参数并返回带注释的值。</li><li id="75c1" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn oh lm ln lo bi translated"><code class="fe mz na nb nc b">reviews</code>和<code class="fe mz na nb nc b">reviews_cleaned</code>变量分别被正确标注为<strong class="js iu">熊猫数据帧</strong>和<strong class="js iu">熊猫系列</strong>。</li></ol><h1 id="d388" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">结束语</h1><p id="956f" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">Python中的类型提示提供了一种编写清晰易读的代码的好方法。记住Python的<a class="ae le" href="https://en.wikipedia.org/wiki/Zen_of_Python" rel="noopener ugc nofollow" target="_blank">禅</a> — <strong class="js iu">可读性很重要！</strong></p><p id="1d40" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过注释，Python采用了静态类型风格，类似于其他流行的语言。</p><p id="8076" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，Python还有许多我们在本文中没有涉及的其他注释类型。</p><p id="2cdc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我个人并不是全部都用。然而，我总是使用函数/方法注释:其他开发人员应该能够立即理解您的函数/方法签名，而无需额外的努力！</p></div><div class="ab cl oi oj hx ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="im in io ip iq"><h1 id="6218" class="lu lv it bd lw lx op lz ma mb oq md me mf or mh mi mj os ml mm mn ot mp mq mr bi translated">感谢您的阅读！</h1><ul class=""><li id="2b88" class="lg lh it js b jt ms jx mt kb ou kf ov kj ow kn ll lm ln lo bi translated">订阅我的<a class="ae le" href="/subscribe/@nikoskafritsas" rel="noopener ugc nofollow" target="_blank">简讯</a>！</li><li id="9a1e" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">在Linkedin上关注我！</li></ul></div></div>    
</body>
</html>