<html>
<head>
<title>5 dbt Data Model Hacks to Save You Precious Time</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5 dbt数据模型帮助您节省宝贵的时间</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-dbt-data-model-hacks-to-save-you-precious-time-b76f410db8c3#2022-09-08">https://towardsdatascience.com/5-dbt-data-model-hacks-to-save-you-precious-time-b76f410db8c3#2022-09-08</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""/><div class=""><h2 id="8c8d" class="pw-subtitle-paragraph js iu iv bd b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj dk translated">添加到您的项目中的最佳开源和付费工具</h2></div><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/ec91d90375aa992aa506a51e7484c9f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A_85DxsZs-kkW27Ru5iEMg.jpeg"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">Artem Maltsev 在<a class="ae la" href="https://unsplash.com/s/photos/time?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="7fd6" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">现在，我喜欢写数据模型，不要误解我。这是成为一名<a class="ae la" rel="noopener" target="_blank" href="/analytics-engineer-the-newest-data-career-role-b312a73d57d7">分析工程师</a>最有趣的部分之一。然而，写它们有很多繁琐的部分。这不仅仅是您使用SQL编码的业务逻辑。您还需要在构建模型之前清理数据，记录数据，验证数据，然后实现数据质量检查。</p><p id="3931" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">对于一个数据模型，这可能看起来不多，但当您有大量不同的数据源并继续构建更多的数据模型时，它最终会占用您的大部分时间。特别是，如果您像大多数数据团队一样，等到一切都接近完美时才实施所有这些基本工作。</p><p id="fe25" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">幸运的是，<a class="ae la" rel="noopener" target="_blank" href="/what-is-dbt-a0d91109f7d0"> dbt </a>使得数据建模变得更加容易。而且，dbt提供了许多有用的工具，它们可以直接与dbt集成，为您省去一些麻烦。如果您不熟悉<a class="ae la" rel="noopener" target="_blank" href="/is-dbt-the-future-of-analytics-d6ff93cbb20c"> dbt </a>(或数据构建工具)，它是一个数据转换工具，允许您编写模块化代码并遵循建模最佳实践。你可以在这里阅读更多关于它的<a class="ae la" rel="noopener" target="_blank" href="/what-is-dbt-a0d91109f7d0">。</a></p><p id="d7c7" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这里有一些工具，既有开源的(也有免费的)，也有付费的，我发现它们为我节省了很多时间和精力。不是所有的东西都要由你从头开始建造！外面有一大堆聪明人可能已经帮你做到了。利用这一点。</p><h1 id="bd33" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">re_data数据清理宏</h1><p id="4888" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">re_data是我最喜欢的免费开源dbt包之一。它非常容易安装并集成到您已经存在的dbt项目中。虽然它们有许多令人惊叹的功能，如异常检测和警报，但它们也有预建的dbt宏来帮助您过滤和清理数据。</p><h2 id="3da1" class="mu ly iv bd lz mv mw dn md mx my dp mh lk mz na mj lo nb nc ml ls nd ne mn nf bi translated">复制</h2><p id="fb8b" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">它们有两个不同的过滤器来处理重复值，<strong class="ld iw"> filter_remove_duplicates </strong>和<strong class="ld iw"> filter_get_duplicates。</strong>你可以像使用任何其他dbt宏一样简单地使用它们，并从中进行选择。它们每个都有三个参数——模型名称、唯一列和记录排序所依据的列。<strong class="ld iw"> filter_remove_duplicates </strong>返回一个没有副本的模型，<strong class="ld iw"> filter_get_duplicates </strong>只返回<em class="ng">模型中的副本</em>。</p><pre class="kl km kn ko gt nh ni nj nk aw nl bi"><span id="0cca" class="mu ly iv ni b gy nm nn l no np">select<br/>   user_id,<br/>   name<br/>from {{ re_data.filter_remove_duplicates(ref('users'), ['user_id']['created_at desc']) }} duplicates</span></pre><p id="bf43" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这两种方法都可以节省您的时间，使您不必为了查找或删除重复项而对列进行聚合和分组。这也使得代码更加简洁。</p><h2 id="a368" class="mu ly iv bd lz mv mw dn md mx my dp mh lk mz na mj lo nb nc ml ls nd ne mn nf bi translated">格式化</h2><p id="4f0f" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">re_data还包含三个不同的数据格式化宏，可以用来清理数据-<strong class="ld iw">clean _ additional _ white spaces</strong>、<strong class="ld iw"> clean_blacklist </strong>和<strong class="ld iw">clean _ capital _ words</strong>。</p><p id="9134" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated"><strong class="ld iw">clean _ additional _ white spaces</strong>将您希望清理的列名作为参数，并删除任何空白。</p><pre class="kl km kn ko gt nh ni nj nk aw nl bi"><span id="6fc2" class="mu ly iv ni b gy nm nn l no np">select<br/>    user_id,<br/>    {{ re_data.clean_additional_whitespaces('name') }} as name<br/>from {{ ref('users') }}</span></pre><p id="8d9c" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated"><strong class="ld iw">clean _ capital _ words</strong>还接受一个列名，并将字符串中每个单词的第一个字母大写。这是一个很好的选择，可以用在你的网站上显示的用户名甚至产品名上。</p><p id="018b" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">最后，<strong class="ld iw"> clean_blacklist </strong>用于屏蔽个人信息。如果您没有可用的屏蔽策略，这是对雪花的屏蔽策略的一个很好的替代。在这里，您指定希望屏蔽的列、要查找的单词列表或正则表达式，然后指定一个字符串来替换那些出现的内容。</p><h1 id="1aa4" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">dbt期望</h1><p id="c813" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">dbt expectations是另一个优秀的开源dbt包，可以在您的dbt项目中使用。它包括根据您的期望测试数据输出的宏，因此得名。在dbt项目中已经存在的dbt测试的基础上，向您的数据模型添加测试本质上是更高级的测试。</p><p id="e22b" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这些宏通常测试特定的用例，当您遇到这些用例时，您可以尝试自己编写。与其花几个小时自己编写这些宏，不如浏览库来找到满足您需要的宏。这里有几个我最喜欢用的。</p><h2 id="a8ba" class="mu ly iv bd lz mv mw dn md mx my dp mh lk mz na mj lo nb nc ml ls nd ne mn nf bi translated">期望_列_值_目标_类型</h2><p id="bba4" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">该测试允许您检查列的数据类型。当您想确保所有时间戳列都是同一类型，日期实际上是日期，并且您想在计算中使用的任何列都是整数或浮点数时，这就很方便了。</p><p id="4e57" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我在诸如Google sheets这样容易出现大量人为错误的混乱数据源中最常使用这个测试。这样，我在源头得到通知，而不是我的模型在下游失败。下面是它在我的<code class="fe nq nr ns ni b">src.yml</code>文件中的样子:</p><pre class="kl km kn ko gt nh ni nj nk aw nl bi"><span id="a287" class="mu ly iv ni b gy nm nn l no np">columns:<br/>   - name: campaign_launch_date<br/>     description: "The date the campaign was launched"<br/>     tests:<br/>       - dbt_expectations.expect_column_values_to_be_of_type:<br/>           column_type: date</span></pre><h2 id="62c7" class="mu ly iv bd lz mv mw dn md mx my dp mh lk mz na mj lo nb nc ml ls nd ne mn nf bi translated">expect _ column _ values _ to _ be _ between</h2><p id="1c63" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">对于id引用映射表的列，这个测试非常有用。通常，我们有太多的值，无法在dbt的<code class="fe nq nr ns ni b">accepted_values</code>测试中包含它们。这是一个很好的捷径，可以防止你因为大量的测试而变得不知所措。</p><p id="d8bb" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我经常在<code class="fe nq nr ns ni b">state_id</code>专栏中使用这个测试。我不想写出数字1-50，所以我指定一个范围，如下所示:</p><pre class="kl km kn ko gt nh ni nj nk aw nl bi"><span id="bc28" class="mu ly iv ni b gy nm nn l no np">columns:<br/>   - name: state_id<br/>     description: "The unique identifier of a state"<br/>     tests:<br/>       - dbt_expectations.expect_column_values_to_be_between:<br/>           min_value: 1 # optional parameter<br/>           max_value: 50 # optional parameter<br/>           row_condition: "id is not null" # optional parameter</span></pre><p id="861e" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">如果您想排除空值或任何其他类型的值，这个测试还可以选择行条件。</p><h1 id="7c17" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">数据文件夹</h1><p id="a051" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">Datafold 是一个强大的工具，可以在实际修改代码之前向您展示代码修改的结果。使用Github，它运行您以前的代码以及您在pull请求中所做的更改，然后比较结果数据集。这允许您在合并代码更改之前看到数据将如何变化。</p><p id="b64d" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这对于在实际投入生产之前验证您的代码是否正确以及数据看起来是否符合预期非常有帮助。我们都知道当某样东西停产时会是多么可怕的一场噩梦。您需要返回并找到问题的根源，恢复到旧版本的代码，并重新部署它。当您可以首先使用Datafold这样的工具来帮助防止这种情况发生时，为什么还要担心这样做呢？</p><p id="d5bb" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">为了实现Datafold，您需要三样东西:一个带有两个分支的Github repo、一个您选择的数据仓库和一些dbt模型。这些都可以很容易地与工具集成，以便从中获益。你可以点击了解更多关于设置过程的细节。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi nt"><img src="../Images/cf95ea2a6f3538fb7c6a19feba88124d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0F2cxVNjgqZ0WdtI"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</p></figure><p id="7666" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在这里，您还可以看到关键指标，如不匹配的列、不同的主键、空主键和总的差值。我们希望通过运行查询来手动检查的所有指标！</p><p id="1d12" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">Datafold节省了我们作为分析工程师的大量时间，因为它还告诉我们数据集中不匹配的确切行。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi nu"><img src="../Images/565bc91b5ffbfd30de8240d28af343a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1bxJqMHBl_3EVAZb"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</p></figure><p id="ae8b" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">它向我们显示了受代码更改影响的每个下游表的信息。如果整个表中的不同值是意料之中的，我们可以合并我们的代码而不用担心。不需要手动验证和一堆聚合查询。Datafold以一种易于查看和深入研究的方式显示关键数据质量指标。</p><p id="e5b7" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">如果你正在寻找一个开源选项，他们也有一个免费的命令行工具和python库，名为<a class="ae la" href="https://www.datafold.com/open-source-data-diff?exp_id=7" rel="noopener ugc nofollow" target="_blank"> data-diff </a>。这将使用主键比较两个不同数据源中的数据行。它显示了哪些行出现在一个表中而没有出现在另一个表中，以及哪些行的值不匹配。尽管在数据复制发生之前，您无法做到这一点，但在某些用例中，它仍然是一个节省了我大量验证时间的工具。</p><h1 id="432e" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">小脚轮</h1><p id="130f" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated"><a class="ae la" href="https://www.castordoc.com/" rel="noopener ugc nofollow" target="_blank"> Castor </a>是一个自动化的数据目录工具，它通过<a class="ae la" rel="noopener" target="_blank" href="/data-documentation-best-practices-3e1a97cfeda6">文档</a>和协作为你的数据栈的所有部分带来透明度。它有助于告诉您组织中的用户某些数据源的位置、它们的质量状态，以及在您有问题时应该联系谁。它与您的dbt文档集成，将您已经记录的所有内容直接填充到工具中。</p><p id="b8bf" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我最喜欢的特性之一是自动填充已经定义的数据列。我无法告诉你我花了多少时间将相同的列定义从一个<code class="fe nq nr ns ni b">src.yml</code>文件复制并粘贴到另一个文件。Castor获取这些定义，并为相同列名的每个实例填充它们，消除了重复的手工工作。是啊！你真的不必跨多个模型定义<code class="fe nq nr ns ni b">user_id</code> 50个不同的时间！</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi nu"><img src="../Images/13bad4e1a7ea8b8f737de2b2ada8db73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3tqwHu3lez0bBeSW"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">从dbt到元数据库的列沿袭(作者图片)</p></figure><p id="7b0b" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">Castor还为整个现代数据栈中的dbt数据模型提供了列级沿袭。这意味着您可以看到从您的数据仓库到您的仪表板的每一列的数据源。这允许您更好地处理数据模型之间的依赖关系，并看到小代码更改的潜在下游影响。我亲自修改了我的基本模型中的列名，以为它不会影响任何东西，结果第二天发现它破坏了整个生产模型。有了列级谱系图，您不必担心这是一个问题。</p><h1 id="7af4" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">dbt新鲜度测试</h1><p id="a7b2" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">最后，dbt有内置的测试，允许您检查源数据和数据模型的新鲜度。当数据集没有按预期更新时，刷新测试有助于提醒您。当在源位置完成时，这将有助于防止下游问题，例如陈旧的数据模型。积极主动地进行这些类型的数据质量检查将节省您调试和修复损坏管道的时间。</p><p id="0c05" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">要向dbt项目添加一个新鲜度测试，只需在<code class="fe nq nr ns ni b">src.yml</code>文件中的源代码或模型名称下添加一个<code class="fe nq nr ns ni b">freshness</code>块。然后包括两个字段:<code class="fe nq nr ns ni b">warn_after</code>和<code class="fe nq nr ns ni b">error_after</code>。<code class="fe nq nr ns ni b">warn_after</code>指的是一个源或模型在向你发出警告之前没有新数据的时间段。这个<strong class="ld iw">不会让</strong>测试失败。<code class="fe nq nr ns ni b">error_after</code>指源或模型在失败前没有新数据的时间段。这个<strong class="ld iw">会让</strong>无法通过你的测试。</p><pre class="kl km kn ko gt nh ni nj nk aw nl bi"><span id="eb24" class="mu ly iv ni b gy nm nn l no np">sources:<br/>  - name: users<br/>    freshness:<br/>      warn_after:<br/>        count: 3<br/>        period: day<br/>      error_after:<br/>        count: 5<br/>        period: day</span></pre><p id="c807" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">请记住，您可以选择<code class="fe nq nr ns ni b">minute</code>、<code class="fe nq nr ns ni b">hour</code>或<code class="fe nq nr ns ni b">day</code>作为您的时间段。就我个人而言，我的数据管道通常每天只运行一次，所以<code class="fe nq nr ns ni b">day</code>时期对我来说最有意义。</p><h1 id="46ed" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">结论</h1><p id="07cc" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">dbt是一个强大的工具，可以无缝地进行数据转换。更好的是，它与其他强大的工具相集成，可以帮助您节省数据清理、验证代码更改、记录数据源和调试数据管道等任务的时间。总之，这套工具将帮助你成为一名高效而全面的<a class="ae la" rel="noopener" target="_blank" href="/analytics-engineer-the-newest-data-career-role-b312a73d57d7">分析工程师</a>来编写高质量的代码。</p><p id="f588" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">欲了解更多关于分析工程和现代数据堆栈工具的信息，请<a class="ae la" href="https://madisonmae.substack.com/" rel="noopener ugc nofollow" target="_blank">订阅</a>我的每周简讯。</p><p id="df59" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">看看我的第一本电子书，<a class="ae la" href="https://madisonmae.gumroad.com/l/learnanalyticsengineering" rel="noopener ugc nofollow" target="_blank">分析工程基础知识</a>，一本全方位的分析工程入门指南。</p></div></div>    
</body>
</html>