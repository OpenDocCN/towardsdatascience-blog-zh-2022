<html>
<head>
<title>3 Unique Python Packages for Time Series Forecasting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于时间序列预测的3个独特的Python包</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3-unique-python-packages-for-time-series-forecasting-2926a09aaf5b#2022-09-13">https://towardsdatascience.com/3-unique-python-packages-for-time-series-forecasting-2926a09aaf5b#2022-09-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a49c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">您可以添加到您的武器库中的一些时间系列包</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/399965c7b8d1bd45412322000dc2ad5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eiNbYu5nM5FBvzRW"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">拉尔夫·哈特在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="71de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时间序列预测是统计领域中的一种方法，用于分析具有时间成分的历史数据，并基于该数据创建预测。</p><p id="8f22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时间序列预测方法的一些经典例子是移动平均、ARIMA和指数平滑。这些方法已经使用了很长时间，现在仍然有用，因为用户很容易解释结果——尽管预测不太准确。</p><p id="f82b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反过来，许多机器学习驱动的预测是通过牺牲一些可解释性和提高准确性来开发的，如<a class="ae ky" href="https://facebook.github.io/prophet/" rel="noopener ugc nofollow" target="_blank">预言家</a>和<a class="ae ky" href="https://facebookresearch.github.io/Kats/" rel="noopener ugc nofollow" target="_blank"> Kats </a>。</p><p id="fb80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论您需要经典方法还是机器学习驱动的模型，许多人都开发了Python包来访问所有这些方法。一些著名的包有<a class="ae ky" href="https://www.statsmodels.org/stable/tsa.html" rel="noopener ugc nofollow" target="_blank"> Statsmodel </a>、<a class="ae ky" href="https://alkaline-ml.com/pmdarima/" rel="noopener ugc nofollow" target="_blank"> pmdarima </a>和<a class="ae ky" href="https://www.sktime.org/en/stable/" rel="noopener ugc nofollow" target="_blank"> sktime </a>。然而，预测模型不仅限于我上面列出的那些，因为许多伟大的软件包都值得考虑。</p><p id="024f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么本文将介绍我的3个独特的用于时间序列预测的Python包。让我们开始吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fc3f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.统计预测</h1><p id="32f7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://github.com/Nixtla/statsforecast" rel="noopener ugc nofollow" target="_blank"> StatsForecast </a>是一个Python包，它提供了一组<a class="ae ky" href="https://itl.nist.gov/div898/handbook/pmc/section4/pmc44.htm" rel="noopener ugc nofollow" target="_blank">单变量</a>时间序列预测模型。StatsForecast的独特之处在于，该模型提供了快速训练，并针对高精度模型进行了优化。此外，该软件包提供了几个基准，我们可以在训练各种模型时使用。</p><p id="dde3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试用一下这个包，感受一下它。首先，我们需要安装StatsForecast包。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ffa3" class="ne md it na b gy nf ng l nh ni">pip install statsforecast</span></pre><p id="ae92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于演示目的，我将使用从StatsForecast生成的合成数据。使用下面的代码，我将获得每月记录的合成数据。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="80ce" class="ne md it na b gy nf ng l nh ni">from statsforecast.utils import generate_series</span><span id="2527" class="ne md it na b gy nj ng l nh ni">synthetic_panel = generate_series(n_series=1, freq = 'M')</span><span id="ce0c" class="ne md it na b gy nj ng l nh ni">synthetic_panel.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/53607282256d474eded40c2b50ecfb9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*ii0g9Sz0cM-ofp3CIHwTUQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="633f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据集包含一个日期特征(“ds”)和我们要预测的数字特征(“y”)。此外，根据StatsForecast，该指数具有“唯一id”指数，这将提高训练速度。</p><p id="ce3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我会将数据集分成训练数据和测试数据。我将最后6次观察作为测试数据，其余的作为训练数据。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="03ac" class="ne md it na b gy nf ng l nh ni">Y_train_df = synthetic_panel[:-6]<br/>Y_test_df = synthetic_panel[-6:]</span></pre><p id="a6ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">准备好数据集后，我们可以尝试开发我们的预测模型。第一步是导入我们想要使用的模型。在我们的例子中，我们将使用AutoARIMA(带自动参数训练的ARIMA模型)和指数平滑(ETS)。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="0d55" class="ne md it na b gy nf ng l nh ni">from statsforecast import StatsForecast<br/>from statsforecast.models import AutoARIMA, ETS</span></pre><p id="2d88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将建立模型并向模型传递一些参数。我们要传递的参数是季节长度(使用12，因为一年有12个月)，以及ets的“ZMZ”模型，以便对模型进行优化调整。此外，我设置了horizon变量作为我们预测的长度。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="abdd" class="ne md it na b gy nf ng l nh ni">season_length = 12</span><span id="aa4c" class="ne md it na b gy nj ng l nh ni">horizon = len(Y_test_df)</span><span id="3aa0" class="ne md it na b gy nj ng l nh ni">models = [<br/>AutoARIMA(season_length=season_length),<br/>ETS(season_length=season_length, model='ZMZ')<br/>]</span><span id="cb5a" class="ne md it na b gy nj ng l nh ni">model = StatsForecast(<br/>df=Y_train_df,<br/>models=models,<br/>freq='M',<br/>n_jobs=-1)</span></pre><p id="8efb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">StatsForecast的优点是可以在一行中直接测试各种模型。我们只需要决定我们想要使用什么样的预测模型，我们可以通过下面的代码轻松获得所有的预测。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="bed2" class="ne md it na b gy nf ng l nh ni">%time</span><span id="3910" class="ne md it na b gy nj ng l nh ni">Y_hat_df = model.forecast(horizon).reset_index()<br/>Y_hat_df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/92e7780dbb0bf7a6316b37ce14330632.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*aZ9OlZ25Op8NczcK-klRyQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="72a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">StatsForecast自诩训练时间快，从上图可以看出预测时间。我们的预测花了很短的时间。那么，我们的预测有多准确呢？让我们用时间图来看看。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="aabe" class="ne md it na b gy nf ng l nh ni">fig, ax = plt.subplots(1, 1, figsize = (20, 7))</span><span id="e56a" class="ne md it na b gy nj ng l nh ni">Y_hat_df = Y_test_df.merge(Y_hat_df, how='left', on=['unique_id', 'ds'])</span><span id="88e0" class="ne md it na b gy nj ng l nh ni">plot_df = pd.concat([Y_train_df, Y_hat_df]).set_index('ds')<br/>plot_df[['y', 'AutoARIMA', 'ETS']].plot(ax=ax, linewidth=2)</span><span id="3378" class="ne md it na b gy nj ng l nh ni">ax.set_title('Forecast Synthetic Data', fontsize=22)<br/>ax.set_ylabel('Number', fontsize=20)<br/>ax.set_xlabel('Timestamp [t]', fontsize=20)<br/>ax.legend(prop={'size': 15})<br/>ax.grid()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/d2b14675bd694808f76ddce0619e228f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZXiSR8gCStgSHEnUC04B5g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="e519" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上图可以看出，预测数据模式足够接近实际数据。这两种预测都会导致与实际情况重叠的预测。</p><p id="4d59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以用StatsForecast尝试很多模型；建议你来访问这个<a class="ae ky" href="https://nixtla.github.io/statsforecast/models.html" rel="noopener ugc nofollow" target="_blank">页面</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7241" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.PyAF</h1><p id="b01f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://github.com/antoinecarme/pyaf" rel="noopener ugc nofollow" target="_blank"> PyAF </a>或Python Automatic Forecasting是一个开源的Python包，用于自动开发时间序列预测模型(单变量或外生数据)。该模型是在Scikit-Learn和Pandas的基础上构建的，因此可以期待熟悉的API。该软件包还提供了各种模型，尽可能在几行中使用。</p><p id="2132" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用之前的数据集来试试PyAF包。首先，我们需要安装软件包。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="1a73" class="ne md it na b gy nf ng l nh ni">pip install pyaf</span></pre><p id="43f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们可以使用以前的数据来开发我们的PyAF预测模型。让我们用下面的代码试试自动预测引擎。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4512" class="ne md it na b gy nf ng l nh ni">horizon = len(Y_test_df)</span><span id="ed9a" class="ne md it na b gy nj ng l nh ni">import pyaf.ForecastEngine as autof</span><span id="1d63" class="ne md it na b gy nj ng l nh ni">#set up the model engine<br/>lEngine = autof.cForecastEngine()</span><span id="eb91" class="ne md it na b gy nj ng l nh ni"># get the best time series model for test prediction<br/>lEngine.train(iInputDS = Y_train_df, iTime = 'ds', iSignal = 'y', iHorizon = horizon)</span></pre><p id="96b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们试着看一下预测数据。我们可以使用下面的代码来获取预测。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4be2" class="ne md it na b gy nf ng l nh ni">forecast_df= lEngine.forecast(Y_train_df, horizon)</span></pre><p id="c47e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">预测结果将是我们当前和预测数据的数据框架。此外，每个预测结果都有如此多的信息，我们可以用来评估我们的模型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/09374143045f70483480bdb2d46ab5f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*68h2jW1RpEZWC5-sXQwnsw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="6957" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们只获取关键信息，并进行视觉比较。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="203a" class="ne md it na b gy nf ng l nh ni">forecast_df.plot.line('ds', ['y' , 'y_Forecast','y_Forecast_Lower_Bound', 'y_Forecast_Upper_Bound'], grid = True, figsize=(12, 8))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/11086b209332a033fefb2190c4e86a80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zS5Euca38YPzju6e0utHBQ.png"/></div></div></figure><p id="715b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">预测相当不错，如上图所示，预测数据和实际数据重叠。此外，上限和下限足够小，可以表示模型的可信度。我们可以通过使用外源数据来改进模型，你可以尝试使用下面的<a class="ae ky" href="https://github.com/antoinecarme/pyaf/blob/master/docs/PyAF_Exogenous.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本教程</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1862" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.神经营养细胞</h1><p id="a906" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://neuralprophet.com/" rel="noopener ugc nofollow" target="_blank"> NeuralProphet </a>是一个Python包，用于开发基于<a class="ae ky" href="https://github.com/facebook/prophet" rel="noopener ugc nofollow" target="_blank">脸书预言家</a>的时间序列模型，但具有神经网络架构。这个包基于PyTorch，可以很容易地使用尽可能少的代码行。</p><p id="dbc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从安装包开始。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a6c0" class="ne md it na b gy nf ng l nh ni">pip install neuralprophet</span></pre><p id="c1f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想在Jupyter笔记本中实现交互式可视化，我们可以使用下面的代码来安装它。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c945" class="ne md it na b gy nf ng l nh ni">pip install neuralprophet[live]</span></pre><p id="f350" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从初始化模型开始。对于这个例子，我们使用与上一个相同的数据集。此外，为了使事情更容易，我将删除数据索引。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="6d0b" class="ne md it na b gy nf ng l nh ni">train = Y_train_df.reset_index(drop = True)<br/>test = Y_test_df.reset_index(drop = True)</span></pre><p id="ecfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将启动神经先知模型。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="dc42" class="ne md it na b gy nf ng l nh ni">from neuralprophet import NeuralProphet<br/>m = NeuralProphet()</span></pre><p id="ffdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将使用下面的代码来训练模型。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7fe9" class="ne md it na b gy nf ng l nh ni">metrics = m.fit(train, freq='M', validation_df=Y_test_df, progress='plot')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/c7a3d773c7cc7ae531d1017d3f0bf5f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*73T3JWJMZtoCIU4nKLgH4w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="1930" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该模型将自动递归训练数据，并在默认纪元后停止(您可以设置您的纪元)。要查看最终的指标，我们可以使用下面的代码。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="adf1" class="ne md it na b gy nf ng l nh ni">metrics.tail(1)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/6ba8ea3a9b9a50246ea1596d4bed24d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*UFJXDcfUVxOFMiT7n5dfAw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="2078" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以尝试使用该模型来直观地预测和比较当前的训练数据。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="eec5" class="ne md it na b gy nf ng l nh ni">forecast = m.predict(train)<br/>fig = m.plot(forecast)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/bfe97a6d7de0e79d67e2ffca3f92f3b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RWR5zp88QNHlqTd6Oc0A5g.png"/></div></div></figure><p id="d2a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的图我们可以看出，预测和实际数据点比较接近。我们试着和测试数据对比一下。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3561" class="ne md it na b gy nf ng l nh ni">forecast = m.predict(test)<br/>m = m.highlight_nth_step_ahead_of_each_forecast(1)<br/>fig = m.plot(forecast)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/1cd3ea68ec4c0c242903c8531df159ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-d2ACtYHlqohSTfMBezUEA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8a22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在上面的图像中看到，预测与实际数据相当接近。仍然有一些误差可以通过进一步的预测模型开发来修正。</p><p id="a011" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与Prophet类似，我们可以使用下面的代码获取NeuralProphet预测组件。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="0b03" class="ne md it na b gy nf ng l nh ni">fig_param = m.plot_parameters()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/af583d519cbd334a60dc5cdd0fbd9058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GzwXhe7gEpQ5GPNveCdNHA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="2055" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分解将显示我们的训练数据的趋势和季节性，这对我们的洞察力也是至关重要的。</p><p id="1469" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">撰写本文时，NeuralProphet包仍处于测试阶段，因此可以期待该包的许多新开发，尤其是增加预测能力。要了解他们的发展时间表，您可以点击查看<a class="ae ky" href="https://github.com/ourownstory/neural_prophet/blob/main/notes/development_timeline.md" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0629" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="44a2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">时间序列预测是一种基于历史时间数据(例如，天气或人数)预测未来值的方法。</p><p id="4ce6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多Python包是为时间序列预测开发的，但我想在本文中展示一些更独特的包。它们是:</p><ol class=""><li id="e982" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated">统计预测</li><li id="9a45" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">PyAF</li><li id="70c2" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">神经营养细胞</li></ol><p id="fcc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望有帮助！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><blockquote class="og oh oi"><p id="bdf0" class="kz la oj lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated"><em class="it">访问我的</em> <a class="ae ky" href="https://bio.link/cornelli" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="it">社交媒体</em></strong></a><strong class="lb iu"><em class="it"/></strong><em class="it">进行更深入的交谈或有任何问题。</em></p></blockquote><blockquote class="on"><p id="3103" class="oo op it bd oq or os ot ou ov ow lu dk translated"><em class="ox">如果您不是作为中等会员订阅，请考虑通过</em> <a class="ae ky" href="https://cornelliusyudhawijaya.medium.com/membership" rel="noopener"> <em class="ox">我的推荐</em> </a> <em class="ox">订阅。</em></p></blockquote></div></div>    
</body>
</html>