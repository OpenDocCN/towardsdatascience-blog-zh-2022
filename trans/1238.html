<html>
<head>
<title>RGB Color Image Compression Using Principal Component Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于主成分分析的 RGB 彩色图像压缩</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/rgb-color-image-compression-using-principal-component-analysis-fce3f48dfdd0#2022-03-29">https://towardsdatascience.com/rgb-color-image-compression-using-principal-component-analysis-fce3f48dfdd0#2022-03-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7481" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">主成分分析在降维中的应用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c5b3bc7a9f092223c2d8192cb1f1787e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xYSObBUB6Z9da_6tLPyfSQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">(图片作者)</strong></p></figure><p id="88a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之前，我们已经讨论了如何使用 PCA 来压缩 MNIST 数字数据集中的灰度图像。你可以在这里阅读那篇文章<a class="ae lv" rel="noopener" target="_blank" href="/image-compression-using-principal-component-analysis-pca-253f26740a9f"/>。</p><p id="b5c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是之前发表文章的高级版本。这一次，我们应用相同的概念来压缩 RGB 彩色图像，而不是灰度图像。</p><h1 id="961e" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">RGB 和灰度图像的区别</h1><p id="b28b" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">RGB 和灰度图像之间的主要区别在于图像拥有的颜色通道数量。RGB 图像有三个颜色通道:红色、绿色和蓝色，而灰度图像只有一个颜色通道。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/307ca2f77650ff6cbb0ed5f51bd9d7b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*klUWFnFXWX4cERE__zm7Cw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">RGB 图像的红、绿、蓝三色通道</strong>(图片由作者提供)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/0ce8b64162eb5553c3a65abba9343ae9.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*7T2PDTO19VA1vHzP4MnNGg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">灰度图像的单色通道</strong>(图片由作者提供)</p></figure><p id="dfbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个区别是用 ML 和 DL 表示 RGB 和灰度图像。灰度图像由二维(2D) NumPy 数组表示。它也可以用一个扁平的一维(1D) NumPy 数组来表示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/1f7bd467c6f851ec1d3b04677524aac6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*DBe5PSZ-0L7koc4g2uSNjw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">展平灰度</strong> <strong class="bd ky">图像</strong>(图片由作者提供)</p></figure><p id="b45c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">RGB <em class="mw"> </em>图像由三维(3D) NumPy 阵列表示。由于 RGB 图像中有三个颜色通道，我们需要一个额外的维度来表示颜色通道。拼合 RGB 图像不好，因为它会丢失大量重要信息。</p><p id="79db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注:</strong>要通过例子和其他图像基础知识了解更多 RGB 和灰度图像的区别，请参考我写的以下文章。</p><ul class=""><li id="1ed5" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated"><a class="ae lv" rel="noopener" target="_blank" href="/exploring-the-mnist-digits-dataset-7ff62631766a">RGB 和灰度图像如何在 NumPy 阵列中表示</a></li><li id="04dc" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><a class="ae lv" href="https://rukshanpramoditha.medium.com/real-world-examples-of-0d-1d-2d-3d-4d-and-5d-tensors-100b0837ced4" rel="noopener">0D、1D、2D、3D、4D 和 5D 张量的真实世界示例</a></li></ul><h1 id="21fe" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">降维图像压缩的基本思想</h1><p id="b5a4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">图像压缩是一种在尽可能保持图像质量的同时最小化图像字节大小的技术。它适用于降低图像在存储和传输时的成本。</p><p id="abfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">维度缩减是减少数据集中的要素(变量)数量，同时尽可能保留原始数据中的方差的过程。</p><p id="c65d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PCA 是可用于压缩图像的降维技术之一。这里有一个大概的想法。</p><h2 id="3e4d" class="nl lx it bd ly nm nn dn mc no np dp mg li nq nr mi lm ns nt mk lq nu nv mm nw bi translated">压缩灰度图像</h2><p id="011c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">处理灰度图像非常容易，因为它们只包含一个颜色通道。灰度图像由二维(2D) NumPy 数组表示。我们将该阵列作为我们的 2D 数据矩阵，并应用 PCA 来减少矩阵中的列(特征)数量。根据我们选择保留的组件数量，我们会损失一些图像质量。</p><h2 id="c6eb" class="nl lx it bd ly nm nn dn mc no np dp mg li nq nr mi lm ns nt mk lq nu nv mm nw bi translated">压缩 RGB 图像</h2><p id="ae3b" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">处理 RGB 图像并不容易，因为它们包含三个颜色通道。RGB <em class="mw"> </em>图像由三维(3D) NumPy 阵列表示。我们不能用 3D 阵列做 PCA。所以，我们必须将原始图像分割成红色、绿色和蓝色通道。每个颜色通道由二维(2D) NumPy 数组表示。然后，我们对每个通道进行主成分分析，最后合并三个通道得到压缩图像。</p><p id="2bd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们从每个通道数据中损失 3%的变化，合并三个颜色通道后我们损失的总变化将是:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="1e33" class="nl lx it ny b gy oc od l oe of">(3 + 3 + 3)% = 9%</span></pre><p id="7489" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大约会损失 9%的图像质量。这不是一个重要的质量。</p><h1 id="a49f" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">一个压缩 RGB 图像的真实例子</h1><h2 id="8a44" class="nl lx it bd ly nm nn dn mc no np dp mg li nq nr mi lm ns nt mk lq nu nv mm nw bi translated">关于我们使用的图像</h2><p id="f877" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们使用下图来解释如何应用 PCA 来压缩 RGB 图像。下面的图片是我在母亲的花园里捕捉到的。出于教育目的，可以免费下载。所以，请随意<a class="ae lv" href="https://drive.google.com/file/d/1P-mHCv7CYnbQQ0Jx23wqiU9Cl3WLP-fv/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">下载图片</a>来练习我们今天讨论的内容。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/2737754af99a7fc4729e4b8a159fc088.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*BgPS-cTyC8KeKFJQrUrSag.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky"> Flower.jpg:我们今天使用的图片</strong>(作者图片，取自我母亲的花园)</p></figure><h2 id="42dd" class="nl lx it bd ly nm nn dn mc no np dp mg li nq nr mi lm ns nt mk lq nu nv mm nw bi translated">加载图像</h2><p id="dc90" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">让我们使用 matplotlib <strong class="lb iu"> imread() </strong>函数加载图像，假设它保存在当前工作目录中。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="a598" class="nl lx it ny b gy oc od l oe of">import matplotlib.pyplot as plt</span><span id="2c42" class="nl lx it ny b gy oh od l oe of">RGB_img = plt.imread("Flower.jpg")</span></pre><p id="1e5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面我们来检查一下。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="0c25" class="nl lx it ny b gy oc od l oe of">print(type(RGB_img))<br/>print(RGB_img.shape)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/39d4f702160a599678c572590f7f37ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:476/format:webp/1*Sj6USLaOQ35IA_cqdDQNCg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="268f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的图像存储在 3D NumPy 数组中。它有 400 x 400 像素和 3 个颜色通道。</p><h2 id="37fd" class="nl lx it bd ly nm nn dn mc no np dp mg li nq nr mi lm ns nt mk lq nu nv mm nw bi translated">显示图像</h2><p id="bf6e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在，我们以原始大小显示图像。为此，我们使用 matplotlib <strong class="lb iu"> imshow() </strong>函数。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="7e55" class="nl lx it ny b gy oc od l oe of">plt.figure(figsize=[7.3, 7.3])<br/>plt.imshow(RGB_img)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/b7b2f519e14a2d935c04f51602729eb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*BRIjaVcg51dMY-iu4KQ-EA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">原花图</strong>(图片由作者提供)</p></figure><h2 id="9edc" class="nl lx it bd ly nm nn dn mc no np dp mg li nq nr mi lm ns nt mk lq nu nv mm nw bi translated">将图像分割成颜色通道</h2><p id="8677" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">然后，我们将原始图像分成红色、绿色和蓝色通道。为此，我们使用 OpenCV <strong class="lb iu"> split() </strong>函数。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="517b" class="nl lx it ny b gy oc od l oe of">import cv2</span><span id="35ad" class="nl lx it ny b gy oh od l oe of">b, g, r = cv2.split(RGB_img)</span></pre><p id="b83b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，RGB 颜色通道在 OpenCV 中以相反的顺序存储。这就是为什么我们将变量声明为<code class="fe ok ol om ny b">b, g, r</code>而不是<code class="fe ok ol om ny b">r, g, b</code>。</p><p id="e64c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面我们来检查一下。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="6f9f" class="nl lx it ny b gy oc od l oe of">print("Red channel")<br/>print(type(r))<br/>print(r.shape)<br/>print("\nGreen channel")<br/>print(type(g))<br/>print(g.shape)<br/>print("\nBlue channel")<br/>print(type(b))<br/>print(b.shape)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/36f03d554e8904b29ba7f9c05778c4f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/1*mKSB3cWEY5vldC2gW542mQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="f81f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个颜色通道由一个 2D 数字阵列表示。每个通道的高度 x 宽度为 400 x 400。这意味着数组包含 400 行和 400 列(变量)。在这个上下文中，每个通道数据的维数是 400，因为有 400 列。我们应用主成分分析来减少这些列的数量。</p><h2 id="9b51" class="nl lx it bd ly nm nn dn mc no np dp mg li nq nr mi lm ns nt mk lq nu nv mm nw bi translated">显示颜色通道</h2><p id="f88b" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在，我们展示红色通道。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="6286" class="nl lx it ny b gy oc od l oe of">plt.figure(figsize=[7.3, 7.3])<br/>plt.imshow(r)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/f776d4a3f5e20c3684a1fad7ab582324.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*ZnegrFG3GBGmBp0F0HJu7w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">花图像的红色通道</strong>(图片由作者提供)</p></figure><p id="5029" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们也可以显示其他两个颜色通道。然而，我不打算在这里展示它们。</p><h2 id="24e7" class="nl lx it bd ly nm nn dn mc no np dp mg li nq nr mi lm ns nt mk lq nu nv mm nw bi translated">应用 PCA</h2><p id="6835" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在，我们应用主成分分析。</p><p id="1015" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们通过使用 Scikit-learn <strong class="lb iu"> PCA() </strong>函数来应用 PCA。在应用 PCA 之前必须进行特征缩放，因为 PCA 方向对特征的相对范围非常敏感。作为可选部分，我将向您展示在应用 PCA 时进行特征缩放的重要性。</p><p id="f743" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通常使用 sci kit-learn<strong class="lb iu">standard scaler()</strong>函数进行特征缩放。然而，在这个例子中，我们使用下面的简单方法进行特征缩放。这是因为每个图像像素值由范围从 0 到 255(包括 0 和 255)的数字表示。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="c621" class="nl lx it ny b gy oc od l oe of">#(0, 255)/255 ~ (0, 1)</span><span id="e91a" class="nl lx it ny b gy oh od l oe of">r_scaled = r / 255<br/>g_scaled = g / 255<br/>b_scaled = b / 255</span></pre><p id="d10a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将对红色通道数据运行<strong class="lb iu"> PCA() </strong>函数。这里，临界超参数是<strong class="lb iu"> n_components </strong>。首先，最好将其设置为<code class="fe ok ol om ny b">None</code>，这样 PCA()函数将保留所有组件(本例中为 400)。但是，我会将其设置为<code class="fe ok ol om ny b">n_components=100</code>并创建以下类型的图，帮助我们为<strong class="lb iu"> n_components </strong>确定正确的整数值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">对红色通道数据应用 PCA</strong>(作者代码)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/a2509989c07386d5b4072a536ae4550f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*GKycTGovV-kYzFd7TzlBdw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">可视化组件的最佳数量</strong>(图片由作者提供)</p></figure><p id="6366" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最高的条显示红色通道数据的最重要组成部分。从上面的图中，只有前 25 到 45 个组件捕获了大部分数据。如果我们忽略 45 岁以后的所有成分，我们将只丢失很少的信息，因为它们在数据中捕捉到非常少量的变化。</p><p id="9173" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这同样适用于其他颜色通道的数据。因此，我们用<code class="fe ok ol om ny b">n_components=40</code>和<code class="fe ok ol om ny b">n_components=25</code>对每个颜色通道数据进行 PCA。在每种情况下，维度将分别减少 10 倍(400/40)和 16 倍(400/25)。</p><p id="023d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">当</strong>当<code class="fe ok ol om ny b"><strong class="lb iu">n_components=40</strong></code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">对 n_components=40 的 RGB 颜色通道应用 PCA</strong>(作者代码<strong class="ak"> </strong>)</p></figure><p id="0c53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们检查以下内容。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(作者代码<strong class="ak"> </strong></p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/d7942659a7e480040ecb64e78cd1c4a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*3hjs-Ap3jyUUYT6H_aq0pw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="9417" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可变性损失的总量可通过下式计算:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="e8b8" class="nl lx it ny b gy oc od l oe of">{(100-97.52) + (100-96.55) + (100-97.17)}% = 8.76%</span></pre><p id="d5d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">压缩后的图像将损失原始图像质量的 8.76%。</p><p id="19f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们运行下面的代码将图像数据恢复到它的原始维度，以便可视化。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="4ba0" class="nl lx it ny b gy oc od l oe of">pca_r_org = pca_r.inverse_transform(pca_r_trans)<br/>pca_g_org = pca_g.inverse_transform(pca_g_trans)<br/>pca_b_org = pca_b.inverse_transform(pca_b_trans)</span></pre><p id="3124" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们使用 OpenCV <strong class="lb iu"> merge() </strong>函数将三个颜色通道合并成一个 3D NumPy 数组。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="6852" class="nl lx it ny b gy oc od l oe of">img_compressed = cv2.merge((pca_b_org, pca_g_org, pca_r_org))</span></pre><p id="fec1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们展示压缩的图像。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="d5b4" class="nl lx it ny b gy oc od l oe of">plt.figure(figsize=[7.3, 7.3])<br/>plt.imshow(img_compressed)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/e09a1420b3ad9626db8ed6fefa3b9732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*zvwI6YpGhPTGTB5g_rL-UQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">n _ components = 40 的压缩花图像</strong>(图片由作者提供)</p></figure><p id="029d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使在压缩之后，我们仍然可以识别图像的重要部分。但是，维度降低了 10 倍！</p><p id="1044" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">当</strong>时<code class="fe ok ol om ny b"><strong class="lb iu">n_components=25</strong></code></p><p id="f106" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，程序与前面的相同。因此，我不会向您展示代码。我只给你看用<code class="fe ok ol om ny b">n_components=25</code>应用 PCA 后的最终输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/e8657ca46d88f3e9b12003f35454faee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*MoWq2SlBCP6ekhLFg0DrZA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">n _ components = 25 的压缩花朵图像</strong>(图片由作者提供)</p></figure><p id="8542" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们仍然可以识别图像的重要部分。但是，维数降低了 16 倍！</p><h1 id="2a1a" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">特征缩放的重要性(可选)</h1><p id="d694" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">作为可选部分，我将向您展示在我们对数据集应用 PCA 时进行要素缩放的重要性。这里，我们使用 Scikit-learn PCA()函数来应用 PCA。PCA()函数使用协方差矩阵进行奇异值分解。图像数据中特征的相对范围也显著不同。因此，我们需要在应用 PCA 之前对特征进行标准化。</p><p id="b2a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图显示了在不执行 PCA 的情况下应用 PCA 后的输出。即使我们设置了<code class="fe ok ol om ny b">n_components=100</code>，转换后的数据也不能代表原始数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/f052f2ebffecc554ac79312b241d12ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*8ea3Y8UEMevnnAXRTBPIbA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">应用 PCA 后输出图像，不进行特征缩放</strong>(图片由作者提供)</p></figure><p id="c8e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PCA 方向对特征的相对范围高度敏感。如果我们没有在相同的尺度上获得所有的特征，PCA 优先考虑由于特征的相对范围而产生的方差，而不是在搜索主成分时数据中存在的真实方差。因此，这些主成分不能代表原始数据。这就是为什么上面的图像不能显示原始的花。</p><h1 id="8817" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">摘要</h1><p id="7e08" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在，考虑下面的图像网格。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/bd15e5454e3da0e48167de29b0e19699.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*kboP0Xa3sKSoIDmttvvK1Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">花卉图像对比</strong>(图片由作者提供)</p></figure><ul class=""><li id="c8a3" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated"><strong class="lb iu">左上:</strong>400 维的原始花卉图像。</li><li id="feb2" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><strong class="lb iu">右上:</strong>只有 40 维的压缩花图像。维数减少了 10 倍，同时保持了原始图像 91.24%的质量！我们仍然可以识别图像中的重要部分。</li><li id="b420" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><strong class="lb iu">左下:</strong>只有 25 维的压缩花图像。维数减少了 16 倍，同时保持了原始图像 83.41%的质量！我们仍然可以识别图像中的重要部分。</li><li id="3d92" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><strong class="lb iu">右下:</strong>不做特征缩放应用 PCA 后的花朵图像输出。转换后的数据不能代表原始数据。我在这里向您展示了在应用 PCA 之前进行特征缩放的重要性。</li></ul></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><p id="5cc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天的文章到此结束。如果你对这篇文章有任何疑问，请在评论区告诉我。</p><p id="1a3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p><p id="9361" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一篇文章再见！一如既往，祝大家学习愉快！</p></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><h2 id="7157" class="nl lx it bd ly nm nn dn mc no np dp mg li nq nr mi lm ns nt mk lq nu nv mm nw bi translated">阅读下一篇(推荐)</h2><p id="c2b0" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated"><em class="mw">主成分分析—回答 18 个问题(关于主成分分析的大多数问题的一站式解决方案)</em></p><div class="pa pb gp gr pc pd"><a href="https://rukshanpramoditha.medium.com/principal-component-analysis-18-questions-answered-4abd72041ccd" rel="noopener follow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd iu gy z fp pi fr fs pj fu fw is bi translated">主成分分析—回答了 18 个问题</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">一站式解决关于 PCA 的大部分问题</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">rukshanpramoditha.medium.com</p></div></div><div class="pm l"><div class="pn l po pp pq pm pr ks pd"/></div></div></a></div><h2 id="825c" class="nl lx it bd ly nm nn dn mc no np dp mg li nq nr mi lm ns nt mk lq nu nv mm nw bi translated">成为会员</h2><p id="b4ad" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果你愿意的话，你可以注册成为会员，以获得我写的每一个故事的全部信息，我会收到你的一部分会员费。</p><div class="pa pb gp gr pc pd"><a href="https://rukshanpramoditha.medium.com/membership" rel="noopener follow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd iu gy z fp pi fr fs pj fu fw is bi translated">通过我的推荐链接加入 Medium</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">rukshanpramoditha.medium.com</p></div></div><div class="pm l"><div class="ps l po pp pq pm pr ks pd"/></div></div></a></div><h2 id="8f47" class="nl lx it bd ly nm nn dn mc no np dp mg li nq nr mi lm ns nt mk lq nu nv mm nw bi translated">订阅我的电子邮件列表</h2><p id="255d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">订阅我的电子邮件列表，再也不会错过精彩的故事了。我一点击发布按钮，你就会在收件箱里收到每一篇文章。</p><div class="pa pb gp gr pc pd"><a href="https://rukshanpramoditha.medium.com/subscribe" rel="noopener follow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd iu gy z fp pi fr fs pj fu fw is bi translated">每当鲁克山·普拉莫迪塔发表文章时，就收到一封电子邮件。</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">每当鲁克山·普拉莫迪塔发表文章时，就收到一封电子邮件。通过注册，您将创建一个中等帐户，如果您没有…</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">rukshanpramoditha.medium.com</p></div></div><div class="pm l"><div class="pt l po pp pq pm pr ks pd"/></div></div></a></div><p id="1d25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="pu pv ep" href="https://medium.com/u/f90a3bb1d400?source=post_page-----fce3f48dfdd0--------------------------------" rel="noopener" target="_blank">鲁克山·普拉莫蒂塔</a><br/>T5】2022–03–29</p></div></div>    
</body>
</html>