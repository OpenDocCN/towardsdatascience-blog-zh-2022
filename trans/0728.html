<html>
<head>
<title>Using Make for Data Science Projects Changed My Life</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Make for Data Science 项目改变了我的生活</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-make-for-data-science-projects-changed-my-life-23de1597e2e#2022-03-01">https://towardsdatascience.com/using-make-for-data-science-projects-changed-my-life-23de1597e2e#2022-03-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="42b1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">基岩实用程序有助于保持代码模块化，并提高迭代速度</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e62e2780f28f2c0b5a0397da75caf92b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G6zf33q-qNoyAZ_KQqvUKA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马丁·w·柯斯特在<a class="ae kv" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="f4e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据科学项目的存在是为了从数据中可重复地产生知识。</p><p id="1fee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也就是说，从探索性数据分析和可视化，通过统计建模，一直到具有庞大参数空间的尖端深度学习架构，我们所掌握的所有工具的统一目的是创造新知识。从广义上讲，我们要么通过推理直接学习，要么通过构造证明我们的黑盒可以解决给定的问题。卓越要求我们的过程透明，以至于其他人可以复制它、仔细检查它、修补它并改进它。</p><p id="7b55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">经典且历史悠久的构建工具 GNU Make 使得这些目标非常容易实现。</p><p id="c949" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在为本文创建的<a class="ae kv" href="https://github.com/SeanEaster/make_life_easy" rel="noopener ugc nofollow" target="_blank">示例项目</a>中，我们将下载<a class="ae kv" href="https://archive.ics.uci.edu/ml/datasets/NIPS+Conference+Papers+1987-2015" rel="noopener ugc nofollow" target="_blank"> NeurIPS abstracts </a>(在 CC 4.0 下发布)，对它们进行一些转换，最后拟合一个潜在的 Dirichlet 分配模型。自始至终，我们将使用 Make 来编排这个过程。我们将介绍的众多优势包括:</p><ol class=""><li id="5094" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">一种表达培训管道中各步骤之间依赖关系的自然方式。(阅读“逃离‘拍摄这些笔记本代码单元的顺序正确吗……’地狱。”)</li><li id="ec6f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">向模块化迈进:简单的依赖管理鼓励我们将我们的程序块分割成小而漂亮的庙宇。</li><li id="d633" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">轻松利用实用程序:因为 Make 为我们编排了命令，所以我们可以利用安装在主机上的任何东西。想在 python 的下游任务之前用 sed 处理文本吗？柠檬汽水，范姆。</li><li id="250e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">更快的迭代:Make 帮助我们避免不必要的重复计算，加速我们的创新周期，帮助我们更快地构建。</li><li id="bed6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">更容易的外部协作:通过依赖一组脚本——而不是例如笔记本——并表达它们的依赖性，Make 帮助我们将规范交给数据工程领域的朋友，而不需要太多额外的工作。</li></ol><p id="4ffd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例项目遵循 DrivenData 发布的<a class="ae kv" href="https://drivendata.github.io/cookiecutter-data-science/" rel="noopener ugc nofollow" target="_blank"> DS cookie cutter </a>。这个模板第一次让我了解了 Make for DS 的价值，这本身就是一个效率提升。</p><h1 id="948b" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">什么是品牌</h1><p id="319f" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">(有经验的 Make 用户，随意跳过这一节——你会觉得很无聊。)</p><p id="82d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">按照传统设计，Make 是可执行文件的构建工具。来自<a class="ae kv" href="https://www.gnu.org/software/make/" rel="noopener ugc nofollow" target="_blank">GNU.org</a>:</p><blockquote class="nd ne nf"><p id="df48" class="kw kx ng ky b kz la jr lb lc ld ju le nh lg lh li ni lk ll lm nj lo lp lq lr ij bi translated">GNU Make 是一个工具，它控制从程序的源文件生成程序的可执行文件和其他非源文件。Make 从一个名为 makefile <em class="iq">的文件中获取如何构建程序的知识，该文件列出了每个非源文件以及如何从其他文件中计算出它。写程序的时候要为它写一个 makefile，这样才有可能用 Make 来构建和安装程序。</em></p></blockquote><p id="2fe3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，在 C++项目中，Make 文件是很常见的。但这是它最常见的用法，<em class="ng">不是</em>的限制。更多来自 GNU:</p><blockquote class="nd ne nf"><p id="ae85" class="kw kx ng ky b kz la jr lb lc ld ju le nh lg lh li ni lk ll lm nj lo lp lq lr ij bi translated">Make 根据哪些源文件发生了变化，自动计算出哪些文件需要更新。如果一个非源文件依赖于另一个非源文件，它还会自动确定更新文件的正确顺序。因此，如果您更改一些源文件，然后运行 Make，它不需要重新编译您的所有程序。它只更新那些直接或间接依赖于您所更改的源文件的非源文件。[…]  Make 并不局限于构建一个包。您还可以使用 Make 来控制软件包的安装或卸载，为其生成标记表，或者您想经常做的任何事情，只要写下如何做就值得了。</p></blockquote><p id="f541" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">概括地说，Make 管理检查哪些文件需要创建或重新创建的过程:如果自上次生成输出后没有任何变化，我们可以跳过重新创建它的步骤。它可以用来管理任何一系列我们想要重现的命令。</p><p id="ce1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这非常自然地有助于分析或机器学习项目。考虑这个非常标准的数据科学工作流程:</p><ol class=""><li id="a926" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">通过文件下载或查询数据库获得一些数据。</li><li id="933c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">对数据进行清理、插补等处理。</li><li id="6543" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">工程师特征。</li><li id="6aa1" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">训练和比较一系列模型架构或配置。</li></ol><p id="538a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个非常常见的 DS 项目周期中，我们做出了几十个决定，包括如何处理什么、尝试哪些超参数、不同的插补方法等等。</p><h1 id="44a5" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">易于表达</h1><p id="6206" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">这些步骤中的每一步都可以在 Make 规则中自然地表达出来。例如，假设我们需要从 UCI ML 存储库中下载一个类似于<a class="ae kv" href="https://archive.ics.uci.edu/ml/datasets/NIPS+Conference+Papers+1987-2015" rel="noopener ugc nofollow" target="_blank"> NeurIPS 数据集</a>的文件。我们可以用<code class="fe nk nl nm nn b">curl</code>来下载。这形成了一个简单的 Make 规则:</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="9cc5" class="ns mh iq nn b gy nt nu l nv nw">data/raw/NIPS_1987-2015.csv : curl -o $@ <a class="ae kv" href="https://archive.ics.uci.edu/ml/machine-learning-databases/00371/NIPS_1987-2015.csv" rel="noopener ugc nofollow" target="_blank">https://archive.ics.uci.edu/ml/machine-learning-databases/00371/NIPS_1987-2015.csv</a></span></pre><p id="30ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用 Make 的语言来说，我们想要创建的这个<strong class="ky ir">目标</strong>文件没有<strong class="ky ir">先决条件</strong>，只有一个创建它的方法。那个<code class="fe nk nl nm nn b">$@</code>是一个 Make 自动变量，它填充了目标的名称。导航到演示项目文件夹的根目录，运行<code class="fe nk nl nm nn b">make --recon data/raw/NIPS_1987-2015.csv</code>,您应该会看到 Make 将运行的命令来生成文件:</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="854b" class="ns mh iq nn b gy nt nu l nv nw">curl -o data/raw/NIPS_1987-2015.csv <a class="ae kv" href="https://archive.ics.uci.edu/ml/machine-learning-databases/00371/NIPS_1987-2015.csv" rel="noopener ugc nofollow" target="_blank">https://archive.ics.uci.edu/ml/machine-learning-databases/00371/NIPS_1987-2015.csv</a></span></pre><p id="1fa6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在没有<code class="fe nk nl nm nn b">--recon</code>标志的情况下运行<code class="fe nk nl nm nn b">make data/raw/NIPS_1987-2015.csv</code>，该命令将实际运行。再次运行它，你会得到这条消息，Make 的方式告诉我们不要浪费时间再次下载它:</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="a8aa" class="ns mh iq nn b gy nt nu l nv nw">make: `data/raw/NIPS_1987-2015.csv' is up to date.</span></pre><p id="b318" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们看到原始文件是按列排列的，我们想转置它。我们将把转置后的版本放在<code class="fe nk nl nm nn b">data/interim</code>中，快速编写一个轻量级脚本来执行 op，并在另一个规则中表达依赖性和执行:</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="6be4" class="ns mh iq nn b gy nt nu l nv nw">data/processed/NIPS_1987-2015.csv : src/data/transpose.py data/raw/NIPS_1987-2015.csv $(PYTHON_INTERPRETER) $^ $@</span></pre><p id="19eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们使用了<code class="fe nk nl nm nn b">$^</code>，另一个自动变量满足了所有的先决条件。使用<code class="fe nk nl nm nn b">--recon</code>标志进行的另一个调用<code class="fe nk nl nm nn b">make data/processed/NIPS_1987-2015.csv --recon</code>将向我们展示我们将在实际运行中看到的命令，即它将使用我们编写的 python 脚本创建目标文件:</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="0b62" class="ns mh iq nn b gy nt nu l nv nw">python3 src/data/transpose.py data/raw/NIPS_1987-2015.csv data/processed/NIPS_1987-2015.csv</span></pre><p id="5189" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当训练模型时，这一步自然依赖于处理后的数据:</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="b3f2" class="ns mh iq nn b gy nt nu l nv nw">models/%_topics.png : src/models/fit_lda.py data/processed/NIPS_1987-2015.csv src/models/prodlda.py $(PYTHON_INTERPRETER) $&lt; $(word 2, $^) $@ --topics $*</span></pre><p id="35c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们编写了<code class="fe nk nl nm nn b">fit_lda.py</code>来训练一个模型，并为每个主题创建一个词云，我们在<code class="fe nk nl nm nn b">png</code>目标文件中捕获它。这是为了举例而简化的。在一个典型的、专业的构建中，我们的目标会更加全面:我们会包括学习曲线、数据集每个部分的错误摘要，以及任何我们需要经验地比较不同模型架构的东西。我们还利用了<strong class="ky ir">模式规则</strong>，在目标中使用字符<code class="fe nk nl nm nn b">%</code>，以及 Make 的<code class="fe nk nl nm nn b">word</code>宏。我们将在模块化一节中详细介绍这些内容。</p><p id="1c35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些步骤中的每一步都自然依赖于前面的步骤，Make 为我们提供了表达它们的自然方式。</p><h1 id="ed43" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">更快的迭代</h1><p id="0945" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">Make 为您处理依赖关系。假设您已经编写了处理数据的脚本和步骤，并将结果保存到一个文件中。你现在正处于训练模特的阶段。当您修改训练脚本时，Make 会识别出训练数据文件的时间戳没有更改，并跳过重新生成它的步骤。</p><p id="885e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，想象一下，在这个模型开发过程中，你了解到一个边缘情况，实际上是一个我们没有考虑到的预处理。很平常的事情。</p><p id="7e0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自然，我们更新执行预处理操作的脚本。Make 会将此脚本识别为包含已处理数据的文件的先决条件，当您下一次运行命令来训练模型时，Make 会识别出需要重新创建数据。当所有先决条件都比目标旧时，Make 会跳过重建步骤。</p><p id="2fb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在数据科学项目过程中，这种事情会发生几十次。让它更快可以大大提高你的迭代速度。Edmund Lau 在<a class="ae kv" href="https://amzn.to/3s2c7ko" rel="noopener ugc nofollow" target="_blank"> <em class="ng">《有效的工程师</em> </a> <em class="ng">，</em>中写道迭代速度在软件工程环境中的应用，但关键的要点是数据科学:“你迭代得越快，你就能学到越多。”(附属链接。)对我来说，避免这种不必要的重复已经使项目更有效率。</p><h1 id="38e8" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">鼓励模块化</h1><p id="27db" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">当然，您可以使用 Make 执行一个脚本来一次性完成所有这些工作。它对<em class="ng">实施</em>模块化没有任何作用，因为我们已经在这个例子中实现了它。</p><p id="7bdc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这些步骤都需要时间，你重复的次数越多，你的迭代速度就会越慢。谁愿意花额外的时间等待重新处理他们的数据？有很多方法可以避免这些额外的重新处理步骤，但是 Make 使它变得简单。</p><p id="3351" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">能够灵活地创建规则是非常强大的。例如，假设您正在比较几种型号配置。在一个神经网络中，你可以改变几个层中隐藏单元的数量，非常少的参数，等等。Make 提供了一种简单的方法来保存和比较这些数据。</p><p id="9c9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的主题建模例子中，开始时我们可能不知道有多少主题会导致一组可解释的、合理的主题。我们可以使用我们编写的模式规则快速训练我们的模型。又来了:</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="033e" class="ns mh iq nn b gy nt nu l nv nw">models/%_topics.png : src/models/fit_lda.py data/processed/NIPS_1987-2015.csv src/models/prodlda.py $(PYTHON_INTERPRETER) $&lt; $(word 2, $^) $@ --topics $*</span></pre><p id="0734" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">模式规则使得使用相同的通用执行模式来声明构建许多文件的规则变得容易。在我们的例子中，我们使用自动变量<code class="fe nk nl nm nn b">$*</code>来包含在实际执行中匹配的<strong class="ky ir">词干</strong>，并且我们使用它作为我们的主题模型中的主题数量。结合一个虚假的目标<code class="fe nk nl nm nn b">all</code>，我们可以使用一次<code class="fe nk nl nm nn b">make all</code>训练多个模型:</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="d6ca" class="ns mh iq nn b gy nt nu l nv nw">all : models/10_topics.png models/20_topics.png</span></pre><p id="2d7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们可以比较两者的输出。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/7163075e57fb63446523b60f9d199679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5a6mvceHY6iJI-xH.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">显示来自 10 个主题的潜在狄利克雷分配模型的主题中的常用词的词云。图片作者。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/33b4902f579326d9210143853297b217.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CrvemvaaycPJLpWK.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">显示来自 20 个主题的潜在狄利克雷分配模型的主题中的常用词的词云。图片作者。</p></figure><h1 id="3e2f" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">利用公用事业</h1><p id="a146" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">假设您有一千个文本文件，都有同样的 20 行样板文件需要删除。无聊吧？制作也很简单:</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="8463" class="ns mh iq nn b gy nt nu l nv nw">data/processed/%.txt : data/raw/%.txt sed 1,20d $^ &gt; $@</span></pre><p id="1610" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就像我们之前依赖于<code class="fe nk nl nm nn b">curl</code>一样，我们可以使用任何我们想要的东西来处理我们的数据，任何读取我们的 Makefile 的人都将确切地知道我们是如何创建这些处理过的数据的。简单、可重复且透明。</p><h1 id="ac09" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">易于协作</h1><p id="5604" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">至少在我的经验中，对于“我们如何让我们的模型去生产？”有很多答案。因为有组织和架构。很多(大部分？)组织拥有多年的数据，以及随之而来的遗留限制。这可能意味着，尽管我们很想采用最新的无缝 MLOps 框架，但我们会发现自己正在与软件或数据工程团队合作。</p><p id="5c35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，这些团队通过经验被训练成“你能帮助 DS 团队部署这个吗？”通常翻译成，“你能把这个没有记录任何进入模型构建的假设的糟糕的笔记本，以某种方式把它变成一个可维护的构建过程吗？我把它扔过去的时候，你站在栅栏的对面！”</p><p id="c964" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Make 并不是挥去这些挑战的魔杖。但是，在 Make 中编排的构造良好的模型管道已经将流程表达为 DAG。通过显式指定先决条件，Make 规则精确地显示了给定步骤之前必须做的事情。这样，即使我们的模型构建必须在其他环境中重建，我们的 Makefile 也给出了该过程的详细规范。</p><p id="3dc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">“当然，我们可以帮忙，”我们的软件或数据工程朋友开始说道，令人不寒而栗。"你能给我们介绍一下你的模型训练/构建过程吗？"</p><p id="82be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">“总的来说，如果你克隆我们的回购协议，导航到项目并运行带有<code class="fe nk nl nm nn b">-B</code>和<code class="fe nk nl nm nn b">--recon</code>标志的<code class="fe nk nl nm nn b">make all</code>，它将向你展示所有的步骤是如何执行的。我来拍一个回购的链接稍等……”</p><p id="29b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当他们运行这个命令时—<code class="fe nk nl nm nn b">-B</code>标志告诉 Make 只需改造所有的目标，即使它们没有过时——他们将看到我们为构建我们的模型所必须做的一切:</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="af88" class="ns mh iq nn b gy nt nu l nv nw">curl -o data/raw/NIPS_1987-2015.csv https://archive.ics.uci.edu/ml/machine-learning-databases/00371/NIPS_1987-2015.csv python3 src/data/transpose.py data/raw/NIPS_1987-2015.csv data/processed/NIPS_1987-2015.csv python3 src/models/fit_lda.py data/processed/NIPS_1987-2015.csv models/10_topics.png --topics 10 python3 src/models/fit_lda.py data/processed/NIPS_1987-2015.csv models/20_topics.png --topics 20</span></pre><h1 id="2cba" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">你为什么讨厌笔记本，你这个怪物？</h1><p id="4a9e" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我绝对没有，我发誓。它们作为交流工具非常有用——我宁愿在任何一天写或读一个光滑的笔记本，而不是一个幻灯片——对于互动，DS 思想笔记。“哦，当我画这个的时候，我们看到了一些共线性…让我们计算并打印 R 平方…”是我很多个早上喃喃自语的事情。我喜欢所有的笔记本，无论是 IPython 笔记本还是填充了不必要的高质量纸张的实体笔记本。(我是英语专业的。)</p><p id="95ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想象珍妮特·温特森在写《激情》<a class="ae kv" href="https://amzn.to/3HAlcFy" rel="noopener ugc nofollow" target="_blank"><em class="ng"/></a>的时候填满了几十个实体笔记本。(附属链接。然而，在这个过程的最后，她出版了一部简洁统一、美丽迷人的小说。你，我亲爱的数据科学家，同样也是一个有野心和远见的艺术家，当我们把最终的媒介和勾画出的让我们到达那里的想法混淆时，我们给自己造成了伤害。</p><p id="d78f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">抛开痛苦的隐喻不谈，笔记本是版本控制的噩梦。</p><h1 id="74ef" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">包扎</h1><p id="b1f9" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我们已经了解了 Make 如何通过将您的工作流分解为模块化的块，并使所有这些块协调运行，从而使您的生活变得简单，并使流程易于重现。但是我们只是触及了 make 及其。这里有一些关于进一步发展这些技能的便利资源。</p><ul class=""><li id="5969" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr ny ly lz ma bi translated"><a class="ae kv" href="https://github.com/SeanEaster/make_life_easy" rel="noopener ugc nofollow" target="_blank">完整示例项目</a>展示了如何编写单独的脚本来完成上面讨论的每个步骤。</li><li id="b334" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ny ly lz ma bi translated">它建立在这种<a class="ae kv" href="https://drivendata.github.io/cookiecutter-data-science/" rel="noopener ugc nofollow" target="_blank">千篇一律</a>的基础上，这是一种惊人的自以为是的方式，以神话般的、合理的意见为基础建立项目。这本书非常值得一读，尤其是它简洁地论证了简单的约定如何提高建模的生产率和可重复性。</li><li id="42eb" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ny ly lz ma bi translated">这本<a class="ae kv" href="https://amzn.to/35cfQmR" rel="noopener ugc nofollow" target="_blank">伟大的书</a>可以帮助人们深入了解 GNU Make 的全部功能，我们在这里只是涉猎了一下。(附属链接。)它的主要焦点是传统的软件项目，但这不是障碍:它全面地展示了 Make 的功能，并给出了全面的、有指导的介绍。如果你想避免仅仅从文档中学习新技术时遇到的麻烦，这可能是一本好书。</li></ul></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="30b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ng">原载于 2022 年 3 月 1 日</em><a class="ae kv" href="https://easter.ai/post/make-life-easy/" rel="noopener ugc nofollow" target="_blank"><em class="ng">https://Easter . ai</em></a><em class="ng">。</em></p></div></div>    
</body>
</html>