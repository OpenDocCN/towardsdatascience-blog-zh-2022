<html>
<head>
<title>How To Merge Pandas DataFrames</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何合并熊猫数据帧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-merge-pandas-dataframes-221e49c41bec#2022-03-18">https://towardsdatascience.com/how-to-merge-pandas-dataframes-221e49c41bec#2022-03-18</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="7acc" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">对熊猫数据帧执行左、右、内和反连接</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/962fa71e7b0d7d987d4d0cec71a5a561.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9EMUihbQXDDPR5ywkTvnbw.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">安德斯·吉尔登在<a class="ae kz" href="https://unsplash.com/s/photos/smoke-grenade?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h2 id="b23f" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">介绍</h2><p id="26a7" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">通常，我们可能必须将 pandas 数据帧合并在一起，以便基于最终服务于我们正在进行的任务的目的的一些逻辑，构建包含来自相关方的列和行的新数据帧。</p><p id="bba2" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">在今天的文章中，我们将展示如何合并熊猫数据帧，并执行<code class="fe mu mv mw mx b">LEFT</code>、<code class="fe mu mv mw mx b">RIGHT</code>、<code class="fe mu mv mw mx b">INNER</code>、<code class="fe mu mv mw mx b">OUTER</code>、<code class="fe mu mv mw mx b">FULL</code>和<code class="fe mu mv mw mx b">ANTI</code>连接。Pandas 合并相当于 SQL 中的连接，我们将采用 SQL 风格的方法来解释合并，因为这将有助于新来者跟上。更具体地说，我们将展示如何表演</p><ul class=""><li id="4aea" class="my mz iu ly b lz mp mc mq lj na ln nb lr nc mo nd ne nf ng bi translated">左连接(也称为左外连接)</li><li id="ebd7" class="my mz iu ly b lz nh mc ni lj nj ln nk lr nl mo nd ne nf ng bi translated">右连接(也称为右外连接)</li><li id="81cb" class="my mz iu ly b lz nh mc ni lj nj ln nk lr nl mo nd ne nf ng bi translated">内部连接</li><li id="47ea" class="my mz iu ly b lz nh mc ni lj nj ln nk lr nl mo nd ne nf ng bi translated">完全外部连接</li><li id="5164" class="my mz iu ly b lz nh mc ni lj nj ln nk lr nl mo nd ne nf ng bi translated">左反连接(又名左排除连接)</li><li id="e8db" class="my mz iu ly b lz nh mc ni lj nj ln nk lr nl mo nd ne nf ng bi translated">右反联接(又名右排除联接)</li><li id="673a" class="my mz iu ly b lz nh mc ni lj nj ln nk lr nl mo nd ne nf ng bi translated">完全反联接</li></ul><p id="c48c" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">除了不同的连接/合并类型，在下面的部分中，我们还将介绍如何</p><ul class=""><li id="8dd1" class="my mz iu ly b lz mp mc mq lj na ln nb lr nc mo nd ne nf ng bi translated">在单个列上合并(在两个 dfs 上具有相同的名称)</li><li id="0f3f" class="my mz iu ly b lz nh mc ni lj nj ln nk lr nl mo nd ne nf ng bi translated">在多列上合并</li><li id="0401" class="my mz iu ly b lz nh mc ni lj nj ln nk lr nl mo nd ne nf ng bi translated">合并不同名称的列</li><li id="93c5" class="my mz iu ly b lz nh mc ni lj nj ln nk lr nl mo nd ne nf ng bi translated">重命名联接中使用的共有列名</li><li id="ef61" class="my mz iu ly b lz nh mc ni lj nj ln nk lr nl mo nd ne nf ng bi translated">仅从联接所涉及的数据框架中选择一些列</li></ul></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><p id="7e11" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">首先，让我们创建几个将在本教程中使用的数据框架，以演示我们今天将讨论的各种连接类型。</p><pre class="kk kl km kn gu nt mx nu nv aw nw bi"><span id="848e" class="la lb iu mx b gz nx ny l nz oa">import pandas as pd<br/></span><span id="ac32" class="la lb iu mx b gz ob ny l nz oa">df1 = pd.DataFrame(<br/>    [<br/>       (1, 345, 'B', True),<br/>       (2, 100, 'C', False),<br/>       (3, 300, 'B', False),<br/>       (4, 151, 'A', False),<br/>       (5, 212, 'A', True),<br/>       (6, 121, 'C', False),<br/>       (7, 333, 'B', True),<br/>       (8, 456, 'C', True),<br/>    ],<br/>    columns=['id', 'value', 'colC', 'colD']<br/>)</span><span id="c7fe" class="la lb iu mx b gz ob ny l nz oa">df2 = pd.DataFrame(<br/>    [<br/>       (1, 111, 10.1, 3),<br/>       (9, 56, 3.33, 10),<br/>       (10, 17, 18.0, 8),<br/>       (3, 567, 19.1, 4),<br/>       (11, 98, 2.1, 1),<br/>       (6, 31, 3.14, 12),<br/>    ],<br/>    columns=['id', 'value', 'colE', 'colF']<br/>)</span><span id="3206" class="la lb iu mx b gz ob ny l nz oa">print(df1)<br/><strong class="mx iv"><em class="oc">   id  value colC   colD<br/></em></strong><em class="oc">0   1    345    B   True<br/>1   2    100    C  False<br/>2   3    300    B  False<br/>3   4    151    A  False<br/>4   5    212    A   True<br/>5   6    121    C  False<br/>6   7    333    B   True<br/>7   8    456    C   True</em></span><span id="761d" class="la lb iu mx b gz ob ny l nz oa">print(df2)<br/><strong class="mx iv"><em class="oc">   id  value   colE  colF<br/></em></strong><em class="oc">0   1    111  10.10     3<br/>1   9     56   3.33    10<br/>2  10     17  18.00     8<br/>3   3    567  19.10     4<br/>4  11     98   2.10     1<br/>5   6     31   3.14    12</em></span></pre></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><h2 id="0a2e" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">内部连接</h2><p id="9fa0" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">两个 pandas 数据帧之间的内部连接将产生一组记录，这些记录在指定的连接列中具有共同的值。</p><blockquote class="od"><p id="19b3" class="oe of iu bd og oh oi oj ok ol om mo dk translated">内部连接:使用两个帧的关键点的交集</p></blockquote><figure class="oo op oq or os ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj on"><img src="../Images/a27515fa8836294408206eb9dafc2abe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xSblAsBOCcjZZHQhZrDhvw.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">对两个数据帧执行内部连接时选择的记录—来源:作者</p></figure><p id="5b0b" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">为了使用单个列在两个数据帧之间执行内部连接，我们只需要在调用<code class="fe mu mv mw mx b">merge()</code>时提供<code class="fe mu mv mw mx b">on</code>参数。</p><pre class="kk kl km kn gu nt mx nu nv aw nw bi"><span id="05dc" class="la lb iu mx b gz nx ny l nz oa">df1.merge(df2, on='id')</span></pre><p id="8437" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">注意，默认情况下，<code class="fe mu mv mw mx b"><a class="ae kz" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.merge.html" rel="noopener ugc nofollow" target="_blank">merge()</a></code>方法执行内部连接(<code class="fe mu mv mw mx b">how='inner'</code>)，因此您不必显式指定连接类型。输出将包含在<code class="fe mu mv mw mx b">df1</code>和<code class="fe mu mv mw mx b">df2</code>中具有共同 id 的所有记录:</p><pre class="kk kl km kn gu nt mx nu nv aw nw bi"><span id="a6dd" class="la lb iu mx b gz nx ny l nz oa"><strong class="mx iv"><em class="oc">   id  value_x colC   colD  value_y   colE  colF<br/></em></strong><em class="oc">0   1      345    B   True      111  10.10     3<br/>1   3      300    B  False      567  19.10     4<br/>2   6      121    C  False       31   3.14    12</em></span></pre></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><h2 id="b397" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">左连接(也称为左外连接)</h2><p id="97c5" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">左联接(或左外联接)将在指定的联接列上，从左数据帧中取出所有记录，以及从右数据帧中取出与左数据帧具有匹配值的记录。</p><p id="ec9e" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">结果中包含的右侧数据帧记录中的任何缺失值将被替换为<code class="fe mu mv mw mx b">NaN</code>。</p><blockquote class="od"><p id="c139" class="oe of iu bd og oh oi oj ok ol om mo dk translated">左侧外部连接:仅使用左侧帧中的关键点</p></blockquote><figure class="oo op oq or os ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ot"><img src="../Images/1477b103bad1a09236e6f0bcdc3e6e95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4qR9zT6z3l6jmWfgpk4ynA.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">对两个数据帧执行左连接时选择的记录-来源:作者</p></figure><p id="7c85" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">要在两个熊猫数据帧之间执行左连接，现在需要在调用<code class="fe mu mv mw mx b">merge()</code>时指定<code class="fe mu mv mw mx b">how='left'</code>。</p><pre class="kk kl km kn gu nt mx nu nv aw nw bi"><span id="ef09" class="la lb iu mx b gz nx ny l nz oa">df1.merge(df2, on='id', how='left')</span></pre><p id="d23d" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">如上所述，得到的数据帧将包含左侧数据帧中的每条记录，以及右侧数据帧中与连接列匹配的这些记录的相应值。这些记录的结果中与右侧数据帧中的记录不匹配的其余列值将被替换为<code class="fe mu mv mw mx b">NaN</code> s。</p><pre class="kk kl km kn gu nt mx nu nv aw nw bi"><span id="1b01" class="la lb iu mx b gz nx ny l nz oa"><strong class="mx iv"><em class="oc">   id  value_x colC   colD  value_y   colE  colF<br/></em></strong><em class="oc">0   1      345    B   True    111.0  10.10   3.0<br/>1   2      100    C  False      NaN    NaN   NaN<br/>2   3      300    B  False    567.0  19.10   4.0<br/>3   4      151    A  False      NaN    NaN   NaN<br/>4   5      212    A   True      NaN    NaN   NaN<br/>5   6      121    C  False     31.0   3.14  12.0<br/>6   7      333    B   True      NaN    NaN   NaN<br/>7   8      456    C   True      NaN    NaN   NaN</em></span></pre></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><h2 id="6098" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">右连接(也称为右外连接)</h2><p id="b86f" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">右联接(或右外联接)将在指定的联接列上，从右数据帧中取出所有记录，以及从左数据帧中取出与右数据帧具有匹配值的记录。</p><p id="468e" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">包含在结果中的左侧数据帧记录中的任何缺失值将被替换为<code class="fe mu mv mw mx b">NaN</code>。</p><blockquote class="od"><p id="54fd" class="oe of iu bd og oh oi oj ok ol om mo dk translated">右侧外部连接:仅使用右侧帧中的关键点</p></blockquote><figure class="oo op oq or os ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ou"><img src="../Images/af54bfaa730dbaa886159b91b5ba1ca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AnmWoqbMpCIMjbwSdoEH1A.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">对两个数据帧执行右连接时选择的记录-来源:作者</p></figure><p id="3bdb" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">要在两个熊猫数据帧之间执行左连接，现在需要在调用<code class="fe mu mv mw mx b">merge()</code>时指定<code class="fe mu mv mw mx b">how='right'</code>。</p><pre class="kk kl km kn gu nt mx nu nv aw nw bi"><span id="ff97" class="la lb iu mx b gz nx ny l nz oa">df1.merge(df2, on='id', how='right')</span></pre><p id="5de8" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated"><code class="fe mu mv mw mx b">df1</code>和<code class="fe mu mv mw mx b">df2</code>数据帧之间右连接的结果如下所示。</p><pre class="kk kl km kn gu nt mx nu nv aw nw bi"><span id="3b5d" class="la lb iu mx b gz nx ny l nz oa"><strong class="mx iv"><em class="oc">   id  value_x colC   colD  value_y   colE  colF<br/></em></strong><em class="oc">0   1    345.0    B   True      111  10.10     3<br/>1   9      NaN  NaN    NaN       56   3.33    10<br/>2  10      NaN  NaN    NaN       17  18.00     8<br/>3   3    300.0    B  False      567  19.10     4<br/>4  11      NaN  NaN    NaN       98   2.10     1<br/>5   6    121.0    C  False       31   3.14    12</em></span></pre></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><h2 id="dc71" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">完全外部连接</h2><p id="770b" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">完整的外部连接基本上包括来自左右数据帧的所有记录。这种类型的连接将使用两个帧中的键——对于任何缺失的行，将插入<code class="fe mu mv mw mx b">NaN</code>值。</p><blockquote class="od"><p id="98b6" class="oe of iu bd og oh oi oj ok ol om mo dk translated">完全外部连接:使用两个帧的键的联合</p></blockquote><figure class="oo op oq or os ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ov"><img src="../Images/d9a8f4acbb27d1c45b6c3aae39a5bb70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*slui3BX0cM_K3s695aUsxg.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">对两个数据帧执行完全外部连接时选择的记录—来源:作者</p></figure><p id="32f3" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">要在两个 pandas 数据帧之间执行完整的外部连接，现在需要在调用<code class="fe mu mv mw mx b">merge()</code>时指定<code class="fe mu mv mw mx b">how='outer'</code>。</p><pre class="kk kl km kn gu nt mx nu nv aw nw bi"><span id="7f4b" class="la lb iu mx b gz nx ny l nz oa">df1.merge(df2, on='id', how='outer')</span></pre><p id="9f2b" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">使用我们的两个示例框架的完整外部连接的输出如下所示。</p><pre class="kk kl km kn gu nt mx nu nv aw nw bi"><span id="852c" class="la lb iu mx b gz nx ny l nz oa"><strong class="mx iv"><em class="oc">    id  value_x colC   colD  value_y   colE  colF<br/></em></strong><em class="oc">0    1    345.0    B   True    111.0  10.10   3.0<br/>1    2    100.0    C  False      NaN    NaN   NaN<br/>2    3    300.0    B  False    567.0  19.10   4.0<br/>3    4    151.0    A  False      NaN    NaN   NaN<br/>4    5    212.0    A   True      NaN    NaN   NaN<br/>5    6    121.0    C  False     31.0   3.14  12.0<br/>6    7    333.0    B   True      NaN    NaN   NaN<br/>7    8    456.0    C   True      NaN    NaN   NaN<br/>8    9      NaN  NaN    NaN     56.0   3.33  10.0<br/>9   10      NaN  NaN    NaN     17.0  18.00   8.0<br/>10  11      NaN  NaN    NaN     98.0   2.10   1.0</em></span></pre></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><h2 id="ec27" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">左反连接(又名左排除连接)</h2><p id="c202" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">左反连接将包含左框架中键没有出现在右框架中的所有记录。</p><blockquote class="od"><p id="1a9b" class="oe of iu bd og oh oi oj ok ol om mo dk translated">左侧反连接:仅使用左侧帧中不出现在右侧帧中的关键点</p></blockquote><figure class="oo op oq or os ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ow"><img src="../Images/21d4c6398ea3de3ad7b430106620dcbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IgRKSWCUz7CmGRCWxSXTJA.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">对两个数据帧执行左反连接时选择的记录—来源:作者</p></figure><p id="9587" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">熊猫的左反加入可以分两步进行。第一步，我们需要用<code class="fe mu mv mw mx b">indicator=True</code>执行一个<strong class="ly iv">左外连接</strong>:</p><blockquote class="ox oy oz"><p id="8cf5" class="lw lx oc ly b lz mp jv mb mc mq jy me pa mr mg mh pb ms mj mk pc mt mm mn mo in bi translated"><strong class="ly iv">指标</strong> <code class="fe mu mv mw mx b"><em class="iu">bool</em></code> <em class="iu">或</em> <code class="fe mu mv mw mx b"><em class="iu">str</em></code> <em class="iu">，默认</em> <code class="fe mu mv mw mx b"><em class="iu">False</em></code></p><p id="956a" class="lw lx oc ly b lz mp jv mb mc mq jy me pa mr mg mh pb ms mj mk pc mt mm mn mo in bi translated">如果是<code class="fe mu mv mw mx b">True</code>，在输出数据帧中添加一个名为<code class="fe mu mv mw mx b">'_merge'</code>的列，其中包含每行的源信息。通过提供字符串参数，可以为该列指定一个不同的名称。对于合并键仅出现在左侧数据帧中的观察，该列将具有值为<code class="fe mu mv mw mx b">'left_only'</code>的<code class="fe mu mv mw mx b">Categorical</code>类型；对于合并键仅出现在右侧数据帧中的观察，该列将具有值为<code class="fe mu mv mw mx b">'right_only'</code>的类型；如果观察的合并键同时出现在两个数据帧中，则该列将具有值为<code class="fe mu mv mw mx b">'both'</code>的类型。</p><p id="ee21" class="lw lx oc ly b lz mp jv mb mc mq jy me pa mr mg mh pb ms mj mk pc mt mm mn mo in bi translated">— Python 文档</p></blockquote><pre class="kk kl km kn gu nt mx nu nv aw nw bi"><span id="a270" class="la lb iu mx b gz nx ny l nz oa">df1.merge(df2, on='id', how='left', indicator=True)</span><span id="8f92" class="la lb iu mx b gz ob ny l nz oa"><strong class="mx iv"><em class="oc">   id  value_x colC   colD  value_y   colE  colF     _merge<br/></em></strong><em class="oc">0   1      345    B   True    111.0  10.10   3.0       both<br/>1   2      100    C  False      NaN    NaN   NaN  left_only<br/>2   3      300    B  False    567.0  19.10   4.0       both<br/>3   4      151    A  False      NaN    NaN   NaN  left_only<br/>4   5      212    A   True      NaN    NaN   NaN  left_only<br/>5   6      121    C  False     31.0   3.14  12.0       both<br/>6   7      333    B   True      NaN    NaN   NaN  left_only<br/>7   8      456    C   True      NaN    NaN   NaN  left_only</em></span></pre><p id="9745" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">在第二步中，我们只需要<code class="fe mu mv mw mx b">query()</code>上一个表达式的结果，以便只保留来自左侧框架的行，并过滤掉那些也出现在右侧框架中的行。</p><p id="8f20" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">如果我们将这两个步骤结合在一起，得到的表达式将是</p><pre class="kk kl km kn gu nt mx nu nv aw nw bi"><span id="2f4d" class="la lb iu mx b gz nx ny l nz oa">df1.merge(df2, on='id', how='left', indicator=True) \<br/>    .query('_merge == "left_only"') \<br/>    .drop('_merge', 1)</span></pre><p id="920d" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">以及相应的结果</p><pre class="kk kl km kn gu nt mx nu nv aw nw bi"><span id="83e7" class="la lb iu mx b gz nx ny l nz oa"><strong class="mx iv"><em class="oc">   id  value_x colC   colD  value_y  colE  colF<br/></em></strong><em class="oc">1   2      100    C  False      NaN   NaN   NaN<br/>3   4      151    A  False      NaN   NaN   NaN<br/>4   5      212    A   True      NaN   NaN   NaN<br/>6   7      333    B   True      NaN   NaN   NaN<br/>7   8      456    C   True      NaN   NaN   NaN</em></span></pre></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><h2 id="daa0" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">右反联接(又名右排除联接)</h2><p id="065f" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">类似地，右反连接将包含右框架的所有记录，这些记录的键没有出现在左框架中。</p><blockquote class="od"><p id="dd92" class="oe of iu bd og oh oi oj ok ol om mo dk translated">右侧反连接:仅使用右侧帧中不出现在左侧帧中的关键点</p></blockquote><figure class="oo op oq or os ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pd"><img src="../Images/a2078b4d5843543d015d0592adb231a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hxnl03wBc5BKvlOTnQnIKg.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">对两个数据帧执行右反连接时选择的记录—来源:作者</p></figure><p id="b3e1" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">熊猫的右反加入可以分两步进行。第一步，我们需要用<code class="fe mu mv mw mx b">indicator=True</code>执行一个<strong class="ly iv">右外连接</strong>:</p><blockquote class="ox oy oz"><p id="f884" class="lw lx oc ly b lz mp jv mb mc mq jy me pa mr mg mh pb ms mj mk pc mt mm mn mo in bi translated"><strong class="ly iv">指示器</strong> <code class="fe mu mv mw mx b"><em class="iu">bool</em></code> <em class="iu">或</em> <code class="fe mu mv mw mx b"><em class="iu">str</em></code> <em class="iu">，默认</em> <code class="fe mu mv mw mx b"><em class="iu">False</em></code></p><p id="3591" class="lw lx oc ly b lz mp jv mb mc mq jy me pa mr mg mh pb ms mj mk pc mt mm mn mo in bi translated">如果是<code class="fe mu mv mw mx b"><em class="iu">True</em></code>，则向输出数据帧添加一个名为<code class="fe mu mv mw mx b"><em class="iu">'_merge'</em></code>的列，其中包含每行的源信息。通过提供字符串参数，可以为该列指定一个不同的名称。对于合并关键字只出现在左侧数据帧中的观察，该列将具有值为<code class="fe mu mv mw mx b"><em class="iu">'left_only'</em></code>的<code class="fe mu mv mw mx b">Categorical</code>类型；对于合并关键字只出现在右侧数据帧中的观察，该列将具有值为<code class="fe mu mv mw mx b"><em class="iu">'right_only'</em></code>的类型；如果观察的合并关键字同时出现在两个数据帧中，则该列将具有值<code class="fe mu mv mw mx b"><em class="iu">'both'</em></code>。</p><p id="14d9" class="lw lx oc ly b lz mp jv mb mc mq jy me pa mr mg mh pb ms mj mk pc mt mm mn mo in bi translated">— Python 文档</p></blockquote><pre class="kk kl km kn gu nt mx nu nv aw nw bi"><span id="ee20" class="la lb iu mx b gz nx ny l nz oa">df1.merge(df2, on='id', how='right', indicator=True)</span><span id="e096" class="la lb iu mx b gz ob ny l nz oa"><strong class="mx iv"><em class="oc">   id  value_x colC   colD  value_y   colE  colF      _merge<br/></em></strong><em class="oc">0   1    345.0    B   True      111  10.10     3        both<br/>1   9      NaN  NaN    NaN       56   3.33    10  right_only<br/>2  10      NaN  NaN    NaN       17  18.00     8  right_only<br/>3   3    300.0    B  False      567  19.10     4        both<br/>4  11      NaN  NaN    NaN       98   2.10     1  right_only<br/>5   6    121.0    C  False       31   3.14    12        both</em></span></pre><p id="f0c2" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">在第二步中，我们只需要<code class="fe mu mv mw mx b">query()</code>上一个表达式的结果，以便只保留来自右帧的行，并过滤掉那些同时出现在左帧中的行。</p><p id="70e3" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">如果我们将这两个步骤结合在一起，得到的表达式将是</p><pre class="kk kl km kn gu nt mx nu nv aw nw bi"><span id="4823" class="la lb iu mx b gz nx ny l nz oa">df1.merge(df2, on='id', how='right', indicator=True) \<br/>  .query('_merge == "right_only"') \<br/>  .drop('_merge', 1)</span></pre><p id="19ce" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">使用我们的示例数据帧得到的帧将是</p><pre class="kk kl km kn gu nt mx nu nv aw nw bi"><span id="6b48" class="la lb iu mx b gz nx ny l nz oa"><strong class="mx iv"><em class="oc">   id  value_x colC colD  value_y   colE  colF<br/></em></strong><em class="oc">1   9      NaN  NaN  NaN       56   3.33    10<br/>2  10      NaN  NaN  NaN       17  18.00     8<br/>4  11      NaN  NaN  NaN       98   2.10     1</em></span></pre></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><h2 id="875c" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">完全反联接</h2><p id="d33c" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">完整的反连接将包含没有任何公共键的左帧和右帧的所有记录。</p><blockquote class="od"><p id="f4dd" class="oe of iu bd og oh oi oj ok ol om mo dk translated">完全反连接:取两帧密钥的对称差</p></blockquote><figure class="oo op oq or os ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pe"><img src="../Images/e0ee585b2e782252e9c93b7e75766333.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nEYKfxeGnchNR1Q6cYaNkQ.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">对两个数据帧执行完全反连接时选择的记录—来源:作者</p></figure><p id="fa41" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">同样，这可以像我们讨论的前两种反连接类型一样分两步执行。</p><pre class="kk kl km kn gu nt mx nu nv aw nw bi"><span id="8b01" class="la lb iu mx b gz nx ny l nz oa">df1.merge(df2, on='id', how='outer', indicator=True) \<br/>  .query('_merge != "both"') \<br/>  .drop('_merge', 1)</span></pre><p id="f6d1" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">使用我们的示例帧的结果如下所示。</p><pre class="kk kl km kn gu nt mx nu nv aw nw bi"><span id="9247" class="la lb iu mx b gz nx ny l nz oa"><strong class="mx iv"><em class="oc">    id  value_x colC   colD  value_y   colE  colF<br/></em></strong><em class="oc">1    2    100.0    C  False      NaN    NaN   NaN<br/>3    4    151.0    A  False      NaN    NaN   NaN<br/>4    5    212.0    A   True      NaN    NaN   NaN<br/>6    7    333.0    B   True      NaN    NaN   NaN<br/>7    8    456.0    C   True      NaN    NaN   NaN<br/>8    9      NaN  NaN    NaN     56.0   3.33  10.0<br/>9   10      NaN  NaN    NaN     17.0  18.00   8.0<br/>10  11      NaN  NaN    NaN     98.0   2.10   1.0</em></span></pre></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><h2 id="9bd8" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">更改同名列的后缀</h2><p id="542c" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">还要注意如何分别使用<code class="fe mu mv mw mx b">_x</code>和<code class="fe mu mv mw mx b">_y</code>自动重命名同名的列。您可以通过向<code class="fe mu mv mw mx b">suffixes</code>参数提供所需的值来更改默认值。举个例子，</p><pre class="kk kl km kn gu nt mx nu nv aw nw bi"><span id="6d80" class="la lb iu mx b gz nx ny l nz oa">df1.merge(df2, on='id', <strong class="mx iv">suffixes=('_df1', '_df2'</strong>))</span></pre><p id="9fc6" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">现在，参与连接的左右数据帧中的每一列都将具有指定的后缀。</p><pre class="kk kl km kn gu nt mx nu nv aw nw bi"><span id="ac57" class="la lb iu mx b gz nx ny l nz oa"><strong class="mx iv">   id  value_df1 colC   colD  value_df2   colE  colF<br/></strong><em class="oc">0   1        345    B   True        111  10.10     3<br/>1   3        300    B  False        567  19.10     4<br/>2   6        121    C  False         31   3.14    12</em></span></pre></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><h2 id="9965" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">合并不同的列名</h2><p id="2d83" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">现在让我们考虑另一个用例，其中我们想要合并两个 pandas 数据帧的列没有相同的名称。在这种情况下，我们不提供<code class="fe mu mv mw mx b">on</code>参数，而是必须提供<code class="fe mu mv mw mx b">left_on</code>和<code class="fe mu mv mw mx b">right_on</code>参数来指定在将左右数据帧合并在一起时要考虑的列。</p><p id="960a" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">作为一个例子，假设我们想要分别基于<code class="fe mu mv mw mx b">id</code>和<code class="fe mu mv mw mx b">colF</code>列合并<code class="fe mu mv mw mx b">df1</code>和<code class="fe mu mv mw mx b">df2</code>。以下命令将完成这一任务:</p><pre class="kk kl km kn gu nt mx nu nv aw nw bi"><span id="4a1a" class="la lb iu mx b gz nx ny l nz oa">df1.merge(df2, left_on='id', right_on='colF')</span></pre><p id="46df" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">得到的数据帧如下所示</p><pre class="kk kl km kn gu nt mx nu nv aw nw bi"><span id="a3db" class="la lb iu mx b gz nx ny l nz oa"><strong class="mx iv"><em class="oc">   id_x  value_x colC   colD  id_y  value_y  colE  colF</em></strong><br/><em class="oc">0     1      345    B   True    11       98   2.1     1<br/>1     3      300    B  False     1      111  10.1     3<br/>2     4      151    A  False     3      567  19.1     4<br/>3     8      456    C   True    10       17  18.0     8</em></span></pre></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><h2 id="9bb4" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">在多列上合并</h2><p id="78ca" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">如果您想要合并多个列，您可以简单地将所有想要的列作为一个列表传递到<code class="fe mu mv mw mx b">on</code>参数中:</p><pre class="kk kl km kn gu nt mx nu nv aw nw bi"><span id="7295" class="la lb iu mx b gz nx ny l nz oa">df1.merge(df2, on=['colA', 'colB', ..])</span></pre><p id="ff42" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">如果左框架和右框架中的列有不同的名称，那么您可以再次使用<code class="fe mu mv mw mx b">right_on</code>和<code class="fe mu mv mw mx b">left_on</code>参数:</p><pre class="kk kl km kn gu nt mx nu nv aw nw bi"><span id="2708" class="la lb iu mx b gz nx ny l nz oa">df1.merge(df2, left_on=['colA', 'colB'], right_on=['colC', 'colD])</span></pre></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><h2 id="c0fa" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">从所涉及的数据帧中仅选择一些列</h2><p id="dc52" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">现在假设我们想使用左外连接将框架<code class="fe mu mv mw mx b">df1</code>和<code class="fe mu mv mw mx b">df2</code>合并在一起，选择<code class="fe mu mv mw mx b">df1</code>中的所有列，但只选择<code class="fe mu mv mw mx b">df2</code>中的列<code class="fe mu mv mw mx b">colE</code>。</p><p id="d20c" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">为此，在将帧传递给<code class="fe mu mv mw mx b">merge()</code>方法时，可以简单地使用<code class="fe mu mv mw mx b">df2</code>列的子集。</p><pre class="kk kl km kn gu nt mx nu nv aw nw bi"><span id="9a4e" class="la lb iu mx b gz nx ny l nz oa">df1.merge(df2[['id', 'colE']], on='id')</span></pre><p id="821d" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">这将从右侧框架中排除除<code class="fe mu mv mw mx b">colE</code>之外的所有列:</p><pre class="kk kl km kn gu nt mx nu nv aw nw bi"><span id="83bc" class="la lb iu mx b gz nx ny l nz oa"><strong class="mx iv"><em class="oc">   id  value colC   colD   colE<br/></em></strong><em class="oc">0   1    345    B   True  10.10<br/>1   3    300    B  False  19.10<br/>2   6    121    C  False   3.14</em></span></pre></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><h2 id="78f3" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">最后的想法</h2><p id="f311" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">在本教程中，我们讨论了合并熊猫数据帧以及如何执行<strong class="ly iv">左外、右外、内、全外、左反、右反</strong>和<strong class="ly iv">全反</strong>连接。</p><p id="3736" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">此外，我们还讨论了一些其他用例，包括如何连接不同名称的列，甚至是多个列。此外，我们还展示了如何更改具有相同名称的列名的后缀，以及如何在执行合并后只从左侧或右侧数据帧中选择列的子集。</p><p id="ef33" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">每当你想在熊猫数据帧之间执行一些连接时，你可以使用这篇文章作为备忘单，因此可以自由地保存这篇文章或在你的浏览器上创建一个书签！</p></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><p id="1b77" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated"><a class="ae kz" href="https://gmyrianthous.medium.com/membership" rel="noopener"> <strong class="ly iv">成为会员</strong> </a> <strong class="ly iv">阅读介质上的每一个故事。你的会员费直接支持我和你看的其他作家。你也可以在媒体上看到所有的故事。</strong></p><div class="pf pg gq gs ph pi"><a href="https://gmyrianthous.medium.com/membership" rel="noopener follow" target="_blank"><div class="pj ab fp"><div class="pk ab pl cl cj pm"><h2 class="bd iv gz z fq pn fs ft po fv fx it bi translated">通过我的推荐链接加入 Medium-Giorgos Myrianthous</h2><div class="pp l"><h3 class="bd b gz z fq pn fs ft po fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pq l"><p class="bd b dl z fq pn fs ft po fv fx dk translated">gmyrianthous.medium.com</p></div></div><div class="pr l"><div class="ps l pt pu pv pr pw kt pi"/></div></div></a></div></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><p id="676e" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated"><strong class="ly iv">相关文章你可能也喜欢</strong></p><div class="pf pg gq gs ph pi"><a rel="noopener follow" target="_blank" href="/apply-vs-map-vs-applymap-pandas-529acdf6d744"><div class="pj ab fp"><div class="pk ab pl cl cj pm"><h2 class="bd iv gz z fq pn fs ft po fv fx it bi translated">熊猫中的 apply() vs map() vs applymap()</h2><div class="pp l"><h3 class="bd b gz z fq pn fs ft po fv fx dk translated">讨论 Python 和 Pandas 中 apply()、map()和 applymap()的区别</h3></div><div class="pq l"><p class="bd b dl z fq pn fs ft po fv fx dk translated">towardsdatascience.com</p></div></div><div class="pr l"><div class="px l pt pu pv pr pw kt pi"/></div></div></a></div></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu pi"><a rel="noopener follow" target="_blank" href="/how-to-efficiently-convert-a-pyspark-dataframe-to-pandas-8bda2c3875c3"><div class="pj ab fp"><div class="pk ab pl cl cj pm"><h2 class="bd iv gz z fq pn fs ft po fv fx it bi translated">加快 PySpark 和 Pandas 数据帧之间的转换</h2><div class="pp l"><h3 class="bd b gz z fq pn fs ft po fv fx dk translated">将大火花数据帧转换为熊猫时节省时间</h3></div><div class="pq l"><p class="bd b dl z fq pn fs ft po fv fx dk translated">towardsdatascience.com</p></div></div><div class="pr l"><div class="py l pt pu pv pr pw kt pi"/></div></div></a></div></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu pi"><a rel="noopener follow" target="_blank" href="/loc-vs-iloc-in-pandas-92fc125ed8eb"><div class="pj ab fp"><div class="pk ab pl cl cj pm"><h2 class="bd iv gz z fq pn fs ft po fv fx it bi translated">熊猫中的 loc 与 iloc</h2><div class="pq l"><p class="bd b dl z fq pn fs ft po fv fx dk translated">towardsdatascience.com</p></div></div><div class="pr l"><div class="pz l pt pu pv pr pw kt pi"/></div></div></a></div></div></div>    
</body>
</html>