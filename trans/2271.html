<html>
<head>
<title>Python vs. Julia: It’s also about Consistency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python vs. Julia:这也是关于一致性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-vs-julia-its-also-about-consistency-236812dd64ba#2022-05-19">https://towardsdatascience.com/python-vs-julia-its-also-about-consistency-236812dd64ba#2022-05-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/f0008989dee1fdf47706a110f473eacb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TIYx5LPhHX4465HlSUFVlA.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">由<a class="ae jd" href="https://unsplash.com/@purzlbaum?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克劳迪奥·施瓦茨</a>在<a class="ae jd" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><div class=""/><div class=""><h2 id="2a0a" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">与Python相比，Julia的主要优势无疑是它的速度和多任务分派等概念。但是还有更多:在日常使用中，一致性起着重要的作用。</h2></div><p id="31e5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">学习和使用一种编程语言的容易(或困难)程度在很大程度上取决于该语言不同构造的一致性。高度的一致性也有助于避免错误，从而使其成为构建高质量软件的一个重要方面。在本文中，我将展示Julia和Python在这方面的表现。</p><p id="0dcf" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以<em class="lr"> ranges </em>和<em class="lr"> indexing </em>为例，我将首先说明这两种语言在这些概念的用法上有何不同，然后解释其背后的基本原理。</p><h1 id="bcd7" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">范围</h1><p id="427e" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在编程中，由一个下限和一个上限指定的数字范围是一个经常使用的概念。让我们来看看它在两种语言中是如何应用的。</p><h2 id="cf98" class="mp lt jg bd lu mq mr dn ly ms mt dp mc le mu mv me li mw mx mg lm my mz mi na bi translated">整数范围</h2><p id="8b6e" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">如果我们需要，比方说一个从4到10的整数范围，这表示如下:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="f03c" class="mp lt jg ng b gy nk nl l nm nn">Python: <strong class="ng jh">range(4,11)  </strong>                  Julia: <strong class="ng jh">4:10</strong></span></pre><p id="6cd2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在Julia中，当指定范围时，下限和上限是包含的，而在Python中，下限是包含的，上限是不包含的。所以我们必须给出一个11的上限，如果我们想让Python中的数字达到10的话。</p><h2 id="9d66" class="mp lt jg bd lu mq mr dn ly ms mt dp mc le mu mv me li mw mx mg lm my mz mi na bi translated">数组中的一组元素</h2><p id="1ed7" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">如果我们有一个数组<code class="fe no np nq ng b">a</code>并且想要提取第4到第10个元素，我们必须写:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="e7dd" class="mp lt jg ng b gy nk nl l nm nn">Python: <strong class="ng jh">a[3:10]</strong>                       Julia: <strong class="ng jh">a[4:10]</strong></span></pre><p id="aaed" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在Python中，数组(列表)的索引从零开始，所以第4个元素的索引为3。同样，上限是唯一的。因此，要指定我们想要的元素一直到第10个元素(它的索引是9)，我们必须在那里放一个10。</p><p id="efb1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如我们在这里看到的，在Julia中使用了与上面完全相同的表达式。而且不仅仅是完全相同的表达式，还有<em class="lr">相同的</em> (range)对象。它可以像上面一样“独立”使用，也可以作为一个数组的参数进行索引。</p><h2 id="efff" class="mp lt jg bd lu mq mr dn ly ms mt dp mc le mu mv me li mw mx mg lm my mz mi na bi translated">从中抽取随机数的范围</h2><p id="d0b3" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">以下表达式用于生成范围从4到10的随机数:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="ccb8" class="mp lt jg ng b gy nk nl l nm nn">Python: <strong class="ng jh">randint(4,10) </strong>               Julia: <strong class="ng jh">rand(4:10)</strong></span></pre><p id="4c59" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在Python中，上限在这种情况下是包含的，因此偏离了常见的概念。在Julia中，我们将上面介绍的<em class="lr">完全相同的</em> range对象作为参数传递给函数<code class="fe no np nq ng b">rand</code>。</p><h2 id="93e1" class="mp lt jg bd lu mq mr dn ly ms mt dp mc le mu mv me li mw mx mg lm my mz mi na bi translated">引入步长</h2><p id="4152" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">如果我们不希望<em class="lr">每个</em>元素都在一个范围内，而是例如每隔一个元素，这可以在两种语言中使用<em class="lr">步长</em>来指定(在本例中，步长为2，而不是1)。所以为了得到从4到10的每隔一秒的数字，我们写:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="57d4" class="mp lt jg ng b gy nk nl l nm nn">Python: <strong class="ng jh">range(4,11,2)   </strong>            Julia: <strong class="ng jh">4:2:10</strong></span></pre><p id="e203" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在Julia中，这个扩展版本也只是一个范围对象。所以它可以用在每一个指定range对象的地方，特别是在上面的例子中指定一个数组的子范围或者指定从中抽取随机数的范围。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="454a" class="mp lt jg ng b gy nk nl l nm nn">                                    Julia: <strong class="ng jh">a[4:2:10]<br/>                                           rand(4:2:10)</strong></span></pre><p id="4444" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这在Python中是不可能的。</p><h2 id="fab3" class="mp lt jg bd lu mq mr dn ly ms mt dp mc le mu mv me li mw mx mg lm my mz mi na bi translated">其他种类的范围</h2><p id="c497" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">当然不仅仅是整数的范围。下一个示例显示了2022年4月8日的三个<strong class="kx jh">小时时间戳</strong>(从12:00到14:00):</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="62cf" class="mp lt jg ng b gy nk nl l nm nn">Python: <strong class="ng jh">pandas.data_range(start='08/04/2022 12:00', <br/>                          periods=3, freq='H')</strong></span><span id="1080" class="mp lt jg ng b gy nr nl l nm nn">Julia:  <strong class="ng jh">DateTime(2022,4,8,12):Hour(1):DateTime(2022,4,8,14)</strong></span></pre><p id="5950" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">可以看出，在Julia中，使用了与整数范围相同的基本语法(<code class="fe no np nq ng b">lower:step:upper</code>)。</p><p id="f3a2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在Julia中，这也可以应用于其他数据类型，比如字符。这里我们指定了一个从‘d’到‘k’的字符范围:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="b189" class="mp lt jg ng b gy nk nl l nm nn">                                  Julia: '<strong class="ng jh">d':'k'</strong></span></pre><p id="5837" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这在Python中是不可能的。</p><h1 id="21d8" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">索引</h1><p id="c1ea" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">本文中使用的第二个示例演示了如何应用一致(或不一致)的概念，它是二维数组式数据结构的索引。</p><h2 id="8646" class="mp lt jg bd lu mq mr dn ly ms mt dp mc le mu mv me li mw mx mg lm my mz mi na bi translated">访问矩阵中的元素</h2><p id="9928" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">为了访问一个矩阵<code class="fe no np nq ng b">m</code>(一个二维数组)的第2行第4列的元素，我们写:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="6352" class="mp lt jg ng b gy nk nl l nm nn">Python: <strong class="ng jh">m[1][3]</strong>                   Julia: <strong class="ng jh">m[2,4]</strong></span></pre><p id="9003" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在Python中使用了列表的列表(因为在基本库中没有<em class="lr"> n </em>维数组)。因此，索引这样的结构是一个两步过程(并且需要两倍的括号)。同样，在Python中，索引从零开始，第2行的索引是1，第4列的索引是3。</p><h2 id="5512" class="mp lt jg bd lu mq mr dn ly ms mt dp mc le mu mv me li mw mx mg lm my mz mi na bi translated">访问数据帧中的元素</h2><p id="8bf2" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">要获得<em class="lr">数据帧</em> <code class="fe no np nq ng b">df</code>(类似于数据库表的二维数据结构)第2行第4列的元素，我们必须编写:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="f702" class="mp lt jg ng b gy nk nl l nm nn">Python: <strong class="ng jh">df.iloc[1,3]</strong>              Julia: <strong class="ng jh">df[2,4]</strong></span></pre><p id="fbd5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在Julia中，这与上面的符号完全相同。</p><p id="d199" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">与Python中用来表示矩阵的列表相比，<em class="lr"> DataFrame </em>是真正的二维结构。因此指数可以写在<em class="lr">一对</em>括号内。</p><h2 id="2ff1" class="mp lt jg bd lu mq mr dn ly ms mt dp mc le mu mv me li mw mx mg lm my mz mi na bi translated">访问数据帧中的一系列元素</h2><p id="e20a" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">数据框中的每一列都有一个名称。这些名称也可以用来引用列。因此，如果我们希望将第4行到第10行的元素放在名为“A”和“B”的列中，我们编写:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="49d8" class="mp lt jg ng b gy nk nl l nm nn">Python: <strong class="ng jh">df.loc[3:10,[“A”,“B”]]</strong>    Julia: <strong class="ng jh">df[4:10,[“A”,“B”]]</strong></span></pre><h2 id="6c55" class="mp lt jg bd lu mq mr dn ly ms mt dp mc le mu mv me li mw mx mg lm my mz mi na bi translated">为矩阵元素赋值</h2><p id="4232" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">为了给矩阵<code class="fe no np nq ng b">m</code>的第2行第4列中的矩阵元素赋值5，我们必须写出:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="5420" class="mp lt jg ng b gy nk nl l nm nn">Python: <strong class="ng jh">m[1][3] = 5</strong>               Julia: <strong class="ng jh">m[2,4] = 5</strong></span></pre><h2 id="8638" class="mp lt jg bd lu mq mr dn ly ms mt dp mc le mu mv me li mw mx mg lm my mz mi na bi translated">为数据帧中的元素赋值</h2><p id="33c4" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">如果我们想将值5赋给<em class="lr">数据帧</em> <code class="fe no np nq ng b">df</code>的第2行第4列的元素，使用以下表达式:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="2265" class="mp lt jg ng b gy nk nl l nm nn">Python: <strong class="ng jh">df.iat[1,3] = 5</strong>          Julia: <strong class="ng jh">df[2,4] = 5</strong></span></pre><p id="5ef0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要将该值赋给“A”列第2行中的元素，我们编写:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="59af" class="mp lt jg ng b gy nk nl l nm nn">Python: <strong class="ng jh">df.at[1,”A”] = 5</strong>         Julia: <strong class="ng jh">df[2,”A”] = 5</strong></span></pre><h2 id="26ac" class="mp lt jg bd lu mq mr dn ly ms mt dp mc le mu mv me li mw mx mg lm my mz mi na bi translated">摘要</h2><p id="243d" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">为了在Python中索引一个矩阵(这是一个列表的列表),使用了由两个括号对组成的符号，而对于数据帧，必须使用一个与方法调用结合的括号对。每种分度(<code class="fe no np nq ng b">iloc, loc, iat, at</code>)都有不同的方法<em class="lr">。</em></p><p id="ef4f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在Julia中，所有这些情况都有一个共同的符号:两个索引总是放在一对括号中。就是这样。</p><h1 id="93a3" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">但是为什么呢？</h1><p id="8be5" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我认为很明显，Julia中更高程度的一致性使得这种语言更容易学习、阅读和使用。那么问题就来了:如果优势这么明显，为什么不用Python(或者其他某种一致性程度较低的编程语言)来做呢？</p><p id="5d26" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">简短的回答是:因为他们不能！</p><h2 id="f27e" class="mp lt jg bd lu mq mr dn ly ms mt dp mc le mu mv me li mw mx mg lm my mz mi na bi translated">更长的答案</h2><p id="450e" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">现在来看一个更长的答案:如果我们看一下幕后，那么例如在Julia中访问一个矩阵中的元素(比如<code class="fe no np nq ng b">m[2,4]</code>)就转化为对函数<code class="fe no np nq ng b">getindex</code>的调用，如下所示:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="2e29" class="mp lt jg ng b gy nk nl l nm nn">getindex(m, 2, 4)</span></pre><p id="5c68" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">带括号的符号只是这个函数调用的语法糖(由操作符重载启用)。这适用于所有的例子:</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="ns nt l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">使用“getindex”访问值[作者图片]</p></figure><p id="d6bd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些函数调用都是用不同类型的参数完成的:</p><figure class="nb nc nd ne gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nu"><img src="../Images/41057aef6d65c3a86670660d48bc9c75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BKXQlrvZrCOaQ-gU9qRoaQ.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">“getindex”的不同参数类型[图片由作者提供]</p></figure><p id="cf9d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">根据参数使用的数据类型，调用适当的<code class="fe no np nq ng b">getindex</code>实现。你可能已经猜到了:这就是著名的<em class="lr">多重调度</em>的工作原理！</p><p id="fd2d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以<em class="lr">多调度</em>最终有利于<em class="lr">一个</em>函数(<code class="fe no np nq ng b">getindex</code>)的一致使用，可以应用于<em class="lr">多个</em>类似的变体。此外，它被裹在漂亮的衣服里(用括号表示)；但这只是为了更好的可读性的包装。核心是基于多重调度。因此，没有这个概念的编程语言不能提供这种程度的一致性。</p><p id="78ab" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">目前，仅Julia的基础库就有220种<code class="fe no np nq ng b">getindex</code>变体。所以它确实允许这个概念的广泛应用。</p><h2 id="650b" class="mp lt jg bd lu mq mr dn ly ms mt dp mc le mu mv me li mw mx mg lm my mz mi na bi translated">赋值</h2><p id="af1a" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">向矩阵状结构的元素赋值的例子以类似的方式工作。他们用<code class="fe no np nq ng b">setindex!</code>代替<code class="fe no np nq ng b">getindex</code>。所以这里的机制是一样的。</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="ns nt l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">使用“setindex”赋值[图片作者]</p></figure><h2 id="a7fd" class="mp lt jg bd lu mq mr dn ly ms mt dp mc le mu mv me li mw mx mg lm my mz mi na bi translated">靶场的幕后</h2><p id="1a82" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">现在来看使用范围的例子:上面所有指定范围的表达式都表示类型为<code class="fe no np nq ng b">UnitRange</code>(默认步长为1)或<code class="fe no np nq ng b">StepRange</code>(使用其他步长)的对象。两种类型都是抽象类型<code class="fe no np nq ng b">AbstractRange</code>的子类型，如下图所示:</p><figure class="nb nc nd ne gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nv"><img src="../Images/04eabd370e9c46a04de6b554aa2aff6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cGRx9L2Ic-oRGXPeugBMUA.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">范围的类型层次结构[按作者分类的图像]</p></figure><p id="d3a0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">举个例子</p><ul class=""><li id="d285" class="nw nx jg kx b ky kz lb lc le ny li nz lm oa lq ob oc od oe bi translated"><code class="fe no np nq ng b">4:10</code>是一个<code class="fe no np nq ng b">UnitRange{Int64}</code>类型的对象(花括号中的<code class="fe no np nq ng b">Int64</code>告诉我们，范围的下限和上限都是这个整数类型)，</li><li id="7032" class="nw nx jg kx b ky of lb og le oh li oi lm oj lq ob oc od oe bi translated"><code class="fe no np nq ng b">4:2:10</code>一个类型为<code class="fe no np nq ng b">StepRange{Int64, Int64}</code>的对象(这里的边界和步骤都属于类型<code class="fe no np nq ng b">Int64</code>)和</li><li id="fbf4" class="nw nx jg kx b ky of lb og le oh li oi lm oj lq ob oc od oe bi translated"><code class="fe no np nq ng b">DateTime(2022,4,8,12):Hour(1):DateTime(2022,4,8,14)</code> <br/>属于<code class="fe no np nq ng b">StepRange{DateTime, Hour}</code>类型。</li></ul><p id="ef24" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后再一次<em class="lr">多重分派</em>来到游戏中:</p><ul class=""><li id="21a2" class="nw nx jg kx b ky kz lb lc le ny li nz lm oa lq ob oc od oe bi translated">正如我们在上面所学的，用<code class="fe no np nq ng b">a[4:10]</code>访问一个数组的一系列元素会转化为<code class="fe no np nq ng b">getindex(a, 4:10)</code>。因此有一个<code class="fe no np nq ng b">getindex</code>的实现，它接受<code class="fe no np nq ng b">AbstractRange</code>的一个子类型作为索引参数(除了使用整数的“经典”索引和相当多的其他变化)。</li><li id="78c8" class="nw nx jg kx b ky of lb og le oh li oi lm oj lq ob oc od oe bi translated">使用<code class="fe no np nq ng b">rand(4:10)</code>从一系列数字中抽取一个随机数意味着有一个<code class="fe no np nq ng b">rand</code>的实现(在其他版本中)，它接受一个<code class="fe no np nq ng b">AbstractRange</code>的子类型作为它的参数。</li></ul><p id="1012" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以最终它也归结为<em class="lr">多重分派</em>的应用(它本质上依赖于Julia类型系统，可以由用户定义的类型任意扩展)。</p><h2 id="f3f5" class="mp lt jg bd lu mq mr dn ly ms mt dp mc le mu mv me li mw mx mg lm my mz mi na bi translated">和更多的句法糖</h2><p id="7a38" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">对于那些感兴趣的人来说:使用冒号如<code class="fe no np nq ng b">4:10</code>或<code class="fe no np nq ng b">4:2:10</code>的范围符号也只是普通函数调用的语法上更好的版本(同样基于操作符重载)。在这种情况下，它是功能<code class="fe no np nq ng b">range</code>。</p><p id="916b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以<code class="fe no np nq ng b">4:10</code>实际上是<code class="fe no np nq ng b">range(4, 10)</code><code class="fe no np nq ng b">4:2:10</code>相当于<code class="fe no np nq ng b">range(4, 10, step = 2)</code>(其中<em class="lr">步长</em>是可选的关键字自变量；这就是为什么在这个例子中关键字<code class="fe no np nq ng b">step</code>是必要的)。</p><h1 id="a071" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">结论</h1><p id="921d" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">使用像<em class="lr">索引</em>和<em class="lr">范围</em>这样的例子，我们可以看到事物可以在Julia中以非常一致的方式表达，这使得语言易于学习，易于阅读，最终也易于使用。</p><p id="e752" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种一致性是通过一些强大的概念实现的，如<em class="lr">多重分派</em>，一个<em class="lr">可扩展类型系统</em>和<em class="lr">操作符重载</em>，这些概念都经过精心制作，以便无缝地协同工作。</p></div></div>    
</body>
</html>