<html>
<head>
<title>5 dbt Modelling Tricks To Learn</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">要学习的5个dbt建模技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-dbt-modelling-tricks-to-learn-2d4928cc7433#2022-10-04">https://towardsdatascience.com/5-dbt-modelling-tricks-to-learn-2d4928cc7433#2022-10-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4ba5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">充分利用dbt(以及快速介绍)</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ceed8655468c2f2355f141e75d4c0661.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aSfghBaBdSanrim1"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@ikukevk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯文·Ku</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="54b5" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">作为“现代数据堆栈”的一部分，dbt是一个最近广受欢迎的工具。这是一个非常棒的工具，它支持直接在SQL中执行数据转换，使分析师和分析工程师能够专注于将业务逻辑转换为模型，而不是数据工程师倾向于关注的管道、编排和读/写细微差别。</p><p id="15a8" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">它还<a class="ae ky" href="https://docs.getdbt.com/docs/building-a-dbt-project/jinja-macros" rel="noopener ugc nofollow" target="_blank">支持jinja模板语言</a>，正如我们将在下面看到的，当创建我们的数据模型时，它产生了一大堆额外的选项。在本文中，我们将重点关注dbt特性，这些特性可用于简化和增强我们的数据建模项目，创建可用于整个项目的有用且可重复的逻辑。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="20a0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">刚接触dbt？</h1><p id="831d" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">如果您正在阅读这篇文章，那么您可能已经使用过或者至少听说过某种形式的dbt，但是如果您是使用dbt的新手，我建议您首先回顾并理解他们常见的<a class="ae ky" href="https://docs.getdbt.com/guides/legacy/best-practices" rel="noopener ugc nofollow" target="_blank">最佳实践</a>。这些并不是dbt建模的全部，但是遵循这些将有助于您的项目结构，并减少未来重构的需要。</p><p id="4907" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我会特别考虑:</p><ol class=""><li id="20aa" class="mz na it li b lj lk lm ln lp nb lt nc lx nd mb ne nf ng nh bi translated"><strong class="li iu">文件夹管理</strong> —这定义了文件树和数据库中数据模型的最终结构。您想要“dim”和“fact”文件前缀吗？基于模式或产品领域的文件夹？</li><li id="99aa" class="mz na it li b lj ni lm nj lp nk lt nl lx nm mb ne nf ng nh bi translated"><strong class="li iu"> SQL和样式指南</strong>—为构成模型的SQL创建一个约定(大小写、跳转、连接等)。)，以及dbt模型(如何使用cte和子查询)。如果对自动化这些检查感兴趣，你可以看看使用类似于<a class="ae ky" href="https://github.com/sqlfluff/sqlfluff" rel="noopener ugc nofollow" target="_blank"> sqlfluff </a>的东西。</li><li id="3eda" class="mz na it li b lj ni lm nj lp nk lt nl lx nm mb ne nf ng nh bi translated"><strong class="li iu">模型引用</strong> —为了使dbt能够完成它的工作，您应该使用<code class="fe nn no np nq b">{{ ref() }}</code> jinja引用模型，以便dbt能够推断模型依赖关系并从上游表中正确构建。<code class="fe nn no np nq b">{{ source() }}</code> jinja应该只使用一次来从原始数据库中选择，并且永远不应该使用直接模型引用。</li><li id="2b7e" class="mz na it li b lj ni lm nj lp nk lt nl lx nm mb ne nf ng nh bi translated"><strong class="li iu">重用模型逻辑</strong> —逻辑应尽可能向上游移动，以免重复(如列重命名)。如果您经常在多个数据模型中重用相同的逻辑，也许您可以将该逻辑本身转换成一个单独的数据模型，并将其移动到上游，这样就可以简单地用<code class="fe nn no np nq b">{{ ref() }}</code>引用它。</li><li id="0760" class="mz na it li b lj ni lm nj lp nk lt nl lx nm mb ne nf ng nh bi translated"><strong class="li iu">分析层</strong> —一旦开发了dbt项目，您可能会因为“循环依赖”而遇到错误，其中两个模型相互依赖。我发现解决这个问题的最好方法是拥有多个模型层，其中每一层只引用其下一层中的模型。有一些关于你如何解决这个问题的文件。</li></ol><p id="3302" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">现在谈谈您可能还没有遇到过的主要dbt技巧…</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/8d61bc14dd4cb8ea2a5d40d5b5b71606.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fBB-9X4_x36ZehQM"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">塞缪尔·里甘-阿桑特在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="b161" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.快照</h1><p id="326e" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated"><a class="ae ky" href="https://docs.getdbt.com/docs/building-a-dbt-project/snapshots" rel="noopener ugc nofollow" target="_blank"> dbt快照</a>是实现类型2渐变维度的一种简单方法，使分析师能够更轻松地执行数据检查，例如数据值或分析指标何时以及为何发生变化。</p><p id="0205" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这些更改是通过添加了<code class="fe nn no np nq b">dbt_valid_from</code>和<code class="fe nn no np nq b">dbt_valid_to </code>列的行快照实现的，当前有效的行有<code class="fe nn no np nq b">dbt_valid_to=null</code>。但是，这些列仅在每次运行快照时更新，因此，如果快照每小时运行一次，并且在此期间状态发生多次更改，则只有最新的值会被捕获为更改。因此，这并不能取代实际的数据监控解决方案，如审计数据库或向数据库中写入产品列，如<code class="fe nn no np nq b">status_value_at</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="3682" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这里从<code class="fe nn no np nq b">product_sales</code>表中创建了一个快照。与常用的<code class="fe nn no np nq b">updated_at</code>策略不同，<code class="fe nn no np nq b">check</code>策略(包含所有列)使快照能够自动包含新的表列。相反，如果从源表中删除了列，快照将保留这些列。</p><h1 id="6e4b" class="mc md it bd me mf nu mh mi mj nv ml mm jz nw ka mo kc nx kd mq kf ny kg ms mt bi translated">2.代理键</h1><p id="30dc" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">dbt-utils包有一个有用的代理键宏<a class="ae ky" href="https://github.com/dbt-labs/dbt-utils#surrogate_key-source" rel="noopener ugc nofollow" target="_blank">,它实现了主键的生成。这对于为唯一主键创建dbt测试非常有用，对于在Looker等BI工具中使用该模型也非常有用，因为Looker需要专门定义主键才能正确执行聚合。</a></p><p id="47d5" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">例如，如果我们为其创建快照的<code class="fe nn no np nq b">product_sales</code>表没有<code class="fe nn no np nq b">id</code>列，我们可以很容易地从两个分组列中创建这个主键。</p><pre class="kj kk kl km gt nz nq oa ob aw oc bi"><span id="a944" class="od md it nq b gy oe of l og oh">select<br/>{{ dbt_utils.surrogate_key(['product_id', 'month']) }} as product_sale_id</span></pre><h1 id="6a80" class="mc md it bd me mf nu mh mi mj nv ml mm jz nw ka mo kc nx kd mq kf ny kg ms mt bi translated">3.在枢轴上转动</h1><p id="0bf0" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">再次回到dbt-utils包，这次是针对<a class="ae ky" href="https://github.com/dbt-labs/dbt-utils/blob/main/macros/sql/pivot.sql" rel="noopener ugc nofollow" target="_blank"> pivot宏</a>。在SQL中，我们经常使用CASE语句来对总数进行分段，以便进行进一步的分析，例如在创建产品销售的群组视图来查看逐月业绩时。</p><pre class="kj kk kl km gt nz nq oa ob aw oc bi"><span id="3739" class="od md it nq b gy oe of l og oh">select<br/>  product_id,<br/>  sum(case when month = 'jan' then amount else 0 end) as amount_jan,<br/>  sum(case when month = 'feb' then amount else 0 end) as amount_feb,<br/>  sum(case when month = 'mar' then amount else 0 end) as amount_mar<br/>from product_sales<br/>group by 1<br/>order by product_id</span></pre><p id="b8f9" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">但是随着我们希望透视的列数的增加，这种语法很快就会变得很麻烦。如果我们有20个月，我真的不想为每一列复制和粘贴相同的SQL逻辑，如果逻辑发生变化，那么我需要更新20行。</p><p id="b31e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">相反，我们可以使用dbt pivot util只用几行代码就可以做到这一点。缺点是这在cte上不起作用，只能在物化数据上起作用。因此，如果我们想要引用的模型不存在，我们需要创建它或使用另一个解决方案(如<a class="ae ky" rel="noopener" target="_blank" href="/5-snowflake-query-tricks-you-arent-using-but-should-be-7f264b2a72d8">雪花的枢纽函数</a>)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="30e9" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这里选择了行(product_id ),然后<code class="fe nn no np nq b">dbt_utils.pivot</code>函数接受要透视的列名的参数和要转换成列(month)的行值。这个宏是通过CASE WHEN语句so实现的，默认为<code class="fe nn no np nq b">then 1 else 0 end</code>，但是这里我们设置了<code class="fe nn no np nq b">then_value</code>，所以结果是<code class="fe nn no np nq b">then amount else 0 end</code>。</p><h1 id="7c08" class="mc md it bd me mf nu mh mi mj nv ml mm jz nw ka mo kc nx kd mq kf ny kg ms mt bi translated">4.试验</h1><p id="fef3" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">dbt附带了四个通用测试，有助于涵盖您可能执行的一般数据完整性测试。这些是<code class="fe nn no np nq b">unique</code>、<code class="fe nn no np nq b">not_null</code>、<code class="fe nn no np nq b">accepted_values</code>和<code class="fe nn no np nq b">relationship</code>测试。通过项目yaml文件可以很容易地实现<a class="ae ky" href="https://docs.getdbt.com/docs/building-a-dbt-project/tests" rel="noopener ugc nofollow" target="_blank">通用测试</a>和文档，并且测试将在每次运行时与数据模型一起被检查。</p><p id="0345" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这里有一个通用的主键检查，通常应该应用于每个数据模型。</p><pre class="kj kk kl km gt nz nq oa ob aw oc bi"><span id="26ee" class="od md it nq b gy oe of l og oh">version: 2</span><span id="4e25" class="od md it nq b gy oi of l og oh">models:<br/>  - name: product_sales<br/>    description: |<br/>      Area: Product<br/>      Table of product sales each month.<br/>    columns:<br/>      - name: product_sale_id<br/>        description: "Primary key"<br/>        tests:<br/>          - unique<br/>          - not_null</span></pre><p id="5689" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">可能导致问题的是，如果dbt测试失败，将不会构建dbt模型。这可能意味着，如果不能设置测试的严格性，我们就不能在非主键列上添加健全性测试，比如<code class="fe nn no np nq b">accepted_values</code>或<code class="fe nn no np nq b">not_null</code>。</p><pre class="kj kk kl km gt nz nq oa ob aw oc bi"><span id="6487" class="od md it nq b gy oe of l og oh">columns:<br/>  - name: month<br/>    description: "Month of sale."<br/>    tests:<br/>      - not_null<br/>      - accepted_values:<br/>          values: ['jan', 'feb', 'mar]<br/>          config:<br/>            severity: warn</span></pre><h1 id="210e" class="mc md it bd me mf nu mh mi mj nv ml mm jz nw ka mo kc nx kd mq kf ny kg ms mt bi translated">5.宏指令</h1><p id="b814" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">除了非常有用的dbt-utils包，我们还可以创建自己的宏。要使用它们，请确保<a class="ae ky" href="https://docs.getdbt.com/reference/project-configs/macro-paths" rel="noopener ugc nofollow" target="_blank">将它们添加到dbt项目路径</a>。这对于创建可以多次重用的代码片段非常有用，正如我们看到的dbt-utils pivot函数的实现一样。</p><p id="4b35" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这种用例的一个例子是获取表中所有未删除的行。可能是快照，原始数据是Fivetran同步的，有一个deleted_at列。最好用<code class="fe nn no np nq b">{{ active_table(table) }}</code>来实现这一点，而不是在代码的多个地方添加3个不同的WHERE子句。</p><p id="3307" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">另一个例子是，尽管<a class="ae ky" href="https://docs.snowflake.com/en/sql-reference/functions/min.html" rel="noopener ugc nofollow" target="_blank"> min/max </a>返回忽略雪花中的空值的最小值/最大值，但是对于日期<a class="ae ky" href="https://docs.snowflake.com/en/sql-reference/functions/greatest.html" rel="noopener ugc nofollow" target="_blank">最大值</a> / <a class="ae ky" href="https://docs.snowflake.com/en/sql-reference/functions/least.html" rel="noopener ugc nofollow" target="_blank">最小值</a>，如果任何参数为空，则两者都返回空值。例如，如果我们想要获得许多日期中的第一个日期，以获得客户的第一个活动日期，这种行为可能会令人讨厌。为了减轻这种情况，我们必须用一个虚拟值合并每个参数…或者我们可以创建一个宏来完成这个任务。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="bae5" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">类似的<code class="fe nn no np nq b">dbt_least</code>值的虚拟值类似于<code class="fe nn no np nq b">'12/31/9999'</code>，所以在我写这篇文章的时候，它至少还能工作7977年！</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="bad8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最后的想法</h1><p id="d0da" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">dbt是用于构建数据模型的强大分析工程解决方案，使用户能够专注于创建健壮的业务逻辑，而不是担心加载和写入数据的细节。我们快速介绍了dbt和一些重要的初始项目注意事项，然后介绍了dbt-utils包中一些有用的特性和宏。这有助于改进一般语法，避免重复代码块，并减少最终数据模型中可能出现的错误。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="2265" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果你喜欢这篇文章，你可以找到更多的文章，并在我的<a class="ae ky" href="https://medium.com/@anthonyli358" rel="noopener">个人资料</a>上关注我！</p></div></div>    
</body>
</html>