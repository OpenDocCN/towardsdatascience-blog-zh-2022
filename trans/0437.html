<html>
<head>
<title>Still Using Python to Aggregate Data? Here’s Why You Should Use SQL Instead</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">还在用Python聚合数据？以下是您应该使用SQL的原因</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/stop-using-python-to-aggregate-data-use-sql-instead-7781d6ea4f0c#2022-02-17">https://towardsdatascience.com/stop-using-python-to-aggregate-data-use-sql-instead-7781d6ea4f0c#2022-02-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4f1a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你在使用Python从数据库中提取原始数据吗？这可能是你的应用程序的一个巨大瓶颈。请改用SQL。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/92d6fe766e45efeac206144fddc4e6cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zzQ-GSGIMPUIvkGu"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查尔斯·德鲁维奥在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="b961" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据科学的新手——包括几年前的我——也面临同样的问题。他们使用Python做任何事情，从收集到存储和操作数据。当然，现代编程语言可以处理一切，但这真的是最好的策略吗？不是的，你今天就会知道为什么了。</p><p id="53b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQL不是最性感的语言，主要是因为它似乎已经存在很久了。每个人和他们的母亲都声称他们了解SQL，但是仅仅因为你能从一个表中取出所有的列并不意味着你是一个熟练的用户。</p><p id="ca28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天我们来看看下面的<strong class="lb iu">场景</strong>:一家公司在本地Postgres数据库中存储了数千万行数据。他们想知道在数据库上聚合数据比用Python获取所有数据并在那里进行聚合要快多少。</p><p id="7c31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不想看书？我曾以视频形式报道过相同的主题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="6dd3" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">使用Python创建合成数据集</h1><p id="1fed" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">首先，我们必须创建一个数据集。您需要安装Numpy、Pandas和Psycopg2(用于Postgres连接)。以下是进口货:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="2b93" class="ng mf it nc b gy nh ni l nj nk">import random<br/>import string<br/>import warnings<br/>import psycopg2<br/>import numpy as np<br/>import pandas as pd<br/>from datetime import datetime</span><span id="048c" class="ng mf it nc b gy nl ni l nj nk">np.random.seed = 42<br/>warnings.filterwarnings('ignore')</span></pre><p id="c846" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于数据，我们将创建一个从1920年到2020年的合成数据集，它将模拟公司不同部门的销售情况。以下是我们需要的函数:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="9814" class="ng mf it nc b gy nh ni l nj nk">def get_department() -&gt; str:<br/>    x = np.random.rand()<br/>    if x &lt; 0.2: return 'A'<br/>    elif 0.2 &lt;= x &lt; 0.4: return 'B'<br/>    elif 0.4 &lt;= x &lt; 0.6: return 'C'<br/>    elif 0.6 &lt;= x &lt; 0.8: return 'D'<br/>    else: return 'E'</span><span id="0be7" class="ng mf it nc b gy nl ni l nj nk">def gen_random_string(length: int = 32) -&gt; str:<br/>    return ''.join(random.choices(<br/>        string.ascii_uppercase + string.digits, k=length)<br/>    )</span><span id="75d0" class="ng mf it nc b gy nl ni l nj nk">date_range = pd.date_range(<br/>    start=datetime(1920, 1, 1),<br/>    end=datetime(2020, 1, 1),<br/>    freq='120s'<br/>)</span><span id="88d7" class="ng mf it nc b gy nl ni l nj nk">df_size = len(date_range)</span></pre><p id="57e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用它们来创建数据集:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="4362" class="ng mf it nc b gy nh ni l nj nk">df = pd.DataFrame({<br/>    'datetime': date_range,<br/>    'department': [get_department() for x in range(df_size)],<br/>    'items_sold': [np.random.randint(low=0, high=100) for x in range(df_size)],<br/>    'string': [gen_random_string() for x in range(df_size)],<br/>})</span></pre><p id="239d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它看起来是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/2e2dd8611e6b0a9d9378a4cb81c935ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dgYTkFXWT8642g0sRg_6pw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片1-合成的26M行数据集(图片由作者提供)</p></figure><p id="2d97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">超过26M的行分布在四列中。这不是看起来最真实的表，我会给你，但它仍然是一个体面的数据量。让我们将它转储到一个CSV文件中:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="da8c" class="ng mf it nc b gy nh ni l nj nk">df.to_csv('df.csv', index=False)</span></pre><p id="08bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它需要1，52 GB的磁盘空间，以今天的标准来看并不算大。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="9f02" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">将数据集加载到Postgres数据库</h1><p id="e941" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">下一步是在Postgres中创建一个表并加载CSV文件。首先放到表上——除了其他四个列之外，它还有一个主键列。我喜欢给列名添加前缀，但您不必这样做:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="8e50" class="ng mf it nc b gy nh ni l nj nk">CREATE TABLE department_sales(<br/>	dsl_id SERIAL PRIMARY KEY,<br/>	dsl_datetime TIMESTAMP,<br/>	dsl_department CHAR(1),<br/>	dsl_items_sold SMALLINT,<br/>	dsl_string VARCHAR(32)<br/>);</span></pre><p id="9ff7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发出以下命令将CSV文件的内容复制到我们的Postgres表中——记住要更改路径:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="a1bb" class="ng mf it nc b gy nh ni l nj nk">COPY department_sales(dsl_datetime, dsl_department, dsl_items_sold, dsl_string)<br/>FROM '/Users/dradecic/Desktop/df.csv'<br/>DELIMITER ','<br/>CSV HEADER;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/eeaf446a59c77e30d982fda9dd760b9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J1XfPQQKbHbEzoDk0WFCvA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图2-数据集复制结果(作者提供的图片)</p></figure><p id="4500" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这样——在不到50秒的时间内加载了超过2600万行。让我们运行一个<code class="fe no np nq nc b">SELECT</code>语句，看看是否一切正常:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="030f" class="ng mf it nc b gy nh ni l nj nk">SELECT * FROM department_sales;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/b2b45e6f54fb38bed5397306caf03f75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gr2jXAMBSs5iwCsDJkI8aA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图Postgres数据库中的合成数据集(图片由作者提供)</p></figure><p id="e8b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">确实如此——所以接下来让我们用Python加载数据。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="3603" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">选项1-用Python加载整个表</h1><p id="c9e7" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">使用Psycopg2中的<code class="fe no np nq nc b">connect()</code>方法通过Python建立数据库连接:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="edcf" class="ng mf it nc b gy nh ni l nj nk">conn = psycopg2.connect(<br/>    user='&lt;username&gt;',<br/>    password='&lt;password&gt;',<br/>    host='127.0.0.1',<br/>    port=5432,<br/>    database='&lt;db&gt;'<br/>)</span></pre><p id="adc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以通过DBMS发出与前面相同的<code class="fe no np nq nc b">SELECT</code>语句:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="f3be" class="ng mf it nc b gy nh ni l nj nk">%%time</span><span id="e3d7" class="ng mf it nc b gy nl ni l nj nk">df_department_sales = pd.read_sql("SELECT * FROM department_sales", conn)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/a9bb0582c82f4abf3c4013c4121317d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MXq3OYfQPFIUM-lR92S36w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图4 —将26M行从Postgres加载到Python所需的时间(图片由作者提供)</p></figure><p id="289f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">取26M行用了75秒，这还不算太糟。这主要是因为数据库不在云中。尽管如此，如果速度是关键，75秒可能是一段很长的等待时间。</p><p id="debc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们汇总数据。我们将按部门进行分组，并计算售出商品的总数:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="a60c" class="ng mf it nc b gy nh ni l nj nk">%%time</span><span id="0679" class="ng mf it nc b gy nl ni l nj nk">df_pd_sales_by_department = (<br/>    df_department_sales<br/>        .groupby('dsl_department')<br/>        .sum()<br/>        .reset_index()<br/>)[['dsl_department', 'dsl_items_sold']]</span><span id="aaf8" class="ng mf it nc b gy nl ni l nj nk">df_pd_sales_by_department</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/c341e046109090bb3c42f810f90eaa78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CrCLLs4B0XXzAUcGHVUo_g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图5 —每个部门售出商品的汇总视图(按作者分类)</p></figure><p id="8d64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不到一秒钟，这是意料之中的。我在<a class="ae ky" href="https://betterdatascience.com/macbook-m1-pro-vs-rtx3060ti/" rel="noopener ugc nofollow" target="_blank"> M1 Pro MacBook Pro 16" </a>上运行笔记本，速度非常快，所以结果并不令我惊讶。</p><p id="2569" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将进行另一次汇总，这次我们将按年份分组，并计算每年售出的商品总数:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="5bc0" class="ng mf it nc b gy nh ni l nj nk">%%time</span><span id="0102" class="ng mf it nc b gy nl ni l nj nk">df_pd_sales_by_year = (<br/>    df_department_sales<br/>        .groupby(df_department_sales['dsl_datetime'].dt.year)<br/>        .sum()<br/>        .reset_index()<br/>)[['dsl_datetime', 'dsl_items_sold']]</span><span id="92ef" class="ng mf it nc b gy nl ni l nj nk">df_pd_sales_by_year</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/945b879c2119368dd3cea58bb22fa02a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wd7cUx25KVl79hBJ9sVmMA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图6 —每年售出商品的汇总视图(按作者分类)</p></figure><p id="b7b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几乎相同的结果。总的来说，<strong class="lb iu">我们可以将运行时间四舍五入到77秒</strong>。接下来让我们检查数据库的性能。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="c2ed" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">选项#2 —用Python加载准备好的视图</h1><p id="ecc0" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">处理大量数据的最佳实践是在包含查询结果的数据库中创建视图。因此，我们必须先发出几条SQL语句。</p><h2 id="5135" class="ng mf it bd mg nu nv dn mk nw nx dp mo li ny nz mq lm oa ob ms lq oc od mu oe bi translated">基于Postgres数据库中的数据聚合创建视图</h2><p id="7d40" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">这个汇总了按部门销售的商品数量:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="7296" class="ng mf it nc b gy nh ni l nj nk">CREATE OR REPLACE VIEW v_sales_by_department AS (<br/>	SELECT <br/>		dsl_department AS "Department",<br/>		SUM(dsl_items_sold) AS "Total items sold"<br/>	FROM department_sales<br/>	GROUP BY dsl_department<br/>	ORDER BY 2 DESC<br/>);</span></pre><p id="7b10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看它是什么样子的:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="63c8" class="ng mf it nc b gy nh ni l nj nk">SELECT * FROM v_sales_by_department;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/fd8530034ccffc504ff5b6578b947625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*aXaIdlinVnciUkUcwVhmaQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图7 —每个部门视图销售的商品(按作者分类的图片)</p></figure><p id="cf78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如所料，这与我们在Python中的第一个聚合操作完全相同。在这里，让我们创建第二个视图，按年汇总销售额:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="70e4" class="ng mf it nc b gy nh ni l nj nk">CREATE OR REPLACE VIEW v_sales_by_year AS (<br/>	SELECT <br/>		EXTRACT(YEAR FROM dsl_datetime) AS "Year",<br/>		SUM(dsl_items_sold) AS "Total items sold"<br/>	FROM department_sales <br/>	GROUP BY "Year"<br/>);</span></pre><p id="58ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只是快速检查一下:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="fadc" class="ng mf it nc b gy nh ni l nj nk">SELECT * FROM v_sales_by_year;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/83aa5de145754f888343615ebe19f227.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*kHsLJf8FDaiIZK7rFBq0Kw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图8 —每年售出的商品视图(按作者分类)</p></figure><p id="0a64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一切看起来都很好，所以让我们用Python从这些视图中获取数据。</p><h2 id="32c2" class="ng mf it bd mg nu nv dn mk nw nx dp mo li ny nz mq lm oa ob ms lq oc od mu oe bi translated">用Python加载视图中的数据</h2><p id="d9e8" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">首先，让我们按部门获取销售数据:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="27df" class="ng mf it nc b gy nh ni l nj nk">%%time</span><span id="2bca" class="ng mf it nc b gy nl ni l nj nk">df_sales_by_department = pd.read_sql("SELECT * FROM v_sales_by_department", conn)<br/>df_sales_by_department</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/10f486c6aaf8064a5b64ada12a9427dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DxuWAKphy0JBOyrM-FRdSA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图9 —从Postgres数据库中获取v_sales_by_department(按作者排序)</p></figure><p id="c154" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">三个。奇怪。秒。让我们对“按年销售”视图进行同样的操作:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="87f0" class="ng mf it nc b gy nh ni l nj nk">%%time</span><span id="59f3" class="ng mf it nc b gy nl ni l nj nk">df_sales_by_year = pd.read_sql("SELECT * FROM v_sales_by_year", conn)<br/>df_sales_by_year</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/16045e548dc0e9edc9877c739e855389.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-jmM-R1E02bO1Ga7dh6CPw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图10 —从Postgres数据库中获取v_sales_by_year(作者图片)</p></figure><p id="9168" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有点长，但仍在合理范围内。<strong class="lb iu">我们可以将两者的运行时间四舍五入到10秒</strong>。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="b2ba" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">判决</h1><p id="9b9a" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">现在，您已经知道了——使用Python加载准备好的视图比动态获取整个表并进行聚合快8倍。请记住——本地Postgres数据库安装的速度要快8倍，如果我们将数据库迁移到云上，结果将远非如此。</p><p id="ff4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这是您想要看到的比较，请告诉我，我很乐意在后续文章中介绍它。</p><p id="a34e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个故事的寓意是——永远利用数据库来完成繁重的工作。这些系统设计用于处理数据。Python当然可以做到，但这不是它的主要用例。</p><h2 id="b0db" class="ng mf it bd mg nu nv dn mk nw nx dp mo li ny nz mq lm oa ob ms lq oc od mu oe bi translated">了解更多信息</h2><ul class=""><li id="00fd" class="oj ok it lb b lc mw lf mx li ol lm om lq on lu oo op oq or bi translated"><a class="ae ky" href="https://betterdatascience.com/top-books-to-learn-data-science/" rel="noopener ugc nofollow" target="_blank">2022年学习数据科学的5本最佳书籍</a></li><li id="9238" class="oj ok it lb b lc os lf ot li ou lm ov lq ow lu oo op oq or bi translated"><a class="ae ky" href="https://betterdatascience.com/apache-airflow-install/" rel="noopener ugc nofollow" target="_blank">如何在本地安装阿帕奇气流</a></li><li id="cc31" class="oj ok it lb b lc os lf ot li ou lm ov lq ow lu oo op oq or bi translated"><a class="ae ky" href="https://betterdatascience.com/google-colab-vs-rtx3060ti/" rel="noopener ugc nofollow" target="_blank">深度学习领域谷歌Colab vs. RTX3060Ti】</a></li></ul><h2 id="42af" class="ng mf it bd mg nu nv dn mk nw nx dp mo li ny nz mq lm oa ob ms lq oc od mu oe bi translated">保持联系</h2><ul class=""><li id="b79d" class="oj ok it lb b lc mw lf mx li ol lm om lq on lu oo op oq or bi translated">雇用我作为一名技术作家</li><li id="c6b9" class="oj ok it lb b lc os lf ot li ou lm ov lq ow lu oo op oq or bi translated">订阅<a class="ae ky" href="https://www.youtube.com/c/BetterDataScience" rel="noopener ugc nofollow" target="_blank"> YouTube </a></li><li id="1029" class="oj ok it lb b lc os lf ot li ou lm ov lq ow lu oo op oq or bi translated">在<a class="ae ky" href="https://www.linkedin.com/in/darioradecic/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上连接</li></ul></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><p id="4188" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ox">原载于2022年2月17日https://betterdatascience.com</em><a class="ae ky" href="https://betterdatascience.com/python-vs-sql-data-aggregation/" rel="noopener ugc nofollow" target="_blank"><em class="ox"/></a><em class="ox">。</em></p></div></div>    
</body>
</html>