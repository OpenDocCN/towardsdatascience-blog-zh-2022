<html>
<head>
<title>Build an Event-Driven Neural Style Transfer Application Using AWS Lambda</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用AWS Lambda构建一个事件驱动的神经风格传输应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-an-event-driven-neural-style-transfer-application-using-aws-lambda-18fa8145ef5b#2022-05-11">https://towardsdatascience.com/build-an-event-driven-neural-style-transfer-application-using-aws-lambda-18fa8145ef5b#2022-05-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/34c90deba4bb514c118d85144d079046.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KeLhxdf0WCUYshIyi2gfYw.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">在5个时期和每个时期100个步骤之后，生成神经类型转移图像(在右侧)</p></figure><p id="4c27" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了构建一个生产就绪的ML应用程序并确保它的长期稳定性，我们需要考虑一长串的需求，包括模型迭代的容易程度、可再现性、基础设施、自动化、资源、内存等等。最重要的是，我们需要一个<em class="la">无缝的开发者体验</em>。会有多难呢？</p><p id="19e8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae lb" href="https://github.com/flyteorg/flyte" rel="noopener ugc nofollow" target="_blank"> Flyte </a>可以处理前一组问题，因为:</p><ul class=""><li id="f2cc" class="lc ld iq ke b kf kg kj kk kn le kr lf kv lg kz lh li lj lk bi translated">这是一个工作流自动化平台，有助于维护和复制管道。</li><li id="d0f9" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated">它提供了基础设施、资源和内存的控制旋钮。</li></ul><p id="06ed" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">此外，Flyte简化了开发人员的体验。在这篇博文中，我们将看到如何使用Flyte和AWS Lambda构建一个神经风格的转换应用程序。我们将对端到端管道进行编码，并分配所需的计算来运行代码。此外，我们将设计一个事件驱动的机制来触发管道，并在用户上传图像时输出风格化的图像。<em class="la">从用户的角度来看，上传图像时必须生成风格化的输出图像。</em></p><p id="d60f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">由于应用程序必须在一个事件上被触发，例如，图像上传，对Flyte来说更合适的选择是使用AWS Lambda。它是无服务器和事件驱动的计算服务。我们的神经风格传输应用程序将利用AWS Lambda的“事件驱动特性”。</p><p id="fe34" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们看看如何使用Flyte和AWS Lambda将管道自动化和事件驱动的服务结合在一起。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9d2805424f70c7cdfd095a7328150d9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RMa64HiiEbe2afrmfU1B8A.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="lu">图一。应用程序概述(图片由作者提供)</em></p></figure><h1 id="b651" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">应用代码</h1><p id="6e85" class="pw-post-body-paragraph kc kd iq ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz ij bi translated">神经风格转移是将风格图像的风格应用到内容图像上。输出图像将是内容和样式图像的混合。</p><p id="d6e9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要开始使用代码，首先要导入并配置依赖项。</p><p id="1e24" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la">注意:此代码改编自TensorFlow文档</em>  <em class="la">中的</em> <a class="ae lb" href="https://www.tensorflow.org/tutorials/generative/style_transfer" rel="noopener ugc nofollow" target="_blank"> <em class="la">神经样式传递示例。运行代码，确保</em> <code class="fe my mz na nb b"><em class="la">tensorflow</em></code> <em class="la">、</em> <code class="fe my mz na nb b"><em class="la">flytekit</em></code> <em class="la">、</em> <code class="fe my mz na nb b"><em class="la">Pillow</em></code> <em class="la">库通过</em> <code class="fe my mz na nb b"><em class="la">pip</em></code> <em class="la">安装。</em></a></p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="ff6a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe my mz na nb b">content_layers</code>和<code class="fe my mz na nb b">style_layers</code>是VGG19模型的层，我们将使用它们来构建我们的模型，<code class="fe my mz na nb b">tensor_to_image</code>任务将张量转换为图像。</p><p id="2ae1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">模型建立过程的第一步是获取图像并对其进行预处理。定义一个<code class="fe my mz na nb b"><a class="ae lb" href="https://docs.flyte.org/projects/flytekit/en/latest/generated/flytekit.task.html" rel="noopener ugc nofollow" target="_blank">@task</a></code>来加载图像，并将其最大尺寸限制为512像素。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="0a68" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe my mz na nb b">preprocess_img</code>任务下载内容和样式图像文件，并使用<code class="fe my mz na nb b">load_img</code>函数调整它们的大小。</p><p id="3b31" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">准备好模型使用的数据后，定义一个返回样式和内容张量的VGG19模型。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><pre class="lq lr ls lt gt ne nb nf ng aw nh bi"><span id="faf3" class="ni lw iq nb b gy nj nk l nl nm">class <strong class="nb ir">StyleContentModel</strong>(tf.keras.models.Model):<br/>    def <strong class="nb ir">__init__</strong>(self, style_layers, content_layers):<br/>        super(StyleContentModel, self).__init__()<br/>        self.vgg = vgg_layers(style_layers + content_layers)<br/>        self.style_layers = style_layers<br/>        self.content_layers = content_layers<br/>        self.num_style_layers = len(style_layers)<br/>        self.vgg.trainable = False</span><span id="ea74" class="ni lw iq nb b gy nn nk l nl nm">    def <strong class="nb ir">call</strong>(self, inputs):<br/>        "Expects float input in [0,1]"<br/>        inputs = inputs * 255.0<br/>        preprocessed_input = tf.keras.applications.vgg19.preprocess_input(inputs)<br/>        outputs = self.vgg(preprocessed_input)<br/>        style_outputs, content_outputs = (<br/>            outputs[: self.num_style_layers],<br/>            outputs[self.num_style_layers :],<br/>        )<br/>        style_outputs = [gram_matrix(style_output) for style_output in style_outputs]<br/>        <strong class="nb ir">content_dict</strong> = {<br/>            content_name: value<br/>            for content_name, value in zip(self.content_layers, content_outputs)<br/>        }<br/>        <strong class="nb ir">style_dict</strong> = {<br/>            style_name: value<br/>            for style_name, value in zip(self.style_layers,    style_outputs)<br/>        }<br/>        return {"content": content_dict, "style": style_dict}</span></pre><p id="424b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe my mz na nb b">vgg_layers</code>函数返回中间层输出的列表，在该列表之上构建模型(注意，我们使用的是预训练的VGG网络)，而<code class="fe my mz na nb b">gram_matrix</code>函数<em class="la">字面上的</em>描述图像的风格。当在图像上调用模型时，它返回<code class="fe my mz na nb b">style_layers</code>的gram矩阵和<code class="fe my mz na nb b">content_layers</code>的内容。</p><p id="cd84" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">接下来是样式转换算法的实现。通过考虑两个损失的加权组合，计算总损失(样式+内容)。</p><pre class="lq lr ls lt gt ne nb nf ng aw nh bi"><span id="d11c" class="ni lw iq nb b gy nj nk l nl nm">def <strong class="nb ir">style_content_loss</strong>(outputs, content_targets, style_targets):<br/>    style_outputs = outputs["style"]<br/>    content_outputs = outputs["content"]<br/>    style_loss = tf.add_n(<br/>        [<br/>            tf.reduce_mean((style_outputs[name] - style_targets[name]) ** 2)<br/>            for name in style_outputs.keys()<br/>        ]<br/>    )<br/>    <strong class="nb ir">style_loss</strong> *= style_weight / len(style_layers)<br/>    content_loss = tf.add_n(<br/>        [<br/>            tf.reduce_mean((content_outputs[name] - content_targets[name]) ** 2)<br/>            for name in content_outputs.keys()<br/>        ]<br/>    )<br/>    <strong class="nb ir">content_loss</strong> *= content_weight / len(content_layers)<br/>    <strong class="nb ir">loss = style_loss + content_loss</strong><br/>    return loss</span></pre><p id="2d84" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">从<code class="fe my mz na nb b">tf.GradientTape</code>内调用<code class="fe my mz na nb b">style_content_loss</code>更新图像。</p><pre class="lq lr ls lt gt ne nb nf ng aw nh bi"><span id="9371" class="ni lw iq nb b gy nj nk l nl nm"><a class="ae lb" href="http://twitter.com/task" rel="noopener ugc nofollow" target="_blank"><strong class="nb ir">@task</strong></a><strong class="nb ir">(requests=Resources(cpu="1", mem="5Gi", storage="5Gi", ephemeral_storage="5Gi"))</strong><br/>def <strong class="nb ir">train_step</strong>(<br/>    image: tf.Variable, content_image: tf.Tensor, style_image: tf.Tensor<br/>) -&gt; tf.Variable:<br/>    opt = tf.optimizers.Adam(learning_rate=0.02, beta_1=0.99, epsilon=1e-1)<br/>    extractor = StyleContentModel(style_layers, content_layers)<br/>    style_targets = extractor(style_image)["style"]<br/>    content_targets = extractor(content_image)["content"]<br/>    <strong class="nb ir">with tf.GradientTape() as tape:<br/>        outputs = extractor(image)<br/>        loss = style_content_loss(outputs, content_targets, style_targets)<br/>        loss += total_variation_weight * tf.image.total_variation(image)</strong><br/>    grad = tape.gradient(loss, image)<br/>    opt.apply_gradients([(grad, image)])<br/>    image.assign(clip_0_1(image))<br/>    return image</span></pre><p id="5b6a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe my mz na nb b">train_step</code>任务初始化样式和内容目标值(张量)，计算总变化损失，运行梯度下降，应用处理过的梯度，并在0和1之间裁剪图像的像素值。如下定义<code class="fe my mz na nb b">clip_0_1</code>功能:</p><pre class="lq lr ls lt gt ne nb nf ng aw nh bi"><span id="9f3b" class="ni lw iq nb b gy nj nk l nl nm">def <strong class="nb ir">clip_0_1</strong>(image):<br/>    return tf.clip_by_value(image, clip_value_min=0.0, clip_value_max=1.0)</span></pre><p id="3a70" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">创建一个<code class="fe my mz na nb b"><a class="ae lb" href="https://docs.flyte.org/projects/flytekit/en/latest/generated/flytekit.dynamic.html#flytekit-dynamic" rel="noopener ugc nofollow" target="_blank">@dynamic</a></code>工作流，为指定数量的<code class="fe my mz na nb b">epochs</code>和<code class="fe my mz na nb b">steps_per_epoch</code>触发<code class="fe my mz na nb b">train_step</code>任务。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="7dd2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe my mz na nb b">tf.Variable</code>存储内容图像。当从<code class="fe my mz na nb b">tf.GradientTape</code>内调用时，<code class="fe my mz na nb b">image</code>，一个<code class="fe my mz na nb b">tf.Variable</code>被观察，操作被记录，用于自动微分。</p><p id="003b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，定义一个<code class="fe my mz na nb b"><a class="ae lb" href="https://docs.flyte.org/projects/flytekit/en/latest/generated/flytekit.workflow.html" rel="noopener ugc nofollow" target="_blank">@workflow</a></code>来封装任务并生成风格化的图像。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="e8b5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一旦管道被<a class="ae lb" href="https://docs.flyte.org/en/latest/deployment/aws/index.html" rel="noopener ugc nofollow" target="_blank">部署</a>，接下来的步骤将是设置S3桶和配置Lambda。</p><h1 id="a6b5" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">配置AWS S3桶和Lambda</h1><p id="758b" class="pw-post-body-paragraph kc kd iq ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz ij bi translated">图像将被上传到S3桶，一旦图像被上传，Lambda将被用来触发Flyte工作流。</p><h2 id="e27f" class="ni lw iq bd lx no np dn mb nq nr dp mf kn ns nt mj kr nu nv mn kv nw nx mr ny bi translated">S3水桶</h2><p id="fc50" class="pw-post-body-paragraph kc kd iq ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz ij bi translated">要配置S3存储桶，</p><ol class=""><li id="8193" class="lc ld iq ke b kf kg kj kk kn le kr lf kv lg kz nz li lj lk bi translated">打开<a class="ae lb" href="https://console.aws.amazon.com/s3/" rel="noopener ugc nofollow" target="_blank">亚马逊S3控制台</a>。</li><li id="54db" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz nz li lj lk bi translated">选择<strong class="ke ir">桶</strong>。</li><li id="6db7" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz nz li lj lk bi translated">选择<strong class="ke ir">创建桶</strong>。</li><li id="3520" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz nz li lj lk bi translated">为存储桶命名，例如，“神经类型转移”。</li><li id="830a" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz nz li lj lk bi translated">选择适当的AWS区域(确保Lambda在同一个AWS区域中创建)。</li><li id="0b52" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz nz li lj lk bi translated">阻止或解除阻止公共访问(本教程假设授予了公共访问)。</li><li id="7a90" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz nz li lj lk bi translated">选择<strong class="ke ir">创建桶</strong>。</li></ol><h2 id="51d8" class="ni lw iq bd lx no np dn mb nq nr dp mf kn ns nt mj kr nu nv mn kv nw nx mr ny bi translated">希腊字母的第11个</h2><p id="3de3" class="pw-post-body-paragraph kc kd iq ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz ij bi translated">Lambda函数可以通过蓝图、容器映像或无服务器应用程序库从头开始创建。可以选择Blueprint来获取样本lambda代码，在我们的例子中，是一个S3 blueprint。然而，由于我们需要从Lambda内部连接到FlyteRemote，我们必须安装<code class="fe my mz na nb b">flytekit</code>库。Lambda内的库安装可以通过<a class="ae lb" href="https://docs.aws.amazon.com/lambda/latest/dg/python-package.html" rel="noopener ugc nofollow" target="_blank"> <em class="la"> zip文件</em> </a>或<a class="ae lb" href="https://docs.aws.amazon.com/lambda/latest/dg/images-create.html" rel="noopener ugc nofollow" target="_blank"> <em class="la">容器镜像</em> </a>的方式实现。</p><p id="e175" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Zip文件是让<code class="fe my mz na nb b">flytekit</code>进入Lambda的最简单的方法，但是由于它对zip文件的大小限制，更可行的方法是使用容器映像方法。</p><h2 id="f237" class="ni lw iq bd lx no np dn mb nq nr dp mf kn ns nt mj kr nu nv mn kv nw nx mr ny bi translated">容器图像</h2><p id="094e" class="pw-post-body-paragraph kc kd iq ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz ij bi translated">要在您的机器上创建容器映像:</p><p id="54df" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">1.创建一个项目目录(例如lambda)来容纳lambda函数。</p><p id="387e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">2.在目录中创建4个文件:<code class="fe my mz na nb b">lambda_function.py</code>、<code class="fe my mz na nb b">Dockerfile</code>、<code class="fe my mz na nb b">requirements.txt</code>和<code class="fe my mz na nb b">flyte.config</code>。</p><pre class="lq lr ls lt gt ne nb nf ng aw nh bi"><span id="37fa" class="ni lw iq nb b gy nj nk l nl nm">lambda<br/> ├── Dockerfile<br/> ├── flyte.config<br/> ├── lambda_function.py<br/> └── requirements.txt</span></pre><p id="cc6e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">3.<code class="fe my mz na nb b">lambda_function.py</code>:封装代码获取上传的图片，实例化一个<a class="ae lb" href="https://docs.flyte.org/projects/flytekit/en/latest/design/control_plane.html#design-control-plane" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> FlyteRemote </strong> </a>对象，触发Flyte工作流。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="oa nd l"/></div></figure><p id="46bd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">ℹ️ FlyteRemote提供了一个编程接口来与Flyte后端进行交互。</p><p id="2bbb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">务必填写<code class="fe my mz na nb b">endpoint</code>、<code class="fe my mz na nb b">default_project</code>(如<code class="fe my mz na nb b">flytesnacks</code>)、<code class="fe my mz na nb b">default_domain</code>(如<code class="fe my mz na nb b">development</code>)，以及投放计划名称(如<code class="fe my mz na nb b">neural_style_transfer.example.neural_style_transfer_wf</code>)。</p><p id="a2a9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">4.<strong class="ke ir"> flyte.config </strong>:添加通过flyteRemote连接Flyte的配置。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="oa nd l"/></div></figure><p id="327c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">5.<strong class="ke ir"> requirements.txt </strong></p><pre class="lq lr ls lt gt ne nb nf ng aw nh bi"><span id="77d6" class="ni lw iq nb b gy nj nk l nl nm">flytekit&gt;=1.0.0</span></pre><p id="6ec2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">6.<strong class="ke ir"> Dockerfile </strong>:将<code class="fe my mz na nb b">lambda_function.py</code>、<code class="fe my mz na nb b">flyte.config</code>、<code class="fe my mz na nb b">requirements.txt</code>复制到根目录。将<code class="fe my mz na nb b">CMD</code>实例化为在<code class="fe my mz na nb b">lambda_function.py</code>文件中使用的处理程序。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="oa nd l"/></div></figure><p id="a22a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">7.使用以下命令在项目目录中构建Docker映像:</p><pre class="lq lr ls lt gt ne nb nf ng aw nh bi"><span id="d21d" class="ni lw iq nb b gy nj nk l nl nm">docker build -t neural-style-transfer .</span></pre><p id="c35f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">8.向Amazon ECR注册表验证Docker CLI。</p><pre class="lq lr ls lt gt ne nb nf ng aw nh bi"><span id="c311" class="ni lw iq nb b gy nj nk l nl nm">aws ecr get-login-password --region &lt;us-east-1&gt; | docker login --username AWS --password-stdin &lt;123456789012&gt;.dkr.ecr.&lt;us-east-1&gt;.amazonaws.com</span></pre><p id="ad20" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">确保替换<code class="fe my mz na nb b">&lt;&gt;</code>中的文本。</p><p id="2434" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">9.在ECR中创建一个存储库。</p><ul class=""><li id="4dc5" class="lc ld iq ke b kf kg kj kk kn le kr lf kv lg kz lh li lj lk bi translated">打开<a class="ae lb" href="https://console.aws.amazon.com/ecr/" rel="noopener ugc nofollow" target="_blank">亚马逊ECR控制台</a>。</li><li id="2df1" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated">选择<strong class="ke ir">储存库</strong>。</li><li id="1310" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated">选择<strong class="ke ir">创建存储库</strong>(如lambda)。</li></ul><p id="7574" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">10.标记您的Docker映像，并将映像推送到新创建的存储库中。</p><pre class="lq lr ls lt gt ne nb nf ng aw nh bi"><span id="a84f" class="ni lw iq nb b gy nj nk l nl nm">docker tag neural-style-transfer:latest &lt;123456789012&gt;.dkr.ecr.&lt;us-east-1&gt;.amazonaws.com/lambda:neural-style-transfer-latest</span><span id="eb18" class="ni lw iq nb b gy nn nk l nl nm">docker push &lt;123456789012&gt;.dkr.ecr.&lt;us-east-1&gt;.amazonaws.com/lambda:neural-style-transfer-latest</span></pre><p id="0754" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">确保替换注册表详细信息中的<code class="fe my mz na nb b">&lt;&gt;</code>中的文本。</p><p id="362b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">就是这样！您现在在ECR中有了自己的图像。</p><h2 id="5330" class="ni lw iq bd lx no np dn mb nq nr dp mf kn ns nt mj kr nu nv mn kv nw nx mr ny bi translated">λ配置</h2><p id="ddfe" class="pw-post-body-paragraph kc kd iq ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz ij bi translated">要配置Lambda，</p><ol class=""><li id="84c1" class="lc ld iq ke b kf kg kj kk kn le kr lf kv lg kz nz li lj lk bi translated">打开Lambda控制台的<a class="ae lb" href="https://console.aws.amazon.com/lambda/home#/functions" rel="noopener ugc nofollow" target="_blank">功能页面</a>。</li><li id="6308" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz nz li lj lk bi translated">选择<strong class="ke ir">创建功能</strong>。</li><li id="edbb" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz nz li lj lk bi translated">选择<strong class="ke ir">容器图像</strong>。</li><li id="c4ac" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz nz li lj lk bi translated">输入函数名(如s3-lambda)。</li><li id="2532" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz nz li lj lk bi translated">给<strong class="ke ir">容器镜像URI </strong>(应该可以在<a class="ae lb" href="https://console.aws.amazon.com/ecr/" rel="noopener ugc nofollow" target="_blank">亚马逊ECR控制台</a>-&gt;-<strong class="ke ir">仓库</strong>仪表盘中找到)。</li><li id="d3c5" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz nz li lj lk bi translated">选择<strong class="ke ir">创建功能</strong>。</li></ol><p id="a33f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您现在已经配置了lambda！</p><h1 id="fb22" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">许可</h1><p id="f77d" class="pw-post-body-paragraph kc kd iq ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz ij bi translated">S3水桶和拉姆达目前是分开的实体。为了在图像上传到S3桶时立即触发Lambda，我们必须在它们之间建立一个连接。</p><p id="7625" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">连接它们还需要设置所需的权限。但是在配置权限之前，复制bucket和Lambda ARNs。</p><p id="222a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">斗ARN </strong>:</p><ol class=""><li id="b9b8" class="lc ld iq ke b kf kg kj kk kn le kr lf kv lg kz nz li lj lk bi translated">打开<a class="ae lb" href="https://console.aws.amazon.com/s3/" rel="noopener ugc nofollow" target="_blank">亚马逊S3控制台</a>。</li><li id="b637" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz nz li lj lk bi translated">选择<strong class="ke ir">木桶</strong>。</li><li id="f0ff" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz nz li lj lk bi translated">选择你的桶。</li><li id="cbae" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz nz li lj lk bi translated">选择<strong class="ke ir">属性</strong>。</li><li id="a6a5" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz nz li lj lk bi translated">复制ARN。</li></ol><p id="931a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">λARN</strong>:</p><ol class=""><li id="b569" class="lc ld iq ke b kf kg kj kk kn le kr lf kv lg kz nz li lj lk bi translated">打开Lambda控制台的<a class="ae lb" href="https://console.aws.amazon.com/lambda/home#/functions" rel="noopener ugc nofollow" target="_blank">功能页面</a>。</li><li id="6b52" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz nz li lj lk bi translated">选择<strong class="ke ir">功能</strong>。</li><li id="8d7e" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz nz li lj lk bi translated">选择你的λ。</li><li id="b523" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz nz li lj lk bi translated">选择<strong class="ke ir">配置</strong>然后选择<strong class="ke ir">权限</strong>。</li><li id="b371" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz nz li lj lk bi translated">点击<strong class="ke ir">中的角色执行</strong>角色。</li><li id="b5c4" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz nz li lj lk bi translated">复制ARN。</li></ol><h2 id="e58a" class="ni lw iq bd lx no np dn mb nq nr dp mf kn ns nt mj kr nu nv mn kv nw nx mr ny bi translated">S3水桶</h2><p id="6461" class="pw-post-body-paragraph kc kd iq ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz ij bi translated">要设置S3存储桶的权限，请执行以下操作:</p><ol class=""><li id="4f57" class="lc ld iq ke b kf kg kj kk kn le kr lf kv lg kz nz li lj lk bi translated">转到您创建的S3存储桶。</li><li id="7344" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz nz li lj lk bi translated">选择<strong class="ke ir">权限</strong>。</li><li id="3b7e" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz nz li lj lk bi translated">在<strong class="ke ir">斗策</strong>中，选择<strong class="ke ir">编辑</strong>。</li><li id="9028" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz nz li lj lk bi translated">添加以下策略:</li></ol><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="oa nd l"/></div></figure><p id="063f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">确保填写Lambda执行角色ARN和S3桶ARN。</p><h2 id="05bb" class="ni lw iq bd lx no np dn mb nq nr dp mf kn ns nt mj kr nu nv mn kv nw nx mr ny bi translated">希腊字母的第11个</h2><p id="bcd2" class="pw-post-body-paragraph kc kd iq ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz ij bi translated">要为Lambda设置权限，请执行以下操作:</p><p id="f5d3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">1.遵循<em class="la">λARN</em>一节中概述的步骤1- 4。</p><p id="e890" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">2.在权限下，选择<strong class="ke ir">添加权限</strong>。</p><p id="67da" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">3.在下拉列表中，选择<strong class="ke ir">创建内嵌策略</strong>。</p><p id="bb41" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">4.在<strong class="ke ir"> JSON </strong>选项卡下，粘贴以下内容:</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="oa nd l"/></div></figure><p id="60ee" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请务必填写S3桶ARN。</p><p id="312c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">5.选择<strong class="ke ir">审核策略</strong>。</p><p id="9ace" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">6.对于<strong class="ke ir">名称</strong>，输入策略的名称。</p><p id="dcad" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">7.选择<strong class="ke ir">创建策略</strong>。</p><p id="7722" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您可以将<code class="fe my mz na nb b">FLYTE_CREDENTIALS_CLIENT_SECRET</code>添加到lambda的环境变量中，作为初始化FlyteRemote的一部分。为此:</p><ol class=""><li id="d352" class="lc ld iq ke b kf kg kj kk kn le kr lf kv lg kz nz li lj lk bi translated">遵循<em class="la">λARN</em>一节中概述的步骤1–3。</li><li id="ad48" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz nz li lj lk bi translated">选择<strong class="ke ir">配置</strong>然后选择<strong class="ke ir">环境变量</strong>。</li><li id="70a2" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz nz li lj lk bi translated">设置密钥为<code class="fe my mz na nb b">FLYTE_CREDENTIALS_CLIENT_SECRET</code>，值应该是你的秘密。</li></ol><p id="e557" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在有趣的部分来了——将lambda与S3桶联系起来！</p><h1 id="cfd4" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">引发</h1><p id="d29a" class="pw-post-body-paragraph kc kd iq ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz ij bi translated">要设置触发器，请执行以下操作:</p><ol class=""><li id="83cc" class="lc ld iq ke b kf kg kj kk kn le kr lf kv lg kz nz li lj lk bi translated">遵循<em class="la">λARN</em>一节中概述的步骤1–3。</li><li id="1494" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz nz li lj lk bi translated">选择<strong class="ke ir">配置</strong>然后选择<strong class="ke ir">触发</strong>。</li><li id="6c78" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz nz li lj lk bi translated">点击<strong class="ke ir">添加触发器</strong>。</li><li id="997c" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz nz li lj lk bi translated">在<strong class="ke ir">选择触发器</strong>下拉菜单中，选择S3。</li><li id="1d78" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz nz li lj lk bi translated">在<strong class="ke ir">铲斗</strong>下选择您的S3铲斗。</li><li id="e2f5" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz nz li lj lk bi translated">选择<strong class="ke ir">添加</strong>。</li></ol><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/c6a5efd7515ad4a6bb59dccda7e74290.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L8pcIi_WLAYytGlM"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="lu">图二。S3和拉姆达之间应该有联系。(图片由作者提供)</em></p></figure><h1 id="e280" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">测试应用程序</h1><p id="ddf3" class="pw-post-body-paragraph kc kd iq ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz ij bi translated">为了测试应用程序，上传一张图片到S3桶。在Flyte控制台上，在neural style transfer工作流下，检查执行是否被触发。执行的输出应该是你的风格化图像！</p><h1 id="face" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">后续步骤</h1><p id="f1e8" class="pw-post-body-paragraph kc kd iq ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz ij bi translated">总的来说，我们构建了一个事件驱动的应用程序，每当有新数据时，它就动态地触发和执行ML管道。用Flyte和AWS Lambda生产管道非常容易，如本教程所示。我们还可以在这个流程之上有一个前端应用程序，使应用程序更容易访问。</p><p id="f1a2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你想对本教程给出反馈或者对实现有疑问，请在评论中发表！</p></div></div>    
</body>
</html>