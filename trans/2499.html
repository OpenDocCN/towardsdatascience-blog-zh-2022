<html>
<head>
<title>Fourier Convolutions with Kernel Sizes of 1024x1024 and Larger</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">内核大小为1024x1024或更大的傅立叶卷积</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/fourier-cnns-with-kernel-sizes-of-1024x1024-and-larger-29f513fd6120#2022-05-31">https://towardsdatascience.com/fourier-cnns-with-kernel-sizes-of-1024x1024-and-larger-29f513fd6120#2022-05-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2d2a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">卷积神经网络中的多维傅立叶变换</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1618ccc7104da72e43985326ba073ee8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NJ5-ofPjuHM58Sei"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@edznorton?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Edz Norton </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="08a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi ls translated"><span class="l lt lu lv bm lw lx ly lz ma di"> C </span>最近，选择性神经网络(CNN)得到了广泛的应用。不管它们是否成功，卷积都是低效的。滑动窗口需要许多计算，并且限制了内核的大小。同时，通常在[3，3]到[7，7]之间的小核限制了感知场，并且需要许多层来捕捉输入张量的全局背景(例如2D图像)。图像越大，小滤镜的效果越差。这就是为什么你很难找到输入高分辨率图像的CNN。</p><p id="e7cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我告诉你有一种方法可以将内核大小扩展到[1024，1024]甚至更大，有一种方法可以在给定的输入分辨率下增加内核大小，而对推理时间几乎没有影响，如果有一种方法可以在不丢失几乎任何信息的情况下大幅降低特征图的空间维度，又会怎么样呢？</p><p id="1c51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有这些承诺都基于一个简单的数学属性:傅立叶变换的卷积定理(准确地说是互相关定理),我将向您展示如何正确地利用它！</p><blockquote class="mb mc md"><p id="64b1" class="kw kx me ky b kz la jr lb lc ld ju le mf lg lh li mg lk ll lm mh lo lp lq lr ij bi translated">注意:随着这篇文章，我在我的GitHub 上发布了一个包含所有代码的<a class="ae kv" href="https://github.com/sascha-kirch/ML_Notebooks/blob/main/2D_FFTs.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote><h1 id="5159" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">概述</h1><ol class=""><li id="b82b" class="na nb iq ky b kz nc lc nd lf ne lj nf ln ng lr nh ni nj nk bi translated"><a class="ae kv" href="#e0f2" rel="noopener ugc nofollow">卷积的缺陷</a></li><li id="0ba7" class="na nb iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><a class="ae kv" href="#69b2" rel="noopener ugc nofollow"> 2D离散傅立叶变换结果</a></li><li id="3937" class="na nb iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><a class="ae kv" href="#5a4c" rel="noopener ugc nofollow">发现2D FFT频谱</a></li><li id="c2ff" class="na nb iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><a class="ae kv" href="#dc1b" rel="noopener ugc nofollow">在TensorFlow中实现</a></li><li id="f4a6" class="na nb iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><a class="ae kv" href="#5720" rel="noopener ugc nofollow">结论</a></li><li id="7e32" class="na nb iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><a class="ae kv" href="#4720" rel="noopener ugc nofollow">进一步阅读和链接</a></li></ol><h1 id="e0f2" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">卷积的缺陷</h1><p id="dbaf" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">让我们回顾一些基础知识。卷积是应用于两个函数的数学运算。让我们从一维情况开始:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/052ec41c949d12bbb52018c66f394849.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*uzHx4oukAJvZGAOoXmm2aQ.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/0aac0cdc52240647d27dfdf78a41ae35.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*E400y2C684PQUL8TzBJ7HA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">1D卷积，(上)连续1D卷积，(下)离散1D卷积</p></figure><p id="f9b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">换句话说:取两个信号，一个保持原样，另一个绕坐标轴翻转。将固定信号上的翻转信号从负无穷大移动到正无穷大(或者直到信号的所有非零部分都已重叠)。对于每个步骤，计算元素乘积并对所有值求和。结果值是该特定步骤的卷积结果。卷积也可以应用于二维信号(例如图像):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/fb6b70b19db43b35b5dc9d56271c1750.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*wC8bQJ6VgsUdqb_10EH7nQ.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/74f7ba3b9d91015b698abafa707b7503.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pFn062EcFudMyGvxqpMSwA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">2D卷积，(上)连续2D卷积，(下)离散2D卷积</p></figure><p id="f387" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是为什么我之前提到了互相关呢？这是因为卷积和互相关实际上是以相同的方式计算的，唯一的区别是滤波器被翻转了。这由不同的符号表示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/0aac0cdc52240647d27dfdf78a41ae35.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*E400y2C684PQUL8TzBJ7HA.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/a9cd04eb00905a6e32ad78c8127384f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*rSXS4xS7tETAdblMHKM2iw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(上)离散卷积和(下)离散互相关之间的比较</p></figure><p id="bcb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TensorFlow和PyTorch实际上是在计算输入信号和可学习滤波器的互相关，而不是卷积。有关系吗？不尽然！由于滤波器是由网络学习的，所以滤波器是否翻转并不重要。网络会自己找出什么是最好的。不翻转过滤器甚至可以节省一些计算。但是，如果过滤器是固定的，这意味着如果您加载一个训练好的模型，您应该知道它是使用互相关还是卷积来训练的，并且最终必须翻转过滤器的权重。</p><p id="bcfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你应该记住两件事:</p><ol class=""><li id="0c1f" class="na nb iq ky b kz la lc ld lf ny lj nz ln oa lr nh ni nj nk bi translated">需要大量的计算来计算输出序列中的单个点。</li><li id="d48c" class="na nb iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">输入信号越大(即图像的分辨率越高)，滤波器必须移动得越频繁，因此需要更多的计算。这同样适用于较大的过滤器。</li></ol><p id="c745" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更多的计算意味着更多的内存和更长的等待时间，直到结果可用。CNN的后果是显而易见的:更低的输入分辨率和更小的滤波器。问题:更少的像素意味着更少的细节，更小的过滤器导致更小的感受野。网络需要有多个连续的卷积层，以增加接收域。网络变得更深，这又给培训带来了新的挑战。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/cfefa5828c2985d5cc08e972b9c3b97d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fxmLWce3WIK8S-qpvD9Fxg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">卷积神经网络感受野的增长</p></figure><h1 id="69b2" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">2D离散傅立叶变换来拯救</h1><p id="66e8" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">从数学上讲，时间变量t的实函数或复函数x(t)的傅立叶变换是实频率变量f的复函数X(f ):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/86025c5435d53b94999b26abf10d27c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*KSVR-gBbLQ0mQwIqI2pSoQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">傅里叶变换</p></figure><p id="e4de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你也可以说我们将信号从时域投射到频域。通过这样做，我们可以受益于傅立叶变换的特殊性质，即卷积定理和相关定理。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/afadf930f78978d25c662ae18800ce28.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*lz9q6u1mUEj1b_tIoUbAug.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/61837727c9cc9c55c82459a83d8238ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*iyghpKiBQKJbjIArrRb9dw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">傅立叶定理，(上)卷积定理，(下)互相关定理</p></figure><p id="c885" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些特性非常重要，也是本文的基础:时域中的卷积/相关对应于频域中简单的逐元素乘法。但这有什么好激动的呢？如前所述，卷积需要很多计算，特别是对于大图像和过滤器。其复杂度与序列长度成二次比例，即O(N)。根据卷积定理，我们只需要对变换后的输入和变换后的滤波器执行逐元素乘法。存在有效的算法来计算傅立叶变换，即快速傅立叶变换(FFT)，其将复杂度降低到O(N log(N))。而最好的部分，只要滤波器作为输入信号更小，计算要求是不变的。不管我们的过滤器的内核大小是[3，3]还是[1024，1024]。在TensorFlow中实现的部分中的细节。</p><p id="7791" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">傅立叶变换也存在于实数或复数离散信号x[k]中，其分配实数变量n的复数离散信号X[n]:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/ab47bff63759056c7a415d7c6fcc74c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/format:webp/1*oq9g8KY2zUG_EH0g_oEG-A.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/684ac567654056722e8d7e2e59ecdc0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*M3A9MF0F1P66HgS6s9n25g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">离散傅立叶变换，(上)1D离散傅立叶变换，(下)2D离散傅立叶变换</p></figure><p id="2237" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">离散傅立叶变换(DFT)注定用于数字信号处理，因为计算机以离散值存储信号。</p><blockquote class="mb mc md"><p id="2766" class="kw kx me ky b kz la jr lb lc ld ju le mf lg lh li mg lk ll lm mh lo lp lq lr ij bi translated">注意:离散信号是时间离散和数值离散的。时间离散型，因为它以特定的时间间隔进行采样；数值离散型，因为每个值都由特定数量的位表示，例如INT32为32位。</p></blockquote><p id="def9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在使用DFT时，我们需要记住一些含义:</p><ol class=""><li id="976f" class="na nb iq ky b kz la lc ld lf ny lj nz ln oa lr nh ni nj nk bi translated">假设输入信号是周期性的，并且采样一个完整的周期</li><li id="9a90" class="na nb iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">产生的光谱是周期性的</li></ol><blockquote class="mb mc md"><p id="bcf4" class="kw kx me ky b kz la jr lb lc ld ju le mf lg lh li mg lk ll lm mh lo lp lq lr ij bi translated">注:图像可以被解释为空间信号，而不是时间信号。在计算机上，图像是空间离散的，因为值存储在像素中，这些像素是从具有空间分布的单元的图像传感器中采样的或者被数字化的。</p></blockquote><p id="c59b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">二维DFT(以及2D连续傅立叶变换)可以分成连续的1D DFT，其中行和列可以分别计算。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/b44440bcbe5598f19feef60ee6c34580.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*ppYI29bw55X7Lnjn--TMew.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">2D DFT在连续的1D DFT中分离</p></figure><p id="50bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这至少有两个优点:第一，可以重复使用1D DFT的算法，第二，有助于建立2D DFT的直觉，因为行和列可以单独解释。</p><p id="0fe8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是当然，离散傅立叶变换有一个小细节:<strong class="ky ir">卷积定理不适用于DFT。</strong></p><p id="26c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">两个信号的DFT的乘积对应于由算子⊛表示的它们的循环卷积，而不是它们的线性卷积。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/d75f7288f29cdcf5c6ff88b6398f1365.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*0IIrNF_-P6Nxy6Fon_KsLg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">DFT的循环卷积定理</p></figure><p id="933b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">循环卷积是以信号长度N重复的周期性信号，而线性卷积的长度为(N+F-1)，其中F是滤波信号的长度。因此，如果您盲目地在频域中求乘积，您会将长度为(N+M-1)的信号压缩到长度为N的信号中，这可以被视为时域中的<strong class="ky ir">混叠，从而在最终结果中产生不需要的伪像。幸运的是，循环卷积和线性卷积共享一些值，即(N-F+1)。剩余的(F-1)值被绕回并干扰信号的其他值。</strong></p><p id="f86f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个想法:如果被包装的值干扰的值为零，意味着没有干扰，那会怎么样？这意味着我们可以从循环卷积中重建线性卷积。当信号至少用(F-1)零填充时，包装值不会干扰真实值。然后，我们可以循环地将包装的值移回它的位置，并裁剪填充的值。详细信息将在实施部分显示。</p><p id="f978" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不再赘述所有的数学细节，并在文章末尾链接了更多的资源。</p><h1 id="5a4c" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">发现2D DFT频谱</h1><p id="6843" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">现在我们已经讨论了理论，让我们发现一些2D傅立叶变换，并加强我们对2D傅立叶变换的直觉。</p><h2 id="8688" class="oj mj iq bd mk ok ol dn mo om on dp ms lf oo op mu lj oq or mw ln os ot my ou bi translated">基本测试信号及其对细胞神经网络的影响</h2><p id="6996" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">考虑像素强度遵循对角正弦波的图像。你期望什么样的振幅谱？如前所述，2D傅立叶变换可以通过将2D傅立叶变换沿着图像的每个轴分成多个1D傅立叶变换来计算。如果你想象沿着横轴行走，你会遇到重复的模式。如果你想象沿着纵轴行走，情况也是如此。因此，在第四象限(右下)，即频率成分为正值的象限内，很自然地会出现高频谱值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/35d35a70c3a06f49f5ef808b8daa6e4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MH4htpOjggXWXCBZcejo-A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">对角正弦输入图像的2D DFT(上图)图像图，(下图)作者的3D图</p></figure><blockquote class="mb mc md"><p id="eb50" class="kw kx me ky b kz la jr lb lc ld ju le mf lg lh li mg lk ll lm mh lo lp lq lr ij bi translated">注意:2D振幅谱在绘制时通常使用对数函数进行缩放，因为图像无论其内容如何都具有高偏移，因为它们通常以无符号整数表示，而无符号整数仅表示正值。</p></blockquote><p id="3700" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们考虑具有不同边长的矩形的输入图像。如果你再次想象沿着每个轴走，你将在水平轴上遇到一个具有短脉冲宽度的矩形，在垂直轴上遇到一个具有较宽脉冲宽度的矩形。如果你熟悉信号理论，你会立即想到你的频谱有某种sinc函数，其中sinc(x)=sin(x)/x。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/209dc6efa48ed90810895362f133da47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CRhNtDGkdotYjDBO9Wf2mg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">不同边长矩形的2D DFT</p></figure><p id="bdcc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你期待一个正弦函数，你是完全正确的。频谱由沿两个轴的正弦函数组成。这里可以做一个<strong class="ky ir"> <em class="me">基本面观察</em> </strong> : <strong class="ky ir"> <em class="me"> </em> </strong>横轴作为纵轴有较高的频率成分，过零点在横轴更分散。这一观察有两层含义:</p><ol class=""><li id="450f" class="na nb iq ky b kz la lc ld lf ny lj nz ln oa lr nh ni nj nk bi translated">输入图像中的窄空间特征在振幅谱中具有高频分量，因此它们具有高带宽。高带宽滤波器容易产生噪声。</li><li id="fac6" class="na nb iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">光谱与输入图像中要素的空间长度成反比。窄特征导致宽光谱，宽特征导致窄光谱。</li></ol><p id="4051" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这对于我们的CNN来说意味着什么呢？根据我们上面的观察，这应该意味着具有小滤波器的<strong class="ky ir"><em class="me">CNN充当高带宽滤波器，因此容易产生输入噪声</em> </strong> <em class="me">。</em>滤波器尺寸越大，滤波器带宽越低，选择性越强。</p><h2 id="e997" class="oj mj iq bd mk ok ol dn mo om on dp ms lf oo op mu lj oq or mw ln os ot my ou bi translated">图像的2D DFT和频域滤波</h2><p id="02cc" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">既然我们已经讨论了一些基本信号，让我们研究真实图像的2D DFT。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/743d0721c496a1a396cc419e07d845fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g8huWDbTVqC9sqOA5HOsOA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者的图像的2D DFT</p></figure><p id="4f4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">频谱的中心表示频率为零，也称为偏移。离中心越远，输入中的频率成分越高。记住这一点，你可以很容易地得出一个高通滤波器和一个低通滤波器。</p><p id="07be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">高通滤波器抑制低频，保留高频成分。这种行为可以通过这样的滤波器来实现，该滤波器在靠近中心的位置具有0，而在远离中心的位置具有1。通过将滤波器与频谱相乘，然后计算傅立叶逆变换来应用滤波器。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/718e61c09b4a5b3ed6bb6955025aa04c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6eisGlkTdj3ci0jfx_nSew.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者的高通滤波器</p></figure><p id="494e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上图所示，高通滤波器可以用作边缘检测器。图像中的边缘的特征在于像素值的突变，因此它具有高梯度。梯度越高，涉及的频率越高。</p><p id="c6d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，低通滤波器抑制高频分量，保留低频分量。低通滤波器可以通过在中心区域为1而在外部区域为0的掩模来实现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/38787268ac535e2f64e5fb546ba34c17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MElB7oUonYJUrEHDS7ioPA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者的低通滤波器</p></figure><p id="17ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">经过低通滤波的图像看起来模糊不清，失去了清晰度。计算机视觉中使用的典型滤波器是高斯滤波器。它也是一个低通滤波器，但对于较高的频率，滤波效果逐渐增强，而不是突然截止频率。它使图像平滑。下图由高斯滤波器滤波，其方差(sigma平方)等于之前圆形低通滤波器的截止频率。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/f18f3fdb2a5aec11869caa99eb2620c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IN2z4KQ4kwFTEKSgUbPsTA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者的高斯滤波器(平滑)</p></figure><p id="26d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">图像模糊，但失真较少。它看起来更光滑。</p><p id="7f67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">机器学习应用的一个非常有趣的过滤器是矩形过滤器。卷积神经网络通常逐渐减小空间宽度并增加通道数量。汇集，如最大汇集或平均汇集经常被用来减少空间宽度。如果我们在频域中汇集呢？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/e6a12650e75819f09fe1e0e35c8f1d2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7gVHGZZVf3zvcsikXqI-sw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者的矩形过滤器</p></figure><p id="c10c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过在频域中应用矩形滤波器，我们可以彻底去除频率分量，而不会对空间域中的图像质量产生大的影响。</p><p id="c1d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">DFT对于实输入有一个有趣的性质:它关于原点共轭对称。对称性意味着频谱包含冗余，在计算过程中可以忽略这些冗余，以进一步加快处理速度。下图显示了这种变换及其从光谱重建的逆变换。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/17b0d9c0dde3972c66bd9942777df392.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*omvB_OUH25Geq0gFt31f1g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者的图像的2D快速傅立叶变换</p></figure><p id="0dec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">从本节中取走:</strong></p><ol class=""><li id="6f19" class="na nb iq ky b kz la lc ld lf ny lj nz ln oa lr nh ni nj nk bi translated">低频成分在2D频谱的中心，而高频成分远离中心</li><li id="2b95" class="na nb iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">您可以利用DFT的对称性来减少所需的计算资源，只计算rDFT。</li><li id="f4af" class="na nb iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">小尺寸滤波器由于其高带宽而易于产生噪声。</li></ol><p id="9f94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我为生成这些图而创建的笔记本:</p><div class="oz pa gp gr pb pc"><a href="https://github.com/sascha-kirch/ML_Notebooks/blob/main/2D_FFTs.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd ir gy z fp ph fr fs pi fu fw ip bi translated">ML _ Notebooks/2D _ ffts . ipynb at main sascha-kir ch/ML _ Notebooks</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">机器学习相关笔记本合集分享。-ML _ Notebooks/2D _ ffts . ipynb at main…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">github.com</p></div></div><div class="pl l"><div class="pm l pn po pp pl pq kp pc"/></div></div></a></div><h1 id="dc1b" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">TensorFlow中的实现</h1><p id="aa96" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">利用离散傅里叶变换实现线性卷积，我们已经具备了所有条件。</p><p id="cf36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">概括地说，我们需要实施以下6个步骤:</p><ol class=""><li id="929c" class="na nb iq ky b kz la lc ld lf ny lj nz ln oa lr nh ni nj nk bi translated">填补输入图像以避免时域中的混叠</li><li id="2f83" class="na nb iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">对图像大小进行填充过滤，以准备元素乘法</li><li id="d9b8" class="na nb iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">计算输入图像和滤波器的2D rFFT</li><li id="950e" class="na nb iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">变换输入和变换滤波器的逐元素乘法</li><li id="fd56" class="na nb iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">计算滤波输入的2D逆rFFT以获得循环卷积</li><li id="25c5" class="na nb iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">从循环卷积重建线性卷积</li></ol><h2 id="b397" class="oj mj iq bd mk ok ol dn mo om on dp ms lf oo op mu lj oq or mw ln os ot my ou bi translated">步骤1 —填充输入图像</h2><p id="4177" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">为了避免时域中的混叠效应，我们需要用至少(F-1)零点来填充图像，其中F是滤波器的边长。此外，计算DFT的FFT算法对于信号长度为2的幂(例如128，512，1024)特别有效。</p><p id="0347" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至少有两种选择来填充输入图像:首先，我们手动填充图像。其次，我们将FFT的序列长度设置为填充信号的长度。我更喜欢后者。</p><p id="f4c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的代码手动填充图像。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pr ps l"/></div></figure><p id="982c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里是我在计算FFT时指定更高序列长度的首选方法:</p><pre class="kg kh ki kj gt pt pu pv pw aw px bi"><span id="ee93" class="oj mj iq pu b gy py pz l qa qb"># image is of shape [b,c,h,w]<br/>padding <strong class="pu ir">=</strong> GetImagePadding(filter_shape[0]) <br/>image_shape <strong class="pu ir">=</strong> (input_shape[0],<br/>               input_shape[1],<br/>               input_shape[2]<strong class="pu ir">+</strong>2<strong class="pu ir">*</strong>padding,<br/>               input_shape[3]<strong class="pu ir">+</strong>2<strong class="pu ir">*</strong>padding)</span><span id="2ea7" class="oj mj iq pu b gy qc pz l qa qb">image_shape <strong class="pu ir">=</strong> FillImageShapeToPower2(image_shape)<br/><br/>F_image <strong class="pu ir">=</strong> tf<strong class="pu ir">.</strong>signal<strong class="pu ir">.</strong>rfft2d(image, fft_length<strong class="pu ir">=</strong>[image_shape[<strong class="pu ir">-</strong>2],image_shape[<strong class="pu ir">-</strong>1]])</span></pre><h2 id="b917" class="oj mj iq bd mk ok ol dn mo om on dp ms lf oo op mu lj oq or mw ln os ot my ou bi translated">步骤2-根据图像大小填充滤镜</h2><p id="3eaa" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">因为我们需要用变换后的滤波器计算变换后图像的元素乘积，所以在计算傅立叶变换之前，我们需要将滤波器填充到填充后图像的大小。过滤器用零填充。同样，我建议通过正确设置fft计算的fft _ lenght参数来填充滤波器，即</p><pre class="kg kh ki kj gt pt pu pv pw aw px bi"><span id="7be4" class="oj mj iq pu b gy py pz l qa qb">F_filter <strong class="pu ir">=</strong> tf<strong class="pu ir">.</strong>signal<strong class="pu ir">.</strong>rfft2d(filter, fft_length<strong class="pu ir">=</strong>[image_shape[<strong class="pu ir">-</strong>2],image_shape[<strong class="pu ir">-</strong>1]])</span></pre><h2 id="be7a" class="oj mj iq bd mk ok ol dn mo om on dp ms lf oo op mu lj oq or mw ln os ot my ou bi translated">步骤3 —计算2D rfft</h2><p id="8eac" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">我们已经准备好输入信号，现在可以计算填充图像和填充滤波器的FFT:</p><pre class="kg kh ki kj gt pt pu pv pw aw px bi"><span id="f601" class="oj mj iq pu b gy py pz l qa qb"># Image shape [b,c,h,w], Filter shape [out, in , k, k]<br/>F_image <strong class="pu ir">=</strong> tf<strong class="pu ir">.</strong>signal<strong class="pu ir">.</strong>rfft2d(image, fft_length<strong class="pu ir">=</strong>[image_shape[<strong class="pu ir">-</strong>2],image_shape[<strong class="pu ir">-</strong>1]])</span><span id="8689" class="oj mj iq pu b gy qc pz l qa qb">F_filter <strong class="pu ir">=</strong> tf<strong class="pu ir">.</strong>signal<strong class="pu ir">.</strong>rfft2d(filter, fft_length<strong class="pu ir">=</strong>[image_shape[<strong class="pu ir">-</strong>2],image_shape[<strong class="pu ir">-</strong>1]])</span></pre><p id="7478" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们利用实输入的共轭对称性，仅使用<a class="ae kv" href="https://www.tensorflow.org/api_docs/python/tf/signal/rfft2d" rel="noopener ugc nofollow" target="_blank"> rfft2d </a>计算2D信号的实FFT。具体来说，我们输入无填充信号，并将fft_length设置为大于输入长度的值。这将自动用零填充信号。</p><p id="55f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">重要</strong> : TensorFlow对<a class="ae kv" href="https://www.tensorflow.org/api_docs/python/tf/signal/rfft2d" rel="noopener ugc nofollow" target="_blank"> rfft2d </a>的实现计算输入的最后两个维度上的fft。不像在<a class="ae kv" href="https://numpy.org/doc/stable/reference/generated/numpy.fft.rfft2.html" rel="noopener ugc nofollow" target="_blank"> numpy的实现</a>中，你不能通过参数改变维度。因此，图像的形状是[批次、通道、高度、宽度]，内核的形状是[输出过滤器、输入过滤器、内核高度、内核宽度]</p><p id="56fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们在频域中执行卷积，我们就完成了。由于TensorFlow实际上实现了互相关，因此我们需要对变换后的滤波器进行共轭，以获得一致的结果:</p><pre class="kg kh ki kj gt pt pu pv pw aw px bi"><span id="fdb2" class="oj mj iq pu b gy py pz l qa qb">F_filter <strong class="pu ir">=</strong> tf<strong class="pu ir">.</strong>math<strong class="pu ir">.</strong>conj(F_filter)</span></pre><h2 id="7227" class="oj mj iq bd mk ok ol dn mo om on dp ms lf oo op mu lj oq or mw ln os ot my ou bi translated">步骤4—变换图像和变换滤波器的相乘</h2><p id="a68e" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">如果我们只有单个图像和单个过滤器，则逐元素乘法将简单地为<code class="fe qd qe qf pu b">F_image*F_folter</code>。在一个真实的场景中，我们通常以批处理的形式有多个图像，并且我们并行地应用多个过滤器。我们需要重新排列输入信号的维度，并利用阵列广播来执行此操作，而不涉及任何循环。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pr ps l"/></div></figure><p id="1d8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TensorFlow的<a class="ae kv" href="https://www.tensorflow.org/api_docs/python/tf/einsum" rel="noopener ugc nofollow" target="_blank"> einsum() </a>函数可用于轻松重塑维度。箭头左边的字符描述输入形状，右边的字符描述输出形状。图像和过滤器的尺寸以这样一种方式重新排列，即当计算元素乘积时，所有批次和所有输出过滤器将被<a class="ae kv" href="https://numpy.org/doc/stable/user/basics.broadcasting.html" rel="noopener ugc nofollow" target="_blank">广播</a>。乘法之后，通过整形和减小输入滤波器维度来恢复初始形状。</p><h2 id="7f21" class="oj mj iq bd mk ok ol dn mo om on dp ms lf oo op mu lj oq or mw ln os ot my ou bi translated">步骤5 —计算逆2D rFFT</h2><p id="b0d8" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated"><a class="ae kv" href="https://www.tensorflow.org/api_docs/python/tf/signal/irfft2d" rel="noopener ugc nofollow" target="_blank">逆FFT </a>简单地取自具有与FFT相同的fft_length参数的滤波信号:</p><pre class="kg kh ki kj gt pt pu pv pw aw px bi"><span id="c339" class="oj mj iq pu b gy py pz l qa qb">out <strong class="pu ir">=</strong> tf<strong class="pu ir">.</strong>signal<strong class="pu ir">.</strong>irfft2d(filterd_image, fft_length<strong class="pu ir">=</strong>[image_shape[<strong class="pu ir">-</strong>2],image_shape[<strong class="pu ir">-</strong>1]])</span></pre><h2 id="ede4" class="oj mj iq bd mk ok ol dn mo om on dp ms lf oo op mu lj oq or mw ln os ot my ou bi translated">步骤6-从循环卷积重建线性卷积</h2><p id="fede" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">记住，要从循环卷积重建线性卷积，我们需要执行两个步骤:首先，我们需要按照填充量循环移位结果。第二，我们需要截断到我们感兴趣的区域，所有批次的图像的初始形状和新的通道数。</p><pre class="kg kh ki kj gt pt pu pv pw aw px bi"><span id="76b5" class="oj mj iq pu b gy py pz l qa qb">#Circular shift<br/>out <strong class="pu ir">=</strong> tf<strong class="pu ir">.</strong>roll(out,shift <strong class="pu ir">=</strong> [2<strong class="pu ir">*</strong>padding,2<strong class="pu ir">*</strong>padding],axis <strong class="pu ir">=</strong> [<strong class="pu ir">-</strong>2,<strong class="pu ir">-</strong>1]) </span><span id="343c" class="oj mj iq pu b gy qc pz l qa qb">#Truncation<br/>out <strong class="pu ir">=</strong> tf<strong class="pu ir">.</strong>slice(out, <br/>               begin <strong class="pu ir">=</strong> [0, 0, padding, padding], <br/>               size<strong class="pu ir">=</strong>[input_shape[0], <br/>                     filter_shape[<strong class="pu ir">-</strong>1],  <br/>                     input_shape[2], <br/>                     input_shape[3]]<br/>               )</span></pre><p id="0e09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仅此而已！<br/>下面的代码显示了步骤1到6的完整实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pr ps l"/></div></figure><blockquote class="mb mc md"><p id="4bfc" class="kw kx me ky b kz la jr lb lc ld ju le mf lg lh li mg lk ll lm mh lo lp lq lr ij bi translated">注意:傅立叶域中的卷积也以TensorFlow层的形式实现，作为我的DeepSaki包的一部分，可以在<a class="ae kv" href="https://github.com/sascha-kirch/DeepSaki/blob/25613bd7d5a98e41aa2ce7a2da1b02abdcd2989f/DeepSaki/layers/fourier_layer.py#L5-L159" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到或从<a class="ae kv" href="https://pypi.org/project/DeepSaki/" rel="noopener ugc nofollow" target="_blank"> PyPi </a>下载。</p></blockquote><h1 id="acde" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">确认</h1><p id="f8d2" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">你可能会问自己:<strong class="ky ir">但是这真的有用吗？</strong>一起来看看吧！所有验证步骤都包含在本文的<a class="ae kv" href="https://github.com/sascha-kirch/ML_Notebooks/blob/main/2D_FFTs.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本中。</a></p><p id="9c3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们将查看两个函数的内核大小的执行时间(秒):<a class="ae kv" href="https://www.tensorflow.org/api_docs/python/tf/nn/conv2d" rel="noopener ugc nofollow" target="_blank"> tf.nn.conv2d() </a>和我们的实现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qg"><img src="../Images/dc27f6e9e91b8e0dbd75c2e51704c8b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wRu1lVYIS9dvEolaDQx0ew.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">2D卷积和2D DFT卷积的执行时间与内核大小。图像大小:550x550x1，批次:1，过滤器:1(作者)</p></figure><p id="bfb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您所料，2D卷积的执行时间会随着内核大小的增加而增加。另一方面，无论滤波器大小如何，2D DFT卷积在执行时间上是恒定的。这是因为滤镜被填充到图像的大小。如果过滤器越大，填充的值就越少。</p><p id="959a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们来看看调查结果中的差异。为此，我们在720x720像素的图像上应用大小为3x3的具有8个过滤器的内核。我们通过两种算法运行它，并计算绝对差的平均值和标准偏差。</p><pre class="kg kh ki kj gt pt pu pv pw aw px bi"><span id="9373" class="oj mj iq pu b gy py pz l qa qb">convResult <strong class="pu ir">=</strong> CalcConv(image, filter)<br/>dftResult <strong class="pu ir">=</strong> CalcDFT2D(image, filter)<br/><br/>error <strong class="pu ir">=</strong> tf<strong class="pu ir">.</strong>math<strong class="pu ir">.</strong>abs(convResult<strong class="pu ir">-</strong>dftResult)<br/>mean = tf<strong class="pu ir">.</strong>math<strong class="pu ir">.</strong>reduce_mean(error)<br/>std = tf<strong class="pu ir">.</strong>math<strong class="pu ir">.</strong>reduce_std(error)</span><span id="1d12" class="oj mj iq pu b gy qc pz l qa qb"># Mean Absolute Error: 0.001560982083901763<br/># Standard deviation: 0.0015975720016285777</span></pre><p id="9062" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">均值和标准差都很低。这种差异来自于数字的不准确性。当观察滤波后的图像和相应的振幅谱时，我们可以看到它们是不可区分的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qh"><img src="../Images/a8de33d0c0c4a944f1a13bf54dcdce4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dR_sD1jvZtVgVIM0hlbaFg.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qh"><img src="../Images/d7b4a0be2efa8ea1117e4a6f914ac4cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K2mvvwmy6DJMmFqwNM1pPA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">过滤图像和2D光谱的直接比较。(上)2D线性卷积(下)2D DFT卷积作者</p></figure><h1 id="5720" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">结论</h1><p id="930a" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">我们已经了解了卷积和DFT背后的数学基础，通过观察不同的光谱获得了一些直觉，查看了TensorFlow中的代码，并最终验证了结果的正确性。</p><p id="ef69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设计在频域而不是空间域工作的层带来了新的机会，特别是对于大输入图像和大滤波器尺寸。绕过频域似乎有悖直觉，但实际上加快了计算速度。</p></div><div class="ab cl qi qj hu qk" role="separator"><span class="ql bw bk qm qn qo"/><span class="ql bw bk qm qn qo"/><span class="ql bw bk qm qn"/></div><div class="ij ik il im in"><h1 id="4720" class="mi mj iq bd mk ml qp mn mo mp qq mr ms jw qr jx mu jz qs ka mw kc qt kd my mz bi translated">进一步阅读和链接</h1><div class="oz pa gp gr pb pc"><a href="https://github.com/sascha-kirch/ML_Notebooks/blob/main/2D_FFTs.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd ir gy z fp ph fr fs pi fu fw ip bi translated">ML _ Notebooks/2D _ ffts . ipynb at main sascha-kir ch/ML _ Notebooks</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">机器学习相关笔记本合集分享。—ML _ Notebooks/2D _ ffts . ipynb at main…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">github.com</p></div></div><div class="pl l"><div class="pm l pn po pp pl pq kp pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="https://github.com/sascha-kirch/DeepSaki" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd ir gy z fp ph fr fs pi fu fw ip bi translated">GitHub - sascha-kirch/DeepSaki:可重用机器学习代码的集合，包括模型…</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">欢迎AI enthuisiasts来到DeepSaki，这是一个可重用机器学习代码的集合。💪 🤖 🤘使用的ML框架是…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">github.com</p></div></div><div class="pl l"><div class="qu l pn po pp pl pq kp pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="https://pypi.org/project/DeepSaki/" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd ir gy z fp ph fr fs pi fu fw ip bi translated">迪普萨基</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">欢迎AI enthuisiasts来到DeepSaki，这是一个可重用机器学习代码的集合。:肌肉::机器人::金属:ML…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">pypi.org</p></div></div><div class="pl l"><div class="qv l pn po pp pl pq kp pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="https://thewolfsound.com/circular-vs-linear-convolution-whats-the-difference/" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd ir gy z fp ph fr fs pi fu fw ip bi translated">循环卷积与线性卷积:有什么区别？</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">什么是循环卷积，它与线性卷积有什么不同？卷积的定义和…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">thewolfsound.com</p></div></div></div></a></div></div></div>    
</body>
</html>