<html>
<head>
<title>Cointegration Popular Methods [1/2]: The Engle-Granger Approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">协整流行方法[1/2]:恩格尔-格兰杰方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/cointegration-popular-methods-1-2-the-engle-granger-approach-82b6d270ddf2#2022-06-16">https://towardsdatascience.com/cointegration-popular-methods-1-2-the-engle-granger-approach-82b6d270ddf2#2022-06-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b6e2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python中的简单协整方法。恩格尔-格兰杰方法，最直观的方法。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8fa7988b207a584a3338e4d4f58b8779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YQyWZ2ugjlr0MULEsO_wPw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</p></figure><p id="ebfa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">大多数协整方法的数学和概念并不总是很简单。通常，复杂的数学工具模糊了方法的意图和步骤。这种复杂性也影响了对这一主题的进一步探索。</p><p id="42d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">恩格尔-格兰杰的协整方法不受此影响。它可能不是最可靠的方法，也不是最稳定的方法，但它简单而直观。对于更稳健的协整方法，参见<a class="ae lu" rel="noopener" target="_blank" href="/canonical-decomposition-a-forgotten-method-for-time-series-cointegration-and-beyond-4d1213396da1"> BTCD </a>或<a class="ae lu" rel="noopener" target="_blank" href="/dickey-fuller-optimization-tackle-time-series-cointegration-head-on-f924f7c51477">迪基-富勒直接优化</a>。</p><p id="6d69" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个故事中，我们将用简单的数学来介绍Engle-Granger方法，并且我们将编写一个迷你库来在未来的项目中使用这个方法。</p><h2 id="10f2" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">故事结构</h2><ul class=""><li id="17a3" class="mo mp it la b lb mq le mr lh ms ll mt lp mu lt mv mw mx my bi translated">协整，阶1</li><li id="66fb" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">从向量和矩阵构建1D时间序列</li><li id="e4a6" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">普通最小二乘残差</li><li id="89fc" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">确定最合适的关系</li><li id="8858" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">合成数据示例</li><li id="db98" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">代码摘要</li><li id="c213" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">最后的话</li></ul><h2 id="dcb2" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">协整，阶1</h2><p id="47b8" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">当提到协整时，我们通常是指一阶时间序列的协整。这意味着我们寻求原始时间序列(不是差异)的线性组合，它是稳定的。有时我们找到它；有时候，它不在那里。数学上，我们寻求系数<em class="nh"> α </em>和可能的常数<em class="nh"> c </em>，使得</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/65bc8c6738fe85bf451d25f5b86473b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*06G6Eyw7IqKJRoMnwqWUaw@2x.jpeg"/></div></figure><p id="fee6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是静止的。</p><p id="fd28" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">需要注意的是，如果<em class="nh"> u </em>是静止的，那么无论常数<em class="nh"> c </em>的值是多少，它都是静止的。该常数仅用于重新确定时间序列值的中心。</p><h2 id="c4c7" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">从向量和矩阵构建1D时间序列</h2><p id="711e" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">在我们深入研究Engle-Granger方法之前，我们需要开发一些工具来简化我们未来的工作。</p><p id="e9db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">给定一个系数向量<strong class="la iu"><em class="nh"/></strong>和一个进程矩阵(时间序列)，每列一个进程，列的索引对应于向量<strong class="la iu"><em class="nh"/></strong>的索引；以下代码的函数“get_u_t”创建了这些条件的线性组合。此外，函数“get_u_mat”从系数矩阵(也按列索引)创建u个时间序列的矩阵(每列一个)，即<strong class="la iu"> <em class="nh"> a </em> </strong>向量的向量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="4eed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以看到，我们将在NumPy数组中使用的约定是，每一列都是一个时间序列，非常类似于pandas数据帧的工作方式。</p><h2 id="903a" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">普通最小二乘残差</h2><p id="3b50" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">让我们回到<em class="nh"> u </em>的等式，稍微改写一下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/9862be537d8649fdcc1b12ba7b731ff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0h4xCaUtJZTr0GAOs5e4DA@2x.jpeg"/></div></div></figure><p id="0976" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里<em class="nh"> x_0 </em>变成了<em class="nh"> y </em>，求和不是从零开始，而是从一开始。</p><p id="5246" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在是恩格尔-格兰杰方法的本质。他们推测使用<strong class="la iu"> OLS回归规范</strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/5cb362bfd8acb13f0f92d7fe2db444a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WpOrlZinZzCfcIQf97wkdw@2x.jpeg"/></div></figure><p id="96ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中<em class="nh"> y </em>是多个时间序列中的一个，<em class="nh"> x </em>是所有其他时间序列。那么因为ε是同分布正态的，因此是平稳的，即使来自实际回归的残差<em class="nh"> u </em>不是同分布正态的，它们也会<strong class="la iu">接近平稳性</strong>。</p><p id="4ad1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么我们的系列<em class="nh"> u </em>就是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/5e612b1e3b581a1de33ab9c82dcd25f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yv9Gm8MhCBw7CLeS4fsCNw@2x.jpeg"/></div></figure><p id="1cc9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中使用OLS估计系数和常数。</p><p id="4d12" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，如果我们有<em class="nh"> n+1 </em>时间序列，就有<em class="nh"> n+1 </em>种方法来选择<em class="nh"> y </em>和<em class="nh">x</em>s。因此，从使用OLS的Engle-Granger方法中，我们找到了系数矩阵，而不是单个向量。</p><p id="98dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">换句话说，给定一个矩阵，其中每一列都是时间序列<em class="nh"> x_j，</em>我们将OLS应用于以下每个规格<em class="nh">。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/e5e94ecb9711772f48edf97ce481b0fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gDmpUi79TUJ7o-afqdMHjA@2x.jpeg"/></div></div></figure><p id="35a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">则每个u_j时间序列为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/8410785b3113922afb51c09de7b58859.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H3j6soHiC4V0AGlfHq6qQw@2x.jpeg"/></div></div></figure><p id="f078" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">构建<em class="nh"> u_j </em>矩阵的系数矩阵定义为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/2013621729dd7005774815bb5029319d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PBAEp3T5qKHpiZQnXr5nCA@2x.jpeg"/></div></div></figure><p id="b7fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意负号；这是因为在回归规范中，线性组合在等号的另一边，我们需要考虑这一点。</p><p id="07d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面的代码找到了这样一个矩阵，其中每一列对应于一个系数向量。我们已经为线性回归模型定义了一个<a class="ae lu" rel="noopener" target="_blank" href="/python-interfaces-why-should-a-data-scientist-care-2ed7ff80f225">接口</a>(所有scikit-learn回归都实现了这个接口)，这样我们就可以测试原始OLS之外的其他模型。使用一个<a class="ae lu" rel="noopener" target="_blank" href="/python-interfaces-why-should-a-data-scientist-care-2ed7ff80f225">接口</a>，我们注入回归模型的依赖性，而不是硬编码它，从而能够在不重写代码的情况下切换模型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="df0c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">到目前为止，一切都很好；然而，我们需要解决一个问题；我们应该找到的是<strong class="la iu"> <em class="nh"> a </em> </strong>向量(带有线性组合系数的向量)，而不是<em class="nh">n</em>+1<em class="nh"/><strong class="la iu"><em class="nh">a</em></strong>向量(系数矩阵)。我们需要决定如何在所有可能的选择中做出选择。</p><h2 id="4e4b" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">确定最合适的关系</h2><p id="20c1" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">我们使用Dickey-Fuller平稳性测试来寻找更可能是平稳的关系。我们估计所有关系的检验统计量，并选择具有最小值的一个。简单。</p><p id="2412" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了快速和简单起见，我们使用直接估计Dickey-Fuller检验统计量的方法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/a2633d1a361b3d3aefcc276482725a1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pmVl6YS9jKloDeZb-Cj-xg@2x.jpeg"/></div></figure><p id="82ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中时间序列样本量为<em class="nh"> T </em> +1，<em class="nh"> ρ </em>为滞后序列和差分序列之间的相关性。</p><p id="6ae2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想查看这个结果的完整数学证明，我推荐阅读<a class="ae lu" rel="noopener" target="_blank" href="/dickey-fuller-direct-estimation-speed-up-to-50x-test-statistic-computation-af3cb28b9803">这个故事</a>。</p><p id="0dd3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实现它的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="212c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将前一节中编码的函数“get_engle_granger_coint_mat”包装在另一个函数中，该函数对线性模型使用相同的接口，并选择具有最低Dickey-Fuller统计值的向量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="6790" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们想要一个简单的解决方案来寻找一个带有系数的矢量<strong class="la iu">来产生一个潜在的稳定时间序列<em class="nh"> u </em>时，我们就调用这个函数。这里的关键是<strong class="la iu">潜在地静止</strong>。有些情况下，恩格尔-格兰杰方法无法找到平稳的时间序列，所以要谨慎使用。再一次，为了更健壮，尽管更复杂的方法，看看<a class="ae lu" rel="noopener" target="_blank" href="/canonical-decomposition-a-forgotten-method-for-time-series-cointegration-and-beyond-4d1213396da1"> BTCD </a>或<a class="ae lu" rel="noopener" target="_blank" href="/dickey-fuller-optimization-tackle-time-series-cointegration-head-on-f924f7c51477">直接迪基-富勒优化</a>。</strong></p><h2 id="4218" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">合成数据示例</h2><p id="c2f6" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">为了测试我们刚刚编写的代码，我们将使用离散采样相关布朗运动形式的单位根过程。查看前面关于生成这种过程的故事，因为我们将使用那里讨论的代码来生成相关的布朗路径。我们将这样的代码保存为“brownian_motion.py ”,并将其放在运行以下代码的同一个文件夹中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="9ec0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们使用OLS，注入来自sklearn的“线性回归”模型，测试Engle-Granger方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/b87e2e1ec428fa2218407e56d28f35a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cVW3txZzu1BDb8E8qcwDow.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</p></figure><p id="78df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们用一个接口对回归进行编码，因为我们想要在不重写代码的情况下自由地改变模型。因此，如果我们现在希望使用套索，我们注入一个来自sklearn的套索模型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/3fbd7bf585ffaf98d1796151e8d4a7c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z6maiyv1v9T4dOYMOnWOoQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</p></figure><p id="0df8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">能这么轻松的换型号真好。尽管在这个特殊的例子中，OLS似乎产生了一个更好的结果，但不要低估惩罚回归的力量。由于使用LASSO的模型复杂度较低，因此它可以产生更稳定的结果。由您决定哪种回归模型更适合您。</p><h2 id="837f" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">代码摘要</h2><p id="4ea3" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">最后，为了完整起见，这里是前面几节中的所有代码。这一次，代码没有那么广泛；不过，文档字符串比代码多。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="ba4f" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">最后的话</h2><p id="2ce7" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">这个故事的目的仅仅是教学，直观地探索协整。使用恩格尔-格兰杰方法有助于探索时间序列之间的关系。每种关系产生不同的时间序列；有些比其他的更可能是静止的。调查为什么会发生这种情况是很有趣的。为什么有些时间序列更适合回归模型？这些问题可以创造有价值的数据洞察力。</p><p id="9714" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，Engle-Granger方法在实际中很少用于计算协整向量。为此，我会建议BTCD或者T2进行迪基-富勒直接优化。</p><h2 id="b2a3" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">参考</h2><p id="d0ee" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">[1] R. F. Engle和C. W. J. Granger，<a class="ae lu" href="http://..." rel="noopener ugc nofollow" target="_blank">协整和误差修正:表示、估计和检验</a> (1987)，《计量经济学》第55卷，第2期，第251-276页</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="9c60" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望这个故事对你有用。请继续关注协整流行方法迷你系列的第2部分。订阅以便在第2部分发布后立即收到通知。</p><div class="nw nx gp gr ny nz"><a href="https://medium.com/subscribe/@diego-barba" rel="noopener follow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">每当迭戈·巴尔巴出版时，就收到一封电子邮件。</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">每当迭戈·巴尔巴出版时，就收到一封电子邮件。通过注册，您将创建一个中型帐户，如果您还没有…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">medium.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on ks nz"/></div></div></a></div></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="812e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">喜欢这个故事吗？通过我下面的推荐链接成为一个媒体成员来支持我的写作。无限制地访问我的故事和许多其他内容。</p><div class="nw nx gp gr ny nz"><a href="https://medium.com/@diego-barba/membership" rel="noopener follow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">通过我的推荐链接加入Medium-Diego Barba</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">medium.com</p></div></div><div class="oi l"><div class="oo l ok ol om oi on ks nz"/></div></div></a></div></div></div>    
</body>
</html>