<html>
<head>
<title>Exciting Ways To Interact With Hardware From Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">令人兴奋的与Python硬件交互的方式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/exciting-ways-to-interact-with-hardware-from-python-2afb9278fe07#2022-09-29">https://towardsdatascience.com/exciting-ways-to-interact-with-hardware-from-python-2afb9278fe07#2022-09-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3f79" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">命令式Python！与您的硬件交互</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/894c63bc9cda77052f904161116e2b6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RB0kHGGnZUrdsGIG"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯蒂安·威迪格在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h2 id="df48" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">介绍</h2><p id="937e" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi mo translated"><span class="l mp mq mr bm ms mt mu mv mw di"> D </span>独立编程语言是当今软件不可或缺的一部分。声明式编程是与命令式编程相对的两种基本编程范式之一。声明式编程的目标是掩盖计算机的硬件，而仅仅关注代码本身的逻辑。另一方面，命令式编程通常涉及程序员和计算机硬件之间的密切关系。这些当然都是范式的简化，但通常这是两者之间的自由裁量权。重要的是要记住这是一个范围，一种语言可以混合命令式和声明式特性，就像一种语言可以混合函数式和面向对象的特性一样。声明式语言的目标是考虑可读性和简单性，而不是速度，这正是大多数声明式语言所提供的。声明式编程语言不仅容易学习，而且对于编程概念的原型开发和教学也非常有用。上一代程序员最典型的声明式编程语言可能是BASIC或类似的语言，但今天这个名称落在了Python上。</p><p id="9e36" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">Python当然提供了我们可能从任何其他声明式编程语言中期待的所有特性。Python有令人难以置信的可读语法，常常感觉像是要消化的英语。这种语言也不需要很长时间就能学会，尤其是与c语言等其他语言相比。如今，许多计算机科学课程都是从Python课程开始，然后才转向另一种编程语言。最后，Python也在许多原型开发环境中使用。由于它们的可读性和缺乏硬件控制，声明性语言使得像原型制作或学习这样的任务变得非常容易。一个程序员甚至不需要首先知道计算机有什么硬件就可以很好地编写Python。</p><p id="3f49" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">然而，除了声明性之外，Python语言当然还有很多巨大的优势。这种语言当然是恰当的，并且已经被它今天在从系统管理到数据科学的一切事物中的普遍使用所证明是值得尊敬的。特别是，由于Python与命令式语言的紧密集成，这种语言在机器学习中得到了很好的应用。此外，PYthon的生态系统<strong class="lx iu">绝对庞大</strong>，在Python包索引中拥有超过200，000个独特的注册包。</p><p id="e342" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">虽然使用声明式编程语言有很多优点，特别是对于像机器学习这样的复杂任务，但是使用这种语言也有很多明显的缺点。第一个也是最明显的是速度。声明式编程语言的固有特性不一定是速度慢，但是大多数时候，有人决定开发一种声明式语言，这种语言最终会被解释。此外，更简单的语法也与声明性语言相关联，结果是语言在大多数情况下运行得有点慢。即使语言本身并不慢，命令式语言中的低级硬件交互也很重要，因为它允许您在大多数情况下尽可能高效。然而，对于声明性语言来说，情况并非如此，因为通常会有一些解释器或编译器试图找出表述您的工作的最佳方式。由于这是声明式语言的一个缺点，它也成为Python的一个缺点。</p><p id="229d" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">毫无疑问，Python是一种声明式编程语言，正如我提到的，早期的语言通常是几种其他编程范式的混合，因此Python是一种通常可能是声明式的语言，但仍然具有一些命令式的特性。尽管功能相对有限，但您可能最终会惊讶于所有Python所能做的事情！</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="0f92" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">压型</h2><p id="cff4" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">许多声明式编程语言的第一个也是最明显的命令式特性是剖析，Python也不例外。在标准库中，有各种不同的工具可以用来分析您的机器。从最基本和最不可能的命令开始，我们可以使用<code class="fe nj nk nl nm b">timeit</code>或<code class="fe nj nk nl nm b">time</code>模块来计时解释。对于我的例子，我将使用<code class="fe nj nk nl nm b">time</code>:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="2223" class="kz la it nm b gy nr ns l nt nu">&gt;&gt;&gt; import time<br/>&gt;&gt;&gt; start = time.time()<br/>&gt;&gt;&gt; print("% s seconds" % (time.time() - start))<br/>0.4931051731109619 seconds</span></pre><p id="2459" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">所以计时功能当然有用，但并不是必须的。我们可能会查看处理器运行这段Python代码所花费的时间，但这仍然不能给我们提供太多关于硬件的信息。在这方面一个类似的技术是使用标准库中的<code class="fe nj nk nl nm b">cProfile</code>，它提供了比<code class="fe nj nk nl nm b">time</code>更多的信息。为此，我们使用<code class="fe nj nk nl nm b">cProfile.run</code>函数，以字符串形式提供我们的Python:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="749f" class="kz la it nm b gy nr ns l nt nu">&gt;&gt;&gt; cProfile.run("5 * 1")<br/>         3 function calls in 0.000 seconds</span><span id="ecec" class="kz la it nm b gy nv ns l nt nu">Ordered by: standard name</span><span id="d947" class="kz la it nm b gy nv ns l nt nu">ncalls  tottime  percall  cumtime  percall filename:lineno(function)<br/>        1    0.000    0.000    0.000    0.000 &lt;string&gt;:1(&lt;module&gt;)<br/>        1    0.000    0.000    0.000    0.000 {built-in method builtins.exec}<br/>        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}</span></pre><p id="fd46" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">我非常喜欢使用的另一个选项是<code class="fe nj nk nl nm b">line_profiler</code>。这个选项有助于获得更多关于这些时间的信息，这些信息没有包含在<code class="fe nj nk nl nm b">cProfile</code>中。然而，在硬件方面，性能评测器可能是<code class="fe nj nk nl nm b">pylikwid</code>，它提供有关处理器的信息:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="bd22" class="kz la it nm b gy nr ns l nt nu">--------------------------------------------------------------------------------</span><span id="944f" class="kz la it nm b gy nv ns l nt nu">CPU name:   Intel(R) Core(TM) i7-6700HQ CPU @ 2.60 GHz x 8</span><span id="fb32" class="kz la it nm b gy nv ns l nt nu">CPU type:   Intel Core Haswell processor</span><span id="9cb2" class="kz la it nm b gy nv ns l nt nu">CPU clock:  2.60 GHz</span><span id="3aa0" class="kz la it nm b gy nv ns l nt nu">--------------------------------------------------------------------------------</span><span id="8f52" class="kz la it nm b gy nv ns l nt nu">================================================================================</span><span id="a019" class="kz la it nm b gy nv ns l nt nu">Group 1 L3: Region MY_REGION</span><span id="5dde" class="kz la it nm b gy nv ns l nt nu">================================================================================</span><span id="85bc" class="kz la it nm b gy nv ns l nt nu">+-------------------+----------+</span><span id="23f5" class="kz la it nm b gy nv ns l nt nu">|    Region Info    |  Core 0  |</span><span id="125d" class="kz la it nm b gy nv ns l nt nu">+-------------------+----------+</span><span id="b12f" class="kz la it nm b gy nv ns l nt nu">| RDTSC Runtime [s] | 0.091028 |</span><span id="d76a" class="kz la it nm b gy nv ns l nt nu">|     call count    |     1    |</span><span id="d100" class="kz la it nm b gy nv ns l nt nu">+-------------------+----------+</span><span id="add3" class="kz la it nm b gy nv ns l nt nu">+-----------------------+---------+--------------+</span><span id="f8cc" class="kz la it nm b gy nv ns l nt nu">|         Event         | Counter |    Core 0    |</span><span id="bfc0" class="kz la it nm b gy nv ns l nt nu">+-----------------------+---------+--------------+</span><span id="1ae7" class="kz la it nm b gy nv ns l nt nu">|   INSTR_RETIRED_ANY   |  FIXC0  | 9.262083e+08 |</span><span id="c7de" class="kz la it nm b gy nv ns l nt nu">| CPU_CLK_UNHALTED_CORE |  FIXC1  | 3.255393e+08 |</span><span id="820d" class="kz la it nm b gy nv ns l nt nu">|  CPU_CLK_UNHALTED_REF |  FIXC2  | 2.846262e+08 |</span><span id="87db" class="kz la it nm b gy nv ns l nt nu">|    L2_LINES_IN_ALL    |   PMC0  | 1.219118e+06 |</span><span id="ba6c" class="kz la it nm b gy nv ns l nt nu">|     L2_TRANS_L2_WB    |   PMC1  | 9.183680e+05 |</span><span id="4949" class="kz la it nm b gy nv ns l nt nu">+-----------------------+---------+--------------+</span><span id="78ae" class="kz la it nm b gy nv ns l nt nu">+-------------------------------+--------------+</span><span id="6b8f" class="kz la it nm b gy nv ns l nt nu">|             Metric            |    Core 0    |</span><span id="e180" class="kz la it nm b gy nv ns l nt nu">+-------------------------------+--------------+</span><span id="a1f0" class="kz la it nm b gy nv ns l nt nu">|      Runtime (RDTSC) [s]      |  0.09102752  |</span><span id="6c7d" class="kz la it nm b gy nv ns l nt nu">|      Runtime unhalted [s]     | 9.596737e-02 |</span><span id="dcd5" class="kz la it nm b gy nv ns l nt nu">|          Clock [MHz]          | 3.879792e+03 |</span><span id="35c1" class="kz la it nm b gy nv ns l nt nu">|              CPI              | 3.514753e-01 |</span><span id="22d8" class="kz la it nm b gy nv ns l nt nu">|  L3 load bandwidth [MBytes/s] | 8.571425e+02 |</span><span id="d0cc" class="kz la it nm b gy nv ns l nt nu">|  L3 load data volume [GBytes] |  0.078023552 |</span><span id="5824" class="kz la it nm b gy nv ns l nt nu">| L3 evict bandwidth [MBytes/s] | 6.456899e+02 |</span><span id="d7c8" class="kz la it nm b gy nv ns l nt nu">| L3 evict data volume [GBytes] |  0.058775552 |</span><span id="d725" class="kz la it nm b gy nv ns l nt nu">|    L3 bandwidth [MBytes/s]    | 1.502832e+03 |</span><span id="73f1" class="kz la it nm b gy nv ns l nt nu">|    L3 data volume [GBytes]    |  0.136799104 |</span><span id="0a94" class="kz la it nm b gy nv ns l nt nu">+-------------------------------+--------------+</span></pre><p id="fb2b" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">最后，当然还有<code class="fe nj nk nl nm b">memory_profile</code>，可以用来检查你的记忆状态。这可能是这里最重要的配置文件，这就是为什么我把最好的留到了最后！要分析给定函数的内存使用情况，只需将profile decorator添加到您想要分析的内容中，然后使用<code class="fe nj nk nl nm b">memory_profiler</code>运行该文件:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="864d" class="kz la it nm b gy nr ns l nt nu">python -m memory_profiler myfile.py</span></pre><h2 id="1a5b" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">记忆</h2><p id="9d7a" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">好吧，剖析很酷，但这并不是绝对必要的特性。我们可能在查看我们的硬件，但我们没有与我们的硬件互动。对于我们的第一个命令性特性，我们将看看关键词<code class="fe nj nk nl nm b">del</code>。这是Python为我们提供的管理内存的少数工具之一。这个关键字将从Python的内存堆中删除一个给定的变量。用法非常简单，只需将关键字放在变量名之前:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="f3f4" class="kz la it nm b gy nr ns l nt nu">&gt;&gt;&gt; x = 5<br/>&gt;&gt;&gt; <strong class="nm iu">del</strong> x<br/>&gt;&gt;&gt; print(x)<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>NameError: name 'x' is not defined</span></pre><p id="0df5" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">这似乎是一个非常基本的特性，但是许多现代声明式语言并不包含这样的东西。甚至我最喜欢的语言Julia也没有这样的功能。取而代之的是，把事情置之不理，让Julia用垃圾收集来随便处理剩下的事情，这是司空见惯的。不用说，这是一个很棒的特性。肯定有一些时候，我们可能希望通过删除不同的对象来节省内存，幸运的是Python包含了一种开箱即用的方法<code class="fe nj nk nl nm b">del</code>！</p><p id="189c" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">还应该注意的是，有了所有这些例子，C语言还可以做更多的事情。如果你用C语言编写Python库，管理硬件要容易得多，这就是为什么Pandas和NumPy有如此出色的性能！</p><h2 id="20ee" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">处理器</h2><p id="0546" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">对于处理器来说，我们在硬件方面做不了多少语言本身做不了的事情，但是，我确实想借此机会提出C语言方面的另一点。每当您运行一个没有依赖关系的典型Python脚本时，该过程将总是在一个线程上运行。然而，当用C编写Python模块时，可以访问多个线程并从模块中获得更大的性能。再一次，这种语言和解释它的语言之间的简单对话，以及C Python模块到轮子中的进一步打包，使得我们日常使用的许多Python包足够快，可以用于那些应用程序。</p><h2 id="845f" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">国家政治保卫局。参见OGPU</h2><p id="5f44" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">虽然Python最初在设计时从未考虑过数值计算或并行计算，但由于该语言在机器学习中的突出使用，我们现在有了大量不同的GPU包。我个人最喜欢的是Numba。Numba非常棒，因为它不仅提供了GPU加速，还提供了JIT编译——它本质上是最快的Python解释器，无需将Python转换成c。更好的是，它使用一个简单的装饰器来完成这一点。我正好有一篇关于Numba的文章(写于2020年的黑暗时期)，所以如果你想读更多关于Numba的文章，这里有一个链接:</p><div class="nx ny gp gr nz oa"><a rel="noopener follow" target="_blank" href="/numba-jit-compilation-but-for-python-373fc2f848d6"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">Numba: JIT编译，但是用于Python</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">快速浏览一下2020年让Python变得更好的神奇工具。</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">towardsdatascience.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo ks oa"/></div></div></a></div><p id="ea2c" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">另一个很好的选择是Dask模块。Dask在很多方面与JIT相似，但是侧重点有所不同。Dask不仅有助于解决并行计算的速度问题，还有助于在机器集群之间分配工作负载。此外，它有自己的数组对象和接口，最后甚至有这些数组的惰性/代数形式。</p><blockquote class="op oq or"><p id="c1cc" class="lv lw nw lx b ly mx ju ma mb my jx md os mz mf mg ot na mi mj ou nb ml mm mn im bi translated">惰性/代数意味着数组不保存在内存中，而是由一个函数来表示。数据的变化会立即保存和计算，但索引可以按需完成，因为函数只是针对该范围内的数字运行。</p></blockquote></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="b292" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h2><p id="5c5d" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">当谈到命令性特性时，Python是一种肯定不会获奖的语言。然而，与许多其他类似的声明性语言相比，Python确实在这方面用相当少的资源完成了很多工作。使用像Python这样的语言肯定有缺点，不与硬件有密切的关系肯定会是其中之一。也就是说，这肯定不会阻止任何人在需要这种硬件集成时用Python做原型并将操作转移到C。幸运的是，即使您不想重新使用ole GCC并编写一个Python模块，仍然有很多方法可以减轻Python的声明性并提高您的性能！</p></div></div>    
</body>
</html>