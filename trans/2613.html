<html>
<head>
<title>Why Pandas-like Interfaces are Sub-optimal for Distributed Computing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么熊猫式界面对于分布式计算来说不是最佳的</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/why-pandas-like-interfaces-are-sub-optimal-for-distributed-computing-322dacbce43#2022-06-07">https://towardsdatascience.com/why-pandas-like-interfaces-are-sub-optimal-for-distributed-computing-322dacbce43#2022-06-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c7cc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">深入了解熊猫界面的假设</h2></div><p id="4986" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编剧<a class="ae lb" href="https://www.linkedin.com/in/kvnkho/" rel="noopener ugc nofollow" target="_blank">凯文·库</a>和<a class="ae lb" href="https://www.linkedin.com/in/han-wang-97272610/" rel="noopener ugc nofollow" target="_blank">汪涵</a></p><p id="bf89" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们最近的<a class="ae lb" href="https://www.youtube.com/watch?v=b3ae0m_XTys" rel="noopener ugc nofollow" target="_blank">皮肯谈话</a>的书面版本。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/d0e2b1ef2857aa32c737d855f6f1063e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G08NSZUH0IOuPfxg"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">照片由<a class="ae lb" href="https://unsplash.com/@tateisimikito?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jukan Tateisi </a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="1d3a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">分布式计算的熊猫式框架</h1><p id="90e9" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">在过去的一年半时间里，我们与想要将Pandas代码转移到Dask或Spark以利用分布式计算资源的数据从业者进行了交谈。他们的工作负载很快变得过于计算密集型，或者他们的数据集不再适合Pandas，Pandas只能在一台机器上运行。</p><p id="295f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的对话中，一个反复出现的主题是像考拉(更名为PySpark Pandas)和<a class="ae lb" href="https://github.com/modin-project/modin" rel="noopener ugc nofollow" target="_blank"> Modin </a>这样的工具，它们旨在使用相同的Pandas接口将工作负载引入Dask、Ray或Spark，只需改变import语句(大部分)。</p><p id="6ca2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，PySpark Pandas <a class="ae lb" href="https://databricks.com/blog/2021/10/04/pandas-api-on-upcoming-apache-spark-3-2.html" rel="noopener ugc nofollow" target="_blank">的替代产品</a>可能是:</p><pre class="ld le lf lg gt mp mq mr ms aw mt bi"><span id="6e82" class="mu lt iq mq b gy mv mw l mx my"># import pandas as pd<br/>import pyspark.pandas as pd</span></pre><p id="bf9b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">据推测，所有东西都应该在Spark上运行。已经有一些<a class="ae lb" href="https://lakefs.io/how-easy-it-is-to-re-use-old-pandas-code-in-spark-3-2/" rel="noopener ugc nofollow" target="_blank">博客</a>表明这并不完全正确(截至2022年5月)。这里和那里都有一些小问题，但我们在这里不是为了谈论微小的差异。<strong class="kh ir">这篇文章讲的是由于分布式计算的细微差别而一直存在的根本差异，而熊猫与分布式计算并不兼容。</strong></p><p id="563f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类似熊猫的框架之所以流行，是因为很多数据科学家抗拒改变(我自己也经历过！).但是仅仅改变导入语句会使用户避免理解分布式系统中真正发生的事情，缺乏理解会导致无效的使用。</p><p id="468c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将看到，试图与Pandas API实现1:1对等将需要在性能和功能上做出妥协。</p><h1 id="b8e4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">基准数据</h1><p id="69dd" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我们创建了一个具有以下结构的数据帧。列<code class="fe mz na nb mq b">a</code>和<code class="fe mz na nb mq b">b</code>是字符串列。列<code class="fe mz na nb mq b">c</code>和<code class="fe mz na nb mq b">d</code>是数值。这个数据帧将有一百万行(但是我们也会在某些情况下改变它)。</p><p id="b90b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将在Pandas、Modin (on Ray)、PySpark Pandas和Dask中创建这个数据帧。对于每个后端，我们将对不同案例的操作进行计时。这一点在讨论完第一个问题后应该会更加清晰。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/25492268075f10696c4065817274ee24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/0*K-OSXQShdehsyGN3"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">按作者分类的图像-示例数据</p></figure><h1 id="7578" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">问题1: Pandas假设数据在物理上是在一起的</h1><p id="0268" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">最常用的熊猫方法之一是<code class="fe mz na nb mq b">iloc</code>。这依赖于数据的隐式全局排序。这就是为什么Pandas可以快速检索给定索引值集中的行。它知道在哪里访问它需要检索的行的内存。</p><p id="911f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下面代码片段中的5种情况为例，我们将评估每种操作相对于情况1的速度。<strong class="kh ir">我们不进行跨框架的比较。我们希望看到每个框架的不同性能。</strong>下面的案例3–5是基于位置访问行和列。情况5特别是在数据帧的中间。我们将在熊猫、摩丁、PySpark熊猫(也称为考拉)和Dask上运行这五个案例。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="fd1e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下面的基准测试中，Pandas在使用整数位置值访问数据时速度加快了。这是因为在单台机器上访问内存中的数据相对便宜。在各种情况下，Modin在提供一致的性能方面做得很好，但是当访问数据帧的中间时(情况5)，速度降低了2倍。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nf"><img src="../Images/155d32f2a263c3bfb6a20316b3a4d6b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p-cxxzzIVvIrpJvB-wlGJQ.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">按作者分类的图片—数据访问比较</p></figure><p id="4322" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">PySpark Pandas(表中标为Spark)和Dask给出了有趣的结果。Spark在所有情况下都有明显的减速。得到头部是相对优化的，但是其他的都是性能较差的。事实上，获取数据帧的尾部或中部会导致15倍于获取头部的持续时间(情况1)。</p><p id="2c49" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Dask实际上不允许在行上使用<code class="fe mz na nb mq b">iloc</code>。为了让<code class="fe mz na nb mq b">iloc</code>表现得像熊猫一样，必须对性能做出妥协，以维持全球秩序。这是一个有意的设计决策，偏离了熊猫的语义以保持性能。</p><p id="fdf4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">PySpark Pandas以牺牲性能为代价，优先考虑维持熊猫的平价。与此同时，Dask对防止不良行为更加敏感。对比这些框架向我们展示了设计理念的不同。这也是第一次表明<strong class="kh ir">统一界面并不意味着一致的性能特征。</strong></p><h1 id="8a38" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">问题2:熊猫认为数据洗牌很便宜</h1><p id="bc56" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">在分布式环境中，数据存在于多台机器上。有时，需要跨机器重新安排数据，以便每个工人拥有属于一个逻辑组的所有数据。这种数据移动被称为“洗牌”，是分布式计算中不可避免但代价高昂的一部分。</p><p id="66e9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">取两个等价的运算。目标是为每个<code class="fe mz na nb mq b">d</code>值保留具有最高值<code class="fe mz na nb mq b">c</code>的行。注意a <code class="fe mz na nb mq b">groupby-max</code>并不保存整行。案例1执行全局排序，然后删除重复项以保留最后一行。另一方面，情况2使用<code class="fe mz na nb mq b">groupby-idxmax</code>操作来保持最大行。然后较小的数据帧被合并回原始数据帧。该基准测试使用了100k行，而不是100万行。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e096" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于熊猫来说，情况2实际上比情况1慢，如下表所示。所有的分布式计算框架在第二种情况下都要快得多，因为它们避免了全局排序。相反，<code class="fe mz na nb mq b">groupby-idxmax</code>是一个优化的操作，首先发生在每个工作机器上，连接将发生在一个更小的数据帧上。可以优化小数据帧和大数据帧之间的连接(例如，广播连接)。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/12b8f4d101559dc55dbf093e809813ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*R6MswImUP_aGS0ZYmuCIDQ.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">作者提供的图片—随机比较</p></figure><p id="cd7d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个很常见的熊猫代码片段的例子，它不能很好地翻译成分布式设置。类似于问题1中的全局排序讨论，进行全局排序是一个非常昂贵的操作。</p><p id="a2a5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">熊猫式框架的问题在于，用户最终会以相同的本地计算思维方式处理大数据问题。如果用户在迁移到分布式设置时不更改代码，很容易遇到耗时过长的次优操作。</p><h1 id="6c97" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">问题3:熊猫认为指数是有益的</h1><p id="3ae3" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">熊猫思维中根深蒂固的核心概念之一是指数。如果用户有熊猫背景，他们会认为这个指数是有益的，值得设置或重置。让我们看看这如何转化为其他后端。</p><p id="711f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下面的代码片段为例。我们筛选给定的组，然后计算这些记录的总和。案例1没有索引，案例2使用了索引。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4453" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">具体来说，<code class="fe mz na nb mq b">set_index</code>没有包含在基准测试中。这是因为<code class="fe mz na nb mq b">set_index</code>有自己的开销。结果如下所示:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/37af6b1194d163c34f501e0301c8cbb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*DKfyar9dPMPvYMFV0KjhBA.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">按作者分类的图像—索引行为比较</p></figure><p id="3db5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于熊猫来说，当数据帧被<code class="fe mz na nb mq b">a</code>索引时，速度会加快。对于摩丁或者火花来说，并没有什么改善。Dask有显著的改进。</p><p id="c225" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">同样，统一的界面并不意味着一致的性能特征。</strong>通常，某些操作无法满足用户期望。这个也没办法有好的直觉。我们已经知道，为了支持Pandas API的分布式版本，必须做出一些妥协，但是很难知道那些设计决策到底是什么。每一个类似熊猫的框架都需要在不同的方向进行特定的优化。</p><p id="5dfc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还要注意，对于上面提到的所有类似Pandas的框架，MultiIndex并不完全受支持。</p><h1 id="6943" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">问题4:急切与懒惰的评估(第一部分)</h1><p id="9308" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">惰性评估是分布式计算框架的一个关键特性。当在数据帧上调用操作时，会构建一个计算图。只有在执行需要数据的操作时，操作才会发生。</p><p id="4770" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下面的代码片段中，案例1读取文件并计算所有列的最小值。案例2读取文件并计算两列的最小值。对于这个问题，我们将使用不同的数据集。这个新的有40列和200万行随机数。在这个一行表达式中有两三个步骤:加载文件，过滤列，然后得到最小值。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="08df" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果如下所示。因为熊猫和摩丁对事物的评价都是热切的，所以案例2只是比案例1略有缩减。这是因为最小值的计算量较少(两列而不是全部)。但是加速并不多，因为在过滤所需的列之前，先读取全部数据。</p><p id="a153" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，PySpark Pandas和Dask对这个操作有巨大的加速。这是因为他们知道最终只需要两列，所以他们只从parquet加载这两列(parquet相对于csv文件的一个好处)。对于三个操作(load、filter、min)，PySpark Pandas和Dask能够通过最小化磁盘I/O来优化计算，这是由于它们的惰性。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/a179d83908dcdf6c61c0ea5897ac95a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*9nEbwyjj3zeH-_e6rjSUbA.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">作者图片—懒评对比1</p></figure><p id="195f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">摩丁特别选择优化迭代工作负载的体验，并且还匹配熊猫的行为。另一方面，PySpark熊猫选择了和Spark一样的懒评价。即使它们都是“分布式熊猫”的一种形式，它们也有非常不同的性能特征。</p><h1 id="2ca6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">问题4:急切与懒惰的评估(第二部分)</h1><p id="92f9" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">在这里，我们看到一个热切评价帮助用户的案例。但是当实践者不理解懒惰评估时，也很容易遇到重复工作。</p><p id="a725" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请参见以下案例，案例1仅获取两列的最小值，而案例2获取最小值、最大值和平均值。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2165" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下面的结果中，熊猫和摩丁似乎没有在案例2中发生任何重新计算。<code class="fe mz na nb mq b">sub</code>被读取后已经保存在内存中。这是意料之中的，因为我们在上一个基准中看到熊猫和摩丁热切地评价。另一方面，PySpark Pandas和Dask表明<code class="fe mz na nb mq b">sub</code>被计算了多次，因为我们没有明确地<a class="ae lb" href="https://spark.apache.org/docs/latest/rdd-programming-guide.html#rdd-persistence" rel="noopener ugc nofollow" target="_blank">持久化</a> <code class="fe mz na nb mq b">sub</code>。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/ccb30280aab54751e537c62132b5eedf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*4WzV-AxMry102o22PuiGkQ.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">作者图片—懒评对比2</p></figure><p id="380d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第4期中，我们看到了懒惰评估的两面性。我们看到了一个场景，其中它导致了急剧的加速，在最后一个场景中，当使用不当时，它会导致速度变慢。这并不意味着急切或懒惰的评估更好，更重要的是<strong class="kh ir">当我们处理大数据以获得最佳结果时，我们需要注意框架正在做什么。</strong></p><p id="fcf6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个常见的陷阱，因为Pandas没有让用户注意到分布式计算复杂性的语法。从熊猫来的人不知道<code class="fe mz na nb mq b">persist</code>行动。</p><h1 id="2394" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="166b" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">Pandas非常适合本地计算(除了有太多的方法来做一些操作)。但是我们需要认识到该接口的固有局限性，并且理解它不是为在几台机器上扩展而构建的。<strong class="kh ir"> Pandas不是为分布式计算设计的接口。</strong></p><p id="3272" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想尝试另一个不像熊猫的语义层，<a class="ae lb" href="https://github.com/fugue-project/fugue/" rel="noopener ugc nofollow" target="_blank">赋格</a>采取了不同的方法。Fugue是一个用于分布式计算的开源抽象层。虽然它可以将Pandas代码引入Spark和Dask，但它有意与Pandas接口解耦，以避免面临Pandas类框架所面临的妥协。</p></div></div>    
</body>
</html>