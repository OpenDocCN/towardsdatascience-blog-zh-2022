<html>
<head>
<title>Don’t use R in production</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要在生产中使用R</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dont-use-r-in-production-e2f4c9dd4a7b#2022-08-12">https://towardsdatascience.com/dont-use-r-in-production-e2f4c9dd4a7b#2022-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0156" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">但是，如果你这样做，这里是如何</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b2f62e795578e382d61faa7a0fceab8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F4U8q9PXH9F0MSqJnRyEmA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">DALL-E生成:计算机科学可再生技术环境的说明</p></figure><p id="66ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们已经在生产中运行R好几年了，这篇文章是关于如何让它发生的。这篇文章也是关于为什么我仍然不认为你应该在生产中运行R，如果你真的不需要它。我是从一个工程师的角度来看这个问题的。我们将讨论许可、R限制以及如何解决主要障碍，以达到这样一个目的，即您可以在生产环境中运行Rscripts，而不那么痛苦(<a class="ae lu" href="https://github.com/digital-thinking/reproducible-r" rel="noopener ugc nofollow" target="_blank"> Github link </a>)。这篇文章不是关于付费或托管服务的。</p><h1 id="d97f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">生产中的研发</h1><h2 id="81e7" class="mn lw it bd lx mo mp dn mb mq mr dp mf lh ms mt mh ll mu mv mj lp mw mx ml my bi translated">使用检查点解决版本控制问题</h2><p id="484b" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">R的最大问题是可重复性。与Python相比，R没有高级版本和包管理。数据科学家在他们的机器上使用R，安装所有的包并使用当时发布的版本。从用户的角度来看，这很容易，不需要考虑版本控制。但是如果您现在想在其他机器上运行这个脚本，那么它很有可能不起作用，尤其是在编写脚本和部署之间有延迟情况下。安装一个旧版本的R包并不像你想象的那样简单，有很多方法，但是很麻烦。</p><p id="1be7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">微软承认这一点，并建立了<a class="ae lu" href="https://mran.microsoft.com/package/checkpoint" rel="noopener ugc nofollow" target="_blank">检查点</a>库，它这样描述自己:</p><blockquote class="ne nf ng"><p id="09e2" class="ky kz nh la b lb lc ju ld le lf jx lg ni li lj lk nj lm ln lo nk lq lr ls lt im bi translated">checkpoint的目标是解决r中的包可复制性问题。具体来说，checkpoint允许您在特定的快照日期安装CRAN上存在的包，就像您有一台CRAN时间机器一样。</p></blockquote><p id="d641" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，有了checkpoint，我们可以选择按日期进行版本化，而且到目前为止已经有了可复制的R环境。这个帖子在使用checkpoint的同时，还有<a class="ae lu" href="https://rstudio.github.io/renv/articles/renv.html" rel="noopener ugc nofollow" target="_blank"> renv </a>，解决了同样的问题。</p><p id="38c5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用它很简单，我们只需将它添加到我们的<em class="nh">脚本</em>中:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="a800" class="mn lw it nm b gy nq nr l ns nt">library(checkpoint)<br/>checkpoint(“2022–07–17”, r_version=”4.2.1")</span></pre><p id="dbd1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Checkpoint将扫描脚本中的导入并管理它们，但是如果您有自定义包，您需要在包含以下内容的<em class="nh"> checkpoint.yml </em>中排除这些包:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="d5d3" class="mn lw it nm b gy nq nr l ns nt">exclude:<br/>   - myRPackage</span></pre><h2 id="a1b1" class="mn lw it bd lx mo mp dn mb mq mr dp mf lh ms mt mh ll mu mv mj lp mw mx ml my bi translated">使用Docker隔离环境</h2><p id="e2dd" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">通常，我们有多个脚本，使用不同的库和版本。为了使它们相互独立，我们使用Docker。有了Docker，我们可以构建可靠的环境，并将它们部署到我们想要的任何地方。Docker与检查点库相结合，解决了可再现性问题。</p><p id="02af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://rocker-project.org/images/versioned/r-ver.html" rel="noopener ugc nofollow" target="_blank"> rocker </a>项目提供了预构建的版本化R容器，我们可以通过扩展版本化映像来使用这些容器:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="7ac7" class="mn lw it nm b gy nq nr l ns nt">ARG VERSION=”4.1.0"<br/>FROM rocker/r-ver:$VERSION as base<br/># Install needed packages and git<br/>RUN apt-get update \<br/>&amp;&amp; apt-get -y install \<br/>libgit2-dev \<br/>libcurl4-openssl-dev \<br/>libssl-dev (...)</span><span id="075e" class="mn lw it nm b gy nu nr l ns nt"># checkout our git repository<br/>WORKDIR /workdir<br/>RUN git clone <a class="ae lu" href="https://{secret_key}@github.com/username/repo.git" rel="noopener ugc nofollow" target="_blank">https://{secret_key}@github.com/username/repo.git</a> .</span><span id="2701" class="mn lw it nm b gy nu nr l ns nt"># install checkpoint library<br/>RUN Rscript -e “install.packages(‘checkpoint’)”</span><span id="3fe6" class="mn lw it nm b gy nu nr l ns nt">#start R script<br/>CMD git pull &amp;&amp; Rscript my_r_script.R</span></pre><p id="08d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了这个小docker文件，你已经能够用一个特定的R版本来启动一个R脚本了(<strong class="la iu"> docker run </strong>),而且你还可以确保所使用的库的版本是由检查点库修复的。但是，您会注意到执行花费了相当长的时间，因为检查点库第一次管理指定日期的脚本依赖项时，需要花几分钟来下载和设置它们，并且每次都是这样。</p><h2 id="88ac" class="mn lw it bd lx mo mp dn mb mq mr dp mf lh ms mt mh ll mu mv mj lp mw mx ml my bi translated">确定开始时间</h2><p id="2d79" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">像这样使用Docker和预构建的R-images是一个很好的开端，但是我们必须解决另一个问题。如果我们在每次代码更改时都从头构建映像，我们会有巨大的开销，因为检查点库最初需要花费很多时间来构建。但是，如果R代码发生变化，我们不需要构建映像，也不需要每次都清除检查点。</p><p id="7cec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了避免这种情况，我们将R脚本的执行移出了docker文件。为了避免在设置R之后关闭容器，我们在最后调用<strong class="la iu">sleep infinity</strong>将控制权交给我们的bash脚本。</p><p id="a0d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在bash脚本必须自己启动和停止docker容器。然而，现在我们可以在启动R脚本之前执行git pull，而不必在每次代码更改时都重新构建容器。</p><p id="9543" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Dockerfile文件中，我们通过调用以下命令来替换最后一个命令:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="2dbc" class="mn lw it nm b gy nq nr l ns nt">CMD sleep infinity</span></pre><p id="c024" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们最初构建容器(或者如果我们需要更新依赖项),使用:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="8d1c" class="mn lw it nm b gy nq nr l ns nt">docker build --no-cache -t foo_image . #build the image<br/>docker create --name foo_container foo_image #create container</span></pre><p id="4fed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的bash脚本完成了以下工作</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="3bc8" class="mn lw it nm b gy nq nr l ns nt">docker start foo_container<br/>docker exec foo_container git pull origin master<br/>docker exec foo_container Rscript my_r_script.R<br/>docker stop foo_container</span></pre><p id="546a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了这些简单的脚本(<a class="ae lu" href="https://github.com/digital-thinking/reproducible-r" rel="noopener ugc nofollow" target="_blank"> github </a>)我们现在可以快速、可伸缩和可复制地运行R脚本。</p><h1 id="8fc7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">为什么R还不用于生产</h1><h2 id="b4b5" class="mn lw it bd lx mo mp dn mb mq mr dp mf lh ms mt mh ll mu mv mj lp mw mx ml my bi translated">许可证</h2><p id="590c" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">R使用多个许可证，大多数核心R库都是在copyright license下发布的，比如GPL-2和GPL-3。因此，在某些情况下，这已经是一个问题。如果您计划编写R代码并将其作为产品的一部分发布，您将被迫开源您的代码。这已经是一个原因，为什么没有很多产品允许在云环境中执行R。然而，如果您的产品没有附带R，那么对于核心库来说，您很可能是安全的。但由于我不是律师，请询问你们的法律部门。</p><h2 id="f5dd" class="mn lw it bd lx mo mp dn mb mq mr dp mf lh ms mt mh ll mu mv mj lp mw mx ml my bi translated">r不适合软件工程师</h2><p id="59dc" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">大多数R用户不会发现这些问题，直到他们必须反复修改他们的脚本。这很好，因为大多数R-coder不是软件工程师，不需要知道产品软件应该是什么样子。然而，经常有人试图争辩，因为它对他们来说很容易使用，它在其他地方也一定很容易使用。以下是我个人在生产中遇到的一些实际问题:</p><ul class=""><li id="7bc8" class="nv nw it la b lb lc le lf lh nx ll ny lp nz lt oa ob oc od bi translated">R <strong class="la iu">缺乏OOP支持</strong>，R是一种函数式语言是有充分理由的。这对小脚本来说很好，但对大项目来说是个问题，因此不建议构建更大、更复杂的应用程序。r更像是编写狭窄任务的脚本，而不是管理大型工作流。</li><li id="7ac2" class="nv nw it la b lb oe le of lh og ll oh lp oi lt oa ob oc od bi translated">与编译语言相比，r本身很慢。因此，很多R库要么依赖于<strong class="la iu">预编译的二进制文件</strong>，要么需要安装g++工具链<strong class="la iu">从源代码</strong>构建它们。该来源依赖于平台，可能会导致许多问题。此外，出于安全原因，您(或您的IT)不希望在生产服务器上使用g++。</li><li id="3f29" class="nv nw it la b lb oe le of lh og ll oh lp oi lt oa ob oc od bi translated">您可以生成日志，但这很糟糕，因为您<strong class="la iu">不能轻松地将所有相同格式的日志重定向到<strong class="la iu"> std:out和std:err </strong>，所以如果您将日志推入ELK(或类似的)并处理来自R print语句的多行日志，您必须做更多的工作。</strong></li><li id="c458" class="nv nw it la b lb oe le of lh og ll oh lp oi lt oa ob oc od bi translated">在python中，你有requirements.txt/setup.py来定义需求，处理依赖和版本，在R中你没有。r易于使用，但这是有代价的。这表明R正在<strong class="la iu">关注特定的分析任务</strong>。</li><li id="e20c" class="nv nw it la b lb oe le of lh og ll oh lp oi lt oa ob oc od bi translated">当您在自己的机器上编写代码时，它可能无法在另一台机器上运行，尤其是如果中间有一段时间。变化很大，一些库被修改了，代码不再工作了。r缺乏非常基本的<strong class="la iu">版本控制</strong>。</li><li id="a8be" class="nv nw it la b lb oe le of lh og ll oh lp oi lt oa ob oc od bi translated"><strong class="la iu"> CI/CDs工具通常不支持R </strong>，你必须定制一切。这包括单元测试、集成测试、静态代码检查、包部署和版本控制。</li><li id="12fd" class="nv nw it la b lb oe le of lh og ll oh lp oi lt oa ob oc od bi translated">r没有成熟的生态系统来部署web服务器和API。有用于简单可视化的<a class="ae lu" href="https://shiny.rstudio.com/" rel="noopener ugc nofollow" target="_blank">闪亮的</a>和用于API的<a class="ae lu" href="https://www.opencpu.org/" rel="noopener ugc nofollow" target="_blank"> OpenCPU </a>和<a class="ae lu" href="https://www.rplumber.io/" rel="noopener ugc nofollow" target="_blank">水管工</a>，但正如其名称所示，它笨重且感觉有限，与Python等语言中的类似工具相去甚远。特别是R用户经常提倡的plumber，缺少HTTPs、OAUTH和其他大多数更高级的特性。此外，在R中，一切都是单线程的。</li><li id="7dc2" class="nv nw it la b lb oe le of lh og ll oh lp oi lt oa ob oc od bi translated">社区中没有安全问题的意识，人们经常用devtools安装未经检查的github库。这是生产服务器上的一个主要安全问题(不仅仅是那里)。</li><li id="09fb" class="nv nw it la b lb oe le of lh og ll oh lp oi lt oa ob oc od bi translated">r确实比python更容易崩溃，因为它的易用性和函数式编程风格让用户不必考虑极限情况。</li></ul><h1 id="fc16" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="198b" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">在这篇文章中，我展示了为什么我认为R不是生产用例的好选择。然而，有时候无论如何都是有意义的。原因可能是上市时间、团队组成或技术基础设施。对于这些情况，我展示了如何使用Docker和checkpoint以可重复的方式部署R。代码可以在<a class="ae lu" href="https://github.com/digital-thinking/reproducible-r" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div></div>    
</body>
</html>