<html>
<head>
<title>Business logic in DBT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DBT 的商业逻辑</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/business-logic-in-dbt-cf72a31bbcfd#2022-03-14">https://towardsdatascience.com/business-logic-in-dbt-cf72a31bbcfd#2022-03-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1e82" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">实现定制逻辑有很多种可能性，这个框架可以帮助您对选项进行排序。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bdaac7e1d042462c0203c77ecff01b26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I_9tnNXBVyyK74BX4P8b8w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">DBT 的默认配置。图片作者。</p></figure><p id="75fc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我真的很喜欢使用<a class="ae lr" href="https://www.getdbt.com" rel="noopener ugc nofollow" target="_blank"> DBT </a>来构建数据管道，它执行的框架要求你以标准化的方式构建管道。该工具完美地结合了数据工程和数据科学，为前者提供了一种动态编码的方式，并约束了后者。作为一名数据科学家，我花了数年时间，在数据管道内外，通过运行 python 进程动态生成复杂的 SQL 代码。模板是这种自由流动的数据科学工作的第二天性，DBT 为数据工程师展示了这种工具以及适用于大多数管道的结构。</p><p id="5b12" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">数据工程的核心是业务逻辑:转换本身包含打开数据的关键信息。对于我们这里的例子，让我们将美国的一个<code class="fe ls lt lu lv b">state</code>列重新编码为一个<code class="fe ls lt lu lv b">region</code>:四个<a class="ae lr" href="https://en.wikipedia.org/wiki/List_of_regions_of_the_United_States#Census_Bureau-designated_regions_and_divisions" rel="noopener ugc nofollow" target="_blank">人口普查被指定为东北、南部、中西部和西部的区域之一</a>。为了帮助我们在构建这一渠道的各种选项之间做出决定，让我们列出我们关心的问题:</p><ol class=""><li id="45bc" class="lw lx iq kx b ky kz lb lc le ly li lz lm ma lq mb mc md me bi translated">人类可读性:我们应该能够理解逻辑，并看到值来自哪里。</li><li id="debf" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated">灵活性:我们希望为这种映射中的变化做好准备，例如，一个新的州加入美国或一个现有的州切换区域。</li><li id="dd5b" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated">机器可读性和 DRY:这个逻辑应该可以被程序解释，这样我们就不需要重复硬编码的值。</li></ol><h2 id="3539" class="mk ml iq bd mm mn mo dn mp mq mr dp ms le mt mu mv li mw mx my lm mz na nb nc bi translated">选项 1:将您的业务逻辑硬编码在 SQL 中</h2><p id="1668" class="pw-post-body-paragraph kv kw iq kx b ky nd jr la lb ne ju ld le nf lg lh li ng lk ll lm nh lo lp lq ij bi translated">从各方面来看，这都不太理想，但这可能是一个起点。它可能看起来像这样:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="886b" class="mk ml iq lv b gy nm nn l no np">SELECT state, <br/>       CASE WHEN state IN ('CT', 'ME', ...) THEN 'Northeast'<br/>            WHEN state IN ('IL', 'IN', ...) THEN 'Midwest'<br/>            ...<br/>       ELSE NULL END AS region<br/>  FROM {{ ref('my_table') }}</span></pre><p id="6dda" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以只编码三个区域，让<code class="fe ls lt lu lv b">ELSE</code>语句捕捉第四个区域。我们将编码所有四个:显式击败隐式。</p><p id="c7c3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用这种硬编码的逻辑，每次更改都需要更改代码。</p><p id="c409" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您的逻辑还没有被硬编码到 SQL 中，请选择选项 2 或 3。让我们不要对这种方法进行过多的讨论，向前推进到在每一点上都更好的解决方案。</p><h2 id="9355" class="mk ml iq bd mm mn mo dn mp mq mr dp ms le mt mu mv li mw mx my lm mz na nb nc bi translated">选项 2:将逻辑放在一个表中，并使用一个连接来执行它</h2><p id="7267" class="pw-post-body-paragraph kv kw iq kx b ky nd jr la lb ne ju ld le nf lg lh li ng lk ll lm nh lo lp lq ij bi translated">这里有一个我可以支持的想法。您的代码就是您的代码:它从 state 列创建 region 列。如果确切的映射发生变化，数据需要更新，但不是您的代码！这些数据可以用许多不同的方式来管理，甚至可以由业务涉众或下游用户来管理。具体来说，这应该是这样的:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="c057" class="mk ml iq lv b gy nm nn l no np">SELECT state, <br/>       lookup.region<br/>  FROM {{ ref('my_table') }}<br/>  JOIN {{ source('fact_schema', 'lookup_table') }} lookup<br/>       USING(state)</span></pre><p id="f8c9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这与我们的目标非常吻合，现在我们需要一种存储逻辑本身的方法。我认为有三种选择:</p><h2 id="7e4a" class="mk ml iq bd mm mn mo dn mp mq mr dp ms le mt mu mv li mw mx my lm mz na nb nc bi translated">选项 2(a):使用 DBT seed csv</h2><p id="5d22" class="pw-post-body-paragraph kv kw iq kx b ky nd jr la lb ne ju ld le nf lg lh li ng lk ll lm nh lo lp lq ij bi translated">dbt 中的种子是 dbt 加载到数据库中的 csv 文件，供下游使用。这使得 csv 文件处于版本控制中，对于这个用例来说，这是一个很酷的特性。这确实是 dbt 中 seed 功能的预期用途，我同意他们在文档中的建议<a class="ae lr" href="https://docs.getdbt.com/docs/building-a-dbt-project/seeds" rel="noopener ugc nofollow" target="_blank">:</a></p><blockquote class="nq nr ns"><p id="d5f7" class="kv kw nt kx b ky kz jr la lb lc ju ld nu lf lg lh nv lj lk ll nw ln lo lp lq ij bi translated">种子是您的 dbt 项目中的 CSV 文件(通常在您的<code class="fe ls lt lu lv b">seeds</code>目录中)，dbt 可以使用<code class="fe ls lt lu lv b">dbt seed</code>命令将其加载到您的数据仓库中。</p><p id="3956" class="kv kw nt kx b ky kz jr la lb lc ju ld nu lf lg lh nv lj lk ll nw ln lo lp lq ij bi translated">种子可以像引用模型一样在下游模型中被引用——通过使用<code class="fe ls lt lu lv b">ref</code> <a class="ae lr" href="https://docs.getdbt.com/reference/dbt-jinja-functions/ref" rel="noopener ugc nofollow" target="_blank">函数</a>。</p><p id="c4b0" class="kv kw nt kx b ky kz jr la lb lc ju ld nu lf lg lh nv lj lk ll nw ln lo lp lq ij bi translated">因为这些 CSV 文件位于您的 dbt 存储库中，所以它们是受版本控制的，并且代码是可审查的。种子最适合不经常改变的静态数据。</p><p id="0811" class="kv kw nt kx b ky kz jr la lb lc ju ld nu lf lg lh nv lj lk ll nw ln lo lp lq ij bi translated">种子的良好用例:<br/> -国家代码到国家名称的映射列表<br/> -从分析中排除的测试电子邮件列表<br/> -员工帐户 id 列表</p></blockquote><h2 id="69e7" class="mk ml iq bd mm mn mo dn mp mq mr dp ms le mt mu mv li mw mx my lm mz na nb nc bi translated">选项 2(b):将它作为一系列插入存储在 SQL 文件中</h2><p id="5be2" class="pw-post-body-paragraph kv kw iq kx b ky nd jr la lb ne ju ld le nf lg lh li ng lk ll lm nh lo lp lq ij bi translated">这个选项很臭，我就不多说了。明确地说，我的意思是编写一个<code class="fe ls lt lu lv b">.sql</code>文件，将数据直接插入到表中。您可以在 dbt 中这样做，这里有一个简单的版本来说明这个想法，如<code class="fe ls lt lu lv b">lookup_table.sql</code>:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="c7cd" class="mk ml iq lv b gy nm nn l no np">WITH data as (<br/>SELECT 'CT' as state, 'Northeast' as region<br/>UNION<br/>SELECT 'ME' as state, 'Northeast' as region<br/>UNION<br/>SELECT 'IL' as state, 'Midwest' as region<br/>UNION<br/>SELECT 'IN' as state, 'Midwest' as region<br/>)<br/>SELECT state, region<br/>FROM data</span></pre><h2 id="89d0" class="mk ml iq bd mm mn mo dn mp mq mr dp ms le mt mu mv li mw mx my lm mz na nb nc bi translated">选项 2(c):存储在 python/R 中，并直接推送到数据库</h2><p id="a0db" class="pw-post-body-paragraph kv kw iq kx b ky nd jr la lb ne ju ld le nf lg lh li ng lk ll lm nh lo lp lq ij bi translated">这里的主要问题是，您将项目分成了两个部分:预 dbt 步骤和 dbt 步骤。虽然有些情况下这是有意义的，但是我们可以在 dbt 中轻松完成这一步，所以我们不要追求这个选项。</p><h2 id="e3b0" class="mk ml iq bd mm mn mo dn mp mq mr dp ms le mt mu mv li mw mx my lm mz na nb nc bi translated">选项 3:在动态查询中使用 DBT 变量</h2><p id="0d4e" class="pw-post-body-paragraph kv kw iq kx b ky nd jr la lb ne ju ld le nf lg lh li ng lk ll lm nh lo lp lq ij bi translated">在<code class="fe ls lt lu lv b">dbt_project.yml</code>中，您可以定义<a class="ae lr" href="https://docs.getdbt.com/reference/dbt-jinja-functions/var" rel="noopener ugc nofollow" target="_blank">变量</a>，然后<a class="ae lr" href="https://docs.getdbt.com/docs/building-a-dbt-project/jinja-macros" rel="noopener ugc nofollow" target="_blank">在查询</a>中使用这些变量。我们可以将数据作为变量存储在 yaml 中，如下所示:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="2eaa" class="mk ml iq lv b gy nm nn l no np">vars:<br/>  state_lookup:<br/>    Northeast:<br/>      - CT<br/>      - ME<br/>    Midwest:<br/>      - IL<br/>      - IN</span></pre><p id="931f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后我们将动态生成 SQL，如下所示</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="7b1e" class="mk ml iq lv b gy nm nn l no np">SELECT state,<br/>       CASE {% for k, v in var("state_lookup").items() %}<br/>            WHEN state in ({% for t in v %}'{{ t }}'{% if not loop.last %}, {% endif %}{% endfor %}) THEN {{ k }}{% endfor %}<br/>            ELSE NULL END AS region<br/>  FROM {{ ref('my_table') }}</span></pre><p id="aaf0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里的中间部分只是构建一个逗号分隔的列表，为它编写一个函数会使它看起来更好。让我们用一个<code class="fe ls lt lu lv b">csl</code>过滤器(逗号分隔列表)快速查看一下:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="627e" class="mk ml iq lv b gy nm nn l no np">SELECT state,<br/>       CASE {% for k, v in var("state_lookup").items() %}<br/>            WHEN state in ({{ v|csl }}) THEN {{ k }}{% endfor %}<br/>            ELSE NULL END AS region<br/>  FROM {{ ref('my_table') }}</span></pre><p id="a7db" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是人和机器都可读的(耶为 yaml！)，而且它很灵活，是目前为止我最喜欢的选择。愿你的数据管道畅通，你的传呼机警报少！</p></div></div>    
</body>
</html>