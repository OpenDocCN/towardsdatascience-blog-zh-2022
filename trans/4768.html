<html>
<head>
<title>6 Methods for Multi-step Forecasting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多步预测的6种方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/6-methods-for-multi-step-forecasting-823cbde4127a#2022-10-24">https://towardsdatascience.com/6-methods-for-multi-step-forecasting-823cbde4127a#2022-10-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d43b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用Python预测时间序列的多个值</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/af0a31f5cc9acfb027c8393bd1636a0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mRYlzVW9TI_nCxEZ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">西蒙·伯杰在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="9df0" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">重要的事情先来。<strong class="li iu">什么是多步预测？</strong></p><p id="9937" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">多步预测就是预测时间序列的多个值的问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/8e1b0076ea07442e351d3f8c3d30c889.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tUnu9_V_FqmgU_rjQqWMjQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1:澳大利亚未来12个月外出就餐总支出(十亿)预测。图片作者。</p></figure><p id="4f5f" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">大多数预测问题都被框定为提前一步预测。也就是说，根据最近的事件预测序列的下一个值。但是，对许多问题来说，预测一个单一的步骤是过于狭隘的。</p><p id="811b" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">提前预测许多步骤具有重要的实际优势。它减少了长期的不确定性，从而实现了更好的运营规划。图1显示了一个为时间序列的下12个值生成预测的示例。</p><p id="526a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">预测很难。试图预测未来的许多步骤甚至更糟。当我们试图预测未来时，这一系列的不确定性增加了。</p><p id="87b1" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">例如，预测明天的最高温度很简单。它会有点像今天的。但是，预测一个月后的最高温度要困难得多。</p><p id="3671" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">以下示例显示了误差在预测范围内是如何增加的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi md"><img src="../Images/4a83fa0bb76a4a1cb431385431437708.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SMBLnhMvDXOf5zx1VnsU_g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图2:预测18个步骤的性能。这些值表示相对于t+1时的误差的百分比增量(提前一步预测)。作者图片</p></figure><p id="3f0b" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">图2显示了一个模型在预测范围内的表现(18个步骤)。</p><p id="9d28" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">误差随着预测范围的增加而增加。这个误差是上千个时间序列的平均值。我从gluonts库得到了它们。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="9406" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在这个故事的其余部分，我将描述多步预测的6种方法。我还将展示如何使用Python实现它们。</p><p id="f1a1" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">首先，让我们从创建一个模拟时间序列开始。我用下面的代码做到了这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="22ae" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">下面是前几个的样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="48da" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">以第一排为例。目标是预测涉及目标变量t+1，…，t+4的值[4，5，6，7]。解释变量是过去的4个滞后(t，…，t-3)。</p><p id="4232" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">现在，让我们看看如何获得多步预测。</p><h1 id="d069" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">1.递归(也称为迭代)</h1><p id="5f3d" class="pw-post-body-paragraph lg lh it li b lj my ju ll lm mz jx lo lp na lr ls lt nb lv lw lx nc lz ma mb im bi translated">最简单的多步预测方法是<strong class="li iu">递归</strong>方法。它的工作原理是为一步预测训练一个单一的模型。也就是预测下一步。然后，使用之前的预测对模型进行迭代，以获得多个步骤的预测。</p><p id="17d0" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">以下是实现它的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="0cca" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我从头实现了递归，以阐明它是如何工作的。但是，可以使用sktime库中可用的方法<a class="ae ky" href="https://www.sktime.org/en/stable/api_reference/auto_generated/sktime.forecasting.compose.RecursiveTimeSeriesRegressionForecaster.html" rel="noopener ugc nofollow" target="_blank"><strong class="li iu">【recursivetimeseriesregressionpredictor】</strong></a>、<strong class="li iu"> </strong>。</p><p id="c767" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">递归方法很吸引人，因为你只需要一个完整预测范围的单一模型。此外，您不需要提前确定预测范围。</p><p id="9dd1" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">但是，这也有严重的缺陷。用自己的预测作为输入来迭代同一个模型会导致误差的传播。这导致长期预测的预测性能较差。</p><h1 id="da44" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">2.直接的</h1><p id="9849" class="pw-post-body-paragraph lg lh it li b lj my ju ll lm mz jx lo lp na lr ls lt nb lv lw lx nc lz ma mb im bi translated"><strong class="li iu">直接</strong>方法为每个地平线建立一个模型。这里有一个片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="48a7" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">scikit-learn的<em class="nd"> MultiOutputRegressor </em>类为每个目标变量复制了一个学习算法。在这种情况下，算法是线性回归。</p><p id="4d41" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这种方法避免了错误传播，因为不需要迭代任何模型。</p><p id="30b1" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">但是，也有一些缺点。额外的模型需要更多的计算资源。此外，它假设每个视界都是独立的。通常，这种假设会导致糟糕的结果。</p><h1 id="0757" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">3.直接递归</h1><p id="d74c" class="pw-post-body-paragraph lg lh it li b lj my ju ll lm mz jx lo lp na lr ls lt nb lv lw lx nc lz ma mb im bi translated">顾名思义，<strong class="li iu"> DirectRecursive </strong>试图融合<strong class="li iu"> Direct </strong>和<strong class="li iu"> Recursive </strong>的思想。为每个层位建立一个模型(直接跟随)。但是，在每一步，输入数据都随着前一个模型的预测而增加(遵循递归)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="1d95" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这种方法在机器学习文献中被称为<strong class="li iu">链接</strong>。scikit-learn用<em class="nd"> RegressorChain </em>类为它提供了一个实现。</p><h1 id="e9aa" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">4.数据作为演示器(DaD)</h1><p id="dfc0" class="pw-post-body-paragraph lg lh it li b lj my ju ll lm mz jx lo lp na lr ls lt nb lv lw lx nc lz ma mb im bi translated">DaD是一种用于多步预测的元学习算法。它试图减轻递归的错误传播问题。</p><p id="4b28" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">其思想是使用训练集来纠正多步预测过程中出现的错误。它用这些修正迭代地丰富训练集。之后，使用丰富的训练数据执行递归方法。</p><p id="6d0e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">作者提供了他们在Github中的实现。链接如下:</p><ul class=""><li id="a95a" class="ne nf it li b lj lk lm ln lp ng lt nh lx ni mb nj nk nl nm bi translated"><a class="ae ky" href="https://github.com/arunvenk/DaD" rel="noopener ugc nofollow" target="_blank">https://github.com/arunvenk/DaD</a></li></ul><p id="6397" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">除了预测，爸爸在强化学习问题上也表现不俗。查看参考文献[1]了解详情。</p><h1 id="2ee7" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">5.动态因子机器学习(DFML)</h1><p id="cb90" class="pw-post-body-paragraph lg lh it li b lj my ju ll lm mz jx lo lp na lr ls lt nb lv lw lx nc lz ma mb im bi translated">DFML方法是专门为多元时间序列设计的。尽管如此，它的原则也可以应用于单变量。</p><p id="3f40" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">其思想是使用降维方法(例如PCA)对时间序列进行预处理。所以，不用预测H值，你只需要预测几个潜在变量。之后，您可以恢复转换以获得原始维度中的预测。</p><p id="6541" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">对于单变量时间序列，你可以这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="1a01" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">减少我们需要预测的变量数量的想法可以被视为预处理步骤。因此，我们实际上可以应用任何多步预测方法和DFML。在上面的例子中，我们使用了直接，但也可以采用不同的方法。</p><h1 id="15fb" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">6.多输出</h1><p id="c3f6" class="pw-post-body-paragraph lg lh it li b lj my ju ll lm mz jx lo lp na lr ls lt nb lv lw lx nc lz ma mb im bi translated">到目前为止描述的方法是<strong class="li iu">单输出方法— </strong>它们一次模拟一个层位。</p><p id="f8e4" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这可能是一个限制，因为它们忽略了不同地平线之间的依赖性。捕捉这种依赖性对于更好的多步预测可能很重要。</p><p id="b23e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">多输出模型解决了这个问题。这些符合一个单一的模型，该模型联合学习所有的预测范围。</p><p id="c191" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">通常，学习算法需要单个变量作为输出。这个变量被称为目标变量。然而，一些算法自然可以接受多个输出变量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="43fb" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在这种情况下，我们应用k-最近邻法。其他例子包括山脊、套索、神经网络或随机森林(以及诸如此类的东西)。</p><p id="fc04" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">多输出方法有一个变体，将它的思想与直接相结合。该变体在预测范围的不同子集中应用了直接方法。该方法在参考文献[2]中有所描述。</p><h1 id="1bc0" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">实用建议</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/f932dc04d8cfefea3fd9b617b9bbde4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tFITDbD8Qo23ZuR4"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@soymeraki?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">贾维尔·阿莱格·巴罗斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5b01" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">那么，你应该使用哪种方法呢？</p><p id="5a47" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">有一项系统研究表明多输出方法更好。文章还提到，对该系列进行非季节性调整非常重要。详见参考文献[2]。</p><p id="430d" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果有计算约束，应该避免直接或直接递归方法。除此之外，测试不同的方法，选择最适合您的数据的方法。</p><h1 id="7a4f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">外卖</h1><p id="4ebc" class="pw-post-body-paragraph lg lh it li b lj my ju ll lm mz jx lo lp na lr ls lt nb lv lw lx nc lz ma mb im bi translated">多步预测在许多领域都很重要。然而，预先预测多个步骤是一项困难的任务。</p><p id="d1bd" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在这篇文章中，我描述了6种方法来帮助你解决这个问题。这些包括递归、直接、直接递归、DaD、DFML和多输出。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="76e7" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">感谢你的阅读，下一个故事再见！</p><h2 id="e537" class="no mh it bd mi np nq dn mm nr ns dp mq lp nt nu ms lt nv nw mu lx nx ny mw nz bi translated">参考</h2><p id="5184" class="pw-post-body-paragraph lg lh it li b lj my ju ll lm mz jx lo lp na lr ls lt nb lv lw lx nc lz ma mb im bi translated">[1] Venkatraman、Arun、Martial Hebert和J. Andrew Bagnell。“改进学习时间序列模型的多步预测。”第二十九届AAAI人工智能会议。2015.</p><p id="5491" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">[2] Taieb，Souhaib Ben等，“基于NN5预测竞赛的多步提前时间序列预测策略的回顾与比较”<em class="nd">专家系统与应用</em>39.8(2012):7067–7083。</p></div></div>    
</body>
</html>