<html>
<head>
<title>5 Coding Problems Solved with Python Map-Reduce Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python Map-Reduce函数解决了5个编码问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-coding-problems-solved-with-python-map-reduce-functions-c744193193ff#2022-10-04">https://towardsdatascience.com/5-coding-problems-solved-with-python-map-reduce-functions-c744193193ff#2022-10-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="faa1" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/interviewing" rel="noopener" target="_blank">面试</a> | <a class="ae ep" href="https://towardsdatascience.com/tagged/algorithms" rel="noopener" target="_blank">算法</a> | <a class="ae ep" href="https://towardsdatascience.com/tagged/python-programming" rel="noopener" target="_blank"> Python编程</a></h2><div class=""/><div class=""><h2 id="9fe0" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">厌倦了使用显式循环？试试Python的map和reduce函数吧。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/b5c032295642695bb15a559720835988.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3T6a5ZDrD7t4p_rYCIRB9A.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://www.pexels.com/photo/pumpkins-3036364/" rel="noopener ugc nofollow" target="_blank">照片由Ylanite Koppens在Pexels上拍摄</a></p></figure><h2 id="63a8" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">建议的点播课程</h2><p id="a7db" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated"><em class="mw">你们很多人联系我要有价值的资源</em> <strong class="mf jd"> <em class="mw">钉Python编码面试</em> </strong> <em class="mw">。下面我分享几个</em> <strong class="mf jd"> <em class="mw">课程/平台</em> </strong> <em class="mw">我强烈推荐练习完本帖算法后继续锻炼:</em></p><ul class=""><li id="d797" class="mx my it mf b mg mz mj na lr nb lv nc lz nd mv ne nf ng nh bi translated"><a class="ae lh" href="https://imp.i115008.net/zaX10r" rel="noopener ugc nofollow" target="_blank"> <strong class="mf jd"> Python数据工程纳米学位(uda city)</strong></a><strong class="mf jd">→</strong><em class="mw">优质课程如果你致力于从事数据工程的职业，</em></li><li id="4504" class="mx my it mf b mg ni mj nj lr nk lv nl lz nm mv ne nf ng nh bi translated"><a class="ae lh" href="https://platform.stratascratch.com/coding?via=antonello" rel="noopener ugc nofollow" target="_blank"> <strong class="mf jd"> <em class="mw"> Python高级编码问题(StrataScratch)</em></strong></a><strong class="mf jd"><em class="mw">→</em></strong><em class="mw">我找到的准备Python的最佳平台&amp; SQL编码面试到此为止！比LeetCode更好更便宜。</em></li><li id="7c83" class="mx my it mf b mg ni mj nj lr nk lv nl lz nm mv ne nf ng nh bi translated"><a class="ae lh" href="https://datacamp.pxf.io/DV3mMd" rel="noopener ugc nofollow" target="_blank"> <strong class="mf jd">用Python练习编码面试题(60+题)</strong> </a> <strong class="mf jd"> → </strong> <em class="mw">列表、数组、集合、字典、map()、filter()、reduce()、iterable对象。</em></li></ul><p id="f4bf" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated"><em class="mw">还不是中等会员？考虑与我的</em> <a class="ae lh" href="https://anbento4.medium.com/membership" rel="noopener"> <strong class="mf jd"> <em class="mw">推荐链接</em> </strong> </a> <em class="mw">签约，以获得Medium提供的所有内容，价格低至每月5美元</em><strong class="mf jd"><em class="mw"/></strong><em class="mw">！</em></p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="73d8" class="nx lj it bd lk ny nz oa ln ob oc od lq ki oe kj lu kl of km ly ko og kp mc oh bi translated">为什么要用map()和reduce()？</h1><p id="fd7a" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">你有没有发现自己在想:<em class="mw">“如果有一种不使用显式循环的方法来解决这个编码问题会怎么样？如果我可以用一个内衬代替循环，我的解决方案会有多优雅？”</em></p><p id="9fea" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated">我知道，对吧？这是我在某个时刻问自己的那种问题，在用一个蛮力解决了几十个算法之后… <em class="mw">“一定有更好的办法，”</em>我想。</p><p id="884f" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated">然后一个顿悟，一个突破…一个真正的游戏改变者:我发现了Python的<code class="fe oi oj ok ol b">map()</code>和<code class="fe oi oj ok ol b">reduce()</code>函数。</p><p id="87b5" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated">我能听到有人说:<em class="mw">“你又来了……又一个把函数式编程当灵丹妙药卖的……</em><code class="fe oi oj ok ol b">map()</code><em class="mw"/><code class="fe oi oj ok ol b">reduce()</code><em class="mw">早就该撤了。还有更好的方法，更大蟒的！”。</em></p><p id="e832" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated">有几分真实，但是我喜欢把<code class="fe oi oj ok ol b">map()</code>和<code class="fe oi oj ok ol b">reduce()</code>想象成SQL:它很老了，不再流行了，但是它很管用，所以人们一直在使用它。<strong class="mf jd">事实上，</strong> <strong class="mf jd">这些方法在处理可重复项时特别方便，无需编写循环。</strong></p><p id="2463" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated">所以请原谅我，在本文中，我将解释这两种方法的优缺点，并与您分享用 <code class="fe oi oj ok ol b"><strong class="mf jd">map()</strong></code> <strong class="mf jd">或</strong> <code class="fe oi oj ok ol b"><strong class="mf jd">reduce()</strong></code>解决的<strong class="mf jd"> 5 Python编码问题。我还将提供一个<em class="mw">替代</em>解决方案，来说明这种方法对于消除循环是有用的，但不是必不可少的。</strong></p><p id="d78f" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated">但首先，一点理论…</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="644f" class="nx lj it bd lk ny nz oa ln ob oc od lq ki oe kj lu kl of km ly ko og kp mc oh bi translated">如何使用Python的地图( )</h1><p id="a33d" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">引用<a class="ae lh" href="https://docs.python.org/3/library/functions.html#map" rel="noopener ugc nofollow" target="_blank">文档</a>，<code class="fe oi oj ok ol b">map()</code> <em class="mw">“返回一个迭代器，该迭代器将函数应用于iterable的每一项，产生结果”</em>。该函数的语法如下:</p><pre class="ks kt ku kv gt om ol on oo aw op bi"><span id="d271" class="li lj it ol b gy oq or l os ot"><strong class="ol jd">map</strong>(<em class="mw">function</em>, <em class="mw">iterable</em>, <em class="mw">...</em>)</span></pre><ul class=""><li id="7a98" class="mx my it mf b mg mz mj na lr nb lv nc lz nd mv ne nf ng nh bi translated"><em class="mw">函数</em>参数可以是任何Python可调用的，如<strong class="mf jd">内置函数</strong>、<strong class="mf jd">方法</strong>、<strong class="mf jd">自定义函数</strong> (UDF)、<strong class="mf jd"> lambda函数</strong>。</li><li id="ff65" class="mx my it mf b mg ni mj nj lr nk lv nl lz nm mv ne nf ng nh bi translated">该函数对一个或多个<em class="mw"> iterables </em>应用转换，如<strong class="mf jd">字典</strong>，<strong class="mf jd">列表</strong>，<strong class="mf jd">元组</strong>返回地图对象。</li></ul><p id="ab35" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated">为了更好地理解<code class="fe oi oj ok ol b">map()</code>，假设你希望<strong class="mf jd">计算10个圆的面积</strong>。因为公式是<strong class="mf jd"> A = π r </strong>，π是已知常数，所以你需要的只是一个半径列表(<strong class="mf jd"> r </strong>):</p><pre class="ks kt ku kv gt om ol on oo aw op bi"><span id="12c4" class="li lj it ol b gy oq or l os ot"># Compute the area of 10 circles starting from their radius expressed in meters.</span><span id="8238" class="li lj it ol b gy ou or l os ot"># Formula --&gt; A = π r²</span><span id="d0ee" class="li lj it ol b gy ou or l os ot"><strong class="ol jd">from math import pi</strong></span><span id="31e7" class="li lj it ol b gy ou or l os ot"><strong class="ol jd">radius =</strong> [3, 5, 2, 8, 18, 22, 12, 6, 9, 15]</span><span id="41a4" class="li lj it ol b gy ou or l os ot"># Using lambda function:</span><span id="cd1a" class="li lj it ol b gy ou or l os ot"><strong class="ol jd">list(map(lambda x: pi*(x**2), radius))</strong></span><span id="ae8f" class="li lj it ol b gy ou or l os ot"><strong class="ol jd">Output:<br/></strong>[28.27, 78.53, 12.56, 201.06, 1017.87,1520.53, 452.38, 113.09, 254.46, 706.85]</span><span id="2a3d" class="li lj it ol b gy ou or l os ot"># Alternative - Using UDF</span><span id="0b47" class="li lj it ol b gy ou or l os ot">def area_of_circle(r):<br/>    return pi*(r**2)</span><span id="336e" class="li lj it ol b gy ou or l os ot"><strong class="ol jd">list(map(area_of_circle, radius))</strong></span><span id="ad7f" class="li lj it ol b gy ou or l os ot"><strong class="ol jd">Output:<br/></strong>[28.27, 78.53, 12.56, 201.06, 1017.87,1520.53, 452.38, 113.09, 254.46, 706.85]</span></pre><p id="a9c9" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated">如您所见，调用<code class="fe oi oj ok ol b">map()</code>将匿名函数或UDF应用于<code class="fe oi oj ok ol b">radius</code>中的所有项目，并且(<em class="mw">来自Python 3.x </em>)返回一个迭代器，该迭代器产生每个圆的面积。然而，为了显示输出，你需要在它上面调用<code class="fe oi oj ok ol b">list()</code>。</p><h2 id="ac80" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated"><strong class="ak">地图的主要优势()</strong></h2><p id="40f7" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">如果有人(<em class="mw">特别是在采访</em>时)问你为什么在解决编码问题时选择使用<code class="fe oi oj ok ol b">map()</code>，这里有一些原因:</p><ul class=""><li id="3c58" class="mx my it mf b mg mz mj na lr nb lv nc lz nd mv ne nf ng nh bi translated">由于<code class="fe oi oj ok ol b"> map()</code>是用C语言编写的，它可以被认为是高度优化的，特别是当它的内部循环与常规Python <code class="fe oi oj ok ol b">for</code>循环比较时。</li><li id="7690" class="mx my it mf b mg ni mj nj lr nk lv nl lz nm mv ne nf ng nh bi translated">使用<code class="fe oi oj ok ol b">map()</code>，一次评估一个条目(<em class="mw">而不是像for循环</em>那样在内存中存储完整的iterable)。这导致了<strong class="mf jd">内存消耗的显著减少</strong>。这就是为什么<code class="fe oi oj ok ol b">map()</code>返回一个<em class="mw">迭代器对象</em>而不是另一个<em class="mw">可迭代</em>像list的主要原因。</li><li id="b74b" class="mx my it mf b mg ni mj nj lr nk lv nl lz nm mv ne nf ng nh bi translated"><code class="fe oi oj ok ol b">map()</code>与lambda函数和用户定义的函数配合得很好，这反过来意味着它可以用于对<em class="mw"> iterables </em>应用复杂的转换。</li></ul><h2 id="a4b5" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">地图的主要缺点( )</h2><p id="5505" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">同样，面试官可能想知道你是否能想到使用这种方法的缺点。例如:</p><ul class=""><li id="8c1a" class="mx my it mf b mg mz mj na lr nb lv nc lz nd mv ne nf ng nh bi translated">事实上<code class="fe oi oj ok ol b">map()</code>返回一个<strong class="mf jd">地图对象</strong>也是一个缺点，因为<strong class="mf jd">你总是需要在上面调用</strong> <code class="fe oi oj ok ol b"><strong class="mf jd">list()</strong></code> <strong class="mf jd">才能使用函数</strong>的输出，这并不是最性感的语法…</li><li id="498b" class="mx my it mf b mg ni mj nj lr nk lv nl lz nm mv ne nf ng nh bi translated">很快，Lambda函数和UDF对你的同事来说会变得很难解释。出于这些原因，由<code class="fe oi oj ok ol b">map()</code>提供的功能几乎总是可以被替换为<strong class="mf jd">列表理解</strong>或<strong class="mf jd">生成器表达式</strong>，它们被认为更具可读性和Pythonic性。</li></ul><p id="3452" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated">既然你已经理解了如何使用<code class="fe oi oj ok ol b">map()</code>，下面的编码挑战将帮助你测试你的能力。</p><h1 id="b4c7" class="nx lj it bd lk ny ov oa ln ob ow od lq ki ox kj lu kl oy km ly ko oz kp mc oh bi translated">用地图解决的问题</h1><h2 id="31b5" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated"># 1.排序数组的正方形</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pa pb l"/></div></figure><pre class="ks kt ku kv gt om ol on oo aw op bi"><span id="d8d7" class="li lj it ol b gy oq or l os ot"><strong class="ol jd">Output:</strong><br/>[4, 9, 9, 49, 121]<br/>[4, 9, 9, 49, 121]</span></pre><p id="2be8" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated">一个预热编码问题，它准确地显示了何时使用<code class="fe oi oj ok ol b">map()</code>是有意义的:一个简单的转换，需要应用于iterable ( <em class="mw">整数列表</em> <code class="fe oi oj ok ol b">nums</code>)和t <strong class="mf jd">的每一项，产生相同数量的转换项</strong>。</p><p id="bca0" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated">注意，<code class="fe oi oj ok ol b">solution_map()</code>不需要调用<code class="fe oi oj ok ol b">list()</code>来评估地图对象。这是因为<code class="fe oi oj ok ol b">sorted()</code>函数(默认为<em class="mw"/>)返回指定可迭代对象的排序列表。</p><p id="d77b" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated"><em class="mw">备选</em>解决方案(<code class="fe oi oj ok ol b">solution_lc</code>)显示了如何使用<strong class="mf jd">列表理解</strong>实现相同的结果。考虑到任务的简单性，可读性方面的改进相当有限。</p><h2 id="04a6" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated"># 2.反转字符串中的单词</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pa pb l"/></div></figure><pre class="ks kt ku kv gt om ol on oo aw op bi"><span id="c4f8" class="li lj it ol b gy oq or l os ot"><strong class="ol jd">Output:</strong><br/>uoY lliw teg doog ta gnivlos gnidoc smelborp<br/>uoY lliw teg doog ta gnivlos gnidoc smelborp</span></pre><p id="b8f4" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated">一个有趣的编码问题，因为您需要找到一种方法来反转输入字符串，保留单词顺序。这意味着您需要首先用<code class="fe oi oj ok ol b">s.split()</code>创建一个iterable，它将输出一个单词列表，然后用<code class="fe oi oj ok ol b">x[::-1]</code>反转它们，最后用<code class="fe oi oj ok ol b">" ".join()</code>重新创建一个句子。</p><p id="e29e" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated">尽管很有效，但<code class="fe oi oj ok ol b">solution_map()</code>看起来有点乱(<em class="mw">因为这里</em> <code class="fe oi oj ok ol b"><em class="mw">list()</em></code> <em class="mw">必须被调用来访问颠倒的单词</em>)，并且需要一段时间来理解<code class="fe oi oj ok ol b">map()</code>内部的内容。</p><p id="3845" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated"><em class="mw">备选</em>解决方案(<code class="fe oi oj ok ol b">solution_genx()</code>)，使用<strong class="mf jd">生成器表达式</strong> ( <em class="mw">的语法类似于列表综合，但使用</em> <code class="fe oi oj ok ol b"><em class="mw">()</em></code> <em class="mw">括号</em>)提供了对<code class="fe oi oj ok ol b">map()</code>的自然替换。生成器表达式在内存消耗方面和<code class="fe oi oj ok ol b">map()</code>一样高效，并且经常使你的代码更具可读性。</p><h2 id="561c" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated"># 3.人数最多的至少是其他人的两倍</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pa pb l"/></div></figure><pre class="ks kt ku kv gt om ol on oo aw op bi"><span id="4fc4" class="li lj it ol b gy oq or l os ot"><strong class="ol jd">Output:</strong><br/>3<br/>3</span></pre><p id="709e" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated">当我试图自己解决这个编码问题时，使用<code class="fe oi oj ok ol b">filter()</code>和<code class="fe oi oj ok ol b">map()</code>功能的组合对我来说比使用<code class="fe oi oj ok ol b">enumerate()</code>更自然，就像在<em class="mw">替代</em>解决方案中一样。</p><p id="a20d" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated">尽管<code class="fe oi oj ok ol b">filter()</code>不是本文的主题，但这是另一个非常受欢迎的方法，它是从<em class="mw">函数编程</em>中派生出来的，可用于根据条件过滤一个可迭代的对象(在本例中为<em class="mw">，目标是用</em> <code class="fe oi oj ok ol b">num != max(nums)</code>从数组中排除最大的整数)，然后在过滤后的列表<code class="fe oi oj ok ol b">filter_max()</code>中调用<code class="fe oi oj ok ol b">map()</code>。</p><p id="1001" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated">然而，我不得不承认使用<code class="fe oi oj ok ol b">enumerate()</code>导致了一个更干净的解决方案，它允许使用索引，而不必调用三个函数(即<code class="fe oi oj ok ol b">filter()</code>、<code class="fe oi oj ok ol b">all()</code>和<code class="fe oi oj ok ol b">map()</code>)，这也使得它非常优雅。</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="5c36" class="nx lj it bd lk ny nz oa ln ob oc od lq ki oe kj lu kl of km ly ko og kp mc oh bi translated">如何使用Python的reduce()</h1><p id="9fc5" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">首先，值得一提的是，<code class="fe oi oj ok ol b">map()</code>是<em class="mw">内置的</em>函数，<code class="fe oi oj ok ol b">reduce()</code>需要从<code class="fe oi oj ok ol b">functools</code>模块导入。</p><p id="98af" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated">该函数的语法如下:</p><pre class="ks kt ku kv gt om ol on oo aw op bi"><span id="c444" class="li lj it ol b gy oq or l os ot"><strong class="ol jd">functools</strong>.<strong class="ol jd">reduce</strong>(<em class="mw">function</em>, <em class="mw">iterable</em>[, <em class="mw">initializer</em>])</span><span id="b806" class="li lj it ol b gy ou or l os ot"># Note that you can pass a third parameter named <strong class="ol jd">initializer</strong>.<br/># When provided, reduce() will feed it to the first call of <!-- -->function<!-- --> # as its first argument.</span></pre><p id="1b6e" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated">与<code class="fe oi oj ok ol b">map()</code>类似，<code class="fe oi oj ok ol b">reduce()</code>接受一个<em class="mw">可迭代</em>并对其应用一个函数。然而，<code class="fe oi oj ok ol b">reduce()</code>从左到右将函数应用于项目，以便<strong class="mf jd">将iterable减少为单个值</strong>。</p><blockquote class="pc"><p id="3041" class="pd pe it bd pf pg ph pi pj pk pl mv dk translated">因此，<code class="fe oi oj ok ol b">map( )</code>和<code class="fe oi oj ok ol b">reduce( )</code>的主要区别在于，前者意在输出与iterable中相同数量的项目，而后者将iterable中的项目减少到一个值。</p></blockquote><p id="cbcb" class="pw-post-body-paragraph md me it mf b mg pm kd mi mj pn kg ml lr po mn mo lv pp mq mr lz pq mt mu mv im bi translated">使用<code class="fe oi oj ok ol b">reduce()</code>最直接的方式是执行聚合，如求和或计数。例如，假设你想计算偶数的数量<strong class="mf jd"/>是一个列表:</p><pre class="ks kt ku kv gt om ol on oo aw op bi"><span id="448e" class="li lj it ol b gy oq or l os ot"># Count the number of even numbers present in the values list.</span><span id="5b4b" class="li lj it ol b gy ou or l os ot">values = [13, 8, 12, 57, 13, 81, 10]</span><span id="9d68" class="li lj it ol b gy ou or l os ot"># Using lambda function:</span><span id="63a3" class="li lj it ol b gy ou or l os ot"><strong class="ol jd">reduce(lambda x, y: x if y % 2 else x + 1, values, 0)</strong></span></pre><p id="b5ff" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated">上面的lambda函数检查每个数字是否能被2整除而没有余数，用这种方法测试它是偶数还是奇数。</p><p id="e8f2" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated">当余数为零时[if语句评估为假，因此]计数增加1(<em class="mw">请注意，初始化器已被设置为零，因为变量</em> <code class="fe oi oj ok ol b"><em class="mw">x</em></code> <em class="mw">充当计数器</em>)。</p><h2 id="c933" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">reduce()的主要优势</h2><p id="b7d0" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated"><code class="fe oi oj ok ol b">reduce()</code>功能带来了与<code class="fe oi oj ok ol b">map()</code>功能相似的好处，例如:</p><ul class=""><li id="907a" class="mx my it mf b mg mz mj na lr nb lv nc lz nd mv ne nf ng nh bi translated">因为<code class="fe oi oj ok ol b">reduce()</code>也是用C编写的，所以它的内部迭代器比标准Python for循环要快。</li><li id="50ba" class="mx my it mf b mg ni mj nj lr nk lv nl lz nm mv ne nf ng nh bi translated">对于需要多行代码的问题，<code class="fe oi oj ok ol b">reduce()</code>提供更简洁的解决方案并不罕见。<em class="mw">正因如此，</em> <code class="fe oi oj ok ol b"><em class="mw">reduce()</em></code> <em class="mw">是面试时的有力工具。</em></li></ul><h2 id="c36a" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">reduce()的主要缺点</h2><p id="b0c0" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">然而，使用该功能的主要缺点是:</p><ul class=""><li id="8eec" class="mx my it mf b mg mz mj na lr nb lv nc lz nd mv ne nf ng nh bi translated"><code class="fe oi oj ok ol b">reduce()</code>会给代码增加额外的计算时间，因为这个函数直到处理完整个<em class="mw"> iterable，</em>才会返回输出，然后无法实现<strong class="mf jd">短路评估</strong>。</li><li id="7386" class="mx my it mf b mg ni mj nj lr nk lv nl lz nm mv ne nf ng nh bi translated"><code class="fe oi oj ok ol b">reduce()</code>在使用复杂的<strong class="mf jd"> UDF </strong>或<strong class="mf jd"> lambda函数</strong>时会损害代码的可读性，所以只要有可能，最好选择专用的内置函数。</li></ul><p id="1c72" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated">既然你也知道如何使用<code class="fe oi oj ok ol b">reduce()</code>，让我们来练习一下你所学的。</p><h1 id="656b" class="nx lj it bd lk ny ov oa ln ob ow od lq ki ox kj lu kl oy km ly ko oz kp mc oh bi translated">使用Reduce解决了问题</h1><h2 id="1f16" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated"># 4.数组乘积的符号</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pa pb l"/></div></figure><pre class="ks kt ku kv gt om ol on oo aw op bi"><span id="3e36" class="li lj it ol b gy oq or l os ot"><strong class="ol jd">Output:</strong><br/>-1<br/>-1</span></pre><p id="b17d" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated">计算数组中所有值的乘积是用<code class="fe oi oj ok ol b">reduce()</code>执行的完美任务，我鼓励你在面试时使用它，因为在这种特定情况下，你实际上需要遍历完整的<em class="mw"> iterable </em>、<em class="mw">、</em>，这样<em class="mw">短路评估</em>就不适用。</p><p id="98f8" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated">然而，从<strong class="mf jd"> Python 3.8 </strong>中，您可以简单地从<code class="fe oi oj ok ol b">math</code>包中导入<code class="fe oi oj ok ol b">prod</code>函数，以获得相同的结果，并且语法更加易读，如备选解决方案所示。</p><h2 id="9578" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated"># 5.两个数组的交集</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pa pb l"/></div></figure><pre class="ks kt ku kv gt om ol on oo aw op bi"><span id="3989" class="li lj it ol b gy oq or l os ot"><strong class="ol jd">Output:</strong><br/>[3, 3, 5]<br/>[3, 3, 5]</span></pre><p id="54c7" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated">最后一个编码问题是如何在字典中使用<code class="fe oi oj ok ol b">reduce()</code>的例子(特别是在<code class="fe oi oj ok ol b">collections.Counter</code>中)。我发现<code class="fe oi oj ok ol b">solution_red()</code>相当优雅，因为它避免了显式循环，并且利用了<code class="fe oi oj ok ol b">elements()</code>方法返回最终数组。</p><p id="fb31" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated">另一方面，另一种解决方案(<code class="fe oi oj ok ol b">solution_ext</code>)确实使用了for循环，感觉有点小众，除非你确切地知道你在用<code class="fe oi oj ok ol b">extend()</code>做什么。</p><h1 id="2b70" class="nx lj it bd lk ny ov oa ln ob ow od lq ki ox kj lu kl oy km ly ko oz kp mc oh bi translated">总结</h1><p id="6bdb" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">编写更紧凑和优雅的代码的能力，是面试官和其他开发人员真正欣赏的品质。</p><blockquote class="pc"><p id="2ba6" class="pd pe it bd pf pg ph pi pj pk pl mv dk translated">编写更紧凑和优雅的代码的能力，是面试官和其他开发人员真正欣赏的品质。</p></blockquote><p id="25d9" class="pw-post-body-paragraph md me it mf b mg pm kd mi mj pn kg ml lr po mn mo lv pp mq mr lz pq mt mu mv im bi translated">一个优秀的Python开发人员是能够以简洁的方式提供智能解决方案的人。效率和速度，在业内确实算数。</p><p id="089b" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated">为了朝这个方向迈出一步，在本文中，您已经学习了Python的<code class="fe oi oj ok ol b">map()</code>和<code class="fe oi oj ok ol b">recuce()</code>函数是如何工作的，以及如何使用它们来处理<em class="mw"> iterables </em>，而无需编写显式循环。</p><p id="4a64" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated">然后，你也实践了你所学到的，解决了5个需要在<em class="mw">可迭代</em>上应用转换的编码问题。</p><p id="12b4" class="pw-post-body-paragraph md me it mf b mg mz kd mi mj na kg ml lr nn mn mo lv no mq mr lz np mt mu mv im bi translated">最终，通过不同的解决方案，您明白了有多种(<em class="mw">通常甚至更高效的</em>)方法可以替代for循环。</p><h1 id="227e" class="nx lj it bd lk ny ov oa ln ob ow od lq ki ox kj lu kl oy km ly ko oz kp mc oh bi translated">来源</h1><ul class=""><li id="1e3d" class="mx my it mf b mg mh mj mk lr pr lv ps lz pt mv ne nf ng nh bi translated"><a class="ae lh" href="https://realpython.com/python-map-function/" rel="noopener ugc nofollow" target="_blank"> <em class="mw"> Python的map():无循环处理Iterables</em></a></li><li id="c260" class="mx my it mf b mg ni mj nj lr nk lv nl lz nm mv ne nf ng nh bi translated"><a class="ae lh" href="https://realpython.com/python-reduce-function/" rel="noopener ugc nofollow" target="_blank"> <em class="mw"> Python的reduce():从函数式到Python式</em> </a></li><li id="5335" class="mx my it mf b mg ni mj nj lr nk lv nl lz nm mv ne nf ng nh bi translated"><a class="ae lh" href="https://melvinkoh.me/understanding-the-python-reduce-function-with-examples-ck7mzz8l200na8ss1ogdvw5c5" rel="noopener ugc nofollow" target="_blank"> <em class="mw">结合实例理解Python Reduce函数</em> </a></li><li id="a415" class="mx my it mf b mg ni mj nj lr nk lv nl lz nm mv ne nf ng nh bi translated"><a class="ae lh" href="https://leetcode.com/problems/squares-of-a-sorted-array/#:~:text=Squares%20of%20a%20Sorted%20Array%20%2D%20LeetCode&amp;text=Given%20an%20integer%20array%20nums,1%2C0%2C9%2C100%5D." rel="noopener ugc nofollow" target="_blank"> <em class="mw"> LeetCode问题977 </em> </a></li><li id="6ca5" class="mx my it mf b mg ni mj nj lr nk lv nl lz nm mv ne nf ng nh bi translated"><a class="ae lh" href="https://leetcode.com/problems/reverse-words-in-a-string-iii/" rel="noopener ugc nofollow" target="_blank"> <em class="mw"> LeetCode问题557 </em> </a></li><li id="e677" class="mx my it mf b mg ni mj nj lr nk lv nl lz nm mv ne nf ng nh bi translated"><a class="ae lh" href="https://leetcode.com/problems/largest-number-at-least-twice-of-others/" rel="noopener ugc nofollow" target="_blank"> <em class="mw"> LeetCode问题747 </em> </a></li><li id="abf4" class="mx my it mf b mg ni mj nj lr nk lv nl lz nm mv ne nf ng nh bi translated"><a class="ae lh" href="https://leetcode.com/problems/sign-of-the-product-of-an-array/" rel="noopener ugc nofollow" target="_blank"> <em class="mw"> LeetCode问题1822 </em> </a></li><li id="d1fa" class="mx my it mf b mg ni mj nj lr nk lv nl lz nm mv ne nf ng nh bi translated"><a class="ae lh" href="https://leetcode.com/problems/intersection-of-two-arrays-ii/" rel="noopener ugc nofollow" target="_blank"> <em class="mw"> LeetCode问题350 </em> </a></li></ul></div></div>    
</body>
</html>