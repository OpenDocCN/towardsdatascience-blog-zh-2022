<html>
<head>
<title>Intuition and Implementation of Non-Max Suppression Algorithm in Object Detection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">目标检测中非极大值抑制算法的直观性与实现</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/intuition-and-implementation-of-non-max-suppression-algorithm-in-object-detection-d68ba938b630#2022-02-01">https://towardsdatascience.com/intuition-and-implementation-of-non-max-suppression-algorithm-in-object-detection-d68ba938b630#2022-02-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c7b7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">本文解释了非最大值抑制技术的使用和实现，该技术用于图像中的对象检测</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f16447e3b986101cf46d542a156c7f77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UpfLrjCUcoPImDw8fOR4Rg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">描绘非最大抑制的封面艺术。(来源:图片由作者提供)</p></figure><p id="f988" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">计算机视觉是能够识别和理解图像和场景的人工智能的基本领域之一。它包括各种子领域，例如图像识别、对象检测、图像分割、图像生成、图像超分辨率等等。由于大量的实际使用案例，对象检测可能是计算机视觉最深刻的方面。</p><h2 id="55cd" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">目标检测</h2><p id="c8d6" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">对象检测针对计算机系统在图像中定位对象并识别每个对象的能力。对象检测已经广泛用于人脸检测、车辆检测、行人计数、安全系统和自动驾驶汽车。“对象检测模型从向端到端学习范式的发展中受益匪浅:建议、特征和分类器成为一个神经网络，将一般对象检测的结果增强了两倍[1]。”通常，所有现代对象检测模型都遵循三步过程:</p><ol class=""><li id="02ab" class="mp mq iq kx b ky kz lb lc le mr li ms lm mt lq mu mv mw mx bi translated">建议窗口的搜索空间(通过滑动窗口或使用建议稀疏)。</li><li id="aa7a" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">用分类器/回归器对窗口进行评分。</li><li id="ec07" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">组合可能属于同一对象的窗口。</li></ol><p id="74ce" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这最后一步被称为<strong class="kx ir"> <em class="nd">“非最大抑制”</em>T3】</strong></p><h2 id="5471" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">边界框</h2><p id="c1dd" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在物体检测中，我们通常使用包围盒来描述物体在图像中的空间位置。边界框是一个矩形，使用左上和右下坐标绘制。另一种常用的边界框表示包含矩形的中心以及矩形的高度和宽度。</p><h1 id="18a2" class="ne ls iq bd lt nf ng nh lw ni nj nk lz jw nl jx mc jz nm ka mf kc nn kd mi no bi translated">非最大值算法(NMS)</h1><p id="ffa2" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">可以使用下面的步骤来解释该算法:<br/> <strong class="kx ir">输入:</strong>边界框列表以及类名和每个检测到的对象的输出概率。</p><ol class=""><li id="2106" class="mp mq iq kx b ky kz lb lc le mr li ms lm mt lq mu mv mw mx bi translated">移除输出概率分数小于指定阈值的边界框。</li><li id="c788" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">按照输出概率的降序排列剩余边界框的列表。</li><li id="ffd7" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">遍历边界框的排序列表，直到至少剩下一个元素。</li><li id="1dd2" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">从列表中移除第一个边界框，并将其标记为<em class="nd">“当前元素”</em>此外，检查其与同一类对象列表中其他元素的边界框的并集交集(IOU)。如果 IOU 高于指定阈值，则从列表中删除该元素，并将当前元素添加到<em class="nd">最终列表中</em></li><li id="5a6c" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">重复步骤 3 和 4。</li><li id="038e" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">返回<em class="nd">'最终列表'</em></li></ol><h2 id="44b8" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">NMS 算法预演</h2><p id="0e0e" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">假设，我们有下面的图像(图 1)包含两只狗(左一只:<em class="nd">玛雅</em>和右一只:<em class="nd">佐罗</em>)，并且我们有一个对象检测模型来区分图像中的玛雅和佐罗。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/2e5fc67b10d5183b264aa0271e12932e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cf3BaM8VIfRHCjeNOzT16w.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图一。两只狗坐着:玛雅(左)和佐罗(右)。(来源:图片由作者提供)</p></figure><p id="5cdd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当使用上面的图像对我们的对象检测模型(没有 NMS)进行推理时，我们将得到如图 2 所示的输出。在这里我们可以看到，我们得到了多个边界框，在单个对象上有各自的概率分数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/169b1af06a203ecd2b46c4bc3ea79b36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HF-ugOhn3kEMoYRfWR8KkA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图二。具有相应输出概率的对象上的多个边界框。(来源:图片由作者提供)</p></figure><p id="47fa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的目标是为一个对象选择最合适的边界框。换句话说，我们必须从概率为 0.94、0.68 和 0.47 的三个框中为<em class="nd">玛雅</em>选择一个边界框。同样，我们也必须从概率为 0.9 和 0.58 的两个边界框中为<em class="nd">佐罗</em>找到最佳边界框。</p><p id="aa5c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">根据该算法，我们将首先丢弃所有那些概率分数小于指定阈值的边界框。例如，如果我们将阈值设为 0.5，我们将丢弃 Maya 概率为 0.47 的边界框。此外，我们将找到具有最高概率分数的包围盒，并将其 IOU 与同类的所有其他包围盒进行检查。如果 IOU 高于阈值(表示相同的对象)，我们丢弃具有较小概率分数的边界框。类似地，我们将对图像中所有检测到的对象执行这些步骤。最终输出如图 3 所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/dbb4fb66de6673ef53e611a9cb67287d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YQEvcpdbYTnk5FDjzVUssA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图 3。应用非最大抑制后的最终边界框。(来源:图片由作者提供)</p></figure><h1 id="d6d9" class="ne ls iq bd lt nf ng nh lw ni nj nk lz jw nl jx mc jz nm ka mf kc nn kd mi no bi translated">密码</h1><p id="75ff" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">首先，我们将初始化概率置信阈值和 IOU 阈值。例如，如果边界框的概率低于概率置信度阈值，那么我们将丢弃该边界框。类似地，如果 IOU 分数高于定义的阈值，我们将不考虑具有低输出概率的边界框。</p><pre class="kg kh ki kj gt ns nt nu nv aw nw bi"><span id="9695" class="lr ls iq nt b gy nx ny l nz oa">import cv2<br/>class NMS:<br/>    def __init__(self) -&gt; None:<br/>        self.conf = 0.5<br/>        self.iou_threshsold = 0.4</span></pre><p id="58f3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面代码中的 IOU 函数计算两个区域的 IOU。顾名思义，IOU 就是两个区域的交集面积和两个面积的并集的比值。在 IOU 函数中，bboxes1 和 bboxes2 是一个包含四个元素的列表，它们是:</p><pre class="kg kh ki kj gt ns nt nu nv aw nw bi"><span id="a6a2" class="lr ls iq nt b gy nx ny l nz oa">[ <strong class="nt ir">X</strong>(top-left), <strong class="nt ir">Y</strong>(top-left), <strong class="nt ir">X</strong>(bottom-right), <strong class="nt ir">Y</strong>(bottom-right) ]</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="1495" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面的代码在图像上绘制边界框，并将概率分数放在框的顶部。参数<em class="nd"> 'images' </em>是一个图像对象，<em class="nd"> 'bboxes_list' </em>包含被检测对象的坐标、类别和概率输出。</p><pre class="kg kh ki kj gt ns nt nu nv aw nw bi"><span id="67c6" class="lr ls iq nt b gy nx ny l nz oa">bboxes_list = [<strong class="nt ir">class</strong>, <strong class="nt ir">X</strong>(top-left), <strong class="nt ir">Y</strong>(top-left), <strong class="nt ir">X</strong>(bottom-right), <strong class="nt ir">Y</strong>(bottom-right), <strong class="nt ir">output_probability</strong>]</span><span id="6671" class="lr ls iq nt b gy od ny l nz oa"><strong class="nt ir">Sample values:</strong><br/>0 187 90 586 607 0.94<br/>0 120 116 600 370 0.68<br/>1 511 185 961 418 0.58<br/>0 340 145 568 478 0.47<br/>1 524 70 920 565 0.92</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="3203" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面的函数是上述 NMS 算法的实现。该函数在应用非最大值抑制算法后返回所需的边界框。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="45bd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是 NMS 类的驱动程序代码。我们首先读取‘coordinates . txt’来获取包围盒的坐标和其他细节；然后，我们应用 NMS 算法得到想要的包围盒。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><pre class="kg kh ki kj gt ns nt nu nv aw nw bi"><span id="e66e" class="lr ls iq nt b gy nx ny l nz oa"><strong class="nt ir">coordinates.txt</strong><br/>0 187 90 586 607 0.94<br/>0 120 116 600 370 0.68<br/>1 511 185 961 418 0.58<br/>0 340 145 568 478 0.47<br/>1 524 70 920 565 0.92</span></pre><p id="4ddb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">完整代码可从以下网址获得:</p><div class="oe of gp gr og oh"><a href="https://github.com/prateekchhikara/non-max-suppression" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd ir gy z fp om fr fs on fu fw ip bi translated">GitHub-prateekchhikara/非最大抑制</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">github.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov kp oh"/></div></div></a></div><h1 id="58b4" class="ne ls iq bd lt nf ng nh lw ni nj nk lz jw nl jx mc jz nm ka mf kc nn kd mi no bi translated">结论</h1><p id="9e50" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">本文概述了非最大值抑制算法的需求以及 python 实现。除此之外，我们用一个图像例子解释了这个算法。</p></div><div class="ab cl ow ox hu oy" role="separator"><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb"/></div><div class="ij ik il im in"><h1 id="4936" class="ne ls iq bd lt nf pd nh lw ni pe nk lz jw pf jx mc jz pg ka mf kc ph kd mi no bi translated">参考</h1><ol class=""><li id="d567" class="mp mq iq kx b ky mk lb ml le pi li pj lm pk lq mu mv mw mx bi translated">Hosang，Jan，Rodrigo Benenson 和 Bernt Schiele。“学习非最大抑制。”IEEE 计算机视觉和模式识别会议论文集。2017.</li></ol></div></div>    
</body>
</html>