<html>
<head>
<title>Node Classification with Node2Vec</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Node2Vec 进行节点分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/node-classification-with-node2vec-58892845697b#2022-03-07">https://towardsdatascience.com/node-classification-with-node2vec-58892845697b#2022-03-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="560c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用 Python 构建多类节点分类模型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/14b009f06a69ba7021b4c11b2fc167c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4G4K5nKRyoyVK0RsDqDzpA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://unsplash.com/@geroldhinzen" rel="noopener ugc nofollow" target="_blank"> Gerold Hinzen </a>从<a class="ae ky" href="https://unsplash.com/photos/p8Jft09BBPw" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="53ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将展示使用图形解决分类问题的管道的实现。今天介绍的解决方案背后的基本算法是 Node2Vec。如果你对 node2vec 不熟悉，我以前写过一篇关于它的文章，你可以在下面看看。</p><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/node2vec-explained-db86a319e9ab"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">Node2Vec 解释</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">用 Python 解释和实现 Node2Vec 白皮书</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="639c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以在这里查看如何使用 Node2Vec 构建链接预测推荐系统<a class="ae ky" rel="noopener" target="_blank" href="/link-prediction-recommendation-engines-with-node2vec-c97c429351a8"/>。</p><h2 id="8caf" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">目录</h2><ul class=""><li id="407f" class="ng nh it lb b lc ni lf nj li nk lm nl lq nm lu nn no np nq bi translated">什么是节点分类？</li><li id="c94b" class="ng nh it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">问题陈述</li><li id="03db" class="ng nh it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">解决方案架构<br/> -需求</li><li id="c213" class="ng nh it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">数据</li><li id="826b" class="ng nh it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">创建网络</li><li id="d721" class="ng nh it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">应用节点 2Vec</li><li id="77ca" class="ng nh it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">训练分类器<br/> -评估分类器<br/> -预测节点类</li><li id="c376" class="ng nh it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">结束语</li><li id="bfb8" class="ng nh it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">资源</li></ul></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><h1 id="5dff" class="od mo it bd mp oe of og ms oh oi oj mv jz ok ka my kc ol kd nb kf om kg ne on bi translated">什么是节点分类？</h1><p id="702c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li oo lk ll lm op lo lp lq oq ls lt lu im bi translated">节点分类是机器学习在图上的常见应用。通常，您训练一个分类模型来学习某个节点属于哪个类。<br/>这种方法常见于二元和多类分类[1]。在二元分类中，你要处理两个不同的类，而在多类分类中，你要处理两个以上不同的类。<br/>在本教程的上下文中，我们将使用 node2vec 来生成网络的节点嵌入。Node2vec 旨在保留原始图中的初始结构。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/82d61791d407ec127bda86e99c2a0bf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P7-KxYinU6-60QDEk69jhw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 g 中的节点分类示例。右图展示了按不同颜色(红色、蓝色、绿色)分类的节点。图片由作者提供。</p></figure><h1 id="316c" class="od mo it bd mp oe os og ms oh ot oj mv jz ou ka my kc ov kd nb kf ow kg ne on bi translated">问题陈述</h1><p id="279b" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li oo lk ll lm op lo lp lq oq ls lt lu im bi translated">给定 arXiv 上发表的研究论文的主题，我们将构建一个管道，该管道将训练一个模型来根据其主题对研究论文进行分类。</p><h1 id="fca6" class="od mo it bd mp oe os og ms oh ot oj mv jz ou ka my kc ov kd nb kf ow kg ne on bi translated">解决方案架构</h1><p id="997a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li oo lk ll lm op lo lp lq oq ls lt lu im bi translated">我们将首先创建一个网络，其中节点作为文章，连接这些节点的边基于连接一对文章的主主题。创建这个网络后，我们将使用 node2vec 来生成与每篇文章相关的节点嵌入。最后，我们可以将与每个节点关联的节点嵌入映射到其关联的主题。嵌入可以作为特征传递，并且主主题可以作为训练分类模型的目标。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/4e89c26fd9d163298a357e0fb7d901d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*URR-EnCC_67UzPOmJxZN4g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">上面概述了建议的节点分类体系结构。图片由作者提供。</p></figure><h2 id="ebed" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">要求</h2><pre class="kj kk kl km gt oy oz pa pb aw pc bi"><span id="c305" class="mn mo it oz b gy pd pe l pf pg">Python=3.8.8<br/>arxiv=1.4.2<br/>networkx=2.5<br/>pandas=1.2.4<br/>numpy=1.20.1<br/>node2vec=0.4.4<br/>sklearn=0.24.1</span></pre><p id="ec0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你没有安装 node2vec 包，这里的<a class="ae ky" href="https://pypi.org/project/node2vec/" rel="noopener ugc nofollow" target="_blank"/>是通过命令行安装它的库文档。类似地，您可以使用以下指令用 Python 安装 arXiv 包<a class="ae ky" href="https://pypi.org/project/arxiv/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h1 id="0a11" class="od mo it bd mp oe os og ms oh ot oj mv jz ou ka my kc ov kd nb kf ow kg ne on bi translated">数据</h1><p id="1ead" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li oo lk ll lm op lo lp lq oq ls lt lu im bi translated">我们将使用 arXiv API 来收集与各种关键字相关的研究论文和出版物的数据。基于他们 API 的 arXiv 使用条款，它是完全免费的，并鼓励使用。有关其使用条款的更多信息，请参考其文档，您可以在此处找到<a class="ae ky" href="https://arxiv.org/help/api/tou" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="199f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将向您展示如何通过 Python 调用 API 来收集我们今天构建的模型所需的以下信息。如果你想通过其他编程语言使用这个 API，或者只是想了解更多关于如何使用这个 API 的信息，我强烈建议你参考他们的文档，你可以在这里找到<a class="ae ky" href="https://arxiv.org/help/api/user-manual" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="c6c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们想要点击 arXiv API 来收集一些关于基于我们上面确定的查询的最新研究论文的信息。这将允许我们根据这篇研究论文数据创建一个网络，然后我们可以尝试对该网络上的节点进行分类。出于本文的目的，我将在每个查询中搜索最多 250 个结果，但是您不必为自己设置相同的约束。arXiv API 允许用户每次查询达到 300，000 个结果[2]。下面概述的函数将生成一个获取以下信息的 CSV:<br/><code class="fe ph pi pj oz b">title, date, article_id, url, main_topic, all_topics, authors, year</code><br/>您可以获取更多信息，如链接、摘要、文章，但我决定不这样做，因为这些功能不会真正用于本分析和教程。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="7f57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我点击 arXiv API 时得到的输出示例。根据您选择查询的关键字和时间，您可能会收到不同的信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/00ced806fa51eeb85d817b39a6d10c16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K1SMr47eFg4S7XQV7AmMeQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过 API 查询 arXiv 后的示例输出。图片由作者提供。</p></figure><p id="372d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在查询数据时遇到问题，出于可再现性的目的，我在本文中进行的分析所使用的 CSV 被上传到我的 GitHub，您可以在这里找到<a class="ae ky" href="https://github.com/vatsal220/medium_articles/blob/main/node_classification/data/arxiv_data.csv" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="75ca" class="od mo it bd mp oe os og ms oh ot oj mv jz ou ka my kc ov kd nb kf ow kg ne on bi translated">创建网络</h1><p id="9848" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li oo lk ll lm op lo lp lq oq ls lt lu im bi translated">现在我们已经使用 arXiv API 获取了数据，我们可以生成一个网络。该网络将具有以下结构，节点将是 article _ ids，边将是连接一对文章的所有主题。例如，具有以下主题天文物理学的 article_id 1 和具有主题 stats 的 article_id 10 以及具有主题<code class="fe ph pi pj oz b">astro-physics</code>、<code class="fe ph pi pj oz b">math</code>的 article_id 7 可以被连接。这将是一个多边网络，其中每条边的权重为 1。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="f31f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是我生成的与网络相关的统计数据:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/9e85c6a51d0be2a0aac6494c2868a74f.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*HKL5lmZNKRvMaSMQd8tUVQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">生成的图表统计信息的摘要。图片由作者提供。</p></figure><h1 id="e2d2" class="od mo it bd mp oe os og ms oh ot oj mv jz ou ka my kc ov kd nb kf ow kg ne on bi translated">应用节点 2Vec</h1><p id="88ad" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li oo lk ll lm op lo lp lq oq ls lt lu im bi translated">这个组件将包括在上面生成的图上运行 node2vec，并为该网络创建相关的节点嵌入。这些嵌入将会起到至关重要的作用，因为它们是构建节点分类模型所必需的主要特性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="344a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面您可以看到嵌入数据的输出示例，其中索引值代表节点，主主题列代表目标变量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/b0aee42efef24f9b3d9ad74f51aa9888.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*svIFHO_i_9McIYl3FW4G6Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">node2vec 生成的嵌入数据的输出示例。图片由作者提供。</p></figure><p id="6d72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我查询这些数据的那天，我注意到数据集中有 110 个不同的主题。下面你可以看到与研究论文中最常出现的主题相关的数值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/a93a10af3cb635b8b8ae77256bc2904d.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*CYgg-Q-5LI2UosiY8iAtPA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">十大最常用话题。图片由作者提供。</p></figure><h1 id="0412" class="od mo it bd mp oe os og ms oh ot oj mv jz ou ka my kc ov kd nb kf ow kg ne on bi translated">训练分类器</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pk pl l"/></div></figure><h2 id="7358" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">评估分类器</h2><p id="d773" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li oo lk ll lm op lo lp lq oq ls lt lu im bi translated">为了评估该模型的性能，我们将考察以下准确度得分:</p><ul class=""><li id="ab92" class="ng nh it lb b lc ld lf lg li pq lm pr lq ps lu nn no np nq bi translated">准确度分数</li><li id="ae99" class="ng nh it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">马修相关系数</li><li id="572f" class="ng nh it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">分类报告</li><li id="c9ec" class="ng nh it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">混淆矩阵</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pk pl l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/0e2a38208b62fdc6977af20a700d39c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*frgg2FZFs2l0fADSypJ2XA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">与节点分类模型评估相关的准确性测量。图片由作者提供。</p></figure><p id="4a91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我没有添加与分类报告和混淆矩阵相关的图像，因为它们太大了(因为有 110 个唯一的类)。你可以参考 Jupyter 笔记本中与本教程相关的图片<a class="ae ky" href="https://github.com/vatsal220/medium_articles/blob/main/node_classification/classify_node.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h2 id="4437" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">预测节点类</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pk pl l"/></div></figure><h1 id="e5f4" class="od mo it bd mp oe os og ms oh ot oj mv jz ou ka my kc ov kd nb kf ow kg ne on bi translated">结束语</h1><p id="642e" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li oo lk ll lm op lo lp lq oq ls lt lu im bi translated">从管道的结果可以看出，梯度提升分类器在基于 node2vec 特性的节点分类方面做得非常好。这一点基于准确率、马太相关系数、混淆矩阵、分类报告的高分都有明显体现。</p><p id="cf0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种流水线很容易被二进制分类所复制。我鼓励您训练和测试各种分类模型，看看哪种模型最适合您正在使用的数据集。</p><p id="ccd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要继续学习这篇教程，你可以参考我的 GitHub 上的 Jupyter 笔记本。</p><h1 id="e240" class="od mo it bd mp oe os og ms oh ot oj mv jz ou ka my kc ov kd nb kf ow kg ne on bi translated">资源</h1><ul class=""><li id="2861" class="ng nh it lb b lc ni lf nj li nk lm nl lq nm lu nn no np nq bi translated">[1]<a class="ae ky" href="https://neo4j.com/docs/graph-data-science/current/algorithms/ml-models/node-classification/#:~:text=Node%20Classification%20is%20a%20common,classification%20problems%3A%20binary%20and%20multiclass" rel="noopener ugc nofollow" target="_blank">https://neo4j . com/docs/graph-data-science/current/algorithms/ml-models/Node-classification/#:~:text = Node % 20 class % 20 is % 20a % 20 common，class % 20 problems % 3A % 20 binary % 20 and % 20 multi class</a></li><li id="99d6" class="ng nh it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">[2]https://pypi.org/project/arxiv/<a class="ae ky" href="https://arxiv.org/help/api/user-manual" rel="noopener ugc nofollow" target="_blank"/></li></ul></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="340a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢读这篇文章，这里有一些我写的其他文章，我想你可能也会喜欢。</p><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/text-summarization-in-python-with-jaro-winkler-and-pagerank-72d693da94e8"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">用 Jaro-Winkler 和 PageRank 实现 Python 中的文本摘要</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">用 Jaro-Winkler 和 PageRank 构建一个文本摘要器</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="pu l mj mk ml mh mm ks ly"/></div></div></a></div><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/random-walks-with-restart-explained-77c3fe216bca"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">带重启的随机漫步解释</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">理解带重启的随机游走算法及其在 Python 中的相关实现</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="pv l mj mk ml mh mm ks ly"/></div></div></a></div><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/frequentist-a-b-testing-explained-90b9ce8c28b9"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">Frequentist A/B 测试说明</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">本文将解释 A/B 测试的 frequentist 方法，并提供一个何时以及如何…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="pw l mj mk ml mh mm ks ly"/></div></div></a></div><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/mining-modelling-character-networks-part-ii-a3d77de89638"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">挖掘和模拟字符网络—第二部分</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">本文将介绍挖掘和建模字符网络的 Python 实现</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="px l mj mk ml mh mm ks ly"/></div></div></a></div></div></div>    
</body>
</html>