<html>
<head>
<title>3 Python Packages for Automatic Dataset-Labeling Process</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于自动数据集标注过程的3个Python包</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3-python-packages-for-automatic-dataset-labeling-process-3fb1d898db5b#2022-06-25">https://towardsdatascience.com/3-python-packages-for-automatic-dataset-labeling-process-3fb1d898db5b#2022-06-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fe95" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">数据标注对于机器学习项目的成功至关重要</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b6d88734e082490a6cbbcb2471f70d2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CRlNlW8s-1vSdTP5"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@muratodr?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">穆拉特·翁德尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="c749" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据科学项目涉及大量的数据收集、清理和处理。我们做了所有的步骤来确保数据集质量对于机器学习训练来说是好的。尽管如此，数据科学项目中有一个特别重要的部分可能决定项目的成败:标签。</p><p id="e516" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个数据科学项目都是为了解决特定的业务问题而开发的，例如，客户流失、购买倾向、欺诈等。考虑主题很容易，但一旦我们需要考虑业务方面，标记过程就变得复杂了。</p><p id="9b65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于不同的业务需求，同一个客户流失项目可能有不同的标签——一个项目可能只考虑一年内客户流失的人数，而另一个项目则希望预测整体客户流失情况。看到标签已经变得如此不同了吗？这就是为什么贴标过程是必不可少的。</p><p id="f16b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了帮助从事标注处理的数据人员，我想介绍几个我认为对日常工作有用的Python包。包裹是什么？让我们开始吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4040" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.构成</h1><p id="33fe" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://compose.alteryx.com/en/stable/index.html" rel="noopener ugc nofollow" target="_blank"> Compose </a>是一个为自动化预测工程工作而开发的Python包。Compose是专门为监督预测问题生成标签而创建的。用户定义标签标准，并合成运行历史数据以创建标签预测。</p><p id="a008" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Compose主要被设计为与名为<a class="ae ky" href="https://docs.featuretools.com/" rel="noopener ugc nofollow" target="_blank"> featuretools </a>和<a class="ae ky" href="https://evalml.alteryx.com/" rel="noopener ugc nofollow" target="_blank"> EvalML </a>的自动化特征工程包一起工作，用于自动化机器学习，但在本文中，我们将重点关注Compose。</p><p id="157b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从安装Compose包开始。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="6f88" class="ne md it na b gy nf ng l nh ni">pip install composeml</span></pre><p id="fa3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，对于这个示例，我将使用Heerla Dedhia的Kaggle中的<a class="ae ky" href="https://www.kaggle.com/datasets/heeraldedhia/groceries-dataset" rel="noopener ugc nofollow" target="_blank">杂货数据集</a>,该数据集在市场上可以买到。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="be06" class="ne md it na b gy nf ng l nh ni">import pandas as pd</span><span id="a3a3" class="ne md it na b gy nj ng l nh ni">df = pd.read_csv('Groceries_dataset.csv')<br/>df['Date'] = pd.to_datetime(df['Date'])</span><span id="800d" class="ne md it na b gy nj ng l nh ni">df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/a343c947a2c5660adbfd32e9286b229d.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*gc9d1jl6Ynt0P2iJ5U4D1w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="99a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据集包含3列:ID(“Member _ number”)、购买时间(“Date”)和购买的项目(“itemDescription”)。</p><p id="dcbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，假设我们有一个业务问题:</p><blockquote class="nl nm nn"><p id="945d" class="kz la no lb b lc ld ju le lf lg jx lh np lj lk ll nq ln lo lp nr lr ls lt lu im bi translated">"顾客会在下一个购物周期购买一些东西吗？"</p></blockquote><p id="acb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据上面的问题，我们可以尝试使用可用的数据集来回答它们，但是我们需要考虑两个参数:</p><ol class=""><li id="5736" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated">客户会购买什么产品？</li><li id="7e8a" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">下一次购物期是多久？</li></ol><p id="be09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想知道顾客是否会在未来3天内购买全脂牛奶；然后，我们可以尝试根据这个定义创建标签。</p><p id="acd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要开始为标签工作使用Compose包，我们需要首先定义符合我们标准的标签函数。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="0367" class="ne md it na b gy nf ng l nh ni">def bought_product(ds, itemDescription):</span><span id="7167" class="ne md it na b gy nj ng l nh ni">   return ds.itemDescription.str.contains(itemDescription).any()</span></pre><p id="b192" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码将检查客户是否购买了特定的产品。创建标签函数后，我们将使用以下代码设置标签生成器。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="b601" class="ne md it na b gy nf ng l nh ni">lm = cp.LabelMaker(</span><span id="9464" class="ne md it na b gy nj ng l nh ni">#We want to process each customer so we use the Customer ID<br/>target_dataframe_name='Member_number',</span><span id="1e7d" class="ne md it na b gy nj ng l nh ni">#Because we want to know if the customer bought item on the next period, we would need the time column<br/>time_index='Date',</span><span id="1da6" class="ne md it na b gy nj ng l nh ni">#Set the label function<br/>labeling_function=bought_product,</span><span id="6015" class="ne md it na b gy nj ng l nh ni">#How long the shopping Period (or any period between time)<br/>window_size='3d'<br/>)</span></pre><p id="20bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们已经设置了LabelMaker类时，我们就可以运行label maker进程了。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3407" class="ne md it na b gy nf ng l nh ni">lt = lm.search(</span><span id="754f" class="ne md it na b gy nj ng l nh ni">#The dataset<br/>df.sort_values('Date'),</span><span id="8119" class="ne md it na b gy nj ng l nh ni">#Number of label per customers, -1 means find all the existing<br/>num_examples_per_instance=-1,</span><span id="e411" class="ne md it na b gy nj ng l nh ni">#What product we want to find<br/>itemDescription='whole milk',</span><span id="22c6" class="ne md it na b gy nj ng l nh ni">minimum_data='3d',<br/>verbose=False,)</span><span id="ea95" class="ne md it na b gy nj ng l nh ni">lt.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/60b73f1e4ee56b3a8018c780c84b46dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*rbGoUxedlGxTazRQZJyhbQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="138c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出的三列解释如下:</p><ul class=""><li id="039b" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu oh ny nz oa bi translated">Member_number与购买相关。由于每个顾客可以购买不止一次，因此可能有不止一个例子。</li><li id="9427" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu oh ny nz oa bi translated">时间是购物期的开始。这也是建筑物特征的截止时间。</li><li id="8b99" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu oh ny nz oa bi translated">如果产品是在期间窗口内购买的，则它们是通过标签函数计算的。</li></ul><p id="b5ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用下面的代码来获得结果的标签摘要。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4f75" class="ne md it na b gy nf ng l nh ni">lt.describe()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/4d238394a10f829046467453cc0c4a28.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*yrghxzbcw9S58E6yL20UwA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="ec8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从标记过程中，我们可以看到在我们的搜索中有一个不平衡的例子。在购物期的3天内购买全脂牛奶的顾客似乎不多。</p><p id="f2e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是作曲的例子。如果你想尝试其他数据或看另一个例子，我们可以访问<a class="ae ky" href="https://compose.alteryx.com/en/stable/examples/predict_next_purchase.html" rel="noopener ugc nofollow" target="_blank">教程</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5301" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.通气管</h1><p id="0d67" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://www.snorkel.org/get-started/" rel="noopener ugc nofollow" target="_blank">通气管</a>是专门为构建数据集标注而开发的Python包，无需任何手动标注过程。speak旨在用几行代码减少标签工作所用的时间。通气管有3个主要特点:</p><ul class=""><li id="ff6b" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu oh ny nz oa bi translated"><strong class="lb iu">标注数据，</strong></li><li id="c4ca" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu oh ny nz oa bi translated"><strong class="lb iu">转换数据，</strong></li><li id="96f6" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu oh ny nz oa bi translated"><strong class="lb iu">切片数据</strong>。</li></ul><p id="49a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，本文将只关注标记数据的过程。让我们试试通气管套件，让我们的贴标过程自动化。</p><p id="a226" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要安装软件包。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3f43" class="ne md it na b gy nf ng l nh ni">pip install snorkel</span></pre><p id="43c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于指导的目的，我们将使用来自Nipun Arora的Kaggle的<a class="ae ky" href="https://www.kaggle.com/datasets/nipunarora8/most-liked-comments-on-youtube" rel="noopener ugc nofollow" target="_blank"> YouTube评论数据集</a>,该数据集在市场上可以买到。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a22f" class="ne md it na b gy nf ng l nh ni">import pandas as pd</span><span id="6227" class="ne md it na b gy nj ng l nh ni">df = pd.read_csv('youtube_dataset.csv')<br/>df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/bba5c29ddb192937a1514f5645ebe2c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PuKSEtoFn9yZq87q3VRJXA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="e9b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据集包含许多字段，包括YouTube评论数据。假设我们想从数据集中训练一个YouTube评论垃圾预测器。在这种情况下，我们需要用特定的要求来标记数据—我们认为什么是垃圾邮件？</p><p id="dcb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用scupk，我们可以创建一个称为标记功能的弱监督功能——监督规则和启发式规则，将标签分配给未标记的训练数据。</p><p id="ba10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了清楚起见，让我们将火腿视为0，垃圾邮件视为1，弃权为-1。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4c25" class="ne md it na b gy nf ng l nh ni">ABSTAIN = -1<br/>HAM = 0<br/>SPAM = 1</span></pre><p id="18e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我认为垃圾邮件的文本中包含“check”和“checking _ out”。让我们用上面的规则来构建标签函数。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7b2a" class="ne md it na b gy nf ng l nh ni">from snorkel.labeling import labeling_function</span><span id="6c12" class="ne md it na b gy nj ng l nh ni">@labeling_function()</span><span id="e395" class="ne md it na b gy nj ng l nh ni">def check(x):<br/>   return SPAM if "check" in x.text.lower() else ABSTAIN<br/></span><span id="092f" class="ne md it na b gy nj ng l nh ni">@labeling_function()</span><span id="43b6" class="ne md it na b gy nj ng l nh ni">def checking_out(x):<br/>   return SPAM if "checking out" in x.text.lower() else ABSTAIN</span></pre><p id="c789" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">准备好函数后，我们可以标记注释数据。但是，我们需要更改希望作为“文本”处理的列名。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a07b" class="ne md it na b gy nf ng l nh ni">df = df.rename(columns = {'Comment' : 'text'})</span></pre><p id="2aed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们也使用熊猫数据帧，我们将使用<code class="fe ok ol om na b">PandasLFApplier</code>来应用标签功能。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ad89" class="ne md it na b gy nf ng l nh ni">from snorkel.labeling import PandasLFApplier</span><span id="fe7f" class="ne md it na b gy nj ng l nh ni">lfs = [checking_out, check]</span><span id="daa2" class="ne md it na b gy nj ng l nh ni">applier = PandasLFApplier(lfs=lfs)</span><span id="493f" class="ne md it na b gy nj ng l nh ni">L_train = applier.apply(df=df)</span></pre><p id="798a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">applier函数的结果是一个标签矩阵，其中列表示标签函数，行表示数据点。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c265" class="ne md it na b gy nf ng l nh ni">L_train</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/64a86da4bb129b5589d52177d1d8aa2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:346/format:webp/1*eJBBOMjC4p0jGoHspm3lyg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="892c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从标签应用程序函数中，让我们检查每个单词的垃圾邮件覆盖率是多少。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4b28" class="ne md it na b gy nf ng l nh ni">coverage_checking_out, coverage_check = (L_train != ABSTAIN).mean(axis=0)</span><span id="8cee" class="ne md it na b gy nj ng l nh ni">print(f"checking out coverage: {coverage_checking_out * 100:.1f}%")<br/>print(f"check coverage: {coverage_check * 100:.1f}%")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/87479438cfb27bd767576146ce0ee86d.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*ulsoOO7N1ilbrMhOSjxv9g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="14b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据我们的标签功能，似乎没有那么多的评论是垃圾邮件。让我们使用通气管中的功能来获得更详细的总结。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="dab6" class="ne md it na b gy nf ng l nh ni">from snorkel.labeling import LFAnalysis</span><span id="50ff" class="ne md it na b gy nj ng l nh ni">LFAnalysis(L=L_train, lfs=lfs).lf_summary()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/04355fd541e00d5065411b5df03e4124.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*7qpcdeidrqmH_ehDSp2dOA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="6849" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe ok ol om na b">LFAnalysis</code>我们可以获得更多关于贴标过程的详细信息。每一列代表以下信息:</p><ul class=""><li id="1402" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu oh ny nz oa bi translated"><strong class="lb iu">极性</strong>:标签功能的唯一标签(不含弃权)，</li><li id="a0c7" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu oh ny nz oa bi translated"><strong class="lb iu">覆盖率</strong>:数据集中的LF标签分数，</li><li id="b388" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu oh ny nz oa bi translated"><strong class="lb iu">重叠</strong>:该LF和至少一个其他LF标签重叠的数据集部分</li><li id="4cb5" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu oh ny nz oa bi translated"><strong class="lb iu">冲突</strong>:该LF和至少一个其他LF标签不一致的数据集部分。</li></ul><p id="e906" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是通气管在贴标过程中的基本用法。对于这些包，您仍然可以做很多事情并从中学习。重要的是，通气管会减少你的标记活动。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2eb6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.清洁实验室</h1><p id="2820" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://docs.cleanlab.ai/v2.0.0/index.html" rel="noopener ugc nofollow" target="_blank"> Cleanlab </a>是一个python包，用于发现标签问题并自动修复它们。本质上，这个包不同于我前面提到的两个包，因为Cleanlab要求我们的数据集已经包含标签。</p><p id="5081" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Cleanlab旨在减少修复数据错误的手动工作，并帮助使用干净的数据集训练可靠的ML模型。大多数时候，坏标签是因为贴错标签而产生的，Cleanlab旨在解决这个问题。</p><p id="96be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用一个数据集例子来使用Cleanlab。首先，我们需要安装软件包。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="d175" class="ne md it na b gy nf ng l nh ni">pip install cleanlab</span></pre><p id="6b06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用来自Sklearn函数的信用数据，并设置随机种子以获得稳定的结果。数据来自于<a class="ae ky" href="https://www.openml.org/search?type=data&amp;status=active&amp;id=31" rel="noopener ugc nofollow" target="_blank"> OpenML信用数据</a>，其来源是<a class="ae ky" href="https://archive.ics.uci.edu/ml/datasets/statlog+(german+credit+data)" rel="noopener ugc nofollow" target="_blank"> UCI </a>并可商业使用。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a7d3" class="ne md it na b gy nf ng l nh ni">from sklearn.datasets import fetch_openml<br/>import random<br/>import numpy as np</span><span id="07f5" class="ne md it na b gy nj ng l nh ni">SEED = 123456<br/>np.random.seed(SEED)<br/>random.seed(SEED)</span><span id="61c3" class="ne md it na b gy nj ng l nh ni">data = fetch_openml("credit-g")<br/>X_raw = data.data<br/>y_raw = data.target</span></pre><p id="8d30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们将使用几个Sklearn函数进行一些数据清理。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c469" class="ne md it na b gy nf ng l nh ni">import pandas as pd<br/>from sklearn.preprocessing import StandardScaler<br/>cat_features = X_raw.select_dtypes("category").columns</span><span id="5657" class="ne md it na b gy nj ng l nh ni">X_encoded = pd.get_dummies(X_raw, columns=cat_features, drop_first=True)<br/>num_features = X_raw.select_dtypes("float64").columns</span><span id="b984" class="ne md it na b gy nj ng l nh ni">scaler = StandardScaler()<br/>X_scaled = X_encoded.copy()<br/>X_scaled[num_features] = scaler.fit_transform(X_encoded[num_features])</span><span id="4bad" class="ne md it na b gy nj ng l nh ni">y = y_raw.map({"bad": 0, "good": 1})  # encode labels as integers</span></pre><p id="c377" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将尝试从数据集样本中找到一个错误标签。根据cleanlab文档，cleanlab需要从模型中对每个数据点进行概率预测。</p><p id="3972" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Cleanlab也仅用于<strong class="lb iu">样本外</strong>预测概率，即训练期间模型中的样本。这就是为什么我们会使用K倍交叉验证来获得样本外概率。</p><p id="25ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们先建立模型来计算概率。我们将使用样本逻辑回归。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="df18" class="ne md it na b gy nf ng l nh ni">from sklearn.linear_model import LogisticRegression</span><span id="7f56" class="ne md it na b gy nj ng l nh ni">clf = LogisticRegression()</span></pre><p id="b6e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们会建立K倍交叉验证。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a8bc" class="ne md it na b gy nf ng l nh ni">from sklearn.model_selection import cross_val_predict</span><span id="19bd" class="ne md it na b gy nj ng l nh ni">num_crossval_folds = 5 </span><span id="18ab" class="ne md it na b gy nj ng l nh ni">pred_probs = cross_val_predict(<br/>    clf,<br/>    X_scaled,<br/>    y,<br/>    cv=num_crossval_folds,<br/>    method="predict_proba",<br/>)</span></pre><p id="f3fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们将使用Cleanlab <code class="fe ok ol om na b">find_label_issues</code>根据样本外概率和给定标签在数据集中找到坏标签。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7c32" class="ne md it na b gy nf ng l nh ni">from cleanlab.filter import find_label_issues</span><span id="ba08" class="ne md it na b gy nj ng l nh ni">ranked_label_issues = find_label_issues(</span><span id="86f1" class="ne md it na b gy nj ng l nh ni">labels=y, pred_probs=pred_probs, return_indices_ranked_by="self_confidence")</span><span id="a4fd" class="ne md it na b gy nj ng l nh ni">print(f"Cleanlab found {len(ranked_label_issues)} potential label errors.")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/f4309a23defb03668b53d69c252a32b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*Qujlq9AsTo9UN8x6SGnzOA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="5799" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们检查结果，我们将得到坏标签的位置。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2eaa" class="ne md it na b gy nf ng l nh ni">ranked_label_issues</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/e038b80606552fdf09016a249d435b8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VCSBLPrdhuvFj0HfITGQ8Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8543" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这些信息，我们需要再次检查数据，并确保质量优良。</p><p id="2003" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Cleanlab，您仍然可以探索许多事情。如果你想知道更多，请访问<a class="ae ky" href="https://docs.cleanlab.ai/v2.0.0/index.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0b17" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="81aa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">标签和数据科学项目一样重要，因为许多机器学习模型都依赖于正确的标签。为了帮助数据科学家在标注过程中工作，我为自动标注过程引入了3个Python包。这些软件包是:</p><ol class=""><li id="985c" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated">构成</li><li id="7731" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">通气管</li><li id="b0c8" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">清洁实验室</li></ol><p id="f433" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望有帮助！</p><blockquote class="nl nm nn"><p id="32f2" class="kz la no lb b lc ld ju le lf lg jx lh np lj lk ll nq ln lo lp nr lr ls lt lu im bi translated"><em class="it">访问我的</em> <a class="ae ky" href="https://bio.link/cornelli" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="it">社交媒体</em></strong></a><strong class="lb iu"><em class="it"/></strong><em class="it">进行更深入的交谈或有任何问题。</em></p></blockquote><blockquote class="os"><p id="76b8" class="ot ou it bd ov ow ox oy oz pa pb lu dk translated"><em class="pc">如果您没有订阅为中等会员，请考虑通过我的推荐订阅。</em></p></blockquote></div></div>    
</body>
</html>