<html>
<head>
<title>Multiclass classification evaluation with ROC Curves and ROC AUC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用ROC曲线和ROC AUC进行多类分类评价</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/multiclass-classification-evaluation-with-roc-curves-and-roc-auc-294fd4617e3a#2022-02-12">https://towardsdatascience.com/multiclass-classification-evaluation-with-roc-curves-and-roc-auc-294fd4617e3a#2022-02-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9648" class="pw-subtitle-paragraph jo ip iq bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">使用OvR和OvO策略使最常用的分类评估度量适应多类分类问题</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ca"><img src="../Images/e2edc4104ff04bfeb1f3721b702a45ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ipz3UCFYCaUZujYtDMG_QA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="3dea" class="pw-post-body-paragraph kv kw iq kx b ky kz js la lb lc jv ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当评估多类分类模型时，我们有时需要调整二元分类中使用的指标，以便在这种情况下工作。我们可以通过使用OvR和OvO策略来做到这一点。</p><p id="5af9" class="pw-post-body-paragraph kv kw iq kx b ky kz js la lb lc jv ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这篇文章中，我将展示如何适应ROC曲线和ROC AUC指标的多类分类。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><p id="4034" class="pw-post-body-paragraph kv kw iq kx b ky kz js la lb lc jv ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">ROC曲线和ROC AUC评分是评估二元分类模型的重要工具。总之，它们通过所有可能的阈值向我们显示了类别的可分性，或者换句话说，模型对每个类别的分类有多好。</p><p id="56c7" class="pw-post-body-paragraph kv kw iq kx b ky kz js la lb lc jv ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如我在另一篇文章中已经解释过的，我们可以比较ROC曲线(上图)和它们各自的直方图(下图)。直方图越分离，ROC曲线也越好。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lz"><img src="../Images/36efce9d11c93b6a327f0596a47757ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SKn7aehckf2J8FVz9xnraQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">ROC曲线比较。图片作者。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ma"><img src="../Images/e92bd98e375a3ee2e5d6718efe6073f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SQe_g5Rs_VzaU5CUV_dzSA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">类分离直方图比较。图片作者。</p></figure><p id="c039" class="pw-post-body-paragraph kv kw iq kx b ky kz js la lb lc jv ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是这个概念不能立即应用于多类分类器。为了在这个场景中使用ROC曲线和ROC AUC，我们需要另一种方法来比较类别:OvR和OvO。</p><p id="5676" class="pw-post-body-paragraph kv kw iq kx b ky kz js la lb lc jv ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在接下来的部分中，我会更好地解释它，您也可以在我的github上查看代码:</p><div class="mb mc gp gr md me"><a href="https://github.com/vinyluis/Articles/tree/main/ROC%20Curve%20and%20ROC%20AUC" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">主要乙烯基/物品的物品/ROC曲线和ROC AUC</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">第一篇:解读ROC曲线和ROC AUC用于分类评价(TBD) [EN]什么是ROC曲线，如何…</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">github.com</p></div></div><div class="mn l"><div class="mo l mp mq mr mn ms kp me"/></div></div></a></div><h1 id="c17b" class="mt mu iq bd mv mw mx my mz na nb nc nd jx ne jy nf ka ng kb nh kd ni ke nj nk bi translated">OvR还是OvO？</h1><h2 id="d3d5" class="nl mu iq bd mv nm nn dn mz no np dp nd le nq nr nf li ns nt nh lm nu nv nj nw bi translated">OvR —一个与其余</h2><p id="b4ac" class="pw-post-body-paragraph kv kw iq kx b ky nx js la lb ny jv ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">OvR代表“One vs Rest”，顾名思义，它是一种通过同时将每个类与所有其他类进行比较来评估多类模型的方法。在这种情况下，我们选择一个类，并将其视为“积极”类，而所有其他类(其余的)则被视为“消极”类。</p><p id="94f7" class="pw-post-body-paragraph kv kw iq kx b ky kz js la lb lc jv ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过这样做，我们将多类分类输出减少为二类分类输出，因此可以使用所有已知的二类分类度量来评估这种情况。</p><p id="e4e9" class="pw-post-body-paragraph kv kw iq kx b ky kz js la lb lc jv ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们必须对数据中出现的每个类重复这一过程，因此对于一个3类数据集，我们得到3个不同的OvR分数。最后，我们可以对它们进行平均(简单平均或加权平均)以得到最终的OvR模型分数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/6c851349acd334dff111218d1d75697a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wY4puy2JRUMNu4akV1M9yQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">三级设置的OvR组合。图片作者。</p></figure><h2 id="dd9a" class="nl mu iq bd mv nm nn dn mz no np dp nd le nq nr nf li ns nt nh lm nu nv nj nw bi translated">卵——一对一</h2><p id="c052" class="pw-post-body-paragraph kv kw iq kx b ky nx js la lb ny jv ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">正如你可能想象的那样，OvO代表“一对一”,与OvR非常相似，但我们不是将每个类与其他类进行比较，而是比较数据集所有可能的两类组合。</p><p id="85d2" class="pw-post-body-paragraph kv kw iq kx b ky kz js la lb lc jv ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">假设我们有一个3类场景，我们选择组合“类1对类2”作为第一个场景。第一步是获得仅包含这两个类的数据集的副本，并丢弃所有其他类。然后，我们将real class = "Class1 "的观察定义为我们的积极类，将real class = "Class2 "的观察定义为我们的消极类。既然问题是二进制的，我们也可以使用我们用于二进制分类的相同度量。</p><p id="53ed" class="pw-post-body-paragraph kv kw iq kx b ky kz js la lb lc jv ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，“类别1与类别2”不同于“类别2与类别1”，因此这两种情况都应考虑在内。因此，在3类数据集中，我们得到6个OvO分数，在4类数据集中，我们得到12个OvO分数。</p><p id="48b4" class="pw-post-body-paragraph kv kw iq kx b ky kz js la lb lc jv ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在OvR中，我们可以平均所有的OvO分数，以获得最终的OvO模型分数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ca"><img src="../Images/f8463eb35d20b0f896a6f79457fcd46a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kLfovll3vI1wO66PqR6vWg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">三级设置的OvO组合。图片作者。</p></figure><h1 id="4adf" class="mt mu iq bd mv mw mx my mz na nb nc nd jx ne jy nf ka ng kb nh kd ni ke nj nk bi translated">OvR ROC曲线和ROC AUC</h1><p id="77a4" class="pw-post-body-paragraph kv kw iq kx b ky nx js la lb ny jv ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">我将使用我在<a class="ae ly" href="https://www.notion.so/ROC-Curve-and-ROC-AUC-2a551988205248a89a28541d70c497c8" rel="noopener ugc nofollow" target="_blank">二元分类ROC </a>文章中使用的函数来绘制曲线，只做一些修改，这些修改可在<a class="ae ly" href="https://github.com/vinyluis/Articles/blob/main/ROC%20Curve%20and%20ROC%20AUC/ROC%20Curve%20-%20Multiclass.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>获得。如果您愿意，也可以使用scikit-learn版本。</p><p id="9c4d" class="pw-post-body-paragraph kv kw iq kx b ky kz js la lb lc jv ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个例子中，我将使用一个包含三个类的合成数据集:“苹果”、“香蕉”和“橙子”。它们在每个类的组合中都有一些重叠，这使得分类器很难正确地学习所有的实例。数据集只有两个特征:“x”和“y”，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/a5861f4a8b7fc2755a5224f1f9bd1846.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*YH1P5-GGv5fZ6l8ihe4o_w.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">多类散点图。图片作者。</p></figure><p id="70a9" class="pw-post-body-paragraph kv kw iq kx b ky kz js la lb lc jv ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于这个模型，我训练了scikit-learn的RandomForestClassifier的一个默认实例。</p><p id="4d98" class="pw-post-body-paragraph kv kw iq kx b ky kz js la lb lc jv ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在下面的代码中，我们:</p><ul class=""><li id="bfae" class="oe of iq kx b ky kz lb lc le og li oh lm oi lq oj ok ol om bi translated">迭代所有类</li><li id="f1f8" class="oe of iq kx b ky on lb oo le op li oq lm or lq oj ok ol om bi translated">准备一个辅助数据帧，使用一个类为“1”，其他类为“0”</li><li id="a0a7" class="oe of iq kx b ky on lb oo le op li oq lm or lq oj ok ol om bi translated">绘制类别分布的直方图</li><li id="94ab" class="oe of iq kx b ky on lb oo le op li oq lm or lq oj ok ol om bi translated">绘制每种情况的ROC曲线</li><li id="fb9e" class="oe of iq kx b ky on lb oo le op li oq lm or lq oj ok ol om bi translated">计算特定类别的AUC</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="7b8d" class="pw-post-body-paragraph kv kw iq kx b ky kz js la lb lc jv ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的代码输出了每个类别相对于其他类别的直方图和ROC曲线:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/9f40e6664be3cab322978da65ebc8241.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VIwOKY8BNHjfUB3BsUO-0A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">ROC曲线和直方图。图片作者。</p></figure><p id="acad" class="pw-post-body-paragraph kv kw iq kx b ky kz js la lb lc jv ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如我们所看到的，“橙色”类的分数比其他两个类低一点，但在所有情况下，分类器在预测每个类方面都做得很好。我们还可以在直方图上注意到，我们在真实数据中看到的重叠也存在于预测中。</p><p id="161c" class="pw-post-body-paragraph kv kw iq kx b ky kz js la lb lc jv ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了显示每个OvR AUC分数，我们可以简单地打印它们。我们也可以取分类器的平均分数:</p><pre class="kg kh ki kj gt ov ow ox oy aw oz bi"><span id="23dd" class="nl mu iq ow b gy pa pb l pc pd"># Displays the ROC AUC for each class<br/>avg_roc_auc = 0<br/>i = 0<br/>for k in roc_auc_ovr:<br/>    avg_roc_auc += roc_auc_ovr[k]<br/>    i += 1<br/>    print(f"{k} ROC AUC OvR: {roc_auc_ovr[k]:.4f}")<br/>print(f"average ROC AUC OvR: {avg_roc_auc/i:.4f}")</span></pre><p id="3e32" class="pw-post-body-paragraph kv kw iq kx b ky kz js la lb lc jv ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">输出是:</p><pre class="kg kh ki kj gt ov ow ox oy aw oz bi"><span id="e492" class="nl mu iq ow b gy pa pb l pc pd">apple ROC AUC OvR: 0.9425<br/>banana ROC AUC OvR: 0.9525<br/>orange ROC AUC OvR: 0.9281<br/>average ROC AUC OvR: 0.9410</span></pre><p id="8ee2" class="pw-post-body-paragraph kv kw iq kx b ky kz js la lb lc jv ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这种情况下，平均ROC AUC OvR为0.9410，这是一个非常好的分数，反映了分类器在预测每一类中的表现。</p><h1 id="ba58" class="mt mu iq bd mv mw mx my mz na nb nc nd jx ne jy nf ka ng kb nh kd ni ke nj nk bi translated">OvO ROC曲线和ROC AUC</h1><p id="8112" class="pw-post-body-paragraph kv kw iq kx b ky nx js la lb ny jv ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">使用与上一个实验相同的设置，首先需要做的是建立一个包含所有可能的类对的列表:</p><pre class="kg kh ki kj gt ov ow ox oy aw oz bi"><span id="d7fe" class="nl mu iq ow b gy pa pb l pc pd">classes_combinations = []<br/>class_list = list(classes)<br/>for i in range(len(class_list)):<br/>    for j in range(i+1, len(class_list)):<br/>        classes_combinations.append([class_list[i], class_list[j]])<br/>        classes_combinations.append([class_list[j], class_list[i]])</span></pre><p id="7390" class="pw-post-body-paragraph kv kw iq kx b ky kz js la lb lc jv ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe pe pf pg ow b">classes_combinations</code>列表将包含所有组合:</p><pre class="kg kh ki kj gt ov ow ox oy aw oz bi"><span id="8c01" class="nl mu iq ow b gy pa pb l pc pd">[['apple', 'banana'],<br/> ['banana', 'apple'],<br/> ['apple', 'orange'],<br/> ['orange', 'apple'],<br/> ['banana', 'orange'],<br/> ['orange', 'banana']]</span></pre><p id="5f1f" class="pw-post-body-paragraph kv kw iq kx b ky kz js la lb lc jv ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后我们迭代所有的组合，类似于OvR的情况，我们</p><ul class=""><li id="3107" class="oe of iq kx b ky kz lb lc le og li oh lm oi lq oj ok ol om bi translated">准备一个辅助数据帧，只包含两个类的实例</li><li id="8f44" class="oe of iq kx b ky on lb oo le op li oq lm or lq oj ok ol om bi translated">将类1的实例定义为“1”，将类2的实例定义为“0”</li><li id="1eb4" class="oe of iq kx b ky on lb oo le op li oq lm or lq oj ok ol om bi translated">绘制类别分布的直方图</li><li id="f4c8" class="oe of iq kx b ky on lb oo le op li oq lm or lq oj ok ol om bi translated">绘制每种情况的ROC曲线</li><li id="615c" class="oe of iq kx b ky on lb oo le op li oq lm or lq oj ok ol om bi translated">计算特定组合的AUC</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="de7a" class="pw-post-body-paragraph kv kw iq kx b ky kz js la lb lc jv ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的代码绘制了所有直方图和ROC曲线:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ph"><img src="../Images/a34aba05177334f658e75a6aa7fed447.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7zlzW0TGWazAcLPyG7Warw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">ROC曲线和直方图。图片作者。</p></figure><p id="64e0" class="pw-post-body-paragraph kv kw iq kx b ky kz js la lb lc jv ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，正如所料，“苹果vs香蕉”图与“香蕉vs苹果”图不同。和前面的例子一样，我们可以单独评估每个组合，并检查模型的不一致性。</p><p id="8303" class="pw-post-body-paragraph kv kw iq kx b ky kz js la lb lc jv ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还可以显示AUC并计算平均OvO AUC:</p><pre class="kg kh ki kj gt ov ow ox oy aw oz bi"><span id="0854" class="nl mu iq ow b gy pa pb l pc pd"># Displays the ROC AUC for each class<br/>avg_roc_auc = 0<br/>i = 0<br/>for k in roc_auc_ovo:<br/>    avg_roc_auc += roc_auc_ovo[k]<br/>    i += 1<br/>    print(f"{k} ROC AUC OvO: {roc_auc_ovo[k]:.4f}")<br/>print(f"average ROC AUC OvO: {avg_roc_auc/i:.4f}")</span></pre><p id="8a2b" class="pw-post-body-paragraph kv kw iq kx b ky kz js la lb lc jv ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">输出是:</p><pre class="kg kh ki kj gt ov ow ox oy aw oz bi"><span id="eac7" class="nl mu iq ow b gy pa pb l pc pd">apple vs banana ROC AUC OvO: 0.9561<br/>banana vs apple ROC AUC OvO: 0.9547<br/>apple vs orange ROC AUC OvO: 0.9279<br/>orange vs apple ROC AUC OvO: 0.9231<br/>banana vs orange ROC AUC OvO: 0.9498<br/>orange vs banana ROC AUC OvO: 0.9336<br/>average ROC AUC OvO: 0.9409</span></pre><p id="f491" class="pw-post-body-paragraph kv kw iq kx b ky kz js la lb lc jv ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这种情况下，平均ROC AUC为0.9409，接近OvR方案获得的分数(0.9410)。</p><h1 id="5665" class="mt mu iq bd mv mw mx my mz na nb nc nd jx ne jy nf ka ng kb nh kd ni ke nj nk bi translated">结论</h1><p id="5ec4" class="pw-post-body-paragraph kv kw iq kx b ky nx js la lb ny jv ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">OvR和OvO策略可以(并且应该)用于使任何二元分类度量适应多类分类任务。</p><p id="9ad1" class="pw-post-body-paragraph kv kw iq kx b ky kz js la lb lc jv ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">评估OvO和OvR结果还有助于了解模型难以描述的类，以及可以添加或移除哪些功能来改善模型的结果。</p><h1 id="cc02" class="mt mu iq bd mv mw mx my mz na nb nc nd jx ne jy nf ka ng kb nh kd ni ke nj nk bi translated">如果你喜欢这个帖子…</h1><p id="823e" class="pw-post-body-paragraph kv kw iq kx b ky nx js la lb ny jv ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">支持我一杯咖啡！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://www.buymeacoffee.com/vinitrevisan"><div class="gh gi pi"><img src="../Images/acf4154cfebdc13859934db49fd502cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*h_y4o6IwDDFFWIyKQE7Rww.png"/></div></a><p class="kr ks gj gh gi kt ku bd b be z dk translated">给我买杯咖啡！</p></figure><p id="cf7c" class="pw-post-body-paragraph kv kw iq kx b ky kz js la lb lc jv ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">看看这个很棒的帖子</p><div class="mb mc gp gr md me"><a rel="noopener follow" target="_blank" href="/interpreting-roc-curve-and-roc-auc-for-classification-evaluation-28ec3983f077"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">解释ROC曲线和ROC AUC进行分类评估</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">我多么希望我第一次学ROC曲线的时候就有人教我</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">towardsdatascience.com</p></div></div><div class="mn l"><div class="pj l mp mq mr mn ms kp me"/></div></div></a></div></div></div>    
</body>
</html>