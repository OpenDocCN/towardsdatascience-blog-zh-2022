<html>
<head>
<title>Taking Your Optimization Skills to the Next Level</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让您的优化技能更上一层楼</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/taking-your-optimization-skills-to-the-next-level-de47a9c51167#2022-03-27">https://towardsdatascience.com/taking-your-optimization-skills-to-the-next-level-de47a9c51167#2022-03-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/7af9802099f46fa816b99f7ce59a770e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5Q9CmHMV5GV6jCUV"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">照片由<a class="ae jd" href="https://unsplash.com/@lukasleitner?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卢卡斯·莱特纳</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><div class=""/><div class=""><h2 id="6836" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated"><strong class="ak">软约束、线性化、多目标等</strong></h2></div><p id="b08f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">如果你是一个优化初学者，我会建议你在回到这篇文章之前，先从</em> <a class="ae jd" href="https://hennie-de-harder.medium.com/why-every-data-scientist-should-learn-mathematical-optimization-3ac102663456" rel="noopener"> <em class="lr">为什么</em> </a> <em class="lr">和</em> <a class="ae jd" href="https://hennie-de-harder.medium.com/how-to-handle-optimization-problems-daf97b3c248c" rel="noopener"> <em class="lr">如何</em> </a> <em class="lr">开始。在这里，当问题比基本的玩具例子复杂一点时，我通过解释常见的实践来提供额外的信息。</em></p><h2 id="e093" class="ls lt jg bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">读取求解程序进度</h2><p id="4eb5" class="pw-post-body-paragraph kv kw jg kx b ky ml kh la lb mm kk ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">通过将<code class="fe mq mr ms mt b">tee=True</code>加到<code class="fe mq mr ms mt b">opt.solve(model)</code>上，优化过程中求解器的进程将被打印出来。您还可以通过指定一个<code class="fe mq mr ms mt b">logfile='fn.log'</code>来选择将日志写入文件。该日志提供了有关运行的信息，对于设置限制很有价值。</p><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mu"><img src="../Images/0a92ba1d2b3bb45d2ff31ec4c76ce9d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bZfFuDzKKYwvBISvW9g5lw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">古罗比日志。图片作者。</p></figure><p id="341c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面你可以看到 Gurobi 运行的输出。这是一个最大化问题。你需要了解的最重要的事情:</p><ul class=""><li id="c59b" class="mz na jg kx b ky kz lb lc le nb li nc lm nd lq ne nf ng nh bi translated">在每一行之前，你会看到一个 H 或者一个空位。这表明当前最佳解决方案(<em class="lr">现任</em>)与之前的最佳解决方案相比是否有所改进。</li><li id="f92b" class="mz na jg kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated"><em class="lr">现任</em>表示当前最佳解决方案。目标的最大值(或最小化问题中的最小值)。</li><li id="f620" class="mz na jg kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated"><em class="lr"> BestBd </em>表示目标将达到的最大值。求解者不确定是否有可能达到这个数，但肯定不会超过。</li><li id="d466" class="mz na jg kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated"><em class="lr">差距</em>是<em class="lr">现任</em>和<em class="lr">最佳</em>之间的百分比差距。由此可见还有多大的提升空间。这是一个重要的值，将在下一节讨论。</li><li id="0308" class="mz na jg kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated"><em class="lr">时间</em>显示该行之前的总加工时间。</li></ul><p id="80bf" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其他解算器的输出日志看起来不同，但大多数至少显示了当前最佳解、最大最佳解、时间、迭代和节点。</p><h2 id="4065" class="ls lt jg bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">MIP 差距和时间限制</h2><p id="c365" class="pw-post-body-paragraph kv kw jg kx b ky ml kh la lb mm kk ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">如果您正在处理具有许多变量和约束的大型优化问题，规划求解可能需要几个小时甚至几天才能得出问题的最优解。大多数公司都希望快速做出决策，所以你需要为求解者设置限制。这就是 MIP 差距和时间限制发挥作用的地方。让我们再看一下日志:</p><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mu"><img src="../Images/0a92ba1d2b3bb45d2ff31ec4c76ce9d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bZfFuDzKKYwvBISvW9g5lw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">古罗比日志。图片作者。</p></figure><p id="7d3e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">311 秒后，也就是 5 分钟多一点，求解器做出了最大的改进。此后，改善变得平缓，正如您在下图中看到的:</p><figure class="mv mw mx my gt is gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/7f3a14500d4e06e66e7da1af04ab5437.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*0d3EanF_PLE8Ye3enmsulw.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">分钟和差距，5 分钟后改善变得越来越小。</p></figure><p id="49ae" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过与利益相关者交谈和分析日志，您可以根据您的具体问题找到一个合适的时间限制。在时间和性能之间有一个平衡。更长的求解时间意味着更好的性能。对于我们在这里看到的过程，您可能希望将时间限制设置为 600 秒(10 分钟)。如果你使用 Gurobi 和 pyomo，你需要在你的代码中添加<code class="fe mq mr ms mt b">opt.options['TimeLimit'] = 600</code>。求解器将在 600 秒后停止，并保持最佳解。</p><p id="4a8b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您也可以选择设置 MIP 间隙。还记得上一节的差距吗？这显示了改进的空间(现任<em class="lr">的</em>和<em class="lr">的</em>之间的差距)。如果您希望求解器在差距低于 1%时停止，您应该在代码中添加<code class="fe mq mr ms mt b">opt.options['MIPGap'] = 0.01</code>。</p><p id="5c9a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最佳做法是设置 MIP 间隙和时间限制。如果满足其中一个条件，求解器将停止并返回当前最佳解。</p><h2 id="7e5d" class="ls lt jg bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">多目标</h2><p id="e71b" class="pw-post-body-paragraph kv kw jg kx b ky ml kh la lb mm kk ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">有时候你的问题无法用一个目标函数来表述。在这种情况下，你必须处理一个多目标。这里的第一步是:试着把你的问题变成一个单一的目标，因为这会让事情变得简单很多。如果你的目标有相同的性质，比如钱，你可以将它们相加或相减，最终得到一个单一的目标。或者你可以尝试用约束来代替一个目标。如果这些方法不起作用，你就面临着多重目标。</p><p id="a803" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">多目标意味着多个最佳解决方案，因为你在最小化(或最大化)多个你不容易比较的东西。假设您正在最小化两个目标，所有具有低目标值的组合都是可能的最佳解决方案(蓝点):</p><figure class="mv mw mx my gt is gh gi paragraph-image"><div class="gh gi no"><img src="../Images/d1c82abe979dfbe38ecdfc7c102ff57d.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*lBIj2hXUBRpGwTtD2-DCew.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">具有两个目标和 Pareto 前沿的目标空间示例。图片作者。</p></figure><p id="75aa" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每一个更高和更靠右的解都比蓝点更差。这些蓝点被称为帕累托前沿。</p><p id="ca98" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你必须处理多目标，看看<a class="ae jd" href="https://pymoo.org/algorithms/moo/nsga2.html" rel="noopener ugc nofollow" target="_blank"> pymoo </a>框架。</p><h2 id="f2ea" class="ls lt jg bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">绝对值</h2><p id="fbbe" class="pw-post-body-paragraph kv kw jg kx b ky ml kh la lb mm kk ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">有时优化问题的目标是尽可能接近某一点。距离是负是正都无所谓，应该越小越好。在这种情况下，最简单的方法是最小化距离的绝对值。但是优化框架不喜欢绝对函数。很难对绝对函数执行标准的优化过程，因为它们不是线性的，也不是连续可微的。</p><figure class="mv mw mx my gt is gh gi paragraph-image"><div class="gh gi np"><img src="../Images/f72dc5f5d040ab2c2ff31435c9119a28.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*TecoMrGC2dvV0ds96uYXmQ.png"/></div></figure><p id="e640" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们应该如何处理绝对值？这其实很简单！我们需要添加两个虚拟变量，并将它们定义为正距离和负距离。如果我们想尽可能接近 30，解决方案看起来像:</p><pre class="mv mw mx my gt nq mt nr ns aw nt bi"><span id="a549" class="ls lt jg mt b gy nu nv l nw nx"># set variables<br/>model.x = pyo.Var()<br/>model.posdelta = pyo.Var(bounds=(0, None))<br/>model.negdelta = pyo.Var(bounds=(0, None))</span><span id="ffd1" class="ls lt jg mt b gy ny nv l nw nx"># constraint to define the posdelta and negdelta<br/>model.define_deltas = pyo.Constraint(expr= model.x + model.posdelta - model.negdelta == 30)</span><span id="f881" class="ls lt jg mt b gy ny nv l nw nx"># minimize the delta values in the objective<br/>model.obj = pyo.Objective(expr= model.posdelta + model.negdelta, sense=pyo.minimize)</span></pre><p id="944f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以如果<code class="fe mq mr ms mt b">model.x</code>等于 35，<code class="fe mq mr ms mt b">model.negdelta</code>会是 5，<code class="fe mq mr ms mt b">model.posdelta</code>会是 0。另一方面，如果<code class="fe mq mr ms mt b">model.x</code>等于 25，<code class="fe mq mr ms mt b">model.posdelta</code>等于 5，<code class="fe mq mr ms mt b">model.negdelta</code>将为 0。通过对<code class="fe mq mr ms mt b">model.posdelta</code>和<code class="fe mq mr ms mt b">model.negdelta</code>求和，我们得到<code class="fe mq mr ms mt b">x</code>和 30°之间的绝对距离。</p><p id="9632" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">小心点。如果你不在目标中使用 delta 变量，奇怪的行为就会发生。求解器可以选择使两个变量都大于零。因为 25+10–5 = 30，在这种情况下<code class="fe mq mr ms mt b">model.posdelta</code>是 10 而<code class="fe mq mr ms mt b">model.negdelta</code>是 5。因此，请确保将它们添加到目标中，或者添加约束，以确保只有一个变量可以大于零。</p><p id="211e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" href="https://hennie-de-harder.medium.com/how-to-handle-optimization-problems-daf97b3c248c" rel="noopener"> <em class="lr">本文的第三个例子</em> </a> <em class="lr">采用了这种技术。</em></p><h2 id="ab44" class="ls lt jg bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">线性化</h2><p id="ce6e" class="pw-post-body-paragraph kv kw jg kx b ky ml kh la lb mm kk ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">假设你正在处理一个优化问题，你有两个变量<code class="fe mq mr ms mt b">x1</code>和<code class="fe mq mr ms mt b">x2</code>。如果<code class="fe mq mr ms mt b">x1</code>大于零，<code class="fe mq mr ms mt b">x2</code>应该等于零。而如果<code class="fe mq mr ms mt b">x2</code>大于零，<code class="fe mq mr ms mt b">x1</code>应该等于零。或者更容易表述为:两者中只有一个可能大于零。我们如何指定满足这一点的约束呢？你可能认为这很简单。如果我们把<code class="fe mq mr ms mt b">x1</code>和<code class="fe mq mr ms mt b">x2</code>相乘，解应该是零(因为只有两者中至少有一个等于零，才能满足<code class="fe mq mr ms mt b">x1*x2=0</code>)。但这是个问题。如果我们把两个变量相乘，问题就不再是线性的了。这意味着我们必须处理不好的东西，比如全局和局部最小值等等…</p><p id="fdec" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">还有别的解决办法吗？</p><p id="e23c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">是的有！我们需要添加两个二进制虚拟变量来解决这个问题。如果<code class="fe mq mr ms mt b">x1_dummy</code>等于零，<code class="fe mq mr ms mt b">x1</code>等于零，如果<code class="fe mq mr ms mt b">x1_dummy</code>等于一，<code class="fe mq mr ms mt b">x1</code>大于零(同样适用于<code class="fe mq mr ms mt b">x2_dummy</code>和<code class="fe mq mr ms mt b">x2</code>)。<br/> <code class="fe mq mr ms mt b">M</code>是<code class="fe mq mr ms mt b">x1</code>和<code class="fe mq mr ms mt b">x2</code>(又名大 M)的最高可能值。我们需要添加的约束条件:</p><pre class="mv mw mx my gt nq mt nr ns aw nt bi"><span id="c173" class="ls lt jg mt b gy nu nv l nw nx"># only one of the two dummies can be equal to 1<br/>x1_dummy + x2_dummy &lt;= 1</span><span id="7ffe" class="ls lt jg mt b gy ny nv l nw nx"># x always smaller than M*dummy, if dummy is 0, variable is 0<br/>x1 &lt;= M*x1_dummy<br/>x2 &lt;= M*x2_dummy</span></pre><p id="0659" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在问题还是线性的，<code class="fe mq mr ms mt b">x1</code>和<code class="fe mq mr ms mt b">x2</code>只能有一个大于零。</p><p id="37a5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这只是线性化的一个例子。</p><h2 id="28fa" class="ls lt jg bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">软约束</h2><p id="7c52" class="pw-post-body-paragraph kv kw jg kx b ky ml kh la lb mm kk ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">你曾经优化过一个没有可能解决的问题吗？当您的边界或约束非常严格，没有解决方案可以满足所有需求时，就会出现这种情况。这可能会令人沮丧，尤其是当一个进程正在等待求解器的答案时。</p><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nz"><img src="../Images/5d81064f25675e3b1eeeecca0aa60809.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BtVYsLbVaean_Cb8oe2qpQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">模型不可行。图片作者。</p></figure><p id="f9e8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个怎么打理？软约束可能是一种可能的解决方案。您可以通过向普通约束添加惩罚变量<code class="fe mq mr ms mt b">x_pen</code>来扩展约束的边界。</p><p id="a4a7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">想象你想要<code class="fe mq mr ms mt b">x1+x2 &gt;= 10</code>。如果将此约束更改为<code class="fe mq mr ms mt b">x1+x2 &gt;= 10-x_pen</code>，求解器可以灵活选择大于 0 的<code class="fe mq mr ms mt b">x_pen</code>。这意味着<code class="fe mq mr ms mt b">x1+x2</code>可能会变得小于 10(所以不要给硬约束增加惩罚)。通过将<code class="fe mq mr ms mt b">x_pen</code>加到目标函数中，求解器将试图保持<code class="fe mq mr ms mt b">x_pen</code>尽可能低。</p></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><h1 id="cb6b" class="oh lt jg bd lu oi oj ok lx ol om on ma km oo kn md kp op kq mg ks oq kt mj or bi translated">结论</h1><p id="8d8c" class="pw-post-body-paragraph kv kw jg kx b ky ml kh la lb mm kk ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">我希望这篇文章能帮助你成为一个更好的优化者。这只是冰山一角，但这些问题是常见的，将有助于您更好地理解优化和解决现实生活中的情况。</p><p id="0be4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下次见！</p></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><h2 id="3d53" class="ls lt jg bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">有关系的</h2><div class="ip iq gp gr ir os"><a rel="noopener follow" target="_blank" href="/why-every-data-scientist-should-learn-mathematical-optimization-3ac102663456"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd jh gy z fp ox fr fs oy fu fw jf bi translated">为什么每个数据科学家都应该学习数学优化</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">数据科学课程的重点是数据可视化，特征工程，数据处理，(非)监督学习…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">towardsdatascience.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg ix os"/></div></div></a></div><div class="ip iq gp gr ir os"><a rel="noopener follow" target="_blank" href="/how-to-handle-optimization-problems-daf97b3c248c"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd jh gy z fp ox fr fs oy fu fw jf bi translated">如何处理优化问题？</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">带有解决方案和代码的简单示例。</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">towardsdatascience.com</p></div></div><div class="pb l"><div class="ph l pd pe pf pb pg ix os"/></div></div></a></div></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="527c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你想在我发表新文章时收到电子邮件，别忘了订阅。</p></div></div>    
</body>
</html>