<html>
<head>
<title>Parallelization in Python: The Easy Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的并行化:简单的方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/parallelization-in-python-the-easy-way-aa03ed04c209#2022-10-26">https://towardsdatascience.com/parallelization-in-python-the-easy-way-aa03ed04c209#2022-10-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="88a5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">并行化不一定很难</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/070f78092433a86f743d5b4c63b77990.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wm0hFRbPsxKCjyI_"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Python中的并行化并不一定很难。阿巴斯·特拉尼在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3471" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多初学者和中级Python开发人员害怕并行化。对他们来说，并行代码意味着困难的代码。进程、线程、greenlets、协程……并行化代码的工作不是以高性能代码而告终，而是经常以令人头疼和沮丧而告终。</p><p id="8d90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我想告诉大家事实并非如此。在简单的场景中，代码很容易并行化。众所周知，Python是一种易于理解的编程语言，并行代码也易于阅读和实现。</p><p id="cbd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文是<em class="lv">而不是</em>并行化的介绍。不全面。相反，我想向您展示在简单的情况下并行化代码是多么简单。这将为您提供将并行化应用于更复杂场景的必要背景。或者至少，从简单的开始总比从难的开始好。</p><p id="0924" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单的例子不一定意味着学术上的例子。作为Python开发人员或数据科学家，您会经常遇到需要加快应用程序速度的情况。您应该做的第一件事是分析代码。忽略这一点可能是试图优化它时最常见的错误。概要分析可以向您展示应用程序中的瓶颈，在这些地方您可以获得一些收益。如果您不分析您的代码，您可能会花一天的时间来优化应用程序中实际上最有效的部分。</p><p id="786f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在进行分析后，您会发现应用程序99%的时间都在运行执行某些计算的iterable上的一个函数。那么，你可能会想，如果你并行运行这个函数，应用程序应该会更快——你<em class="lv">可能是对的。这种情况就是我所说的简单情况。</em></p><p id="eda1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文旨在展示如何在这种情况下简单地并行化Python代码。不过，你可能还会学到一件事:如何设计和原型化代码。我不会写一个实际的应用程序，因为这样的代码会让我们分心。相反，我将编写这样一个应用程序的简单原型。原型可以工作，但不会做任何有价值的事情；它只会做一些类似于这种应用程序在现实生活中所能做的事情。</p><h1 id="6ec5" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">示例应用程序</h1><p id="ea15" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">假设我们的目标是编写一个处理文本的应用程序。这种处理可以是你想对文本做的任何事情。例如，你可以在书中搜索指纹，正如本·布拉特在他关于纳博科夫的精彩著作中所做的那样(布拉特2017)。</p><p id="e3a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的应用程序中，对于每个文本，将运行以下管道:</p><ul class=""><li id="fdcc" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">读取文本文件</li><li id="ff80" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">预处理文件；这意味着清洁和检查</li><li id="0c49" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">处理文件</li><li id="108e" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">返回结果</li></ul><p id="a497" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种优雅的方法是创建一个生成器管道。我在我的<a class="ae ky" rel="noopener" target="_blank" href="/building-generator-pipelines-in-python-8931535792ff">另一篇文章</a>中展示了如何做。我们将使用这种方法。</p><p id="6c90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面，您将找到创建上述管道的一个函数，以及管道使用的三个函数。管道函数将负责运行所有这些函数，然后返回结果。</p><p id="74d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将使用这些函数的简单模拟，因为我不希望您关注与并行化无关的代码。我还将添加一些睡眠时间，以便函数花费的时间与它们在现实中可能花费的时间成比例。请注意，这些休眠旨在表示计算量大(而不是等待HTTP响应)的任务，对于这些任务，加速计算的唯一方法是使用并行化。</p><pre class="kj kk kl km gt nh ni nj bn nk nl bi"><span id="d455" class="nm lx it ni b be nn no l np nq">import time<br/>import pathlib<br/>from typing import Dict, Generator, Iterable<br/><br/># type aliases<br/>ResultsType = Dict[str, int]<br/><br/>def read_file(path: pathlib.Path) -&gt; str:<br/>    # a file is read to a string and returned<br/>    # here, it's mocked by the file's name as a string<br/>    # this step should be rather quick <br/>    time.sleep(.05)<br/>    text = path.name<br/>    return text<br/><br/>def preprocess(text: str) -&gt; str:<br/>    # preprocessing is done here<br/>    # we make upper case of text<br/>    # longer than reading but quite shorter than processing<br/>    time.sleep(.25)<br/>    text = text.upper()<br/>    return text<br/><br/>def process(text: str) -&gt; ResultsType:<br/>    # the main process is run here<br/>    # we return the number of "A" and "O" letters in text<br/>    # this is the longest process among all<br/>    time.sleep(1.)<br/>    search = ("A", "B", )<br/>    results = {letter: text.count(letter) for letter in search}<br/>    return results<br/><br/>def pipeline(path: pathlib.Path) -&gt; ResultsType:<br/>    text = read_file(path)<br/>    preprocessed = preprocess(text)<br/>    processed = process(preprocessed)<br/>    return processed</span></pre><p id="c57c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们需要一个可迭代的路径。真正的<code class="fe nr ns nt ni b">read_file()</code>函数会读取文件，但是我们的模拟函数不会；相反，它根据路径名生成文本。我这样做是为了让事情尽可能简单。所以，这将是我们的迭代:</p><pre class="kj kk kl km gt nh ni nj bn nk nl bi"><span id="dfd0" class="nm lx it ni b be nn no l np nq">file_paths = (<br/>    pathlib.Path(p)<br/>    for p in (<br/>        "book_about_python.txt",<br/>        "book_about_java.txt",<br/>        "book_about_c.txt",<br/>        "science_fiction_book.txt",<br/>        "lolita.txt",<br/>        "go_there_and_return.txt",<br/>        "statistics_for_dummies.txt",<br/>        "data_science_part_1.txt",<br/>        "data_science_part_2.txt",<br/>        "data_science_part_3.txt",<br/>    )<br/>)</span></pre><p id="c1f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经拥有了我们所需要的一切:一个产生路径的<code class="fe nr ns nt ni b">file_paths</code>生成器，就像<code class="fe nr ns nt ni b">pathlib.Path</code>一样，指向文件。我们现在可以使用这个生成器运行整个管道，这样我们将使用一个生成器管道，就像我承诺的那样。为此，我们可以迭代<code class="fe nr ns nt ni b">file_path</code>生成器，在每次迭代中，每条路径都将通过<code class="fe nr ns nt ni b">pipeline()</code>函数进行处理。这样，我们将像承诺的那样使用一个生成器管道。</p><p id="1cda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在name-main块中执行生成器的评估:</p><pre class="kj kk kl km gt nh ni nj bn nk nl bi"><span id="d9a7" class="nm lx it ni b be nn no l np nq">if __name__ == "__main__":<br/>    start = time.perf_counter()<br/>    results = {path: pipeline(path) for path in file_paths}<br/>    print(f"Elapsed time: {round(time.perf_counter() - start, 2)}")<br/>    print(results)</span></pre><p id="c1af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个管用。我增加了测量时间。因为我们有10个文件要处理，而一个文件的处理时间大约为1.3秒，所以我们应该预计整个管道的运行时间大约为13秒，外加一些开销。</p><p id="fc3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，在我的机器上，整个流水线需要13.02秒来处理。</p><h1 id="ae4a" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">Python并行化:操作指南</h1><p id="b69f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">上面，我们使用字典理解评估了管道。我们可以使用生成器表达式或<code class="fe nr ns nt ni b">map()</code>函数:</p><pre class="kj kk kl km gt nh ni nj bn nk nl bi"><span id="370e" class="nm lx it ni b be nn no l np nq">if __name__ == "__main__":<br/>    start = time.perf_counter()<br/>    pipeline_gen = map(lambda p: (p, pipeline(p)), file_paths)<br/>    # or we can use a generator expression: <br/>    # pipeline_gen = ((path, pipeline(path)) for path in file_paths)<br/>    results = dict(pipeline_gen)<br/>    print(f"Elapsed time: {round(time.perf_counter() - start, 2)}")<br/>    print(results)</span></pre><p id="1ad9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对<code class="fe nr ns nt ni b">map()</code>的调用看起来比上面的dict理解更难。这是因为我们不仅想返回<code class="fe nr ns nt ni b">pipeline()</code>的结果，还想返回一个正在处理的路径。当我们需要将结果与输入联系起来时，这是一种常见的情况。在这里，我们通过返回一个包含两个条目的元组来实现这个目的，<code class="fe nr ns nt ni b">(path, pipeline(path))</code>，基于这些元组，我们可以创建一个包含<code class="fe nr ns nt ni b">path-pipeline(path)</code>键-值对的字典。将<code class="fe nr ns nt ni b">lambda</code> s和<code class="fe nr ns nt ni b">map()</code>一起使用是一种常见的方法——但不一定是最清晰的方法。</p><p id="3ba6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，如果我们不需要路径名，代码会简单得多，因为我们唯一需要的是<code class="fe nr ns nt ni b">pipeline(path)</code>的结果:</p><pre class="kj kk kl km gt nh ni nj bn nk nl bi"><span id="e552" class="nm lx it ni b be nn no l np nq">pipeline_gen = map(pipeline, file_paths)</span></pre><p id="3706" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，由于我们需要添加路径名，所以我们使用了<code class="fe nr ns nt ni b">lambda</code>函数。产生的代码，带有<code class="fe nr ns nt ni b">lambda</code>的那个，看起来不太吸引人，不是吗？幸运的是，有一个很好的简单技巧来简化对使用<code class="fe nr ns nt ni b">lambda</code> s的<code class="fe nr ns nt ni b">map()</code>的调用。我们可以使用包装函数来代替:</p><pre class="kj kk kl km gt nh ni nj bn nk nl bi"><span id="6ee4" class="nm lx it ni b be nn no l np nq">def evaluate_pipeline(path):<br/>    return path, pipeline(path)<br/><br/>if __name__ == "__main__":<br/>    start = time.perf_counter()<br/>    pipeline_gen = map(evaluate_pipeline, file_paths)<br/>    results = dict(pipeline_gen)<br/>    print(f"Elapsed time: {round(time.perf_counter() - start, 2)}")<br/>    print(results)</span></pre><p id="b6b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的<code class="fe nr ns nt ni b">map</code>对象产生一个二元元组的生成器<code class="fe nr ns nt ni b">(path, pipeline(path))</code>。我们可以使用<code class="fe nr ns nt ni b">dict(pipeline_gen)</code>来</p><ul class=""><li id="1008" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">评估发电机，以及</li><li id="6ae5" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">将结果转换成由<code class="fe nr ns nt ni b">path</code> - <code class="fe nr ns nt ni b">pipeline(path)</code>键值对组成的字典。</li></ul><p id="460e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">难道你不同意这段代码比带有<code class="fe nr ns nt ni b">lambda</code>的版本可读性更强，更容易理解吗？</p><p id="7d99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对了，如果你想知道生成器管道在哪里，就在这里:<code class="fe nr ns nt ni b">map(evaluate_pipeline, file_paths)</code>。我们使用<code class="fe nr ns nt ni b">dict()</code>函数对其进行评估。</p><h2 id="f5da" class="nu lx it bd ly nv nw dn mc nx ny dp mg li nz oa mi lm ob oc mk lq od oe mm of bi translated">为什么我们谈论map()这么多？！</h2><p id="55bd" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">你可能想知道为什么我如此关注<code class="fe nr ns nt ni b">map()</code>函数。这是怎么回事？我们不应该讨论并行化吗？</p><p id="dce0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该这样做——我们确实这样做了。为了并行化你的代码，你需要首先理解<code class="fe nr ns nt ni b">map()</code>是如何工作的。这是因为你经常会使用与<code class="fe nr ns nt ni b">map()</code>非常相似的函数；事实上，这个功能经常被称为<code class="fe nr ns nt ni b">map</code>。因此，每当您考虑并行化您的代码时，不要使用<code class="fe nr ns nt ni b">for</code>循环、生成器表达式、列表理解、字典理解、集合理解等——考虑使用<code class="fe nr ns nt ni b">map()</code>函数。</p><p id="5b0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我在关于<code class="fe nr ns nt ni b">map()</code>(科萨克2022)的<em class="lv">数据科学</em>文章中所写的，这个函数被许多并行化模块和技术使用，它们的<code class="fe nr ns nt ni b">map()</code>版本与内置的<code class="fe nr ns nt ni b">map()</code>函数非常相似。因此，如果您计划并行化代码，从一开始就使用<code class="fe nr ns nt ni b">map()</code>通常是好的。不是必须的；只是一个建议。这样，当并行化代码时，您可以节省一些时间。</p><p id="1a18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，也许从一个<code class="fe nr ns nt ni b">map()</code>版本开始更好，甚至不用考虑是否将代码并行化？另一方面，<code class="fe nr ns nt ni b">map()</code>有时比相应的生成器表达式可读性差；但是你可以使用一个包装函数，基于<code class="fe nr ns nt ni b">map()</code>的代码应该变得非常可读。</p><p id="7de8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不会告诉你哪个设计是最好的。有时，<code class="fe nr ns nt ni b">map()</code>将是完美的解决方案——尤其是当您计划并行化代码时。重要的一点是，永远要小心。代码可读性很重要，但并不总是简单明了的。没有单一的配方。用你的技能和经验来决定。</p><p id="5293" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果您决定用最流行的并行化包之一来并行化代码，您通常会使用类似于<code class="fe nr ns nt ni b">map()</code>的函数。所以，不要忽略内置的<code class="fe nr ns nt ni b">map()</code>功能。明天，它可能会成为你比你今天想象的更亲密的朋友。</p><h1 id="ff3b" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">行动的并行化</h1><p id="a342" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在我们已经使用了<code class="fe nr ns nt ni b">map()</code>，我们的代码已经准备好被并行化了。为此，让我们使用<code class="fe nr ns nt ni b"><a class="ae ky" href="https://docs.python.org/3/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank">multiprocessing</a></code>，用于并行化的标准库模块:</p><pre class="kj kk kl km gt nh ni nj bn nk nl bi"><span id="f7c0" class="nm lx it ni b be nn no l np nq">import multiprocessing</span></pre><p id="9a6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在大多数情况下，这可能是一个好主意。然而，我们需要记住，其他模块可以提供更好的性能。我希望在其他文章中写他们。</p><p id="5ddf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的名称-主块现在变成了:</p><pre class="kj kk kl km gt nh ni nj bn nk nl bi"><span id="5ded" class="nm lx it ni b be nn no l np nq">if __name__ == "__main__":<br/>    start = time.perf_counter()<br/>    with mp.Pool(4) as p:<br/>        pipeline_gen = dict(p.map(evaluate_pipeline, file_paths))<br/>    print(f"Elapsed time: {round(time.perf_counter() - start, 2)}")<br/>    print(results)</span></pre><p id="22da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">四核，仅4.0秒！(使用8名工人，耗时2.65秒。)好看；我们看到<code class="fe nr ns nt ni b">multiprocessing</code>像预期的那样工作。</p><p id="7e23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们不需要对代码做太多修改，只需要做两处修改:</p><ul class=""><li id="25ea" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated"><code class="fe nr ns nt ni b">with mp.Pool(4) as p:</code>:为<code class="fe nr ns nt ni b">mp.Pool</code>使用上下文管理器是一个很好的规则，因为您不需要记住关闭池。我选择了4个工人，这意味着该流程将在四个流程中运行。如果您不想对工作人员的数量进行硬编码，可以用不同的方式来实现，如下所示。我使用了<code class="fe nr ns nt ni b">mp.cpu_count()-1</code>,这样我们的应用程序就不会触及一个进程；<code class="fe nr ns nt ni b">mp.cpu_count()</code>返回要使用的内核数量。我有4个物理核和8个逻辑核，<code class="fe nr ns nt ni b">mp.cpu_count()</code>返回8。</li></ul><pre class="kj kk kl km gt nh ni nj bn nk nl bi"><span id="5908" class="nm lx it ni b be nn no l np nq">workers = mp.cpu_count() - 1<br/>with mp.Pool(workers) as p:</span></pre><ul class=""><li id="0bcd" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated"><code class="fe nr ns nt ni b">p.map(evaluate_pipeline, file_paths)</code>:我们所做的唯一改变是将<code class="fe nr ns nt ni b">map()</code>改为<code class="fe nr ns nt ni b">p.map()</code>。还记得我告诉过你使用<code class="fe nr ns nt ni b">map()</code>会使代码并行化更容易吗？给你，这是这点零钱。然而，不要忘记<code class="fe nr ns nt ni b">p.map()</code>并不像<code class="fe nr ns nt ni b">map()</code>那样懒洋洋地求值，而是贪婪地(立即)求值。因此，它不返回生成器；相反，它返回一个列表。</li></ul><h1 id="b8f3" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">一个更简单的例子</h1><pre class="kj kk kl km gt nh ni nj bn nk nl bi"><span id="a635" class="nm lx it ni b be nn no l np nq">import multiprocessing as mp<br/>import random<br/>import time<br/><br/>def some_calculations(x: float) -&gt; float:<br/>    time.sleep(.5)<br/>    # some calculations are done<br/>    return x**2<br/><br/>if __name__ == "__main__":<br/>    x_list = [random.random() for _ in range(20)]<br/>    with mp.Pool(4) as p:<br/>        x_recalculated = p.map(some_calculations, x_list)</span></pre><p id="5f3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样—这个脚本使用并行计算为<code class="fe nr ns nt ni b">x_list</code>运行<code class="fe nr ns nt ni b">some_calcualations()</code>。这是一段非常简单的Python代码，不是吗？在这样一个简单的情况下，当您想要使用并行计算时，您可以随时返回到它。</p><p id="79b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一件好事是，如果您想运行更多的并行计算，您可以为<code class="fe nr ns nt ni b">mp.Pool</code>使用另一个这样的上下文管理器。</p><h1 id="1b18" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结论</h1><p id="0405" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我承诺向您展示Python中的并行化可以很简单。第一个例子是一个应用程序的原型，它有点复杂，就像现实生活中的应用程序一样。但是请注意，代码的并行部分非常短，相当简单。第二个例子强化了这一点。完整的代码只有十几行——而且是简单的代码。</p><p id="613f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使在简单的情况下，也不要害怕使用并行化。当然，只在需要的时候使用。当你不需要让你的代码更快时，使用它是没有意义的。请记住，当要并行调用的函数非常快时，您可能会使您的应用程序变慢，因为并行化不是没有代价的；这一次，成本是创建并行后端的开销。</p><p id="7635" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我展示了Python中的并行化可以很简单，但是您可以用它做更多的事情。我将在下一篇文章中讨论这个问题。如果你不想将你的知识局限于这些基础知识，Micha Gorelick和Ian Ozsvald的书(2020)是一个非常好的来源——虽然不是一个简单的来源，因为作者讨论了相当高级的主题。</p><p id="3289" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并不总是最好的方法。有时使用其他工具会更好。有<code class="fe nr ns nt ni b"><a class="ae ky" href="https://pathos.readthedocs.io/en/latest/pathos.html" rel="noopener ugc nofollow" target="_blank">pathos</a></code>，有<code class="fe nr ns nt ni b"><a class="ae ky" href="https://docs.ray.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank">ray</a></code>，还有其他工具。有时，您的环境会促使您选择并行化后端。例如，在AWS SageMaker中，您将需要使用<code class="fe nr ns nt ni b">ray</code>。这个计划比<code class="fe nr ns nt ni b">multiprocessing</code>提供的要多得多，我也会试着写一篇关于这个的文章。</p><p id="7bec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天到此为止。感谢阅读。如果您对Python中的并行化感到害怕，我希望您不会再有这种感觉了。亲自尝试一下，注意基本并行化是多么容易。当然，还有更多，但是让我们一步一步地学习。今天，你知道了没有理由害怕它，最基本的是…基本而简单。</p><p id="87fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我没有涉及技术细节，比如并行化代码的其他方式而不是池、命名和其他类似的事情。我只是想告诉你如何去做，以及有多简单。我希望我成功了。</p><p id="d0a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您阅读本文，请在评论中分享您对并行化的想法。我很乐意阅读您的首次尝试故事:您对并行化的首次尝试是什么？你并行了什么？你有什么问题吗？它像你期望的那样工作吗？你对它的工作方式满意吗？</p><h1 id="b693" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">资源</h1><ul class=""><li id="cf09" class="mt mu it lb b lc mo lf mp li og lm oh lq oi lu my mz na nb bi translated">科萨克米(2022)。用Python构建生成器管道。</li><li id="c180" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">布拉特B. (2017)。纳博科夫最喜欢的词是紫红色:数字揭示的经典、畅销书和我们自己的作品。西蒙和舒斯特。</li><li id="9b2b" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/does-python-still-need-the-map-function-96787ea1fb05">科萨克米(2022)。Python还需要map()函数吗？</a></li><li id="db64" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><code class="fe nr ns nt ni b"><a class="ae ky" href="https://docs.python.org/3/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank">multiprocessing</a></code> <a class="ae ky" href="https://docs.python.org/3/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank">模块文档</a>。</li><li id="3fc4" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">Gorelick M .，Ozsvald I. (2020年)。<em class="lv">高性能Python:人类实用的高性能编程</em>。第二版。奥莱利媒体。</li><li id="cb10" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><code class="fe nr ns nt ni b"><a class="ae ky" href="https://pathos.readthedocs.io/en/latest/pathos.html" rel="noopener ugc nofollow" target="_blank">pathos</a></code> <a class="ae ky" href="https://pathos.readthedocs.io/en/latest/pathos.html" rel="noopener ugc nofollow" target="_blank">模块文档</a>。</li><li id="e5f2" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><code class="fe nr ns nt ni b"><a class="ae ky" href="https://docs.ray.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank">ray</a></code> <a class="ae ky" href="https://docs.ray.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank">模块文档</a>。</li></ul></div></div>    
</body>
</html>