<html>
<head>
<title>REST APIs on Industrial PLCs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">工业PLC上的REST APIs</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/rest-apis-on-industrial-plcs-eb17e8c4d51b#2022-05-27">https://towardsdatascience.com/rest-apis-on-industrial-plcs-eb17e8c4d51b#2022-05-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fc0e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">扩展PLC的功能以执行几乎任何任务</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/62a13400ed5164cfc0d8e5f6b4fef589.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o4RVmdw1sbGJtGsHF4Rp1A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">与REST API的通信，作者的图像</p></figure><h2 id="5a7f" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">介绍</h2><p id="de6f" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">API允许两个不同应用程序之间的简单接口，在本文中，Python <a class="ae mn" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank"> REST API </a>的基本实现将用于管理来自PLC的各种SQL命令。</p><p id="159d" class="pw-post-body-paragraph lu lv it lw b lx mo ju lz ma mp jx mc lh mq me mf ll mr mh mi lp ms mk ml mm im bi translated">在这个例子中，数据将从连接到MP3300iec控制器的适马-7伺服驱动器网络中采样。这些数据将用于训练和评估一个<a class="ae mn" rel="noopener" target="_blank" href="/anomaly-detection-on-servo-drives-f711f3e6022f">异常检测</a>模型，该模型将在类似配置的机器网络中使用。出于这个原因，一个好的设计应该是有一个中央服务器与所有这些机器通信，存储所有数据，计算模型的权重，并将权重实时分配回控制器。</p><h2 id="eaed" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">动机</h2><p id="a03a" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">通过REST API与Python应用程序通信，任何不可能在PLC上运行的东西现在都可以在本地服务器上运行，并将结果返回给PLC。这允许昂贵的计算过程与控制器一起实时运行。例如，如果在控制器上与其他进程和任务一起运行，具有几十万或几百万个参数的大型机器学习模型可能会导致看门狗错误或cpu负载问题。有两个直接的解决方案:</p><ol class=""><li id="6bd1" class="mt mu it lw b lx mo ma mp lh mv ll mw lp mx mm my mz na nb bi translated">缩小机器学习模型的规模</li><li id="a509" class="mt mu it lw b lx nc ma nd lh ne ll nf lp ng mm my mz na nb bi translated">在不同的硬件上运行计算</li></ol><p id="0a75" class="pw-post-body-paragraph lu lv it lw b lx mo ju lz ma mp jx mc lh mq me mf ll mr mh mi lp ms mk ml mm im bi translated">在某些情况下，选项1可以很好地工作，但是，模型的准确性可能会受到影响。有些应用可能会损失精度，但其他要求更高精度的应用可能需要选项2。</p><p id="5873" class="pw-post-body-paragraph lu lv it lw b lx mo ju lz ma mp jx mc lh mq me mf ll mr mh mi lp ms mk ml mm im bi translated">除了将计算负载分配给另一个设备，REST API对于执行控制器不常见的动作也很有用。一些示例可能包括:跟踪订单或库存、从第三方应用程序获取信息或与外部网络通信。</p><p id="1512" class="pw-post-body-paragraph lu lv it lw b lx mo ju lz ma mp jx mc lh mq me mf ll mr mh mi lp ms mk ml mm im bi translated">虽然可以直接从控制器与第三方应用程序进行通信，但使用给定应用程序作者提供的预建库和存储库进行通信要容易得多。随着Python和其他现代编程语言的流行，有许多库和工具可以为您完成繁重的工作。使用REST API允许您这样做，以及流程所需的任何额外的定制操作。</p><h2 id="a92d" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">REST API</h2><p id="da92" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">API将在位于与所有控制器相关联的本地网络内的服务器上运行。Python的Flask模块用于创建所有用于数据处理的端点。定义的第一个端点将用于向数据库添加数据点，如下所示:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="1921" class="ky kz it ni b gy nm nn l no np"><a class="ae mn" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/add_row', methods=['POST'])<br/>def add_row():<br/>    row_data = request.data<br/>    if insert_sql_row(data):<br/>        return json.dumps({'statusCode': 200, 'data': 'Success'})<br/>    else:<br/>        return json.dumps({'statusCode': 400, 'data': 'Error'})</span><span id="d99c" class="ky kz it ni b gy nq nn l no np">def insert_sql_row(row_data) -&gt; bool:<br/>    try:<br/>        database = mysql.connector.connect(<br/>            host = 'localhost',<br/>            user = 'admin',<br/>            password = 'password'<br/>        )<br/>        cursor = database.cursor()</span><span id="c507" class="ky kz it ni b gy nq nn l no np">        sql_statement = 'INSERT INTO table_name VALUES ('<br/>        for value in row_data:<br/>            sql_statement = f'{sql_statement},{value}'<br/>        sql_statement = f'{sql_statement})'</span><span id="eeb4" class="ky kz it ni b gy nq nn l no np">        cursor.execute(sql_statement)<br/>        database.commit()<br/>        cursor.close()<br/>        database.close()<br/>        return True<br/>    except:<br/>        return False</span></pre><p id="3adb" class="pw-post-body-paragraph lu lv it lw b lx mo ju lz ma mp jx mc lh mq me mf ll mr mh mi lp ms mk ml mm im bi translated">上面代码中的几个关键项目:</p><ul class=""><li id="2704" class="mt mu it lw b lx mo ma mp lh mv ll mw lp mx mm nr mz na nb bi translated"><strong class="lw iu"> /add_row端点:</strong>这是当控制器希望向数据库添加一行数据时将使用的端点。</li><li id="847e" class="mt mu it lw b lx nc ma nd lh ne ll nf lp ng mm nr mz na nb bi translated"><strong class="lw iu"> request.get_data(): </strong>这将返回与请求相关的数据，该数据包含要输入数据库的采样值行，以及与网络请求相关的其他信息</li><li id="066b" class="mt mu it lw b lx nc ma nd lh ne ll nf lp ng mm nr mz na nb bi translated"><strong class="lw iu"> mysql.connector: </strong>这是用来连接和查询sql数据库的模块。</li></ul><p id="deea" class="pw-post-body-paragraph lu lv it lw b lx mo ju lz ma mp jx mc lh mq me mf ll mr mh mi lp ms mk ml mm im bi translated">定义的下一个端点将用于从数据库中检索异常检测模型。模型权重将存储在不同的表中，这反映在下面的代码中:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="6f4d" class="ky kz it ni b gy nm nn l no np"><a class="ae mn" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/retrieve_model', methods=['GET'])<br/>def retrieve_model():<br/>    model_id = request.data<br/>    return json.dumps(<br/>                       {'statusCode': 200, <br/>                        'data': str(retrieve_sql_row(model_id))<br/>                       }<br/>                      )</span><span id="8427" class="ky kz it ni b gy nq nn l no np">def retrieve_sql_row(model_id):<br/>    try:<br/>        database = mysql.connector.connect(<br/>            host = 'localhost',<br/>            user = 'admin',<br/>            password = 'password'<br/>        )<br/>        cursor = database.cursor()<br/>        cursor.execute(f'SELECT * FROM ml_model_table <br/>                          WHERE model_id="{model_id}"'<br/>                       )<br/>        row = cursor.fetchone()<br/>        cursor.close()<br/>        database.close()<br/>        return row if row else []<br/>    except:<br/>        return []</span></pre><h2 id="ce60" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">与API通信</h2><p id="a221" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">控制器通过TCP套接字发送的HTTP请求与API通信。对于将异常检测模型权重返回给客户端的基本GET命令，可以使用以下字符串:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="9fb4" class="ky kz it ni b gy nm nn l no np">GET /retrieve_model HTTP/1.1</span></pre><p id="f74b" class="pw-post-body-paragraph lu lv it lw b lx mo ju lz ma mp jx mc lh mq me mf ll mr mh mi lp ms mk ml mm im bi translated">字符串的第一部分<em class="ns"> ('GET') </em>表示被请求的REST方法的类型，字符串的第二部分<em class="ns"> ('/retrieve_model') </em>表示被请求的端点，字符串的最后一部分<em class="ns"> ('HTTP/1.1') </em>指定HTTP协议版本。</p><p id="33bd" class="pw-post-body-paragraph lu lv it lw b lx mo ju lz ma mp jx mc lh mq me mf ll mr mh mi lp ms mk ml mm im bi translated">当使用上面创建的数据存储端点时，上面的命令将被修改为:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="1fad" class="ky kz it ni b gy nm nn l no np">POST /add_row HTTP/1.1</span></pre><p id="4b8f" class="pw-post-body-paragraph lu lv it lw b lx mo ju lz ma mp jx mc lh mq me mf ll mr mh mi lp ms mk ml mm im bi translated">在PLC编程方面，已经创建了一个自定义功能块，用于处理发出这些命令所需的所有预处理和后处理。如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/55d289f1052f6cf8c13fb6725184b92c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zE-HcLsv7250kMCuGxFdCw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用于发出REST请求的功能块，由作者生成图像</p></figure><p id="df3e" class="pw-post-body-paragraph lu lv it lw b lx mo ju lz ma mp jx mc lh mq me mf ll mr mh mi lp ms mk ml mm im bi translated">“REST_API_1”功能块有以下输入:</p><ul class=""><li id="94e3" class="mt mu it lw b lx mo ma mp lh mv ll mw lp mx mm nr mz na nb bi translated"><strong class="lw iu">执行:</strong>发送命令并等待响应的布尔值</li><li id="bd25" class="mt mu it lw b lx nc ma nd lh ne ll nf lp ng mm nr mz na nb bi translated"><strong class="lw iu">端口:</strong>这是请求被发送到的服务器的端口号</li><li id="9081" class="mt mu it lw b lx nc ma nd lh ne ll nf lp ng mm nr mz na nb bi translated"><strong class="lw iu"> IPAddress: </strong>这是请求被发送到的服务器的IP地址</li><li id="be60" class="mt mu it lw b lx nc ma nd lh ne ll nf lp ng mm nr mz na nb bi translated"><strong class="lw iu"> LocalIP: </strong>这是发出请求的设备所分配的IP地址。</li><li id="3348" class="mt mu it lw b lx nc ma nd lh ne ll nf lp ng mm nr mz na nb bi translated">命令类型:这是被请求的REST命令的类型。</li><li id="0f07" class="mt mu it lw b lx nc ma nd lh ne ll nf lp ng mm nr mz na nb bi translated"><strong class="lw iu">数据:</strong>这是一个包含所有将被附加到请求的数据的结构</li></ul><p id="9a35" class="pw-post-body-paragraph lu lv it lw b lx mo ju lz ma mp jx mc lh mq me mf ll mr mh mi lp ms mk ml mm im bi translated">存在单一输出“ReceivedString”。这是服务器响应的字符串。在本例中，它将是一个JSON结构化响应，格式如下:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="0639" class="ky kz it ni b gy nm nn l no np">{'statusCode': 200, 'data': 'Success'}</span></pre><h2 id="a15b" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">例子</h2><p id="d8c2" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">该示例从运行将托管REST API的Flask服务器开始。上面“REST API”一节中的代码用于本例，日志显示服务器正在运行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/df3d5d4ff09105e2afe59e8850efc5ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*6mZjFdiN65PLauyZRO4mAQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Flask服务器初始化的输出日志，图片作者</p></figure><p id="de7d" class="pw-post-body-paragraph lu lv it lw b lx mo ju lz ma mp jx mc lh mq me mf ll mr mh mi lp ms mk ml mm im bi translated">在PLC程序中，在“REST_API_1”功能块上启用“执行”布尔，包含以下输入:</p><ul class=""><li id="ac5f" class="mt mu it lw b lx mo ma mp lh mv ll mw lp mx mm nr mz na nb bi translated">端口= 5000</li><li id="fe62" class="mt mu it lw b lx nc ma nd lh ne ll nf lp ng mm nr mz na nb bi translated">IP地址= 192.168.1.71</li><li id="0d21" class="mt mu it lw b lx nc ma nd lh ne ll nf lp ng mm nr mz na nb bi translated">LocalIP = 192.168.207.35</li><li id="d805" class="mt mu it lw b lx nc ma nd lh ne ll nf lp ng mm nr mz na nb bi translated">CommandType = 'GET '</li><li id="3588" class="mt mu it lw b lx nc ma nd lh ne ll nf lp ng mm nr mz na nb bi translated">data = { ' endpoint ':/retrieve _ model '，' model _ id ':' anomaly 7 ' }</li></ul><p id="c963" class="pw-post-body-paragraph lu lv it lw b lx mo ju lz ma mp jx mc lh mq me mf ll mr mh mi lp ms mk ml mm im bi translated">一旦服务器对请求做出响应,“ReceivedString”输出将收到以下输出:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="246e" class="ky kz it ni b gy nm nn l no np">{'statusCode': 200, 'data': [0.0291, 0.1253. 0.2843, 0.0112, 0.0895, 0.2001, 0.0013, 0.0984]}</span></pre><p id="b416" class="pw-post-body-paragraph lu lv it lw b lx mo ju lz ma mp jx mc lh mq me mf ll mr mh mi lp ms mk ml mm im bi translated">现在，控制器具有必要的权重，以利用来自服务器的更新的机器学习模型权重来运行异常检测。</p><h2 id="2d38" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h2><p id="7913" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">使用REST API是扩展PLC功能的一种简单方法。它允许控制器请求几乎任何类型的过程，并将计算卸载到另一个设备。使用Python的Flask是实现这一点的最简单和最容易的方法之一。</p><h2 id="a76e" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">参考</h2><p id="92a3" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">[1]维基媒体基金会。(2022年5月22日)。<em class="ns">具象状态转移</em>。维基百科。2022年5月25日检索，来自<a class="ae mn" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/representative _ state _ transfer</a></p><p id="1eb0" class="pw-post-body-paragraph lu lv it lw b lx mo ju lz ma mp jx mc lh mq me mf ll mr mh mi lp ms mk ml mm im bi translated">[2]维基媒体基金会。(2022年5月22日)。<em class="ns">可编程逻辑控制器</em>。维基百科。于2022年5月25日从<a class="ae mn" href="https://en.wikipedia.org/wiki/Programmable_logic_controller" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Programmable_logic_controller</a>检索</p><p id="4ffd" class="pw-post-body-paragraph lu lv it lw b lx mo ju lz ma mp jx mc lh mq me mf ll mr mh mi lp ms mk ml mm im bi translated">[3]列别德津斯基，P. (2021年11月12日)。<em class="ns">伺服驱动器上的异常检测。</em>中等。2022年5月12日检索，来自<a class="ae mn" rel="noopener" target="_blank" href="/anomaly-detection-on-servo-drives-f711f3e6022f">https://towards data science . com/a-single-number-metric-for-evaluating-object-detection-models-c97f 4a 98616d</a>。</p></div></div>    
</body>
</html>