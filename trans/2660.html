<html>
<head>
<title>1:length(A) considered harmful — or how to make Julia code “generic safe”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">1:长度(A)被认为是有害的——或者如何使Julia代码“通用安全”</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/1-length-a-considered-harmful-or-how-to-make-julia-code-generic-safe-ac7b39cfc2f0#2022-06-08">https://towardsdatascience.com/1-length-a-considered-harmful-or-how-to-make-julia-code-generic-safe-ac7b39cfc2f0#2022-06-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/dbb2e4be904320e5cb939e44d373bf47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CJcUJ3ezWVHWoUeg_Xzl3Q.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">照片由<a class="ae jd" href="https://unsplash.com/@ewitsoe?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">埃里克·维特索</a>在<a class="ae jd" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><div class=""/><div class=""><h2 id="0a2c" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">Julia允许在相当抽象和通用的层次上编写代码，因此提供了强大的表达能力。然而，这种优势也给程序员带来了特殊的挑战。这篇文章展示了如何克服它们。</h2></div><p id="40ec" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Julia的几个语言概念，如用户可扩展的类型系统、参数类型、可选的类型声明和多重分派，使得编写非常通用的代码成为可能，并且可以应用于许多情况——甚至代码的作者也经常无法预料的情况。这些可能性也是Julia高度可组合性的支柱。</p><p id="6d8f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一个明显的优势，也是很多人喜欢Julia胜过其他编程语言的原因之一。但是这是有代价的，因为它扩大了可能出错的范围。所以在编写这样的代码时必须特别小心。</p><p id="6f83" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您编写的Julia代码只是供自己使用，因此能够控制传递的参数以及代码如何与其他包组合，那么您就不需要太担心这些问题。但是如果你写的代码被其他人使用(特别是公开可用的包，比如Julia注册表中的包)，那么你需要记住这些方面。</p><p id="7d8e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我将给出三个常见的例子来展示这些挑战是怎样的，以及如何克服它们。这些信息中的大部分都可以在Julia文档中找到，但是我怀疑该语言的许多新手是否读过它们，因为在许多其他编程语言中，这些情况并不存在。那么，如果你不知道有一个问题，你为什么要去寻找答案呢？此外，最近关于话语的讨论表明，即使是经验丰富的Julia程序员有时也会落入这些陷阱。</p><h1 id="5474" class="lr ls jg bd lt lu lv lw lx ly lz ma mb km mc kn md kp me kq mf ks mg kt mh mi bi translated">数组</h1><p id="970d" class="pw-post-body-paragraph kv kw jg kx b ky mj kh la lb mk kk ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">让我们从Julia中最常见的数据结构之一开始:<code class="fe mo mp mq mr b">Array</code> s .(一维)数组乍一看与其他编程语言中的数组非常相似(可能除了索引是基于1的)。</p><p id="553d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以在<code class="fe mo mp mq mr b">Array</code>上使用一堆预定义的函数，例如<code class="fe mo mp mq mr b">length(A)</code>给你数组<code class="fe mo mp mq mr b">A</code>中包含的元素个数。这提供了迭代数组并以如下方式打印每个元素的可能性:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="2906" class="na ls jg mr b gy nb nc l nd ne">for i in 1:length(A)<br/>    println(A[i])<br/>end</span></pre><p id="2dd3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以找到另一种方法，使用函数<code class="fe mo mp mq mr b">eachindex(A)</code>返回<code class="fe mo mp mq mr b">A</code>的迭代器:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="f3d5" class="na ls jg mr b gy nb nc l nd ne">for i in eachindex(A)<br/>    println(A[i])<br/>end</span></pre><p id="7e92" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第二个版本看起来更优雅，但除此之外，两个版本似乎可以互换。…这就是问题开始的地方。</p><p id="1536" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">事实上，如果你使用(具体的)类型<code class="fe mo mp mq mr b">Array</code>的数组，这两种变体只有可以互换。<code class="fe mo mp mq mr b">Array</code>是<code class="fe mo mp mq mr b">AbstractArray</code>的一个亚型。如果你允许<code class="fe mo mp mq mr b">A</code>是<code class="fe mo mp mq mr b">AbstractArray</code>的任何其他子类型，你可能会遇到麻烦。<code class="fe mo mp mq mr b">AbstractArray</code>不保证第一个元素在索引1处，也不保证最后一个元素在索引<code class="fe mo mp mq mr b">length(A)</code>处。</p><blockquote class="ng"><p id="9d04" class="nh ni jg bd nj nk nl nm nn no np lq dk translated">因此<code class="fe mo mp mq mr b">1:length(A)</code>必须被视为有害。</p></blockquote><p id="d09a" class="pw-post-body-paragraph kv kw jg kx b ky nq kh la lb nr kk ld le ns lg lh li nt lk ll lm nu lo lp lq ij bi translated">如果您使用<code class="fe mo mp mq mr b">OffsetArrays</code>(另一个<code class="fe mo mp mq mr b">AbstractArray</code>的子类型)，您可以自由定义索引边界。以下语句创建一个包含11个(随机)元素的数组，索引从-5到5:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="8769" class="na ls jg mr b gy nb nc l nd ne">B = OffsetArray(rand(11), -5:5)</span><span id="93c1" class="na ls jg mr b gy nv nc l nd ne"><em class="nf">--&gt; 11-element OffsetArray(::Vector{Float64}, -5:5) <br/>    with eltype Float64 with indices -5:5</em></span></pre><p id="90b9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您应用<code class="fe mo mp mq mr b">1:length(B)</code>-变量进行索引，将会出现错误，因为在这种情况下将使用索引值&gt; 5。除此之外，索引不会从第一个元素开始，而是从第七个元素开始。</p><p id="e5ca" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一方面，<code class="fe mo mp mq mr b">eachindex(B)</code> -variant是安全的，因为它保证你得到一个迭代器，覆盖从第一个到最后一个的所有元素，不管数据结构使用哪种索引方式。</p><p id="5885" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您不需要索引值(如示例中的情况)，下面的变体也是安全的(因为它更简洁，所以是首选的):</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="2c07" class="na ls jg mr b gy nb nc l nd ne">for a in A<br/>    println(a)<br/>end</span></pre><h1 id="fd26" class="lr ls jg bd lt lu lv lw lx ly lz ma mb km mc kn md kp me kq mf ks mg kt mh mi bi translated">用线串</h1><p id="0c74" class="pw-post-body-paragraph kv kw jg kx b ky mj kh la lb mk kk ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">另一种常见的数据结构是<code class="fe mo mp mq mr b">String</code> s，在Julia中被定义为一系列<code class="fe mo mp mq mr b">Char</code> s。乍一看,<code class="fe mo mp mq mr b">String</code> s可以像字符数组一样使用(类似于Java或C)。所以要访问字符串<code class="fe mo mp mq mr b">s = "Hello"</code>中的第二个字符，你可以写<code class="fe mo mp mq mr b">c = s[2]</code>。该操作后，变量<code class="fe mo mp mq mr b">c</code>包含字母“e”。</p><p id="9970" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以使用<code class="fe mo mp mq mr b">s[3]</code>来访问<code class="fe mo mp mq mr b">s</code>中“e”后面的字符(本例中为“l”)。</p><p id="a45a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">只要<em class="nf">只使用</em> ASCII字符，这就可以工作。但是在Julia中，<code class="fe mo mp mq mr b">Char</code>可能是任何Unicode字符(UTF 8编码)。这些字符可能需要多于一个字节的存储空间(与纯ASCII字符相反)。</p><p id="e14c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于Unicode字符，上面的例子不再适用:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="0ea8" class="na ls jg mr b gy nb nc l nd ne">u = “α = alpha”    # string with a Unicode-character</span><span id="1e6a" class="na ls jg mr b gy nv nc l nd ne">u[1]     --&gt; 'α': Unicode U+03B1 (category Ll: Letter, lowercase)</span><span id="80b3" class="na ls jg mr b gy nv nc l nd ne">u[2]     --&gt; <strong class="mr jh">ERROR: </strong>StringIndexError: invalid index [2], <br/>             valid nearby indices [1]=&gt;'α', [3]=&gt;' '</span></pre><p id="0596" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mo mp mq mr b">u</code>(‘α’)中的第一个字母是一个(2字节)Unicode字符。因此<code class="fe mo mp mq mr b">u[2]</code>不是可打印字符(而是第一个字符的一部分)。</p><p id="1f6c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要安全地索引任意Unicode字符串，您需要以下函数:</p><ul class=""><li id="ad40" class="nw nx jg kx b ky kz lb lc le ny li nz lm oa lq ob oc od oe bi translated"><code class="fe mo mp mq mr b">firstindex(u)</code>—<code class="fe mo mp mq mr b">u</code>的最小指数</li><li id="71f2" class="nw nx jg kx b ky of lb og le oh li oi lm oj lq ob oc od oe bi translated"><code class="fe mo mp mq mr b">lastindex(u)</code>—<code class="fe mo mp mq mr b">u</code>的最大指数</li><li id="5b8f" class="nw nx jg kx b ky of lb og le oh li oi lm oj lq ob oc od oe bi translated"><code class="fe mo mp mq mr b">nextind(u, i)</code> —索引<code class="fe mo mp mq mr b">i</code>之后的下一个有效索引</li><li id="1aa8" class="nw nx jg kx b ky of lb og le oh li oi lm oj lq ob oc od oe bi translated"><code class="fe mo mp mq mr b">prevind(u, i)</code> —索引<code class="fe mo mp mq mr b">i</code>之前的前一个有效索引</li></ul><p id="bfe4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，要获得<code class="fe mo mp mq mr b">u</code>(‘α’)中的第一个字符，然后是‘α’后面的下一个字符，您应该使用:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="a7d5" class="na ls jg mr b gy nb nc l nd ne">i = firstindex(u)   --&gt; 1<br/>u[i]                --&gt; 'α': Unicode U+03B1 <br/>                        (category Ll: Letter, lowercase)</span><span id="ba55" class="na ls jg mr b gy nv nc l nd ne">i = nextind(u,i)    --&gt; 3<br/>u[i]                --&gt; ' ': ASCII/Unicode U+0020 <br/>                        (category Zs: Separator, space)</span></pre><p id="cbcd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了安全地迭代一个字符串的所有元素，下面的表达式完成了这项工作(只有当您想要在一个字符串内来回移动时，才需要上述函数):</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="9407" class="na ls jg mr b gy nb nc l nd ne">for c in u<br/>    println(c)<br/>end</span></pre><h1 id="a404" class="lr ls jg bd lt lu lv lw lx ly lz ma mb km mc kn md kp me kq mf ks mg kt mh mi bi translated">类型声明</h1><p id="398d" class="pw-post-body-paragraph kv kw jg kx b ky mj kh la lb mk kk ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">到目前为止，我们看到的两个例子处理的是您应该在适当的抽象级别上访问数据结构的情况。也就是说，对数据结构的访问不应该依赖于对其实现的知识或(更糟的)假设。</p><p id="05d1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下一个例子提出了另一个主题:关于类型声明的使用。</p><p id="f317" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在Julia中，类型声明是可选的，但它们有助于编译器生成最佳代码。编译器至少需要知道输入参数的具体类型，以便为算法生成高效的代码。基于这个起点，它可以推断出大多数情况下所有其他变量的类型。</p><p id="5ecb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一方面，您希望您的代码尽可能通用，以使其适用于广泛的情况。这两个要求相互冲突。</p><p id="0f77" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看一个例子来更清楚地说明这种情况。二维空间中的点的类型定义可能如下所示:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="3496" class="na ls jg mr b gy nb nc l nd ne">struct Point<br/>    x<br/>    y<br/>end</span></pre><p id="7bfe" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是这种定义的最一般的方式。但是通常我们希望在我们的<code class="fe mo mp mq mr b">Point</code>上定义依赖于一些算术函数的函数，如下例所示:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="1513" class="na ls jg mr b gy nb nc l nd ne">function distance(a::Point, b::Point)<br/>    sqrt((b.x - a.x)^2 + (b.y - a.y)^2)<br/>end</span></pre><p id="bcfb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了保证这些算术函数可用于<code class="fe mo mp mq mr b">x</code>和<code class="fe mo mp mq mr b">y</code>，我们必须将这些字段声明为<code class="fe mo mp mq mr b">Number</code>类型。这是最通用(即最不具体)的声明:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="b1b0" class="na ls jg mr b gy nb nc l nd ne">struct Point<br/>    x :: Number<br/>    y :: Number<br/>end</span></pre><p id="b2b5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以保持代码尽可能通用的需求通过<code class="fe mo mp mq mr b">Point</code>的定义得到了满足。但是对于编译器来说并不是真正有用的。</p><p id="e910" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当创建<code class="fe mo mp mq mr b">Point</code> s的实例时，我们可以使用<code class="fe mo mp mq mr b">Number</code>的任何子类型，如<code class="fe mo mp mq mr b">Int8</code>、<code class="fe mo mp mq mr b">Int64</code>、<code class="fe mo mp mq mr b">Int128</code>、<code class="fe mo mp mq mr b">Float16</code>、<code class="fe mo mp mq mr b">Float32</code>、<code class="fe mo mp mq mr b">Complex{Float32}</code>、<code class="fe mo mp mq mr b">Rational{Int64}</code>等。例如，如果我们想要用我们的<code class="fe mo mp mq mr b">Point</code>类型在屏幕上表示像素，那么<code class="fe mo mp mq mr b">x</code>和<code class="fe mo mp mq mr b">y</code>的<code class="fe mo mp mq mr b">Int32</code>值可能适合这个任务。为了对一些数学应用的点进行建模，我们可以使用<code class="fe mo mp mq mr b">Float64</code>来表示真实值。对于这两个用例，多边形(表示为点的向量)的定义是:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="863c" class="na ls jg mr b gy nb nc l nd ne">pixel_poly = Vector{Point}()</span><span id="0a42" class="na ls jg mr b gy nv nc l nd ne">real_poly  = Vector{Point}()</span></pre><p id="c449" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">两个表达式是相同的。这意味着编译器不知道在每种情况下需要什么样的内存表示，因此无法为该特定类型生成优化的代码。相反，它必须提供一个非常通用的结构，能够存储上述每个子类型。这样效率不高。</p><p id="a4d4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">解决这一冲突的方法是使用(受约束的)参数类型，如下所示:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="c30e" class="na ls jg mr b gy nb nc l nd ne">struct Point{T &lt;: Number}<br/>    x :: T<br/>    y :: T<br/>end</span></pre><p id="d37c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当创建一个<code class="fe mo mp mq mr b">Point</code>的实例时，使用参数类型<code class="fe mo mp mq mr b">T</code>仍然给了我们使用任何具体类型<code class="fe mo mp mq mr b">T</code>的自由。声明<code class="fe mo mp mq mr b">&lt;: Number</code>将可能的类型限制为<code class="fe mo mp mq mr b">Number</code>的子类型(同上)。</p><p id="8e24" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，如果我们需要一个特定的实例，我们现在也可以指定它的类型，并将多边形的两个定义写成:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="a90a" class="na ls jg mr b gy nb nc l nd ne">pixel_poly = Vector{Point{Int32}}()</span><span id="de76" class="na ls jg mr b gy nv nc l nd ne">real_poly  = Vector{Point{Float64}}()</span></pre><p id="54f6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用(受约束的)参数类型代替抽象类型满足了我们的两个要求:类型的广泛适用性和能够通知编译器在特定用例中需要的具体类型。</p><h1 id="1d4a" class="lr ls jg bd lt lu lv lw lx ly lz ma mb km mc kn md kp me kq mf ks mg kt mh mi bi translated">结论</h1><p id="ff2e" class="pw-post-body-paragraph kv kw jg kx b ky mj kh la lb mk kk ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">我们已经看到了编写泛型Julia代码的一些最常见的挑战，以及如何使其安全。</p><p id="9acf" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">前两个例子表明，您必须理解数据类型提供的抽象，并使用与该抽象级别匹配的函数来访问它:</p><ul class=""><li id="c286" class="nw nx jg kx b ky kz lb lc le ny li nz lm oa lq ob oc od oe bi translated"><code class="fe mo mp mq mr b">AbstractArray</code>表示(在一维情况下)可以使用索引访问的元素序列。但是它没有断言最小和最大索引。<br/>只有具体子类型<code class="fe mo mp mq mr b">Array</code>保证第一个索引为1，最后一个索引为<code class="fe mo mp mq mr b">length(A)</code>。</li><li id="0d0c" class="nw nx jg kx b ky of lb og le oh li oi lm oj lq ob oc od oe bi translated"><code class="fe mo mp mq mr b">String</code>表示一系列的<code class="fe mo mp mq mr b">Char</code>,但是它没有断言它们的大小相等。<br/>只有当您将应用程序限制为ASCII字符时，您才可以假定大小相等(一个字节)。</li></ul><p id="00f8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在所有这些情况下，Julia都提供了一组丰富的函数来以一种适当(并且安全)的方式处理数据结构。</p><p id="2572" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后一个示例演示了如何将类型声明与参数类型结合使用，以尽可能保持代码的通用性，同时为编译器提供足够的信息来生成最佳代码。</p><p id="545e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当然，这些并不是你必须小心这些问题的唯一情况。但我认为这些例子很有代表性，希望我能提高对这些挑战的认识。</p></div></div>    
</body>
</html>