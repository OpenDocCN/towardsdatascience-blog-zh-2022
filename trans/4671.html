<html>
<head>
<title>How to Boost Pandas Speed And Process 10M-row Datasets in Milliseconds</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何提高熊猫的速度，在几毫秒内处理1000万行数据集</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-boost-pandas-speed-and-process-10m-row-datasets-in-milliseconds-48d5468e269#2022-10-18">https://towardsdatascience.com/how-to-boost-pandas-speed-and-process-10m-row-datasets-in-milliseconds-48d5468e269#2022-10-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e1ec" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">按照预期的方式使用熊猫</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cba5e11bfec080109e91154f8eb52e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6nngRPSJom20r8Xg1wuW9A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/photo/a-fast-supercar-on-the-road-7702307/" rel="noopener ugc nofollow" target="_blank">supreme</a>拍摄</p></figure><h1 id="3cba" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="d26a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">"太好了…另一篇关于如何让熊猫速度提高n倍的文章."</p><p id="2015" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">我想我已经说过无数次了，在过去的两年里我一直在用熊猫。最近看到的一条说“让熊猫快71803倍”。</p><p id="1e57" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">但我不会给你这种承诺。我将向你展示如何以最快的方式使用熊猫。因为你不能加快已经很快的东西。没道理？</p><p id="2622" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">让我问你这个问题。当我说“摸摸你的右耳”时，你用哪只手当然，右手。把你的左手放在头上，你不会碰到你的右耳。那会很奇怪。</p><p id="ce91" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">嗯，使用这些函数，熊猫文档清楚地说明了慢而不是最快的方法，也会很奇怪。</p><p id="8901" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">这就是为什么本文将向您展示Pandas中一些最常见的数据操作的最佳实践。你甚至可以将这些最佳实践视为“常识”，因为这就是熊猫的创造者打算如何使用他的图书馆。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><p id="4532" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">获得由强大的AI-Alpha信号选择和总结的最佳和最新的ML和AI论文:</p><div class="na nb gp gr nc nd"><a href="https://alphasignal.ai/?referrer=Bex" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">阿尔法信号|机器学习的极品。艾总结的。</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">留在循环中，不用花无数时间浏览下一个突破；我们的算法识别…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">alphasignal.ai</p></div></div><div class="nm l"><div class="nn l no np nq nm nr ks nd"/></div></div></a></div></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="791c" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">高效索引</h1><p id="5bfc" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">先说最基础的操作。具体来说，我们将看到选择行和列的最快方法。如你所知，熊猫有两个索引操作符——<code class="fe nx ny nz oa b">loc</code>和<code class="fe nx ny nz oa b">iloc</code>。尽管它们的差异对于小数据集来说关系不大，但随着数据量的增加，它们会变得非常明显。</p><p id="c776" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">首先，对于选择一行或多行，<code class="fe nx ny nz oa b">iloc</code>更快。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="5135" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">相比之下，<code class="fe nx ny nz oa b">loc</code>最适合选择带有标签的列:</p><pre class="kj kk kl km gt od oa oe of aw og bi"><span id="c543" class="oh la it oa b gy oi oj l ok ol">&gt;&gt;&gt; tps.loc[:, ["f1", "f2", "f3"]]</span></pre><p id="8edd" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">对于采样列或行，内置的<code class="fe nx ny nz oa b">sample</code>函数是最快的。您可能认为通过NumPy使用随机索引进行采样会更快，但事实并非如此:</p><pre class="kj kk kl km gt od oa oe of aw og bi"><span id="5765" class="oh la it oa b gy oi oj l ok ol"># Sampling rows<br/>&gt;&gt;&gt; tps.sample(7, axis=0)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl om"><img src="../Images/4ef314b47959ea31fe17a6f8dc8483bd.png" data-original-src="https://miro.medium.com/v2/format:webp/1*zavT6QkaQhkTFy1xejPtOA.png"/></div></figure><pre class="kj kk kl km gt od oa oe of aw og bi"><span id="c00e" class="oh la it oa b gy oi oj l ok ol"># Sampling 5 columns and 7 rows<br/>&gt;&gt;&gt; tps.sample(5, axis=1).sample(7, axis=0)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl om"><img src="../Images/709fc4defa4db540b0a0cb7229ef67c2.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Jb8yoINERM21QqUYjL1DDg.png"/></div></figure></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="ef3c" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">有效替换值</h1><p id="6a9c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">大多数时候，我看到人们使用<code class="fe nx ny nz oa b">loc</code>或<code class="fe nx ny nz oa b">iloc</code>来替换数据帧中的特定值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="9ce3" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">的确，这种方法似乎是最快的，因为我们指定了要替换的值的确切位置，而不是让Pandas来搜索它。但是，这种方法很笨拙，而且没有<code class="fe nx ny nz oa b">replace</code>快:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="6c25" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">速度是<code class="fe nx ny nz oa b">replace</code>的第一个好处，其次是它的灵活性。上面，我们用<code class="fe nx ny nz oa b">NaN</code>替换了所有的问号——这是一个基于索引替换的多次调用操作。</p><p id="c03e" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">另外，<code class="fe nx ny nz oa b">replace</code>允许使用列表或字典同时改变多个值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="0bf2" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">当用一个值列表替换另一个值列表时，它们将具有一对一的索引到索引的映射。你可以更具体地使用字典，比如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="5405" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">使用嵌套字典可以更细化:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="4ae9" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">当您只想影响特定列的值时，嵌套替换会有所帮助。这里，我们只替换<code class="fe nx ny nz oa b">education</code>和<code class="fe nx ny nz oa b">income</code>列中的值。</p><p id="3d0a" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><code class="fe nx ny nz oa b">replace</code>还有其他好处，包括基于正则表达式的替换，这可以在<a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.replace.html" rel="noopener ugc nofollow" target="_blank">文档</a>中读到。</p><div class="na nb gp gr nc nd"><a href="https://ibexorigin.medium.com/membership" rel="noopener follow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">通过我的推荐链接加入Medium-bex boost</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">获得独家访问我的所有⚡premium⚡内容和所有媒体没有限制。支持我的工作，给我买一个…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">ibexorigin.medium.com</p></div></div><div class="nm l"><div class="on l no np nq nm nr ks nd"/></div></div></a></div></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="c483" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">高效迭代</h1><p id="b2dd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对整列或数据帧应用操作的黄金法则是<em class="mn">永远不要使用循环</em>。这是行之有效的陈词滥调。但是，我明白了——如何在不循环的情况下操作整个数组？</p><p id="be05" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">诀窍是开始将数组视为向量，将整个数据帧视为矩阵。毕竟ML模型就是这么接受数据的——说白了都是多变量<a class="ae ky" href="https://en.wikipedia.org/wiki/Vector-valued_function" rel="noopener ugc nofollow" target="_blank">向量值函数</a>。</p><p id="a1fe" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">从线性代数中，我们知道对向量的运算是对整个向量进行的，不管是乘法、加法等等。幸运的是，这种对数学向量进行操作的思想在Pandas和NumPy中实现为矢量化。</p><p id="bc95" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">因此，如果您想在一个或多个列上执行任何数学运算，很有可能该运算在Pandas中是矢量化的。例如，像+、-、*、/、**这样的内置Python操作符就像对向量一样工作。</p><p id="75a6" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">为了体验一下矢量化，让我们对大规模数据集执行一些操作。我们将选择<a class="ae ky" href="https://www.kaggle.com/c/tabular-playground-series-sep-2021/data" rel="noopener ugc nofollow" target="_blank"> Kaggle TPS九月竞赛</a>的约1M行数据集:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="c0f0" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">让我们用熊猫<code class="fe nx ny nz oa b">apply</code>函数对几列进行一些数学运算。那是熊猫最快的内置迭代器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="70b5" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">我们将用<code class="fe nx ny nz oa b">apply</code>在三列上运行这个函数，并检查运行时间:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="362b" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">1M行数据集为19.3秒。还不错。现在，看看当我们将列作为向量而不是标量传递时会发生什么。无需修改功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="3cef" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">37毫秒！这比最快的迭代器快了大约600倍。但是我们可以做得更好—在NumPy阵列上使用时，矢量化甚至更快:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="5c35" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">只需添加<code class="fe nx ny nz oa b">.values</code>即可获得熊猫系列的底层NumPy ndarray。NumPy数组速度更快，因为它们不像Pandas系列那样执行额外的索引调用和数据类型检查。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="b95d" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">让我们快速疯狂吧</h1><p id="de47" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们应该到此为止吗？熊猫还有一些锦囊妙计。不过，公平的警告是，除非你有超过100万行，否则这些不会给你带来太多好处。</p><p id="1d74" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">好了，我们开始吧。首先，我们将把数据集的大小增加十倍，给自己一个挑战:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="66db" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">大约9gb，这应该足够了。哦，顺便说一下，如果这种规模的数据集对你来说是一个问题，请查看我关于驯服这些野兽的文章:</p><div class="na nb gp gr nc nd"><a rel="noopener follow" target="_blank" href="/how-to-work-with-million-row-datasets-like-a-pro-76fb5c381cdd"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">如何像专家一样处理百万行数据集</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">编辑描述</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">towardsdatascience.com</p></div></div><div class="nm l"><div class="oo l no np nq nm nr ks nd"/></div></div></a></div><p id="8077" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">现在，我们将继续使用我们的<code class="fe nx ny nz oa b">crazy_function</code>，从NumPy矢量化作为基线开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="e4f5" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">对于10M行的数据集，大约0.3秒。当我用<code class="fe nx ny nz oa b">apply</code>试着这样做的时候，它甚至在一个小时内都没有完成。</p><p id="4009" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">现在，让我们进一步改进运行时。第一个候选人是农巴。我们通过pip ( <code class="fe nx ny nz oa b">pip install numba</code>)安装并导入它。然后，我们将用<code class="fe nx ny nz oa b">jit</code>功能来装饰我们的<code class="fe nx ny nz oa b">crazy_function</code>。JIT代表<em class="mn"> just in time，</em>它将纯Python和NumPy代码翻译成本机指令，从而大大提高了速度。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="5001" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">现在，我们像运行任何其他函数一样运行它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="33d5" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">我们实现了大约1.5倍的速度提升。请注意，Numba最适用于包含许多原生Python循环、大量数学运算的函数，甚至更好的是NumPy函数和数组。</p><blockquote class="op oq or"><p id="65eb" class="lr ls mn lt b lu mo ju lw lx mp jx lz os mq mc md ot mr mg mh ou ms mk ml mm im bi translated">Numba可以做得更多，包括并行计算和基于GPU的编译。查看<a class="ae ky" href="https://numba.pydata.org/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p></blockquote><p id="7730" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">如果你不在乎额外的依赖，我给你介绍一下熊猫的<code class="fe nx ny nz oa b">eval</code>功能。有两个版本- <code class="fe nx ny nz oa b">pd.eval</code>(更高级)和<code class="fe nx ny nz oa b">df.eval</code>(在数据帧的上下文中)。像Numba一样，您应该在数据帧中至少有+10，000个样本才能看到改进。但是一旦你这样做了，你将会看到速度上的巨大好处。</p><p id="dce3" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">让我们在<code class="fe nx ny nz oa b">df.eval</code>的上下文中运行我们的<code class="fe nx ny nz oa b">crazy_function</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="453b" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">没有矢量化或Numba快，但它有几个好处。首先，通过避免引用DataFrame名称，您编写的代码要少得多。接下来，它显著加快了对数据帧的非数学运算，如布尔索引、比较等等。</p><p id="f7ba" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">当你不做数学运算时，评估你在<code class="fe nx ny nz oa b">pd.eval</code>中的陈述。我建议从<a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/enhancingperf.html#expression-evaluation-via-eval" rel="noopener ugc nofollow" target="_blank">文档</a>中查看使用<code class="fe nx ny nz oa b">eval</code>的注意事项。</p><blockquote class="op oq or"><p id="adfe" class="lr ls mn lt b lu mo ju lw lx mp jx lz os mq mc md ot mr mg mh ou ms mk ml mm im bi translated">注意，即使对于10M行的数据集，我们也是在<strong class="lt iu">毫秒</strong>的范围内讨论。</p></blockquote></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="d299" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">包装</h1><p id="d282" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们讨论的大部分内容摘自Pandas文档中信息丰富的<a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/enhancingperf.html" rel="noopener ugc nofollow" target="_blank"> <em class="mn">提高速度</em> </a>部分。我们已经涵盖了最重要和最有效的方法，忽略了小细节。我强烈建议你通过它来获得更多的速度提示。</p><div class="na nb gp gr nc nd"><a href="https://ibexorigin.medium.com/membership" rel="noopener follow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">通过我的推荐链接加入Medium-bex boost</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">获得独家访问我的所有⚡premium⚡内容和所有媒体没有限制。支持我的工作，给我买一个…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">ibexorigin.medium.com</p></div></div><div class="nm l"><div class="on l no np nq nm nr ks nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://ibexorigin.medium.com/subscribe" rel="noopener follow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">每当BEXBoost发布时收到电子邮件。</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">每当BEXBoost发布时收到电子邮件。通过注册，您将创建一个中型帐户，如果您还没有…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">ibexorigin.medium.com</p></div></div><div class="nm l"><div class="ov l no np nq nm nr ks nd"/></div></div></a></div></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><div class="kj kk kl km gt nd"><a rel="noopener follow" target="_blank" href="/a-complete-shap-tutorial-how-to-explain-any-black-box-ml-model-in-python-7538d11fae94"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">完整的SHAP教程:如何用Python解释任何黑盒ML模型</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">向非技术人员解释任何黑盒模型</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">towardsdatascience.com</p></div></div><div class="nm l"><div class="ow l no np nq nm nr ks nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a rel="noopener follow" target="_blank" href="/3-step-feature-selection-guide-in-sklearn-to-superchage-your-models-e994aa50c6d2"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">Sklearn中的3步功能选择指南，让您的模型焕然一新</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">为任何受监督的问题开发一个健壮的特征选择工作流</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">towardsdatascience.com</p></div></div><div class="nm l"><div class="ox l no np nq nm nr ks nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a rel="noopener follow" target="_blank" href="/how-to-use-umap-for-much-faster-and-effective-outlier-detection-e4608f336915"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">如何使用UMAP进行更快更有效的异常检测</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">让我们抓住那些高维离群值</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">towardsdatascience.com</p></div></div><div class="nm l"><div class="oy l no np nq nm nr ks nd"/></div></div></a></div></div></div>    
</body>
</html>