<html>
<head>
<title>Improve your time series analysis with stochastic and deterministic components decomposition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用随机和确定性成分分解改进时间序列分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/improve-your-time-series-analysis-with-stochastic-and-deterministic-components-decomposition-464e623f8270#2022-02-15">https://towardsdatascience.com/improve-your-time-series-analysis-with-stochastic-and-deterministic-components-decomposition-464e623f8270#2022-02-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3ae7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何将时间序列分解成可以用动力系统和随机过程方法预测的部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e4fa02eddf4f0debb50f0a21d973c769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VhmvXkMaB1GQJLZu"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@m_____me?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> m. </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="353f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://medium.com/towards-data-science/time-series-forecasting-with-dynamical-systems-methods-fa4afdf16fd0" rel="noopener">我的上一篇文章</a>中，我谈到了如何使用Taken的嵌入定理，通过标准的机器学习算法来预测确定性的时间序列数据。</p><p id="b7d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在那篇文章中没有谈到的是，如果我们正在处理的序列不是完全确定的，我们可以做什么。正如我们在文章中看到的，当系列出现一些噪音时，预测的质量会下降很多。</p><p id="3db7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将分析并实现论文“<a class="ae kv" href="https://www.sciencedirect.com/science/article/abs/pii/S0165168415002297?via%3Dihub" rel="noopener ugc nofollow" target="_blank">的结果，该论文应用经验模式分解和互信息来分离嵌入信号</a>【1】中的随机和确定性影响，该论文提出了一个框架，在给定时间序列的情况下，将其分解为随机和确定性成分。</p><p id="8cae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">能够生成这种分解将提高我们利用图克嵌入定理所能实现的预测，并且还将允许我们单独对随机分量建模。</p><p id="cfc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的主要思想是分析由应用于时间序列的经验模式分解方法产生的IMFs的相位谱。让我们来理解这意味着什么，以及我们如何将它应用到现实世界的问题中。</p><h2 id="39fa" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">经验模态分解</h2><p id="8f5e" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">第一步是把我们的时间序列分成所谓的固有模态函数(IMF)。为此，我们将使用一种称为经验模式分解(EMD)的方法，它将接收一个时间序列作为输入，并从中生成IMF。</p><p id="afad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但什么是国际货币基金组织？</p><p id="f4b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">IMF本身是一个时间序列，它满足两个条件:</p><ul class=""><li id="1c30" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">序列的最大值和最小值之间的差值绝对不能大于1</li><li id="03de" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">IMF的平均值必须为零</li></ul><p id="3c88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">EMD将通过应用以下算法来生成这些IMF:</p><ul class=""><li id="27f6" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">找出数列的所有最大值和最小值</li><li id="7f88" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">使用三次样条插值它们，生成我们所说的包络。对于计算机科学的人来说，你可以把它看作是大O和大ω函数</li><li id="4bc2" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">计算这个包络的平均值，并从中减去原始信号</li></ul><p id="fd25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在这个图上看到我所说的上述过程的意思:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/81e2b55904d1f8127a5d34f9c3aed96b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SNCP2EDKRZhtdRVoYWzyow.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">基于EMD方法的包络创建。由作者生成的图像</p></figure><p id="6af4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们从平均值中减去原始时间序列后获得的这个新信号将被测试，以验证它是否是一个IMF。如果一个或多个条件不满足，那么算法将重复自身，但是这次是在这个新的候选上而不是在原始的时间序列上。直到我们找到一个国际货币基金组织。</p><p id="e102" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦找到一个IMF，就从这个IMF中减去原始时间序列，产生一个新的信号，我们称之为h。然后，我们将对h重复整个过程，直到找到下一个IMF，然后从h中减去，依此类推。</p><p id="53fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只有当我们找到一个单调的序列(即，它只增长或减少)，或者换句话说，一个只有一个极值点(最大值或最小值)的序列时，这个过程才会停止。这一系列将被称为剩余。</p><h2 id="abe8" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">解释IMFs并编码</h2><p id="8db6" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">由于这个过程是如何完成的，人们可以很容易地看到，如果我们得到所有的IMF和残差，并将它们相加，我们将得到原始序列。</p><p id="08fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么我们称这种方法为“分解”。我们正在将我们的系列分解成一组组件。除此之外，第一个IMF将包含噪声最大的信号，而后面的IMF将呈现更具确定性的成分，如下所示。</p><p id="4ab2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们把它编码起来。为此，我们需要安装一个已经实现了EMD的库，名为PyEMD。我们可以通过pip轻松做到这一点:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="2ea2" class="ls lt iq ng b gy nk nl l nm nn">pip install EMD-signal</span></pre><p id="f1bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还将使用sknet库中的一些免费数据集和sklearn库中的一个函数，因此我们也必须安装它们:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="a62f" class="ls lt iq ng b gy nk nl l nm nn">pip install scikit-learn<br/>pip install sktime</span></pre><p id="69b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们创建一个函数，它将返回给定信号的IMFs:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="9262" class="ls lt iq ng b gy nk nl l nm nn">import numpy as np<br/>from scipy.fft import fft<br/>import matplotlib.pyplot as plt</span><span id="40a1" class="ls lt iq ng b gy no nl l nm nn">from PyEMD import EMD<br/>from sktime.datasets import load_airline, load_shampoo_sales<br/>from sklearn.feature_selection import mutual_info_regression</span><span id="70d3" class="ls lt iq ng b gy no nl l nm nn">def emd(signal):<br/>    emd = EMD(DTYPE=np.float16, spline_kind='akima')<br/>    imfs = emd(signal.values)<br/>    <br/>    t = [i for i in range(len(signal))]<br/>    N = imfs.shape[0]<br/>    fig, axs = plt.subplots(N + 1, 1, figsize=(15,9))</span><span id="7d0a" class="ls lt iq ng b gy no nl l nm nn">    axs[0].plot(t, signal)<br/>    axs[0].set_title('Original Signal')<br/>    for n, imf in enumerate(imfs):<br/>        axs[n+1].plot(t, imf)<br/>        axs[n+1].set_title(f'IMF {n}')<br/>    <br/>    return imfs</span></pre><p id="7b8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个函数中，我们只是从PyEMD库中调用EMD，并将它们与原始数据一起绘制。让我们将它应用到来自sktime的航空公司数据[2]中，这是我们可以免费使用的，看看会发生什么:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/11a4b57a23391733fefac3c6f87587ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JI6oM61n5U2svxyHTf4O-A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">航线数据集的EMD分解[3]。图片由作者生成。</p></figure><p id="7947" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以看到IMF 3实际上表现得像一个残渣。</p><p id="c826" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了自己的国际货币基金组织，我们能用它们做什么？它们对我们如何区分时间序列中的随机成分和确定成分有用？</p><h2 id="cfd6" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">相位谱</h2><p id="8b67" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">生成IMF后，我们可以分析这些元件在频谱上的表现。一个随机信号的频谱到处都是，没有清晰的频率。另一方面，确定性信号会表现得更好。</p><p id="9805" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一种直观的方法是在频率空间上观察这些成分的相位谱。为此，我们必须首先通过快速傅里叶变换(FFT)获得IMF的频率表示，然后用虚部除以实部。</p><p id="0de9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们将从那个阶段的角度来看，这将使我们更容易看到发生了什么。为此，我们必须应用反正切函数。</p><p id="ed72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看这在代码中是什么样子的:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="3d5f" class="ls lt iq ng b gy nk nl l nm nn">def phase_spectrum(imfs):<br/>    imfs_p = []<br/>    fig, axs = plt.subplots(len(imfs), 1, figsize=(15,9))<br/>    for i, imf in enumerate(imfs):<br/>        trans = fft(imf)<br/>        imf_p = np.arctan(trans.imag / trans.real)<br/>        <br/>        imfs_p.append(imf_p)<br/>        <br/>        axs[i].plot(imf_p, 'o')<br/>        axs[i].set_title(f'IMF {i}')<br/>        <br/>    return imfs_p</span></pre><p id="6455" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们只是应用Scipy库中的FFT，然后进行我之前描述的计算。最后，我们还绘制了阶段图，生成了下图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/fa5c9ac018d283253771deb61a3e30a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BjUF-r1wSw_UC-JFDk08GA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">国际货币基金组织的阶段。由作者生成的图像</p></figure><p id="4a29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以看到，当我们沿着IMF向下接近余数时，随着角度开始对齐，一种模式开始出现。这对我们来说是决定性行为的一个标志。</p><p id="3109" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，看这个图，最后两个部分似乎比前两个更具决定性。因此，我们可以这样选择它们，并手动定义随机和确定性组件。然而，有一种更好的方法。</p><h2 id="b7aa" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">利用互信息选择IMFs</h2><p id="c16b" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">评估两个分布之间关系的一种方法是互信息。这一指标的逻辑是，通过观察一个变量，衡量一个人可以从另一个变量获得多少信息。</p><p id="ca9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">两个随机信号之间的互信息应该为零。如果它们中只有一个是确定性的，那么这个值也应该相当接近于零。如果我们有两个确定性信号，那么这个值应该更大。</p><p id="d0d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">知道了这一点，我们可以在我们的IMF上应用互信息，并观察它何时达到峰值。在这一点上，我们应该开始将IMFs视为确定性组件。</p><p id="6768" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们把它编码起来:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="dfff" class="ls lt iq ng b gy nk nl l nm nn">def phase_mi(phases):<br/>    mis = []<br/>    for i in range(len(phases)-1):<br/>        mis.append(mutual_info_regression(phases[i].reshape(-1, 1), phases[i+1])[0])<br/>        <br/>    return np.array(mis)</span></pre><p id="88b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们利用了sklearn库中的计算。</p><p id="cd06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，有很多方法可以使用交互信息。在这篇文章中，我们将寻找一个分界点。</p><h2 id="a756" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">分割信号</h2><p id="1f51" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">现在我们有了将时间序列分成两部分所需的一切。让我们看看代码:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="eee5" class="ls lt iq ng b gy nk nl l nm nn">def divide_signal(signal, imfs, mis, cutoff=0.05):<br/>    cut_point = np.where(mis &gt; cutoff)[0][0]</span><span id="c801" class="ls lt iq ng b gy no nl l nm nn">    stochastic_component = np.sum(imfs[:cut_point], axis=0)<br/>    deterministic_component = np.sum(imfs[cut_point:], axis=0)<br/>    <br/>    t = [i for i in range(len(signal))]<br/>    <br/>    fig, axs = plt.subplots(3, 1, figsize=(15,12))<br/>    axs[0].plot(t, signal.values)<br/>    axs[0].set_title('Original Signal')<br/>    <br/>    axs[1].plot(t, stochastic_component)<br/>    axs[1].set_title('Stochastic Component')<br/>    <br/>    axs[2].plot(t, deterministic_component)<br/>    axs[2].set_title('Deterministic Component')<br/>    <br/>    return stochastic_component, deterministic_component</span></pre><p id="f9b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们定义多少互信息将被视为确定性分量的开始，然后我们对IMF求和，并绘制原始信号旁边的分量:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/947ded5c737f97558dd71947c07ef282.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FC-pYTDPVTdvXwhvixLsXw.png"/></div></div></figure><p id="3bdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，有了这两个分量，我们就可以利用图森嵌入定理预测确定性分量，利用ARIMA等预测工具预测随机分量，以捕捉可能仍存在于该分量上的某些确定性残差。</p><h2 id="5a83" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">结论</h2><p id="cb5f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">现在，我们的工具包中又多了一个工具，可以用来改进我们的时间序列分析。使用这种方法和图克的嵌入定理，我们有一个很好的框架来开始分析和预测时间序列数据。</p><p id="cad9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，没有一种方法是完美的，在某些情况下，这个框架不会产生最好的结果。但这就是数据科学的美妙之处，没有先验的正确答案，所以我们必须深入问题，找出前进的最佳方式。</p><h2 id="4471" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">感谢</h2><p id="1fea" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我必须在这里感谢Rodrigo Mello，他在2019年在我们大学的一堂课上首次向我介绍了这些概念。</p><p id="43b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[1]里奥斯，里卡多·阿劳若；罗德里戈·费尔南德斯·德·梅洛(2016年)。应用经验模式分解和互信息分离嵌入信号中的随机和确定性影响。信号处理，118()，159–176。doi:10.1016/j.sigpro</p><p id="b3fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[2] Box，G. E. P .，Jenkins，G. M .和Reinsel，G. C. (1976年)时间序列分析、预测和控制。第三版。霍尔登日。g系列。</p></div></div>    
</body>
</html>