<html>
<head>
<title>Everything You Need to Know About the Binary Search Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于二分搜索法算法你需要知道的一切</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/everything-you-need-to-know-about-the-binary-search-algorithm-6bc4f9a3127d#2022-09-27">https://towardsdatascience.com/everything-you-need-to-know-about-the-binary-search-algorithm-6bc4f9a3127d#2022-09-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="48d5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在8分钟内掌握二分搜索法算法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5319decd56c7b8ae5fd258591f6f3bf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i9hvkwILZ4hDQsIBotekuw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。</p></figure><p id="b9cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi lu translated">你如何在英语词典中查找一个单词？我知道你不会这样做:从第一页开始，仔细阅读每个单词，直到找到你要找的那个——当然，除非你的单词是“土豚”。但是，如果你要找的词是“动物园”，这种方法将需要很长时间。</p><blockquote class="md"><p id="2ddd" class="me mf it bd mg mh mi mj mk ml mm lt dk translated">你如何在英语词典中查找一个单词？</p></blockquote><p id="cab9" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">更快的方法是在中间打开它，然后决定是在词典的前半部分还是后半部分继续搜索。</p><p id="4663" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种方法是二分搜索法算法的松散描述，该算法<strong class="la iu">在元素的排序列表中查找元素的位置。</strong>它被称为二分搜索法(来自拉丁语<em class="ms">bīnī:</em>“two-by-two，pair”)，因为它在每次迭代时将数组分成两半，以缩小搜索空间。</p><p id="5593" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们定义一下前一句话中的行话。“算法”是一种解决问题的方法，就像我们在例子中用来查找单词的方法一样。“元素”是我们正在查找的单词，“元素排序列表”是字典。它被“排序”是因为字典中的单词是按字母顺序排列的。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><p id="dd1c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文讨论了二分搜索法算法是如何在直观的层面上工作的。然后我们将看看它在Python和C++中的实现以及它们的内置函数。最后，我们将讨论它与线性搜索算法相比的性能。</p><h1 id="14b9" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">算法</h1><p id="de7d" class="pw-post-body-paragraph ky kz it la b lb ns ju ld le nt jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">这一节将让你对二分搜索法算法有一个更好的直觉。首先，我们将查看问题陈述，然后了解算法本身，最后，通过一个示例来浏览算法。</p><h2 id="bf36" class="nx nb it bd nc ny nz dn ng oa ob dp nk lh oc od nm ll oe of no lp og oh nq oi bi translated">问题陈述</h2><p id="c761" class="pw-post-body-paragraph ky kz it la b lb ns ju ld le nt jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">在Leetcode这个练习编码面试问题的平台上，二分搜索法问题表述如下[3]:</p><blockquote class="oj ok ol"><p id="c68a" class="ky kz ms la b lb lc ju ld le lf jx lg om li lj lk on lm ln lo oo lq lr ls lt im bi translated">给定一个由n个元素组成的有序(升序)整数数组<code class="fe op oq or os b">nums</code>和一个<code class="fe op oq or os b">target</code>值，编写一个函数来搜索<code class="fe op oq or os b">nums</code>中的<code class="fe op oq or os b">target</code>。如果目标存在，返回其索引；否则，返回-1。</p></blockquote><ul class=""><li id="9201" class="ot ou it la b lb lc le lf lh ov ll ow lp ox lt oy oz pa pb bi translated">输入:排序数组(<code class="fe op oq or os b">nums</code>)和一个目标值(<code class="fe op oq or os b">target</code>)</li><li id="9cd4" class="ot ou it la b lb pc le pd lh pe ll pf lp pg lt oy oz pa pb bi translated">输出:<code class="fe op oq or os b">target</code>值的索引</li></ul><h2 id="6913" class="nx nb it bd nc ny nz dn ng oa ob dp nk lh oc od nm ll oe of no lp og oh nq oi bi translated">二分搜索法算法</h2><p id="4c1f" class="pw-post-body-paragraph ky kz it la b lb ns ju ld le nt jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">二分搜索法算法的工作原理如下:</p><ol class=""><li id="4b8d" class="ot ou it la b lb lc le lf lh ov ll ow lp ox lt ph oz pa pb bi translated">将搜索空间设置为等于排序后的数组</li><li id="f5ce" class="ot ou it la b lb pc le pd lh pe ll pf lp pg lt ph oz pa pb bi translated">取搜索空间的中间元素，并将其与目标值进行比较。<br/> -如果<strong class="la iu">目标等于中间元素</strong>，则您已经找到目标值。返回中间元素的索引并终止函数。<br/> -如果<strong class="la iu">目标小于中间元素</strong>，则通过丢弃中间元素右侧的所有元素将搜索空间减半，并继续在其左侧搜索，因为数组按升序排序。重复此步骤，直到找到目标。<br/> -如果<strong class="la iu">目标大于中间元素</strong>，则通过丢弃中间元素左侧的所有元素将搜索空间减半，并继续在其右侧搜索，因为数组是按升序排序的。重复此步骤，直到找到目标。</li><li id="28f5" class="ot ou it la b lb pc le pd lh pe ll pf lp pg lt ph oz pa pb bi translated">如果数组中没有匹配，返回-1</li></ol><h2 id="1c2b" class="nx nb it bd nc ny nz dn ng oa ob dp nk lh oc od nm ll oe of no lp og oh nq oi bi translated">示例演示</h2><p id="6358" class="pw-post-body-paragraph ky kz it la b lb ns ju ld le nt jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">让我们通过一个例子来完成二分搜索法算法。在下图中，你可以看到一个排序后的数组<code class="fe op oq or os b">nums</code> = [3，7，8，9，14，16，17，22，24]，有n = 9个元素。我们要找到<code class="fe op oq or os b">target</code> = 8的位置。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/f02411525bfc3549f66fd1d76cd1409d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MoS9QRWgO6D6wtmmCWuV0g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">二分搜索法算法问题陈述(图片由作者受<a class="ae pj" href="https://mikebuss.com/2016/04/21/binary-search/" rel="noopener ugc nofollow" target="_blank">迈克·巴斯</a>【7】启发而来)</p></figure><p id="0568" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">迭代1: </strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/5d0f62527628fdb16c344bc61f5bc5e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qcvebONRgoLBUyplLWgEKw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">二分搜索法算法迭代1(图片由作者从<a class="ae pj" href="https://mikebuss.com/2016/04/21/binary-search/" rel="noopener ugc nofollow" target="_blank">迈克·巴斯</a>【7】获得灵感)</p></figure><p id="ba36" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们通过称为<code class="fe op oq or os b">low</code>和<code class="fe op oq or os b">high</code>的开始和结束索引来定义搜索空间。我们通过将<code class="fe op oq or os b">low</code>分配给数组中第一个元素的索引(0)并将<code class="fe op oq or os b">high</code>分配给数组中最后一个元素的索引(8)来设置搜索空间。</p><p id="d0cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们用公式(<code class="fe op oq or os b">low</code>+【T8)//2得到数组<code class="fe op oq or os b">mid</code>中间元素的索引。该操作执行一个floor函数来实现所需的中间元素:<code class="fe op oq or os b">mid = (low + high) // 2 = (0 + 8) / 2 = 4</code></p><p id="10c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">中间元素的值是<code class="fe op oq or os b">nums[mid] = nums[4] = 14</code>，因此大于<code class="fe op oq or os b">target = 8</code>。因此，中间元素右侧的所有元素都可以被丢弃。我们通过将<code class="fe op oq or os b">high</code>更新为<code class="fe op oq or os b">(mid — 1) = 4 — 1 = 3</code>将搜索空间减半。</p><p id="f48b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">迭代2: </strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/d4033007980c485fc7b0efc6727cb904.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Io9ZDX1PHZvfhCingZFDzA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">二分搜索法算法迭代2(图片由作者从<a class="ae pj" href="https://mikebuss.com/2016/04/21/binary-search/" rel="noopener ugc nofollow" target="_blank">迈克·巴斯</a>【7】获得灵感)</p></figure><p id="050c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们重复步骤2。</p><p id="014b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数组中间元素的索引现在是<code class="fe op oq or os b">mid = (low + high) // 2 = (0 + 3) / 2 = 1</code>。中间元素的值是<code class="fe op oq or os b">nums[mid] = nums[1] = 7</code>，因此小于<code class="fe op oq or os b">target</code> = 8。因此，中间元素左侧的所有元素都可以被丢弃。我们通过将<code class="fe op oq or os b">low</code>更新为<code class="fe op oq or os b">(mid + 1) = 1 + 1 = 2</code>，将搜索空间减半。</p><p id="823d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">迭代3: </strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/efa6643428a9610a7124b8e9947d22fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NSqABXgVZ1eQPsSrArW6ag.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">二分搜索法算法迭代3(图片由作者从<a class="ae pj" href="https://mikebuss.com/2016/04/21/binary-search/" rel="noopener ugc nofollow" target="_blank">迈克·巴斯</a>【7】获得灵感)</p></figure><p id="4d3c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，我们重复步骤2。</p><p id="5a2a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数组中间元素的索引现在是<code class="fe op oq or os b">mid = (low + high) // 2 = (1 + 3) / 2 = 2</code>。</p><p id="3912" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">中间元素的值是<code class="fe op oq or os b">nums[mid] = nums[2] = 8</code>，因此等于<code class="fe op oq or os b">target</code> = 8。我们返回<code class="fe op oq or os b">mid = 2</code>作为目标的位置并终止函数。</p><h1 id="e2f9" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">履行</h1><p id="acaa" class="pw-post-body-paragraph ky kz it la b lb ns ju ld le nt jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">在这一节中，您将看到二分搜索法算法在Python和C++中最基本的实现。我们还将<strong class="la iu">看看Python和C++ </strong>中内置的二分搜索法函数。</p><p id="f72e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">二分搜索法算法有不同的实现方式[4]。但是，本文将只讨论<strong class="la iu">初等迭代实现</strong>，这也是最常见的实现。</p><h2 id="b3e4" class="nx nb it bd nc ny nz dn ng oa ob dp nk lh oc od nm ll oe of no lp og oh nq oi bi translated">计算机编程语言</h2><p id="7493" class="pw-post-body-paragraph ky kz it la b lb ns ju ld le nt jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">Python实现如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pk pl l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用Python实现的二分搜索法算法</p></figure><p id="5b42" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以使用Python [5]中的<code class="fe op oq or os b">bisect</code>模块中的<code class="fe op oq or os b">bisect_left()</code>函数，而不是编写自己的二分搜索法函数。</p><pre class="kj kk kl km gt pm os pn po aw pp bi"><span id="54c8" class="nx nb it os b gy pq pr l ps pt">from<!-- --> <!-- -->bisect import<!-- --> <!-- -->bisect_left</span><span id="d78c" class="nx nb it os b gy pu pr l ps pt">i =<!-- --> <!-- -->bisect_left(target, nums)<!-- --> </span></pre><h2 id="df7f" class="nx nb it bd nc ny nz dn ng oa ob dp nk lh oc od nm ll oe of no lp og oh nq oi bi translated">C++</h2><p id="6f4a" class="pw-post-body-paragraph ky kz it la b lb ns ju ld le nt jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">C++实现如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pk pl l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">二分搜索法算法的C++实现</p></figure><p id="e8a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在C++中，标准模板库(STL)提供了函数<code class="fe op oq or os b">lower_bound()</code>，可以按照下面的例子[2]使用。还有函数<code class="fe op oq or os b">binary_search()</code>，它返回一个布尔值，不管<code class="fe op oq or os b">target</code>是否存在于排序后的数组中，但不返回它的位置[1]。</p><pre class="kj kk kl km gt pm os pn po aw pp bi"><span id="6869" class="nx nb it os b gy pq pr l ps pt">#include &lt;algorithm&gt;</span><span id="09c9" class="nx nb it os b gy pu pr l ps pt">i = std::lower_bound(nums.begin(), nums.end(), target);</span></pre><h1 id="baac" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">讨论</h1><p id="5f5c" class="pw-post-body-paragraph ky kz it la b lb ns ju ld le nt jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">二分搜索法算法的时间和空间复杂度是:</p><ul class=""><li id="621c" class="ot ou it la b lb lc le lf lh ov ll ow lp ox lt oy oz pa pb bi translated"><strong class="la iu">时间复杂度与O(log n) </strong>成对数关系【6】。如果n是输入数组的长度，二分搜索法算法最坏情况下的时间复杂度是O(log n ),因为它是通过在每次迭代中将搜索空间减半来执行的。例如，如果我们想要在长度为8的数组中找到一个元素，在最坏的情况下将需要log₂(8 = 3次迭代。</li><li id="b1a7" class="ot ou it la b lb pc le pd lh pe ll pf lp pg lt oy oz pa pb bi translated"><strong class="la iu">空间复杂度与O(1) </strong>不变。因为该算法需要用于三个索引、<code class="fe op oq or os b">mid</code>、<code class="fe op oq or os b">low</code>和<code class="fe op oq or os b">high</code>的空间，但是每次迭代不需要额外的空间。</li></ul><p id="c088" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与线性搜索算法相比，二分搜索法算法的主要优势在于其速度。因为线性搜索算法的概念是遍历数组直到找到目标元素——就像从英文字典的第一页开始查找特定的单词一样——<strong class="la iu">线性搜索算法的时间复杂度与O(n) </strong>成线性关系。</p><p id="3a3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，如果我们想要从前面长度为8的示例中找到数组中的元素，在最坏的情况下将需要n = 8次迭代。二分搜索法算法只需要三次迭代。</p><p id="b8e0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，二分搜索法算法的主要<strong class="la iu">缺点</strong>是它需要一个有序数组在每次迭代中丢弃一半的搜索空间。尽管可以在运行二分搜索法算法之前对数组进行排序，但排序算法会增加总的时间复杂度。一般来说，排序的时间复杂度为O(n log n)，比线性搜索算法的线性时间复杂度更差。</p><p id="2995" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面，您可以看到二分搜索法算法、线性搜索算法和二分搜索法算法的时间复杂性，以及作为预处理步骤的附加排序:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pv"><img src="../Images/fef34582c970678ccf0a3a4cf1128f49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QJN9NfulJdtIhu7LM1C5sQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">大O总结(图片由作者启发[8])</p></figure><h1 id="5218" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">结论</h1><p id="7d38" class="pw-post-body-paragraph ky kz it la b lb ns ju ld le nt jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">开发算法的最佳方法是将问题分解成你已经知道如何解决的算法，比如搜索和排序。这就是为什么理解二分搜索法算法可以帮助你编写更好的算法——无论你是软件工程师、数据科学家还是其他任何开发算法的人。</p><blockquote class="md"><p id="90af" class="me mf it bd mg mh mi mj mk ml mm lt dk translated"><strong class="ak">理解二分搜索法算法可以帮助你写出更好的算法——无论你是软件工程师、数据科学家还是其他人</strong></p></blockquote><p id="5b6b" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">这篇文章解释了二分搜索法算法是如何工作的。该算法在排序列表中查找元素。因为搜索空间是排序的，所以该算法在每次迭代后丢弃一半的搜索空间。因此，我们将搜索空间减半，直到找到目标元素。您可以在下面看到算法的直观总结。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pw"><img src="../Images/9c3dab7d44ca8eae1b2078189f1272dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LWBhyy5VLO-IIOg18-He9A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如何在数组中二分搜索法为数字8(图片由作者受迈克·巴斯的启发而创作)</p></figure><p id="92ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在排序列表上，二分搜索法算法比线性搜索算法更有效。它具有对数时间复杂度和常数空间复杂度。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="c57b" class="na nb it bd nc nd px nf ng nh py nj nk jz pz ka nm kc qa kd no kf qb kg nq nr bi translated">喜欢这个故事吗？</h1><p id="b6ed" class="pw-post-body-paragraph ky kz it la b lb ns ju ld le nt jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated"><em class="ms">如果你想把我的新故事直接发到你的收件箱，</em> <a class="ae pj" href="https://medium.com/subscribe/@iamleonie" rel="noopener"> <em class="ms">订阅</em> </a> <em class="ms">！</em></p><p id="e677" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="ms">成为媒介会员，阅读更多其他作家和我的故事。报名时可以用我的</em> <a class="ae pj" href="https://medium.com/@iamleonie/membership" rel="noopener"> <em class="ms">推荐链接</em> </a> <em class="ms">支持我。我将收取佣金，不需要你额外付费。</em></p><div class="qc qd gp gr qe qf"><a href="https://medium.com/@iamleonie/membership" rel="noopener follow" target="_blank"><div class="qg ab fo"><div class="qh ab qi cl cj qj"><h2 class="bd iu gy z fp qk fr fs ql fu fw is bi translated">通过我的推荐链接加入Medium—Leonie Monigatti</h2><div class="qm l"><h3 class="bd b gy z fp qk fr fs ql fu fw dk translated">阅读Leonie Monigatti(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接…</h3></div><div class="qn l"><p class="bd b dl z fp qk fr fs ql fu fw dk translated">medium.com</p></div></div><div class="qo l"><div class="qp l qq qr qs qo qt ks qf"/></div></div></a></div><p id="c115" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="ms">在</em> <a class="ae pj" href="https://twitter.com/helloiamleonie" rel="noopener ugc nofollow" target="_blank"> <em class="ms">上找我</em></a><em class="ms"/><a class="ae pj" href="https://www.linkedin.com/in/804250ab/" rel="noopener ugc nofollow" target="_blank"><em class="ms">LinkedIn</em></a><em class="ms"/><a class="ae pj" href="https://www.kaggle.com/iamleonie" rel="noopener ugc nofollow" target="_blank"><em class="ms">ka ggle</em></a><em class="ms">！</em></p><h1 id="e559" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">参考</h1><p id="a600" class="pw-post-body-paragraph ky kz it la b lb ns ju ld le nt jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">[1]“c++参考”，“std::binary_search。”cppreference.com。<a class="ae pj" href="https://en.cppreference.com/w/cpp/algorithm/binary_search" rel="noopener ugc nofollow" target="_blank">https://en.cppreference.com/w/cpp/algorithm/binary_search</a>(2022年7月2日访问)</p><p id="0f86" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[2]《c++参考》，《std::lower_bound》cppreference.com。<a class="ae pj" href="https://en.cppreference.com/w/cpp/algorithm/lower_bound" rel="noopener ugc nofollow" target="_blank">https://en.cppreference.com/w/cpp/algorithm/lower_bound</a>(2022年7月2日访问)</p><p id="cc5f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[3]李特码，“704。二分搜索法。”leetcode.com。https://leetcode.com/problems/binary-search/<a class="ae pj" href="https://leetcode.com/problems/binary-search/" rel="noopener ugc nofollow" target="_blank">(2022年7月2日访问)</a></p><p id="d3c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[4]李特码，“了解二分搜索法”。leetcode.com。<a class="ae pj" href="https://leetcode.com/explore/learn/card/binary-search/" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/explore/learn/card/binary-search/</a>(2022年7月2日访问)</p><p id="25dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[5]“Python”，“二等分—数组二等分算法。”python.org。<a class="ae pj" href="https://docs.python.org/3/library/bisect.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/string.html#formatspec</a>(2022年7月2日访问)</p><p id="36ef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[6] S. Selkow，G. T. Heineman，G. Pollice,《算法概述》( 2008年), O'Reilly Media。</p><p id="fc9e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[7] M .巴斯，“在斯威夫特与二分搜索法分而治之”，mikebuss.com。<a class="ae pj" href="https://mikebuss.com/2016/04/21/binary-search/" rel="noopener ugc nofollow" target="_blank">https://mikebuss.com/2016/04/21/binary-search/</a>(2022年7月2日访问)</p><p id="4ea4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[8]“大O小抄”，“了解你的复杂性！”，bigocheatsheet.com。https://www.bigocheatsheet.com/<a class="ae pj" href="https://www.bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank">(2022年7月2日访问)</a></p></div></div>    
</body>
</html>