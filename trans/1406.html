<html>
<head>
<title>Integer vs. Linear Programming in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中整数与线性编程的比较</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/integer-programming-vs-linear-programming-in-python-f1be5bb4e60e#2022-04-07">https://towardsdatascience.com/integer-programming-vs-linear-programming-in-python-f1be5bb4e60e#2022-04-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="788d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Google OR-Tools优化混合整数规划</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/02c47beff8c0236fa98014f2493853b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*61w8yJ9mSDplUK30hXhpQg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供，表情符号由<a class="ae ky" href="https://openmoji.org/" rel="noopener ugc nofollow" target="_blank">open moji</a>(<a class="ae ky" href="https://creativecommons.org/licenses/by-sa/4.0/#" rel="noopener ugc nofollow" target="_blank">CC BY-SA 4.0</a>)</p></figure><p id="35ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么<strong class="lb iu">线性规划</strong>这么叫？</p><p id="ccfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个术语都令人困惑:</p><ul class=""><li id="d933" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">线性</strong>暗示<strong class="lb iu">非线性</strong>编程存在；</li><li id="9994" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">编程</strong>实际上<strong class="lb iu"> </strong>在这个上下文中的意思是“<strong class="lb iu">策划</strong>”。</li></ul><p id="c168" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">综上，与代码无关:线性与否。是关于<strong class="lb iu">用各种约束优化</strong>变量。</p><p id="c06b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将讨论另一种类型的优化:<strong class="lb iu">整数编程</strong>。我们将会看到为什么对我们所面临的问题有一个很好的理解对于选择正确的解算器是必要的。最后，我们将编写一个能够接受更大挑战的模型，并实际解决一整类优化问题。</p><p id="462a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以用下面的<a class="ae ky" href="https://colab.research.google.com/drive/1aIKnXPEiXFo1M3U0EM6arE2teD9KkJdF?usp=sharing" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Google Colab笔记本</strong> </a>运行本教程的代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/582d989b61568b650280397c91d6cf58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Nh7gzKjRzcxFQo_o"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供，表情符号由<a class="ae ky" href="https://openmoji.org/" rel="noopener ugc nofollow" target="_blank">open moji</a>(<a class="ae ky" href="https://creativecommons.org/licenses/by-sa/4.0/#" rel="noopener ugc nofollow" target="_blank">CC BY-SA 4.0</a>)</p></figure><h1 id="c7c6" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">📊一、优化问题类型</h1><p id="2d8c" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在<a class="ae ky" rel="noopener" target="_blank" href="/introduction-to-linear-programming-in-python-9261e7eb44b">线性规划介绍</a>中，我们<strong class="lb iu">优化了一个军队构成</strong>。结果如下:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="50af" class="nm ml it ni b gy nn no l np nq">================= Solution =================<br/>Solved in 87.00 milliseconds in 2 iterations<br/><br/><strong class="ni iu">Optimal power</strong> = 1800.0 💪power<br/>Army:<br/> - 🗡️<strong class="ni iu">Swordsmen </strong>= 6.0000000000000036<br/> - 🏹<strong class="ni iu">Bowmen </strong>= 0.0<br/> - 🐎<strong class="ni iu">Horsemen </strong>= 5.999999999999999</span></pre><p id="a025" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">怎么会有5.999……骑兵？我们指定我们的变量<strong class="lb iu">应该是带有<code class="fe nr ns nt ni b">VarInt</code>的整数</strong>。我们的代码有什么问题？</p><p id="5c82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题不在于模型，而在于求解者的选择。</p><p id="ac20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GLOP是一个<a class="ae ky" href="https://en.wikipedia.org/wiki/GLOP" rel="noopener ugc nofollow" target="_blank">纯线性规划求解器</a>。这意味着它<strong class="lb iu">无法理解整数</strong>的概念。它仅限于具有线性关系的连续参数。</p><p id="c3fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是<strong class="lb iu">线性</strong>编程(LP)和<strong class="lb iu">整数线性</strong>编程(ILP)的区别。总之，LP求解器只能使用实数而不能使用整数作为变量。如果不考虑变量，为什么我们把变量声明为整数呢？</p><p id="d600" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GLOP不能解决ILP问题，但是其他解决者可以。其实他们很多都是<strong class="lb iu">混合整数线性规划</strong> (MILP，俗称MIP)求解器。这意味着他们既可以考虑<strong class="lb iu">连续的</strong>(实数)，也可以考虑<strong class="lb iu">离散的</strong>(整数)变量。离散值的一个特殊情况是布尔变量用0-1值来表示决策。</p><p id="e894" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他解算器如SCIP或<a class="ae ky" href="https://projects.coin-or.org/Cbc" rel="noopener ugc nofollow" target="_blank"> CBC </a>可以解决<strong class="lb iu"> MILP和</strong>(混合整数<em class="nu">非线性</em>规划)问题。多亏了OR-Tools，我们可以使用相同的模型，只需将求解器更改为SCIP或CBC。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="cfda" class="nm ml it ni b gy nn no l np nq">================= Solution =================<br/>Solved in 3.00 milliseconds in 0 iterations</span><span id="1a0a" class="nm ml it ni b gy nx no l np nq"><strong class="ni iu">Optimal value</strong> = 1800.0 💪power<br/>Army: <br/> — 🗡️<strong class="ni iu">Swordsmen </strong>= 6.0<br/> — 🏹<strong class="ni iu">Bowmen </strong>= 0.0<br/> — 🐎<strong class="ni iu">Horsemen </strong>= 6.0</span></pre><p id="054d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">严格地说，我们的变量仍然是浮点数(<code class="fe nr ns nt ni b">type(swordsmen.solution_value()) = float</code>)，但是我们可以看到它们不再有奇怪的小数:CBC求解器实际上认为它们是整数<strong class="lb iu"/>。</p><p id="8760" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，我们通常只需<strong class="lb iu">将这些值</strong>向上取整，因为误差很小。然而，重要的是要记住根据所研究的问题选择合适的求解器:</p><ul class=""><li id="19ba" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu"> LP </strong>为连续变量；</li><li id="21fe" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">连续和离散变量组合的MIP/MILP </strong>。</li></ul><p id="e49b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有其他类型，如<strong class="lb iu">二次</strong> (QP)或<strong class="lb iu">非线性</strong> (NLP或MINLP，例如具有指数目标函数或约束)问题。它们适用于不同的环境，但遵循与LP或MIP解算器相同的原则。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/91267b8bc2d9995426b73688be07441a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eXPkPpMEX0bNxeRZnuXzKg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="5899" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">🧱二世。建立一个通用模型</h1><p id="1b56" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">但是如果我们的<strong class="lb iu">资源发生变化</strong>呢？还是一个单位的成本进化了？如果我们升级了骑士，他们的力量增加了呢？</p><p id="3c87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">OR-Tools最好的好处之一是它使用了Python这样的通用编程语言。代替静态数字，我们可以将我们的参数存储在类似于<strong class="lb iu">字典</strong>或<strong class="lb iu">列表</strong>的对象中。</p><p id="3522" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码不那么可读，但它变得更加灵活:实际上，它非常灵活，我们可以在不改变模型(只是参数)的情况下解决一整类优化问题。</p><p id="d8fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将输入参数转换成Python列表，并通过函数将它们提供给求解器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="5c12" class="nm ml it ni b gy nn no l np nq">================= Solution =================<br/>Solved in 2.00 milliseconds in 0 iterations</span><span id="44a9" class="nm ml it ni b gy nx no l np nq"><strong class="ni iu">Optimal value</strong> = 1800.0 💪power <br/>Army:<br/> — 🗡️<strong class="ni iu">Swordsmen </strong>= 6.0<br/> — 🏹<strong class="ni iu">Bowmen </strong>= 0.0<br/> — 🐎<strong class="ni iu">Horsemen </strong>= 6.0</span></pre><p id="05a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们获得了相同的结果:我们的代码似乎工作正常。现在让我们<strong class="lb iu">改变参数</strong>来解决一个稍微复杂一点的问题。</p><p id="9e6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象我们有更多的资源:🌾183000 ，🪵 <strong class="lb iu"> 90512 </strong>，🪙 <strong class="lb iu"> 80150 </strong>，所以我们还可以生产更多的单位！这是新的表格:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/002e7bf8623d6abc4a8a6af48961d541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NXG4ze1sme2tqOYLjW6Jyw.png"/></div></div></figure><p id="8fb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们转换了💪<strong class="lb iu">功率</strong>分为两个值:💪<strong class="lb iu">攻击</strong>和❤️ <strong class="lb iu">生命值</strong>，后者更详细一点。生命值高于攻击值，这就是为什么我们要增加一个加权因子，让它们更有可比性。</p><p id="60b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们以10为例，那么<em class="nu">力量= 10 *攻击+生命值</em>。我们的目标函数变成了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/4b88957f8028b2c6efd440c4823aa6c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WGMoYgtG7I7PwJxLAtwSXg.png"/></div></div></figure><p id="72b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们的代码适应这个新问题实际上很简单:我们只需要<strong class="lb iu">改变输入参数</strong>并更新<strong class="lb iu">目标函数</strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="7e5e" class="nm ml it ni b gy nn no l np nq">================= Solution =================<br/>Solved in 74.00 milliseconds in 412 iterations</span><span id="5f82" class="nm ml it ni b gy nx no l np nq"><strong class="ni iu">Optimal value</strong> = 1393145.0 💪power<br/>Army:<br/> — 🗡️<strong class="ni iu">Swordsmen </strong>= 2.0<br/> — 🛡️<strong class="ni iu">Men-at-arms</strong> = 1283.0<br/> — 🏹<strong class="ni iu">Bowmen </strong>= 3.0<br/> — ❌<strong class="ni iu">Crossbowmen </strong>= 0.0<br/> — 🔫<strong class="ni iu">Handcannoneers </strong>= 454.0<br/> — 🐎<strong class="ni iu">Horsemen </strong>= 0.0<br/> — ♞<strong class="ni iu">Knights </strong>= 0.0<br/> — 🐏<strong class="ni iu">Battering rams</strong> = 301.0<br/> — 🎯<strong class="ni iu">Springalds </strong>= 0.0<br/> — 🪨<strong class="ni iu">Mangonels </strong>= 0.0</span></pre><p id="dc82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题需要人类花很长时间来解决，但是ILP解决者在眨眼之间就解决了。比这更好的是:它也给了我们保证<strong class="lb iu">我们的解决方案是最优的</strong>，这意味着我们的敌人无法以同样的成本找到更好的军队构成！</p><p id="8c3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以增加单元的数量，并提供数十亿的资源，但你会明白:这只是需要更长的时间来获得一个解决方案，但它不会改变问题。</p><h1 id="6ca2" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">⚔️三世。组合约束</h1><p id="c1e0" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">现在，假设我们侦察了我们的敌人，知道他们的军队有一支💪<strong class="lb iu">100万</strong>的功率。我们可以建立一支更好的军队，但是我们的资源很宝贵，而且效率不高:我们所要做的就是建立一支拥有<strong class="lb iu">的军队💪功率高于1，000，000 </strong>(即使1，000，001也足够)。</p><p id="33a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换言之，总功率现在是一个<strong class="lb iu">约束</strong>(💪&gt; 1，000，000)而不是目标最大化。新的目标是最大限度地减少生产这支军队所需的资源。然而，我们可以重用我们的输入参数，因为它们没有改变。</p><p id="c963" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">新的约束可以翻译为“所选单元的功率之和必须严格大于1，000，000”。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/122e7daebc529cadfc8bfa31bd79dbb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LAq7zYjqG_-njYqOlcdnQQ.png"/></div></div></figure><p id="b1ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在代码中，我们可以遍历我们的单元和资源来设计这个约束。</p><p id="8dd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目标函数也必须改变。我们的目标是将花费在建军上的资源最少化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/21558ea1ee340b6051ab1a2374763829.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a9PmrsH5Zl2nNWN3LaGG-A.png"/></div></div></figure><p id="e362" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们可以循环使用我们的资源，在OR-Tools中实现它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="fc36" class="nm ml it ni b gy nn no l np nq">================= Solution =================<br/>Solved in 4.00 milliseconds in 0 iterations</span><span id="9b25" class="nm ml it ni b gy nx no l np nq"><strong class="ni iu">Optimal value</strong> = 111300.0 🌾🪵🪙resources<br/><strong class="ni iu">Power </strong>= 💪1001700.0 <br/>Army:<br/> — 🗡️<strong class="ni iu">Swordsmen </strong>= 0.0<br/> — 🛡️<strong class="ni iu">Men-at-arms</strong> = 0.0<br/> — 🏹<strong class="ni iu">Bowmen </strong>= 0.0<br/> — ❌<strong class="ni iu">Crossbowmen </strong>= 0.0<br/> — 🔫<strong class="ni iu">Handcannoneers </strong>= 0.0<br/> — 🐎<strong class="ni iu">Horsemen </strong>= 0.0<br/> — ♞<strong class="ni iu">Knights </strong>= 0.0<br/> — 🐏<strong class="ni iu">Battering rams</strong> = 371.0<br/> — 🎯<strong class="ni iu">Springalds </strong>= 0.0<br/> — 🪨<strong class="ni iu">Mangonels </strong>= 0.0</span><span id="1874" class="nm ml it ni b gy nx no l np nq">Resources:<br/> — 🌾<strong class="ni iu">Food </strong>= 0.0<br/> — 🪵<strong class="ni iu">Wood </strong>= 111300.0<br/> — 🪙<strong class="ni iu">Gold </strong>= 0.0</span></pre><p id="4096" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">规划求解找到了一个最优解:我们需要建造371🐏攻城槌总共花费111300 🪵wood.等等，如果我们没有那么多木头怎么办？在上一节中，我们只有🪵90512:，我们无法生产371🐏攻城锤。😱</p><p id="66d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么有没有可能将这些<strong class="lb iu">有限的资源</strong>考虑在内，同时仍然努力<strong class="lb iu">打造最好的军队</strong>？实际上，这非常简单:我们只需要复制/粘贴上一节中的约束。</p><p id="c25e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个版本中，我们有两种类型的约束:</p><ul class=""><li id="1641" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">总功率必须大于100万；</li><li id="6bc1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们不能花费超过我们有限的资源。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="eebd" class="nm ml it ni b gy nn no l np nq">================= Solution =================<br/>Solved in 28.00 milliseconds in 1 iterations</span><span id="ef80" class="nm ml it ni b gy nx no l np nq"><strong class="ni iu">Optimal value</strong> = 172100.0 🌾🪵🪙resources<br/><strong class="ni iu">Power </strong>= 💪1000105.0<br/>Army:<br/> — 🗡️<strong class="ni iu">Swordsmen </strong>= 1.0<br/> — 🛡️<strong class="ni iu">Men-at-arms</strong> = 681.0<br/> — 🏹<strong class="ni iu">Bowmen </strong>= 0.0<br/> — ❌<strong class="ni iu">Crossbowmen </strong>= 0.0<br/> — 🔫<strong class="ni iu">Handcannoneers </strong>= 0.0<br/> — 🐎<strong class="ni iu">Horsemen </strong>= 0.0<br/> — ♞<strong class="ni iu">Knights </strong>= 0.0<br/> — 🐏<strong class="ni iu">Battering rams</strong> = 301.0<br/> — 🎯<strong class="ni iu">Springalds </strong>= 0.0<br/> — 🪨<strong class="ni iu">Mangonels </strong>= 0.0 </span><span id="de0f" class="nm ml it ni b gy nx no l np nq">Resources:<br/> — 🌾<strong class="ni iu">Food </strong>= 68160.0<br/> — 🪵<strong class="ni iu">Wood </strong>= 90320.0<br/> — 🪙<strong class="ni iu">Gold </strong>= 13620.0</span></pre><p id="be77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们现在有一个<strong class="lb iu">🪵wood</strong>的有限资源，数量🐏攻城锤可悲的从371降到了301。作为交换，我们得到了681个🛡️men-at-arms，失去了1个🗡️swordsman(欢迎他们)。</p><p id="4210" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">军队的总花费是<strong class="lb iu"> 172，100 </strong>，这比我们之前发现的111，300要高得多(+65%的增长)，但是在这些限制下这确实是最优的解决方案。这表明我们应该生产更多的木材，因为这些🐏攻城锤性价比极高！</p><p id="1028" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子向<strong class="lb iu">展示了</strong> LP模型的模块化程度。可以在另一个模型中重用部分代码，比如约束，以组合它们并解决更复杂的问题。</p><h1 id="2365" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">🧠四世。线性规划vs机器学习</h1><p id="b199" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">让我们来谈谈房间里的大象。为什么不用<strong class="lb iu">机器学习</strong>(广义)代替线性规划？这并不是说这个问题不能用遗传算法来解决。</p><p id="e10a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数学优化往往被机器学习技术所忽视，但两者都有其优点:</p><ul class=""><li id="f688" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">线性规划可以在不确定的时间内(可能需要数年)产生一个<strong class="lb iu">最优解</strong>，而机器学习可以在任何时间内逼近复杂函数。</li><li id="81ab" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">LP里没有<strong class="lb iu">训练</strong>，但是需要专家建立数学模型。机器学习需要数据，但模型可以用作黑盒来解决问题。</li><li id="c6ff" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">根据经验，没有特定时间约束<strong class="lb iu">和/或不是非常复杂的问题可以有利地用线性规划来解决。</strong></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/5a76414c235e887d3434a007263c036e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CkyNIGyMSguOt1eS9Uh10g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供，表情符号由<a class="ae ky" href="https://openmoji.org/" rel="noopener ugc nofollow" target="_blank">open moji</a>(<a class="ae ky" href="https://creativecommons.org/licenses/by-sa/4.0/#" rel="noopener ugc nofollow" target="_blank">CC BY-SA 4.0</a>)</p></figure><h1 id="3c98" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">结论</h1><p id="d813" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在本教程中，我们深入了解了数学优化。</p><ul class=""><li id="f639" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">我们讲了最优化问题的求解器和类型:<strong class="lb iu"> LP，MIP，NLP</strong>；</li><li id="2885" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们以最佳方式建模并解决了一个极其常见的优化问题，并且<strong class="lb iu">通过一个函数推广了我们的模型</strong>；</li><li id="4603" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们重新架构了这个问题，<strong class="lb iu">合并了两组约束</strong>，以最低的价格获得最佳的军队构成；</li><li id="0842" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们对比了线性编程和机器学习的<strong class="lb iu">利弊</strong>。</li></ul><p id="b628" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有很多可以应用优化的问题。例如，如何创建满足每个人要求的学校时间表？如何在最短的时间内交付1000份不同的订单？在哪里建造一条新的地铁线以最大化其效用？</p><p id="427c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在以后的文章中，我们将讨论这些技术的新型应用，包括可满足性和非线性问题。</p><p id="ae7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇更高级的文章。如果你喜欢机器学习和优化，<a class="ae ky" href="https://twitter.com/maximelabonne" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">我们在Twitter上联系一下</strong> </a>！</p><h1 id="1fb6" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">相关文章</h1><div class="oc od gp gr oe of"><a rel="noopener follow" target="_blank" href="/constraint-programming-67ac16fa0c81"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">第3部分:Python中的约束编程</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">在8，080，104个候选项中找出一个解决方案的编程范例</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">towardsdatascience.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot ks of"/></div></div></a></div><div class="oc od gp gr oe of"><a rel="noopener follow" target="_blank" href="/introduction-to-linear-programming-in-python-9261e7eb44b"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">第1部分:Python线性编程简介</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">使用谷歌或工具进行数学优化的指南</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">towardsdatascience.com</p></div></div><div class="oo l"><div class="ou l oq or os oo ot ks of"/></div></div></a></div></div></div>    
</body>
</html>