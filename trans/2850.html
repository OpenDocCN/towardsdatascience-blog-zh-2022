<html>
<head>
<title>Handling Trends in Tree-Based Time Series Forecasting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于树的时间序列预测中的趋势处理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/handling-trends-in-tree-based-time-series-forecasting-fea5e4c066fb#2022-06-21">https://towardsdatascience.com/handling-trends-in-tree-based-time-series-forecasting-fea5e4c066fb#2022-06-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f03c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">事实是——没有趋势</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ef6efd71e28bea270bbfbd1b44af7209.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IIDTK5dNsI-IRYtY8iY2sg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安娜·昆潘在<a class="ae ky" href="https://unsplash.com/s/photos/spoon?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="6e3e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="d0d8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">通常，当您看到关于使用Xgboost或LightGBM等模型解决时间序列问题的文章或指南时，作者会提到树模型获取趋势和预测数据边界之外的能力。这被视为一个需要克服的问题。但是，这确实是一个特性，而不是一个缺陷。只有当我们认为我们的预测<strong class="lt iu">需要</strong>超出范围时，才应该关闭这个功能——而不是因为趋势存在于我们的数据中。</p><p id="5ffb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">通过用一条线对数据进行去趋势化，考虑您所声明的内容:</p><blockquote class="ms"><p id="3c52" class="mt mu it bd mv mw mx my mz na nb mm dk translated">在未来的某个时间点，数据将有一个新的最大值或最小值</p></blockquote><p id="55df" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">这是一个相当强有力的声明，你可能应该非常了解你的数据<strong class="lt iu">才能做出这样的声明。尤其是当对数据进行去趋势化时，还会从树中窃取信息——即使它不能显式地对其建模。</strong></p><p id="cfdb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">所以…虽然接受趋势的存在，但是<strong class="lt iu">并不</strong>总是<em class="nh">有用的</em>去模拟它…</p><h1 id="0f8e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">激励人心的例子</h1><p id="3d56" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们来看看一个相当著名的时间序列:航空乘客数据集。这些数据随处可得，其中一个来源来自<a class="ae ky" href="https://www.kaggle.com/rakannimer/air-passengers" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>，它带有一个开放数据库许可证。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="a3d6" class="nn la it nj b gy no np l nq nr">import numpy as np<br/>import pandas as pd<br/>from matplotlib import pyplot as plt<br/>import seaborn as sns<br/>sns.set_style("darkgrid")#Airlines Data, if your csv is in a different filepath adjust this<br/>df = pd.read_csv(r'AirPassengers.csv')<br/>df.index = pd.to_datetime(df['Month'])<br/>y = df['#Passengers']<br/>plt.plot(y)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/588f750f3d244791b351ddd822c782c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*LFodFMcDw_7814Gwb5kcrw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="ed45" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">显然，有上升趋势。但是，一个新的“最大”值会出现多少次？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/8bd9b226006d1f3f71388c257f9618a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*Cj-F4KGS1gx_oNyA5XjU6w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="c93b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">大约有20%的时间会发生这种情况，大多是在季节性高峰期。那剩下的80%呢？“允许”模型出界有意义吗，特别是如果我们非常确定接下来的几个时期不是季节性高峰的话？更重要的是——如果我们不需要<strong class="lt iu">预测新的最大值，去趋势化会损害我们的预测准确性吗？</strong></p><h1 id="c65f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">建模</h1><p id="910f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于这个例子，我们将使用我用LightGBM开发的用于时间序列预测的包:<a class="ae ky" href="https://github.com/tblume1992/LazyProphet" rel="noopener ugc nofollow" target="_blank"> LazyProphet </a>。只需快速进行pip安装:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="cc58" class="nn la it nj b gy no np l nq nr">pip install LazyProphet</span></pre><p id="b061" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你想了解更多关于这个包的信息，你应该看看我以前的文章:</p><div class="nt nu gp gr nv nw"><a rel="noopener follow" target="_blank" href="/lazyprophet-time-series-forecasting-with-lightgbm-3745bafe5ce5"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd iu gy z fp ob fr fs oc fu fw is bi translated">LazyProphet:用LightGBM进行时间序列预测</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">都是关于功能的</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">towardsdatascience.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok ks nw"/></div></div></a></div><p id="0635" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在我们的实验中，我们将保留过去12个月的数据，然后使用LazyProphet对去趋势预测和标准预测进行扩展预测。然后，我们将查看测试集MSE进行比较。下面是实现这一目的的代码片段:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="f0ff" class="nn la it nj b gy no np l nq nr">import numpy as np<br/>import pandas as pd<br/>from matplotlib import pyplot as plt<br/>from sklearn.metrics import mean_squared_error<br/>from LazyProphet import LazyProphet as lp<br/>import seaborn as sns<br/>sns.set_style("darkgrid")#Airlines Data, if your csv is in a different filepath adjust this<br/>df = pd.read_csv(r'AirPassengers.csv')<br/>df.index = pd.to_datetime(df['Month'])<br/>y = df['#Passengers'][:-12]<br/>results =[]<br/>for i in range(1, 13):<br/>    if (-12 + i) == 0:<br/>        y_test = df['#Passengers'][-12:]<br/>    else:<br/>        y_test = df['#Passengers'][-12:-12 + i]<br/>    lp_model = lp.LazyProphet(seasonal_period=12,<br/>                              n_basis=10,<br/>                              objective='regression',<br/>                              fourier_order=5,<br/>                              ar=list(range(1, 13)),<br/>                              decay=.99,<br/>                              linear_trend=False,<br/>                              scale=True<br/>                              )<br/>    fitted = lp_model.fit(y)<br/>    predicted = lp_model.predict(i)<br/>    no_trend = mean_squared_error(y_test.values, predicted)</span><span id="4794" class="nn la it nj b gy ol np l nq nr">    lp_model = lp.LazyProphet(seasonal_period=12,<br/>                              n_basis=10,<br/>                              objective='regression',<br/>                              fourier_order=5,<br/>                              ar=list(range(1, 13)),<br/>                              decay=.99,<br/>                              linear_trend=True,<br/>                              scale=True<br/>                              )<br/>    fitted = lp_model.fit(y)<br/>    predicted = lp_model.predict(i)<br/>    trend = mean_squared_error(y_test.values, predicted)<br/>    results.append([no_trend, trend])</span></pre><p id="94f2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们来看看结果:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="fb61" class="nn la it nj b gy no np l nq nr">plt.bar(x=range(1, 13), height=[i[0] for i in results], alpha=.5, label='No Trend')<br/>plt.bar(x=range(1, 13), height=[i[1] for i in results], alpha=.5, label='De-Trended')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/694ccf8dbd8463e5db28af624949bae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*sQTL-yDTEWL59moIswxtIg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="a20b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">第一个条形图似乎没有“无趋势”值，这看起来可能有点奇怪。该模型实际上准确地预测了它，所以MSE值相当小。即使忽略这一点，我们仍然看到，去趋势模型通常在预测范围内具有更高的错误率，直到7期范围。事实上,“无趋势”模型在前6个层位的误差平均少30%。</p><p id="7b3e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">你能猜到6期之后会发生什么吗？</strong></p><p id="7200" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们的测试数据超出了界限，需要一个趋势来允许树到达那里。</p><p id="e5c2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是我的观点。我们的训练数据(和测试数据)中显然存在一种趋势，但是一直对这种趋势<em class="nh">建模</em>会损害我们的准确性。这不仅仅是趋势的存在，而是我们是否相信预测范围内的数据突破了我们的上限。这是一个实际问题，而不是统计问题。</p><h1 id="5377" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">一些补救措施</h1><p id="09b7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><em class="nh">*在我们了解一些“测试”之前，我只想强调，这些应该是用于指导您决策的指标。或者潜在地标记预测以供审查。趋势线可能很危险！</em></p><p id="9e0a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最直接的解决方案是使用一种简单的方法来“预测”我们是否需要用线性趋势来扩展我们的界限。有很多方法可以做到这一点，但是我将使用LazyProphet来完成分类任务。我们将需要通过移除缩放和ar组件以及调整“目标”来稍微调整模型。</p><p id="22b5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">首先，让我们构建我们的新数据集，如果该值是最大值，它将简单地为1，否则为0。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="8ffe" class="nn la it nj b gy no np l nq nr">y_class = []<br/>max_val = 0<br/>for i in y:<br/>    if i &gt; max_val:<br/>        max_val = i<br/>        y_class.append(1)<br/>    else:<br/>        y_class.append(0)</span></pre><p id="1553" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">接下来我们将进行时间序列分类。<code class="fe on oo op nj b">return_proba</code>参数表示我们是否想要返回概率而不是二进制分类:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="ceb1" class="nn la it nj b gy no np l nq nr">lp_model = lp.LazyProphet(seasonal_period=12,<br/>                          n_basis=10,<br/>                          objective='classification',<br/>                          fourier_order=5,<br/>                           # ar=list(range(1, 13)),<br/>                          decay=.99,<br/>                          linear_trend=False,<br/>                          scale=False,<br/>                          return_proba=True<br/>                          )<br/>fitted = lp_model.fit(np.array(y_class))<br/>predicted = lp_model.predict(12)<br/>plt.bar(x=range(1,13), height=predicted.reshape(-1,))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/06eb460c38e2b166d530892b8ce5a235.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*sCbQ5jLiv6e8th25AUbq4w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="fe15" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">看起来不出所料！基于此，如果预测范围超过6(当概率大于0.5时)，我们需要去趋势，这是100%正确的。通过一些简单的逻辑来解释这个输出，我们可以为<code class="fe on oo op nj b">linear_trend</code>传递一个<code class="fe on oo op nj b">True</code>或<code class="fe on oo op nj b">False</code>，这将产生‘最优’性能。</p><p id="50a3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是可行的，但是我们增加了一些计算，而且按顺序预测对我来说不是很好。</p><p id="b1af" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">另一种方法是创建桶并检查这些桶的平均值。如果平均值一直在增加，那么我们就有一个趋势。这似乎不是什么新鲜事，但是我们将根据预测范围来选择存储桶的大小。让我们来写函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="bf95" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">通过逻辑思考，如果您的预测范围为1，则:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="6353" class="nn la it nj b gy no np l nq nr">n_bins = int(len(y) / (forecast_horizon))</span></pre><p id="8da6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">简化为系列的长度。因此，大部分值(大于给定的阈值百分比)必须增加/减少。随着我们增加预测范围，我们平滑了数据，最终得到12个周期范围的类似结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/fba64f23b754b22390473c41342b6793.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*6UOjEV-2UUy05mKtxOyq2w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="32f3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">其在数据的平滑视图中总是增加。</p><p id="3bf3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">接下来，让我们实际运行这个测试:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="8d0d" class="nn la it nj b gy no np l nq nr">trend = []<br/>for i in range(1, 13):<br/>    trend.append(tree_trend_test(y, i, threshold=.9))</span></pre><p id="d5fe" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这给了我们:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="bd64" class="nn la it nj b gy no np l nq nr">[False, False, False, False, False, True, True, False, True, True, True, True]</span></pre><p id="48de" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这确实在实际需要之前证明了这一点，但是这种方法不需要任何关于季节性的知识，这是有利也有弊的。</p><h1 id="ccf5" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="9367" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">去趋势化是一个重要的问题。这个问题需要我们的关注。我不提倡完全自动化去趋势化，尽管我意识到有时这是必需的。但是，你应该总是选择<strong class="lt iu">而不是</strong>减少树木的趋势。</p><p id="d588" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在介绍中，我提到了使用树模型进行预测的指南，在某些时候，它们通常会对线性趋势进行可能的“测试”。然后继续用“但是没有什么能打败视力测试”来结束这一部分，我同意这一点。我们可以向整个数据科学界展示这些数据，他们都会说这是一种趋势，而且他们是正确的。</p><p id="e19c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">从传统的时间序列观点来看，趋势是存在的。</p><p id="fe01" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">但是我们必须记住，我们是<strong class="lt iu">而不是</strong>使用传统的时间序列方法。这不是一个趋势存在与否的问题，而是…</p><p id="8591" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们<strong class="lt iu">需要</strong>一个趋势吗？</p><p id="50ae" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你觉得这很有趣，那么你可以看看我的其他文章:</p><div class="nt nu gp gr nv nw"><a rel="noopener follow" target="_blank" href="/lazyprophet-time-series-forecasting-with-lightgbm-3745bafe5ce5"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd iu gy z fp ob fr fs oc fu fw is bi translated">LazyProphet:用LightGBM进行时间序列预测</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">都是关于功能的</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">towardsdatascience.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok ks nw"/></div></div></a></div><div class="nt nu gp gr nv nw"><a rel="noopener follow" target="_blank" href="/gradient-boosted-arima-for-time-series-forecasting-e093f80772f6"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd iu gy z fp ob fr fs oc fu fw is bi translated">时间序列预测的梯度增强ARIMA</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">提升PmdArima的Auto-Arima性能</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">towardsdatascience.com</p></div></div><div class="of l"><div class="ot l oh oi oj of ok ks nw"/></div></div></a></div><div class="nt nu gp gr nv nw"><a rel="noopener follow" target="_blank" href="/thymeboost-a0529353bf34"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd iu gy z fp ob fr fs oc fu fw is bi translated">用百里香增强进行时间序列预测</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">一种梯度增强的时间序列分解方法</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">towardsdatascience.com</p></div></div><div class="of l"><div class="ou l oh oi oj of ok ks nw"/></div></div></a></div></div></div>    
</body>
</html>