<html>
<head>
<title>4 Techniques to Handle Missing values in Time Series Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理时间序列数据中缺失值的4种技术</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/4-techniques-to-handle-missing-values-in-time-series-data-c3568589b5a8#2022-04-28">https://towardsdatascience.com/4-techniques-to-handle-missing-values-in-time-series-data-c3568589b5a8#2022-04-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e800" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">时间序列分析基本指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7d841268653c34bf89ce9ce3ee360f93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JIzI5Fi-bxT1xS427fv6IA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=693873" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/wilhei-883152/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=693873" rel="noopener ugc nofollow" target="_blank"> Willi Heidelbach </a></p></figure><p id="f133" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">真实世界的数据通常包含缺失值。包括时间序列数据在内的所有类型的数据集都存在缺失值的问题。丢失值的原因可能是数据损坏或无法在任何给定时间记录数据。</p><p id="517a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我以前的一篇文章中，我讨论了处理非时序数据集缺失值的7种不同技术:</p><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/7-ways-to-handle-missing-values-in-machine-learning-1a6326adf79e"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">机器学习中处理缺失值的7种方法</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">处理数据集中缺失值的常用策略</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="928a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时间序列模型使用完整的数据，因此需要在建模或实际时间序列分析之前估算缺失值。时间序列数据集中缺失的值可以使用两种广泛的技术来处理:</p><ul class=""><li id="fc62" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated">删除缺少值的记录</li><li id="c887" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">估算缺失的信息</li></ul><p id="4637" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，丢弃丢失的值不是一个合适的解决方案，因为我们可能会丢失相邻观测值的相关性。估计或估算缺失值是处理缺失值的一个很好的方法。</p><h2 id="6552" class="nb nc it bd nd ne nf dn ng nh ni dp nj li nk nl nm lm nn no np lq nq nr ns nt bi translated">开始使用:</h2><p id="e492" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">在本文中，我们将讨论4种可用于估算时间序列数据集中缺失值的技术:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="d053" class="nb nc it oa b gy oe of l og oh"><strong class="oa iu">1) Last Observation Carried Forward (LOCF)<br/>2) Next Observation Carried Backward (NOCB)<br/>3) Rolling Statistics<br/>4) Interpolation</strong></span></pre><p id="0c75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">样本数据包含50天内收集的温度数据，其中有5个值随机缺失。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/13a9ca7d7fb6f92f9bf97a28adf0f429.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bqlRoEuywENSbCE2orRBUw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)，样本数据集随时间变化的快照</p></figure><h1 id="80c1" class="oj nc it bd nd ok ol om ng on oo op nj jz oq ka nm kc or kd np kf os kg ns ot bi translated">1)最后一次观察结转:</h1><p id="ffb2" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">LOCF是一个简单而优雅的技巧，它将之前没有丢失的值结转或复制，并用丢失的值替换。</p><blockquote class="ou ov ow"><p id="7efb" class="kz la ox lb b lc ld ju le lf lg jx lh oy lj lk ll oz ln lo lp pa lr ls lt lu im bi translated"><code class="fe pb pc pd oa b"><strong class="lb iu">df[‘Forward_Fill’] = df[‘AvgTemperature’].ffill()</strong></code></p></blockquote><p id="2310" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe pb pc pd oa b"><a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.ffill.html" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">ffill()</strong></a></code>功能来自熊猫。DataFrame函数可用于用以前的值估算缺失的值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/d015270e1d8a243f9a0708eda1280cd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*4svUcTpnLaJq-VKUQObbhg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)，向前插补</p></figure><h1 id="d34a" class="oj nc it bd nd ok ol om ng on oo op nj jz oq ka nm kc or kd np kf os kg ns ot bi translated">2)下一次向后观测:</h1><p id="67b4" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">NOCB是另一种简单的技术，它复制下一个没有丢失的值，并用前面丢失的值替换。</p><blockquote class="ou ov ow"><p id="8ec7" class="kz la ox lb b lc ld ju le lf lg jx lh oy lj lk ll oz ln lo lp pa lr ls lt lu im bi translated"><code class="fe pb pc pd oa b"><strong class="lb iu">df[‘Backward_Fill’] = df[‘AvgTemperature’].bfill()</strong></code></p></blockquote><p id="e6a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe pb pc pd oa b"><a class="ae ky" href="https://www.geeksforgeeks.org/python-pandas-dataframe-bfill/" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">bfill()</strong></a></code>大熊猫的功能。DataFrame函数可用于用以前的值估算缺失的值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/684c8696920cbe5f45cb91a078ad77ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*o6SRQy1nbfV1hvrPyFY-Hw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)，反向插补</p></figure><h1 id="18d8" class="oj nc it bd nd ok ol om ng on oo op nj jz oq ka nm kc or kd np kf os kg ns ot bi translated">3)滚动统计:</h1><p id="64a2" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">统计技术可用于通过聚合先前的非缺失值来估算缺失值。滚动统计技术可以是:</p><p id="4093" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> a)简单移动平均线:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/251d48bb3dc25b81314717f327222bff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*GqcyY6_vA-cvcj90Tg6KdA.png"/></div></figure><blockquote class="ou ov ow"><p id="b077" class="kz la ox lb b lc ld ju le lf lg jx lh oy lj lk ll oz ln lo lp pa lr ls lt lu im bi translated"><code class="fe pb pc pd oa b"><strong class="lb iu">df[‘SMA’] = df['<em class="it">AvgTemperature</em>'].rolling(window=5).mean()</strong></code></p></blockquote><p id="5e75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> b)加权移动平均:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/25360aa8304f8f13eadf14ceb2ee5327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6PlxApRuwnKzomxEaN1zjw.png"/></div></div></figure><blockquote class="ou ov ow"><p id="bbb6" class="kz la ox lb b lc ld ju le lf lg jx lh oy lj lk ll oz ln lo lp pa lr ls lt lu im bi translated"><code class="fe pb pc pd oa b"><strong class="lb iu"><em class="it">df[‘WMA’] = </em>data<em class="it">['AvgTemperature']</em>.rolling(window=5).apply(lambda x: x[::-1].cumsum().sum() * 2 / n / (n + 1))</strong></code></p></blockquote><p id="de03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> c)指数(加权)移动平均:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/7f7e64807514305bd145b44d58dec64d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*1tmY0vW2LmgAY4ASIWD-5A.png"/></div></figure><blockquote class="ou ov ow"><p id="85e2" class="kz la ox lb b lc ld ju le lf lg jx lh oy lj lk ll oz ln lo lp pa lr ls lt lu im bi translated"><code class="fe pb pc pd oa b"><strong class="lb iu">df['EWA] = df['AvgTemperature'].ewm(halflife=4).mean()</strong></code></p></blockquote><h1 id="4194" class="oj nc it bd nd ok ol om ng on oo op nj jz oq ka nm kc or kd np kf os kg ns ot bi translated">4)插值:</h1><p id="8603" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">插值技术通过假设数据点范围内的关系来估计缺失值。在滚动统计技术中，只有以前的值被认为是估算缺失值，插值技术使用过去和未来的已知数据点进行估计。</p><p id="867a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有各种插值方法:</p><ul class=""><li id="59c0" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated">线性:假设数据点范围呈线性关系</li><li id="2312" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">样条:估计使整体曲率最小化的值，从而获得通过输入点的平滑曲面。</li><li id="ee0c" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">时间:通过更多地关注附近的点而不是远处的点来估计缺失值。</li></ul><p id="0053" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有各种其他插值技术可用于估算缺失值。所有这些都假设相邻的数据点是相似的，但事实并非总是如此。</p><blockquote class="ou ov ow"><p id="9e5f" class="kz la ox lb b lc ld ju le lf lg jx lh oy lj lk ll oz ln lo lp pa lr ls lt lu im bi translated"><code class="fe pb pc pd oa b"><strong class="lb iu">df[‘Interpolate_Spline’]= df[‘AvgTemperature’].interpolate(option=’spline’)</strong></code></p></blockquote><p id="12d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">熊猫。DataFrame软件包提供使用<a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.interpolate.html" rel="noopener ugc nofollow" target="_blank">插值</a>技术估算缺失值。<a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.interpolate.html" rel="noopener ugc nofollow" target="_blank">插值</a>实现中的选项参数采用算法('样条'、'线性'、'时间'、'二次'等等)。</p><h1 id="8113" class="oj nc it bd nd ok ol om ng on oo op nj jz oq ka nm kc or kd np kf os kg ns ot bi translated">结论:</h1><p id="64c4" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">在本文中，我们讨论了处理和估算时间序列数据集中缺失值的各种技术。熊猫。DataFrame实现了大多数插补技术。</p><p id="79af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面讨论的所有算法都假定相邻的数据点是相似的，但事实并非总是如此。有一些先进的插补技术不遵循这一假设。</p><h1 id="0b73" class="oj nc it bd nd ok ol om ng on oo op nj jz oq ka nm kc or kd np kf os kg ns ot bi translated">参考资料:</h1><p id="73a1" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">[1]熊猫文献:<a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html" rel="noopener ugc nofollow" target="_blank">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html</a></p><blockquote class="pi"><p id="0492" class="pj pk it bd pl pm pn po pp pq pr lu dk translated">感谢您的阅读</p></blockquote></div></div>    
</body>
</html>