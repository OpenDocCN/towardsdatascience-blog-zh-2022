<html>
<head>
<title>On the Myths and Problems of Jupyter Notebooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">朱庇特笔记本的神话和问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/on-the-myths-and-problems-of-jupyter-notebooks-81517a4696ef#2022-03-03">https://towardsdatascience.com/on-the-myths-and-problems-of-jupyter-notebooks-81517a4696ef#2022-03-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="f7f2" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">数据科学软件工程</h2><div class=""/><div class=""><h2 id="b05c" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">您可以使用当前工具对笔记本进行版本控制、测试和模块化。让我们讨论真正的问题。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/4ab0c7572cb79d8e9c72179499590db2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jXx7Y_dXPrTAHNeYLtoc3A.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片作者。</p></figure><p id="671c" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja"> Jupyter笔记本，你爱它们，或者你讨厌它们。</strong>Jupyter笔记本的使用(和误用)是数据社区中最具争议的话题之一。当然，有正当的理由避免使用笔记本，但是我希望谈话集中在真正的问题上，而不是一遍又一遍地讨论已经解决的问题。在这篇博文中，我讨论了笔记本电脑最常见的误区，并评论了尚未解决的关键问题。</p><h1 id="58a6" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">"您不能对笔记本进行版本控制"</h1><p id="9389" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">通常，笔记本是<code class="fe mx my mz na b">.ipynb</code>文件。在幕后，<code class="fe mx my mz na b">.ipynb</code>文件是具有预定义模式的JSON文件，它们将代码和输出保存在同一个文件中。独立笔记本很方便:你可以在笔记本上工作，保存它，明天再来，结果就在那里了。需要注意的是，用git管理它们很有挑战性。首先，<code class="fe mx my mz na b">.ipynb</code>文件会增大git存储库的大小，其次，<code class="fe mx my mz na b">git diff</code>(和GitHub Pull请求)不会起作用。GitHub上笔记本的diff视图是这样的:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nb"><img src="../Images/a579695351c9a7753a2c4bb591a8fd2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vFVTvWk37GeNFtSZ1jddxQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">GitHub不喜欢。ipynb文件。图片作者。</p></figure><p id="9e27" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">幸运的是，我们可以轻松解决这个问题。有一个官方的JupyerLab扩展，将git集成到Jupyter接口中，允许你(除了别的以外)区分笔记本。它看起来是这样的:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ne"><img src="../Images/35eb8927dae94282d64f0c6d32163036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ySXc-CHzGJ6T1_j5XjNzjA.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">您可以使用jupyterlab-git扩展来执行笔记本代码审查。图片作者。</p></figure><p id="755c" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">你可以看到它清楚地显示了区别，git上的当前版本有红色边框的图形，而新版本有绿色边框。</p><p id="b484" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">另一个选择是使用<a class="ae nc" href="https://github.com/jupyter/nbdime" rel="noopener ugc nofollow" target="_blank"> nbdime </a>，它允许您从终端执行同样的操作(事实上，JupyterLab扩展使用了幕后的<code class="fe mx my mz na b">nbdime</code>)。</p><p id="c415" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">第三种选择(也是我最喜欢的！)是<a class="ae nc" href="https://github.com/mwouts/jupytext" rel="noopener ugc nofollow" target="_blank"> Jupytext </a>。该软件包允许您将<code class="fe mx my mz na b">.py</code>文件作为笔记本打开。这样，您可以交互地编辑您的代码，但是一旦您保存了它，它将存储一个<code class="fe mx my mz na b">.py</code>文件。</p><p id="abda" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">当使用Jupytext时，您可以使用<code class="fe mx my mz na b">git diff</code>和pull请求，因为您的笔记本是简单的脚本。主要的警告是，一旦关闭文件，输出就会丢失，但是可以使用Jupytext的配对函数，该函数将结果存储在一个单独的<code class="fe mx my mz na b">.ipynb</code>文件中，有效地存储源代码并输出两个不同的文件。</p><h1 id="5faf" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">“您不能测试笔记本”</h1><p id="2a13" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">这个有几个角度。如果我们考虑将笔记本作为一个整体来测试，我们可以使用<a class="ae nc" href="https://github.com/nteract/papermill" rel="noopener ugc nofollow" target="_blank"> papermill </a>来有计划地执行它们并评估它们的结果。例如，您可以用<code class="fe mx my mz na b">papermill</code>编写一个测试用例，如下所示:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="eca8" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">一个更简单的替代方法是运行冒烟测试(即检查笔记本是否运行，但跳过输出检查)。您可以编写这样的脚本在您的<a class="ae nc" href="https://en.wikipedia.org/wiki/Continuous_integration" rel="noopener ugc nofollow" target="_blank"> CI </a>系统中执行(例如GitHub操作):</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="afc1" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">最后，您可能对笔记本的单元测试部分感兴趣(例如，笔记本内部定义的功能)。我建议在笔记本外部定义函数，然后导入到笔记本中。这样，您可以像对任何其他函数一样对这些函数进行单元测试。但是，如果你想在<code class="fe mx my mz na b">.ipynb</code>文件中编写函数，你可以使用<a class="ae nc" href="https://github.com/nteract/testbook" rel="noopener ugc nofollow" target="_blank"> testbook </a>。</p><p id="4e1d" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">Testbook允许你从一个<code class="fe mx my mz na b">.ipynb</code>文件中提取定义并测试它们:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h1 id="fd54" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">“您不能模块化笔记本”</h1><p id="2487" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">另一个批评是你不能模块化笔记本。然而，这对于<a class="ae nc" href="https://github.com/ploomber/ploomber" rel="noopener ugc nofollow" target="_blank"> Ploomber </a>来说很简单。假设您有三个笔记本(<code class="fe mx my mz na b">load.ipynb</code>、<code class="fe mx my mz na b">clean.ipynb</code>和<code class="fe mx my mz na b">plot.ipynb</code>)，您可以创建一个管道来按如下顺序执行它们:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="eb9f" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">然后，您可以使用以下命令运行它们:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="2d57" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">Ploomber将按顺序执行笔记本，并为每个笔记本制作一份副本，因此您可以记录这次运行的输出。</p><p id="7eb9" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">试试吧！</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="b3ea" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">模块化的笔记本打开了许多可能性:它们更容易协作、测试，并且计算效率高(你可以并行运行独立的笔记本！).所以，<strong class="lg ja">我们非常鼓励你写流水线，而不是大块头的笔记本。</strong></p><h1 id="24fb" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">那么，真正的问题是什么？</h1><h2 id="4910" class="nh mb iq bd mc ni nj dn mg nk nl dp mk ln nm nn mm lr no np mo lv nq nr mq iw bi translated">隐藏状态</h2><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ns"><img src="../Images/9d545aeda27be287d4075b42ddf94565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wGBmrPD-xbO-CC41av7VoA.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">笔记本的隐藏状态阻碍了再现性。图片作者。</p></figure><p id="6066" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">给定一个笔记本，我们说它有一个隐藏状态，当它线性地返回不同于存储的输出时。例如，左边的笔记本没有隐藏状态，因为如果您重新启动内核并按顺序运行所有单元，您将得到相同的结果(数字<code class="fe mx my mz na b">3</code>)。但是，右边的笔记本有隐藏状态:如果我们重新启动内核，按顺序运行所有细胞，最终输出不会匹配(记录的是<code class="fe mx my mz na b">42</code>，但我们会得到<code class="fe mx my mz na b">3</code>)。这个问题如此普遍，甚至有一篇关于它的自然博客文章。隐藏使得不可能重现我们的结果。</p><p id="5ea7" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们可以通过测试来部分解决这个问题:我们可以在每个<code class="fe mx my mz na b">git push</code>上线性执行我们的笔记本，以确保可重复的结果。然而，这并没有完全解决问题，因为我们仍然可能在笔记本开发期间以隐藏状态结束，直到我们推到存储库和CI中断时才发现。</p><p id="41e7" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">一种流行的方法是反应式笔记本，它自动重新计算单元格以防止隐藏状态。例如，假设我有一个这样的笔记本:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/3bb4750bb5b6f16c361258c99bcb4844.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*EaL0JUBxTKIEb9dR6YbYIQ.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">反应式内核是隐藏状态的一种解决方案。图片作者。</p></figure><p id="cf0c" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">如果我运行一个反应式笔记本并编辑单元格<code class="fe mx my mz na b">a = 1</code>，笔记本将自动运行第三和第四个单元格(<code class="fe mx my mz na b">total = a + b</code>和<code class="fe mx my mz na b">total</code>)，因为它们依赖于<code class="fe mx my mz na b">a</code>的值，有效地更新和打印<code class="fe mx my mz na b">total</code>变量的新值。反应性是Julia的笔记本系统Pluto已经提供的一个很好的特性，它也可以在一些Jupyter商业发行版中使用。幸运的是，人们已经在为Jupyter 中的<a class="ae nc" href="https://discourse.jupyter.org/t/dag-based-notebooks/11173/2" rel="noopener ugc nofollow" target="_blank">反应式内核开发开源解决方案。</a></p><p id="f68f" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">然而，反应式内核也有局限性。在许多情况下，一些单元可能太昂贵而无法重新计算，如果运行一个看似很小的计算突然触发一个小时的计算，这可能会导致用户沮丧。反应式内核应该被强制到什么程度，或者我们应该建立什么样的替代品，这是一个值得讨论的话题。</p><h2 id="dbd1" class="nh mb iq bd mc ni nj dn mg nk nl dp mk ln nm nn mm lr no np mo lv nq nr mq iw bi translated">代码质量</h2><p id="557c" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">笔记本中的代码质量是我发现的最吸引人的问题，因为它总是导致从不同方面解决问题的观点。<strong class="lg ja">代码质量是目前笔记本最大的问题。</strong></p><p id="1026" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">许多人认为笔记本会导致糟糕的代码质量。这是真的吗？我不这么认为。低质量的代码到处存在；这不是木星独有的问题。我的看法是，笔记本中有如此多难以阅读的代码，是因为Jupyter使计算大众化了。你不再需要掌握一个IDE和一个终端来开发数据分析代码；你可以打开笔记本，马上开始。所以突然之间，我们有很多没有软件背景的人在所有行业中作为数据科学家工作，这是一件非常棒的事情。每个人都应该有机会编码和创造价值，Jupyter是许多人进入计算世界的入口。</p><p id="271e" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">问题不在于笔记本产生低质量的代码。作为一个社区，我们未能指导那些知道很多统计学和机器学习但没有多少编码经验的人。低质量笔记本电脑的普遍存在是缺乏开发和部署数据分析代码流程的结果。几乎没有任何数据团队将代码评审作为他们开发过程的一部分，那么我们如何期望我们成为好的导师并帮助提升我们同事的技能呢？</p><h1 id="6062" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">总结想法</h1><p id="672d" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">笔记本是探索和分析数据的最佳方式，但它们有问题。因此，我希望我们能够从<em class="nd">笔记本无法版本化</em>的对话中继续，开始更多地讨论如何改进基于笔记本的开发和部署流程。在Ploomber，我们坚信最大化数据团队交付价值的速度是笔记本电脑的核心。因此，我们正在努力解决所有笔记本电脑问题，以在功能交互性和定义良好的开发和部署流程的可靠性之间找到最佳平衡点。<a class="ae nc" href="https://ploomber.io/community" rel="noopener ugc nofollow" target="_blank">加入我们的社区</a>让对话继续下去。</p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><p id="c1a2" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><em class="nd">最初发布于</em><a class="ae nc" href="https://ploomber.io/blog/nbs-myths/" rel="noopener ugc nofollow" target="_blank"><em class="nd">ploomber . io</em></a></p></div></div>    
</body>
</html>