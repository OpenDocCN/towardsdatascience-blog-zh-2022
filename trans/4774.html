<html>
<head>
<title>Be Careful When Using Pandas Groupby with Categorical Data Type</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在对分类数据类型使用Pandas Groupby时要小心</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/be-careful-when-using-pandas-groupby-with-categorical-data-type-a1d31f66b162#2022-10-24">https://towardsdatascience.com/be-careful-when-using-pandas-groupby-with-categorical-data-type-a1d31f66b162#2022-10-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4fd1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为了避免意外的结果</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4b603dd8502ae735625430ece8599225.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2yl_6AOFzkA6ImI-k1_iDQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com/s/photos/warning?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@ahsanjaya?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Muhammad Daudy </a>拍摄的照片</p></figure><p id="2f20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在统计学中，<a class="ae ky" href="https://en.wikipedia.org/wiki/Categorical_variable" rel="noopener ugc nofollow" target="_blank">分类变量</a>是一个变量，它可以取有限的、通常是固定数量的可能值中的一个。Pandas有一个专用于分类变量的数据类型，即category。</p><p id="cc5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某些情况下，使用category数据类型非常有用且高效。例如，如果您的字符串或对象列只包含几个不同的值，将其转换为类别数据类型将节省大量内存。</p><p id="bbd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了比较内存使用情况，让我们首先创建一个Pandas系列，它包含三百万行三种不同的字符串，数据类型为string。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6519" class="ma mb it lw b gy mc md l me mf">import pandas as pd</span><span id="5279" class="ma mb it lw b gy mg md l me mf">names = pd.Series(["John", "Jane", "James"] * 1000000, dtype="string")</span><span id="fc38" class="ma mb it lw b gy mg md l me mf">names.memory_usage()<br/><strong class="lw iu"># output</strong><br/>24000128</span></pre><p id="cfb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它占用了大约2400万字节的空间。让我们用category数据类型来试试。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4ad5" class="ma mb it lw b gy mc md l me mf">names = pd.Series(["John", "Jane", "James"] * 1000000, dtype="category")</span><span id="613a" class="ma mb it lw b gy mg md l me mf">names.memory_usage()<br/><strong class="lw iu"># output</strong><br/>3000260</span></pre><p id="1f77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">内存使用量减少到300万，比字符串数据类型的内存使用量少8倍。</p><p id="f263" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">category数据类型允许为一个列强制一组可能的值。如果试图赋一个不在指定类别中的值，将引发类型错误。因此，具有类别数据类型的列中的所有值要么在给定的类别中，要么缺少值(即np.nan或None)。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><p id="fe73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到我们对数据类型为category的列上的groupby函数的讨论，有一点您应该注意。</p><p id="bb80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个包含两列的示例数据框架，其中一列是包含3个类别的类别数据类型。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7313" class="ma mb it lw b gy mc md l me mf">df = pd.DataFrame({<br/>    "col1": pd.Categorical(<br/>        ["A", "A", "B", "A", "B"], <br/>        categories=["A","B","C"], <br/>        ordered=False<br/>    ),<br/>    "col2": [10, 14, 20, 25, 23]<br/>})</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/2f01109fc2eff0d617fdcc61a85b287a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XawXXRof9W5ULt4BLUrJPw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">df(作者图片)</p></figure><p id="5419" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列col1的数据类型是具有值A、B或c的类别。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="35e6" class="ma mb it lw b gy mc md l me mf">df["col1"]<br/><strong class="lw iu"># output</strong><br/>0    A<br/>1    A<br/>2    B<br/>3    A<br/>4    B<br/>Name: col1, dtype: category<br/>Categories (3, object): ['A', 'B', 'C']</span></pre><p id="21b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们对该列使用groupby函数时，尽管DataFrame的col1列中不包含带有C的行，但类别C仍会出现在结果中。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ca0a" class="ma mb it lw b gy mc md l me mf">df.groupby("col1")["col2"].sum()<br/><strong class="lw iu"># output</strong><br/>col1<br/>A    49<br/>B    43<br/>C     0<br/>Name: col2, dtype: int64</span></pre><p id="145d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过将observed参数的值设置为True来改变这种行为，这将只返回在DataFrame中观察到的值。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5541" class="ma mb it lw b gy mc md l me mf">df.groupby("col1", observed=True)["col2"].sum()<br/><strong class="lw iu"># output</strong><br/>col1<br/>A    49<br/>B    43<br/>Name: col2, dtype: int64</span></pre></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h2 id="b3b4" class="ma mb it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">棘手的部分</h2><p id="dfdb" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">棘手的部分是当我们在数据类型为category的列中缺少值时。让我们在category列中添加一个缺少值的新行。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7e3c" class="ma mb it lw b gy mc md l me mf">import numpy as np</span><span id="656f" class="ma mb it lw b gy mg md l me mf">df.loc[5,:] = [np.nan, 30]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/d21103c4157adecb4cbd4e84d3f83e0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*odZ2usXKaBRBj05CY_IO6Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">df(作者图片)</p></figure><p id="23de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，groupby函数不显示缺失值的聚合值。因此，如果我们按col1列对行进行分组，我们将不会在结果中看到NaN组。我们可以通过使用dropna参数并将其值设置为False来更改此设置。在其他数据类型中，此更改将在结果中包括NaN组。但是，它不适用于类别数据类型。</p><p id="8384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来做几个例子说清楚。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6b2d" class="ma mb it lw b gy mc md l me mf">df.groupby("col1", dropna=False)["col2"].sum()<br/><strong class="lw iu"># output</strong><br/>col1<br/>A    49.0<br/>B    43.0<br/>C     0.0<br/>Name: col2, dtype: float64</span></pre><p id="30e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使我们使用观测参数，结果也是一样的。它将只移除未观察到的类别，但丢失的值不会显示在输出中。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="175e" class="ma mb it lw b gy mc md l me mf">df.groupby("col1", observed=True, dropna=False)["col2"].sum()<br/><strong class="lw iu"># output</strong><br/>col1<br/>A    49.0<br/>B    43.0<br/>Name: col2, dtype: float64</span></pre><p id="7525" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是类别数据类型的问题，在<a class="ae ky" href="https://pandas.pydata.org/docs/whatsnew/v1.5.1.html" rel="noopener ugc nofollow" target="_blank">新版本</a>文档中有提及。如果数据类型是string或object，dropna参数将按预期工作。让我们通过将数据类型更改为string来进行确认。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="82e5" class="ma mb it lw b gy mc md l me mf">df["col1"] = df["col1"].astype("string")<br/>df.groupby("col1", dropna=False)["col2"].sum()<br/><strong class="lw iu"># output</strong><br/>col1<br/>A       49.0<br/>B       43.0<br/>&lt;NA&gt;    30.0<br/>Name: col2, dtype: float64</span></pre><p id="d823" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们在输出中将缺失的值视为一组。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><p id="add8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能不是一个重要的问题，但绝对是我们需要记住的事情。我们经常会遇到原始数据中的缺失值，应该把它们考虑进去。否则，我们可能会得到意想不到的结果或不可靠的模型。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><p id="1859" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nm">你可以成为</em> <a class="ae ky" href="https://sonery.medium.com/membership" rel="noopener"> <em class="nm">媒介会员</em> </a> <em class="nm">解锁我的全部写作权限，外加其余媒介。如果你已经是了，别忘了订阅<em class="nm"/><em class="nm">如果你想在我发表新文章时收到电子邮件。</em></em></p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><p id="9bf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。如果您有任何反馈，请告诉我。</p></div></div>    
</body>
</html>