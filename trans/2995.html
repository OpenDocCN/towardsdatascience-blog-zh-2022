<html>
<head>
<title>Digit Classification with Single-Layer Perceptron</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于单层感知器的数字分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/digit-classification-with-single-layer-perceptron-9a4e7d4d9628#2022-06-30">https://towardsdatascience.com/digit-classification-with-single-layer-perceptron-9a4e7d4d9628#2022-06-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="244b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从零开始构造单层感知器及其在二进制数字分类中的应用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f1f7ec7c05c28e07084b7e13afa9fe32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KHdLncCjG3xUwcxY"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@waldemarbrandt67w?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Waldemar Brandt </a>拍照</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="1ae0" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi mc translated"><span class="l md me mf bm mg mh mi mj mk di"> G </span>一般来说，当一个人要对图像应用监督学习技术时，首先想到的是利用卷积神经网络(CNN)。事实上，这种类型的神经网络最适合这种类型的任务，主要是由于维数的减少。</p><p id="999f" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果我们想象一个图像数据集，其中的图像已经被展平(例如，一个4x4矩阵的图像被转换为16维向量，如图<em class="ml">图1 </em>所示)，这些图像是n维空间中的数据点，其中n是图像中的像素数。可以推断，当我们谈论图像时，数据的维度是巨大的，因此这意味着在神经网络中有大量的参数，这反过来导致更高的计算成本和执行时间。CNN在神经网络的每一层中减少了图像的维度，也减少了训练中所需的参数数量，并优化了这类任务的模型性能。有关CNN的更多信息可在本出版物中找到:</p><div class="mm mn gp gr mo mp"><a rel="noopener follow" target="_blank" href="/a-comprehensive-guide-to-convolutional-neural-networks-the-eli5-way-3bd2b1164a53"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd iu gy z fp mu fr fs mv fu fw is bi translated">卷积神经网络综合指南ELI5方法</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">人工智能见证了人类能力差距的巨大增长…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">towardsdatascience.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd ks mp"/></div></div></a></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/9945e5679e1dc79e6655672f8fb85b03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vkp1GqW_3jD4TkpB14XXmA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd nf">图一。</strong>图像的展平。作者图片</p></figure><p id="6f23" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">另一方面，本文旨在通过单层感知器来解决数字图像的二进制分类，这是一种比CNN更简单、更古老的架构，因此尽管其起源过早，但仍展示了其巨大的潜力，并为任何想要了解深度神经网络(DNNs)和最新深度学习模型如何工作的人提供了一个良好的起点。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="5c8e" class="ng nh it bd ni nj nk dn nl nm nn dp no lp np nq nr lt ns nt nu lx nv nw nx ny bi translated">感知器</h2><p id="c642" class="pw-post-body-paragraph lg lh it li b lj nz ju ll lm oa jx lo lp ob lr ls lt oc lv lw lx od lz ma mb im bi translated">感知机是由心理学家弗兰克·罗森布拉特在1957年发明的，它由一个能够执行二元分类任务的线性鉴别器组成。虽然感知器很快就开始用于使用数字特征来训练它的分类，但Rosenblatt最初的目的是使用感知器进行图像分类，这最终在1962年实现，并在这里再次复制。</p><p id="2221" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">感知器可以很容易地理解为一个数学函数，因为它接收大量的输入并从中获得一个结果。这些输入是训练数据集中数据点的每个维度的值。正如我们之前所说，当我们处理展平的图像时，数据点属于一个n维的空间，其中n是像素的数量。感知器因此接收n个输入。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/77dfc54be7b7033cf4ee385b013a79e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rwrPkwYbrqr4eYF8wuSXTg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd nf">感知器。</strong>作者图片</p></figure><p id="3b12" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">上图中感知机的数学函数定义如下。当y为0时，该等式是n维空间上的超平面的等式(0 = <strong class="li iu"> w x </strong> + b，其中<strong class="li iu"> w </strong>和<strong class="li iu"> x </strong>都是n维向量)，该等式将用于根据数据点在超平面的哪一侧来将点分类为一类或另一类。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/58770a017768e516d29904c8c702195f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*_fChcmbVxNofcSub6ey9uA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd nf">感知器的数学函数。</strong>作者图片</p></figure><p id="46ad" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">所以感知器接收输入向量<strong class="li iu"> <em class="ml"> x </em> </strong>，但是<strong class="li iu"> <em class="ml"> w </em> </strong>和<em class="ml"> b </em>在函数中取什么值呢？这些值分别是权重和偏差，是感知器在训练过程中必须学习的参数。</p><p id="d32e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">此时，感知器的高级操作被定义:它接收一个n维向量作为输入，用训练好的权重应用它的函数，并返回一个值；这个值将是负的或正的，这取决于它在划分超平面的哪一侧。</p><p id="da81" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">感知器的结果，如上所述是正值或负值，通过激活函数映射到其相应的类。这个功能可以在<em class="ml">图2中看到。</em>，映射到0或1时称为阶跃函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/091f27ec2616f73ec6a40d94bcaa7b7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*4l6IpnBqhDsvgTcNcW_J8w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd nf">图二。</strong>步进功能。作者图片</p></figure><p id="9212" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">用于从感知器获得预测的代码以及激活函数的定义如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="bdf0" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">只剩下一件事需要理解。感知器如何学习哪些权重是最佳的，以最佳地执行分类？接下来的步骤将展示负责优化感知器权重的算法的逻辑，以及实现它的代码。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="ac57" class="ng nh it bd ni nj nk dn nl nm nn dp no lp np nq nr lt ns nt nu lx nv nw nx ny bi translated"><strong class="ak"> 1。正向传播</strong></h2><p id="df81" class="pw-post-body-paragraph lg lh it li b lj nz ju ll lm oa jx lo lp ob lr ls lt oc lv lw lx od lz ma mb im bi translated">首先，将训练数据集中的一个数据点加载到感知器中，并计算感知器函数的结果。对这个输出应用激活函数得到最终预测，最后通过比较预测值和真实值得到损耗。</p><p id="3315" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">要最小化的变量<strong class="li iu">误差</strong>或<strong class="li iu">损失</strong>通过对实际值和预测值之间的差值求平方来计算(在这种特殊情况下)，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/eeb06e81424d6b814dc108558e554bf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:410/format:webp/1*Px_cpawovC_lPX8uz73Lqg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd nf">误差/损失函数。</strong>作者图片</p></figure><p id="6b31" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在这种情况下，前向函数将利用它已经做出的预测来计算误差和误差对预测y的偏导数(计算该偏导数的原因和有用性在下面的步骤中解释)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="18a3" class="ng nh it bd ni nj nk dn nl nm nn dp no lp np nq nr lt ns nt nu lx nv nw nx ny bi translated">2.<strong class="ak">反向传播</strong></h2><p id="39e5" class="pw-post-body-paragraph lg lh it li b lj nz ju ll lm oa jx lo lp ob lr ls lt oc lv lw lx od lz ma mb im bi translated">计算损失相对于每个权重的偏导数。这些都是通过应用链式法则来计算的，链式法则将导数一分为二，大大简化了计算过程。这些偏导数是在感知器中的每个权重上计算的，并将在以后的优化过程中使用。</p><p id="09c1" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">计算这些偏导数(更好地称为<strong class="li iu">梯度</strong>)的理论原因是，它们形成了一个向量，指示在何处更新感知器的权重向量(<strong class="li iu"> <em class="ml"> w </em> </strong>),以使损失最小化。为了更好地理解它，如果我们考虑三维图中的损失函数r(看起来像一组山)，梯度向量(<em class="ml"> d </em> <strong class="li iu"> <em class="ml"> W </em> </strong>)将具有3个值/维度，将指示到达局部或全局最小值(或者继续类推，到达山的最低点)所遵循的方向，从而允许我们在每次迭代中最小化损失。有关渐变的更多信息，请访问本文:</p><div class="mm mn gp gr mo mp"><a href="https://machinelearningmastery.com/gradient-in-machine-learning/" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd iu gy z fp mu fr fs mv fu fw is bi translated">什么是机器学习中的梯度？-机器学习精通</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">梯度是最优化和机器学习中常用的术语。例如，深度学习神经网络是…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">machinelearningmastery.comwei</p></div></div><div class="my l"><div class="ok l na nb nc my nd ks mp"/></div></div></a></div><p id="1d1e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">下面你可以看到基于链式法则计算偏导数的数学发展。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/37db48bf5a8d987efb2fd4f99c407af5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*SsQXiZDCQGlAssJrHpel6g.png"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="6e87" class="ng nh it bd ni nj nk dn nl nm nn dp no lp np nq nr lt ns nt nu lx nv nw nx ny bi translated">3.权重更新</h2><p id="6594" class="pw-post-body-paragraph lg lh it li b lj nz ju ll lm oa jx lo lp ob lr ls lt oc lv lw lx od lz ma mb im bi translated">权重按照下面所示的等式更新(注意，<strong class="li iu"> <em class="ml"> W </em> </strong>和<strong class="li iu"> <em class="ml"> w </em> </strong>沿着文章可互换使用)。导数向量<em class="ml"> d </em> <strong class="li iu"> <em class="ml"> W </em> </strong>已经从反向传播步骤中获得，并且学习速率<strong class="li iu"> <em class="ml"> η </em> </strong>是由用户设置的超参数，其将影响感知机学习的速度。非常低的值会导致算法陷入局部最小值，而太高的值会使算法永远不会收敛。因此，学习率是一个必须仔细确定的参数，通常通过试错法或基于以前的研究。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/53b65310e57c418967c11a69bf8c4742.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*nUIHMeN009vevegP_F8vEQ.png"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="ec94" class="ng nh it bd ni nj nk dn nl nm nn dp no lp np nq nr lt ns nt nu lx nv nw nx ny bi translated">4.优化感知器</h2><p id="5765" class="pw-post-body-paragraph lg lh it li b lj nz ju ll lm oa jx lo lp ob lr ls lt oc lv lw lx od lz ma mb im bi translated">优化将存在于一个循环中，该循环将重复上述三个步骤，重复用户想要的<strong class="li iu">个时期</strong>(迭代)。每次迭代将选取训练数据的每个值，对其应用前向传播和后向传播，并相应地更新权重。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="e71b" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">感知器的底层功能已经被理解，将其应用于图像的二值分类是可行的。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="2ec0" class="ng nh it bd ni nj nk dn nl nm nn dp no lp np nq nr lt ns nt nu lx nv nw nx ny bi translated">数字分类</h2><p id="0880" class="pw-post-body-paragraph lg lh it li b lj nz ju ll lm oa jx lo lp ob lr ls lt oc lv lw lx od lz ma mb im bi translated">单层感知器只能进行线性分离，因此只能进行二进制分类，所以只能从数据集中的9个数字中选择两个数字。在这种情况下，选择0和1，因为在计算机科学的应用中，机器可以提供更大的效用来分类0和1。除了提取与所选数字对相关的数据之外，还需要将标签的值转换为0和1(在这种情况下没有必要，因为标签已经是0和1，但是对于任何其他值对来说都是如此)，或者改变激活函数，以便将感知器的输出映射到一个值或另一个值。映射到0和1的常量激活函数，以及将任意一对数字的标签更改为0和1的数据预处理管道，似乎是这项任务的最佳选择。</p><p id="7e0a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">第一步是加载数据集并过滤标签为0和1的实例。然后，创建一个训练集和测试集，并依次划分为用于训练的标签和特征。此外，数据点被重新调整为0到1之间的值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="cc07" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如前所述，感知器接受一个向量作为输入，该向量的维数与图像中的像素数一样多。许多图像数据集将图像存储为矩阵，因此在这种情况下，有必要将这些矩阵转换为矢量。还需要注意的是，数据集通常以CSV文件的形式出现，由于其表格性质，很难将图像存储为矩阵。因此，大多数CSV格式的图像数据集将图像存储为矢量而不是度量。</p><p id="c93b" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在这种特殊情况下，要使用的数据集包含作为向量的数据点，因此在预处理期间没有必要展平图像。然而，在下面你可以看到在矩阵形式的图像数据集上展平图像的代码。这只是将每个数据点从一个矩阵<em class="ml">m×l</em>重新整形为一个矢量<em class="ml">n×1</em>，即<em class="ml">n = m×l</em>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="bb17" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">一旦数据被预处理，之前构建的感知器被训练。在<strong class="li iu"><em class="ml"/>optimize _ perceptron()<em class="ml"/></strong>函数的主<em class="ml"> while </em>循环的条件中可见，为训练设置的两个停止条件是时期数和误差:如果达到最大时期数或损失低于给定阈值，则训练结束。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/89d653cb016a39855f692c4fab20692b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oTGBFYfnPVEGZWUe_m3PDA.png"/></div></div></figure><p id="4869" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">现在权重已经被优化了，有趣的是注意到感知机学到了什么。经过训练的权重向量在视觉上不能给出太多信息，但是如果将其转换为28×28矩阵，我们将能够看到感知器给予训练图像的哪些像素更大的重要性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/2e6f462572d130bf8276a1ab0f600e90.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*lczmAinIzyjniE2FQBPDyQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd nf">训练过的重量。</strong>作者图片</p></figure><p id="653e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">感知器的权重显示零的形状！画出0形状的像素具有暗色调，这意味着这些权重是负的并且具有高绝对值。因此，当这些像素通过接收零而被激活时，感知器的结果将是负的，因为那些权重是负的。相比之下，1预期通过图像的中心，因此具有正值的重要权重在图像的中心，从而当感知器接收到1的图像时，其输出为正。用测试数据集评估感知机的准确性将确认机器已经学会区分类别，正如权重形成的图像似乎显示的那样。</p><p id="0efc" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">通过获得测试数据集中所有图像的预测，并将正确预测的数量除以总预测来计算准确度函数。函数的实现可以在我的GitHub资源库中找到。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/9e89098fab20a7d9aafbc0c4015f4eb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*2iEteA9j_oIGq9_HHcWosQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd nf">准确度。</strong>图片由用户提供</p></figure><p id="0b12" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">感知器取得了99.72%的准确率，令人难以置信的好成绩！它成功地对测试数据集中的2204幅图像中的2198幅进行了正确分类，这意味着它已经正确地学习了该任务，并且能够将该知识推广到它从未见过的图像。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="9873" class="ng nh it bd ni nj nk dn nl nm nn dp no lp np nq nr lt ns nt nu lx nv nw nx ny bi translated"><strong class="ak">结论</strong></h2><p id="dceb" class="pw-post-body-paragraph lg lh it li b lj nz ju ll lm oa jx lo lp ob lr ls lt oc lv lw lx od lz ma mb im bi translated">在观察了在二进制数字分类中获得的结果之后，可以说Frank Rosenblatt在建立图像分类器的愿望方面做得非常好。此外，深度学习领域年复一年的进步表明，罗森布拉特奠定了该学科绝大多数发展所基于的基础。</p><p id="7ec2" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">最后，值得注意的是，在像数字分类这样复杂的任务中，从1957年的算法中可以获得的结果是惊人的。虽然感知器的性质排除了多类分类，但通过将若干训练与数字对的所有组合相结合，可以构建9类数字分类器，这在当时是一项真正令人惊叹的技术！</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="acae" class="ng nh it bd ni nj nk dn nl nm nn dp no lp np nq nr lt ns nt nu lx nv nw nx ny bi translated">完整代码</h2><p id="1fc7" class="pw-post-body-paragraph lg lh it li b lj nz ju ll lm oa jx lo lp ob lr ls lt oc lv lw lx od lz ma mb im bi translated">所有的功能都可以在我的GitHub存储库中找到，还有一个真实的运行示例Jupyter Notebook和用于训练的数据集。</p><p id="1256" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">尽管如此，尝试理解其功能，并亲自对其进行编程仍然是一个很好的练习！</p><p id="3929" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果你喜欢这篇文章和/或觉得它有用，请关注我以后的文章，分享这篇文章，这样其他人也可以学习。非常感谢您的阅读和支持！</p><p id="2788" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="li iu"> GitHub库</strong>:</p><div class="mm mn gp gr mo mp"><a href="https://github.com/JavierMtz5/ArtificialIntelligence" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd iu gy z fp mu fr fs mv fu fw is bi translated">GitHub-Javier mtz 5/人工智能</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">github.com</p></div></div><div class="my l"><div class="oq l na nb nc my nd ks mp"/></div></div></a></div></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="839f" class="ng nh it bd ni nj nk dn nl nm nn dp no lp np nq nr lt ns nt nu lx nv nw nx ny bi translated">数据</h2><p id="82c7" class="pw-post-body-paragraph lg lh it li b lj nz ju ll lm oa jx lo lp ob lr ls lt oc lv lw lx od lz ma mb im bi translated">本文使用的数据摘自ka ggle competition<strong class="li iu">数字识别器</strong>的名为<em class="ml"> train.csv </em>的数据集，可以在下面的链接中找到。该数据集在<a class="ae ky" href="https://creativecommons.org/licenses/by-sa/3.0/" rel="noopener ugc nofollow" target="_blank">知识共享署名-共享3.0许可</a>下可用。</p><div class="mm mn gp gr mo mp"><a href="https://www.kaggle.com/competitions/digit-recognizer/overview" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd iu gy z fp mu fr fs mv fu fw is bi translated">数字识别器</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">用著名的MNIST数据学习计算机视觉基础</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">www.kaggle.com</p></div></div><div class="my l"><div class="or l na nb nc my nd ks mp"/></div></div></a></div></div></div>    
</body>
</html>