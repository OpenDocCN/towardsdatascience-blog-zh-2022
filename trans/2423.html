<html>
<head>
<title>When a Count Goes Mad, or How to Count Orders over Time in DAX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当一个计数变得疯狂时，或者如何在DAX中计数订单</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/when-a-count-goes-mad-or-how-to-count-orders-over-time-in-dax-850b55145f3#2022-05-26">https://towardsdatascience.com/when-a-count-goes-mad-or-how-to-count-orders-over-time-in-dax-850b55145f3#2022-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5392" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">当我们不得不扩大我们的范围，纳入比本期可见订单更多的订单时，会发生什么？</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/2f19fd76ca19ff1450f59fb991116abd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YxMvvmZXd-fMpfXF"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@isaacmsmith?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">艾萨克·史密斯</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="39db" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">我的委托人要求的</h1><p id="f1d0" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">我的一个客户问了我以下两个问题:</p><ol class=""><li id="e0fa" class="mo mp it lu b lv mq ly mr mb ms mf mt mj mu mn mv mw mx my bi translated">我想统计所有订单，包括特定期间的未结订单</li><li id="bc26" class="mo mp it lu b lv mz ly na mb nb mf nc mj nd mn mv mw mx my bi translated">我希望根据一段时间内的订单数量对客户进行分类</li></ol><p id="df79" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">这两个问题看似简单，但经过一番思考，我不得不再三考虑可能的解决方案。</p><p id="0dfa" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">要解决这两个问题，我们必须操作过滤器上下文，以包含比当前过滤器上下文中可见的更多的行。</p><p id="5199" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">现在，我将一次解决一个问题，并描述我是如何试图解决这些挑战的，以及在解决第二个挑战时，在找到正确的方法之前，我是如何走上错误的道路的。</p><h1 id="a1ef" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">数据模型</h1><p id="0d80" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">我在本文中使用了Contoso数据模型(参见下面的源代码和许可信息)。</p><p id="ab92" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">数据模型如下图所示:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nh"><img src="../Images/6560166b1ee51f6ea0ba7cb222150f81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zKXLfY8gcABZZzR8w0mkMQ.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">图1 —数据模型</p></figure><p id="1f10" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">在线销售表与日期表有三种关系:</p><ul class=""><li id="ade7" class="mo mp it lu b lv mq ly mr mb ms mf mt mj mu mn ni mw mx my bi translated">订单日期至今</li><li id="1abb" class="mo mp it lu b lv mz ly na mb nb mf nc mj nd mn ni mw mx my bi translated">截止日期至今(无效)</li><li id="ec68" class="mo mp it lu b lv mz ly na mb nb mf nc mj nd mn ni mw mx my bi translated">发货日期至今(无效)</li></ul><h1 id="d0fe" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">第一个问题的挑战</h1><p id="be9b" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">第一步是为期望的结果定义一个真值表。</p><p id="edc1" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">我们需要这样一个表来指定期望的结果:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/cf8463910abdc3ab360783abc76b8ede.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*CHKa85j8u1wOJ-Ic7wexFg.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">图2 —未结订单的真值表</p></figure><p id="5b81" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">如您所见，在观察期开始前创建但在观察期内发货的每个订单都被定义为未结订单。</p><p id="da29" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">此外，在观察期间创建的所有订单都必须包括在计数中。</p><h1 id="265d" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">DAX中的解</h1><p id="0bbc" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">为了满足需求，我们需要创建两个度量。</p><p id="1271" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">1.简单订单计数</p><p id="61d3" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">该度量对事实表中的订单数进行计数。</p><p id="c4a0" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">由于每个订单有几个订单行(订单中的每个产品一个)，我必须使用DISTINCTCOUNT()函数来度量:</p><pre class="kk kl km kn gt nk nl nm nn aw no bi"><span id="4603" class="np lb it nl b gy nq nr l ns nt">Online Order Count = DISTINCTCOUNT(‘Online Sales’[Sales Order Number])</span></pre><p id="2300" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">此度量返回当前筛选器上下文中的订单数。</p><p id="9d7a" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">2.活动订单计数</p><p id="7f48" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">这个衡量标准稍微复杂一点:</p><p id="a716" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">我必须包含所有OrderDate在观察期开始之前的未结订单(Date表的实际过滤上下文)。</p><p id="631a" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">这是衡量标准:</p><pre class="kk kl km kn gt nk nl nm nn aw no bi"><span id="3b08" class="np lb it nl b gy nq nr l ns nt">Online order count (open orders) =</span><span id="9871" class="np lb it nl b gy nu nr l ns nt">VAR FirstActualDate = MIN( ‘Date’[Date] )</span><span id="7d74" class="np lb it nl b gy nu nr l ns nt">VAR ActiveOrders =<br/>    CALCULATE(<br/>        [Online Order Count]<br/>        ,CROSSFILTER(‘Online Sales’[OrderDate], ‘Date’[Date], NONE)<br/>        ,’Online Sales’[OrderDate] &lt; FirstActualDate<br/>          &amp;&amp; ‘Online Sales’[ShipDate] &gt;= FirstActualDate<br/>        )</span><span id="9ea3" class="np lb it nl b gy nu nr l ns nt">RETURN<br/>    ActiveOrders</span></pre><p id="41b8" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">我使用[在线订单计数]来统计订单。</p><p id="5eb6" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">然后，我使用CROSSFILTER()禁用与数据表的活动关系。</p><p id="6880" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">此函数确保过滤器上下文不会应用于此计算。<br/>或者，您可以使用ALL('Date ')来删除日期表上的实际过滤上下文。</p><p id="ab94" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">然后，我使用在度量开始时定义的变量FirstActualDate，只包含在实际周期/过滤器上下文之前创建但尚未发货的订单。</p><p id="6c2e" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">我试图编写一个度量来获取当前过滤器上下文中的所有订单和所有未结订单，如上面的真值表中所定义的。但是这种方法会导致非常复杂的测量。</p><p id="839f" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">因此，我决定更改度量的最后一行，将[在线订单计数]度量和新度量加在一起，以获得正确的结果:</p><pre class="kk kl km kn gt nk nl nm nn aw no bi"><span id="a2e7" class="np lb it nl b gy nq nr l ns nt">RETURN<br/>    [Online Order Count] + ActiveOrders</span></pre><p id="e69a" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">通过这一步，我可以用一种简单的方法在结果中包含所有其他订单。</p><h1 id="5f9d" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">第二个问题的挑战</h1><p id="ce2f" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">这个要复杂得多。</p><p id="0129" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">确切的要求如下:</p><p id="dad3" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">必须对每个客户进行观察，并根据过去180天的订单数量对其进行分类(以下要求根据我的客户的原始要求改编为Contoso数据集)。</p><ol class=""><li id="f6c1" class="mo mp it lu b lv mq ly mr mb ms mf mt mj mu mn mv mw mx my bi translated">当客户下的订单少于20份时，该客户必须归类为“待联系”</li><li id="3d36" class="mo mp it lu b lv mz ly na mb nb mf nc mj nd mn mv mw mx my bi translated">当客户下了21到35份订单时，该客户必须被归类为“普通客户”</li><li id="b0ad" class="mo mp it lu b lv mz ly na mb nb mf nc mj nd mn mv mw mx my bi translated">当客户下了36到50份订单时，该客户必须被归类为“好客户”</li><li id="abcb" class="mo mp it lu b lv mz ly na mb nb mf nc mj nd mn mv mw mx my bi translated">当客户下了超过50份订单时，该客户必须被归类为“非常好的客户”</li></ol><p id="076c" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">我的客户强调计算每天和每个顾客的分类。</p><p id="07f9" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">在这个阶段，单一客户并不那么重要。但是随着时间的推移，观察所有客户的发展是至关重要的。</p><p id="8879" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">我的第一个想法是这样的:我需要知道每个客户的订单之间的距离。然后尝试根据这些信息计算每个客户的类别。</p><p id="1059" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">获得这个结果的最直接的方法是创建一个计算列。</p><p id="0b1e" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">另一种方法是创建一个衡量标准并动态计算这些信息。</p><p id="bb40" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">每种方法都有优点和缺点。但是我确信计算列可以支持该解决方案，因为随着时间的推移，每个客户都会在类别之间发生变化。</p><p id="9c53" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">但最终的解决方案是一个措施，因为客户可以在一个月内创建100个订单，但在接下来的三个月内只能创建10个，随着时间的推移，他将转移到另一个类别。</p><h1 id="38b9" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">在达克斯寻找解决方案的路上</h1><p id="f843" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">第一步是获得每个订单之间的天数距离作为计算列:</p><pre class="kk kl km kn gt nk nl nm nn aw no bi"><span id="9fab" class="np lb it nl b gy nq nr l ns nt">DistanceToPrevOrder =<br/>    VAR CurrentCust = ‘Online Sales’[CustomerKey]<br/>    VAR CurrentDate = ‘Online Sales’[OrderDate]</span><span id="f35a" class="np lb it nl b gy nu nr l ns nt">    VAR PrevOrder = CALCULATE ( MAX(‘Online Sales’[OrderDate])<br/>                       ,FILTER(‘Online Sales’<br/>                       ,’Online Sales’[CustomerKey] = CurrentCust<br/>                         &amp;&amp; ‘Online Sales’[OrderDate] &lt; CurrentDate)<br/>                       )</span><span id="f1db" class="np lb it nl b gy nu nr l ns nt">VAR OrderDistanceDay =<br/>    IF (NOT ISBLANK(PrevOrder), INT ( CurrentDate — PrevOrder ) )</span><span id="1ae0" class="np lb it nl b gy nu nr l ns nt">RETURN<br/>    OrderDistanceDay</span></pre><p id="3f8c" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">在这里，我使用上下文转换来获取每个客户和每个订单的前一个订单的日期。</p><p id="8edc" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">要了解有关上下文转换的更多信息，请阅读本文:</p><div class="nv nw gp gr nx ny"><a rel="noopener follow" target="_blank" href="/whats-fancy-about-context-transition-in-dax-efb5d5bc4c01"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd iu gy z fp od fr fs oe fu fw is bi translated">DAX中的语境转换有什么奇特之处</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">行和过滤器上下文是DAX中众所周知的概念。但是我们可以通过上下文转换在这两者之间切换。</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">towardsdatascience.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om kt ny"/></div></div></a></div><p id="f1f9" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">下一步是创建获得最终结果的方法。</p><p id="f20a" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">我必须为每个类别创建一个度量。多种衡量标准是实现客户动态计数的唯一方法。</p><p id="f53e" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">我的下一步是使用计算列生成结果。</p><p id="978f" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">但是用这种方法不可能得到正确的结果，因为当有订单时，这个度量只返回一个数字。</p><p id="c8db" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">但是客户端每个周期需要一个数字。</p><p id="c7c9" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">我第二次尝试解决这一挑战时，采取了以下措施:</p><pre class="kk kl km kn gt nk nl nm nn aw no bi"><span id="79d1" class="np lb it nl b gy nq nr l ns nt">Customer to contact =</span><span id="da52" class="np lb it nl b gy nu nr l ns nt">VAR ActualDate = MAX(‘Date’[Date])<br/>// Get only the rows where Max OrderDate per customer is ActualDate<br/>        — 180 days</span><span id="6efe" class="np lb it nl b gy nu nr l ns nt">VAR Result = COUNTROWS(<br/>                FILTER(<br/>                   SUMMARIZE (<br/>                         GENERATE(<br/>                           ‘Date’<br/>                           ,’Online Sales’<br/>                           )<br/>                           ,’Date’[Date]<br/>                           ,’Online Sales’[CustomerKey]<br/>                           ,”OrderCount”, CALCULATE (<br/>                             DISTINCTCOUNT(<br/>                               ‘Online Sales’[Sales Order Number]) )<br/>                             )<br/>                       ,’Date’[Date] &lt; ActualDate<br/>                            &amp;&amp; ‘Date’[Date] &gt;= ActualDate — 180<br/>                            &amp;&amp; [OrderCount] &lt; 20<br/>                       )<br/>                   )</span><span id="b6c3" class="np lb it nl b gy nu nr l ns nt">RETURN<br/>    Result</span></pre><p id="4f73" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">但是返回前两个类别的结果需要五分钟以上，这是不可接受的。</p><p id="2f61" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">这个冗长响应的原因是GENERATE()函数。</p><p id="86dc" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">我试图用日期表中每个客户和每一行的每个组合生成一行。</p><p id="28f3" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">我在FILTER()函数中使用结果表来过滤出需要的行。为此，我使用上下文转换(CALCULATE(distinct count(' Online Sales '[销售订单号]))计算了SUMMARIZE()结果中的OrderCount列</p><p id="78ad" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">虽然我用19，000名客户的Contoso数据集得到了一个结果，但它不适用于我的客户数据。他的客户表上有超过140万行。</p><p id="b430" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">但是仔细观察发现结果也是不正确的。所以，这种方法是一个死胡同。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi on"><img src="../Images/fe11e2d7a3335e6e51c6df7cf59bd821.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OuvTA2HxOzKOUROz"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae kz" href="https://unsplash.com/@enginakyurt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> engin akyurt </a>拍摄的照片</p></figure><p id="35e0" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">为了找到一种新的方法，我不得不退后一步，理清思绪，从新的角度看待这个挑战。</p><p id="9589" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">我意识到，在基于日期层次结构创建报告时，我总是有一个日期上下文。我不必为每个日期和每个客户生成一个表来计算订单数。在那之前，我完全走错了路。</p><p id="d32d" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">然后我把问题分成两个问题:</p><ol class=""><li id="7f37" class="mo mp it lu b lv mq ly mr mb ms mf mt mj mu mn mv mw mx my bi translated">过去180天内创建了多少订单？</li><li id="bfb2" class="mo mp it lu b lv mz ly na mb nb mf nc mj nd mn mv mw mx my bi translated">在过去的180天里，每位顾客有多少订单<br/>答:根据这些信息，我可以对顾客进行分类</li></ol><p id="2dfa" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">第一项措施是统计过去180天的订单:</p><pre class="kk kl km kn gt nk nl nm nn aw no bi"><span id="f09b" class="np lb it nl b gy nq nr l ns nt">Orders last 180 Days =<br/>    VAR Last180Days =<br/>           DATESINPERIOD(‘Date’[Date], MIN(‘Date’[Date]), -180, DAY)</span><span id="05e4" class="np lb it nl b gy nu nr l ns nt">    VAR OrdersLast180Days =<br/>                        CALCULATETABLE(<br/>                             SUMMARIZE(‘Online Sales’<br/>                                ,’Online Sales’[Sales Order Number])<br/>                             ,Last180Days<br/>                            )</span><span id="60e5" class="np lb it nl b gy nu nr l ns nt">    VAR OrderCountLast180Days = COUNTROWS(OrdersLast180Days)</span><span id="e7d9" class="np lb it nl b gy nu nr l ns nt">RETURN<br/>    OrderCountLast180Days</span></pre><p id="a3a4" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">第一步是生成一个表，其中包含实际过滤上下文之前的所有日期— 180天。</p><p id="6279" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">在第二步中，我使用CALCULATETABLE()和SUMMARIZE()获得这段时间内所有订单的列表。</p><p id="10c1" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">第三步也是最后一步是计算第二步的行数。</p><p id="0a38" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">现在我用它来计算每个客户的订单数。</p><p id="507f" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">对于此计算，我为第一个类别创建了以下衡量标准:</p><pre class="kk kl km kn gt nk nl nm nn aw no bi"><span id="82a0" class="np lb it nl b gy nq nr l ns nt">Cat 1 Customers =<br/>    COUNTROWS(<br/>        CALCULATETABLE(VALUES(‘Customer’[CustomerKey])<br/>                         ,FILTER(‘Customer’<br/>                               ,NOT ISBLANK([Orders last 180 Days])<br/>                               &amp;&amp;<br/>                               [Orders last 180 Days] &lt; 20<br/>                              )<br/>                         )<br/>                   )</span></pre><p id="f96e" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">因为我需要考虑每个客户，所以我必须遍历customer表并检查每个客户的订单数。</p><p id="626f" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">让我们从外到内来看看这个衡量标准:</p><ol class=""><li id="7647" class="mo mp it lu b lv mq ly mr mb ms mf mt mj mu mn mv mw mx my bi translated">COUNTROWS()将使用每个客户的订单数来计算表的行数</li><li id="0863" class="mo mp it lu b lv mz ly na mb nb mf nc mj nd mn mv mw mx my bi translated">CALCULATETABLE()生成一个表<br/> a .在CALCULATETABLE()内部，我使用VALUES('Customer[CustomerKey])来获取所有客户<br/> b .然后，我使用FILTER()根据每个客户的订单数来过滤Customer表</li></ol><p id="7cd8" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">因为FILTER()是一个迭代器，所以我利用上下文转换来获取每个客户过去180天的订单数。度量[最近180天的订单]获取实际客户作为筛选上下文，并计算每个客户的订单量。</p><p id="5a4c" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">我必须使用NOT is blank([订单持续180天])来排除没有任何订单的周期。如果没有这种排除，即使没有订单，我也可以获得所有时期所有客户的计数。这仅适用于第一个订单之前和最后一个订单之后的所有期间。我们总是在这些边界之间得到一个结果。</p><p id="b4a7" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">结果是在过去180天内订单超过20个的客户列表。该列表中的行是COUNTROWS()的输入。</p><p id="96e3" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">结果如下图所示(所有四个测量值):</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi oo"><img src="../Images/13dc401595643ef024def3fc7ff00ab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qTvLNu27OKKXkxsIJ4nhMw.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">图3 —最终解决方案的结果(由作者提供)</p></figure><p id="f51b" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">这种方法有以下两个优点:</p><ul class=""><li id="be7d" class="mo mp it lu b lv mq ly mr mb ms mf mt mj mu mn ni mw mx my bi translated">我为每个客户创建了一个报告，因为每个客户的过滤上下文将预先过滤客户表。这样，我将得到每个客户的正确结果</li><li id="48c4" class="mo mp it lu b lv mz ly na mb nb mf nc mj nd mn ni mw mx my bi translated">结果的计算在很短的时间内就完成了</li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi op"><img src="../Images/7d074751bde0f2b790e595154bcc5dd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*OHwzyW6AX9tklEnQSSm9hg.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">图4—解决方案的查询性能(由作者提供)</p></figure><p id="1a9b" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">您可以看到存储引擎执行了大部分工作(蓝色部分)。尽管该引擎有27个查询要做，但它们可以在很短的时间内并行执行。</p><p id="112b" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">然后，我将这个解决方案转移到我的客户的Power BI文件中，在他的客户表中有140万个条目。</p><p id="b845" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">第一个视频花了一分多钟才显示出结果。这是一个不好的迹象。</p><p id="ff44" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">然后我在订单年份上设置了一个过滤器。Power BI在不到一秒的时间内完成了结果的计算。</p><p id="51af" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">我必须看看性能，并与我的客户讨论，看看这是否可以，或者我是否必须尝试进一步优化解决方案。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi oq"><img src="../Images/a33d1d31488747e4122b2eb1c3a992af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_hqLWUQmtI9I2-pk"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">安德烈·亨特在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><h1 id="158f" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">经验教训</h1><p id="c7be" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">虽然第一个挑战的解决方案相对简单，但第二个挑战被证明要困难得多。</p><p id="f966" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">我的错误是开始用我的客户定义问题的方式来思考。这种想法是找到正确方法的一大障碍。</p><p id="241b" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">我不得不从他的表述中断开我的思考，开始从一个新的角度思考。</p><p id="4c4f" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">当我这样做的时候，我在相对短的时间内找到了解决方案。我只需要将挑战分解成更小的部分，这很有效。</p><p id="eaec" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">回过头来看，我想建议不要在和你的客户讨论的时候开始寻找解决方案。首先，完成挑战的定义。然后坐下来休息几分钟，在将思维切换到“DAX模式”后看看挑战。</p><p id="69ae" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">很容易让人想到:“我知道这个挑战的答案”或“我必须做这个或那个”。虽然这种想法可能是正确的，但它有时会导致错误的方法。</p><p id="2408" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">就像在DAX中一样，你思维的上下文转换需要时间，而且并不简单。</p><h1 id="9033" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">参考</h1><p id="4ccd" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">我使用Contoso样本数据集，就像我以前的文章一样。你可以从微软<a class="ae kz" href="https://www.microsoft.com/en-us/download/details.aspx?id=18279" rel="noopener ugc nofollow" target="_blank">这里</a>免费下载ContosoRetailDW数据集。</p><p id="a0f6" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">Contoso数据可以在MIT许可下自由使用，如这里的<a class="ae kz" href="https://github.com/microsoft/Power-BI-Embedded-Contoso-Sales-Demo" rel="noopener ugc nofollow" target="_blank">所述</a>。</p><p id="08be" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">我扩大了数据集，使DAX引擎工作更努力。<br/>在线销售表包含7100万行(而不是1260万行)，零售表包含1550万行(而不是340万行)。</p><div class="nv nw gp gr nx ny"><a href="https://medium.com/@salvatorecagliari/membership" rel="noopener follow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd iu gy z fp od fr fs oe fu fw is bi translated">通过我的推荐链接加入Medium-Salvatore Cagliari</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">medium.com</p></div></div><div class="oh l"><div class="or l oj ok ol oh om kt ny"/></div></div></a></div></div></div>    
</body>
</html>