<html>
<head>
<title>7 Code Smells You Should Know About And Avoid</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该知道和避免的7种代码气味</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/7-code-smells-you-should-know-about-and-avoid-b1edf066c3a5#2022-04-27">https://towardsdatascience.com/7-code-smells-you-should-know-about-and-avoid-b1edf066c3a5#2022-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="396d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">#2使用打印语句进行调试</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2ac3e8fea74e935430564564c6296de2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vtjchAzRXaZ5jqMU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@charlesdeluvio?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> charlesdeluvio </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="57af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">程序不一定要崩溃才能对其中的问题发出警报:一些其他因素可能会作为一个问题即将出现的严重警告。例如，如果你在房子的某个地方闻到煤气味或烟味，这可能表明你有煤气泄漏或有东西在燃烧。这两种情况都需要在成为重大问题之前进行调查(例如，你的房子爆炸)。</p><p id="0cb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码气味可以被认为是在你家里闻到煤气或烟味。您的代码不会因为它的存在而停止执行，但是在它失控之前，值得研究一下。这是一个指示性的警告，表明您的代码需要一些关注。</p><blockquote class="lv"><p id="0fcd" class="lw lx it bd ly lz ma mb mc md me lu dk translated">“气味是代码中的某些结构，它表明违反了基本设计原则，并对设计质量产生负面影响”。代码气味通常不是bugs它们在技术上并非不正确，也不会妨碍程序的运行。相反，它们指出了设计中的弱点，这些弱点可能会减慢开发速度，或者增加将来出现错误或失败的风险。糟糕的代码气味可能是导致技术债务的因素的指示器。”<br/>-<strong class="ak">来源</strong> : <a class="ae ky" href="https://en.wikipedia.org/wiki/Code_smell" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="0a1d" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">仅仅是代码气味的存在并不等同于bug，但是它的气味值得关注，值得研究。所有程序员都会同意，在我们遇到bug之前阻止它需要更少的努力和花费更少的时间——消除代码气味是确保这一点的一种方法。</p><p id="1687" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了减少代码气味的数量，了解它们的样子是很重要的。在本文中，我们将按非时间顺序介绍其中的七个。</p><h1 id="a3db" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">#1使用打印语句进行调试</h1><p id="4e40" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">Print语句可能是您在编程之旅中学习的第一个内置语句之一(即大多数人的第一个程序是<code class="fe nh ni nj nk b">print("Hello World")</code>)。print语句本身没有什么错误，只是开发人员经常过于依赖它们。</p><p id="4812" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你如何知道自己是否过于依赖打印报表？如果你用它来调试你的代码。T13】</p><p id="b8a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Print语句很容易实现，因此它在欺骗人们认为这是调试代码的最佳方式方面做得非常好。然而，使用print进行调试通常需要您在显示必要的信息以修复代码中的错误之前执行多次程序运行迭代——这需要更长的时间，尤其是当您返回并删除所有这些信息时。</p><p id="a215" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种解决方案比使用打印调试更好:1)使用调试器一次运行一行程序，2)使用日志文件记录程序中的大量信息，这些信息可以与以前的运行进行比较。</p><p id="904d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我更喜欢使用日志文件，这可以通过内置的<code class="fe nh ni nj nk b">logging</code>模块在Python中轻松完成。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="6e99" class="nq ml it nk b gy nr ns l nt nu"><strong class="nk iu">import </strong>logging </span><span id="eca6" class="nq ml it nk b gy nv ns l nt nu">logging.basicConfig(<br/>    filename = "log_age.txt", <br/>    level = logging.DEBUG,<br/>    format = "%(asctime)s - %(levelname)s - %(message)s") </span><span id="eeea" class="nq ml it nk b gy nv ns l nt nu">logging.debug("This is a log message.") </span></pre><h1 id="4df0" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">#2重复代码</h1><p id="dd8e" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">程序中最常见的代码味道很可能是重复的代码。识别重复代码是如此容易:您所要做的就是考虑在程序的不同部分中，您可以简单地复制和粘贴代码。因此，重复代码可以定义为在多个位置重复的代码。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="6239" class="nq ml it nk b gy nr ns l nt nu"><strong class="nk iu">print</strong>("What would you like for breakfast?")<br/>breakfast = input()<br/><strong class="nk iu">print</strong>(f"One {breakfast} coming up")</span><span id="4b07" class="nq ml it nk b gy nv ns l nt nu"><strong class="nk iu">print</strong>("What would you like for lunch?")<br/>lunch = input()<br/><strong class="nk iu">print</strong>(f"One {lunch} coming up")</span><span id="6cab" class="nq ml it nk b gy nv ns l nt nu"><strong class="nk iu">print</strong>("What would you like for dinner?")<br/>dinner = input()<br/><strong class="nk iu">print</strong>(f"One {dinner} coming up")</span></pre><p id="85bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">表面上，重复代码看起来无害。当必须对代码进行更新或更改时，它就成了一个棘手的问题。更改重复代码的一个副本意味着必须对代码的所有区域进行更改，忘记这样做可能会导致程序中代价高昂且难以检测的错误。</p><p id="b58b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题的解决方案非常简单:对代码进行重复数据删除。通过利用函数或循环的力量，我们可以很容易地让代码在程序中出现一次。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="c1fd" class="nq ml it nk b gy nr ns l nt nu"><strong class="nk iu">def </strong>ask_meal(meal_of_the_day:str) -&gt; str: <br/>    <strong class="nk iu">print</strong>(f"What would you like to eat for {meal_of_the_day}")<br/>    meal = input()<br/>    return f"One {meal} coming up"<br/>    <br/>meals_of_the_day = ["breakfast", "lunch", "dinner"]</span><span id="2544" class="nq ml it nk b gy nv ns l nt nu"><strong class="nk iu">for </strong>meal <strong class="nk iu">in</strong> meals_of_the_day: <br/>    ask_meal(meal)</span></pre><p id="f944" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些人将复制发挥到了极致，试图在复制和粘贴代码后的任何时候消除重复。虽然可能有一些程序员支持它，但有时它可能是多余的。复制粘贴代码一次或两次可能不会有问题，但如果出现三次，就创建一个函数或循环来修复它。</p><h1 id="11ea" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">#3神奇的数字</h1><p id="cacd" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">有时我们不得不在代码中使用数字；我们在源代码中使用的一些数字会给其他开发人员带来极大的困惑——如果您将来不得不重新访问这些代码，也会给自己带来困惑。这些数字被称为<strong class="lb iu"> <em class="nl">幻数</em> </strong>。</p><blockquote class="lv"><p id="f494" class="lw lx it bd ly lz ma mb mc md me lu dk translated">“幻数或幻常数这个术语指的是在源代码中直接使用数字的反模式。”<br/> - [ <strong class="ak">来源</strong> : <a class="ae ky" href="https://en.wikipedia.org/wiki/Magic_number_(programming)" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="9877" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">幻数被认为是一种代码味道，因为它们没有给出任何关于它们为什么存在的指示——它掩盖了开发人员选择那个特定数字的意图。因此，您的代码可读性更差，您和其他开发人员将来更难更新或更改，并且更容易出现像打字错误这样的细微错误。</p><p id="1eb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑以下场景:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="4625" class="nq ml it nk b gy nr ns l nt nu"><strong class="nk iu">from </strong>sklearn.model_selection <strong class="nk iu">import</strong> train_test_split</span><span id="8d9b" class="nq ml it nk b gy nv ns l nt nu">X_train, X_test, y_train, y_test = train_test_split(<br/>    X, <br/>    y, <br/>    0.3, <br/>    0.7, <br/>    25, <br/>    True, <br/>    None<br/>)</span></pre><p id="003a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们从Scikit-learn导入了<code class="fe nh ni nj nk b">train_test_split</code>函数，并用一些似乎没有明确含义的超参数实例化了它。</p><p id="f4d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使代码可读性更好的一个解决方案是添加信息性的注释，告诉我们为什么选择这个特定的数字。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="4118" class="nq ml it nk b gy nr ns l nt nu"><strong class="nk iu">from </strong>sklearn.model_selection <strong class="nk iu">import</strong> train_test_split</span><span id="91ca" class="nq ml it nk b gy nv ns l nt nu">X_train, X_test, y_train, y_test = train_test_split(<br/>    X # features array, <br/>    y # labels, <br/>    0.3 # test size, <br/>    0.7 # train size, <br/>    25 # random state, <br/>    True # shuffle, <br/>    None # stratify<br/>)</span></pre><p id="6a0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决这种代码味道的一个更有用的方法是使用一个<strong class="lb iu"> <em class="nl">常量</em> </strong>。常数是每次执行程序时保持不变的有价值的数据。[我不确定其他语言，但是]在Python中，我们通常用大写字母来写常量，以告知他人(并提醒自己)它们的值在初始赋值后不应该改变。</p><p id="b302" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您经常会看到在配置中定义的常量，或者在脚本开始时作为全局变量定义的常量。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="7d03" class="nq ml it nk b gy nr ns l nt nu"><strong class="nk iu">from </strong>sklearn.model_selection <strong class="nk iu">import</strong> train_test_split</span><span id="afbb" class="nq ml it nk b gy nv ns l nt nu">TEST_SIZE = 0.3<br/>TRAIN_SIZE = 0.7<br/>RANDOM_STATE = 25<br/>SHUFFLE = True<br/>STRATIFY = None</span><span id="f45e" class="nq ml it nk b gy nv ns l nt nu">X_train, X_test, y_train, y_test = train_test_split(<br/>    X, <br/>    y, <br/>    TEST_SIZE, <br/>    TRAIN_SIZE, <br/>    RANDOM_STATE, <br/>    SHUFFLE, <br/>    STRATIFY<br/>)</span></pre><p id="9228" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有多大的可读性？</p><p id="2303" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"/></p><p id="4a9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用不同的常数而不是用一个常数来解决两个问题是很重要的。这样做的原因是，它们可以在将来独立更改，这通常会减少很多麻烦。</p><h1 id="b972" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">#4保留注释掉的代码</h1><p id="bbd8" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">当代码中的注释提供信息时，它无疑被视为一种好的实践。有时，我们甚至会暂时注释掉代码，看看在没有我们删除的代码行的情况下，剩余的代码是如何运行的——可能是在我们调试的时候——这本身也没有什么错。</p><p id="3c04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当程序员变得懒惰时，它就会成为一个问题。这种懒惰的一个例子是注释掉代码，但是保留注释掉的代码。</p><p id="a3c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就地注释掉代码的原因是代码味道，因为它是不明确的。其他程序员会将注释掉的代码视为一个完全的谜，并且不知道在什么条件下应该将它重新放入程序中。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="c9f7" class="nq ml it nk b gy nr ns l nt nu">walk()<br/># run()<br/>sprint()<br/>stop()</span></pre><p id="9a08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么<code class="fe nh ni nj nk b">run()</code>被注释掉了？什么时候可以取消对<code class="fe nh ni nj nk b">run()</code>的注释？如果不需要，那么删除代码。</p><h1 id="2588" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">#5死代码</h1><p id="e89c" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">为了节省计算和内存，必须处理程序中的所有死代码。</p><blockquote class="lv"><p id="d27a" class="lw lx it bd ly lz ma mb mc md me lu dk translated">“死代码是一个程序的源代码中的一部分，它被执行，但其结果永远不会在任何其他计算中使用。”<br/> - [ <strong class="ak">来源</strong> : <a class="ae ky" href="https://en.wikipedia.org/wiki/Dead_code#:~:text=In%20some%20areas%20of%20computer,wastes%20computation%20time%20and%20memory." rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="f29e" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">在你的程序中有死代码是非常误导人的。其他程序员阅读您的代码时可能不会马上理解，并认为它是代码的一个工作部分，而实际上，它除了浪费空间之外什么也没做。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="cb64" class="nq ml it nk b gy nr ns l nt nu"># Code source: <a class="ae ky" href="https://twitter.com/python_engineer/status/1510165975253069824?s=20&amp;t=VsOWz55ZILPXCz6NMgJtEg" rel="noopener ugc nofollow" target="_blank">https://twitter.com/python_engineer/status/1510165975253069824?s=20&amp;t=VsOWz55ZILPXCz6NMgJtEg</a></span><span id="1883" class="nq ml it nk b gy nv ns l nt nu"><strong class="nk iu">class </strong>TodoItem: <br/>    <strong class="nk iu">def </strong>__init__(self, state=None):<br/>        self.state = state if state else -1 <br/> <br/>    <strong class="nk iu">def </strong>__str__(self): <br/>        if self.state == -1: <br/>            return "UNDEFINED"<br/>        elif self.state == 0: <br/>            return "UNSET" <br/>        else: <br/>            return "SET"</span></pre><p id="a9dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">乍一看，这段代码看起来不错，但是其中有一个bug:这段代码永远不能被设置为0，因为在<code class="fe nh ni nj nk b">self.state</code>变量中的求值会将0设置为<code class="fe nh ni nj nk b">False</code>。因此，将状态设置为0将返回<code class="fe nh ni nj nk b">UNDEFINED</code>而不是<code class="fe nh ni nj nk b">UNSET</code>。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="68a5" class="nq ml it nk b gy nr ns l nt nu">class TodoItem: <br/>    def __init__(self, state=None):<br/>        self.state = state if state is not None else -1 <br/> <br/>    def __str__(self): <br/>        if self.state == -1: <br/>            return "UNDEFINED"<br/>        elif self.state == 0: <br/>            return "UNSET" <br/>        else: <br/>            return "SET"</span></pre><p id="32d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="nl">注</em> </strong> <em class="nl">:见本</em> <a class="ae ky" href="https://www.youtube.com/watch?v=_9yJdVl-K9M&amp;t=59s" rel="noopener ugc nofollow" target="_blank"> <em class="nl">视频</em> </a> <em class="nl">由Python工程师得到完整解释。</em></p><h1 id="55fb" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">#6存储带数字后缀的变量</h1><p id="6677" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我已经被这种代码气味困扰过几次——直到今天我还没有完全摆脱它；有时，我们可能需要跟踪同一类型数据的几个实例。在这种情况下，重用一个名字并给它添加一个后缀，使它存储在程序中的一个不同的名称空间中，这是非常诱人的。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="8065" class="nq ml it nk b gy nr ns l nt nu">person_1 = "John" <br/>person_2 = "Doe"<br/>person_3 = "Michael</span></pre><p id="a8e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种代码味道之所以是代码味道，是因为后缀不能很好地描述每个变量中包含的内容或变量之间的差异。它也没有给出任何关于程序中有多少变量的指示——你不想搜索1000多行代码来确保没有其他的数字。</p><p id="b824" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更好的解决方案是:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="fe34" class="nq ml it nk b gy nr ns l nt nu">people = ["John", "Doe", "Michael"] </span></pre><p id="3bc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要把这当作改变所有以数字结尾的变量的指令:一些变量应该以数字结尾，尤其是当数字是你存储的数据的独特名称的一部分时。</p><h1 id="798c" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">#7不必要的类(特定于Python)</h1><p id="0348" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">像Java这样的编程语言使用类来组织程序中的代码。Python使用模块。因此，试图像在Java中一样使用Python中的类(来组织代码)是不会有效的。</p><p id="bbd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python中的代码不需要存在于类中，有时，使用类可能是多余的。</p><p id="e84d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以这门课为例:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="1a60" class="nq ml it nk b gy nr ns l nt nu"><strong class="nk iu">class </strong>Human:<br/>    <strong class="nk iu">def </strong>__init__(self, name: str): <br/>        self.name = name</span><span id="b85d" class="nq ml it nk b gy nv ns l nt nu">    <strong class="nk iu">def </strong>introduction(self): <br/>        return f"Hi, my name is {self.name}"</span><span id="9e7c" class="nq ml it nk b gy nv ns l nt nu">person = Human("Kurtis")<br/>print(person.introduction()) </span><span id="0619" class="nq ml it nk b gy nv ns l nt nu">"""<br/>Hi, my name is Kurtis<br/>"""</span></pre><p id="a90f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么这个类不需要成为一个类的主要决定因素是它只有一个函数。根据经验，如果一个类只包含一个方法或者只包含静态方法，那么它不一定是Python中的类。不如写个函数来代替。</p><p id="444c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要了解这个概念的更多信息，请查看Jack Diederich在PyCon 2012上关于为什么我们应该"<a class="ae ky" href="https://www.youtube.com/watch?v=o9pEzgHorH0" rel="noopener ugc nofollow" target="_blank">停止编写类</a>"的演讲。</p><p id="b083" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nl">感谢阅读。</em></p><p id="9ba8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">联系我:</strong><br/><a class="ae ky" href="https://www.linkedin.com/in/kurtispykes/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a><br/><a class="ae ky" href="https://twitter.com/KurtisPykes" rel="noopener ugc nofollow" target="_blank">Twitter</a><br/><a class="ae ky" href="https://www.instagram.com/kurtispykes/" rel="noopener ugc nofollow" target="_blank">insta gram</a></p><p id="5d8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢阅读这样的故事，并希望支持我的写作，可以考虑成为一名灵媒。每月支付5美元，你就可以无限制地阅读媒体上的故事。如果你使用<a class="ae ky" href="https://kurtispykes.medium.com/membership" rel="noopener">我的注册链接</a>，我会收到一小笔佣金。</p><p id="a0ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">已经是会员了？<a class="ae ky" href="https://kurtispykes.medium.com/subscribe" rel="noopener">订阅</a>在我发布时得到通知。</p><div class="nw nx gp gr ny nz"><a href="https://kurtispykes.medium.com/subscribe" rel="noopener follow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">每当Kurtis Pykes发表文章时都收到一封电子邮件。</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">每当Kurtis Pykes发表文章时都收到一封电子邮件。通过注册，您将创建一个中型帐户，如果您还没有…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">kurtispykes.medium.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on ks nz"/></div></div></a></div></div></div>    
</body>
</html>