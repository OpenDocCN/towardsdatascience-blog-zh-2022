<html>
<head>
<title>pymoode: Differential Evolution in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">pymoode:Python中的差异进化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pymoode-differential-evolution-in-python-78e4221e5cbe#2022-05-31">https://towardsdatascience.com/pymoode-differential-evolution-in-python-78e4221e5cbe#2022-05-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1aba" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用差分进化算法求解单目标和多目标优化问题</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b79e563f717908ef95594052c06dede2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5mVWqFzHdGxgwlWA"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@bdchu614?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布伦丹·丘奇</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="92e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">差分进化(DE) (Storn &amp; Price，1997)最初是为标量目标优化而设计的。然而，由于其简单的实现和高效的问题解决质量，DE已经以不同的方式被修改来解决多目标优化问题。</p><p id="bcce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在整篇文章中，我们将看到Python包<a class="ae kv" href="https://github.com/mooscaliaproject/pymoode" rel="noopener ugc nofollow" target="_blank"> <em class="ls"> pymoode </em> </a>中可用的算法和操作符，以及对单目标、多目标和多目标优化问题的应用。它在PyPI上可用，因此任何Python用户都可以用简单的命令行安装它:</p><pre class="kg kh ki kj gt lt lu lv bn lw lx bi"><span id="f7ea" class="ly lz iq lu b be ma mb l mc md">pip install pymoode</span></pre><p id="615b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该软件包是使用<a class="ae kv" href="https://pymoo.org/" rel="noopener ugc nofollow" target="_blank"><em class="ls">pymoo</em></a><em class="ls"/>基本结构(Blank &amp; Deb，2020)编写的，它有效、易用，并在用户希望或需要时给予高度定制的余地。我强烈建议查看它的文档和可用特性。<a class="me mf ep" href="https://medium.com/u/12b065b8160a?source=post_page-----78e4221e5cbe--------------------------------" rel="noopener" target="_blank"> Julian Blank </a>也写了这篇关于媒介的<a class="ae kv" rel="noopener" target="_blank" href="/an-introduction-to-genetic-algorithms-the-concept-of-biological-evolution-in-optimization-fc96e78fa6db">伟大文章</a>，概述了<em class="ls">遗传算法</em>，其中他介绍了<em class="ls"> pymoo </em>的一些特征。</p><p id="929c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来的部分将涵盖以下主题。</p><ol class=""><li id="0a4b" class="mg mh iq ky b kz la lc ld lf mi lj mj ln mk lr ml mm mn mo bi translated"><a class="ae kv" href="#f054" rel="noopener ugc nofollow"> <em class="ls"> pymoode </em>:算法和附加运算符</a></li><li id="7f0e" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr ml mm mn mo bi translated"><a class="ae kv" href="#f6d9" rel="noopener ugc nofollow"> DE:概述和控制参数</a></li><li id="8be6" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr ml mm mn mo bi translated"><a class="ae kv" href="#4a06" rel="noopener ugc nofollow">在<em class="ls">pymoo</em>T31】中定义问题</a></li><li id="64be" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr ml mm mn mo bi translated"><a class="ae kv" href="#6e0d" rel="noopener ugc nofollow">单目标DE </a></li><li id="5634" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr ml mm mn mo bi translated"><a class="ae kv" href="#ab33" rel="noopener ugc nofollow">多目标优化简介</a></li><li id="154c" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr ml mm mn mo bi translated"><a class="ae kv" href="#2b40" rel="noopener ugc nofollow">多目标算法:GDE3和NSDE </a></li><li id="fc6b" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr ml mm mn mo bi translated"><a class="ae kv" href="#27ba" rel="noopener ugc nofollow">改进双目标问题的解决方案</a></li><li id="74f7" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr ml mm mn mo bi translated"><a class="ae kv" href="#c5da" rel="noopener ugc nofollow">多目标算法:NSDE-R和GDE3-MNN </a></li><li id="8146" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr ml mm mn mo bi translated"><a class="ae kv" href="#8bf5" rel="noopener ugc nofollow">应用和前景</a></li><li id="e3ea" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr ml mm mn mo bi translated"><a class="ae kv" href="#2cb7" rel="noopener ugc nofollow">结论</a></li><li id="f590" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr ml mm mn mo bi translated"><a class="ae kv" href="#7872" rel="noopener ugc nofollow">致谢</a></li><li id="3b9a" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr ml mm mn mo bi translated"><a class="ae kv" href="#6c06" rel="noopener ugc nofollow">参考文献</a></li></ol><p id="eed3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你们都能好好阅读，并成功地将<em class="ls"> pymoode </em>应用到你们的一些项目中！感兴趣的人可以跟随本<a class="ae kv" href="https://github.com/mooscaliaproject/pymoode/blob/main/notebooks/tutorial.ipynb" rel="noopener ugc nofollow" target="_blank"> <em class="ls">示例笔记本</em> </a>了解所有实施步骤。该软件包也可以在<a class="ae kv" href="https://github.com/mooscaliaproject/pymoode" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><p id="d869" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您不熟悉非线性编程或差分进化，我建议您阅读我以前的文章，以便更好地理解这里介绍的概念。</p><div class="mu mv gp gr mw mx"><a rel="noopener follow" target="_blank" href="/nonlinear-programming-theory-and-applications-cfe127b6060c"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd ir gy z fp nc fr fs nd fu fw ip bi translated">非线性规划:理论与应用</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">详细解释了基于梯度的线搜索优化算法，并用Python从头开始实现</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">towardsdatascience.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl kp mx"/></div></div></a></div><div class="mu mv gp gr mw mx"><a rel="noopener follow" target="_blank" href="/differential-evolution-an-alternative-to-nonlinear-convex-optimization-690a123f3413"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd ir gy z fp nc fr fs nd fu fw ip bi translated">差分进化:非线性凸优化的替代方案</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">了解差分进化的基础知识及其在Python中的应用</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">towardsdatascience.com</p></div></div><div class="ng l"><div class="nm l ni nj nk ng nl kp mx"/></div></div></a></div><p id="9fca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然以前我们追求的是一个单一的目标，但在这篇文章中，我们有许多方向可以同时遵循！</p><p id="6b41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了给读者提供不同部分的导航，每个部分的末尾都有一个“<a class="ae kv" href="#929c" rel="noopener ugc nofollow">返回目录</a>”链接，可以将页面滚动回目录列表。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="f054" class="nu lz iq bd nv nw nx ny nz oa ob oc od jw oe jx of jz og ka oh kc oi kd oj ok bi translated"><em class="ol"> pymoode </em>:算法和附加运算符</h1><p id="2aed" class="pw-post-body-paragraph kw kx iq ky b kz om jr lb lc on ju le lf oo lh li lj op ll lm ln oq lp lq lr ij bi translated"><em class="ls"> pymoode </em>的目的是提供<em class="ls"> pymoo </em>中可用算法的扩展，重点关注差分进化变体。因此，这些算法将共享DE复制操作符之间的一些共同特征。此外，我还实现了一些<em class="ls"> survival </em>操作符，这些操作符在<em class="ls"> pymoo </em>中还没有，为用户提供了更多的选择。这些算法和操作符可能会被未来版本的pymoo所整合。</p><p id="6810" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该软件包可以通过以下树结构进行总结:</p><pre class="kg kh ki kj gt lt lu lv bn lw lx bi"><span id="ddb2" class="ly lz iq lu b be ma mb l mc md">pymoode<br/>├───algorithms<br/>│   ├───DE<br/>│   ├───GDE3<br/>│   ├───NSDE<br/>│   └───NSDER<br/>├───survival<br/>│   ├───RankAndCrowding<br/>│   └───ConstrRankAndCrowding<br/>└───performance<br/>    └───SpacingIndicator</span></pre><p id="3ffb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可用的算法有:</p><ul class=""><li id="31f4" class="mg mh iq ky b kz la lc ld lf mi lj mj ln mk lr or mm mn mo bi translated"><strong class="ky ir">德</strong>:Storn&amp;Price(1997)提出的单目标问题的差分进化。还提供了后来实现的其他功能，如抖动、抖动、选择变量和交叉策略。详情见Price等人(2005年)。</li><li id="7851" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr or mm mn mo bi translated"><strong class="ky ir"> NSDE </strong>:非支配排序差分进化，一种多目标算法，将DE变异和交叉算子结合到NSGA-II (Deb et al .，2002)生存中。</li><li id="1dff" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr or mm mn mo bi translated"><strong class="ky ir"> GDE3 </strong>:广义差分进化3，一种多目标算法，将DE变异和交叉算子结合到NSGA-II生存和混合型生存策略中。在该算法中，在通过多目标生存算子截断种群之前，个体可能在一对一的比较中被移除。它是由Kukkonen，S. &amp; Lampinen，J. (2005年)提出的。具有M-最近邻和2-最近邻存活的变体也是可用的。</li><li id="2677" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr or mm mn mo bi translated"><strong class="ky ir"> NSDE-R </strong>:基于参考方向的非支配排序差分进化(Reddy &amp; Dulikravich，2019)。这是一种针对多目标问题的算法，是使用NSGA-III (Deb &amp; Jain，2014)生存策略的NSDE的扩展。</li></ul><p id="cb0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其他幸存运算符包括:</p><ul class=""><li id="de84" class="mg mh iq ky b kz la lc ld lf mi lj mj ln mk lr or mm mn mo bi translated"><strong class="ky ir"> RandAndCrowding </strong>:实现NSGA-II等级和拥挤生存的灵活结构，具有拥挤度量和个体淘汰的不同选项。</li><li id="e7e7" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr or mm mn mo bi translated"><strong class="ky ir">constrankandcrowding</strong>:Kukkonen，s .和Lampinen，J. (2005)提出的基于等级和拥挤的生存算子，具有特殊的约束处理方法。</li></ul><p id="c97a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可用的拥挤指标有:</p><ul class=""><li id="021f" class="mg mh iq ky b kz la lc ld lf mi lj mj ln mk lr or mm mn mo bi translated"><strong class="ky ir">拥挤距离(<em class="ls">CD</em>’)</strong>:由Deb等(2002)在NSGA II中提出。从<em class="ls"> pymoo </em>导入。</li><li id="9c89" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr or mm mn mo bi translated"><strong class="ky ir">修剪拥挤距离(<em class="ls">PCD</em>)</strong>:由Kukkonen &amp; Deb (2006a)提出，它递归地重新计算拥挤距离，从种群中移除个体以提高多样性。</li><li id="0c28" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr or mm mn mo bi translated"><strong class="ky ir"><em class="ls">M</em>-最近邻(<em class="ls">mnn</em>’)</strong>:由Kukkonen &amp; Deb (2006b)在GDE3对多目标问题的扩展中提出，其中<em class="ls"> M </em>对应目标的个数。</li><li id="f779" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr or mm mn mo bi translated"><strong class="ky ir">2-最近邻(<em class="ls"> 2nn </em> ') </strong>:也是Kukkonen &amp; Deb (2006b)提出的，是邻居个数为2的<em class="ls">M</em>-最近邻<strong class="ky ir"> </strong>的变种。</li><li id="a7ab" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr or mm mn mo bi translated"><strong class="ky ir">拥挤熵(<em class="ls">ce</em>’)</strong>:王等(2009)在MOSADE提出。</li></ul><p id="573e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="#929c" rel="noopener ugc nofollow">返回目录。</a></p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="f6d9" class="nu lz iq bd nv nw nx ny nz oa ob oc od jw oe jx of jz og ka oh kc oi kd oj ok bi translated">DE:概述和控制参数</h1><p id="0a81" class="pw-post-body-paragraph kw kx iq ky b kz om jr lb lc on ju le lf oo lh li lj op ll lm ln oq lp lq lr ij bi translated">DE算法的基本结构如下图所示，接下来将描述在<em class="ls"> pymoode </em>中实现的最重要的控制参数。要了解更多的细节，我推荐阅读我在<a class="ae kv" rel="noopener" target="_blank" href="/differential-evolution-an-alternative-to-nonlinear-convex-optimization-690a123f3413">上一篇关于德的文章</a>和普莱斯等人的书(2005)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/62f752f100faacb3854ce59eb1289aaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FGCAhZPxbEbkKmzQ33w0DQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">差分进化算法的基本结构。(图片由作者提供)。</p></figure><ul class=""><li id="c821" class="mg mh iq ky b kz la lc ld lf mi lj mj ln mk lr or mm mn mo bi translated"><strong class="ky ir"> pop_size </strong> (int，可选):人口规模。</li><li id="bc16" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr or mm mn mo bi translated"><strong class="ky ir">采样</strong>(采样，群体，或类数组，可选)<em class="ls"> pymoo </em>的采样策略。</li><li id="6e51" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr or mm mn mo bi translated"><strong class="ky ir">变体</strong> (str，可选):差分进化策略。必须是格式为“去/选择/n/交叉”的字符串。默认为“DE/rand/1/bin”。</li><li id="31b7" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr or mm mn mo bi translated"><strong class="ky ir"> CR </strong>(浮点，可选):交叉参数。在范围[0，1]中定义。要加强突变，请使用更高的值。要控制收敛速度，请使用较低的值。</li><li id="fafc" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr or mm mn mo bi translated"><strong class="ky ir"> F </strong>(可迭代的float或float，可选):比例因子或突变参数。在范围(0，2)中定义。为了加强探索，使用更高的值；而对于剥削，使用较低。</li><li id="ace8" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr or mm mn mo bi translated"><strong class="ky ir"> gamma </strong> (float，可选):抖动偏差参数。应该在范围(0，2)内。默认为1e-4。</li><li id="3980" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr or mm mn mo bi translated"><strong class="ky ir">变异</strong>(变异，可选):交叉后Pymoo的变异算子。默认为无。</li><li id="752f" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr or mm mn mo bi translated"><strong class="ky ir"> de_repair </strong> (callable或str):对问题边界外的突变载体的修复策略。所采用的策略基于Price等人(2005)。默认为“反弹”。</li><li id="1262" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr or mm mn mo bi translated"><strong class="ky ir">生存</strong>(生存，可选):Pymoo的生存策略。应该在多目标算法中考虑。</li></ul><p id="bfc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在选择DE的控制参数时，我建议优先选择<em class="ls"> pop_size </em>、<em class="ls"> variant </em>、<em class="ls"> CR </em>和<em class="ls"> F </em>(按先后顺序)。据文献报道，当使用非常小的群体规模时(Price等人，2005年)，抖动是有用的，在这种情况下，使用更高的<em class="ls">伽马值</em>可能是可取的。我发现它对于在帕累托前沿连接线性段的情况也是有用的。参数<em class="ls">突变</em>是指交叉后可能执行的<em class="ls"> pymoo </em>突变。当使用强化剥削和精英主义的变体时，如DE/best，使用<em class="ls">多项式突变</em>非常有用。</p><p id="277d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls"> de_repair </em>参数选择问题边界外突变载体采用的修复策略。它可能作为一个<em class="ls">可调用的</em>或一个<em class="ls">字符串</em>被传递。目前的实施使用Price等人(2005年)提出的替代方案。默认<em class="ls">反弹</em>策略将违反边界的变量设置为DE变异对应基向量与变量边界之间的随机值；<em class="ls">中间</em>，以类似的策略，将数值重置为两者之间的中间点。策略<em class="ls"> rand-init </em>随机采样违反决策变量的问题边界之间的新值，这对于增强多样性是有用的，尽管它可能会破坏接近边界的解决方案的进展。</p><p id="aa0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">生存</em>策略是对多目标变体有效的论点，而单目标DE使用经典的一对一替换。考虑到要解决的问题，选择适当的策略是至关重要的。对于双目标问题，推荐使用<em class="ls"> pymoode </em>的<em class="ls"> RankAndCrowding </em>生存，使用<em class="ls">crowding _ func</em>=<em class="ls">‘PCD’</em>，而对于多目标问题，优选使用<em class="ls">crowding _ func</em>=<em class="ls">‘mnn’</em>，或者将算法切换到NSDE-R</p><p id="cf94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在接下来的部分中，让我们动手使用<em class="ls"> pymoo的</em>结构来解决问题。</p><p id="ab88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="#929c" rel="noopener ugc nofollow">返回目录。</a></p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="4a06" class="nu lz iq bd nv nw nx ny nz oa ob oc od jw oe jx of jz og ka oh kc oi kd oj ok bi translated">在<em class="ol"> pymoo </em>中定义问题</h1><p id="e08c" class="pw-post-body-paragraph kw kx iq ky b kz om jr lb lc on ju le lf oo lh li lj op ll lm ln oq lp lq lr ij bi translated">在pymoo，中，有三种不同的方式来定义一个问题。这三者都创建了一个继承自<em class="ls">问题</em>类的实例。在<a class="ae kv" href="https://pymoo.org/problems/definition.html" rel="noopener ugc nofollow" target="_blank">文档</a>中对它们进行了如下描述:</p><ul class=""><li id="4502" class="mg mh iq ky b kz la lc ld lf mi lj mj ln mk lr or mm mn mo bi translated"><a class="ae kv" href="https://pymoo.org/problems/definition.html#nb-problem-definition-vectorized" rel="noopener ugc nofollow" target="_blank">问题</a>:面向对象的定义实现了一个评估一组<strong class="ky ir">解决方案的方法。</strong></li><li id="cbea" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr or mm mn mo bi translated"><a class="ae kv" href="https://pymoo.org/problems/definition.html#nb-problem-definition-elementwise" rel="noopener ugc nofollow" target="_blank"> ElementwiseProblem </a>:面向对象的定义，实现一次评估一个<strong class="ky ir">单个</strong>解决方案的函数。</li><li id="6a14" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr or mm mn mo bi translated"><a class="ae kv" href="https://pymoo.org/problems/definition.html#nb-problem-definition-functional" rel="noopener ugc nofollow" target="_blank">功能问题</a>:通过对每个目标和约束使用<strong class="ky ir">功能</strong>来定义问题。</li></ul><pre class="kg kh ki kj gt lt lu lv bn lw lx bi"><span id="f740" class="ly lz iq lu b be ma mb l mc md">from pymoo.core.problem import Problem, ElementwiseProblem<br/>from pymoo.problems.functional import FunctionalProblem</span></pre><p id="28a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一节中，我将使用三种可用的结构来展示解决同一个优化问题的不同方法。</p><p id="ee8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个例子将基于<em class="ls"> Rastrigin </em>函数的单目标优化问题。这是非凸优化中常见的单目标测试问题，因为它包含多个局部最优解。它由下面的等式描述。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/f3eae9a0aa0316328ddaa086d10ed62b.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*UwOtE6ht6EicWQQsHMKOPw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">拉斯特里金问题。(图片由作者提供)。</p></figure><p id="afca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中，<em class="ls"> A </em>是用户指定的参数(通常为10)，而<em class="ls"> n </em>是所使用的决策变量的数量。在我们的实现中，我们将使用两个决策变量。都将以-5.12和5.12为界。</p><p id="af29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可能，定义问题最直观的方式是<em class="ls">函数</em>，代码如下。</p><pre class="kg kh ki kj gt lt lu lv bn lw lx bi"><span id="77e9" class="ly lz iq lu b be ma mb l mc md"># Defining the objective function<br/>def rastrigin(x):<br/>    return np.sum(x * x - \<br/>        10 * np.cos(2 * np.pi * x)) \<br/>            + 10 * np.size(x)<br/><br/># Functional<br/>functional_rastrigin = FunctionalProblem(<br/>    n_var=2, objs=rastrigin,<br/>    xl=np.full(2, -5.12), xu=np.full(2, 5.12),<br/>    constr_ieq=[],<br/>)</span></pre><p id="866c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，同样的问题可以被定义为<em class="ls">基本问题</em> …</p><pre class="kg kh ki kj gt lt lu lv bn lw lx bi"><span id="541d" class="ly lz iq lu b be ma mb l mc md">class ElementwiseRastrigin(ElementwiseProblem):<br/><br/>    def __init__(self):<br/>        xl = np.full(2, -5.12)<br/>        xu = np.full(2, 5.12)<br/>        super().__init__(<br/>            n_var=2, n_obj=1, n_constr=0,<br/>            xl=xl, xu=xu)<br/><br/>    def _evaluate(self, x, out, *args, **kwargs):<br/>        out["F"] = rastrigin(x)</span></pre><p id="91c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">…或者作为一个<em class="ls">问题</em>，定义为以矢量化的方式评估一组解决方案。</p><pre class="kg kh ki kj gt lt lu lv bn lw lx bi"><span id="03e8" class="ly lz iq lu b be ma mb l mc md">class Rastrigin(Problem):<br/><br/>    def __init__(self):<br/>        xl = np.full(2, -5.12)<br/>        xu = np.full(2, 5.12)<br/>        super().__init__(<br/>            n_var=2, n_obj=1, n_constr=0,<br/>            xl=xl, xu=xu)<br/><br/>    def _evaluate(self, x, out, *args, **kwargs):<br/>        out["F"] = np.sum(x * x - \<br/>            10 * np.cos(2 * np.pi * x), axis=1) \<br/>                + 10 * x.shape[1]</span></pre><p id="39e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意<em class="ls">问题</em>结构中的<strong class="ky ir"> <em class="ls"> x </em> </strong>是一个形状为(<em class="ls"> N </em>，<em class="ls"> m </em>)的<em class="ls">种群</em>中决策变量对应的数组，其中<em class="ls"> N </em>对应种群大小，<em class="ls"> m </em>对应决策变量的个数。</p><p id="7dca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下一节中，让我们使用单目标de的<em class="ls"> pymoode </em>实现来解决这个问题。</p><p id="0f46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="#929c" rel="noopener ugc nofollow">返回目录。</a></p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="6e0d" class="nu lz iq bd nv nw nx ny nz oa ob oc od jw oe jx of jz og ka oh kc oi kd oj ok bi translated">单目标差分进化算法</h1><p id="e682" class="pw-post-body-paragraph kw kx iq ky b kz om jr lb lc on ju le lf oo lh li lj op ll lm ln oq lp lq lr ij bi translated">为了解决Rastrigin问题，我们将首先导入一些有用的操作符。它们将是算法(<em class="ls"> DE </em>)、<em class="ls">最小化</em>接口和单目标终止操作符(<em class="ls">defaultsingleobjecttermination</em>)。</p><pre class="kg kh ki kj gt lt lu lv bn lw lx bi"><span id="d00f" class="ly lz iq lu b be ma mb l mc md">from pymoode.algorithms import DE<br/>from pymoo.optimize import minimize<br/>from pymoo.termination.default import DefaultSingleObjectiveTermination</span></pre><p id="5037" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将如下实例化DE的第一个实现。</p><pre class="kg kh ki kj gt lt lu lv bn lw lx bi"><span id="0e3d" class="ly lz iq lu b be ma mb l mc md">de = DE(pop_size=30, variant="DE/rand/1/bin", F=(0.3, 1.0), CR=0.5)</span></pre><p id="bd0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个低维问题，尽管由于存在许多局部最优而具有挑战性。因此，我使用30作为种群大小<em class="ls"> N </em>以确保全局收敛。选择<em class="ls"> DE </em>变量作为最常用的DE/rand/1/bin，<em class="ls"> F </em>参数为(0.3，1.0)，使用随机均匀分布抖动，<em class="ls"> CR </em>参数为0.5，以加强坐标轴上的搜索并控制收敛。</p><p id="2118" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个问题，我在调整控制参数方面做得不多。因此，其他组合可能更有效。对<em class="ls"> DE </em>的工作原理感兴趣的，建议看一下我的<a class="ae kv" rel="noopener" target="_blank" href="/differential-evolution-an-alternative-to-nonlinear-convex-optimization-690a123f3413">上一篇文章</a>，里面我有详细的描述。</p><p id="07e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，让我们根据<em class="ls"> f </em> ( <em class="ls"> f_tol </em>)、<strong class="ky ir"><em class="ls">x</em></strong>(<em class="ls">x _ tol</em>)、约束违反(<em class="ls"> cv_tol </em>)和最大代数(<em class="ls"> n_max_gen </em>)的变化来定义终止标准。参数<em class="ls">n _ gen</em>控制检查标准的频率，参数<em class="ls"> n_last </em>控制评估变更时考虑多少个前几代。</p><pre class="kg kh ki kj gt lt lu lv bn lw lx bi"><span id="063e" class="ly lz iq lu b be ma mb l mc md">termination_single = DefaultSingleObjectiveTermination(<br/>    xtol=1e-8,<br/>    cvtol=0.0,<br/>    ftol=1e-8,<br/>    period=20,<br/>    n_max_gen=200<br/>)</span></pre><p id="d707" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们使用<em class="ls">最小化</em>接口来解决这个问题。</p><pre class="kg kh ki kj gt lt lu lv bn lw lx bi"><span id="2236" class="ly lz iq lu b be ma mb l mc md">res_de_rastrigin = minimize(<br/>    Rastrigin(),<br/>    de,<br/>    termination=termination_single,<br/>    seed=12,<br/>    save_history=True,<br/>    verbose=False,<br/>)</span></pre><p id="6f64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该算法是有效的，并引导我们找到了函数的全局最优解，该函数是一个在<strong class="ky ir"> <em class="ls"> x </em> </strong>中为零的向量，目标函数也为零。</p><p id="b691" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我已经将参数<em class="ls"> save_history </em>指定为True，所以我可以访问各代的人口属性，我们可以创建如下所示的惊人视觉效果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/c2d15dde74e264ad050afac3fe9f93ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*28EOZGYgw-pm2v_N71TsSg.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">拉斯特里金问题中种群的世代进化。(作者动画)。</p></figure><p id="a2f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在创建它的时候，我使用了<a class="ae kv" href="https://medium.com/@julian.blank/animations-in-matplotlib-no-need-to-struggle-42130f915c13" rel="noopener"> <em class="ls"> pyrecorder </em> </a>库，也是由<a class="me mf ep" href="https://medium.com/u/12b065b8160a?source=post_page-----78e4221e5cbe--------------------------------" rel="noopener" target="_blank"> Julian Blank </a>开发的。</p><p id="5b31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="#929c" rel="noopener ugc nofollow">返回目录。</a></p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="ab33" class="nu lz iq bd nv nw nx ny nz oa ob oc od jw oe jx of jz og ka oh kc oi kd oj ok bi translated">多目标优化简介</h1><blockquote class="ov ow ox"><p id="1981" class="kw kx ls ky b kz la jr lb lc ld ju le oy lg lh li oz lk ll lm pa lo lp lq lr ij bi translated">顾名思义，多目标优化涉及同时优化多个目标。当目标相互冲突时，即一个目标函数的最优解不同于另一个目标函数的最优解时，问题变得具有挑战性。在解决此类问题时，无论是否存在约束，这些问题都会产生一组折衷最优解，通常称为Pareto最优解。由于解决方案的多样性，建议使用进化算法来适当解决这些问题，该算法在其搜索过程中使用群体方法(Deb，2011)。</p></blockquote><p id="bc8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<em class="ls">支配</em>的概念可以理解<em class="ls">帕累托最优</em>解。它们是在给定群体中不受任何其他因素支配的解决方案。</p><p id="5c24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据Deb (2001)，如果满足以下条件，一个解<em class="ls"> x1 </em>优于另一个解<em class="ls"> x2 </em>:</p><ul class=""><li id="744d" class="mg mh iq ky b kz la lc ld lf mi lj mj ln mk lr or mm mn mo bi translated"><em class="ls"> x1 </em>在所有目标上不比<em class="ls"> x2 </em>差。</li><li id="64b6" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr or mm mn mo bi translated"><em class="ls"> x1 </em>至少在一个目标上比<em class="ls"> x2 </em>强。</li></ul><p id="09fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">已经提出了几种处理约束的想法。一种常用的方法是Deb等人(2002)在NSGA II中采用的方法，其中可行的解决方案总是比不可行的好，不可行的解决方案按照整体约束违反情况进行排序。</p><p id="02e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">双目标最小化问题的帕累托最优解如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/8de39b2acd4a969f1b3d5b464a050345.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*jkAnDFpHwNy0DxxCawUL1w.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">帕累托最优解。(图片由作者提供)。</p></figure><p id="b899" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">生存算子必须强调好的解决方案而不是坏的解决方案。在现代多目标算法中，<em class="ls">非支配排序</em>(或类似操作)几乎总是存在，它根据支配标准将每个解决方案归入一个<em class="ls">等级</em>。等级从最好到最差的解决方案按升序排列，通常是第一生存标准。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/7807dd105436da5ad7ffef5e8762937e.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*QOxkT7nWR0Ooez-7A37XaA.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">非支配排序和等级。(图片由作者提供)。</p></figure><p id="bb72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当超过种群规模时，具有相同等级的个体通过几种策略进行排序，其中两种常见的策略是NSGA-II中的<em class="ls">拥挤距离</em>(Deb等人，2002年)和NSGA-III中的<em class="ls">参考方向</em>(Deb&amp;Jain，2014年)。</p><p id="bc5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<em class="ls"> pymoode </em>算法中，默认情况下，GDE3和NSDE使用与NSGA-II相同的生存策略，而NSDE-R使用与NSGA-III相同的策略。</p><p id="5aa6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下一节中，我们将使用GDE3、NSDE和NSGA-II解决一个多目标问题(在<em class="ls"> pymoo </em>中实现)。</p><p id="7e1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="#929c" rel="noopener ugc nofollow">返回目录。</a></p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="2b40" class="nu lz iq bd nv nw nx ny nz oa ob oc od jw oe jx of jz og ka oh kc oi kd oj ok bi translated">多目标算法:GDE3和NSDE</h1><p id="81b9" class="pw-post-body-paragraph kw kx iq ky b kz om jr lb lc on ju le lf oo lh li lj op ll lm ln oq lp lq lr ij bi translated">GDE3和NSDE是DE的两个多目标变体，在<em class="ls">生存</em>阶段使用<em class="ls">非支配排序</em>和<em class="ls">拥挤度量</em>。它们共享相同的繁殖算子，尽管它们的生存策略不同。</p><p id="1a8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">NSDE使用完全(<em class="ls"> </em> + <em class="ls"> λ </em>)生存策略，将双亲群体与后代结合起来，而GDE3在将群体截断成原始大小之前，在双亲群体中的每个成员与其相应的试验向量之间进行一对一的比较。在这种<em class="ls">一对一</em>的比较中，每对个体中的一个可能会在(<em class="ls"> </em> + <em class="ls"> λ </em>)存活之前被另一个提前从组合群体中移除。</p><p id="6b94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于大多数问题，GDE3和NSDE将导致非常相似的结果。NSDE在某些问题上可能会稍微快一点，而GDE3在使用低<em class="ls"> CR </em>值时可能会更好地避免过早收敛。</p><p id="32af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们导入本节中使用的操作符。</p><pre class="kg kh ki kj gt lt lu lv bn lw lx bi"><span id="6827" class="ly lz iq lu b be ma mb l mc md"># Algorithms<br/>from pymoode.algorithms import GDE3<br/>from pymoode.algorithms import NSDE<br/>from pymoo.algorithms.moo.nsga2 import NSGA2<br/><br/># Termination<br/>from pymoo.termination.default import DefaultMultiObjectiveTermination</span></pre><p id="5b76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我将引入两个冲突的凸目标，这些目标由于约束而增加了难度。该问题将被定义在两个决策变量<em class="ls"> x1 </em>和<em class="ls"> x2 </em>上，它们都被-5.0和5.0所限制。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/234a651d6e133bac455631570a63fb8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*40Dx36WUHO7WpiGW9lQCQw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">多目标示例的目标函数。(图片由作者提供)。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/5ae6cd2f06c9cf362efcb56f1b56402d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*vzCqy3LWa4dm9UOOa-5Y_Q.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">多目标示例的约束函数。(图片由作者提供)。</p></figure><p id="ed5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Python代码中，使用了<em class="ls"> pymoo </em>问题<em class="ls">结构。</em></p><pre class="kg kh ki kj gt lt lu lv bn lw lx bi"><span id="2fd0" class="ly lz iq lu b be ma mb l mc md">class TwoObjExample(Problem):<br/><br/>    def __init__(self):<br/>        xl = np.full(2, -5.0)<br/>        xu = np.full(2, 5.0)<br/>        super().__init__(n_var=2, n_obj=2, n_ieq_constr=2, xl=xl, xu=xu)<br/><br/>    def _evaluate(self, x, out, *args, **kwargs):<br/><br/>        F1 = (x[:, 0] - 0.5) ** 2 + 0.7 * x[:, 0] * \<br/>            x[:, 1] + 1.2 * (x[:, 1] + 0.7) ** 2<br/><br/>        F2 = 1.1 * (x[:, 0] + 1.5) ** 2 + 0.8 * x[:, 0] * \<br/>            x[:, 1] + 1.3 * (x[:, 1] - 1.7) ** 2<br/><br/>        out["F"] = np.column_stack([F1, F2])<br/><br/>        G1 = x[:, 0] ** 2 + (x[:, 1] - 1) ** 2 - 9<br/>        G2 = - (x[:, 0] + 0.5) ** 2 - (x[:, 1] - 1) ** 2 + 2<br/>        out["G"] = np.column_stack([G1, G2])</span></pre><p id="c633" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，让我们定义停止标准。由于这是一个多目标问题，所以<em class="ls"> f </em>和<strong class="ky ir">xT39】的区别就不那么直观了。在<em class="ls"> pymoo </em>中，<em class="ls"> IGD </em>度量用于评估两个不同代之间<strong class="ky ir"> <em class="ls"> f </em> </strong>和<strong class="ky ir"> <em class="ls"> x </em> </strong>的差异。这个定义只是为了说明<em class="ls">defaultmultiobjectterminationoperator</em>的工作方式。</strong></p><pre class="kg kh ki kj gt lt lu lv bn lw lx bi"><span id="85ea" class="ly lz iq lu b be ma mb l mc md">termination_multi = DefaultMultiObjectiveTermination(<br/>    xtol=1e-8,<br/>    cvtol=1e-8,<br/>    ftol=1e-8,<br/>    period=50,<br/>    n_max_gen=200<br/>)</span></pre><p id="1492" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在解决这个问题时，除了GDE3和NSDE，我们将使用<em class="ls"> pymoo </em>中的NSGA-II的实现。再说一次，我还没有调整DE算法的控制参数。因此，他们可能已经得到改善。在NSGA-II中，采用了默认的<em class="ls">模拟二进制交叉</em>和<em class="ls">多项式变异</em>的控制参数，隐含为可选的关键字参数。</p><pre class="kg kh ki kj gt lt lu lv bn lw lx bi"><span id="6e6e" class="ly lz iq lu b be ma mb l mc md">gde3 = GDE3(pop_size=50, variant="DE/rand/1/bin",\<br/>    F=(0.0, 1.0), CR=0.7)<br/><br/>nsde = NSDE(pop_size=50, variant="DE/rand/1/bin",\<br/>    F=(0.0, 1.0), CR=0.7)<br/><br/>nsga2 = NSGA2(pop_size=30)</span></pre><p id="70da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们定义了算法和问题，让我们使用<em class="ls">最小化</em>接口来解决它。</p><pre class="kg kh ki kj gt lt lu lv bn lw lx bi"><span id="82e0" class="ly lz iq lu b be ma mb l mc md">res_gde3_problem_2 = minimize(<br/>    TwoObjExample(),<br/>    gde3,<br/>    termination_multi,<br/>    seed=12,<br/>    save_history=True,<br/>    verbose=False,<br/>)</span></pre><p id="9c1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有算法的过程都是一样的，只是改变了传递给<em class="ls">的第二个参数，使</em>最小化。<em class="ls"> </em>因此，我将省略其他实现。</p><p id="aaae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以使用几个度量来比较多目标问题中的性能。一些最常见的是<em class="ls">世代距离</em>、<em class="ls">反向世代距离</em>和<em class="ls">超级卷</em>。它们都是在<em class="ls"> pymoo </em>中用<a class="ae kv" href="https://pymoo.org/misc/indicators.html" rel="noopener ugc nofollow" target="_blank">例子</a>实现的。由于在这个问题中<em class="ls">真实波前</em>是先验未知的，我只使用了<em class="ls">超体积</em>来比较算法性能。</p><p id="cbae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整的实施可在<a class="ae kv" href="https://github.com/mooscaliaproject/pymoode/blob/main/notebooks/tutorial.ipynb" rel="noopener ugc nofollow" target="_blank"> <em class="ls">示例笔记本</em> </a>中找到，主要结果总结如下。</p><pre class="kg kh ki kj gt lt lu lv bn lw lx bi"><span id="eeda" class="ly lz iq lu b be ma mb l mc md">hv GDE3 0.753470843848252<br/>hv NSDE 0.752272658484699<br/>hv NSGA-II 0.7527205037080124</span></pre><p id="ff2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这三种算法表现出非常相似的性能，尽管GDE3略胜一筹。或许，在几次独立的运行中，这不会呈现出统计学意义。</p><p id="da99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了说明进化的过程，我使用GDE3解决方案的<em class="ls"> pyrecorder </em>创建了一些简短的动画。前70代在决策变量和目标空间中都有说明。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/50e8a09e8bd48b9fd3ebeefb5508dcf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*gIsYk65_lXciTyOI-d8-vQ.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">基于GDE3的多目标实例在决策空间中的进化过程。(作者动画)。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/11cbd2f32efde813d409aef8de69a16b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*hcE45NTSbNm3JdLAHuN1CA.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">基于GDE3的多目标实例在目标空间中的演化过程。(作者动画)。</p></figure><p id="c6c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="#929c" rel="noopener ugc nofollow">返回目录。</a></p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="27ba" class="nu lz iq bd nv nw nx ny nz oa ob oc od jw oe jx of jz og ka oh kc oi kd oj ok bi translated">改进双目标问题的解决方案</h1><p id="9a76" class="pw-post-body-paragraph kw kx iq ky b kz om jr lb lc on ju le lf oo lh li lj op ll lm ln oq lp lq lr ij bi translated">虽然前一部分的结果很好，但是<em class="ls"> Pareto前沿</em>可以更平滑，元素的分布也可以更均匀。这是由于与NSGA-II中提出的原始策略相比，<em class="ls">等级和拥挤</em>生存的其他变体的优越性能。为了在生存阶段给用户提供更多的选择，<em class="ls"> RankAndCrowding </em>类已经在<em class="ls"> pymoode </em>中实现。</p><p id="aca2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为提高多样性而采用的相关策略是递归地消除个体并重新计算拥挤度量，而不是基于整个前沿的拥挤度量从超过群体大小的最后一个前沿立即消除所有个体。Kukkonen &amp; Deb (2006a)对修改后的策略进行了深入分析。</p><p id="03a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使用Kukkonen &amp; Deb (2006a)的剪枝策略，我们必须在RankAndCrowding算子中选择不同的拥挤函数。在<em class="ls"> pymoode </em>中，表示为<em class="ls">【PCD】</em>，代表“修剪拥挤距离”。由于Cython的实施，它的速度与原来的运营商一样快。</p><p id="74d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就目前而言，可以执行如下。</p><pre class="kg kh ki kj gt lt lu lv bn lw lx bi"><span id="455b" class="ly lz iq lu b be ma mb l mc md"># Import survival operator<br/>from pymoode.survival import RankAndCrowding<br/><br/># Instantiate it with respective elimination rule and crowding metric<br/>pruning_survival = RankAndCrowding(crowding_func="pcd")<br/><br/># Pass it in the survival argument of the algorithm<br/>gde3_ps = GDE3(pop_size=50, variant="DE/rand/1/bin", F=(0.0, 1.0),<br/>               CR=0.7, survival=pruning_survival)</span></pre><p id="c8ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这产生了比原始拥挤距离算法更均匀的解分布。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pe"><img src="../Images/caaab262b9273c70cb8272000846e338.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bLbbDFUPPso06g1xBr5F4g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">GDE3中修剪拥挤距离与原始拥挤距离的比较。(图片由作者提供)。</p></figure><p id="9a96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了评估帕累托前沿元素的分布情况，可以使用<em class="ls">间距</em>指示器，该指示器在<em class="ls"> pymoode </em>中实现。该指标的值越小，要素在帕累托前沿的分布越均匀。</p><pre class="kg kh ki kj gt lt lu lv bn lw lx bi"><span id="3876" class="ly lz iq lu b be ma mb l mc md">from pymoode.performance import SpacingIndicator<br/><br/>ideal = np.vstack(<br/>    (res_gde3_problem_2.F, res_gde3_ps_problem_2.F)<br/>).min(axis=0) - 1e-3<br/><br/>nadir= np.vstack(<br/>    (res_gde3_problem_2.F, res_gde3_ps_problem_2.F)<br/>).max(axis=0) + 1e-3<br/><br/>sp_p2 = SpacingIndicator(<br/>    zero_to_one=True, ideal=ideal, nadir=nadir<br/>)<br/><br/>print("SP GDE3", sp_p2.do(res_gde3_problem_2.F))<br/>print("SP GDE3-PS", sp_p2.do(res_gde3_ps_problem_2.F))</span></pre><p id="d14a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它返回:</p><pre class="kg kh ki kj gt lt lu lv bn lw lx bi"><span id="3fdd" class="ly lz iq lu b be ma mb l mc md">SP GDE3 0.012024880243150753<br/>SP GDE3-PS 0.004881671664926163</span></pre><p id="481d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在提供了一个定量的度量标准来衡量由于采用了修改的剪枝解决方案策略而带来的分布上的改进。</p><p id="d690" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="#929c" rel="noopener ugc nofollow">返回目录。</a></p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="c5da" class="nu lz iq bd nv nw nx ny nz oa ob oc od jw oe jx of jz og ka oh kc oi kd oj ok bi translated">多目标算法:NSDE-R和GDE3-MNN</h1><p id="3208" class="pw-post-body-paragraph kw kx iq ky b kz om jr lb lc on ju le lf oo lh li lj op ll lm ln oq lp lq lr ij bi translated">由于GDE3和NSDE最初是使用NSGA-II等级和拥挤生存设计的，它们在许多目标问题上表现不佳。然而，从用户的角度来看，简单的修改就可以解决这个问题。</p><p id="149c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">NSDE-R (Reddy &amp; Dulikravich，2019)结合了NSGA-III的生存算子和DE的繁殖算子，在多目标问题中表现出色。GDE3-MNN是由Kukkonen和Deb (2006b)提出的GDE3的变体，其用具有递归消除和重新计算的基于<em class="ls"> M </em>最近邻的拥挤度量代替了<em class="ls">等级和拥挤</em>生存的原始拥挤距离。它大大提高了GDE3在多目标问题上的性能。</p><p id="b735" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">特别是在多目标问题中，由于目标空间的稀疏性，当使用相同的生存策略时，NSDE和GDE3会产生比<em class="ls">双目标</em>问题更加相似的结果。因此，在本节中，将只实现每种方法的一种变体。</p><p id="b9a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了DE算法，我们还将实现NSGA-III，这是多目标优化中最成功的算法之一。</p><p id="c1b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们导入新的运算符。</p><pre class="kg kh ki kj gt lt lu lv bn lw lx bi"><span id="eef3" class="ly lz iq lu b be ma mb l mc md"># Algorithms<br/>from pymoode.algorithms import NSDER, GDE3<br/>from pymoo.algorithms.moo.nsga3 import NSGA3<br/><br/># Interface to obtain reference direction<br/>from pymoo.util.ref_dirs import get_reference_directions</span></pre><p id="d741" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我将使用<em class="ls"> get_problem </em>接口导入一个在<em class="ls"> pymoo </em>中实现的多目标问题。它将是<a class="ae kv" href="https://pymoo.org/problems/many/dtlz.html#DTLZ2" rel="noopener ugc nofollow" target="_blank"> DTLZ2 </a>，其中<strong class="ky ir"> <em class="ls"> x </em> </strong>中的每个组件都被定义在范围[0，1]中，并且没有函数约束。这些目标由下面的等式描述。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/3809c3d880aa6c5c3af97262c2de8fc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*3ZsWf9xfd4inLyhjVdeUEw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">DTLZ2问题的目标函数。(图片由作者提供)。</p></figure><p id="ea8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们举例说明本节中使用的算法。注意参考方向是NSDE-R和NSGA-III的必选项。幸运的是，<em class="ls"> pymoo </em>有一个接口可以轻松获得通常的方向。此外，请注意，在GDE3中，<em class="ls"> RankAndCrowding </em>运算符与<em class="ls">crowding _ func</em>=<em class="ls">' mnn '</em>一起使用，后者使用前面提到的<em class="ls"> M </em> -NN策略。或者，我们可以只导入<em class="ls"> GDE3MNN </em>类。</p><pre class="kg kh ki kj gt lt lu lv bn lw lx bi"><span id="a987" class="ly lz iq lu b be ma mb l mc md"># Define the reference directions<br/>ref_dirs = get_reference_directions(<br/>    "das-dennis", 3, n_partitions=15)<br/><br/># Suggestion for NSGA-III<br/>popsize = ref_dirs.shape[0] + ref_dirs.shape[0] % 4<br/><br/>nsder = NSDER(ref_dirs, pop_size=popsize,<br/>    variant="DE/rand/1/bin", F=(0.0, 1.0), CR=0.5)<br/><br/>gde3mnn = GDE3(pop_size=popsize,<br/>    variant="DE/rand/1/bin", F=(0.0, 1.0), CR=0.2,<br/>    survival=RankAndCrowding(crowding_func="mnn"))<br/><br/>nsga3 = NSGA3(ref_dirs, pop_size=popsize)</span></pre><p id="a60e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一节中，我将采用一个简化的终止准则(' n_gen '，250)，仅基于世代数，这对于多目标问题是常见的。</p><pre class="kg kh ki kj gt lt lu lv bn lw lx bi"><span id="1191" class="ly lz iq lu b be ma mb l mc md">res_nsder_problem_3 = minimize(<br/>    get_problem("dtlz2"),<br/>    nsder,<br/>    ('n_gen', 250),<br/>    seed=SEED,<br/>    save_history=True,<br/>    verbose=True,<br/>)</span></pre><p id="c286" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个问题上，NSGA-III比差分进化算法产生了更接近参考点的解，尽管差分进化算法的性能也很好。</p><p id="9ef6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过完成算法获得的帕累托前沿显示在下面的动画中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/3d47ec32c9e55fca11620281826034bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*uiuJmVbO4eTNQoJRLArG5Q.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在DTLZ2中获得的Pareto前沿。(作者动画)。</p></figure><p id="9b2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太好了！现在我们已经完成了pymoode中的操作符，解决了几个不同的问题。</p><p id="9568" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="#929c" rel="noopener ugc nofollow">返回目录。</a></p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="8bf5" class="nu lz iq bd nv nw nx ny nz oa ob oc od jw oe jx of jz og ka oh kc oi kd oj ok bi translated">应用和前景</h1><p id="8f2f" class="pw-post-body-paragraph kw kx iq ky b kz om jr lb lc on ju le lf oo lh li lj op ll lm ln oq lp lq lr ij bi translated">多目标进化算法已经应用于许多不同的领域，包括投资组合优化(赵等，2020)，电厂运行(王等，2014)，供水系统(Monsef等，2019)，以及网络控制(Gonç alves等，2022)。此外，工程过程设计和控制有许多应用，作为一名化学工程师，这就是我开始的地方。</p><p id="0ab0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我第一次遇到多目标进化算法是在为我的第一篇文章<a class="ae kv" href="https://doi.org/10.1016/j.ces.2021.116805" rel="noopener ugc nofollow" target="_blank">苯乙烯反应器</a>的模拟和优化做文献综述(Leite等人，2021)。Yee等人(2003)使用Srinivas &amp; Deb (1994)的原始NSGA算法对该问题进行了首次应用。它产生了很大的结果，后来激发了Tarafader等人(2005)的研究，除了增加问题公式化的复杂性以在目标中加入更多的过程外，还采用了更有效的算法:NSGA-II (Deb等人，2002)。Babu等人(2005年)和Gujarathi &amp; Babu (2010年)也提出了一种解决苯乙烯反应器问题的多目标差分进化方法。</p><p id="5632" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我发现看到算法在过去几十年中是如何改进并提供给用户的令人惊讶。包<em class="ls"> pymoode </em>开始试图通过进化方法优化复杂的反应堆模拟模型，但现在我相信它已经变得更好，因为它为任何Python用户提供了一些迄今为止提出的最有效的差分进化算法和工具。</p><p id="5f58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我现在更新这篇中型文章时，开发了<em class="ls"> pymoode </em>的关于苯乙烯反应器的多目标优化的主要研究论文以标题<a class="ae kv" href="https://doi.org/10.1016/j.ces.2022.118196" rel="noopener ugc nofollow" target="_blank"> <em class="ls">使用广义差分进化的绝热苯乙烯反应器的多目标优化3(GD E3)</em></a><em class="ls"/>(Leite等人，2023)发表。如果出于学术目的使用<em class="ls"> pymoode </em>，请相应引用。</p><p id="f7db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="#929c" rel="noopener ugc nofollow">返回目录。</a></p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="2cb7" class="nu lz iq bd nv nw nx ny nz oa ob oc od jw oe jx of jz og ka oh kc oi kd oj ok bi translated">结论</h1><p id="27dc" class="pw-post-body-paragraph kw kx iq ky b kz om jr lb lc on ju le lf oo lh li lj op ll lm ln oq lp lq lr ij bi translated">在本文中，Python包<a class="ae kv" href="https://github.com/mooscaliaproject/pymoode" rel="noopener ugc nofollow" target="_blank"> <em class="ls"> pymoode </em> </a>提供了解决单目标、多目标和多目标问题的教程。该软件包是对专注于差分进化算法的<a class="ae kv" href="https://pymoo.org/" rel="noopener ugc nofollow" target="_blank"><em class="ls">pymoo</em></a><em class="ls"/>的扩展，具有各种各样的操作符，可确保出色的性能并允许高度定制。用于生成本文的所有代码都可以在<a class="ae kv" href="https://github.com/mooscaliaproject/pymoode/blob/main/notebooks/tutorial.ipynb" rel="noopener ugc nofollow" target="_blank"> Github </a>上获得。<em class="ls">py mood</em>的新功能可能会在以后被<em class="ls"> pymoo </em>整合。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="7872" class="nu lz iq bd nv nw nx ny nz oa ob oc od jw oe jx of jz og ka oh kc oi kd oj ok bi translated">承认</h1><p id="9c0a" class="pw-post-body-paragraph kw kx iq ky b kz om jr lb lc on ju le lf oo lh li lj op ll lm ln oq lp lq lr ij bi translated">朱利安·布兰克，他创造了<em class="ls">皮穆</em>的惊人结构，使得这样一个项目成为可能。</p><p id="b1d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢<a class="me mf ep" href="https://medium.com/u/faa75a9d06fc?source=post_page-----78e4221e5cbe--------------------------------" rel="noopener" target="_blank">小埃斯利·费雷拉·达·科斯塔</a>，是他让这一切成为可能。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="6c06" class="nu lz iq bd nv nw nx ny nz oa ob oc od jw oe jx of jz og ka oh kc oi kd oj ok bi translated">参考</h1><p id="b569" class="pw-post-body-paragraph kw kx iq ky b kz om jr lb lc on ju le lf oo lh li lj op ll lm ln oq lp lq lr ij bi translated">Babu，B. V .，Chakole，P. G .和Mubeen，J. H. S .，2005年。绝热苯乙烯反应器优化的多目标差分进化算法。<em class="ls">化学。英语。Sci。，</em>第60卷，第4822–4837页。</p><p id="bdb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Blank，j .和Deb，k .，2020年。pymoo:Python中的多目标优化。<em class="ls"> IEEE访问，</em>第8卷，第89497–89509页。</p><p id="1ddf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">k . deb，2001年。<em class="ls">采用进化算法的多目标优化。</em>1版。奇切斯特:约翰·威利的儿子们。</p><p id="2ead" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">k . deb，2004年。工程优化遗传算法导论。载于:G. C. Onwubolu和b .诉Babu，编辑。模糊性和软计算工程研究中的新优化技术，第141卷。海德堡:施普林格出版社，柏林海德堡，第13-51页。</p><p id="859a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">黛比，k，2011。使用进化算法的多目标优化:导论。产品设计和制造的多目标进化优化。伦敦:施普林格出版社，第3-34页。</p><p id="0b7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Deb，k .和Jain，h .，2014年。使用基于参考点的非支配排序方法的进化多目标优化算法，第一部分:解决带盒约束的问题。<em class="ls"> IEEE进化计算汇刊，</em> 18(4)，第577–601页。</p><p id="af34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">戴布，k，普拉塔普，a，阿加瓦尔，s &amp;梅亚利万，交通运输管理，2002年。一种快速的精英多目标遗传算法:NSGA-II。<em class="ls"> IEEE进化计算汇刊，</em> 6(2)，第182–197页。</p><p id="57e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">贡萨尔维斯，E. N .，贝洛，M. A. R .和巴蒂斯塔，A. P .，2022。网络控制系统中优化网络使用的具有优先前沿精英策略的自适应多目标差分进化算法。应用软件计算。，第114卷，第108112页。</p><p id="1cc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">古吉拉特邦，A. M .和Babu，B. V .，2010年。工业苯乙烯反应器的多目标优化:绝热和伪等温操作。<em class="ls">化学。英语。Sci。，</em>第65卷，第2009–2026页。</p><p id="280b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Kukkonen，s .和Deb，k .，2006年a。<em class="ls">基于拥挤距离的双目标优化问题非支配解的改进剪枝。温哥华，南北卡罗来纳州，第1179-1186页。</em></p><p id="f37e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Kukkonen，s .和Deb，k .，2006年b。一种快速有效的多目标问题非支配解剪枝方法。In: <em class="ls">来自自然的并行问题求解——PPSN九世。柏林:施普林格出版社，第553-562页。</em></p><p id="ce22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Kukkonen，s .和Lampinen，j .，2005年。GDE3:广义差分进化的第三步进化。2005年IEEE进化计算大会，第1卷，第443-450页。</p><p id="4a97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">莱特，b，科斯塔，A. O. S .和科斯塔少年，E. F .，2021。基于非均相动力学模型的乙苯脱氢轴向流和径向流反应器的模拟与优化。<em class="ls">化学。英语。Sci。，</em>第244卷，第116805条。</p><p id="500f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">莱特，b，科斯塔，A. O. S .，科斯塔，E. F .，2023。基于广义差分进化算法3的绝热苯乙烯反应器多目标优化。化学。英语。Sci。，第265卷，第118196条。</p><p id="9aca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Monsef，h .，Naghashzadegan，m .，Jamali，A. &amp; Farmani，r .，2019年。给水管网优化设计中进化多目标优化算法的比较。<em class="ls"> Ain Shams工程杂志，</em>第10卷，第103–111页。</p><p id="f4ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">普莱斯，K. V .，Storn，R. M .和Lampinen，J. A .，2005年。差分进化:一种实用的全局优化方法。第一版。柏林。</p><p id="bf81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Reddy，S. R .和Dulikravich，G. S .，2019年。基于参考点的多目标差分进化优化:NSDE-R. <em class="ls"> Struct。多碟。Optim。，</em>第60卷，第1473—1455页。</p><p id="ddbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">斯里尼瓦斯，n .和德布，k .，1994年。遗传算法中使用非支配排序的多目标优化。<em class="ls">进化计算，</em> 2(3)，第221–248页。</p><p id="4bd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">storn r .和Price k .，1997年。差分进化——连续空间全局优化的简单有效的启发式算法。<em class="ls">全球j。Optim。，</em>第11卷第4期，第359—341页。</p><p id="a62d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Tarafder，a .，Rangaiah，g .和Ray，A. K .，2005年。工业苯乙烯单体生产过程的多目标优化。<em class="ls">化学。英语。Sci。，</em>第60卷第2期，第363—347页。</p><p id="8f70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">王等，2014。基于差分进化的燃煤电厂多目标优化。<em class="ls">应用能量，</em>第115卷，第254–264页。</p><p id="dece" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">王燕宁，吴，李良宏，袁晓峰，2010。基于精英保留和拥挤熵多样性测度的多目标自适应差分进化。<em class="ls">软计算。，</em>第14卷第3期，第209—193页。</p><p id="23da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">易，雷，兰盖亚，2003。工业苯乙烯反应器的多目标优化。计算机。化学。英语。，第27卷第1期，第130—111页。</p><p id="2c91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">赵平，高，杨，倪，2020。基于MOEA/D的多目标投资组合优化问题求解<em class="ls"> 2020年第12届高级计算智能国际会议(ICACI)</em>第30–37页。</p></div></div>    
</body>
</html>