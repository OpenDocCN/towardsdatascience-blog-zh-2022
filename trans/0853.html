<html>
<head>
<title>Grouping Data in Data Science</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学中的数据分组</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/grouping-data-in-data-science-be7387870c4d#2022-03-08">https://towardsdatascience.com/grouping-data-in-data-science-be7387870c4d#2022-03-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="047f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">著名聚类算法背后的技术的简单概述</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/12030de0779ef626ad5212264a1a7a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nfjoJnmwpktGDdQb4h7xAQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马尔万·艾哈迈德</p></figure><blockquote class="ky"><p id="e452" class="kz la it bd lb lc ld le lf lg lh li dk translated">“物以类聚，人以群分”</p></blockquote><p id="bf27" class="pw-post-body-paragraph lj lk it ll b lm ln ju lo lp lq jx lr ls lt lu lv lw lx ly lz ma mb mc md li im bi translated">这是一个众所周知的谚语，我们从小就听说过。这表明，相同类型或具有相似特征的个体往往彼此更接近。</p><p id="b1ff" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">在数据科学中，这种自然现象被称为聚类，它用于通过发现几个组来发现数据中的分组，当与其他组中的对象相比时，这些组中的对象与同一组中的对象基本相似。</p><h2 id="d208" class="mk ml it bd mm mn mo dn mp mq mr dp ms ls mt mu mv lw mw mx my ma mz na nb nc bi translated">应用程序</h2><p id="02e5" class="pw-post-body-paragraph lj lk it ll b lm nd ju lo lp ne jx lr ls nf lu lv lw ng ly lz ma nh mc md li im bi translated">聚类具有多种功能，包括生成肉眼看不到的洞察力的能力。例如，一个众所周知的应用是<em class="mj">犯罪热点识别、</em>，其中可以通过聚类来定位罪犯和/或防止更多犯罪。另一方面，在通过分析具有相似特征的消费者来帮助企业完成诸如<em class="mj">目标营销</em>等任务的情况下，它可能非常有价值。</p><p id="8105" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">它在<em class="mj">数据挖掘、社会网络分析、在线集群引擎、生物数据分析、图像处理</em>等方面也有广泛的应用。如你所见，几乎在每个领域都有应用，理解这一点是非常有价值的。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h2 id="d7ee" class="mk ml it bd mm mn mo dn mp mq mr dp ms ls mt mu mv lw mw mx my ma mz na nb nc bi translated">聚类算法的类别</h2><p id="261d" class="pw-post-body-paragraph lj lk it ll b lm nd ju lo lp ne jx lr ls nf lu lv lw ng ly lz ma nh mc md li im bi translated">你可能认为将对象分组很容易。但是你有没有有条不紊地尝试过，以至于连机器都可以做到。</p><p id="709d" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">多年前，研究人员已经提出了许多算法来实现这一点，但很少有非常常用的算法，如 K 均值、聚类等。这些知识对于数据科学学习者、从业者或该领域的任何人来说都是非常有价值的。这是因为每种算法都有自己的优缺点，因此在为特定任务选择正确的聚类方法时，有必要彻底掌握它们。</p><p id="c7c3" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">本文的重点是概述聚类算法的主要类别。大多数著名的算法可以分为三类。</p><ul class=""><li id="964a" class="np nq it ll b lm me lp mf ls nr lw ns ma nt li nu nv nw nx bi translated">分割聚类</li><li id="0e57" class="np nq it ll b lm ny lp nz ls oa lw ob ma oc li nu nv nw nx bi translated">分层聚类</li><li id="59ea" class="np nq it ll b lm ny lp nz ls oa lw ob ma oc li nu nv nw nx bi translated">基于密度的聚类</li></ul></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h2 id="a5eb" class="mk ml it bd mm mn mo dn mp mq mr dp ms ls mt mu mv lw mw mx my ma mz na nb nc bi translated">分割聚类</h2><p id="c636" class="pw-post-body-paragraph lj lk it ll b lm nd ju lo lp ne jx lr ls nf lu lv lw ng ly lz ma nh mc md li im bi translated">当我们听到“隔断”这个名字时，我们脑海中浮现的是将一个空间分成几个部分，就像我们家的内墙一样。部分聚类的作用是完全一样的。它通过将更接近的项目分组在一起来创建用户指定的组数。它是如何有条不紊地完成的，</p><blockquote class="ky"><p id="90e9" class="kz la it bd lb lc od oe of og oh li dk translated">选择 k 个不同的聚类中心，并开始吸引最接近该聚类的数据点。</p></blockquote><p id="4ac4" class="pw-post-body-paragraph lj lk it ll b lm ln ju lo lp lq jx lr ls lt lu lv lw lx ly lz ma mb mc md li im bi translated">在这些技术中，每个数据点将根据一组标准被分配到第 k 个聚类，genreally 旨在改进相似性函数，以便距离成为一个重要的元素。该过程将迭代地继续，直到迭代稳定，这意味着只有当一个聚类中的样本没有传递到另一个聚类时，该过程才会结束。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/34b884d1cab9e3b6c7fcb292b55f6b0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sp3UKl9DZHL4n5cCQRajzQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片:分区聚类，k=2</p></figure><p id="a2fb" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">这些方法的一个主要特征是它们要求用户定义聚类的数量，这由变量 K 表示。<strong class="ll iu"> K-means、k-medoids 和 k mode </strong>是划分聚类技术的三个例子。</p><p id="56f3" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated"><strong class="ll iu">优势<br/> - </strong>简单、有效、<strong class="ll iu">可扩展</strong>且易于部署<br/> -同步计算所有可达到的集群<strong class="ll iu"/>。<br/> -当集群具有<strong class="ll iu">球形</strong>时，它们工作良好。</p><p id="07b7" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated"><strong class="ll iu">缺点<br/> - </strong>需要<strong class="ll iu">在开始时定义簇数</strong>。<br/> -尝试制作<strong class="ll iu">球形</strong>集群，不适合复杂形状<br/> -尝试制作<strong class="ll iu">大小相同的集群。</strong><br/>——它们是<strong class="ll iu">不确定的</strong>，因此完全不同的排列可以由初始随机选择的聚类中心的微小变化而产生。</p><h2 id="179a" class="mk ml it bd mm mn mo dn mp mq mr dp ms ls mt mu mv lw mw mx my ma mz na nb nc bi translated">分层聚类</h2><p id="3ea3" class="pw-post-body-paragraph lj lk it ll b lm nd ju lo lp ne jx lr ls nf lu lv lw ng ly lz ma nh mc md li im bi translated">在层次聚类中，分组是在将它们按层次排列后进行的。有两种主要方法可以做到这一点:</p><ul class=""><li id="75f5" class="np nq it ll b lm me lp mf ls nr lw ns ma nt li nu nv nw nx bi translated">自下而上的方法是<strong class="ll iu"> </strong>称为<strong class="ll iu">凝聚聚类。</strong></li></ul><blockquote class="ky"><p id="3f6d" class="kz la it bd lb lc ld le lf lg lh li dk translated">将每个观察值视为独立聚类，然后开始迭代合并最接近的聚类对。</p></blockquote><p id="2d64" class="pw-post-body-paragraph lj lk it ll b lm ln ju lo lp lq jx lr ls lt lu lv lw lx ly lz ma mb mc md li im bi translated">通俗地说，这类似于一个社区是如何建立的。每一对最亲密的个体首先聚在一起。然后，每一对与另一对具有最相似特征的组合，这在理论上可以反复发生，直到所有的个体都在一个群体中。</p><ul class=""><li id="362e" class="np nq it ll b lm me lp mf ls nr lw ns ma nt li nu nv nw nx bi translated">自上而下的方法被称为<strong class="ll iu">分裂聚类</strong></li></ul><blockquote class="ky"><p id="d46a" class="kz la it bd lb lc ld le lf lg lh li dk translated">将所有数据视为一个聚类，然后开始在每一步拆分最不相似的聚类，直到只剩下单个数据点。</p></blockquote><p id="4c1f" class="pw-post-body-paragraph lj lk it ll b lm ln ju lo lp lq jx lr ls lt lu lv lw lx ly lz ma mb mc md li im bi translated">与上面的例子类似，这可以用一个社区如何发生分裂来解释。首先，所有的个体都在一个群体中。然后，如果两个群体有不同的信仰，社区将分裂成两个群体，形成两个子社区。这在理论上可以反复发生，直到一个社区最终只有一个个体。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/55d59ae0217d7bb24183581017dca1e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sgRIMZabvHL_g736KdtrCw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片:层次聚类</p></figure><p id="656a" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">集群层次的传统可视化是一个树状图<em class="mj">。</em>树状图是由这些方法产生的基于树的点层次结构。</p><p id="de82" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">类似于分区聚类，用户经常选择分层聚类中的聚类数目(k)。通过在一定深度切割树状图来创建聚类，产生 k 个更小树状图的分组。</p><p id="8740" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated"><strong class="ll iu">优势<br/> -确定性</strong>过程，意味着当您对相同的输入数据执行两次算法时，聚类分配不会改变。<br/> - <strong class="ll iu">不必在开始时定义最终的聚类数</strong><br/>-更高的树状图可解释性。<br/> - <strong class="ll iu">更深入地洞察</strong>关系，有利于<strong class="ll iu">小型</strong>数据集</p><p id="e662" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated"><strong class="ll iu">缺点<br/> - </strong> C <strong class="ll iu">比较贵</strong>。<br/> -对<strong class="ll iu">异常值</strong>非常敏感</p><h2 id="ee97" class="mk ml it bd mm mn mo dn mp mq mr dp ms ls mt mu mv lw mw mx my ma mz na nb nc bi translated">基于密度的方法</h2><p id="d010" class="pw-post-body-paragraph lj lk it ll b lm nd ju lo lp ne jx lr ls nf lu lv lw ng ly lz ma nh mc md li im bi translated">这里分组是根据一个区域中数据点的密度进行的。它可识别点密集且被空白或稀疏区域分隔的位置。基本上，它</p><blockquote class="ky"><p id="3f40" class="kz la it bd lb lc od oe of og oh li dk translated">将数据紧密包装在一起—高密度区域视为群集</p></blockquote><figure class="ol om on oo op kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/5a2e2ff554d95542b4878110acf12628.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*40gtrQoP_IJhrWKU0352zQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片:基于密度的聚类</p></figure><p id="a45d" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">与以前的聚类方法不同，这种方法不需要用户提供聚类数。相反，基于距离的参数用于设置可变阈值。此参数决定了聚类中必须包含的接近点的数量。与其他方法不同，基于密度的聚类对异常值具有鲁棒性。这里，没有必要对每个点进行聚类以形成聚类。</p><p id="fd28" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">常用的基于密度的聚类算法的例子包括<strong class="ll iu"> DBSCAN </strong>(带噪声的应用的基于密度的空间聚类)和<strong class="ll iu"> OPTICS </strong>(对点进行排序以识别聚类结构)。</p><p id="ffb6" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated"><strong class="ll iu">优势<br/> - </strong>更擅长识别<strong class="ll iu">任意形状的</strong>星团。<br/> -抵抗<strong class="ll iu">异常值</strong>。<br/> -不需要在开始时定义簇的数量</p><p id="51f4" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated"><strong class="ll iu">缺点<br/> - </strong>难以识别密度<strong class="ll iu"/><br/>-难以处理<strong class="ll iu">高维度</strong>空间</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h2 id="a965" class="mk ml it bd mm mn mo dn mp mq mr dp ms ls mt mu mv lw mw mx my ma mz na nb nc bi translated">结论</h2><p id="44c9" class="pw-post-body-paragraph lj lk it ll b lm nd ju lo lp ne jx lr ls nf lu lv lw ng ly lz ma nh mc md li im bi translated">上面提到了一些最常用的聚类算法类别。然而，还有更多，如基于模型的、基于网格的、基于遗传的等等。实际上，没有精确的聚类方法可以提前选择，因为潜在的数学方法经常不能产生现实的可解释的结果。</p><p id="dcdd" class="pw-post-body-paragraph lj lk it ll b lm me ju lo lp mf jx lr ls mg lu lv lw mh ly lz ma mi mc md li im bi translated">然而，正如文献中所指出的，在许多情况下都有更好的技术，如果挖掘得足够深入，可以发现许多不同的 od 算法变体。一般来说，划分算法被认为更适合大型数据集，因为它们是可扩展的，而分层方法被认为更适合小型数据集，因为它们更具适应性。另一方面，当存在噪声和异常值时，基于密度的聚类更健壮。</p></div></div>    
</body>
</html>