<html>
<head>
<title>Apply Functions to Pandas DataFrame Using map(), apply(), applymap() and pipe()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用map()、Apply()、applymap()和pipe()将函数应用到Pandas数据帧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/apply-functions-to-pandas-dataframe-using-map-apply-applymap-and-pipe-9571b1f1cb18#2022-04-04">https://towardsdatascience.com/apply-functions-to-pandas-dataframe-using-map-apply-applymap-and-pipe-9571b1f1cb18#2022-04-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b855" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">什么是熊猫地图，应用，应用地图和管道？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3f5dcc314dc0c1a519d9f47f6397169e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-cLpHWbSYWZDS_NJ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@itookthose?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Sid Balachandran </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="5d40" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="a036" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe mn mo mp mq b">apply</code>、<code class="fe mn mo mp mq b">applymap</code>、<code class="fe mn mo mp mq b">map</code>和<code class="fe mn mo mp mq b">pipe</code>可能会令人困惑，特别是如果你对熊猫不熟悉的话，因为它们看起来都很相似，并且能够接受功能作为输入。这里有一个不同方法的快速比较。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/192ee6aababa90492bacb8f2cf74025d.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/0*YkXAYT7Kzx139UGr"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b5fe" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">我们将使用下面的样本数据来详细研究它们。</p><pre class="kj kk kl km gt mx mq my mz aw na bi"><span id="833a" class="nb la it mq b gy nc nd l ne nf"># python version 3.9<br/># pandas version 1.4.1</span><span id="4e20" class="nb la it mq b gy ng nd l ne nf">import pandas as pd</span><span id="c092" class="nb la it mq b gy ng nd l ne nf">df = pd.DataFrame({'name':['John Doe', 'Mary Re', 'Harley Me'],<br/>                   'gender':[1,2,0],<br/>                   'age':[80, 38, 12],<br/>                   'height': [161.0, 173.5, 180.5],<br/>                   'weight': [62.3, 55.7, 80.0]<br/>                   })</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/d334e8ccf30dcc17c539a2307b8fc6b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/0*ZUC8YACr3qf4yKCK"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><ul class=""><li id="d373" class="ni nj it lt b lu ms lx mt ma nk me nl mi nm mm nn no np nq bi translated"><code class="fe mn mo mp mq b">gender</code> : 0，1，2分别表示“未知”、“男性”和“女性”</li><li id="0843" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated"><code class="fe mn mo mp mq b">height</code>:厘米</li><li id="c86e" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated"><code class="fe mn mo mp mq b">weight</code>:单位为千克</li></ul><h1 id="88ed" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">熊猫<code class="fe mn mo mp mq b">map()</code>是什么？</h1><blockquote class="nw nx ny"><p id="9147" class="lr ls nz lt b lu ms ju lw lx mt jx lz oa mu mc md ob mv mg mh oc mw mk ml mm im bi translated"><code class="fe mn mo mp mq b"><em class="it">pandas.series.map</em></code> <em class="it">根据输入映射函数映射系列的值。用于将一个数列中的每一个值替换为另一个值，该值可以是从一个函数、一个字典或一个数列中导出的。</em></p></blockquote><p id="83ae" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><strong class="lt iu">参数</strong></p><ul class=""><li id="930b" class="ni nj it lt b lu ms lx mt ma nk me nl mi nm mm nn no np nq bi translated"><code class="fe mn mo mp mq b">arg</code>:映射对应关系</li><li id="ca17" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated"><code class="fe mn mo mp mq b">na_action</code> : { '无'，'忽略' }。默认无。如果“ignore ”,则传播NaN值，而不将它们传递给映射对应。</li></ul><p id="ac57" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><strong class="lt iu">退货</strong></p><ul class=""><li id="4c28" class="ni nj it lt b lu ms lx mt ma nk me nl mi nm mm nn no np nq bi translated"><code class="fe mn mo mp mq b">Series</code></li></ul><p id="fb76" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><strong class="lt iu">要点</strong></p><ol class=""><li id="2e96" class="ni nj it lt b lu ms lx mt ma nk me nl mi nm mm od no np nq bi translated">仅适用于熊猫系列</li><li id="0585" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm od no np nq bi translated">元素式操作</li><li id="858f" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm od no np nq bi translated">主要用于替换值</li><li id="34c5" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm od no np nq bi translated"><code class="fe mn mo mp mq b">arg</code>参数接受旧值和新值之间的映射，可以是(a)字典、(b)系列和(c)函数的形式。</li></ol><p id="01f4" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><strong class="lt iu">字典</strong></p><p id="d812" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">目标是将编码的性别(0，1，2)替换为它们的实际值(未知，男性，女性)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/fc175a39aefe1fd2bd113624d7205cc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*U-465TflRqMs1hh4"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="ac7c" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">首先，我们以下面的形式<code class="fe mn mo mp mq b">{previous_value_1: new_value_1, previous_value_2:new_value_2..}</code>定义编码值和实际值之间的映射字典，然后我们将<code class="fe mn mo mp mq b">.map()</code>应用到<code class="fe mn mo mp mq b">gender</code>列。<code class="fe mn mo mp mq b">.map()</code>在映射字典中查找对应于编码性别的关键字，并用字典值替换它。</p><pre class="kj kk kl km gt mx mq my mz aw na bi"><span id="535d" class="nb la it mq b gy nc nd l ne nf">gender_map = {0: 'Unknown', 1:'Male', 2:'Female'}<br/>df['gender'] = df['gender'].map(gender_map)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/547642eb53b90b1cf8777d00f4fde9fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/0*zFfhmAfjlOah6lXo"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="ba77" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">如果在映射字典中没有找到键值对，输出将是<code class="fe mn mo mp mq b">Nan</code>。<code class="fe mn mo mp mq b">{0: 'Unknown'}</code>的映射被删除，这是输出的样子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/8585ac264a5e7d025600bd4edcdb0790.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1IGo7yH7xaM7eNFS"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><pre class="kj kk kl km gt mx mq my mz aw na bi"><span id="88d2" class="nb la it mq b gy nc nd l ne nf">gender_map = {1:'Male', 2:'Female'}<br/>df['gender'] = df['gender'].map(gender_map)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/efdd23c75b066395f927c400531a5a00.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/0*hdli9AXgYXln3_IZ"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="9d0a" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><strong class="lt iu">系列</strong></p><p id="6e98" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">我们不使用映射字典，而是使用映射序列。<code class="fe mn mo mp mq b">.map()</code> looks在序列中查找对应于编码性别的相应索引，并用序列中的值替换它。</p><p id="d625" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">映射系列的<code class="fe mn mo mp mq b">index</code>包含编码的性别，而<code class="fe mn mo mp mq b">gender</code>列包含性别的实际值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/84e1f58229c48adfc8568f28eab92f6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R06jpzSggJgY35UY"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><pre class="kj kk kl km gt mx mq my mz aw na bi"><span id="b8fe" class="nb la it mq b gy nc nd l ne nf">gender_map = {0: 'Unknown', 1:'Male', 2:'Female'}<br/>s = pd.Series(gender_map) # mapping series<br/>df['gender'] = df['gender'].map(s)</span></pre><p id="7298" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">如果在系列中找不到映射，输出将是<code class="fe mn mo mp mq b">NaN</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/c532829d4634447edb7927434a11c397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uuEx7oO_8JDpynAa"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><pre class="kj kk kl km gt mx mq my mz aw na bi"><span id="160e" class="nb la it mq b gy nc nd l ne nf">gender_map = {1:'Male', 2:'Female'}<br/>s = pd.Series(gender_map) # mapping series<br/>df['gender'] = df['gender'].map(s)</span></pre><p id="1f63" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><strong class="lt iu">功能</strong></p><p id="5d18" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">我们也可以使用一个函数(或lambda)作为<code class="fe mn mo mp mq b">.map()</code>中的<code class="fe mn mo mp mq b">arg</code>参数。让我们尝试使用lambda函数给每个人分配一个<code class="fe mn mo mp mq b">age_group</code>类别(成人或儿童)。</p><pre class="kj kk kl km gt mx mq my mz aw na bi"><span id="ff84" class="nb la it mq b gy nc nd l ne nf">df['age_group'] = df['age'].map(lambda x: 'Adult' if x &gt;= 21 else 'Child')</span></pre><p id="5599" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">或者，我们可以做以下事情。</p><pre class="kj kk kl km gt mx mq my mz aw na bi"><span id="c4ed" class="nb la it mq b gy nc nd l ne nf">def get_age_group(age):</span><span id="a628" class="nb la it mq b gy ng nd l ne nf">    threshold = 21</span><span id="5583" class="nb la it mq b gy ng nd l ne nf">    if age &gt;= threshold:<br/>        age_group = 'Adult'<br/>    else:<br/>        age_group = 'Child'</span><span id="366f" class="nb la it mq b gy ng nd l ne nf">    return age_group</span><span id="1037" class="nb la it mq b gy ng nd l ne nf">df['age_group'] = df['age'].map(get_age_group)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/761f6b50af59ec9aacef9c1cf44e04ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/0*qKzWjnnGUQMhkZJN"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="3345" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">注意，年龄阈值在<code class="fe mn mo mp mq b">get_age_group</code>函数中是硬编码的，因为<code class="fe mn mo mp mq b">.map()</code>不允许向函数传递参数。</p><h1 id="86a9" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">什么是熊猫<code class="fe mn mo mp mq b">apply()</code>？</h1><p id="9630" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe mn mo mp mq b">.apply()</code>适用于熊猫数据框和系列。当应用于数据帧时，<code class="fe mn mo mp mq b">.apply()</code>可以按行或列操作。</p><h2 id="abc8" class="nb la it bd lb ol om dn lf on oo dp lj ma op oq ll me or os ln mi ot ou lp ov bi translated"><code class="fe mn mo mp mq b">Series.apply()</code></h2><blockquote class="nw nx ny"><p id="aee9" class="lr ls nz lt b lu ms ju lw lx mt jx lz oa mu mc md ob mv mg mh oc mw mk ml mm im bi translated"><em class="it">对系列的值调用函数。可以是ufunc(适用于整个系列的NumPy函数)或只对单个值起作用的Python函数。</em></p></blockquote><p id="6618" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><strong class="lt iu">参数</strong></p><ul class=""><li id="2491" class="ni nj it lt b lu ms lx mt ma nk me nl mi nm mm nn no np nq bi translated"><code class="fe mn mo mp mq b">func</code>:功能</li><li id="bd55" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated"><code class="fe mn mo mp mq b">convert_dtype</code>:布尔值，默认为真。尝试为elementwise函数结果找到更好的数据类型。如果为False，则保留为dtype=object。注意，对于某些扩展数组dtype，比如Categorical，总是保留dtype。</li><li id="55b9" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated"><code class="fe mn mo mp mq b">args</code>:元组。序列值后传递给<code class="fe mn mo mp mq b">func</code>的位置参数。</li><li id="6e41" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated"><code class="fe mn mo mp mq b">**kwargs</code>:传递给<code class="fe mn mo mp mq b">func</code>的附加关键字参数。</li></ul><p id="d330" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><strong class="lt iu">返回</strong></p><ul class=""><li id="b808" class="ni nj it lt b lu ms lx mt ma nk me nl mi nm mm nn no np nq bi translated"><code class="fe mn mo mp mq b">Series</code>或<code class="fe mn mo mp mq b">DataFrame</code></li><li id="6b73" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">如果<code class="fe mn mo mp mq b">func</code>返回一个系列对象，结果将是一个数据帧。</li></ul><p id="139b" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><strong class="lt iu">要点</strong></p><ul class=""><li id="cd62" class="ni nj it lt b lu ms lx mt ma nk me nl mi nm mm nn no np nq bi translated">适用于熊猫系列</li><li id="2113" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">接受一个函数</li><li id="9952" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">能够将位置或关键字参数传递给函数</li><li id="67ff" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">可以返回序列或数据帧</li></ul><p id="de24" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">从前面的例子中，我们看到<code class="fe mn mo mp mq b">.map()</code>不允许参数被传递到函数中。另一方面,<code class="fe mn mo mp mq b">.apply()</code>允许传递位置或关键字参数..让我们参数化这个函数来接受一个<code class="fe mn mo mp mq b">thershold</code>参数。</p><pre class="kj kk kl km gt mx mq my mz aw na bi"><span id="8322" class="nb la it mq b gy nc nd l ne nf">def get_age_group(age, threshold):</span><span id="c74a" class="nb la it mq b gy ng nd l ne nf">    if age &gt;= int(threshold):<br/>        age_group = 'Adult'<br/>    else:<br/>        age_group = 'Child'</span><span id="0282" class="nb la it mq b gy ng nd l ne nf">    return age_group</span></pre><p id="83fe" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">将<code class="fe mn mo mp mq b">threshold</code>作为关键字参数传递</p><pre class="kj kk kl km gt mx mq my mz aw na bi"><span id="9037" class="nb la it mq b gy nc nd l ne nf"># keyword argument<br/>df['age_group'] = df['age'].apply(get_age_group, threshold = 21)</span></pre><p id="32f4" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">传<code class="fe mn mo mp mq b">threhsold</code>作为立场论点</p><pre class="kj kk kl km gt mx mq my mz aw na bi"><span id="8b87" class="nb la it mq b gy nc nd l ne nf"># positional argument<br/>df['age_group'] = df['age'].apply(get_age_group, args = (21,))</span></pre><p id="4910" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><strong class="lt iu">多重论证</strong></p><p id="870f" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><code class="fe mn mo mp mq b">.apply()</code>也可以接受多个位置或关键字参数。让我们根据年龄下限和上限将<code class="fe mn mo mp mq b">age</code>分成3个<code class="fe mn mo mp mq b">age_group</code>(儿童、成人和老年人)。</p><pre class="kj kk kl km gt mx mq my mz aw na bi"><span id="7c23" class="nb la it mq b gy nc nd l ne nf">def get_age_group(age, lower_threshold, upper_threshold):</span><span id="d0ae" class="nb la it mq b gy ng nd l ne nf">    if age &gt;= int(upper_threshold):<br/>        age_group = 'Senior'<br/>    elif age &lt;= int(lower_threshold):<br/>        age_group = 'Child'<br/>    else:<br/>        age_group = 'Adult'</span><span id="2106" class="nb la it mq b gy ng nd l ne nf">    return age_group</span></pre><p id="3016" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">将<code class="fe mn mo mp mq b">lower_threshold</code>和<code class="fe mn mo mp mq b">upper_threshold</code>作为关键字参数传递</p><pre class="kj kk kl km gt mx mq my mz aw na bi"><span id="d53d" class="nb la it mq b gy nc nd l ne nf">df['age_group'] = df['age'].apply(get_age_group, lower_threshold = 20, upper_threshold = 65)</span></pre><p id="8386" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">将<code class="fe mn mo mp mq b">lower_threshold</code>和<code class="fe mn mo mp mq b">upper_threshold</code>作为位置参数传递</p><pre class="kj kk kl km gt mx mq my mz aw na bi"><span id="c1fb" class="nb la it mq b gy nc nd l ne nf">df['age_group'] = df['age'].apply(get_age_group, args = (20,65))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/ab8883becbdbd356aaae9251ac6b5c92.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/0*k4BfV0DQYTXJx6gc"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="668e" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><strong class="lt iu">应用数字功能</strong></p><p id="5331" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">除了应用python函数(或Lamdba)，<code class="fe mn mo mp mq b">.apply()</code>还允许numpy函数。例如，我们可以应用numpy <code class="fe mn mo mp mq b">.ceil()</code>将每个人的<code class="fe mn mo mp mq b">height</code>四舍五入到最接近的整数。</p><pre class="kj kk kl km gt mx mq my mz aw na bi"><span id="9974" class="nb la it mq b gy nc nd l ne nf">df['height'] = df['height'].apply(np.ceil)</span></pre><p id="a089" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><strong class="lt iu">返回一个系列</strong></p><p id="4091" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><code class="fe mn mo mp mq b">.apply()</code>如果函数返回单个值，则返回一个序列。让我们写一个函数来查找一个人的姓。</p><pre class="kj kk kl km gt mx mq my mz aw na bi"><span id="b017" class="nb la it mq b gy nc nd l ne nf">def get_last_name(x):</span><span id="68b9" class="nb la it mq b gy ng nd l ne nf">    return x.split(' ')[-1]</span><span id="c020" class="nb la it mq b gy ng nd l ne nf">type(df['name'].apply(get_last_name))</span><span id="1613" class="nb la it mq b gy ng nd l ne nf">&gt;&gt; pandas.core.series.Series</span></pre><p id="8764" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><strong class="lt iu">返回一个数据帧</strong></p><p id="ec8c" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><code class="fe mn mo mp mq b">.apply()</code>当函数返回一个序列时，返回一个数据帧。</p><pre class="kj kk kl km gt mx mq my mz aw na bi"><span id="3e0b" class="nb la it mq b gy nc nd l ne nf">def get_last_name(x):</span><span id="4840" class="nb la it mq b gy ng nd l ne nf">    return pd.Series(x.split(' ')[-1]) # function returns a Series</span><span id="bd8c" class="nb la it mq b gy ng nd l ne nf">type(df['name'].apply(get_last_name))</span><span id="378f" class="nb la it mq b gy ng nd l ne nf">&gt;&gt; pandas.core.frame.DataFrame</span></pre><h2 id="5cb6" class="nb la it bd lb ol om dn lf on oo dp lj ma op oq ll me or os ln mi ot ou lp ov bi translated"><code class="fe mn mo mp mq b">DataFrame.apply()</code></h2><blockquote class="nw nx ny"><p id="44a7" class="lr ls nz lt b lu ms ju lw lx mt jx lz oa mu mc md ob mv mg mh oc mw mk ml mm im bi translated"><em class="it">沿数据帧的轴应用一个函数。</em></p></blockquote><p id="9e2d" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><strong class="lt iu">参数</strong></p><ul class=""><li id="921f" class="ni nj it lt b lu ms lx mt ma nk me nl mi nm mm nn no np nq bi translated"><code class="fe mn mo mp mq b">func</code>:应用于各列或各行的函数</li><li id="a9bf" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated"><code class="fe mn mo mp mq b">axis</code>:沿其应用函数的轴。<code class="fe mn mo mp mq b">axis=0</code> -对每列应用函数。<code class="fe mn mo mp mq b">axis=1</code> -将函数应用于每一行。</li><li id="48fd" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated"><code class="fe mn mo mp mq b">raw</code>:确定行或列是作为序列还是ndarray对象传递:False——将每行或每列作为序列传递给函数。True -将ndarray对象传递给函数。</li><li id="682d" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated"><code class="fe mn mo mp mq b">result_type</code> :这些只有在<code class="fe mn mo mp mq b">axis=1</code>(列):<br/>--【展开】:列表式的结果会变成列。<br/>--“减少”:尽可能返回一个序列，而不是展开列表式结果。这是“扩展”的反义词。<br/>--“广播”:结果将被广播到数据帧的原始形状，原始索引和列将被保留。</li><li id="6e1c" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated"><code class="fe mn mo mp mq b">args</code>:元组。在序列值之后传递给func的位置参数。</li><li id="4bd6" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated"><code class="fe mn mo mp mq b">**kwargs</code>:传递给func的附加关键字参数。</li></ul><p id="1c9a" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><strong class="lt iu">回报</strong></p><ul class=""><li id="0345" class="ni nj it lt b lu ms lx mt ma nk me nl mi nm mm nn no np nq bi translated"><code class="fe mn mo mp mq b">Series</code>或<code class="fe mn mo mp mq b">DataFrame</code></li></ul><p id="8c63" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><strong class="lt iu">要点</strong></p><ul class=""><li id="984c" class="ni nj it lt b lu ms lx mt ma nk me nl mi nm mm nn no np nq bi translated">函数可以按列(<code class="fe mn mo mp mq b">axis = 0</code>)或行(<code class="fe mn mo mp mq b">axis = 1</code>)应用</li><li id="e534" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">能够将数据作为序列或数字数组传递给函数</li><li id="6486" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">能够将位置或关键字参数传递给函数</li></ul><p id="fd21" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><strong class="lt iu">按列应用numpy函数</strong></p><p id="8c6e" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">将身高和体重四舍五入到最接近的整数。函数按照<code class="fe mn mo mp mq b">axis = 0</code>的定义按列应用。当按列使用时，<code class="fe mn mo mp mq b">pd.DataFrame.apply()</code>可以一次应用于多个列。</p><pre class="kj kk kl km gt mx mq my mz aw na bi"><span id="27fc" class="nb la it mq b gy nc nd l ne nf">df[['height', 'weight']].apply(np.round, axis = 0)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/eea5d884cd5a8f9f77b2ac04df423bb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:372/format:webp/1*-UYKRdopfNq63cv3OUhWFw.png"/></div></figure><p id="e5d8" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><strong class="lt iu">逐行应用Lambda函数</strong></p><p id="c263" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">通过应用由<code class="fe mn mo mp mq b">axis = 1</code>定义的<code class="fe mn mo mp mq b">split</code>函数按行将姓名分为名和姓。</p><pre class="kj kk kl km gt mx mq my mz aw na bi"><span id="16b3" class="nb la it mq b gy nc nd l ne nf">df.apply(lambda x: x['name'].split(' '), axis = 1)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/e971d7c3443c6a5317516114029f0b3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:372/format:webp/1*LkOvTIF5F_fmEkGVzIn6ng.png"/></div></figure><p id="d44f" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">通过将<code class="fe mn mo mp mq b">result_type</code>参数定义为<code class="fe mn mo mp mq b">expand</code>，我们可以将列表分解为多列，每列一个元素。</p><pre class="kj kk kl km gt mx mq my mz aw na bi"><span id="85ae" class="nb la it mq b gy nc nd l ne nf">df.apply(lambda x: x['name'].split(' '), axis = 1, result_type = 'expand')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/de74cac76a878755be4b5c32292cf7e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:330/format:webp/1*UQ6ihtcThd-K37knxAqkDg.png"/></div></figure><p id="68c8" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><strong class="lt iu">按行应用函数</strong></p><p id="b1f2" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">让我们找出每个人的体重指数(身体质量指数)。身体质量指数被定义为以千克为单位的重量除以以米为单位的高度的平方。我们创建一个用于计算身体质量指数的UDF，并以逐行方式将UDF应用于数据帧。按行使用时，<code class="fe mn mo mp mq b">pd.DataFrame.apply()</code>可以通过根据列名选择列来利用不同列中的值。</p><pre class="kj kk kl km gt mx mq my mz aw na bi"><span id="c5d4" class="nb la it mq b gy nc nd l ne nf">def calculate_bmi(x):<br/>    <br/>    bmi = x['weight'] / (x['height']/100)**2<br/><br/>    return bmi<br/><br/>df.apply(calculate_bmi, axis = 1)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/8e09561eddae9db23f0428aae41c9311.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/0*GvVhCsFYHlaTDi6d"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="249f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">什么是熊猫<code class="fe mn mo mp mq b">applymap()</code>？</h1><blockquote class="nw nx ny"><p id="618a" class="lr ls nz lt b lu ms ju lw lx mt jx lz oa mu mc md ob mv mg mh oc mw mk ml mm im bi translated"><em class="it">按元素将函数应用于数据帧。该方法将接受和返回标量的函数应用于DataFrame的每个元素。</em></p></blockquote><p id="4e9c" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><strong class="lt iu">参数</strong></p><ul class=""><li id="e528" class="ni nj it lt b lu ms lx mt ma nk me nl mi nm mm nn no np nq bi translated"><code class="fe mn mo mp mq b">func</code> : Python函数，从单个值返回单个值。</li><li id="83f4" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated"><code class="fe mn mo mp mq b">na_action</code> : { '无'，'忽略' }。默认无。如果“ignore ”,则传播NaN值，而不将它们传递给映射对应。</li><li id="301f" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated"><code class="fe mn mo mp mq b">**kwargs</code>:传递给<code class="fe mn mo mp mq b">func</code>的附加关键字参数。</li></ul><p id="0a2e" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><strong class="lt iu">返回</strong></p><ul class=""><li id="67c1" class="ni nj it lt b lu ms lx mt ma nk me nl mi nm mm nn no np nq bi translated"><code class="fe mn mo mp mq b">DataFrame</code></li></ul><p id="14fd" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><strong class="lt iu">要点</strong></p><ul class=""><li id="3d74" class="ni nj it lt b lu ms lx mt ma nk me nl mi nm mm nn no np nq bi translated">适用于熊猫数据框</li><li id="f7f3" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">接受一个函数</li><li id="7efe" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">能够将关键字参数传递给函数</li><li id="c967" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">元素式操作</li></ul><p id="5523" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">在下面的例子中，我们对两列数值进行了简单的运算。</p><pre class="kj kk kl km gt mx mq my mz aw na bi"><span id="800b" class="nb la it mq b gy nc nd l ne nf">def some_math(x, multiplier, add):</span><span id="a195" class="nb la it mq b gy ng nd l ne nf">    return x * multiplier + add</span><span id="e0ea" class="nb la it mq b gy ng nd l ne nf">df = pd.DataFrame({'A':[1,2,3], 'B':[10,20,30]})<br/>df.applymap(some_math, multiplier = 2, add = 1)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/f6354c897712897dd7fbb219576d9e6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/0*SPO8tPG-sikOVz9n"/></div></figure><p id="e17c" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><code class="fe mn mo mp mq b">.applymap()</code>获取原始数据帧中的每个值，将其作为<code class="fe mn mo mp mq b">x</code>传递给<code class="fe mn mo mp mq b">some_math</code>函数，执行运算并返回单个值。<code class="fe mn mo mp mq b">.applymap()</code>也接受关键字参数，但不接受位置参数。</p><h1 id="99f3" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">熊猫<code class="fe mn mo mp mq b">.pipe()</code>是什么？</h1><blockquote class="nw nx ny"><p id="32d8" class="lr ls nz lt b lu ms ju lw lx mt jx lz oa mu mc md ob mv mg mh oc mw mk ml mm im bi translated"><em class="it">应用期望序列或数据帧的可链接函数。</em></p></blockquote><p id="1326" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><strong class="lt iu">参数</strong></p><ul class=""><li id="ec5c" class="ni nj it lt b lu ms lx mt ma nk me nl mi nm mm nn no np nq bi translated"><code class="fe mn mo mp mq b">func</code>:应用于系列/数据帧的功能</li><li id="a8b1" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated"><code class="fe mn mo mp mq b">args</code>:传递给<code class="fe mn mo mp mq b">func</code>的位置参数</li><li id="10f4" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated"><code class="fe mn mo mp mq b">kwargs</code>:传递给<code class="fe mn mo mp mq b">func</code>的关键字参数</li></ul><p id="c9e0" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><strong class="lt iu">退货</strong></p><ul class=""><li id="eb44" class="ni nj it lt b lu ms lx mt ma nk me nl mi nm mm nn no np nq bi translated"><code class="fe mn mo mp mq b">object</code>:返回类型<code class="fe mn mo mp mq b">func</code></li></ul><p id="f975" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><strong class="lt iu">要点</strong></p><ul class=""><li id="c8da" class="ni nj it lt b lu ms lx mt ma nk me nl mi nm mm nn no np nq bi translated">适用于熊猫系列和数据框</li><li id="34e8" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">接受一个函数</li><li id="842e" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">能够传递参数作为位置或关键字参数</li><li id="099f" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">返回与<code class="fe mn mo mp mq b">func</code>相同的对象</li></ul><p id="f17a" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><strong class="lt iu"/><code class="fe mn mo mp mq b"><strong class="lt iu">pipe</strong></code><strong class="lt iu">如何工作？</strong></p><p id="f70d" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><code class="fe mn mo mp mq b">.pipe()</code>通常用于将多个功能链接在一起。例如，我们有3个对数据帧进行操作的函数，<code class="fe mn mo mp mq b">f1</code>、<code class="fe mn mo mp mq b">f2</code>和<code class="fe mn mo mp mq b">f3</code>，每个函数都需要一个数据帧作为输入，并返回一个转换后的数据帧。</p><pre class="kj kk kl km gt mx mq my mz aw na bi"><span id="91ee" class="nb la it mq b gy nc nd l ne nf">def f1(df, arg1):<br/>	# do something</span><span id="e504" class="nb la it mq b gy ng nd l ne nf">	return # a dataframe</span><span id="df8c" class="nb la it mq b gy ng nd l ne nf">def f2(df, arg2):<br/>	# do something</span><span id="d282" class="nb la it mq b gy ng nd l ne nf">	return # a dataframe</span><span id="60f6" class="nb la it mq b gy ng nd l ne nf">def f3(df, arg3):<br/>	# do something</span><span id="cb54" class="nb la it mq b gy ng nd l ne nf">	return # a dataframe</span><span id="f745" class="nb la it mq b gy ng nd l ne nf">df = pd.DataFrame(..) # some dataframe</span></pre><p id="b888" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">如果不使用<code class="fe mn mo mp mq b">.pipe()</code>，我们会以嵌套的方式应用函数，如果有多个函数的话，这可能看起来很难理解。为了遵循函数执行的顺序，必须从“由内向外”阅读。首先执行最内部的功能<code class="fe mn mo mp mq b">f3</code>，然后执行<code class="fe mn mo mp mq b">f2</code>，最后执行<code class="fe mn mo mp mq b">f1</code>。</p><pre class="kj kk kl km gt mx mq my mz aw na bi"><span id="ef56" class="nb la it mq b gy nc nd l ne nf">f1(f2(f3(df, arg3 = arg3), arg2 = arg2), arg1 = arg1)</span></pre><p id="db1f" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><code class="fe mn mo mp mq b">.pipe()</code>避免嵌套，允许使用点符号(<code class="fe mn mo mp mq b">.</code>)链接函数，使其更具可读性。<code class="fe mn mo mp mq b">.pipe()</code>还允许传递位置参数和关键字参数，并假设函数的第一个参数引用输入数据帧/序列。</p><pre class="kj kk kl km gt mx mq my mz aw na bi"><span id="0a50" class="nb la it mq b gy nc nd l ne nf">df.pipe(f3, arg3 = arg3).pipe(f2, arg2 = arg2).pipe(f1, arg1 = arg1)</span></pre><p id="0be4" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">跟随与<code class="fe mn mo mp mq b">.pipe()</code>链接在一起的功能的执行顺序更直观；我们只是从左向右读。</p><p id="7957" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated"><code class="fe mn mo mp mq b">apply</code>、<code class="fe mn mo mp mq b">map</code>和<code class="fe mn mo mp mq b">applymap</code>被约束为返回Series、DataFrame或两者。然而<code class="fe mn mo mp mq b">pipe</code>可以返回任何对象，不一定是Series或DataFrame。让我们看一些使用相同样本数据集的例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/32953668414268335e716918ac079b9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/0*Ay07bsW0VDgL34rz"/></div></figure><p id="9d17" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">下面的函数返回一个浮点值。</p><pre class="kj kk kl km gt mx mq my mz aw na bi"><span id="0e2b" class="nb la it mq b gy nc nd l ne nf">def find_average_weight(df):</span><span id="91da" class="nb la it mq b gy ng nd l ne nf">    return df['weight'].mean()</span><span id="0ebe" class="nb la it mq b gy ng nd l ne nf">df.pipe(find_average_weight)</span><span id="ddaf" class="nb la it mq b gy ng nd l ne nf">&gt;&gt; 66.0</span></pre><p id="4366" class="pw-post-body-paragraph lr ls it lt b lu ms ju lw lx mt jx lz ma mu mc md me mv mg mh mi mw mk ml mm im bi translated">下面的函数返回一个字符串。</p><pre class="kj kk kl km gt mx mq my mz aw na bi"><span id="5f5c" class="nb la it mq b gy nc nd l ne nf">def report_average_weight(df):</span><span id="0f15" class="nb la it mq b gy ng nd l ne nf">    avg_weight = df['weight'].mean()</span><span id="ecdb" class="nb la it mq b gy ng nd l ne nf">    return f'The average weight is {avg_weight}'</span><span id="3311" class="nb la it mq b gy ng nd l ne nf">df.pipe(report_average_weight)</span><span id="f977" class="nb la it mq b gy ng nd l ne nf">&gt;&gt; 'The average weight is 66.0'</span></pre><h1 id="f714" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">摘要</h1><p id="3ef5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本文中，我们研究了<code class="fe mn mo mp mq b">map</code>、<code class="fe mn mo mp mq b">apply</code>和<code class="fe mn mo mp mq b">applymap</code>、<code class="fe mn mo mp mq b">pipe</code>之间的区别，以及如何使用这些方法来转换我们的数据。虽然我们没有详细讨论<code class="fe mn mo mp mq b">map</code>、<code class="fe mn mo mp mq b">apply</code>和<code class="fe mn mo mp mq b">applymap</code>的执行速度，但请注意，这些方法是伪装的循环，只有在没有等效的矢量化运算时才应使用。一般来说，矢量化操作比循环更快，并且随着数据集大小的增加，执行时间的差异变得更加显著。</p></div><div class="ab cl pb pc hx pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="im in io ip iq"><ul class=""><li id="461d" class="ni nj it lt b lu ms lx mt ma nk me nl mi nm mm nn no np nq bi translated"><a class="ae ky" href="https://medium.com/@edwin.tan/membership" rel="noopener">加入Medium </a>阅读更多这样的故事</li><li id="486b" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated"><a class="ae ky" href="https://medium.com/@edwin.tan" rel="noopener">关注我</a>获取更多类似的帖子</li></ul></div></div>    
</body>
</html>