<html>
<head>
<title>Should You Define Named Python Functions Using lambda?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应该用 lambda 定义命名的 Python 函数吗？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/should-you-define-named-python-functions-using-lambda-fb5806c0898b#2022-11-30">https://towardsdatascience.com/should-you-define-named-python-functions-using-lambda-fb5806c0898b#2022-11-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="36e6" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">PYTHON 编程</h2><div class=""/><div class=""><h2 id="5a91" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">这样做是违背 PEP8 的，那么为什么这么多作者这么建议呢？</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/69c57d003bb888001af20ed7f1ecc42d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*faUYsitHy4QLXyoi"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">在 Python 中，lambda 关键字允许定义匿名函数。由<a class="ae lh" href="https://unsplash.com/@saadahmad_umn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Saad Ahmad </a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="61c0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">许多作者声称，为了缩短你的代码，你可以使用<code class="fe me mf mg mh b"><a class="ae lh" rel="noopener" target="_blank" href="/lambda-functions-with-practical-examples-in-python-45934f3653a8">lambda</a></code> <a class="ae lh" rel="noopener" target="_blank" href="/lambda-functions-with-practical-examples-in-python-45934f3653a8">函数</a>来定义函数并给它们分配一个名字。一些初学者可能想尝试这种方法；说实话，我不仅在某个时候尝试过，而且乐此不疲。</p><p id="f7b1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请注意，这与使用未命名的<code class="fe me mf mg mh b">lambda</code>函数作为高阶函数的参数的情况不同，如下所示:</p><pre class="ks kt ku kv gt mi mh mj bn mk ml bi"><span id="ffeb" class="mm mn it mh b be mo mp l mq mr">&gt;&gt;&gt; x = [<br/>...     ("Johny Faint", 197),<br/>...     ("Jon Krohn", 187),<br/>...     ("Anna Vanna", 178),<br/>...     ("Michael Ginger", 165),<br/>...     ("Viola Farola", 189)<br/>... ]<br/>&gt;&gt;&gt; sorted(x, key=lambda x: -x[1])<br/>[('Johny Faint', 197), ('Viola Farola', 189), ('Jon Krohn', 187), ('Anna Vanna', 178), ('Michael Ginger', 165)]</span></pre><p id="fdd8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将讨论给一个名字分配一个<code class="fe me mf mg mh b">lambda</code>功能，如下所示:</p><pre class="ks kt ku kv gt mi mh mj bn mk ml bi"><span id="9145" class="mm mn it mh b be mo mp l mq mr">&gt;&gt;&gt; sort_fun = lambda x: -x[1]</span></pre><p id="309a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不同之处在于赋值，用<code class="fe me mf mg mh b">=</code>表示，这意味着我们定义函数<code class="fe me mf mg mh b">sort_fun(x)</code>，它在形式上是一个有一个参数<code class="fe me mf mg mh b">x</code>的函数。该函数假设<code class="fe me mf mg mh b">x</code>是一个至少包含两个元素的 iterable。当然，我们知道这个函数是为与上面使用的函数相同的排序而构建的，如下所示:</p><pre class="ks kt ku kv gt mi mh mj bn mk ml bi"><span id="07f6" class="mm mn it mh b be mo mp l mq mr">&gt;&gt;&gt; sorted(x, key=sort_fun)<br/>[('Johny Faint', 197), ('Viola Farola', 189), ('Jon Krohn', 187), ('Anna Vanna', 178), ('Michael Ginger', 165)]</span></pre><p id="ecaf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这两种方法不同。当我们在高阶函数内部定义一个<code class="fe me mf mg mh b">lambda</code>函数时，它不能在其他地方使用；并且它严格地专用于这种特殊的用途。当我们定义一个<code class="fe me mf mg mh b">lambda</code>函数并给它指定一个名字(<code class="fe me mf mg mh b">sort_fun</code>)时，它可以在代码的其他地方使用。同样，在 Python 中，函数就是函数，不管它们是如何定义的，是使用<code class="fe me mf mg mh b">def</code>还是<code class="fe me mf mg mh b">lambda</code>；因此，<code class="fe me mf mg mh b">sort_fun()</code>是一个有效的 Python 函数。</p><p id="594e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">本文讨论命名的<code class="fe me mf mg mh b">lambda</code>函数；也就是说，<code class="fe me mf mg mh b">lambda</code>被定义的功能<em class="ms">和</em>被赋予一个名称。我们将讨论您是否应该这样定义函数，或者更确切地说，您应该避免这样做。我们将会看到 PEP8 对此会说些什么，但是我们也会对<code class="fe me mf mg mh b">def</code>定义的函数和<code class="fe me mf mg mh b">lambda</code>定义的函数进行比较。这将帮助我们决定<code class="fe me mf mg mh b">lambda</code>是否确实提供了一种在 Python 中定义简单函数的替代方式。</p><h1 id="1af8" class="mt mn it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated">PEP8 对此怎么说？</h1><p id="61bd" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">尽管已经 20 多年了，我们仍然使用 PEP8 作为“Python 代码的风格指南”所以，如果你需要检查一些与编码风格相关的东西，PEP8 应该是你的第一来源。</p><p id="e86f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用分配的<code class="fe me mf mg mh b">lambda</code>函数的想法与 PEP8 的建议相违背，PEP8 使用精确的措辞来声明您不应该这样做:</p><blockquote class="np nq nr"><p id="b970" class="li lj ms lk b ll lm kd ln lo lp kg lq ns ls lt lu nt lw lx ly nu ma mb mc md im bi translated">总是使用 def 语句，而不是将 lambda 表达式直接绑定到标识符的赋值语句…</p></blockquote><p id="4e7e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">那么，这个<em class="ms">真的</em>意味着使用一个命名的<code class="fe me mf mg mh b">lambda</code>函数确实是违背 PEP8 的吗？我认为有两种可能性:</p><ol class=""><li id="6358" class="nv nw it lk b ll lm lo lp lr nx lv ny lz nz md oa ob oc od bi translated">不，不是的！这个基于<code class="fe me mf mg mh b">lambda</code>的 PEP8 推荐已经过时了。例如，许多开发人员不同意 PEP8 推荐的 79 个字符的最大行长度，认为这是旧的气息。同样,<code class="fe me mf mg mh b">lambda</code>建议已经过时，我们不应该担心与 PEP8 背道而驰。PEP8 不是在 20 多年前，早在 2001 年就被创造出来了吗？在像 Python 编程语言这样现代的东西中，我们真的应该遵循如此古老的风格指南吗？</li><li id="eb14" class="nv nw it lk b ll oe lo of lr og lv oh lz oi md oa ob oc od bi translated">是的，确实如此！建议打破这种基于<code class="fe me mf mg mh b">lambda</code>的推荐的作者，只依赖一个前提:字符数。这就意味着，越短越好。世界没有那么简单，编程也没有什么不同:仅仅是<code class="fe me mf mg mh b">lambda</code>函数的简洁还不够。听 PEP8，不要用命名的<code class="fe me mf mg mh b">lambda</code>函数！</li></ol><p id="d3fa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">老实说，前一段时间我自己也偶尔使用这样命名的<code class="fe me mf mg mh b">lambda</code>定义。我只是喜欢它们的样子:简洁和与众不同。现在，我认为正是这种差异吸引了我。我知道我倾向于<em class="ms">喜欢</em>复杂的解决方案，那些看起来与众不同、非典型的解决方案，因为它们让我觉得我是一个优秀的程序员。但是这太误导人了！写复杂的代码并不意味着成为一名优秀的程序员。现在我知道了这一点，我试着小心并仔细检查我是否做了不必要的复杂。</p><p id="8eb3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，让我们客观地分析一下，基于命名的<code class="fe me mf mg mh b">lambda</code>的函数定义是否比基于<code class="fe me mf mg mh b">def</code>的函数定义更好——如果是的话，什么时候更好。</p><p id="90af" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请注意，我们<em class="ms">不</em>讨论使用<code class="fe me mf mg mh b">lambda</code>的一般情况，而只是命名的<code class="fe me mf mg mh b">lambda</code>定义，它将<code class="fe me mf mg mh b">lambda</code>功能分配给一个名称，如下所示:</p><pre class="ks kt ku kv gt mi mh mj bn mk ml bi"><span id="6c6f" class="mm mn it mh b be mo mp l mq mr">foo = lambda x, u: f"{x} and {u}"</span></pre><p id="d068" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">无论我们想出什么，都与在高阶函数中使用 lambdas 无关。</p><h1 id="c579" class="mt mn it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated">使用 lambda 和<code class="fe me mf mg mh b">def</code>定义函数</h1><p id="0540" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">让我们来做一个实际的比较。为此，我将使用四个函数:</p><ul class=""><li id="b999" class="nv nw it lk b ll lm lo lp lr nx lv ny lz nz md oj ob oc od bi translated">没有参数的函数</li><li id="5877" class="nv nw it lk b ll oe lo of lr og lv oh lz oi md oj ob oc od bi translated">只有一个参数的函数</li><li id="2c27" class="nv nw it lk b ll oe lo of lr og lv oh lz oi md oj ob oc od bi translated">有两个参数的函数</li><li id="70ee" class="nv nw it lk b ll oe lo of lr og lv oh lz oi md oj ob oc od bi translated">有三个参数的函数</li></ul><p id="64f1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于最后一个，我们将使用其中一个参数的默认值。以下是以传统方式定义的函数:</p><pre class="ks kt ku kv gt mi mh mj bn mk ml bi"><span id="737c" class="mm mn it mh b be mo mp l mq mr">def weather():<br/>    return "beautiful weather"<br/><br/>def square(x):<br/>    return x**2<br/><br/>def multiply(x, m):<br/>    """Multiply x by m.<br/><br/>    &gt;&gt;&gt; multiply(10, 5)<br/>    50<br/>    &gt;&gt;&gt; multiply("a", 3)<br/>    'aaa'<br/>    """<br/>    return x * m<br/><br/>def join_sep(iter1, iter2, sep="-"):<br/>    return [f"{v1}{sep}{v2}" for v1, v2 in zip(iter1, iter2)]</span></pre><p id="6ad1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们看看这些函数在使用<code class="fe me mf mg mh b">lambda</code> s 定义时是什么样子的:</p><pre class="ks kt ku kv gt mi mh mj bn mk ml bi"><span id="8145" class="mm mn it mh b be mo mp l mq mr">weather = lambda: "beautiful weather"<br/><br/>square = lambda x: x**2<br/><br/>multiply = lambda x, m: x * m<br/><br/>join_sep =lambda iter1, iter2, sep="-": [f"{v1}{sep}{v2}" for v1, v2 in zip(iter1, iter2)]</span></pre><p id="9445" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将从几个方面比较这两种方法。</p><h2 id="a944" class="ok mn it bd mu ol om dn my on oo dp nc lr op oq ne lv or os ng lz ot ou ni iz bi translated">代码简洁和视觉混乱</h2><p id="fd1c" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">代码看起来更加密集。是好事吗？注意，分配的<code class="fe me mf mg mh b">lambda</code>函数并没有短多少:它们用<code class="fe me mf mg mh b">= lambda</code>替换了以下字符:<code class="fe me mf mg mh b">def</code>、<code class="fe me mf mg mh b">():</code>和<code class="fe me mf mg mh b">return</code>。因此，他们使用<code class="fe me mf mg mh b">7</code>而不是<code class="fe me mf mg mh b">12</code>字符，所以只有<code class="fe me mf mg mh b">5</code>字符更少(忽略空白)。那不是很多。</p><p id="9e74" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我认为<code class="fe me mf mg mh b">lambda</code>定义更密集的感觉来自于在一行中呈现它们。然而，我们可以使用<code class="fe me mf mg mh b">def</code>做同样的事情:</p><pre class="ks kt ku kv gt mi mh mj bn mk ml bi"><span id="4916" class="mm mn it mh b be mo mp l mq mr">def square(x): return x**2</span></pre><p id="8d49" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个定义和<code class="fe me mf mg mh b">lambda</code>的定义在长度上没有太大区别，是吗？然而，使用<code class="fe me mf mg mh b">def</code>定义这样的短函数，我们在第一行之后使用新的一行是有原因的——对我来说，不是更多的字符；相反，它有助于避免视觉混乱。</p><p id="1213" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，就代码简洁而言，我真的看不出选择<code class="fe me mf mg mh b">lambda</code>定义而不是<code class="fe me mf mg mh b">def</code>定义有什么意义。</p><p id="a0c9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">就视觉杂乱而言，<code class="fe me mf mg mh b">lambda</code>的定义在我看来更糟糕，意思是更杂乱。再次比较使用<code class="fe me mf mg mh b">lambda</code>定义的<code class="fe me mf mg mh b">multiply()</code>函数:</p><pre class="ks kt ku kv gt mi mh mj bn mk ml bi"><span id="9224" class="mm mn it mh b be mo mp l mq mr">multiply = lambda x, m: x * m</span></pre><p id="cb44" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">和<code class="fe me mf mg mh b">def</code>:</p><pre class="ks kt ku kv gt mi mh mj bn mk ml bi"><span id="2a2d" class="mm mn it mh b be mo mp l mq mr">def multiply(x, m):<br/>    return x * m</span></pre><p id="9062" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">后者中的额外空白有助于将功能直观地分为两个部分:</p><ol class=""><li id="3d93" class="nv nw it lk b ll lm lo lp lr nx lv ny lz nz md oa ob oc od bi translated">函数的签名:<code class="fe me mf mg mh b">def multiply(x, m):</code></li><li id="94ee" class="nv nw it lk b ll oe lo of lr og lv oh lz oi md oa ob oc od bi translated">函数体:<code class="fe me mf mg mh b">return x * m</code></li></ol><p id="870e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在<code class="fe me mf mg mh b">lambda</code>定义中，没有这样的视觉区分。相反，我们得到的是视觉混乱和密度，这需要额外的脑力劳动来区分函数的签名和主体。更糟糕的是，我们做的<em class="ms">不是</em>直接看到的签名！我们必须在头脑中创造它。</p><p id="b4f1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我不喜欢<code class="fe me mf mg mh b">lambda</code>定义的另一个视觉方面，这也让它们看起来很混乱。也就是说，函数名和它的参数不在一起，而是用“<code class="fe me mf mg mh b">= lambda </code>”隔开。</p><h2 id="59f7" class="ok mn it bd mu ol om dn my on oo dp nc lr op oq ne lv or os ng lz ot ou ni iz bi translated">清晰，无注释(类型提示)</h2><p id="4eca" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">因此，尽管有些作者说，<code class="fe me mf mg mh b">lambda</code>定义的简洁带来了视觉混乱和代码密度的增加。因此，对我来说，这种简洁是缺点而不是优点。</p><p id="5a1c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">也许<code class="fe me mf mg mh b">lambda</code>函数的代码更清晰？在下面的代码块中，后面的定义是否比前面的更清晰？</p><pre class="ks kt ku kv gt mi mh mj bn mk ml bi"><span id="a9c1" class="mm mn it mh b be mo mp l mq mr">def square(x):<br/>    return x**2<br/><br/>square = lambda x: x**2</span></pre><p id="3af5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然我在阅读和理解这个<code class="fe me mf mg mh b">lambda</code>函数方面没有问题，但我不会说它比使用<code class="fe me mf mg mh b">def</code>关键字定义的函数更清晰。说实话，由于我已经习惯了<code class="fe me mf mg mh b">def</code>函数定义，所以前者对我来说更加清晰。</p><p id="b47d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们上面关于视觉混乱和代码密度的讨论也适用于此。我喜欢两行的<code class="fe me mf mg mh b">def</code>定义，它立即显示了函数的签名和主体。相反，<code class="fe me mf mg mh b">lambda</code>定义要求我在一行中通读整个代码，以便看到函数的签名和主体。这降低了代码的可读性——即使对于这个简单的函数也是如此。</p><p id="cdbc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们看看它在一个有两个参数的函数中是什么样子的:</p><pre class="ks kt ku kv gt mi mh mj bn mk ml bi"><span id="ffba" class="mm mn it mh b be mo mp l mq mr">def multiply(x, m):<br/>    return x * m<br/><br/>multiply = lambda x, m: x * m</span></pre><p id="4529" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这一次，<code class="fe me mf mg mh b">def</code>版本对我来说似乎更加清晰。这也是由于在视觉上区分函数签名(包括函数参数)和函数体的一些问题。</p><p id="ef65" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这不是没有原因的，无论是谁提出了<code class="fe me mf mg mh b">lambda</code>定义，都是为了简短的函数。我们可以在<code class="fe me mf mg mh b">join_sep</code>函数的定义中看到这一点:</p><pre class="ks kt ku kv gt mi mh mj bn mk ml bi"><span id="8258" class="mm mn it mh b be mo mp l mq mr">def join_sep(iter1, iter2, sep="-"):<br/>    return [f"{v1}{sep}{v2}" for v1, v2 in zip(iter1, iter2)]<br/><br/>join_sep =lambda iter1, iter2, sep="-": [f"{v1}{sep}{v2}" for v1, v2 in zip(iter1, iter2)]</span></pre><p id="6e91" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有人选择用<code class="fe me mf mg mh b">lambda</code>关键字定义的<code class="fe me mf mg mh b">join_sep()</code>作为更好的吗？对我来说，只有前者可以被认为是可读的，而后者过于困难——尽管我确实理解这个<code class="fe me mf mg mh b">lambda</code>定义。在这种情况下，理解不等于欣赏。</p><p id="1324" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我提供这个例子只是为了强调一点，即使您决定使用<code class="fe me mf mg mh b">lambda</code>定义，您也应该为简单和简短的函数这样做；<code class="fe me mf mg mh b">join_sep()</code>是不是<em class="ms">不够</em>简单。</p><p id="cafa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，<code class="fe me mf mg mh b">def</code>定义使我们能够做更多的事情来增加它的清晰度:文档字符串。让我重复一下<code class="fe me mf mg mh b">multiply()</code>定义的例子:</p><pre class="ks kt ku kv gt mi mh mj bn mk ml bi"><span id="a8cd" class="mm mn it mh b be mo mp l mq mr">def multiply(x, m):<br/>    """Multiply x by m.<br/><br/>    &gt;&gt;&gt; multiply(10, 5)<br/>    50<br/>    &gt;&gt;&gt; multiply("a", 3)<br/>    'aaa'<br/>    """<br/>    return x * m</span></pre><p id="97d9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">文档字符串是记录功能和用单元测试丰富功能的强大方法(例如，<code class="fe me mf mg mh b"><a class="ae lh" href="https://docs.python.org/3/library/doctest.html" rel="noopener ugc nofollow" target="_blank">doctest</a></code> <a class="ae lh" href="https://docs.python.org/3/library/doctest.html" rel="noopener ugc nofollow" target="_blank"> s </a>)。您可以向命名的<code class="fe me mf mg mh b">lambda</code>函数添加任何类型的文档，除了行内注释。另一方面，我想你不会对需要 docstring 的函数使用<code class="fe me mf mg mh b">lambda</code>。然而，我会说<code class="fe me mf mg mh b">multiply()</code>不需要<em class="ms">而</em>需要 docstring——但是有了它就更清楚了。</p><h2 id="aa0b" class="ok mn it bd mu ol om dn my on oo dp nc lr op oq ne lv or os ng lz ot ou ni iz bi translated">清晰，带注释(类型提示)</h2><p id="0912" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">我们知道，当明智地使用时，类型提示可以增加函数的清晰度。考虑这两个例子:</p><pre class="ks kt ku kv gt mi mh mj bn mk ml bi"><span id="18db" class="mm mn it mh b be mo mp l mq mr">from numbers import Number<br/><br/>def square(x: Number) -&gt; Number:<br/>    return x**2<br/><br/>square = lambda x: x**2</span></pre><pre class="ov mi mh mj bn mk ml bi"><span id="c0e5" class="mm mn it mh b be mo mp l mq mr">def multiply(x: Number, m: Number) -&gt; Number:<br/>    return x * m<br/><br/>multiply = lambda x, m: x * m</span></pre><p id="c8cc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们不能在<code class="fe me mf mg mh b">lambda</code>定义中使用函数注释。所以，每当你有一个函数，它的签名使用了<em class="ms">有用的</em>类型提示，基于<code class="fe me mf mg mh b">def</code>的定义总是更好，因为它比它的<code class="fe me mf mg mh b">lambda</code>定义传达了更多关于函数的信息。</p><p id="c978" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，做一个简短的心理练习:想象一下既有 docstring 又有 type 提示的<code class="fe me mf mg mh b">multiply()</code>,看看这个定义比简单的命名的<code class="fe me mf mg mh b">lambda</code>定义好多少。</p><p id="3930" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的例子表明，具有两个(或者更多)参数的函数可能比单参数函数更缺少类型提示。</p><h1 id="5b4a" class="mt mn it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated">结论</h1><p id="0546" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">我们比较了 Python 中基于<code class="fe me mf mg mh b">lambda</code>和基于<code class="fe me mf mg mh b">def</code>的函数定义。在这样做的时候，我们只使用了两个方面:简洁和视觉混乱；和清晰度。这种对比并不十分富有——因为我们不需要让它变得富有。无论从哪个角度来看这两种定义，<code class="fe me mf mg mh b">def</code>总是比<code class="fe me mf mg mh b">lambda</code>更好。</p><p id="fd54" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">即使在最简单的函数的情况下，我也没有找到足够的理由来使用<code class="fe me mf mg mh b">lambda</code>定义它们。通常情况下，相应的<code class="fe me mf mg mh b">def</code>定义更清晰，即使稍微长一点，它的代码在视觉上也不那么混乱和密集。</p><p id="32c2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我很难想象一个双参数函数，特别是至少有一个参数的默认值，定义<code class="fe me mf mg mh b">lambda</code>时比定义<code class="fe me mf mg mh b">def</code>时更清晰。</p><p id="6969" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，<code class="fe me mf mg mh b">def</code>定义使开发者能够使用<code class="fe me mf mg mh b">lambda</code>函数中没有的三个强大工具:</p><ul class=""><li id="edfb" class="nv nw it lk b ll lm lo lp lr nx lv ny lz nz md oj ob oc od bi translated">函数注释(类型提示)</li><li id="1f6d" class="nv nw it lk b ll oe lo of lr og lv oh lz oi md oj ob oc od bi translated">文档字符串</li><li id="fa24" class="nv nw it lk b ll oe lo of lr og lv oh lz oi md oj ob oc od bi translated">单元测试，通过 doctest 内部的 doctest</li></ul><p id="b5a5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">多亏了它们，我们可以让<code class="fe me mf mg mh b">def</code>函数提供更多信息。</p></div><div class="ab cl ow ox hx oy" role="separator"><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb"/></div><div class="im in io ip iq"><p id="c526" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">感谢阅读这篇文章。我希望你喜欢它。</p><p id="1122" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我真的希望我已经说服了你。即使这两种类型的函数定义对你来说都一样好——即使这样，我还是会<em class="ms">而不是</em>使用命名的<code class="fe me mf mg mh b">lambda</code>定义。这是因为使用它们，你什么也得不到，同时也冒着别人不同意你的风险。如果连这都不能说服你，记住这样做是违背 PEP8 的。</p><p id="a931" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">那么，在给一个函数命名时，为什么要使用命名的<code class="fe me mf mg mh b">lambda</code>定义呢？</p><h1 id="12b6" class="mt mn it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated">资源</h1><div class="pd pe gp gr pf pg"><a href="https://peps.python.org/pep-0008/" rel="noopener  ugc nofollow" target="_blank"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd jd gy z fp pl fr fs pm fu fw jc bi translated">PEP 8 风格的 Python 代码指南</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">本文档给出了 Python 代码的编码约定，包括主 Python 中的标准库…</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">peps.python.org</p></div></div></div></a></div><div class="pd pe gp gr pf pg"><a href="https://betterprogramming.pub/pythons-type-hinting-friend-foe-or-just-a-headache-73c7849039c7" rel="noopener  ugc nofollow" target="_blank"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd jd gy z fp pl fr fs pm fu fw jc bi translated">Python 的类型暗示:朋友，敌人，还是只是头痛？</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">类型提示在 Python 社区越来越受欢迎。这将把我们引向何方？我们能做些什么来使用它…</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">better 编程. pub</p></div></div><div class="pp l"><div class="pq l pr ps pt pp pu lb pg"/></div></div></a></div><div class="pd pe gp gr pf pg"><a rel="noopener follow" target="_blank" href="/lambda-functions-with-practical-examples-in-python-45934f3653a8"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd jd gy z fp pl fr fs pm fu fw jc bi translated">Python 中的 Lambda 函数及其实例</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">如何、何时使用以及何时不使用 Lambda 函数</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">towardsdatascience.com</p></div></div><div class="pp l"><div class="pv l pr ps pt pp pu lb pg"/></div></div></a></div><div class="pd pe gp gr pf pg"><a href="https://docs.python.org/3/library/doctest.html" rel="noopener  ugc nofollow" target="_blank"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd jd gy z fp pl fr fs pm fu fw jc bi translated">doctest -测试交互式 Python 示例- Python 3.11.0 文档</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">源代码:Lib/doctest.py 检查模块的文档字符串是否是最新的</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">docs.python.org</p></div></div></div></a></div></div><div class="ab cl ow ox hx oy" role="separator"><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb"/></div><div class="im in io ip iq"><div class="ks kt ku kv gt pg"><a href="https://medium.com/@nyggus/membership" rel="noopener follow" target="_blank"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd jd gy z fp pl fr fs pm fu fw jc bi translated">加入我的介绍链接媒体-马尔钦科萨克</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">阅读马尔钦·科萨克(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">medium.com</p></div></div><div class="pp l"><div class="pw l pr ps pt pp pu lb pg"/></div></div></a></div></div></div>    
</body>
</html>