<html>
<head>
<title>Demystify Iterators and Generators in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开Python中迭代器和生成器的神秘面纱</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/demystify-iterators-and-generators-in-python-f21878c9897#2022-07-01">https://towardsdatascience.com/demystify-iterators-and-generators-in-python-f21878c9897#2022-07-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9b5f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解处理大型数据集的有效方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1cd3f689abc22407266ffff0161174e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*j8LBmrobZUbqBHKa.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由Pixabay中的<a class="ae ky" href="https://pixabay.com/photos/magic-cube-patience-tricky-hobby-1976725/" rel="noopener ugc nofollow" target="_blank">设计</a>完成</p></figure><p id="3083" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您有一个大型数据集时，比如一个大的CSV文件或一个大的SQL表，将所有数据加载到内存中是低效的，甚至是不可能的。你的电脑会卡住，你的程序会崩溃。调试起来既费时又令人沮丧。幸运的是，迭代器和生成器是解决这类问题的好工具。此外，理解生成器有助于学习更高级的特性，比如目前越来越流行的asyncio。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="c8e0" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">Python中的范围</h2><p id="4b76" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在开始之前，让我们看一下特殊的<code class="fe na nb nc nd b">range</code>函数，该函数返回一个产生整数序列的<strong class="lb iu">可迭代的</strong>。Iterable，顾名思义，就是可以迭代的东西。或者你可以把它理解为可以在一个<code class="fe na nb nc nd b">for</code>循环中使用的东西。让我们用一些简单的代码来验证一下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="89bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这个简单的代码片段中，我们可以知道:</p><ul class=""><li id="2a7a" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">从技术上讲，<code class="fe na nb nc nd b">range</code>是一个类，尽管它以非Pythonic化的小写字母开头。<code class="fe na nb nc nd b">range</code>返回的对象属于<code class="fe na nb nc nd b">range</code>类型。</li><li id="63a7" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">一个<code class="fe na nb nc nd b">range</code>对象是<strong class="lb iu">可迭代的</strong>并且可以被迭代。</li><li id="ef3d" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">然而，<code class="fe na nb nc nd b">range</code>对象不是迭代器。我们需要使用<code class="fe na nb nc nd b">iter</code>函数将一个<strong class="lb iu">可迭代</strong>转换成一个<strong class="lb iu">迭代器</strong>。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="5516" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">迭代器</h2><p id="a854" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">迭代器是一个实现神奇的<code class="fe na nb nc nd b">__next__</code>方法的对象，因此可以在<code class="fe na nb nc nd b">next</code>函数中用来产生数据流的下一个元素，如上所示。为了理解迭代器是如何工作的，让我们创建一个模仿<code class="fe na nb nc nd b">range</code>函数行为的类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="54ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要一些代码来模拟<code class="fe na nb nc nd b">range</code>的位置参数的行为。重要的是，我们需要一个状态变量<code class="fe na nb nc nd b">counter</code>来记录自定义迭代器处于哪个状态以及下次生成哪个值。</p><p id="a9f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用<code class="fe na nb nc nd b">next</code>函数试试定制迭代器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="100c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，它像预期的那样工作。现在，让我们试着在一个<code class="fe na nb nc nd b">for</code>循环中使用它，看看会发生什么。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="5ec0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，有点奇怪，不是吗？<code class="fe na nb nc nd b">MyRangeIter</code>是迭代器，但不是可迭代的。如果迭代器只能在<code class="fe na nb nc nd b">next</code>函数中使用，而不能在<code class="fe na nb nc nd b">for</code>循环中使用，那么它就没有用。实际上，要使一个迭代器可迭代，我们需要实现<code class="fe na nb nc nd b">__iter__</code>魔法方法，这使得它可迭代，并且可以与上面演示的<code class="fe na nb nc nd b">iter</code>函数一起使用。如果你现在在<code class="fe na nb nc nd b">r_iter</code>上使用<code class="fe na nb nc nd b">iter</code>，你也会看到一个错误，说它是不可迭代的。现在让我们添加<code class="fe na nb nc nd b">__iter__</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a038" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经知道，<code class="fe na nb nc nd b">iter</code>函数调用底层类的<code class="fe na nb nc nd b">__iter__</code>方法并返回一个迭代器。在这个例子中，返回的迭代器是它自己。是的，很奇怪，但事情就是这样。实际上，如果您意识到要使类能够使用<code class="fe na nb nc nd b">next</code>和<code class="fe na nb nc nd b">iter</code>函数，必须分别实现神奇的<code class="fe na nb nc nd b">__next__</code>和<code class="fe na nb nc nd b">__iter__</code>方法，那么理解起来就不会那么困难了。</p><p id="9aa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在该变量可以在<code class="fe na nb nc nd b">for</code>循环中使用。你可以自己尝试一下。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="386e" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">发电机</h2><p id="e506" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如上所述，创建迭代器需要相当多的样板代码。我们需要创建一个类并实现神奇的<code class="fe na nb nc nd b">__next__</code>和<code class="fe na nb nc nd b">__iter__</code>方法。在Python中有一种更好的方法，这就是生成器的亮点。</p><p id="7037" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要创建一个生成器，我们不需要创建一个类并实现神奇的<code class="fe na nb nc nd b">__next__</code>和<code class="fe na nb nc nd b">__iter__</code>方法。生成器简单地由生成器函数定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="91cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成器函数的所有魔力都在于关键字<code class="fe na nb nc nd b"><strong class="lb iu">yield</strong></code>，它将数据和控制返回给调用者，但保留函数的状态。当它再次迭代时，函数被恢复，并基于最新状态产生一个新值。在这个例子中，状态是用简单的计数器实现的。如果你把<code class="fe na nb nc nd b">yield</code>改成<code class="fe na nb nc nd b">return</code>，那么它就是一个常规函数，只会返回一个值。实际上，如果没有<code class="fe na nb nc nd b">yield</code>关键字，它根本不是一个生成器，不能被迭代。</p><p id="11e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试试我们的发电机:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="646a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似于迭代器，当生成器耗尽时会引发<code class="fe na nb nc nd b">StopIteration</code>异常。该异常由<code class="fe na nb nc nd b">for</code>循环自动处理。</p><p id="4294" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，应该注意的是，生成器函数中的<code class="fe na nb nc nd b">return</code>关键字会引发<code class="fe na nb nc nd b">StopIteration</code>异常，返回值将被用作异常的消息。这对于理解生成器的类型注释是很重要的，我们将很快介绍这一点。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="1816" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">生成器理解</h2><p id="9ee0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在我们学习更高级的生成器的<code class="fe na nb nc nd b">send</code>方法之前，让我们先学习一些简单而方便的东西。与列表理解类似，我们可以使用生成器理解用一行代码创建一个生成器。唯一的区别是我们需要将括号改为圆括号:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="66b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，生成器理解与列表理解非常相似。你只需要把括号换成圆括号。但是，使用list comprehension，所有数据都被加载到内存中，这可以通过创建的变量的大小反映出来。另一方面，它不是生成器理解的情况，这使得它更加节省内存。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="ab79" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">了解发电机的<code class="fe na nb nc nd b">send</code>方法</h2><p id="d900" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">大多数情况下，不需要使用生成器的<code class="fe na nb nc nd b">send</code>方法。在用Python编码的这些年里，我从来没有机会使用它。然而，理解它是如何工作的有助于为生成器添加类型注释。此外，如果你想了解Python中的<a class="ae ky" href="https://docs.python.org/3/library/asyncio.html" rel="noopener ugc nofollow" target="_blank"> asyncio </a>库是如何工作的，这也很重要，因为<a class="ae ky" href="https://peps.python.org/pep-0342/" rel="noopener ugc nofollow" target="_blank">协程</a>是由幕后的生成器实现的。</p><p id="51d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们更新生成器，让它接受用户发送的值。该值将用于更改生成器函数中的<code class="fe na nb nc nd b">stop</code>变量，这样我们可以生成更多的值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="7ef8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，发送给生成器函数的值是由<code class="fe na nb nc nd b">yield</code>语句接收的。您可以将<code class="fe na nb nc nd b">yield</code>语句的返回值赋给一个变量，并相应地使用它。要向生成器发送一个值，只需调用生成器上的<code class="fe na nb nc nd b">send()</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="62da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，您只能在生成器已经产生某些东西之后向它发送数据，否则，您将看到一个<code class="fe na nb nc nd b">TypeError</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="d0c3" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">生成器的类型注释</h2><p id="9225" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">最后，让我们向上面创建的生成器函数添加类型注释。<a class="ae ky" href="https://lynn-kwong.medium.com/python-typing-and-validation-with-mypy-and-pydantic-a2563d67e6d" rel="noopener">在函数中添加类型注释</a>可以让你的代码更健壮，更容易理解。不用读函数体就能知道返回类型。</p><p id="f6bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个生成器函数既包含了<code class="fe na nb nc nd b">yield</code>和<code class="fe na nb nc nd b">return</code>关键字，也可以接受外部发送的值，那么我们需要使用泛型<code class="fe na nb nc nd b">Generator[YieldType, SendType, ReturnType]</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9fe3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意对于<code class="fe na nb nc nd b">*args</code>，我们只需要为一个参数添加类型注释。更多细节请参考<a class="ae ky" href="https://stackoverflow.com/questions/37031928/type-annotations-for-args-and-kwargs" rel="noopener ugc nofollow" target="_blank">本讨论</a>。</p><p id="8c6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在大多数情况下，我们的生成器只会产生值。在这种情况下，我们可以将<code class="fe na nb nc nd b">SendType</code>和<code class="fe na nb nc nd b">ReturnType</code>设置为<code class="fe na nb nc nd b">None</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="0a82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://docs.python.org/3.6/library/typing.html#typing.Generator" rel="noopener ugc nofollow" target="_blank">或者</a>，当一个生成器只产生值时，我们可以将返回类型标注为<code class="fe na nb nc nd b">Iterable[YieldType]</code>或<code class="fe na nb nc nd b">Iterator[YieldType]</code>，这对于那些不理解生成器的<code class="fe na nb nc nd b">send</code>方法的人来说更简洁，更容易混淆:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="4e77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们介绍了iterables、iterators和generators的技术细节，它们可以让您高效地处理需要大量资源(尤其是内存)的大型数据集。提供了一些简单的代码片段，可以帮助您理解迭代器和生成器的神奇方法，您通常将它们用作黑盒。发电机更受关注，因为它更简单，应用更广泛。我们已经揭开了<code class="fe na nb nc nd b">send</code>方法及其类型注释的神秘面纱。有了这些知识，您也可以理解更高级的特性，比如Python中的asyncio。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="1ce1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相关文章:</p><ul class=""><li id="0fbf" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><a class="ae ky" href="https://lynn-kwong.medium.com/python-typing-and-validation-with-mypy-and-pydantic-a2563d67e6d" rel="noopener">使用mypy和pydantic进行Python类型化和验证</a></li></ul></div></div>    
</body>
</html>