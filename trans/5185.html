<html>
<head>
<title>Python: To OOP or to FP?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python:面向对象还是面向编程？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-to-oop-or-to-fp-13ac79a43b16#2022-11-21">https://towardsdatascience.com/python-to-oop-or-to-fp-13ac79a43b16#2022-11-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="39bb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这是一个问题</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6a200bf69efb92c512297266e87c01ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-94Bzm1IKl4t-aY7"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">苏珊·霍尔特·辛普森在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="6a22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">程序员永远无法在任何事情上达成一致，但迄今为止，不断困扰互联网的最大争论之一是面向对象编程(OOP)和函数式编程(FP)之间的斗争。</p><p id="69fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">提醒一下，OOP 围绕着将所有的业务逻辑和数据包装在类中，然后可以创建共享相同功能的对象。它还包括继承和多态等概念，这使得拥有功能相似但略有不同的类变得更加容易。</p><p id="1daf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常用来演示 OOP 的语言是 Java。在 Java 中，所有东西都必须包装在一个类中，包括程序的主执行循环。</p><p id="24fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，函数式编程更关心——你猜对了——函数。在函数式编程中，数据通常通过管道从一个函数传递到另一个函数，每个函数对数据执行一个操作。如果给定相同的输入，函数通常被设计成产生完全相同的输出。</p><p id="4420" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最流行的函数式编程语言是 Clojure、Elixir 和 Haskell。</p><h1 id="842b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">但是 Python 呢？</h1><p id="a3d8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Python 是一个有趣的例子。它共享了面向对象语言的许多共同特性，允许您创建类并从超类继承，但它也具有您通常在函数式语言中看到的功能。你可以在程序的主体中定义函数，函数也是一等公民，这意味着你可以把它们作为对象传递。</p><p id="ac96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实是，Python 非常灵活。如果您来自 Java，并且想用纯面向对象的风格编写所有东西，那么您将能够完成您想要的大部分事情。如果您以前是 Clojure 开发人员，用 Python 复制 FP 模式也不会有太大的困难。</p><p id="4f7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，Python 的美妙之处在于，你不局限于任何一种做事方式。您可以使用这两种范例的特性来创建可读的、可扩展的代码，这将保持您的代码库的可维护性，即使它在增长。</p><p id="a832" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是三个用 OOP、FP 和两者混合编写的相同(非常简单)程序的例子。我将强调每种方法的优点和缺点，这将为您设计下一个 Python 项目打下良好的基础。</p><h1 id="656c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">该计划</h1><p id="4745" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">用于演示的程序非常简单——它创建了两只动物(一只狗和一条鱼),并让它们执行一些非常简单的动作。在这个例子中，动作只是记录到<code class="fe mp mq mr ms b">stdout</code>，但是它们显然可以做得更多。</p><h2 id="aac7" class="mt lt iq bd lu mu mv dn ly mw mx dp mc lf my mz me lj na nb mg ln nc nd mi ne bi translated">OOP 示例</h2><pre class="kg kh ki kj gt nf ms ng bn nh ni bi"><span id="9b95" class="nj lt iq ms b be nk nl l nm nn">from abc import ABC, abstractmethod<br/><br/><br/>class Logger(ABC):<br/>    @abstractmethod<br/>    def log(self, message: str):<br/>        ...<br/><br/><br/>class MyLogger(Logger):<br/>    def __init__(self, name: str):<br/>        self.name = name<br/><br/>    def log(self, message: str):<br/>        print(f'{self.name}: {message}')<br/><br/><br/>class Animal:<br/>    def __init__(self, name: str, logger: Logger):<br/>        self.name = name<br/>        self.logger = logger<br/><br/>    def speak(self):<br/>        self.logger.log('Speaking')<br/>        ...<br/><br/><br/>class Dog(Animal):<br/>    def speak(self):<br/>        self.logger.log('Woof!')<br/>        ...<br/><br/>    def run(self):<br/>        self.logger.log('Running')<br/>        ...<br/><br/><br/>class Fish(Animal):<br/>    ...<br/><br/><br/>class App:<br/>    @staticmethod<br/>    def run():<br/>        fido = Dog(name='Fido', logger=MyLogger('Fido'))<br/>        goldie = Fish(name='Goldie', logger=MyLogger('Goldie'))<br/><br/>        fido.speak()<br/>        fido.run()<br/><br/>        goldie.speak()<br/><br/><br/>if __name__ == '__main__':<br/>    App.run()<br/><br/># Fido: Woof!<br/># Fido: Running<br/># Goldie: Speaking</span></pre><p id="552c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，代码创建了一个用于将事件记录到<code class="fe mp mq mr ms b">stdout</code>的<code class="fe mp mq mr ms b">MyLogger</code>类，一个<code class="fe mp mq mr ms b">Animal</code>基类，然后是用于更具体动物的<code class="fe mp mq mr ms b">Dog</code>和<code class="fe mp mq mr ms b">Fish</code>类。</p><p id="1b2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了更好地遵循 OOP 范例，它还定义了一个具有运行程序的单一方法<code class="fe mp mq mr ms b">run</code>的<code class="fe mp mq mr ms b">App</code>类。</p><p id="1fc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">OOP 和继承的好处是我们不必在<code class="fe mp mq mr ms b">Fish</code>类上定义一个<code class="fe mp mq mr ms b">speak</code>方法，它仍然能够说话。</p><p id="decd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，如果我们想要有更多可以运行的动物，我们就必须在<code class="fe mp mq mr ms b">Animal</code>和<code class="fe mp mq mr ms b">Dog</code>之间引入一个定义<code class="fe mp mq mr ms b">run</code>方法的<code class="fe mp mq mr ms b">RunningAnimal</code>类，并且可能为<code class="fe mp mq mr ms b">Fish</code>引入一个类似的<code class="fe mp mq mr ms b">SwimmingAnimal</code>类，但是之后我们的层次结构开始变得越来越复杂。</p><p id="0e04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，<code class="fe mp mq mr ms b">MyLogger</code>和<code class="fe mp mq mr ms b">App</code>类在这里几乎没有用。每个都只做一件事，实际上使代码可读性稍差。这些最好放在一个<code class="fe mp mq mr ms b">log</code>和一个<code class="fe mp mq mr ms b">main</code>(或<code class="fe mp mq mr ms b">run</code>)函数中。</p><p id="01ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还必须创建一个纯粹的<code class="fe mp mq mr ms b">Logger</code>抽象基类，这样代码就可以正确地进行类型提示，并允许我们 API 的用户传入其他日志程序，如果他们想登录到<code class="fe mp mq mr ms b">stdout</code>之外的地方，或者如果他们想用不同的格式登录。</p><h2 id="f65a" class="mt lt iq bd lu mu mv dn ly mw mx dp mc lf my mz me lj na nb mg ln nc nd mi ne bi translated">FP 示例</h2><p id="3e69" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">只是提醒一下——我对 FP 的熟悉程度不如 OOP，所以这可能不是实现这种行为的最像 FP 的方式，但这是我要做的。</p><pre class="kg kh ki kj gt nf ms ng bn nh ni bi"><span id="f36e" class="nj lt iq ms b be nk nl l nm nn">import functools<br/>from typing import Callable<br/><br/>Logger = Callable[[str], None]<br/><br/><br/>def log(message: str, name: str):<br/>    print(f'{name}: {message}')<br/><br/><br/>def bark(<br/>    name: str,<br/>    log_fn: Logger,<br/>) -&gt; (str, Logger):<br/>    log_fn('Woof!')<br/>    return name, log_fn<br/><br/><br/>def run(<br/>    name: str,<br/>    log_fn: Logger,<br/>) -&gt; (str, Logger):<br/>    log_fn('Running')<br/>    return name, log_fn<br/><br/><br/>def speak(<br/>    name: str,<br/>    log_fn: Logger,<br/>) -&gt; (str, Logger):<br/>    log_fn('Speaking')<br/>    return name, log_fn<br/><br/><br/>def main():<br/>    run(<br/>        *bark(<br/>            'Fido',<br/>            functools.partial(log, name='Fido'),<br/>        ),<br/>    )<br/><br/>    speak(<br/>        'Goldie',<br/>        functools.partial(log, name='Goldie'),<br/>    )<br/><br/><br/>if __name__ == '__main__':<br/>    main()<br/><br/># Fido: Woof!<br/># Fido: Running<br/># Goldie: Speaking</span></pre><p id="09f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很快，我们可以看到我们的<code class="fe mp mq mr ms b">Logger</code>类已经成为<code class="fe mp mq mr ms b">Callable[[str], None]</code>的一个方便的类型别名。我们还定义了一个<code class="fe mp mq mr ms b">log</code>函数来处理我们的打印。我们没有为我们的动物定义类，而是简单地定义了以动物的名字和一个<code class="fe mp mq mr ms b">Logger</code>函数命名的函数。</p><p id="d1b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您会注意到，<code class="fe mp mq mr ms b">run</code>、<code class="fe mp mq mr ms b">speak</code>和<code class="fe mp mq mr ms b">bark</code>函数也都返回它们的名称和日志记录函数参数，以便将它们组合到管道中，就像我们对 Fido 的<code class="fe mp mq mr ms b">run</code>和<code class="fe mp mq mr ms b">bark</code>所做的那样。</p><p id="1854" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还将我们的逻辑移到了一个<code class="fe mp mq mr ms b">main</code>函数中，消除了仅仅为了运行我们的程序而定义整个类的需要。</p><p id="40e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了避免我们的<code class="fe mp mq mr ms b">log</code>函数与<code class="fe mp mq mr ms b">Logger</code>类型不匹配的事实，我们使用<code class="fe mp mq mr ms b">functools.partial</code>来创建一个匹配的部分函数。这允许我们用我们喜欢的任何东西来替换我们的记录器，只要我们可以使用一个部分函数来减少它，以便它匹配我们的<code class="fe mp mq mr ms b">Logger</code>类型。</p><p id="416a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，由于我们没有将数据封装在任何东西中，如果我们想给我们的动物添加更多的属性，我们可能不得不开始使用<code class="fe mp mq mr ms b">dict</code>对象来表示它们并传递它们，但这样总是会担心字典创建不正确，从而缺少我们的一个函数所依赖的键。</p><p id="a787" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了避开<em class="no">和</em>，我们需要为我们的动物创建初始化函数，这时代码又变得越来越乱。</p><h2 id="8c7d" class="mt lt iq bd lu mu mv dn ly mw mx dp mc lf my mz me lj na nb mg ln nc nd mi ne bi translated">两者都有点</h2><p id="a9ce" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">那么，如果我们将一点 OOP 和一点 FP 结合起来，会发生什么呢？我将引入一些 Pythonic 代码来脱离传统的 OOP 和 FP 范例，并希望使代码更加简洁易读。</p><pre class="kg kh ki kj gt nf ms ng bn nh ni bi"><span id="6b24" class="nj lt iq ms b be nk nl l nm nn">from dataclasses import dataclass<br/>from functools import partial<br/>from typing import Callable<br/><br/>Logger = Callable[[str], None]<br/><br/><br/>def log(message: str, name: str):<br/>    print(f'{name}: {message}')<br/><br/><br/>@dataclass<br/>class Animal:<br/>    name: str<br/>    log: Logger<br/><br/>    def speak(self):<br/>        self.log('Speaking')<br/><br/><br/>@dataclass<br/>class Dog(Animal):<br/>    breed: str = 'Labrador'<br/><br/>    def speak(self):<br/>        self.log('Woof!')<br/><br/>    def run(self):<br/>        self.log('Running')<br/><br/><br/>@dataclass<br/>class Fish(Animal):<br/>    ...<br/><br/><br/>def main():<br/>    fido = Dog('Fido', partial(log, name='Fido'))<br/>    goldie = Fish('Goldie', partial(log, name='Goldie'))<br/><br/>    fido.speak()<br/>    fido.run()<br/><br/>    goldie.speak()<br/><br/><br/>if __name__ == '__main__':<br/>    main()<br/><br/># Fido: Woof!<br/># Fido: Running<br/># Goldie: Speaking</span></pre><p id="1220" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我使用 python<code class="fe mp mq mr ms b">dataclasses</code>模块来避免为我的类编写构造函数。这不仅减少了我需要编写的一些代码，而且如果我需要的话，还可以更容易地添加新的属性。</p><p id="d009" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似于 OOP 的例子，我们有一个带有<code class="fe mp mq mr ms b">Dog</code>和<code class="fe mp mq mr ms b">Fish</code>子类的<code class="fe mp mq mr ms b">Animal</code>基类。然而，就像在 FP 示例中一样，我使用了<code class="fe mp mq mr ms b">Logger</code>类型别名和<code class="fe mp mq mr ms b">functools.partial</code>来为动物创建记录器。Python 支持作为一等公民的函数使得这变得更加容易。</p><p id="7be6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有，<code class="fe mp mq mr ms b">main</code>函数只是一个函数。我永远不会明白为什么 Java 是 Java 的样子。</p><h1 id="9aed" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">在生产中混合 OOP 和 FP</h1><p id="2c07" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">好的，我承认这个例子非常简单，虽然它为我们的讨论提供了一个很好的起点，但是我现在想给你们一个例子来说明这些概念是如何在生产中使用的，我将使用我最喜欢的两个 Python 库:<a class="ae kv" href="https://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank"> FastAPI </a>和<a class="ae kv" href="https://pydantic-docs.helpmanual.io/" rel="noopener ugc nofollow" target="_blank"> Pydantic </a>。FastAPI 是 Python 的轻量级 API 框架，Pydantic 是数据验证和设置管理库。</p><p id="2540" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不打算详细介绍这些库，但是 Pydantic 有效地允许您使用 Python 类定义数据结构，然后验证传入的数据并通过对象属性访问它。这意味着您不会遇到使用字典带来的问题，并且您总是知道您的数据是您期望的格式。</p><p id="dbb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">FastAPI 允许您将 API 路由定义为函数，用一个装饰器(这是一个非常类似 FP 的概念)包装每一个路由，以封装您的逻辑。</p><p id="6a9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是如何使用它的一个例子。同样，这是一个简单的示例，但它相当能代表您在生产中可能看到的情况。</p><pre class="kg kh ki kj gt nf ms ng bn nh ni bi"><span id="7f6e" class="nj lt iq ms b be nk nl l nm nn">from fastapi import FastAPI<br/>from pydantic import BaseModel<br/><br/>app = FastAPI()<br/><br/><br/>class Baz(BaseModel):<br/>    qux: int<br/><br/><br/>class Foo(BaseModel):<br/>    bar: str<br/>    baz: Baz<br/><br/><br/>@app.get('/foo')<br/>async def get_foo(name: str, age: int) -&gt; Foo:<br/>    ...  # Some logic here<br/>    return Foo(<br/>        bar=name,<br/>        baz=Baz(qux=age),<br/>    )<br/><br/># GET /foo?name=John&amp;age=42<br/># {<br/>#   "bar": "John",<br/>#   "baz": {<br/>#     "qux": 42<br/>#   }<br/># }</span></pre><p id="5fc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，FastAPI 使用 Pydantic 的能力将嵌套对象转换为 JSON，从而为我们的端点创建一个 JSON 响应。<code class="fe mp mq mr ms b">app.get</code>装饰器还向<code class="fe mp mq mr ms b">app</code>对象注册了我们的<code class="fe mp mq mr ms b">get_foo</code>函数，允许我们向<code class="fe mp mq mr ms b">/foo</code>端点发出<code class="fe mp mq mr ms b">GET</code>请求。</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><p id="c8c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这篇文章对你有所帮助。我很想听听你们的想法，以及你们在编写 Python 时倾向于哪种范式。</p><p id="4b3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显然，这并不是 Python 中结合 FP 和 OOP 的唯一方式，使用这种结合可以实现和改进很多设计模式。</p><p id="62e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将在未来写下这些，通过在<a class="ae kv" href="https://medium.isaacharrisholt.com/" rel="noopener ugc nofollow" target="_blank">媒体</a>上跟随我，你将不会错过。我也在 Twitter 上发关于 Python 和我当前项目的推文，并且(最近)也在乳齿象上发关于它们的帖子。</p><p id="9de3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我相信我们很快会再见的！</p><p id="e1f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">-艾萨克</p></div></div>    
</body>
</html>