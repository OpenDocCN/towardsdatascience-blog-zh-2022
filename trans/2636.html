<html>
<head>
<title>Raw text correction with Fuzzy Matching for NLP tasks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自然语言处理任务中模糊匹配的原始文本校正</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/raw-text-correction-with-fuzzy-matching-for-nlp-tasks-828547742ef7#2022-06-07">https://towardsdatascience.com/raw-text-correction-with-fuzzy-matching-for-nlp-tasks-828547742ef7#2022-06-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5e76" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何修复拼写错误的单词，以便更好地识别重要的文本表达式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/013d48202172113b5d4f13300cb28407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AFhhdcqduXT49UmP"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Diomari Madulara 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e106" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，自然语言处理(NLP)被用于医疗保健、金融、营销等领域的许多ML任务和项目中。数据科学家经常努力清理和分析文本数据，以便获得洞察力。对于大多数自然语言处理任务，通常使用诸如标记化、词干化、词汇化等技术。</p><p id="44b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，在某些情况下，需要保持原始文本的完整性，而不是将其拆分成标记。例如，在作为命名实体识别(NER)的私人情况的数据去标识中，一种用于识别文档中不同实体的方法，该方法的输出显示原始文本，其中标签替换期望的实体。</p><p id="597b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这些情况下，纠正拼写错误或错误的术语可能会很有挑战性。这篇文章将解释如何结合使用正则表达式和模糊字符串匹配来完成这项任务。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="cff6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">模糊字符串匹配</strong></p><p id="093e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">模糊字符串匹配是一种查找与给定字符串模式近似匹配的字符串的技术。模糊字符串匹配背后的算法使用距离度量(如Levenshtein距离)来计算两个字符串之间的差异，方法是确定将第一个字符串转换为第二个字符串所需的最少更改次数。我们将使用python库<em class="lz"> Fuzzywuzzy </em>来执行这项任务。</p><p id="12a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">安装和示例:</p><pre class="kg kh ki kj gt ma mb mc md aw me bi"><span id="a94e" class="mf mg iq mb b gy mh mi l mj mk">pip install fuzzywuzzy</span><span id="53b1" class="mf mg iq mb b gy ml mi l mj mk">from fuzzywuzzy import fuzz</span><span id="eba5" class="mf mg iq mb b gy ml mi l mj mk">fuzz.ratio("appls","apples")</span><span id="9f23" class="mf mg iq mb b gy ml mi l mj mk">#91</span></pre><p id="2acb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我们得到了91分的相似度，所以单词非常相似。现在，我们可以考虑使用什么阈值来决定是否“纠正”原始单词。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="32a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">正则表达式</strong></p><p id="ae4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">RegEx是正则表达式的缩写，是一种特殊的文本字符串，用于指定文本中的搜索模式。这种模式基本上是一种语言，它确切地定义了在文本字符串中要寻找什么。例如，如果我们想提取除数字以外的所有字符，正则表达式模式将是:</p><pre class="kg kh ki kj gt ma mb mc md aw me bi"><span id="c44f" class="mf mg iq mb b gy mh mi l mj mk">[^0-9]+</span></pre><p id="edb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们想要提取所有的电子邮件地址，正则表达式模式将是:</p><pre class="kg kh ki kj gt ma mb mc md aw me bi"><span id="1704" class="mf mg iq mb b gy mh mi l mj mk">[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}</span></pre><p id="26f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用python库<em class="lz"> re </em>来执行这项任务。</p><p id="76d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">安装和示例:</p><pre class="kg kh ki kj gt ma mb mc md aw me bi"><span id="027e" class="mf mg iq mb b gy mh mi l mj mk">pip install re</span><span id="1add" class="mf mg iq mb b gy ml mi l mj mk">import re</span><span id="2907" class="mf mg iq mb b gy ml mi l mj mk">string = "my e-mail is example@email.com"</span><span id="92fb" class="mf mg iq mb b gy ml mi l mj mk">pattern=r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}'</span><span id="5335" class="mf mg iq mb b gy ml mi l mj mk">print(re.search(pattern,string).group())</span><span id="cdf5" class="mf mg iq mb b gy ml mi l mj mk"># example@email.com</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="a5c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">原始文本校正</strong></p><p id="4793" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到最初的问题，当我们需要修复错误的单词或短语，但保持原始文本完整，而不是将其拆分为标记时，该怎么办。保持文本完整也意味着保持完全相同的间距、制表符、换行符、标点符号等。</p><p id="004b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设在一个NER任务中，我们想要标记医院里给病人的药物。该信息可在电子健康记录(EMR)系统的医生笔记部分获得。例如，这里有一个条目:</p><blockquote class="mm mn mo"><p id="28cf" class="kw kx lz ky b kz la jr lb lc ld ju le mp lg lh li mq lk ll lm mr lo lp lq lr ij bi translated">病人XXX上周住院了。</p><p id="2787" class="kw kx lz ky b kz la jr lb lc ld ju le mp lg lh li mq lk ll lm mr lo lp lq lr ij bi translated">他被赋予了勇气。</p><p id="ed4d" class="kw kx lz ky b kz la jr lb lc ld ju le mp lg lh li mq lk ll lm mr lo lp lq lr ij bi translated">他是男性，65岁，有心脏病史。</p></blockquote><p id="f7a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该药物的正确名称是“莫昔普利”。为了纠正这一点，我们需要:</p><ol class=""><li id="80d0" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">准备一个我们想要搜索的关键字列表，在这种情况下只有一个关键字</li><li id="3235" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">决定相似性阈值(默认为85)</li><li id="e8fd" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">将文本拆分成标记</li><li id="ff31" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">在关键字和每个标记之间运行模糊匹配</li><li id="4a92" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">如果相似性得分超过预定阈值，则用关键字替换标记</li><li id="941c" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">把它们放回原处</li></ol><p id="b095" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用如下函数来实现这一点:</p><pre class="kg kh ki kj gt ma mb mc md aw me bi"><span id="3768" class="mf mg iq mb b gy mh mi l mj mk">from fuzzywuzzy import fuzz<br/>import re</span><span id="4241" class="mf mg iq mb b gy ml mi l mj mk">def fuzzy_replace(keyword_str, text_str, threshold=85):<br/>    l = len(keyword_str.split())<br/>    splitted = re.split(r'(\W+)',text_str) #split, keep linebreaks<br/>    for i in range(len(splitted)-l+1):<br/>        temp = "".join(splitted[i:i+l])<br/>        if fuzz.ratio(keyword_str, temp) &gt;= threshold:<br/>            before = "".join(splitted[:i])<br/>            after = "".join(splitted[i+l:])<br/>            text_str= before + keyword_str + after<br/>            splitted = re.split(r'(\W+)',text_str)    <br/>    return text_str</span></pre><p id="b97b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行此函数后，文本输出现已得到纠正，文本原始结构得以保留:</p><blockquote class="mm mn mo"><p id="8a56" class="kw kx lz ky b kz la jr lb lc ld ju le mp lg lh li mq lk ll lm mr lo lp lq lr ij bi translated">病人XXX上周住院了。</p><p id="39f0" class="kw kx lz ky b kz la jr lb lc ld ju le mp lg lh li mq lk ll lm mr lo lp lq lr ij bi translated">他被给予莫昔普利。</p><p id="7c1c" class="kw kx lz ky b kz la jr lb lc ld ju le mp lg lh li mq lk ll lm mr lo lp lq lr ij bi translated">他是男性，65岁，有心脏病史。</p></blockquote><p id="7b73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们看一个更复杂的例子。这一次，医疗记录中包含了一些我们想要纠正的不同的药物，而且有些在文本中出现了不止一次。为了解决这个问题，我们定义了一个包含所有正确药物名称的列表，并简单地遍历文本以找到需要纠正的内容。以下代码片段显示了如何实现这一点:</p><pre class="kg kh ki kj gt ma mb mc md aw me bi"><span id="47c4" class="mf mg iq mb b gy mh mi l mj mk">meds = ["moexipril", "vasotec", "candesartan"]<br/></span><span id="04eb" class="mf mg iq mb b gy ml mi l mj mk">text = """The patient XXX was hospitalized last week.</span><span id="b6d8" class="mf mg iq mb b gy ml mi l mj mk">He was given moxiperil and vasotek.</span><span id="c0ae" class="mf mg iq mb b gy ml mi l mj mk">He is male, 65 years old, with a history of heart disease.</span><span id="4b3f" class="mf mg iq mb b gy ml mi l mj mk">Patient has been taking vasotek for several years.</span><span id="4100" class="mf mg iq mb b gy ml mi l mj mk">In the past was given candasarta."""</span><span id="75d3" class="mf mg iq mb b gy ml mi l mj mk"><br/>for med in meds:</span><span id="d854" class="mf mg iq mb b gy ml mi l mj mk">    text = fuzzy_replace(med, text)</span></pre><p id="6866" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果是所有药物名称均已更正的相同文本。</p><blockquote class="mm mn mo"><p id="07df" class="kw kx lz ky b kz la jr lb lc ld ju le mp lg lh li mq lk ll lm mr lo lp lq lr ij bi translated">病人XXX上周住院了。</p><p id="34c6" class="kw kx lz ky b kz la jr lb lc ld ju le mp lg lh li mq lk ll lm mr lo lp lq lr ij bi translated">他接受了莫昔普利和vasotec治疗。</p><p id="39c6" class="kw kx lz ky b kz la jr lb lc ld ju le mp lg lh li mq lk ll lm mr lo lp lq lr ij bi translated">他是男性，65岁，有心脏病史。</p><p id="ba07" class="kw kx lz ky b kz la jr lb lc ld ju le mp lg lh li mq lk ll lm mr lo lp lq lr ij bi translated">患者服用vasotec已有数年。</p><p id="a3f8" class="kw kx lz ky b kz la jr lb lc ld ju le mp lg lh li mq lk ll lm mr lo lp lq lr ij bi translated">曾被给予坎地沙坦。</p></blockquote><p id="3c4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我已经决定不包括强制转换成小写的文本，因为有些时候人们希望保持原来的大小写，例如识别缩写。然而，这可以通过将参数的小写形式输入到函数中很容易地完成，就像这样— <code class="fe ng nh ni mb b">fuzzy_replace(med.lower(),text.lower())</code></p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="19a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">结论</strong></p><p id="b3e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用模糊字符串匹配和正则表达式的组合来纠正错误的单词或短语，并保持原始文本不变。当处理不同的NLP任务(如NER)时，这种操作是可取的。</p></div></div>    
</body>
</html>