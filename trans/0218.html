<html>
<head>
<title>5 Advanced Tips on Python Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于 Python 对象的 5 个高级技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-advanced-tips-on-python-objects-689de0f055d6#2022-02-09">https://towardsdatascience.com/5-advanced-tips-on-python-objects-689de0f055d6#2022-02-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b368" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Python 是一种面向对象的编程语言，但是它的行为很奇怪。如果你来自其他 OOP 语言，这篇文章可能对你有益</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/feb6a13acc59e6d1cc4d3406ab198a69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C7fmtiwfQOEwyDU_"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@howlingred16?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迈克·丹勒</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0be3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在《流畅的 Python》的第 8 章中，卢西亚诺·拉马尔霍讨论了 Python 如何在幕后处理对象。这里将定义 python 中变量存储背后的基本概念，并探讨一些相关的注意事项。</p><p id="7286" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事不宜迟，我们开始吧。</p><h1 id="6c94" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1-Python 变量不是盒子</h1><p id="9cc6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><strong class="ky ir">提示:python 变量是值的标签。</strong></p><p id="1b20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在编程 101 中，我们经常被告知变量是存储值的盒子。例如，盒子<code class="fe mp mq mr ms b">a</code>存储列表<code class="fe mp mq mr ms b">[1,2,3]</code>。然而，在 python 中，情况并非如此。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/b1b0365260b219122e2ddff30ce77122.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A4nRbDiSrSDp7yga6Go5yQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图 python 变量的图示。蓝色是变量名，红色是值，黑色是存储它们的盒子。图片作者。</p></figure><p id="2719" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在图 1 中，<strong class="ky ir">变量名(蓝色)是内存中某个位置的“标签”。</strong>注意每个对象可以有多个变量名，如左图所示。内存中的位置(黑色)是“盒子”，而不是名称本身。那些盒子储存数值(红色)。让我们看一个例子。</p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="5fd8" class="my lt iq ms b gy mz na l nb nc">var_name = 1</span><span id="5ca1" class="my lt iq ms b gy nd na l nb nc">var_name         # 1<br/>id(var_name)     # 4443642160</span></pre><p id="03b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码片段中，变量<code class="fe mp mq mr ms b">var_name</code>被赋值为<code class="fe mp mq mr ms b">1</code>。存储值的“盒子”是内存 id <code class="fe mp mq mr ms b">4443642160</code>。</p><p id="609f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们将另一个变量添加到内存中的<strong class="ky ir">相同的</strong>位置…</p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="acaf" class="my lt iq ms b gy mz na l nb nc">another_var_name = var_name</span><span id="292b" class="my lt iq ms b gy nd na l nb nc">id(var_name)                            # 4443642160<br/>var_name                                # 1<br/>id(var_name) == id(another_var_name)    # True</span></pre><p id="862f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们所看到的，我们有两个引用同一个对象的 python 变量。然而，一旦我们改变了第二个变量，例如通过运行<code class="fe mp mq mr ms b">y += 1</code>，我们的内存位置就变成了<code class="fe mp mq mr ms b">4443642192</code>，使得对象变得不同。</p><p id="303f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在 python 中，更直观的概念是将<strong class="ky ir">变量名分配给内存中的位置。</strong>内存中的那些位置存储值。</p><h1 id="4aca" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2-对象相等</h1><p id="1861" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><strong class="ky ir">提示:使用</strong> <code class="fe mp mq mr ms b"><strong class="ky ir">==</strong></code> <strong class="ky ir">判断两个变量是否有相等的值，使用</strong> <code class="fe mp mq mr ms b"><strong class="ky ir">is</strong></code> <strong class="ky ir">判断两个变量是否共享内存中的位置。</strong></p><p id="4331" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据第 1 节中的设置，本节将会很简短。</p><p id="ab43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">==</code>确定变量是否有相同的值——这就像 java 中的<code class="fe mp mq mr ms b">.equals()</code>函数。然而，如果你真的想确定变量是否是同一个对象，你应该使用 T2 来测试内存 id。</p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="8d4f" class="my lt iq ms b gy mz na l nb nc">a = 1<br/>b = 1<br/>c = a</span><span id="352c" class="my lt iq ms b gy nd na l nb nc">a == b == c      # True<br/>a is c           # True</span></pre><p id="470a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个有趣的旁注。我们期望<code class="fe mp mq mr ms b">a is b</code>评估为<code class="fe mp mq mr ms b">False</code>。但是，有时候是<code class="fe mp mq mr ms b">True</code>。</p><p id="768b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">令人惊讶的是，为了节省空间，如果对象值相同，python 有时会将变量分配给同一个对象。这节省了内存，因为在我们的例子中，您不需要创建整数<code class="fe mp mq mr ms b">1</code>的单独实例——您可以引用同一个对象。</p><p id="d477" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在只要我们改变这些变量中的任何一个，它就会在内存中找到自己的位置。</p><h1 id="8255" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3 —拷贝与深层拷贝</h1><p id="238f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><strong class="ky ir">提示:如果你不知道自己在做什么，使用</strong> <code class="fe mp mq mr ms b"><strong class="ky ir">deepcopy()</strong></code> <strong class="ky ir">。</strong></p><p id="ed21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你和熊猫一起工作过，你可能见过和/或用过<code class="fe mp mq mr ms b">df.copy()</code>。使用<code class="fe mp mq mr ms b">copy</code>与<code class="fe mp mq mr ms b">deepcopy</code>只会在处理复合对象(包含其他对象的对象，如列表或类实例)时对您产生影响。但是对于一些编程范例，复合对象是常见的。</p><p id="ff41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是<strong class="ky ir">深层拷贝</strong>和<strong class="ky ir">浅层拷贝</strong>的区别</p><ul class=""><li id="4744" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">深度副本构造一个新的复合对象，然后递归地将在原始对象中找到的对象的副本<em class="ne">插入其中。</em></li><li id="3952" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><em class="ne">一个</em> <strong class="ky ir">浅拷贝</strong>构造一个新的复合对象，然后(尽可能地)将<em class="ne">引用</em>插入到原始对象中。</li></ul><p id="aa23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个例子应该有助于澄清这一点…</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="1b08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">Bus</code>类创建一个乘客列表，从而使每个类实例成为一个复合对象。</p><p id="c4b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们所见，<code class="fe mp mq mr ms b">bus2</code>是<code class="fe mp mq mr ms b">bus1</code>的浅层拷贝，而<code class="fe mp mq mr ms b">bus3</code>是深层拷贝。当<code class="fe mp mq mr ms b">bus1</code>中的对象改变时，会影响<code class="fe mp mq mr ms b">bus2</code>。但是，<code class="fe mp mq mr ms b">bus3</code>完全不受影响。</p><p id="dc98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么使用<code class="fe mp mq mr ms b">deepcopy</code> — <strong class="ky ir">更安全的原因，你将得到一个对象值的全新副本。</strong></p><h1 id="6c2c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">4 —功能参数</h1><p id="23fd" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><strong class="ky ir">提示:如果你设置一个空的可变变量作为 python 函数的默认值，要小心。</strong></p><p id="4034" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python 参数通过共享使用一个名为<em class="ne">的系统调用来传递，这意味着传递的值是浅拷贝。</em></p><p id="b25d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你默认传递一个空列表，例如<code class="fe mp mq mr ms b">def my_func(x=[]):</code>，然后改变<code class="fe mp mq mr ms b">x</code>，你将编辑内置的<code class="fe mp mq mr ms b">list()</code>功能，而不是变量<code class="fe mp mq mr ms b">x</code>。</p><p id="b5cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">书中推荐的方法是通过 case 逻辑在函数的开头指定默认值…</p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="174e" class="my lt iq ms b gy mz na l nb nc">def my_func(x):<br/>  if x is None:<br/>    x = []</span></pre><p id="c2c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就我个人而言，我认为上述方法有些矫枉过正，对风格也不好，不过这是你的选择。</p><h1 id="9881" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">5 —垃圾收集</h1><p id="27be" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><strong class="ky ir">提示:python 变量在引用用完时会被“垃圾收集”。</strong></p><p id="3785" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我们的最后一个技巧，让我们来谈谈 python 垃圾收集是如何工作的。</p><p id="c7c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每次我们给一个对象赋一个变量名，我们就给它一个引用。所以<code class="fe mp mq mr ms b">a=1; b=a</code>意味着存储<code class="fe mp mq mr ms b">1</code>的存储单元的引用计数为 2。</p><p id="a7b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在假设我们将<code class="fe mp mq mr ms b">a</code>和<code class="fe mp mq mr ms b">b</code>都分配给<code class="fe mp mq mr ms b">None</code>，例如<code class="fe mp mq mr ms b">a=None; b=None</code>。现在，因为没有变量引用值为<code class="fe mp mq mr ms b">1</code>的对象，所以可以对该内存位置进行垃圾收集。</p><p id="b1ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">如果参考计数为 0，存储器位置将被擦除，以便重新使用。</strong></p><p id="2af6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很简单，对吧？</p><p id="43fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，为了结束这个话题，让我们也来谈谈关键字<code class="fe mp mq mr ms b">del</code>。<code class="fe mp mq mr ms b"><strong class="ky ir">del</strong></code> <strong class="ky ir">是用来删除变量名，而不是对象本身</strong>。通过删除变量的名称，它释放了这个名称供以后使用，从而避免了潜在的名称冲突。然而，在后端，如果<code class="fe mp mq mr ms b">del</code>导致引用计数为 0，那么对象也将被删除。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><p id="0390" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ne">感谢阅读！我会再写 16 篇文章，把学术研究带到 DS 行业。查看我的评论，链接到这篇文章的主要来源和一些有用的资源。</em></p></div></div>    
</body>
</html>