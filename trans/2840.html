<html>
<head>
<title>5 Sorting Algorithm Visualisations in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的5种排序算法可视化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-sorting-algorithms-in-python-c7ece9df5dd6#2022-06-21">https://towardsdatascience.com/5-sorting-algorithms-in-python-c7ece9df5dd6#2022-06-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5465" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python实现选择、冒泡、插入、合并和快速排序算法</h2></div></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="e593" class="kp kq it bd kr ks kt dn ku kv kw dp kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">介绍</h2><p id="51f7" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt ky lu lv lw lc lx ly lz lg ma mb mc md im bi translated"><strong class="ln iu">排序</strong>数组在编程中很常见，以帮助<em class="me">理解</em>数据并执行<em class="me">查找</em>。因此，与分类大量信息相关的速度对于功能设计和<strong class="ln iu">优化运行时间</strong>至关重要。存在许多算法来完成排序对象的任务。</p><p id="1f46" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">这篇文章展示了五种流行的排序算法的实现和可视化。代码用<em class="me"> Python，</em>图形界面用<em class="me"> Tkinter </em>构建。</p><blockquote class="mk"><p id="99d1" class="ml mm it bd mn mo mp mq mr ms mt md dk translated">这个项目的灵感来自于提莫·宾曼在T21的视频。</p></blockquote><figure class="mw mx my mz na nb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi mv"><img src="../Images/bdb42fe80e86929ecef7bca122bdfb5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yIs6PUM0dSFWPikThl-Wvg.jpeg"/></div></div><p class="ni nj gj gh gi nk nl bd b be z dk translated">乔恩·泰森在<a class="ae mu" href="https://unsplash.com/s/photos/pattern?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="7c76" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">涵盖的算法包括:</p><ul class=""><li id="60e2" class="nm nn it ln b lo mf lr mg ky no lc np lg nq md nr ns nt nu bi translated"><em class="me">选择</em>排序</li><li id="d9f3" class="nm nn it ln b lo nv lr nw ky nx lc ny lg nz md nr ns nt nu bi translated"><em class="me">冒泡</em>排序</li><li id="682a" class="nm nn it ln b lo nv lr nw ky nx lc ny lg nz md nr ns nt nu bi translated"><em class="me">插入</em>排序</li><li id="ea8c" class="nm nn it ln b lo nv lr nw ky nx lc ny lg nz md nr ns nt nu bi translated"><em class="me">合并</em>排序</li><li id="c3a3" class="nm nn it ln b lo nv lr nw ky nx lc ny lg nz md nr ns nt nu bi translated"><em class="me">快速排序</em></li></ul></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="e663" class="kp kq it bd kr ks kt dn ku kv kw dp kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">阵列可视化</h2><p id="9f80" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt ky lu lv lw lc lx ly lz lg ma mb mc md im bi translated">图1是<em class="me">无序整数数据</em>的示例数组。</p><figure class="ob oc od oe gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi oa"><img src="../Images/c9caf06f05fe7ab40230fcf166539937.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lhcWWFPhfTdsr630WSi-Xw.png"/></div></div><p class="ni nj gj gh gi nk nl bd b be z dk translated">图1 —无序的整数数据(作者图片)</p></figure><p id="ef38" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">一旦一个类提供了一些<strong class="ln iu">重载</strong>的<em class="me">比较</em> <em class="me">运算符</em>的实现，那么<strong class="ln iu">就是可排序的</strong>。在Python中，它们是:</p><ul class=""><li id="b91d" class="nm nn it ln b lo mf lr mg ky no lc np lg nq md nr ns nt nu bi translated"><code class="fe of og oh oi b">__lt__</code>:小于</li><li id="30b4" class="nm nn it ln b lo nv lr nw ky nx lc ny lg nz md nr ns nt nu bi translated"><code class="fe of og oh oi b">__gt__</code>:大于</li><li id="ac55" class="nm nn it ln b lo nv lr nw ky nx lc ny lg nz md nr ns nt nu bi translated"><code class="fe of og oh oi b">__eq__</code>:等于</li></ul><p id="2359" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">例如，Gist 1中的代码显示了一个<em class="me">重载的小于</em>的方法。</p><figure class="ob oc od oe gt nb"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ni nj gj gh gi nk nl bd b be z dk translated">要点1 —重载小于运算符</p></figure><p id="7f5b" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">可以使用<strong class="ln iu">条</strong>来表示数字数据。<em class="me"> iᵗʰ条的<strong class="ln iu">高度</strong>等于iᵗʰ数组元素</em>的值。每个杆都有一个<em class="me">等宽</em>。因此，图2给出了将图1中的<strong class="ln iu">数值列表</strong>描绘为一组<em class="me">条</em>。</p><figure class="ob oc od oe gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi ol"><img src="../Images/269468b592e5b596d9cc37f8f24e9c49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6GRLJo_gi4gsH9LQ94u2Nw.png"/></div></div><p class="ni nj gj gh gi nk nl bd b be z dk translated">图2 —以列高表示的整数数据值(图片由作者提供)</p></figure><p id="a33a" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">按<strong class="ln iu"/><em class="me">或</em> <strong class="ln iu">升序</strong><em class="me"/>排序<em class="me">数值数据</em>需要相应地重新排列数值。因此，要实现操纵数据的每个算法的动画，需要在交换单个元素后刷新条形图。</p><p id="c369" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">Gist 2展示了Python代码来交换列表<em class="me">中</em>的两个元素。</p><figure class="ob oc od oe gt nb"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ni nj gj gh gi nk nl bd b be z dk translated">要点2 —交换列表中的元素</p></figure><p id="c6ed" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated"><em class="me">渲染需要两个类</em>，一个是<code class="fe of og oh oi b">Canvas</code>，另一个是<code class="fe of og oh oi b">Bar</code>。查看带有<strong class="ln iu">注释代码</strong>的<a class="ae mu" href="https://github.com/ad-1/SortingVisualisation" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>以获得完整的<em class="me">用户界面</em>。</p><p id="8b5b" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">Gist 3为<code class="fe of og oh oi b">Canvas</code>类中的<strong class="ln iu">渲染更新</strong>提供了必要的代码。当<code class="fe of og oh oi b">bar</code> <code class="fe of og oh oi b">index</code>改变时，如上所述，<code class="fe of og oh oi b">setter</code>触发主画布上的<code class="fe of og oh oi b">update_bar</code>功能。一旦更新被触发，数组项交换位置。</p><figure class="ob oc od oe gt nb"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ni nj gj gh gi nk nl bd b be z dk translated">要点3 —当条索引改变时，触发主画布上的渲染更新</p></figure></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h1 id="e98e" class="om kq it bd kr on oo op ku oq or os kx jz ot ka lb kc ou kd lf kf ov kg lj ow bi translated">算法</h1><h2 id="f1dc" class="kp kq it bd kr ks kt dn ku kv kw dp kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">选择排序</h2><p id="a1dd" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt ky lu lv lw lc lx ly lz lg ma mb mc md im bi translated">选择排序是一种<strong class="ln iu">就地</strong>排序算法，意味着<em class="me">排序后的</em> <em class="me">项</em>使用与<em class="me">原始元素</em>相同的<em class="me">存储</em>。</p><p id="d4ed" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">要点4展示了选择排序Python实现，详细的<strong class="ln iu">注释</strong>一步步解释了技术<em class="me">。</em></p><p id="a66c" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">外部循环遍历未排序数组的长度，而内部循环在数据集的剩余部分中搜索最小值。然后发生一次交换，用<code class="fe of og oh oi b">min_index</code>项替换<em class="me"> iᵗʰ </em>元素。</p><figure class="ob oc od oe gt nb"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ni nj gj gh gi nk nl bd b be z dk translated">要点Python中的选择排序算法</p></figure><p id="ff2f" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated"><em class="me">选择</em>排序方法一般有以下几种:</p><ul class=""><li id="d124" class="nm nn it ln b lo mf lr mg ky no lc np lg nq md nr ns nt nu bi translated"><em class="me">时间复杂度</em> = <strong class="ln iu"> O(n ) </strong>。从两个嵌套的for循环中可以明显看出n次迭代。</li><li id="e60e" class="nm nn it ln b lo nv lr nw ky nx lc ny lg nz md nr ns nt nu bi translated"><em class="me">空间复杂度</em> = <strong class="ln iu"> O(1) </strong>。如上所述，排序就地进行；因此，内存使用不依赖于处理数据。</li></ul><p id="3ceb" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">图3显示了运行中的算法。</p><figure class="ob oc od oe gt nb gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/ead2e71a60900fe88a192a39771cd2e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*PFbg6PgFh0fGKLdKjQcMWQ.gif"/></div><p class="ni nj gj gh gi nk nl bd b be z dk translated">图3 —选择排序(按作者排序的图片)</p></figure></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="381f" class="kp kq it bd kr ks kt dn ku kv kw dp kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">冒泡排序</h2><p id="bcb9" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt ky lu lv lw lc lx ly lz lg ma mb mc md im bi translated"><em class="me">冒泡</em>或下沉排序反复遍历列表，<em class="me">比较相邻元素</em>。根据分拣条件，物品被<strong class="ln iu">交换</strong>。</p><p id="a649" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">Gist 4展示了选择排序Python实现，详细的<strong class="ln iu">注释</strong>一步步解释了技术<em class="me"/>。</p><figure class="ob oc od oe gt nb"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ni nj gj gh gi nk nl bd b be z dk translated">gist 4—Python中的冒泡排序算法</p></figure><p id="ccce" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">冒泡排序有一个<em class="me">最坏情况</em>和<em class="me">平均值</em>:</p><ul class=""><li id="2473" class="nm nn it ln b lo mf lr mg ky no lc np lg nq md nr ns nt nu bi translated"><em class="me">时间复杂度</em> = <strong class="ln iu"> O(n ) </strong>。<strong class="ln iu"/><strong class="ln iu"/>内<em class="me">循环</em>至少运行<em class="me"> n次</em>。因此，整个操作至少需要n次。</li><li id="4f67" class="nm nn it ln b lo nv lr nw ky nx lc ny lg nz md nr ns nt nu bi translated"><em class="me">空间复杂度</em> = <strong class="ln iu"> O(1) </strong>。N <em class="me">没有额外的内存</em>被利用，因为项目的交换发生在原始数组上。</li></ul><p id="1663" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">当程序执行时，较大的值<em class="me">冒泡</em>到列表的顶部，如图4所示。</p><figure class="ob oc od oe gt nb gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/2b1cc705e35d93a85fb792b39aa57952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*TzvLt6b0QR73ilVEx5GTlA.gif"/></div><p class="ni nj gj gh gi nk nl bd b be z dk translated">图4 —冒泡排序(作者图片)</p></figure></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="c5a8" class="kp kq it bd kr ks kt dn ku kv kw dp kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">插入排序</h2><p id="8c8f" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt ky lu lv lw lc lx ly lz lg ma mb mc md im bi translated"><em class="me">插入</em>排序构建最终数组<em class="me">一次一项</em>。使用Gist 5中提供的代码对未排序的对象数组执行该方法。</p><p id="2eb2" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">在外循环上遇到的每个<em class="me">对象</em><em class="me"/>被放在当前最接近的<strong class="ln iu"/><em class="me">最小</em>和<em class="me">最大</em>元素之间。</p><figure class="ob oc od oe gt nb"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ni nj gj gh gi nk nl bd b be z dk translated">要点Python中的插入排序</p></figure><p id="86b4" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">插入排序有一个最坏的情况:</p><ul class=""><li id="6778" class="nm nn it ln b lo mf lr mg ky no lc np lg nq md nr ns nt nu bi translated"><em class="me">时间复杂度</em> = <strong class="ln iu"> O(n ) </strong>。循环的外<em class="me">运行大约<em class="me"> n </em>次，而</em>循环的内<em class="me">运行大约相同的次数。</em></li><li id="e506" class="nm nn it ln b lo nv lr nw ky nx lc ny lg nz md nr ns nt nu bi translated"><em class="me">空间复杂度</em> = <strong class="ln iu"> O(1) </strong>。操作发生在原始数组上。因此，不需要额外的内存需求。</li></ul><p id="bcc0" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">图5展示了插入排序的实际应用。</p><figure class="ob oc od oe gt nb gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/0a69283a1c5733c8e43c8ce7b1bf16d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*aLR2f08apknZPBZKO9L4qg.gif"/></div><p class="ni nj gj gh gi nk nl bd b be z dk translated">图5 —插入排序(按作者排序的图片)</p></figure></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="830b" class="kp kq it bd kr ks kt dn ku kv kw dp kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">合并排序</h2><p id="4759" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt ky lu lv lw lc lx ly lz lg ma mb mc md im bi translated">合并排序是一种<strong class="ln iu">分治</strong>排序算法。因此，问题<em class="me">将</em>分解成更小的类似<em class="me">子问题</em>，直到一个<em class="me">基础案例</em>被解决。</p><p id="b533" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">拆分未排序的数组，直到获得单个元素的基本情况。然后，在<strong class="ln iu">临时</strong> <strong class="ln iu">数组</strong>之间进行比较，沿着<em class="me">递归堆栈</em>向上移动。</p><figure class="ob oc od oe gt nb"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ni nj gj gh gi nk nl bd b be z dk translated">要点Python中的合并排序</p></figure><p id="fe95" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">合并排序有一个:</p><ul class=""><li id="e683" class="nm nn it ln b lo mf lr mg ky no lc np lg nq md nr ns nt nu bi translated">时间复杂度= <strong class="ln iu"> O(n*log(n)) </strong>。分治排序算法具有这种时间复杂度。⁴这种复杂性是最坏的情况。</li><li id="c5c8" class="nm nn it ln b lo nv lr nw ky nx lc ny lg nz md nr ns nt nu bi translated">空间复杂度= <strong class="ln iu"> O(n) </strong>，表明内存分配的增长不会快于一个<em class="me">常数</em> <em class="me">乘以<em class="me">数据集</em>的大小，即k*N</em></li></ul><figure class="ob oc od oe gt nb gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/f8aeb4f43995d2524c37000bd374f1be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*e8eLFtyam71dUwgTuDckJQ.gif"/></div><p class="ni nj gj gh gi nk nl bd b be z dk translated">图6 —合并排序(按作者排序的图片)</p></figure></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="4800" class="kp kq it bd kr ks kt dn ku kv kw dp kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">快速排序</h2><p id="87f1" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt ky lu lv lw lc lx ly lz lg ma mb mc md im bi translated">Quicksort比它的主要竞争对手merge sort和heapsort快两到三倍。它通常是递归实现的，如Gist 6所示。</p><p id="243d" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated"><strong class="ln iu"> Pivot </strong>值是快速排序算法的核心。本质上，枢轴是在排序数组中它们的<em class="me">正确索引</em>处的值。定位枢轴意味着左边的对象总是较少，而右边的项目比枢轴多。</p><figure class="ob oc od oe gt nb"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ni nj gj gh gi nk nl bd b be z dk translated">要点Python中的快速排序</p></figure><p id="0c0c" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated"><em class="me">递归地</em> <strong class="ln iu">划分</strong>数组，选择中枢点并将它们分配到正确的位置给出最终排序的数组。</p><p id="ba55" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">快速排序有一个<em class="me">平均值</em>:</p><ul class=""><li id="dcc9" class="nm nn it ln b lo mf lr mg ky no lc np lg nq md nr ns nt nu bi translated"><em class="me">时间复杂度</em> = <strong class="ln iu"> O(n*log(n)) </strong>。像归并排序一样，这种表示法是由分而治之或快速排序决定的。一个<em class="me">最坏的情况</em>是O( <strong class="ln iu"> n </strong>)。但是，这仅在数组元素正确升序或降序时发生。</li></ul><p id="e1f2" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">图7显示了快速排序动画。</p><figure class="ob oc od oe gt nb gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/85f1fc5d5e4d5dbd986467a1948ebfc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*wI80xGdW289JzsHKqx0pMw.gif"/></div><p class="ni nj gj gh gi nk nl bd b be z dk translated">图7 —快速排序(作者图片)</p></figure></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="d6cf" class="kp kq it bd kr ks kt dn ku kv kw dp kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">结论</h2><p id="1c82" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt ky lu lv lw lc lx ly lz lg ma mb mc md im bi translated">优化排序在软件开发中至关重要。<strong class="ln iu">具体算法的时间复杂度</strong>会根据项目的<em class="me">初始</em> <em class="me">顺序</em>而<em class="me">不同</em>。然而，<em class="me">假设</em>最坏的情况<strong class="ln iu">是最合适的。</strong></p><p id="3f5f" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">还有许多其他技术没有涉及。一些这样的例子包括<em class="me">堆</em>、<em class="me">基数</em>和心爱的<em class="me"> bogo </em>排序。</p><p id="3a2d" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">本文介绍了五种标准排序算法的Python代码和<strong class="ln iu">可视化。理解这些机制对于计算机科学的学生来说是很有价值的，因为其中一些程序经常出现在<strong class="ln iu">的编码面试中。</strong></strong></p><p id="3955" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">如果你对Python、工程学和数据科学感兴趣，可以看看我的其他文章。</p><div class="oy oz gp gr pa pb"><a href="https://medium.com/codex/python-project-idea-graph-traversal-and-pathfinding-algorithm-visualisations-99595c414293" rel="noopener follow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd iu gy z fp pg fr fs ph fu fw is bi translated">Python中的广度优先搜索、深度优先搜索、Dijakras和A*寻路算法</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">Python中的图遍历和寻路算法可视化</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">medium.com</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp ng pb"/></div></div></a></div><div class="oy oz gp gr pa pb"><a href="https://medium.com/@andrewdaviesul/membership" rel="noopener follow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd iu gy z fp pg fr fs ph fu fw is bi translated">通过我的推荐链接加入媒体-安德鲁·约瑟夫·戴维斯</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">medium.com</p></div></div><div class="pk l"><div class="pq l pm pn po pk pp ng pb"/></div></div></a></div></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="427c" class="kp kq it bd kr ks kt dn ku kv kw dp kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">参考</h2><p id="515e" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt ky lu lv lw lc lx ly lz lg ma mb mc md im bi translated">[1] <a class="ae mu" href="https://xlinux.nist.gov/dads/HTML/inplacesort.html#:~:text=Definition%3A%20A%20sort%20algorithm%20in,known%20as%20sort%20in%20place." rel="noopener ugc nofollow" target="_blank">原地排序</a> —美国国家标准技术研究院<br/>【2】<a class="ae mu" href="https://www.javatpoint.com/quick-sort#:~:text=The%20best%2Dcase%20time%20complexity,O(n*logn)." rel="noopener ugc nofollow" target="_blank">快速排序时间复杂度</a>—Java point<br/>【3】<a class="ae mu" href="https://stackoverflow.com/questions/27663624/what-exactly-does-on-space-complexity-mean-and-how-inefficient-is-it#:~:text=Space%20complexity%20of%20O(n)%20means%20that%20for%20each%20input,than%20linearly%20at%20k*N." rel="noopener ugc nofollow" target="_blank">空间复杂度是什么意思？</a>—stack overflow<br/>【4】<a class="ae mu" href="https://www.bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank">了解你的复杂性！</a> —大O-备忘单</p></div></div>    
</body>
</html>