<html>
<head>
<title>Profiling Machine Learning Algorithms in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python描述机器学习算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/profiling-machine-learning-algorithms-in-python-7d12e0d740f6#2022-05-24">https://towardsdatascience.com/profiling-machine-learning-algorithms-in-python-7d12e0d740f6#2022-05-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="33fe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用于分析机器学习任务的有用工具</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4922449a5d176dd353ad0102982fe673.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g3j5TWu1Vki0dpXd5_dYHQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://www.pexels.com/photo/a-woman-typing-on-keyboard-5473337/" rel="noopener ugc nofollow" target="_blank"> cottonbro </a>在<a class="ae ky" href="https://www.pexels.com/photo/a-woman-typing-on-keyboard-5473337/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄</p></figure><p id="0904" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">概要分析是一项软件工程任务，其中软件瓶颈是通过编程来分析的。这个过程包括分析内存使用情况、函数调用的数量以及这些调用的运行时间。这种分析很重要，因为它提供了一种严格的方法来检测软件程序中可能很慢或资源效率低的部分，最终允许优化软件程序。</p><p id="8941" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">剖析在几乎每种类型的软件程序中都有用例，包括那些用于数据科学和机器学习任务的程序。这包括提取、转换和加载(ETL)以及机器学习模型开发。您可以使用Python中的Pandas库对ETL进行分析，包括分析Pandas操作，如读入数据、合并数据帧、执行groupby操作、类型转换和缺失值插补。</p><p id="bf7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">识别机器学习软件中的瓶颈是我们作为数据科学家工作的重要部分。例如，考虑一个Python脚本，它读入数据并对数据执行若干操作，以进行模型训练和预测。假设机器学习管道中的步骤是读入数据、执行分组、拆分数据以进行训练和测试、拟合三种类型的机器模型、对测试数据的每种模型类型进行预测以及评估模型性能。对于第一个部署的版本，运行时间可能是几分钟。</p><p id="7530" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在数据刷新之后，想象一下脚本的运行时间增加到几个小时。我们如何知道ML管道中的哪一步导致了问题？软件概要分析允许我们检测哪部分代码是负责任的，这样我们就可以修复它。</p><p id="68c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个例子与记忆有关。考虑已部署的机器学习流水线的第一个版本的存储器使用。该脚本可能每月运行一小时，并使用100 GB的内存。未来，在更大的数据集上训练的模型的更新版本，可能每个月运行五个小时，需要500 GB的内存。随着数据集大小的增加，预计资源使用量也会增加。检测这样的增加可能有助于数据科学家和机器学习工程师决定他们是否希望以某种方式优化代码的内存使用。优化有助于防止公司在不必要的内存资源上浪费金钱。</p><p id="d231" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python在运行时和内存方面为分析软件提供了有用的工具。其中最基本和最广泛使用的是timeit方法，它提供了一种简单的方法来测量软件程序的执行时间。Python memory_profile模块允许您测量Python脚本中代码行的内存使用情况。您可以用几行代码轻松实现这两种方法。</p><p id="1a0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用<a class="ae ky" href="https://www.kaggle.com/datasets/mlg-ulb/creditcardfraud" rel="noopener ugc nofollow" target="_blank">信用卡欺诈数据集</a>并建立一个预测交易是否欺诈的机器学习模型。我们将构建一个简单的机器学习管道，并使用Python分析工具来测量运行时和内存使用情况。这些数据拥有<a class="ae ky" href="https://opendatacommons.org/licenses/dbcl/1-0/" rel="noopener ugc nofollow" target="_blank">开放数据库许可证</a>，可以自由共享、修改和使用。</p><p id="9ad0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">准备数据</strong></p><p id="6839" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们导入Pandas库并将我们的数据读入Pandas数据框:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3c27" class="ma mb it lw b gy mc md l me mf">df = pd.read_csv("creditcard.csv")</span></pre><p id="184b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们使用Pandas方法set_option()放宽列和行的显示限制:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9b5e" class="ma mb it lw b gy mc md l me mf">pd.set_option('display.max_columns', None)</span><span id="0ef6" class="ma mb it lw b gy mg md l me mf">pd.set_option('display.max_rows', None)</span></pre><p id="d935" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们使用head()方法显示前五行数据:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6224" class="ma mb it lw b gy mc md l me mf">print(df.head())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/a06b552f2ed35ef24e0ea95a65d7ef37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IZkz_TY_DfcuyM4e"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d78a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，为了了解这个数据集有多大，我们可以使用len方法来查看有多少行:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5581" class="ma mb it lw b gy mc md l me mf">print("Number of rows: ", len(df))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/4125f9562451896a2ee463306580ddd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/0*Ib64v1Do5391edvR"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d93e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以做类似的事情来计算列数。我们可以评估Pandas数据框对象的columns属性，并使用len()方法计算列数:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e26a" class="ma mb it lw b gy mc md l me mf">print("Number of columns: ", len(df.columns))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/fe29539fa2222284dafeb84831fb0de0.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/0*EmU75TowLiV-Y20h"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4bee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到这个数据集比较大:284，807行31列。此外，它占用150 MB的空间。为了展示Python中概要分析的好处，我们将从这个数据的一个小的子样本开始，在这个子样本上我们将执行ETL并训练一个分类模型。</p><p id="5db0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从生成一个小的子样本数据集开始。让我们从我们的数据中随机抽取10，000条记录。我们还将为random_state传递一个值，这将保证我们每次运行脚本时都选择相同的记录集。我们可以在Pandas数据框上使用sample()方法来实现这一点:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c06f" class="ma mb it lw b gy mc md l me mf">df = df.sample(10000, random_state=42)</span></pre><p id="6378" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们可以将数据的子样本写入一个新的csv文件:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3eac" class="ma mb it lw b gy mc md l me mf">df.to_csv("creditcard_subsample10000.csv", index=False)</span></pre><p id="13d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">定义我们的ML管道</strong></p><p id="7042" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以开始构建数据准备和模型训练的逻辑了。让我们定义一个方法，读入我们的csv文件，将它存储在数据帧中并返回它:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="fa19" class="ma mb it lw b gy mc md l me mf">def read_data(filename):<br/>    df = pd.read_csv(filename)<br/>    return df</span></pre><p id="8980" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们定义一个选择数据中列的子集的函数。该函数将数据框和列列表作为输入，并返回包含所选列的新数据框:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0f73" class="ma mb it lw b gy mc md l me mf">def data_prep(dataframe, columns):<br/>    df_select = dataframe[columns]<br/>    return df_select</span></pre><p id="ad55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们定义一个方法，该方法本身定义模型输入和输出，并返回这些值:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b54b" class="ma mb it lw b gy mc md l me mf">def feature_engineering(dataframe, inputs, output):<br/>    X = dataframe[inputs]<br/>    y = dataframe[output]<br/>    return X, y</span></pre><p id="12c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以定义一种方法，用于为训练和测试拆分数据。首先，在脚本的顶部，让我们从Scikit-learn中的model_selection模块导入train_test_split方法:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4509" class="ma mb it lw b gy mc md l me mf">from sklearn.model_selection import train_test_split</span></pre><p id="0602" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以定义拆分数据的方法:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9649" class="ma mb it lw b gy mc md l me mf">def split_data(X, y):<br/>    X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42, test_size = 0.33)<br/>    return X_train, X_test, y_train, y_test</span></pre><p id="7153" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们可以定义一种方法，使我们选择的模型适合我们的训练数据。让我们从一个简单的逻辑回归模型开始。我们可以从Scikit-learn中的线性模型模块导入逻辑回归类:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1d83" class="ma mb it lw b gy mc md l me mf">from sklearn.linear_models import logistic_regression</span></pre><p id="d865" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将定义一个方法，该方法接受我们的训练数据和一个指定模型类型的输入。稍后我们将用于定义和训练更复杂模型的模型类型参数:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3fd6" class="ma mb it lw b gy mc md l me mf">def model_training(X_train, y_train, model_type):<br/>    if model_type == 'Logistic Regression':<br/>        model = LogisticRegression()<br/>        model.fit(X_train, y_train)<br/>    elif model_type == 'CatBoost':<br/>        model = CatBoostClassifier()<br/>        model.fit(X_train, y_train)        <br/>    return model</span></pre><p id="8e45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们可以定义一种方法，将我们训练好的模型和测试数据作为输入，并返回预测:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e979" class="ma mb it lw b gy mc md l me mf">def predict(model, X_test):<br/>    y_pred = model.predict(X_test)<br/>    return y_pred</span></pre><p id="9180" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们定义一个评估我们预测的方法。我们将使用平均精度，这对于不平衡分类问题是一个有用的性能指标。不平衡分类问题是指其中一个目标的实例明显少于其他目标。在这种情况下，大多数交易数据对应于合法交易，而一小部分交易是欺诈性的:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="322a" class="ma mb it lw b gy mc md l me mf">def evaluate(y_pred, y_test):<br/>    precision = average_precision_score(y_test, y_pred)<br/>    print("Precision: ", precision)</span></pre><p id="64fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经为简单的ML管道准备好了所有的逻辑。让我们对数据的小子样执行这个逻辑。首先，让我们定义一个用于执行代码的主函数。在这个主函数中，我们将读入二次抽样数据:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e0c7" class="ma mb it lw b gy mc md l me mf">def main():</span><span id="d292" class="ma mb it lw b gy mg md l me mf">    data = read_data('creditcard_subsample10000.csv')</span></pre><p id="f38d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，使用数据准备方法选择我们的色谱柱。让我们选择V1、V2、V3、金额和等级:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e95d" class="ma mb it lw b gy mc md l me mf">def main():</span><span id="cc56" class="ma mb it lw b gy mg md l me mf">    … # preceding code left out for clarity</span><span id="5c74" class="ma mb it lw b gy mg md l me mf">    columns = ['V1', 'V2', 'V3', 'Amount', 'Class']</span><span id="6615" class="ma mb it lw b gy mg md l me mf">    df_select = data_prep(data, columns)</span></pre><p id="3280" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后让我们定义输入和输出。我们将使用V1、V2、V3和金额作为输入；该类将是输出:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6d7e" class="ma mb it lw b gy mc md l me mf">def main():</span><span id="7112" class="ma mb it lw b gy mg md l me mf">    … # preceding code left out for clarity</span><span id="66f1" class="ma mb it lw b gy mg md l me mf">    inputs = ['V1', 'V2', 'V3']</span><span id="5254" class="ma mb it lw b gy mg md l me mf">    output = 'Class'</span><span id="a323" class="ma mb it lw b gy mg md l me mf">    X, y = feature_engineering(df_select, inputs, output)</span></pre><p id="f0eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将为训练和测试拆分数据:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="97de" class="ma mb it lw b gy mc md l me mf">def main():</span><span id="01ff" class="ma mb it lw b gy mg md l me mf">    … # preceding code left out for clarity</span><span id="5f3d" class="ma mb it lw b gy mg md l me mf">    X_train, X_test, y_train, y_test = split_data(X, y)</span></pre><p id="08ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">符合我们的数据:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2d34" class="ma mb it lw b gy mc md l me mf">def main():</span><span id="0b49" class="ma mb it lw b gy mg md l me mf">    … # preceding code left out for clarity</span><span id="dd40" class="ma mb it lw b gy mg md l me mf">    model_type = ‘Logistic Regression’</span><span id="e5f8" class="ma mb it lw b gy mg md l me mf">    model = model_training(X_train, y_train, model_type)</span></pre><p id="90fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">进行预测:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e526" class="ma mb it lw b gy mc md l me mf">def main():</span><span id="c4a5" class="ma mb it lw b gy mg md l me mf">    … # preceding code left out for clarity</span><span id="9a32" class="ma mb it lw b gy mg md l me mf">    y_pred = predict(model, X_test)</span></pre><p id="0a7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，评估模型预测:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="25d1" class="ma mb it lw b gy mc md l me mf">def main():</span><span id="36f1" class="ma mb it lw b gy mg md l me mf">    … # preceding code left out for clarity</span><span id="78d9" class="ma mb it lw b gy mg md l me mf">    evaluate(y_pred, y_test)</span></pre><p id="15ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以使用以下逻辑执行main函数:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2de3" class="ma mb it lw b gy mc md l me mf">if __name__ == “__main__”:</span><span id="ca9a" class="ma mb it lw b gy mg md l me mf">    main()</span></pre><p id="b894" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/d5b366dc665ddc99fc1d8fd0e07c7e07.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*9lZdKfXU1ZZGOXJu"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="82b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以使用一些分析工具来监控内存使用和运行时。</p><p id="c677" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从监控运行时开始。让我们从python中的timeit模块导入default_timer:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b800" class="ma mb it lw b gy mc md l me mf">from timeit import default_timer as timer</span></pre><p id="3d4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">剖析运行时</strong></p><p id="b8ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们先看看将数据读入Pandas数据帧需要多长时间。我们定义开始和结束时间变量，并打印差值，以查看已经过去的时间:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b63e" class="ma mb it lw b gy mc md l me mf">def main():</span><span id="e9a5" class="ma mb it lw b gy mg md l me mf">    #read in data</span><span id="eca5" class="ma mb it lw b gy mg md l me mf">    start = timer()</span><span id="c10c" class="ma mb it lw b gy mg md l me mf">    data = read_data(‘creditcard_subsample10000.csv’)</span><span id="55f3" class="ma mb it lw b gy mg md l me mf">    end = timer()</span><span id="a66f" class="ma mb it lw b gy mg md l me mf">    print("Reading in data takes: ", end — start)</span><span id="e16b" class="ma mb it lw b gy mg md l me mf">    … # proceeding code left out for clarity</span></pre><p id="3606" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行我们的脚本，我们看到读取数据需要0.06秒:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/b2726a74c17e2d11cfb2344174064df2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/0*b1t0VsAHluYqL0rP"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="a2f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们对ML管道中的每一步做同样的事情。我们将计算每一步的运行时间，并将结果存储在一个字典中:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e404" class="ma mb it lw b gy mc md l me mf">def main():<br/>    runtime_metrics = dict()<br/>    #read in data<br/>    start = timer()<br/>    data = read_data('creditcard.csv')<br/>    end = timer()<br/>    read_time = end - start<br/>    runtime_metrics['read_time'] = read_time<br/>    <br/>    #slect relevant columns<br/>    start = timer()<br/>    columns = ['V1', 'V2', 'V3', 'Amount', 'Class']<br/>    df_select = data_prep(data, columns)<br/>    end = timer()<br/>    select_time = end - start<br/>    runtime_metrics['select_time'] = select_time<br/>    <br/>    <br/>    #define input and output<br/>    start = timer()<br/>    inputs = ['V1', 'V2', 'V3']<br/>    output = 'Class'<br/>    X, y = feature_engineering(df_select, inputs, output)<br/>    end = timer()<br/>    data_prep_time = end - start<br/>    runtime_metrics['data_prep_time'] = data_prep_time<br/>    <br/>    <br/>    #split data for training and testing<br/>    start = timer()<br/>    X_train, X_test, y_train, y_test = split_data(X, y)<br/>    end = timer()<br/>    split_time = end - start<br/>    runtime_metrics['split_time'] = split_time<br/>    <br/>    <br/>    #fit model<br/>    start = timer()<br/>    model_type = 'CatBoost'<br/>    model = model_training(X_train, y_train, model_type)<br/>    end = timer()<br/>    fit_time = end - start<br/>    runtime_metrics['fit_time'] = fit_time<br/>    <br/>    #make predictions<br/>    start = timer()<br/>    y_pred = predict(model, X_test)<br/>    end = timer()<br/>    pred_time = end - start<br/>    runtime_metrics['pred_time'] = pred_time<br/>    <br/>    #evaluate model predictions<br/>    start = timer()<br/>    evaluate(y_pred, y_test)<br/>    end = timer()<br/>    pred_time = end - start<br/>    runtime_metrics['pred_time'] = pred_time<br/>    <br/>    print(runtime_metrics)</span></pre><p id="ce41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行后，我们得到以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mm"><img src="../Images/e77113b70edde348a7f482b55c7a9c41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dtrdppBQj_UwlIfm"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="3166" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到读入数据和拟合数据是最耗时的操作。让我们用大数据集重新运行一遍。在main函数的顶部，我们将文件名改为:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2128" class="ma mb it lw b gy mc md l me mf">data = read_data('creditcard.csv')</span></pre><p id="b223" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们返回我们的脚本:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mm"><img src="../Images/bdd5d28e1f733be07f6c0542ac127ac5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j9FRyh2z_mYbc6uT"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="06bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到，当我们使用完整数据集时，将数据读入数据帧需要1.6秒，相比之下，较小数据集需要0.07秒。识别导致运行时间增加的数据读入步骤对于资源管理非常重要。了解这样的瓶颈来源可以防止公司浪费计算时间等资源。</p><p id="1fd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们修改模型训练方法，使CatBoost成为模型选项:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="77c0" class="ma mb it lw b gy mc md l me mf">from catboost import CatBoostClassifier</span><span id="55e7" class="ma mb it lw b gy mg md l me mf">def model_training(X_train, y_train, model_type):</span><span id="1115" class="ma mb it lw b gy mg md l me mf">    if model_type == ‘Logistic Regression’:</span><span id="a88a" class="ma mb it lw b gy mg md l me mf">        model = LogisticRegression() </span><span id="352d" class="ma mb it lw b gy mg md l me mf">        model.fit(X_train, y_train)</span><span id="f74a" class="ma mb it lw b gy mg md l me mf">    elif model_type == ‘CatBoost’:</span><span id="75a3" class="ma mb it lw b gy mg md l me mf">        model = CatBoostClassifier()</span><span id="5b5d" class="ma mb it lw b gy mg md l me mf">        model.fit(X_train, y_train)</span><span id="207c" class="ma mb it lw b gy mg md l me mf">    return model</span></pre><p id="12e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们重新运行我们的脚本，但是现在指定一个CatBoost模型:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="28c1" class="ma mb it lw b gy mc md l me mf">def main():</span><span id="142b" class="ma mb it lw b gy mg md l me mf">    …</span><span id="cc0b" class="ma mb it lw b gy mg md l me mf">    #fit model</span><span id="a28b" class="ma mb it lw b gy mg md l me mf">    start = timer()</span><span id="d5fd" class="ma mb it lw b gy mg md l me mf">    model_type = 'CatBoost'</span><span id="7262" class="ma mb it lw b gy mg md l me mf">    model = model_training(X_train, y_train, model_type)</span><span id="af8a" class="ma mb it lw b gy mg md l me mf">    end = timer()</span><span id="f477" class="ma mb it lw b gy mg md l me mf">    fit_time = end — start</span><span id="7fbd" class="ma mb it lw b gy mg md l me mf">    runtime_metrics[‘fit_time’] = fit_time</span></pre><p id="febf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mm"><img src="../Images/d94b7eb36b9cf652f3b6ec5918e24bda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bVPBSL0wR5Meh_VQ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8c91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到，通过使用CatBoost模型而不是逻辑回归，我们将运行时间从大约2秒增加到大约22秒，这在运行时间上增加了10倍以上，因为我们更改了一行代码。想象一下，如果运行时间的增加发生在原本需要10个小时的脚本上:仅仅通过切换模型类型，运行时间就会增加到超过100个小时。</p><p id="d097" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">分析内存使用情况</strong></p><p id="694d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个需要跟踪的重要资源是内存。我们可以使用memory_usage模块在代码中逐行监控内存使用情况。首先，让我们使用pip在终端中安装memory_usage模块:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f697" class="ma mb it lw b gy mc md l me mf">pip install memory_profiler</span></pre><p id="2a69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以简单地在每个函数定义前添加@profiler。例如:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c1a5" class="ma mb it lw b gy mc md l me mf">@profile<br/>def read_data(filename):<br/>    df = pd.read_csv(filename)<br/>    return df</span><span id="8491" class="ma mb it lw b gy mg md l me mf">@profile<br/>def data_prep(dataframe, columns):<br/>    df_select = dataframe[columns]<br/>    return df_select</span></pre><p id="a7f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">诸如此类。</p><p id="c26e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们使用逻辑回归模型类型运行我们的脚本。让我们看看我们拟合模型的步骤。我们看到，用于拟合我们的逻辑回归模型的内存使用量约为4.4 MB(第61行):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/66e48a7c4a6e4b27b5e7c2ab8ad25c3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j2EaKVWHPb0aSo6L"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="06c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们为CatBoost重新运行这个:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/1789798693d90ea96920bbecff4eabf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3Q3VBNcQzinhUQDv"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4ebd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到拟合逻辑回归模型的内存使用量是13.3 MB(第64行)。这相当于内存使用量增加了三倍。对于我们这个简单的例子，这并不是什么大问题，但是如果一家公司部署了一个新版本的产品，并且它从使用100 GB的内存增加到300 GB，这在资源成本方面可能是很大的。此外，拥有这样的工具可以指出哪里出现了内存使用的增加是非常有用的。</p><p id="9ddd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章中使用的代码可以在<a class="ae ky" href="https://github.com/spierre91/builtiin/blob/main/python_profiling_tutorial.py" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><p id="2e3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">结论</strong></p><p id="33e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">监控资源使用是软件、数据和机器学习工程的重要组成部分。不管应用程序是什么，理解脚本中的运行时依赖性在几乎所有依赖软件开发和维护的行业中都是非常重要的。在新部署的机器学习模型的情况下，运行时间的增加会对业务产生负面影响。生产运行时间的显著增加会导致提供实时机器学习预测的应用程序的用户体验降低。</p><p id="6a4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果UX要求用户不应该为预测结果等待超过几秒钟，而这突然增加到几分钟，这可能会导致客户沮丧，他们最终可能会寻找更好/更快的工具。</p><p id="d3e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">了解内存使用情况也很重要，因为可能会出现不必要过度使用内存的情况。这种使用可以转化为在不必要的内存资源上浪费数千美元。考虑我们将逻辑回归模型转换为CatBoost模型的例子。导致内存使用增加的主要原因是CatBoost包的默认参数。这些默认参数可能会导致包执行不必要的计算。</p><p id="74d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过理解这种动态，研究人员可以修改CatBoost类的参数。如果做得好，研究人员可以保持模型的准确性，同时减少拟合模型所需的内存。对于构建生产就绪软件的工程师和数据科学家来说，使用这些分析工具快速识别内存和运行时瓶颈是一项基本技能。</p><p id="a50d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有兴趣学习python编程的基础知识、Pandas的数据操作以及python中的机器学习，请查看<a class="ae ky" href="https://www.amazon.com/dp/B08N38XW2Q/ref=sr_1_1?dchild=1&amp;keywords=sadrach+python&amp;qid=1604966500&amp;s=books&amp;sr=1-1" rel="noopener ugc nofollow" target="_blank"><em class="mp">Python for Data Science and Machine Learning:Python编程、Pandas和sci kit-初学者学习教程</em> </a> <em class="mp">。我希望你觉得这篇文章有用/有趣。</em></p><p id="bcb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="mp">本帖原载于</em> </strong> <a class="ae ky" href="https://builtin.com/data-science/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="mp">内置博客</em> </strong> </a> <strong class="lb iu"> <em class="mp">。原片可以在这里找到</em></strong><a class="ae ky" href="https://builtin.com/data-science/python-profiling-tools-tutorial" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"><em class="mp"/></strong></a><strong class="lb iu"><em class="mp">。</em>T29】</strong></p></div></div>    
</body>
</html>