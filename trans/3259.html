<html>
<head>
<title>Rolling Windows in NumPy — The Backbone of Time Series Analytical Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NumPy中的滚动窗口——时间序列分析方法的支柱</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/rolling-windows-in-numpy-the-backbone-of-time-series-analytical-methods-bc2f79ba82d2#2022-07-20">https://towardsdatascience.com/rolling-windows-in-numpy-the-backbone-of-time-series-analytical-methods-bc2f79ba82d2#2022-07-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2859" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">NumPy中的滚动(滑动)窗口计算是如何工作的？它们和熊猫打滚相比如何？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bc99b2cba9cddd17494686d51081a36d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uU81arJnhysPkBfYdVmGHw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</p></figure><p id="5da6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">滚动或滑动计算在时间序列分析中至关重要。从金融到流行病分析，很可能你需要执行移动窗口计算，所以学会如何做并做好它们是至关重要的。</p><p id="41f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个故事还将探索NumPy中滚动计算的基础及其局限性；它还将包括一些日常用例的配方。</p><p id="7dfa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Pandas中，执行滚动计算非常简单，也许比NumPy更简单。在NumPy中，执行这个任务的实用程序有些隐藏；也许这就是为什么在时间序列滚动中很少看到NumPy代码的原因。</p><p id="03b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个自然的问题出现了:如果我们可以很容易地在熊猫身上做到这一点，为什么要使用NumPy？在这个故事中，我们将比较熊猫和NumPy的滚动窗口。我喜欢熊猫，但有时我们需要更深入地了解NumPy，以便更精细地处理数据。</p><p id="f807" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Pandas和NumPy中，对向量(1D数组)进行滚动计算非常简单，但是对矩阵进行滚动计算更具挑战性；这就是为什么我们需要NumPy的粒度。</p><h2 id="7d4b" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">故事结构</h2><ul class=""><li id="e8ab" class="mn mo it la b lb mp le mq lh mr ll ms lp mt lt mu mv mw mx bi translated">滑动窗口-&gt;添加额外维度</li><li id="8452" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">For循环与NumPy</li><li id="7cab" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">滚动阵列存储器配置文件</li><li id="ea78" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">函数:1D数组-&gt;标量</li><li id="a23e" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">功能:多个1D阵列-&gt; 1D阵列</li><li id="0012" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">熊猫大战熊猫</li><li id="58c2" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">2D阵列中的滚动函数</li><li id="1ee6" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">多元回归的滚动最小二乘系数</li><li id="f13f" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">多元回归的滚动最小二乘R-squared</li><li id="7408" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">2D阵列的滚动线性组合</li><li id="6436" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">这个故事的寓意</li></ul><h2 id="3461" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">滑动窗口-&gt;添加额外维度</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/0e1a2a2a9b037d94bf3f44d9c8e2ac50.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*bESjSnmsi8xEf-U_qvuqFA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">滚动机制[图片由作者提供]。</p></figure><p id="aa30" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">NumPy的滚动窗口解决方案是创建另一个具有额外维度的数组。这种数组包含附加轴的每个索引上的指定滑动窗口处的滚动原始数组。这个工具有些隐蔽，你可以通过导入中的<br/>点的数量来判断:</p><p id="cd31" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ne nf ng nh b">np.lib.stride_tricks.sliding_window_view</code></p><p id="5fd5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，让我们创建一个包含1000个元素的1D数组:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><blockquote class="nk nl nm"><p id="f4f8" class="ky kz nn la b lb lc ju ld le lf jx lg no li lj lk np lm ln lo nq lq lr ls lt im bi">(1000,)</p></blockquote><p id="686e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们用100的窗口滚动它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><blockquote class="nk nl nm"><p id="fa70" class="ky kz nn la b lb lc ju ld le lf jx lg no li lj lk np lm ln lo nq lq lr ls lt im bi">(901, 100)</p></blockquote><p id="4a08" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，形状的维度增加了一，这个新维度的大小正好是窗口的大小。</p><p id="41c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于维数更高的数组也是如此，例如，对于具有1，000行10列的2D数组:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><blockquote class="nk nl nm"><p id="b53f" class="ky kz nn la b lb lc ju ld le lf jx lg no li lj lk np lm ln lo nq lq lr ls lt im bi">(1000, 10)</p></blockquote><p id="d6c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们沿着行滚动它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><blockquote class="nk nl nm"><p id="3454" class="ky kz nn la b lb lc ju ld le lf jx lg no li lj lk np lm ln lo nq lq lr ls lt im bi">(901, 10, 100)</p></blockquote><h2 id="1b59" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">For循环与NumPy</h2><p id="de57" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">由于滑动(滚动)计算在按时间索引的过程中最有用，首先想到的编程控制流语句是<code class="fe ne nf ng nh b">for</code>循环。</p><p id="de59" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">NumPy以其相对于纯Python的性能而闻名。因此，让我们比较一下使用<code class="fe ne nf ng nh b">for</code>循环和NumPy的<code class="fe ne nf ng nh b">sliding_window_view</code>循环通过滚动回顾窗口遍历数组所需的时间:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><blockquote class="nk nl nm"><p id="9691" class="ky kz nn la b lb lc ju ld le lf jx lg no li lj lk np lm ln lo nq lq lr ls lt im bi translated">每圈37.2秒±4.06秒(平均标准偏差。戴夫。7次运行，每次10，000个循环)</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><blockquote class="nk nl nm"><p id="981e" class="ky kz nn la b lb lc ju ld le lf jx lg no li lj lk np lm ln lo nq lq lr ls lt im bi translated">每圈297s±14.2s(平均标准偏差。戴夫。7次运行，每次1000个循环)</p></blockquote><p id="be37" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">众所周知，如果使用得当，NumPy至少比Python快一个数量级。这次考试也不例外。</p><h2 id="e6f8" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">滚动阵列存储器配置文件</h2><p id="3980" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">一个自然的问题出现了:</p><p id="f1dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果一个额外的维度被添加到滚动窗口大小的数组中，这难道不是内存效率很低吗？</p><p id="5949" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">答案是否定的，因为新数组实际上是原始数组的视图；因此，内存中没有副本。</p><p id="58f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们创建两个数组，并检查它们是否共享内存</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><blockquote class="nk nl nm"><p id="b7cd" class="ky kz nn la b lb lc ju ld le lf jx lg no li lj lk np lm ln lo nq lq lr ls lt im bi translated">真实的</p></blockquote><p id="283d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，他们有。</p><p id="519b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，新的滚动数组的内存使用量稍高，因为为<code class="fe ne nf ng nh b">view</code>本身创建了一些新数据。但是内存使用率高多少呢？</p><p id="5887" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们使用Pympler内存分析器编写一个小测试。我们将通过参数<code class="fe ne nf ng nh b">size_lb</code>(数组大小下限)<code class="fe ne nf ng nh b">size_hb</code>(数组大小上限)和<code class="fe ne nf ng nh b">size_steps</code>来改变原始数组的大小，以控制试验的次数。窗口的大小通过<code class="fe ne nf ng nh b">window </code>参数指定:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="64db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">返回的<code class="fe ne nf ng nh b">dataclass</code>具有每个大小的数组内存使用量和滚动数组使用量。结果总结在下面的内存使用率图中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/2cd80bbba8baf4d3c8e5fa86ce30e05b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V4ha52V3xNiNnJw114S17A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">内存比率图:滚动数组/原始数组[图片由作者提供]。</p></figure><p id="410e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到，对于较小的阵列，滚动阵列视图的开销很大，但随着阵列变大，它会收敛到1。</p><h2 id="3c1f" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">函数:1D数组-&gt;标量</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/0bd0e782c8b866d128525180e85013e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*9Q24PPe6XYWmsRCmxjrbcQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个函数:1D数组-&gt; float，当滚动时产生另一个1D数组。</p></figure><p id="32fe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在1D数组中执行滚动计算是最简单的情况。直觉上，我们希望映射一个函数，它接受回看数组并返回一个标量；这样，一个新的1D阵列就产生了。新数组的长度为:</p><blockquote class="nw"><p id="62fa" class="nx ny it bd nz oa ob oc od oe of lt dk translated">原始数组的长度—窗口大小+ 1</p></blockquote><p id="4841" class="pw-post-body-paragraph ky kz it la b lb og ju ld le oh jx lg lh oi lj lk ll oj ln lo lp ok lr ls lt im bi translated">一旦我们有了滚动数组(有了额外的维度)，我们需要沿着最后一个轴(滚动轴)应用一个NumPy函数；为此，我们有两个选择:</p><ul class=""><li id="2197" class="mn mo it la b lb lc le lf lh ol ll om lp on lt mu mv mw mx bi translated">使用NumPy内置函数</li><li id="fd0a" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">在滚动轴中使用带有<code class="fe ne nf ng nh b">reduce</code>方法的数字<code class="fe ne nf ng nh b">ufunc</code></li></ul><p id="54ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想了解更多关于<code class="fe ne nf ng nh b">ufuncs</code>和如何创建你自己的真正矢量化<code class="fe ne nf ng nh b">ufuncs</code>的信息，请查看<a class="ae oo" rel="noopener" target="_blank" href="/numpy-ufuncs-the-magic-behind-vectorized-functions-8cc3ba56aa2c">这个故事</a>。</p><p id="a5e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">计算过程中使用的函数必须针对数组进行优化；这是利用NumPy性能的唯一方法。使用NumPy的实用程序如<code class="fe ne nf ng nh b">apply_along_axis</code>不会导致性能提升。</p><p id="9f7c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个简单的例子是计算滚动标准差。让我们首先用标准正态分布的样本创建一个数组，然后滚动该数组。我们可以保持生成的数组不变，或者回填缺失的索引:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/adadf3a264b02848c678690c417c34a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZegR98u0odv_QmSlWSLx3w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</p></figure><h2 id="119f" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">功能:多个1D阵列-&gt; 1D阵列</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/1a114f4338b2530c7dd1f635a00eb682.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_DgkTllZg2kekTxtho4IPg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个函数:2D数组(多个1D数组)-&gt; 1D数组(多个浮点数)，当滚动时产生另一个2D数组。</p></figure><p id="b4d4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们也可以同时对多个向量进行滚动计算。这些向量可以排列成2D阵列，但是滚动计算本身不在滚动矩阵<em class="nn">上。所有列(行)都以同样的方式处理；在适当的矩阵卷上，列(行)索引之间没有区别。这就是矢量化的工作原理。</em></p><p id="95ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，我们可以用标准正态样本创建一个2D数组(每列一个过程),然后一次性计算所有列的滚动标准偏差:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/dea90c46dfbe366ec8a74e7163d094cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wrc4TjEZNAZfDVDs7yaaSA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</p></figure><p id="2ff9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实证明，适当的矩阵滚动，即我们可以以特定的方式组合列(行)，要复杂得多，我们将在后面的章节中看到。</p><h2 id="5c0e" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">熊猫大战熊猫</h2><p id="3b75" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">Pandas有一个非常方便的滚动序列和数据帧的方法。我发现它比NumPy的更直观，更容易使用。但正如我们将看到的，它也有缺点。</p><p id="d781" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就速度而言，熊猫滚动和NumPy相比如何？让我们计算滚动标准偏差并找出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><blockquote class="nk nl nm"><p id="12d3" class="ky kz nn la b lb lc ju ld le lf jx lg no li lj lk np lm ln lo nq lq lr ls lt im bi translated">每圈258s±20.7s(平均标准偏差。戴夫。7次运行，每次1000个循环)</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><blockquote class="nk nl nm"><p id="5a9e" class="ky kz nn la b lb lc ju ld le lf jx lg no li lj lk np lm ln lo nq lq lr ls lt im bi translated">每圈262s±8.16s(平均标准偏差。戴夫。7次运行，每次1000个循环)</p></blockquote><p id="e495" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如你所见，速度性能都差不多。因此，对于内置计算来说，这是一个平局。</p><p id="9e58" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们想应用一个自定义函数呢？我们可以在pandas中使用<code class="fe ne nf ng nh b">apply</code>方法，在NumPy中使用<code class="fe ne nf ng nh b">apply_along_axis</code>方法来使用我们的函数，该函数接受一个1D数组(序列)并返回一个浮点数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><blockquote class="nk nl nm"><p id="87ac" class="ky kz nn la b lb lc ju ld le lf jx lg no li lj lk np lm ln lo nq lq lr ls lt im bi translated">每循环5.31毫秒386秒(平均标准偏差戴夫。7次运行，每次100个循环)</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><blockquote class="nk nl nm"><p id="8f36" class="ky kz nn la b lb lc ju ld le lf jx lg no li lj lk np lm ln lo nq lq lr ls lt im bi translated">每循环6.64毫秒693秒(平均标准时间。戴夫。7次运行，每次100个循环)</p></blockquote><p id="a410" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，它们在速度上不相上下。</p><p id="a347" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是最后一个测试有一个警告；在使用NumPy时，如果可以的话，我们应该避免使用<code class="fe ne nf ng nh b">apply_along_axis</code>，因为它没有针对速度进行优化。为了释放NumPy的性能，我们需要在滚动数组中使用的函数下，使用编译的、真正的矢量化、<code class="fe ne nf ng nh b">ufuncs</code>。查看<a class="ae oo" rel="noopener" target="_blank" href="/numpy-ufuncs-the-magic-behind-vectorized-functions-8cc3ba56aa2c">这个故事</a>来了解关于<code class="fe ne nf ng nh b">ufuncs</code>的一切。</p><p id="3678" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，如果我们以矢量化的方式进行相同的计算:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><blockquote class="nk nl nm"><p id="3043" class="ky kz nn la b lb lc ju ld le lf jx lg no li lj lk np lm ln lo nq lq lr ls lt im bi translated">每圈79.8秒±3.77秒(平均标准偏差。戴夫。7次运行，每次10，000个循环)</p></blockquote><p id="2444" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">令人印象深刻的提升。</p><p id="680f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以争辩说，我们可以在Pandas中应用编译的矢量化函数和<code class="fe ne nf ng nh b">ufuncs </code>。然而，在熊猫滚动的工作流程中迷路更容易。经常会混淆什么是矢量化(快速性能)，什么不是矢量化(慢速)。NumPy说得很清楚。</p><p id="c99f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">NumPy提供的只是一个额外维度的滚动数组视图，我们可以根据自己的需要使用这样的数组。如果您正在进行非向量化操作或在NumPy数组上使用for循环，您知道这样做是在自担风险。</p><h2 id="0d0a" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">2D阵列中的滚动函数</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/39dd4116921e68d2d5c72118c67ca341.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*-lAmqGa15xt944QXP0gxaA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将2D数组滚动到标量中[图片由作者提供]。</p></figure><p id="f978" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我们前面指出的，滚动矩阵(2D阵列)是棘手的。在NumPy或Pandas中，对滚动矩阵应用用户定义的函数没有简单的解决方案。如前一节所述，同时滚动多个1D阵列(技术上是2D阵列)与滚动一个矩阵不同。</p><p id="53ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">滚动矩阵的一个示例是对多个回归变量(具有多个列的矩阵)执行滚动最小二乘回归，并对每个行索引(可以将此轴视为时间)获取R平方度量或所有回归变量系数。我经常面临的问题。在前一种情况下，2D数组在滚动时会产生1D数组，而在后一种情况下，2D数组在滚动时会创建另一个2D数组。</p><p id="cab0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有很多方法可以做到这一点，但是没有一个通用的T2解决方案。没有任何方法可以应用一个任意的、可能是纯Python函数，并期望它能够工作并且很快。相反，我们需要能够产生一种算法，该算法可以利用一个或多个编译和矢量化的操作来操纵滚动数组。通常，除了NumPy的工具之外，还需要一些数学知识。</p><p id="3a96" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下面的部分中，我们将回顾一些我经常使用的滚动2D阵列的配方。</p><h2 id="6acf" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">多元回归的滚动最小二乘系数</h2><p id="9f34" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">要做滚动最小二乘回归，我们首先需要知道矩阵形式的数学。以下形式的线性模型:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/c056753ff3c1a2e211582a46f1c58e91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pxMGtf1ULE-dL-vH2Onpow@2x.jpeg"/></div></div></figure><p id="5a2f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中<em class="nn"> ε </em>为内径，可通过<em class="nn"> y </em>和<em class="nn"> x </em>的多个样本进行拟合。考虑所有样本可得出模型规格的矩阵方程:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/3cace4ac7dfc21cb6f745e350cedec23.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*99XtWPJ1t09ikkgxCWpk9Q@2x.jpeg"/></div></figure><p id="e761" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中<em class="nn"> y，β </em>和<em class="nn"> ε </em>是大小等于样本大小的列向量，<em class="nn"> T </em>上标表示转置。<em class="nn"> X </em>是一个有<em class="nn"> n </em>列的矩阵，行数等于样本大小。如果我们想包含一个不为零的截距，矩阵<em class="nn"> X </em>的第一列中有1。</p><p id="4770" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么<em class="nn"> β </em>的OLS(普通最小二乘法)估计为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/ec00b9e94a5c6defba9acaa4b852b551.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*b6sVnAPo5_yYFXK3kHyJCQ@2x.jpeg"/></div></figure><p id="d5aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">利用这个方程，我们可以进行适当的矢量化滚动。但是首先，让我们用最简单的方法，使用一个<code class="fe ne nf ng nh b">for</code>循环来滚动。然后我们将实现矢量化版本并比较性能。</p><p id="2ecb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的玩具数据将是1，000 x 10个标准正态样本的数组:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/ccae90f961109ba0b864de4b9a1f6d1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5jsf3WfSKmQdxC07QGgo5g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</p></figure><p id="809f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要应用的在滑动窗口的每个索引处获得<em class="nn"> β </em>的函数是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="95c5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们使用一个<code class="fe ne nf ng nh b">for</code>循环编写一个通用滚动代码，该循环使用一个<code class="fe ne nf ng nh b">Func4Loop</code>类型的静态函数进行滚动:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="614e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们传递我们的函数，我们可以创建一个矩阵，其中每一行都是一个<em class="nn"> β </em>向量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="7aab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们实现矢量化版本。它比<code class="fe ne nf ng nh b">for</code>循环稍微复杂一点，但是值得努力。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><ul class=""><li id="180d" class="mn mo it la b lb lc le lf lh ol ll om lp on lt mu mv mw mx bi translated">如果需要，第一个函数<code class="fe ne nf ng nh b">_get_X_n_y_rolled</code>将一个常数加到<em class="nn"> X </em>上，并生成滚动阵列视图。</li><li id="56a2" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">第二个函数<code class="fe ne nf ng nh b">_get_beta_vec_from_Xy</code>通过<code class="fe ne nf ng nh b">np.einsum</code>执行滚动矩阵乘法，对产品进行粒度控制，<em class="nn"> t </em>轴(第一个轴)保留在所有产品中。</li><li id="7008" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">最后一个函数只是合并了前面函数的逻辑。</li></ul><p id="7480" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">调用我们的函数，我们创建我们的滚动<em class="nn"> β </em>矩阵，向量化:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="c2b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">两种方法产生相同的结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><blockquote class="nk nl nm"><p id="29e6" class="ky kz nn la b lb lc ju ld le lf jx lg no li lj lk np lm ln lo nq lq lr ls lt im bi translated">真实的</p></blockquote><p id="1d1b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管有一些微小的数字差异。</p><p id="62db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好的部分来了，让我们测试一下速度:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><blockquote class="nk nl nm"><p id="8d62" class="ky kz nn la b lb lc ju ld le lf jx lg no li lj lk np lm ln lo nq lq lr ls lt im bi translated">每循环314毫秒±141毫秒(平均标准时间。戴夫。7次运行，每次1个循环)</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><blockquote class="nk nl nm"><p id="3e5e" class="ky kz nn la b lb lc ju ld le lf jx lg no li lj lk np lm ln lo nq lq lr ls lt im bi translated">每循环56.4毫秒±2.48毫秒(平均标准时间戴夫。7次运行，每次10个循环)</p></blockquote><p id="6a86" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">矢量化版本确实值得努力。</p><h2 id="0f16" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">多元回归的滚动最小二乘R-squared</h2><p id="c0a1" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">获得滚动R平方需要更多的数学知识。请记住，该指标可以表示为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/83e2407cc3d167435d9c10649c122f34.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*yhtYbRHyskFq-cUqSkonTA@2x.jpeg"/></div></figure><p id="5413" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中<strong class="la iu"> <em class="nn"> y_c </em> </strong>是居中的<strong class="la iu"><em class="nn"/></strong>y矢量【贬低】，矢量<strong class="la iu"> <em class="nn"> e </em> </strong>是剩余矢量:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/92397f753765f62616b8182b57200d09.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*lhUUdTZ1kesZ8-jAudY1Eg@2x.jpeg"/></div></figure><p id="d1f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">和上一节一样，我们首先用一个<code class="fe ne nf ng nh b">for</code>循环开始滚动。也就是说，我们定义了在循环的每次迭代中应用的静态函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="a0a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">借用上一节中的<code class="fe ne nf ng nh b">get_rolling_func_loop</code>，我们计算滚动R平方:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="2a72" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于矢量化版本，我们还借用了上一节中的函数<code class="fe ne nf ng nh b">_get_X_n_y_rolled</code>和<code class="fe ne nf ng nh b">_get_beta_vec_from_Xy</code>。像上一节一样，我们使用<code class="fe ne nf ng nh b">np.einsum</code>进行滚动矩阵乘法来保留第一个轴(即<em class="nn"> t </em>轴)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="1ff9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，两种计算是等效的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><blockquote class="nk nl nm"><p id="5899" class="ky kz nn la b lb lc ju ld le lf jx lg no li lj lk np lm ln lo nq lq lr ls lt im bi translated">真实的</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/6701ac8715709ef9482c3758eaf55324.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OpvSJIEBxC12KZkao0lmkQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</p></figure><p id="0f7d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">和速度:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><blockquote class="nk nl nm"><p id="5051" class="ky kz nn la b lb lc ju ld le lf jx lg no li lj lk np lm ln lo nq lq lr ls lt im bi translated">每循环958毫秒397毫秒(平均标准时间。戴夫。7次运行，每次1个循环)</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><blockquote class="nk nl nm"><p id="b49e" class="ky kz nn la b lb lc ju ld le lf jx lg no li lj lk np lm ln lo nq lq lr ls lt im bi translated">每循环73.7毫秒±2.11毫秒(平均值±标准偏差戴夫。7次运行，每次10个循环)</p></blockquote><p id="901b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">和往常一样，矢量化版本不会让人失望。</p><h2 id="bb34" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">2D阵列的滚动线性组合</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/02cccaa7ca79cac3b98af32c8d9294bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IJbu_eD4rzjwwhsPfc3PuA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">2D阵列的滚动线性组合(按列排列)。</p></figure><p id="7874" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我想和大家分享的最后一个配方是滚动线性组合。这在时间序列分析中对向量进行协整时非常有用。</p><p id="0ff4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在每个时间点，我们都有一个权重向量(<code class="fe ne nf ng nh b">w_vec</code>)，形成多个时间序列的线性组合。所以实际上，我们有两个列数相同的矩阵，一个用于权重(<code class="fe ne nf ng nh b">w_mat</code>)，另一个用于时间序列(每列一个序列)。</p><p id="8c78" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每一个<code class="fe ne nf ng nh b">w_vec</code>都是在一个使用回顾窗口的协整设置中找到的。因此，滚动线性组合允许我们分析协整向量算法的演变。</p><p id="a13c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于我们的玩具数据，我们创建了一个数组(<code class="fe ne nf ng nh b">a )</code>包含时间序列，<code class="fe ne nf ng nh b">w_mat,</code>包含线性组合系数(列的索引对应于<code class="fe ne nf ng nh b">a 's</code>列)。</p><p id="8c07" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们创建滚动数组(<code class="fe ne nf ng nh b">a_rolled</code>)并执行乘积(<code class="fe ne nf ng nh b">a_prod_w_rolled</code>)。这个产品是2D的；每行包含滚动线性组合时间序列:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="8987" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们可以对最后一个轴应用一个函数；我们使用标准偏差进行演示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/8e0563720255dd4e3f82fb4b5feafc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dWyjkvWhMf2xkk2ewrvaeQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由autor提供。</p></figure><p id="533a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">说清楚。该函数适用于随时间变化的系数和过程的滚动线性组合。</p><h2 id="b485" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">这个故事的寓意</h2><p id="a967" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">这个故事没有单一的寓意，而是有四个:</p><ul class=""><li id="0c90" class="mn mo it la b lb lc le lf lh ol ll om lp on lt mu mv mw mx bi translated">没有什么神奇的方法可以应用一个通用函数来执行快速的矢量化滚动计算，尤其是当我们滚动2D数组并且列(行)的顺序很重要的时候。我们需要停下来，设计一种算法，能够利用矢量化代码的性能，实现我们的功能目标。</li><li id="9fe8" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">有时NumPy提供了熊猫所缺乏的粒度。</li><li id="8ee0" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">使用NumPy时，一定要注意不要把编译(矢量化和优化)的代码和纯Python代码混在一起；否则，我们的性能会受到影响。如果我们必须这样做，界限应该尽可能的清晰。</li><li id="1394" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">当您需要在阵列之间定制产品时，请使用<code class="fe ne nf ng nh b">np.einsum</code>。</li></ul></div><div class="ab cl pb pc hx pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="im in io ip iq"><p id="ddb0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望这个故事对你有用。 <a class="ae oo" href="https://medium.com/subscribe/@diego-barba" rel="noopener"> <em class="nn">订阅</em> </a> <em class="nn">到我的邮件列表如果你想知道更多这样的故事。</em></p><p id="9026" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">喜欢这个故事吗？通过我下面的推荐链接成为一个媒体成员来支持我的写作。无限制地访问我的故事和许多其他内容。</p><div class="pi pj gp gr pk pl"><a href="https://medium.com/@diego-barba/membership" rel="noopener follow" target="_blank"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd iu gy z fp pq fr fs pr fu fw is bi translated">通过我的推荐链接加入Medium-Diego Barba</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">阅读迭戈·巴尔巴(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">medium.com</p></div></div><div class="pu l"><div class="pv l pw px py pu pz ks pl"/></div></div></a></div></div></div>    
</body>
</html>