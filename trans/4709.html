<html>
<head>
<title>Three Critical Elements of Data Preprocessing — Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据预处理的三个关键要素—第3部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/three-critical-elements-of-data-preprocessing-part-3-6a7da681ae16#2022-10-19">https://towardsdatascience.com/three-critical-elements-of-data-preprocessing-part-3-6a7da681ae16#2022-10-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5fd5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">数据科学中建模的主干。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7f3cdff788520d10c9bef63dda61042e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4YPXAvfxqi7jcL75"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯·劳顿在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="4733" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将讨论数据转换，这是数据科学项目生命周期中数据预处理步骤的一个关键元素。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl lv"><img src="../Images/27cf5b0922fcd2866861c277aaa8f414.png" data-original-src="https://miro.medium.com/v2/format:webp/1*68QtVs-0kgPpiOZDN4dSjA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="68ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据预处理是将来自不同来源的原始数据转换成可用于获得可操作见解的精炼形式的过程。它需要整合、清理和改造。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/7c821e81d2aafd675c4d7a1fff9c3c4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*68dPokoI75z04mKbw7KvLA.png"/></div></div></figure><p id="2101" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本系列的第1部分中，我们讨论了数据集成，将不同来源的数据组合起来，获得一个包含所有可用相关特性和示例(如沙拉碗)的数据集😊。详情如下:</p><div class="lx ly gp gr lz ma"><a rel="noopener follow" target="_blank" href="/three-critical-elements-of-data-preprocessing-part-1-3c16f46f8ced"><div class="mb ab fo"><div class="mc ab md cl cj me"><h2 class="bd iu gy z fp mf fr fs mg fu fw is bi translated">数据预处理的三个关键要素—第1部分</h2><div class="mh l"><h3 class="bd b gy z fp mf fr fs mg fu fw dk translated">数据科学中建模的主干。</h3></div><div class="mi l"><p class="bd b dl z fp mf fr fs mg fu fw dk translated">towardsdatascience.com</p></div></div><div class="mj l"><div class="mk l ml mm mn mj mo ks ma"/></div></div></a></div><p id="0e28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随后，我们探讨了数据清理，即在收集的数据集中查找和修复重复、损坏和丢失的数据的过程。详情可在此处找到:</p><div class="lx ly gp gr lz ma"><a rel="noopener follow" target="_blank" href="/three-critical-elements-of-data-preprocessing-part-2-2078110ae8e7"><div class="mb ab fo"><div class="mc ab md cl cj me"><h2 class="bd iu gy z fp mf fr fs mg fu fw is bi translated">数据预处理的三个关键要素—第2部分</h2><div class="mh l"><h3 class="bd b gy z fp mf fr fs mg fu fw dk translated">数据科学中建模的主干。</h3></div><div class="mi l"><p class="bd b dl z fp mf fr fs mg fu fw dk translated">towardsdatascience.com</p></div></div><div class="mj l"><div class="mp l ml mm mn mj mo ks ma"/></div></div></a></div><p id="1ec3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我将从数据科学中建模的角度介绍数据预处理难题的最后一部分，即数据转换。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="b3e5" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">数据转换</h1><p id="0de0" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">在机器学习的上下文中，数据转换是将数据转换成最能代表数据模式并适合模型拟合的适当格式或结构的过程。</p><blockquote class="nu"><p id="7782" class="nv nw it bd nx ny nz oa ob oc od lu dk translated">如果我们在建模之前恰当地应用转换，我们可以从数据中挤出更多的汁液。</p></blockquote><p id="849f" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">机器学习算法接受不同的数据格式和类型，尽管数字数据是最可接受的格式。其中，数字数据是可以是小数或整数的数字，其值的范围从-无穷大到+无穷大。</p><p id="a58e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相比之下，分类数据是表示为字符串的定性特征(例如，状态特征可以将“开”或“关”作为唯一的类别)。数据集还可能包含具有“真”或“假”特征值的布尔数据类型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/3a36559b47271051adf21b5db99a3e23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sdp2miuZ0k4aS1Apgh3Nsw.png"/></div></div></figure><p id="4bd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下数据转换通常适用于数据科学建模，并且非常有价值。</p><p id="3a2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">特征编码</strong></p><p id="bb11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是将分类数据转换成数字数据的过程。存在两种主要的方法，即顺序编码和独热编码。</p><p id="be13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ok">序数编码:</em>在这种情况下，分类数据中的层次结构在转换后保持不变。例如，风险级别特征可以转换如下:低风险-0，中风险-1，高风险-2。熊猫图书馆的<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OrdinalEncoder.html" rel="noopener ugc nofollow" target="_blank">顺序编码器</a>可用于此操作。</p><p id="da52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ok"> One-hot编码:</em>这种方法在分类特征中没有顺序，并且很少有唯一的类别(低基数)时使用。因为为每个类别创建了一个新列，所以当将这种方法应用于具有高基数的特性时，数据大小会显著增长。在这种情况下，可以应用基数编码，如这里的<a class="ae ky" href="https://pycaret.gitbook.io/docs/get-started/preprocessing/data-preparation#cardinal-encoding" rel="noopener ugc nofollow" target="_blank">所述</a>。</p><p id="1b0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">离散化</strong></p><p id="9e9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过创建离散化数据的类区间<strong class="lb iu"> </strong>可以更好地将连续数据呈现给算法。例如，一组年龄范围(0-12:0，13-19:1，20-35:2，35+:4)可以从连续年龄数据中创建，转换后的数据具有更好的预测能力。用于离散化的有用的熊猫方法包括<a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.cut.html" rel="noopener ugc nofollow" target="_blank">切割</a>和<a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.qcut.html" rel="noopener ugc nofollow" target="_blank">q切割</a>。</p><p id="b545" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，二进制化是一种特殊类型的离散化，它涉及将特征值分配给两组中的任何一组，即0或1。Scikit-learn预处理模块中的<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.binarize.html" rel="noopener ugc nofollow" target="_blank">二进制化</a>工具可用于该操作。</p><p id="27be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">分布映射</strong></p><p id="96a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当输入数据具有特定分布(例如正态分布)时，一些机器学习算法表现更好。绘制分布图的著名方法包括:</p><p id="cf46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ok">均匀映射:</em>这涉及到将数据映射到具有同等可能性结果的均匀分布。更多详情可点击查看<a class="ae ky" href="https://scikit-learn.org/stable/modules/preprocessing.html#mapping-to-a-uniform-distribution" rel="noopener ugc nofollow" target="_blank">。此外，Scikit-learn中的</a><a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.QuantileTransformer.html#sklearn.preprocessing.QuantileTransformer" rel="noopener ugc nofollow" target="_blank">分位数转换器</a>工具可用于此操作。</p><p id="b358" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ok">高斯映射:</em>这里，数据被映射成尽可能接近正态分布，平均值、中值和众数大致相同。更多细节可以在<a class="ae ky" href="https://scikit-learn.org/stable/modules/preprocessing.html#mapping-to-a-gaussian-distribution" rel="noopener ugc nofollow" target="_blank">这里</a>找到。此外，Scikit-learn中的<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.PowerTransformer.html#sklearn.preprocessing.PowerTransformer" rel="noopener ugc nofollow" target="_blank">电源变压器</a>工具可用于此操作。</p><p id="ff3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以说，变换数据分布并不总是一个好主意，因为会产生意想不到的影响，例如掩盖残差的真实行为。更多解释可以在<a class="ae ky" href="https://medium.com/peter-flom-the-blog/why-you-should-probably-not-transform-your-data-9ea098dcaddf" rel="noopener">这里</a>找到。</p><p id="08c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">数据缩放</strong></p><p id="a689" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此过程可确保将具有不同单位和量值范围的要素转换为相同的比例，以避免将数据误报给模型。存在几种数据缩放方法，但为了简洁起见，我在这里只简要描述几种，如果有兴趣，还提供了进一步研究的链接。</p><p id="3517" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ok">标准化:</em>这包括减去平均值并除以标准差。它确保数据以零为中心，并根据标准偏差进行调整。更多详情可在<a class="ae ky" href="https://scikit-learn.org/stable/modules/preprocessing.html#standardization-or-mean-removal-and-variance-scaling" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="69ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ok">标准化:</em>该方法确保每个观察值或每个特征的数据值都有一个单位标准。更多细节可以在这里找到<a class="ae ky" href="https://scikit-learn.org/stable/modules/preprocessing.html#normalization" rel="noopener ugc nofollow" target="_blank">。此外，可以使用Scikit-learn预处理模块中的</a><a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.normalize.html#sklearn.preprocessing.normalize" rel="noopener ugc nofollow" target="_blank"> normalize </a>方法。</p><p id="62e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ok">缩放到一个范围:</em>这里，给定特征的数据值被映射到一个特定的范围。它通常包括减去平均值，然后除以要素的最小值和最大值之间的差值。更多详情可点击查看<a class="ae ky" href="https://scikit-learn.org/stable/modules/preprocessing.html#scaling-features-to-a-range" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="55cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他缩放方法包括使用最小和最大阈值的对数缩放和限幅值。这个免费的Google课程对数据缩放(规范化)进行了更深入的解释。不同的缩放方法对有异常值的数据的影响可以<a class="ae ky" href="https://scikit-learn.org/stable/auto_examples/preprocessing/plot_all_scaling.html#sphx-glr-auto-examples-preprocessing-plot-all-scaling-py" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="6d8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">数据还原</strong></p><p id="8cb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在数据转换过程中，可能会出于很好的理由创建许多新功能。然而，随着特征数量的增加，计算成本和时间也会增加。此外，过多的特征可能会导致过度拟合等问题。这个问题通常被称为维数灾难。</p><blockquote class="nu"><p id="9257" class="nv nw it bd nx ny nz oa ob oc od lu dk translated">因此，我们可能需要减少特征的数量，以有效地建立机器学习模型，同时提高预测性能。</p></blockquote><p id="9d0a" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">多重共线性(两个或多个独立要素高度相关)是可能修剪要素的另一个原因。它会影响模型性能和可解释性，尤其是非基于树的算法，如线性回归。更多关于多重共线性的细节可以在<a class="ae ky" rel="noopener" target="_blank" href="/multicollinearity-why-is-it-bad-5335030651bf">这里</a>找到。</p><p id="fbb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据简化的一些方法包括:</p><p id="ee8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ok">主成分分析:</em>这是一种非常有用的方法，可以将数据特征映射到一个较低的正交维度空间，同时尽可能多地保留数据中的信息。然而，变换后的特征不像原始特征那样可解释。因此，它们在某些应用中可能不被使用。更多细节可以在<a class="ae ky" href="https://scikit-learn.org/stable/modules/decomposition.html#principal-component-analysis-pca" rel="noopener ugc nofollow" target="_blank">这里</a>找到。另外，Scikit-learn中的分解模块有一个<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html" rel="noopener ugc nofollow" target="_blank"> PCA </a>工具可以用于这个动作。</p><p id="f618" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ok">特征消除:</em>在这种情况下，最不相关的特征被去除，同时保留最具预测能力的特征。使用直观且大多可解释的原始特征，这避免了PCA遇到的可解释性问题。该方法可以递归执行，如这里的<a class="ae ky" href="https://www.scikit-yb.org/en/latest/api/model_selection/rfecv.html#recursive-feature-elimination" rel="noopener ugc nofollow" target="_blank">所述</a>。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="4ae1" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">结论</h1><p id="8279" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">在本文中，我们讨论了数据转换，即将数据转换成适合模型的格式的过程。此过程还可能包括一些讨论过的数据简化策略。</p><p id="b95d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里探讨的数据转换与大多数数据科学建模应用程序相关，但并不详尽。应该注意的是，还有其他特定于不同领域的转换，例如用于自然语言编程的符号化和用于时间序列分析的滞后特征的特征创建。</p><p id="3d6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就把我们带到了数据预处理系列的结尾。耶！！我希望你喜欢这些文章，直到下次。干杯！</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><p id="f9f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">什么更有趣？你可以通过下面我的推荐链接订阅Medium来获得更多我和其他作者的启发性文章，这也支持我的写作。</p><div class="lx ly gp gr lz ma"><a href="https://aolaoye.medium.com/membership" rel="noopener follow" target="_blank"><div class="mb ab fo"><div class="mc ab md cl cj me"><h2 class="bd iu gy z fp mf fr fs mg fu fw is bi translated">通过我的推荐链接加入媒体</h2><div class="mh l"><h3 class="bd b gy z fp mf fr fs mg fu fw dk translated">阅读Abiodun Olaoye(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="mi l"><p class="bd b dl z fp mf fr fs mg fu fw dk translated">aolaoye.medium.com</p></div></div><div class="mj l"><div class="ol l ml mm mn mj mo ks ma"/></div></div></a></div></div></div>    
</body>
</html>