<html>
<head>
<title>Three Cases When Parsing JSON Documents In A Python Pandas DataFrame</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python Pandas数据帧中解析JSON文档的三种情况</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/three-cases-when-parsing-json-documents-in-a-python-pandas-dataframe-9c9dfea9ec34#2022-02-14">https://towardsdatascience.com/three-cases-when-parsing-json-documents-in-a-python-pandas-dataframe-9c9dfea9ec34#2022-02-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/c20ae02e6b9acf9a7d18dee6232bed4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*INi3cKet9-rhxIu0WxXvYA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://pixabay.com/users/wflore-11084744/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4395609" rel="noopener ugc nofollow" target="_blank"> Flore W </a>来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4395609" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><div class=""/><div class=""><h2 id="6d0d" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">如果你知道这些技巧，在Pandas中标准化JSON对象并不困难</h2></div><p id="d44f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们在做一些数据科学工作时，不得不处理JSON文档这样的半结构化数据是相当常见的。作为Python中最流行的数据处理框架，Pandas提供了内置的JSON规范化特性“json_normalize()”。</p><p id="f994" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，这篇文章的目的不仅仅是介绍如何在Pandas中使用JSON规范化方法。在现实世界中，数据并不完美。例如，当我们使用JSON normalize方法时，JSON对象中可能会有丢失的数据，这可能会导致错误。</p><p id="5259" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将描述三种情况，当我们试图用Pandas中丢失的数据来规范化JSON文档时。</p><h1 id="5488" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">0.熊猫JSON标准化方法</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/707d341825fc38f58ee5167fe3369a8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iv5soOFkKZRgCj14uLWckA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6495338" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="3217" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们讨论特殊情况之前，让我们先看看<code class="fe mq mr ms mt b">json_normalize()</code>方法在正常情况下的用法。假设我们有这样一个JSON文档。我们可以从JSON对象创建一个熊猫数据帧，如下所示。</p><pre class="mm mn mo mp gt mu mt mv mw aw mx bi"><span id="978f" class="my lv jj mt b gy mz na l nb nc">import pandas as pd</span><span id="28eb" class="my lv jj mt b gy nd na l nb nc">df = pd.DataFrame({<br/>    'student_id': [1, 2, 3],<br/>    'student_name': ['Alice', 'Bob', 'Chris'],<br/>    'student_info': [<br/>        {'gender': 'F', 'age': 20},<br/>        {'gender': 'M', 'age': 22},<br/>        {'gender': 'M', 'age': 33}<br/>    ]<br/>})</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ne"><img src="../Images/0b1c4ab92e1b767fe062502360ba5e50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pIJX5P0IeEZbuvjMhIELYA.png"/></div></div></figure><p id="d7ef" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好的。现在，<code class="fe mq mr ms mt b">student_info</code>字段嵌套在JSON对象中。是时候使用<code class="fe mq mr ms mt b">json_normalise()</code>方法从JSON对象中解码它了。</p><pre class="mm mn mo mp gt mu mt mv mw aw mx bi"><span id="c72a" class="my lv jj mt b gy mz na l nb nc">pd.json_normalize(df['student_info'])</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nf"><img src="../Images/1b7dadbea928935febcc51a25e390314.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e4b-2GD-uJEW8gjCdv-YGw.png"/></div></div></figure><p id="e985" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该方法非常方便。它聪明地计算出所有JSON对象的属性，并将它们用作列名。然后，提取它们的值并将它们转换成表格格式。</p><p id="a17f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果想把它放回原来的数据帧，可以用熊猫里的<code class="fe mq mr ms mt b">concat()</code>方法。</p><pre class="mm mn mo mp gt mu mt mv mw aw mx bi"><span id="979b" class="my lv jj mt b gy mz na l nb nc">df = pd.concat([<br/>    df.drop('student_info', axis=1), <br/>    pd.json_normalize(df['student_info'])], <br/>    axis=1<br/>)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ng"><img src="../Images/ed36decb85f4048327694a27bdec9282.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TwJrhc5Kn2QLJFuqveIN8w.png"/></div></div></figure><h1 id="e96f" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">案例1 — JSON作为字典</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/8ac52eb61c0960b55be7554f34c0a640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1_qlNb3-vZVNFVJznF0RfA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://pixabay.com/users/00firefly00-6414409/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2821388" rel="noopener ugc nofollow" target="_blank"> Liselle VD </a>从<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2821388" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>获得</p></figure><p id="33c8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们看看JSON对象中丢失数据的一些情况。在第一种情况下，假设我们已经有了Python字典格式的JSON。</p><pre class="mm mn mo mp gt mu mt mv mw aw mx bi"><span id="6427" class="my lv jj mt b gy mz na l nb nc">df = pd.DataFrame({<br/>    'student_id': [1, 2, 3],<br/>    'student_name': ['Alice', 'Bob', 'Chris'],<br/>    'student_info': [<br/>        {'gender': 'F', 'age': 20},<br/>        {'gender': 'M', 'age': 22},<br/>        None<br/>    ]<br/>})</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nh"><img src="../Images/b2fb3a94c0021a573c238a7cef0936c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nxsUlTwNv5CjQzLz_cC_Sg.png"/></div></div></figure><p id="6bb7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，所有的<code class="fe mq mr ms mt b">student_info</code>类型都是Python字典。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ni"><img src="../Images/40dac884a9b84b650afefa5e1da1b3b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NedL_a8d6HGAYKUF2NitDQ.png"/></div></div></figure><p id="255d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本案例模拟学生“Chris”的缺失数据。对他来说没有<code class="fe mq mr ms mt b">student_info</code>。如果我们试图使用<code class="fe mq mr ms mt b">json_normalize()</code>方法，将会抛出一个错误。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nj"><img src="../Images/dc3182cddbb29ca81f0285103db21d24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y8B2OYFewEp9jzDpXj3rjQ.png"/></div></div></figure><p id="097d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，我们不想使用<code class="fe mq mr ms mt b">dropna()</code>来删除这些行，因为还有其他有用的字段。在这种情况下，我们需要用一个空字典来填充【无】<code class="fe mq mr ms mt b">student_info</code>。</p><p id="2f8f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">到目前为止，我相信没有问题。难的是我们可以很容易的使用<code class="fe mq mr ms mt b">fillna()</code>方法如下。</p><pre class="mm mn mo mp gt mu mt mv mw aw mx bi"><span id="bf03" class="my lv jj mt b gy mz na l nb nc">df['student_info'].fillna({})</span></pre><p id="3c64" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这根本行不通。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nk"><img src="../Images/2372f5fff59a49459953198980779d01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QMfkk4iAkEZWv3OFPA0YTg.png"/></div></div></figure><p id="f2be" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是因为<code class="fe mq mr ms mt b">fillna()</code>方法需要一个标量/文字值或者一个字典、序列，甚至是数据帧。换句话说，如果它是一个标量或文字值，它将用于填充所有缺失的单元格。否则，它必须是一个集合类型，可以告诉哪个单元格将填充什么。</p><p id="0ea1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">显然，空字典<code class="fe mq mr ms mt b">{}</code>或<code class="fe mq mr ms mt b">dict()</code>不是标量，但不能用来告诉程序哪些字段应该填充什么值。因此，我们必须使用数据帧的索引来组成字典。</p><blockquote class="nl nm nn"><p id="42e5" class="ky kz no la b lb lc kk ld le lf kn lg np li lj lk nq lm ln lo nr lq lr ls lt im bi translated">用于填补漏洞的值(例如0)，或者是值的字典/系列/数据框架，指定每个索引(对于系列)或列(对于数据框架)使用哪个值。不在字典/系列/数据框架中的值将不会被填充。该值不能是列表。</p></blockquote><pre class="mm mn mo mp gt mu mt mv mw aw mx bi"><span id="8844" class="my lv jj mt b gy mz na l nb nc">df['student_info'].fillna({i: {} for i in df.index})</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ns"><img src="../Images/93052ea2b4add5d7900e43930d29b241.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U4tDP670dSmKAPMxljG2Ww.png"/></div></div></figure><p id="73ad" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们可以使用<code class="fe mq mr ms mt b">json_normalize()</code>方法。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nt"><img src="../Images/093984d52383cc99ae9521431852ede8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JX6fq_4jvMEY1EruOf-sJw.png"/></div></div></figure><h2 id="6417" class="my lv jj bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">*熊猫的重要更新*</h2><p id="2a67" class="pw-post-body-paragraph ky kz jj la b lb of kk ld le og kn lg lh oh lj lk ll oi ln lo lp oj lr ls lt im bi translated">在此添加本节是为了澄清上述问题已在Pandas更新版本1.3.0中涵盖。换句话说，上面的错误只会出现在1.2.5或更低版本中。</p><h1 id="d849" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">案例2 —字符串形式的JSON</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/8416c2dc932facf02b2f094981836a90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vSTJnIUXTfjYp_FTdV6AKA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/users/julesroman-359800/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=792912" rel="noopener ugc nofollow" target="_blank">茱莉亚·罗曼</a>来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=792912" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="3a24" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，让我们假设我们得到的JSON文档是字符串格式的。这在实践中很常见。想象一下，我们从一些CSV文件中读取数据，这些文件是从NoSQL数据库中转储的(有人可能会这样做，不要惊讶)。</p><p id="5b40" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">样本数据如下。</p><pre class="mm mn mo mp gt mu mt mv mw aw mx bi"><span id="565e" class="my lv jj mt b gy mz na l nb nc">df = pd.DataFrame({<br/>    'student_id': [1, 2, 3],<br/>    'student_name': ['Alice', 'Bob', 'Chris'],<br/>    'student_info': [<br/>        '{"gender": "F", "age": 20}',<br/>        '{"gender": "M", "age": 22}',<br/>        None<br/>    ]<br/>})</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ok"><img src="../Images/a87cb3dfe43659b3b678cb5817023b8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LIMQTNGBiynEta6533Snfw.png"/></div></div></figure><p id="2b8b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，我们需要使用一些魔法将JSON字符串转换成Python字典。我们可以使用内置的JSON库来加载它们，并将<code class="fe mq mr ms mt b">json.loads()</code>方法放入<code class="fe mq mr ms mt b">pands.apply()</code>方法中。然而，有更简单的方法。那就是使用AST(抽象语法树)中的<code class="fe mq mr ms mt b">literal_eval()</code>方法，这也是一个内置的库。</p><p id="264a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">顺便说一句，避免使用<code class="fe mq mr ms mt b">eval()</code>方法是很好的方式，因为它会立即评估一切，而不需要任何安全检查。不管我们之后会对数据做什么，我们都应该使用<code class="fe mq mr ms mt b">literal_eval()</code>。简单来说，后者只会对字符串、字节、数字、元组、列表、字典、集合、布尔、None求值。</p><pre class="mm mn mo mp gt mu mt mv mw aw mx bi"><span id="9b00" class="my lv jj mt b gy mz na l nb nc">from ast import literal_eval</span><span id="d94b" class="my lv jj mt b gy nd na l nb nc">my_dict = literal_eval('{"gender": "F", "age": 20}')</span><span id="8528" class="my lv jj mt b gy nd na l nb nc">type(my_dict)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/4ac544bd7729376dffef2eeeb4754a51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BG9QP6-uv02g3pVKTTNjWA.png"/></div></div></figure><p id="09c1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们可以使用<code class="fe mq mr ms mt b">literal_eval()</code>方法将JSON字符串转换成Python字典吗？它将完成工作，但是不要忘记我们仍然没有价值。</p><pre class="mm mn mo mp gt mu mt mv mw aw mx bi"><span id="e534" class="my lv jj mt b gy mz na l nb nc">df['student_info'].apply(literal_eval)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi om"><img src="../Images/c858c8846a92175e559a021dcc2d1c1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bnadZpeVWXKcelkkjcuuMw.png"/></div></div></figure><p id="9748" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">解决方案并不复杂，只需用一个空字典填充<code class="fe mq mr ms mt b">None</code>值，但采用字符串格式<code class="fe mq mr ms mt b">'{}'</code>。所以，它将被<code class="fe mq mr ms mt b">literal_eval()</code>方法转换成一个空字典。</p><pre class="mm mn mo mp gt mu mt mv mw aw mx bi"><span id="1cb8" class="my lv jj mt b gy mz na l nb nc">df['student_info'] = df['student_info'].fillna('{}')</span><span id="6a99" class="my lv jj mt b gy nd na l nb nc">df = pd.concat([<br/>    df.drop('student_info', axis=1), <br/>    pd.json_normalize(df['student_info'].apply(literal_eval))], axis=1)<br/>df</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi on"><img src="../Images/cc319ea59d7a8ff30d2d98cf62dd81c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NuR1VP5HaZGYQwMEUFL5EQ.png"/></div></div></figure><h1 id="02f1" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">案例3 —字符串形式的JSON数组</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/411fab6491932cfae3c5b5d9e3d95dfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CiG2k-dIkdfR6rL4W4Y1_g.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4300222" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/kavowo-6764465/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4300222" rel="noopener ugc nofollow" target="_blank"> KAVOWO </a>的图像</p></figure><p id="4c30" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，源数据中有大量JSON数组对象并不少见。如果能把它们读入Python list，我们消费起来就容易多了。然而，有时它们也可能是字符串。</p><p id="c6cf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们这样来考虑这个案例。</p><pre class="mm mn mo mp gt mu mt mv mw aw mx bi"><span id="e212" class="my lv jj mt b gy mz na l nb nc">df = pd.DataFrame({<br/>    'student_id': [1, 2, 3],<br/>    'student_name': ['Alice', 'Bob', 'Chris'],<br/>    'student_exam': [<br/>        '[{"math": 90, "english": 85}]',<br/>        '[{"math": 85}]',<br/>        None<br/>    ]<br/>})</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oo"><img src="../Images/b1f7be9e18644cb2f1e3081a7e911e7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4G4KkB_YvDCHkmlccCHbAw.png"/></div></div></figure><p id="fbb3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">出于某种原因，这就是我们拥有的数据。我们没有别的选择，就改造吧。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi op"><img src="../Images/6f521fc3c7df213e601d54e816303239.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*82Q9ZC3MTRuwMotpuoy1hw.png"/></div></div></figure><p id="0d2f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于它们也是字符串，我们可以再次使用<code class="fe mq mr ms mt b">literal_eval()</code>方法将它们转换成真正的Python列表。这一次，我们需要分别用<code class="fe mq mr ms mt b">'[]'</code>填充None值。</p><pre class="mm mn mo mp gt mu mt mv mw aw mx bi"><span id="0528" class="my lv jj mt b gy mz na l nb nc">df['student_info'] = df['student_info'].fillna('[]').apply(literal_eval)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oq"><img src="../Images/157e526cf5a16ad96496d865e9691f7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jbpqpZGM485zeT5IBXQpuw.png"/></div></div></figure><p id="d5dd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，重要的部分是我们需要使用Pandas中的<code class="fe mq mr ms mt b">explode()</code>方法从列表中提取值。如果一个列表中有多个项目，那么这个特定的行将被重复几次，这样每个项目都在一行中。</p><p id="c8a9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，使用<code class="fe mq mr ms mt b">explode()</code>方法不会产生数据帧的新索引。如果有任何包含多项的列表，数据帧索引也将重复。因此，我们可以添加<code class="fe mq mr ms mt b">reset_index()</code>方法来重置索引，然后删除旧的。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi or"><img src="../Images/c0c0d8e76b521b829205f642397b5278.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CmR9ovn3wmqLf35WwUeHdg.png"/></div></div></figure><p id="9cd0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一步，我们可以毫无问题地使用<code class="fe mq mr ms mt b">json_normalize()</code>方法。</p><pre class="mm mn mo mp gt mu mt mv mw aw mx bi"><span id="c5e8" class="my lv jj mt b gy mz na l nb nc">df = pd.concat([<br/>    df.drop('student_info', axis=1), <br/>    pd.json_normalize(df['student_info'])], <br/>    axis=1<br/>)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi os"><img src="../Images/7514257f1bad93da7096752d2c44d533.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sad-LsxqWYItUJBihyFBRQ.png"/></div></div></figure><h1 id="b24b" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">摘要</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/83cb33f844f5b1159060c4d2a48237b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M0g1SS8uMVuuwlpLjoILVA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://pixabay.com/users/seth0s-816508/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4301479" rel="noopener ugc nofollow" target="_blank">Seth OS</a>来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4301479" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="0c8b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇文章中，我介绍了Pandas框架中最方便的方法之一<code class="fe mq mr ms mt b">json_normalise()</code>。它很容易使用，可以节省大量的时间和精力，虽然有时它不能处理一些特殊情况。本文展示了JSON文档中有空值的3种情况以及如何处理它。</p><div class="is it gp gr iu ot"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd jk gy z fp oy fr fs oz fu fw ji bi translated">通过我的推荐链接加入灵媒-陶</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">medium.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph ja ot"/></div></div></a></div><p id="2188" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你觉得我的文章有帮助，请考虑加入Medium会员来支持我和成千上万的其他作者！(点击上面的链接)</p></div></div>    
</body>
</html>