<html>
<head>
<title>Convenient Scheduler in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中方便的调度程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/convenient-scheduler-in-python-2adbb57be94f#2022-06-21">https://towardsdatascience.com/convenient-scheduler-in-python-2adbb57be94f#2022-06-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="14a8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用python调度ETL任务的小规模便捷方法。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7b8a716f0a89e8f8d10d9ceef3de2ca8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tq6JNo7nkgmw51O7IwMPag.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个永远悬而未决的任务的例子，波兰<a class="ae ky" href="https://private.zerowithdot.com/travelling" rel="noopener ugc nofollow" target="_blank"> 2021 </a>。(作者供图)。</p></figure><h1 id="cf91" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="d898" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Python已经成为一种通用语言。它尤其常用于数据科学中的分析和解决算法问题，但在web开发中也很流行。这种组合使它成为各种提取-转换-加载(ETL)任务的合理选择。</p><p id="55fb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，这些任务中的许多都相当小，不需要大型框架，如<a class="ae ky" href="https://airflow.apache.org/" rel="noopener ugc nofollow" target="_blank">气流</a>或<a class="ae ky" href="https://luigi.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> Luigi </a>。当轮询一个或多个web页面的数据时，一个简单的python脚本加上<a class="ae ky" href="https://docs.oracle.com/en/learn/oracle-linux-crontab/" rel="noopener ugc nofollow" target="_blank"> crontab </a>就足够了。尽管如此，当一个项目变得稍微大一点时，使用cron管理多个作业可能会变得很麻烦。同时，“小作业”的Airflow裸装至少需要4GB RAM和2个CPU(此处<a class="ae ky" href="https:    //stackoverflow.com/questions/47277180/minimum-hardware-requirements-for-apache-airflow-cluster" rel="noopener ugc nofollow" target="_blank"/>)。考虑到AWS的成本，它至少是一个一直运行的<em class="ms"> t2.small </em>实例。</p><p id="e23d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">有中间的吗？小到可以使用，比如说<em class="ms"> t2.nano </em>(非常便宜)并且相当“可维护”和“可扩展”？</p><p id="9c6c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这篇文章中，我想和你分享一个简单的方法，它使用python的<a class="ae ky" href="https://schedule.readthedocs.io/en/stable/examples.html" rel="noopener ugc nofollow" target="_blank"> schedule </a>包，并做了一些修改。</p><h1 id="78b6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">Python调度程序</h1><p id="3cba" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Python <a class="ae ky" href="https://schedule.readthedocs.io/en/stable/examples.html" rel="noopener ugc nofollow" target="_blank"> schedule </a>库提供了简单的任务调度。它可以使用<code class="fe mt mu mv mw b">pip</code>来安装，并且非常容易使用。不幸的是，文档没有提供在更大的项目中使用它的例子:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="e5ae" class="nb la it mw b gy nc nd l ne nf">import schedule<br/>import time<br/><br/>def job():<br/>    print("I'm working...")<br/><br/>    # Run job every 3 second/minute/hour/day/week,<br/>    # Starting 3 second/minute/hour/day/week from now<br/>    schedule.every(3).seconds.do(job)<br/>    schedule.every(3).minutes.do(job)<br/>    schedule.every(3).hours.do(job)<br/>    schedule.every(3).days.do(job)<br/>    schedule.every(3).weeks.do(job)<br/><br/>    # Run job every minute at the 23rd second<br/>    schedule.every().minute.at(":23").do(job)<br/><br/>    # Run job every hour at the 42rd minute<br/>    schedule.every().hour.at(":42").do(job)<br/><br/>    # Run jobs every 5th hour, 20 minutes and 30 seconds in.<br/>    # If current time is 02:00, first execution is at 06:20:30<br/>    schedule.every(5).hours.at("20:30").do(job)<br/><br/>    # Run job every day at specific HH:MM and next HH:MM:SS<br/>    schedule.every().day.at("10:30").do(job)<br/>    schedule.every().day.at("10:30:42").do(job)<br/><br/>    # Run job on a specific day of the week<br/>    schedule.every().monday.do(job)<br/>    schedule.every().wednesday.at("13:15").do(job)<br/>    schedule.every().minute.at(":17").do(job)<br/><br/>    while True:<br/>        schedule.run_pending()<br/>            time.sleep(1)</span></pre><p id="7ad9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正如您所看到的，所有的函数都在模块级别被调用，这对于将它放在脚本中是可以的。但是，如果您有几个不同的作业，代码很快就会变得混乱，特别是如果不同的调用需要不同的参数。</p><p id="faae" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">换句话说，利用面向对象的方法并围绕它定义一些“架构”可能更好。</p><h1 id="a908" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">在项目中使用它</h1><p id="6c89" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了便于讨论，假设我们有一组专用的ETL任务，使用下面的抽象类建模:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="8e20" class="nb la it mw b gy nc nd l ne nf">from abc import ABC, abstractmethod<br/>from typing import Any, Dict, TypeVar<br/><br/><br/>E = TypeVar("ETL")<br/><br/><br/>class BaseETL(ABC):<br/>    def __init__(self, **kwargs: Dict) -&gt; None:<br/>        self.raw_data = None<br/>        self.transformed_data = None<br/><br/>    @abstractmethod<br/>    def extract(self, **kwargs: Dict) -&gt; E:<br/>        ...<br/><br/>    @abstractmethod<br/>    def transform(self, **kwargs: Dict) -&gt; E:<br/>        ...<br/><br/>    @abstractmethod<br/>    def load(self, **kwargs: Dict) -&gt; Any:<br/>        ...<br/><br/>    def run(self, **kwargs: Dict) -&gt; None:<br/>        self.extract(**kwargs).transform(**kwargs).load(**kwargs)</span></pre><p id="6b39" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">任何实现ETL过程的类都会继承这个基类。例如，<code class="fe mt mu mv mw b">extract</code>方法可以获取一个网站。然后<code class="fe mt mu mv mw b">transform</code>将原始HTML转换成数据库可接受的格式。最后，<code class="fe mt mu mv mw b">load</code>会将数据保存到数据库中。按照这个顺序执行的所有方法都可以使用<code class="fe mt mu mv mw b">run</code>方法包装。</p><p id="e411" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，在定义了ETL类之后，我们希望通过<code class="fe mt mu mv mw b">schedule</code>模块以一种很好的方式来调度它们。</p><h1 id="fb8b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">两个示例ETL任务</h1><p id="88d9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了简洁，在下面的例子中，让我们跳过继承，只关注<code class="fe mt mu mv mw b">run</code>方法。假设他们的<code class="fe mt mu mv mw b">extract</code>、<code class="fe mt mu mv mw b">transform</code>和<code class="fe mt mu mv mw b">load</code>方法在别处实现。</p><h2 id="7b7d" class="nb la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated">etl.py</h2><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="d31a" class="nb la it mw b gy nc nd l ne nf">class DummyETL:  # normally DummyETL(BaseETL)<br/>    def __init__(self, init_param: int) -&gt; None:<br/>        # super().__init__()  # - not needed here<br/>        self.init_param = init_param<br/><br/>    def run(self, p1: int, p2: int) -&gt; None:<br/>        name = self.__class__.__name__<br/>        print(f"{name}({self.init_param}, p1={p1}, p2={p1})")<br/><br/><br/>class EvenDummierETL:  # same...<br/>    def __init__(self, init_param: int) -&gt; None:<br/>        # super().__init__()  # - same<br/>        self.init_param = init_param<br/><br/>    def run(self, p1: int) -&gt; None:<br/>        name = self.__class__.__name__<br/>        print(f"{name}({self.init_param}, p1={p1})")</span></pre><p id="d42c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">例如，构造函数的参数可以指定用于抓取的页面的URL。方法的参数可以用来传递秘密。</p><p id="a1c2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，我们已经定义了ETL类，让我们创建一个单独的<em class="ms">注册中心</em>来将流程与某种时间表关联起来。</p><h2 id="0a65" class="nb la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated">注册表. py</h2><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="3ad7" class="nb la it mw b gy nc nd l ne nf">import schedule<br/><br/>from etl import DummyETL, EvenDummierETL<br/><br/><br/>def get_registry():<br/>    dummy_etl = DummyETL(init_param=13)<br/>    dummier_etl = EvenDummierETL(init_param=15)<br/><br/>    return [<br/>        (dummy_etl, schedule.every(1).seconds),<br/>        (dummier_etl, schedule.every(1).minutes.at(":05")),<br/>    ]</span></pre><p id="4aa0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe mt mu mv mw b">get_registry</code>功能是定义时间表的地方。尽管参数的值是硬编码的，但是您可以考虑函数从配置文件中加载它们的情况。无论哪种方式，它都会返回一个元组列表，这些元组匹配带有<code class="fe mt mu mv mw b">Job</code>的ETL对象(来自<code class="fe mt mu mv mw b">schedule</code>)。注意，这是我们的<strong class="lt iu">约定。</strong>作业尚未与任何特定的<code class="fe mt mu mv mw b">Scheduler</code>相关联(同样来自<code class="fe mt mu mv mw b">schedule</code>)。然而，公约允许我们在项目的任何其他部分这样做。我们不必将它们与模块级对象绑定，如文档示例所示。</p><h1 id="ebe7" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">我们基于调度程序的调度程序</h1><p id="4eae" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最后，让我们创建一个新的类来激活整个机制。</p><h2 id="0c1a" class="nb la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated">scheduler.py</h2><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="fd0e" class="nb la it mw b gy nc nd l ne nf">import time<br/>from typing import Dict, List, Tuple, TypeVar<br/><br/>from schedule import Job, Scheduler<br/><br/>from etl import DummyETL, EvenDummierETL<br/>from etl import E  # we could do so from e.g. etl.base<br/><br/><br/>S = TypeVar("Scheduler")<br/><br/><br/>class TaskScheduler:<br/>    def __init__(self, registry: List[Tuple[E, Job]]) -&gt; None:<br/>        self.scheduler = Scheduler()<br/>        self.registry = []<br/><br/>        for task, job in registry:<br/>            self.registry.append(task)<br/>            self.scheduler.jobs.append(job)<br/><br/>    def register(self, run_params: Dict) -&gt; S:<br/>        jobs = self.scheduler.get_jobs()<br/>        for task, job in zip(self.registry, jobs):<br/>            params = run_params.get(task.__class__.__name__)<br/>            job.do(task.run, **params)<br/><br/>        return self<br/><br/>    def run(self, polling_seconds: int) -&gt; None:<br/>        while True:<br/>            time.sleep(polling_seconds)<br/>            self.scheduler.run_pending()</span></pre><p id="8add" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们的<code class="fe mt mu mv mw b">TaskScheduler</code>使用组合来创建一个单独的<code class="fe mt mu mv mw b">Scheduler</code>实例，并向其中添加先前注册的作业。尽管不是强制的，我们使用<code class="fe mt mu mv mw b">typing</code>来给出一个强有力的提示，告诉构造函数应该提供什么来正确地注册作业。然后，<code class="fe mt mu mv mw b">register</code>方法是一个提供绑定的独立方法。最后，同样重要的是，<code class="fe mt mu mv mw b">run</code>激活机器。</p><p id="aa9d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用此实现的脚本如下所示:</p><h2 id="84f3" class="nb la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated">run.py</h2><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="bb09" class="nb la it mw b gy nc nd l ne nf">from registry import get_registry<br/>from scheduler import TaskScheduler<br/><br/><br/>if __name__ == "__main__":<br/>    run_params = {<br/>        "DummyETL": dict(p1=1, p2=2),  # e.g. from env vars<br/>        "EvenDummierETL": dict(p1=3),<br/>    }<br/>    <br/>    registry = get_registry()  # e.g. from script's args or config<br/>    task_scheduler = TaskScheduler(registry).register(run_params)<br/>    task_scheduler.run()</span></pre><p id="9f14" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个解决方案最弱的一点可能是在<code class="fe mt mu mv mw b">run_params</code>字典中使用<code class="fe mt mu mv mw b">__class__.__name__</code>作为键的约定。然而，考虑到这种方法的简单性，它可能是可以的，特别是如果这些参数是在运行时定义的。有很多选择，其中之一是创建一个额外的抽象层，比如像<code class="fe mt mu mv mw b">DummyTask</code>这样的对象，作为ETL对象和注册中心之间的桥梁。</p><h1 id="fbf4" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">任务调度的另一种方法</h1><p id="6008" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">回到<code class="fe mt mu mv mw b">TaskScheduler</code>，我们也可以通过继承来定义它，而不是像以前一样通过组合来定义。这将意味着扩展<code class="fe mt mu mv mw b">schedule</code>的原生<code class="fe mt mu mv mw b">Scheduler</code>类的功能。在这种情况下，<code class="fe mt mu mv mw b">TaskScheduler</code>如下所示:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="4489" class="nb la it mw b gy nc nd l ne nf">class TaskScheduler(Scheduler):  # &lt;- here<br/>    def __init__(self, registry: List[Tuple[E, Job]]) -&gt; None:<br/>        super().__init__()  # &lt;- here<br/>        self.registry = []<br/><br/>        for task, job in registry:<br/>            self.registry.append(task)<br/>            self.jobs.append(job)  # &lt;- here<br/><br/>    def register(self, run_params: Dict) -&gt; S:<br/>        jobs = self.get_jobs()  # &lt;- here<br/>        for task, job in zip(self.registry, jobs):<br/>            params = run_params.get(task.__class__.__name__)<br/>            job.do(task.run, **params)<br/><br/>        return self<br/><br/>    def run(self, polling_seconds: int) -&gt; None:<br/>        while True:<br/>            time.sleep(polling_seconds)<br/>            self.run_pending()  # &lt;- and here</span></pre><p id="aff4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">你决定哪种方式更好，如果有的话；).</p><h1 id="32bb" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="0442" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在这篇简短的文章中，我们展示了如何扩展简单的<code class="fe mt mu mv mw b">schedule</code>模块来创建一个小型ETL工作机器。最重要的是，这种方法允许在一个小项目中更好地组织代码，而不必去找大炮。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><p id="af9a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="ms">最初发表于</em><a class="ae ky" href="https://zerowithdot.com/scheduler-in-python/" rel="noopener ugc nofollow" target="_blank"><em class="ms">https://zerowithdot.com</em></a><em class="ms">。</em></p></div></div>    
</body>
</html>