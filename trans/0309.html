<html>
<head>
<title>Apache Airflow : 10 Rules to Make It Work</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">阿帕奇气流:使其工作的10条规则</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/apache-airflow-in-2022-10-rules-to-make-it-work-b5ed130a51ad#2022-02-13">https://towardsdatascience.com/apache-airflow-in-2022-10-rules-to-make-it-work-b5ed130a51ad#2022-02-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d011" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">默认情况下，气流非常宽松，如果没有严格的规则，您很可能会在管道堆栈实现中失败。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/277233cfdd6e2ecade89eba4e052a231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*2E2jHrw6Snd461Vs5HwjAQ.jpeg"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">如果你不小心，你的捷径会让你付出很大的代价</p></figure><p id="7760" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">气流许可的方法挫败了许多贡献者实施他们自己坚持的替代方案，如<strong class="kt ir">提督</strong>、<strong class="kt ir">达格斯特</strong>……所有这些都是通过解释气流缺点的博客帖子介绍的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi ln"><img src="../Images/3d5a46dcbc21539a345cd7a8b4033c7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cfa_L5O114F8U3MjR5uBZw.jpeg"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">Airflow允许您在不与框架本身隔离的情况下运行您的作业</p></figure><p id="dd97" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最初，Airflow是一种“超级cron ”,因此运行作业的方式与框架本身紧密相关。今天，您必须克服的最大挑战是消除调度和运行作业之间的耦合。</p><p id="6701" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="ls">现今(2023) GCP、AWS、AZURE提供托管气流v2。这足以证明，如果你正确设置和使用框架，它的工作！</em> </strong></p><h1 id="534c" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">十大法则</strong>:</h1><p id="8aa7" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated"><em class="ls">因此，您可以仅根据要运行的Dag和任务的数量(而不是根据您运行的内容)来扩展您的气流部署</em></p><p id="7306" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 1) Airflow是一个编排框架，不是执行框架:</strong></p><p id="d8cf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于您的工作，您应该只使用在单独的处理解决方案中触发气流计算的运算符<strong class="kt ir">，例如:</strong></p><ul class=""><li id="3436" class="mq mr iq kt b ku kv kx ky la ms le mt li mu lm mv mw mx my bi translated">一个集装箱:K8S，GKE，EKS，ECS，云跑…</li><li id="6d2b" class="mq mr iq kt b ku mz kx na la nb le nc li nd lm mv mw mx my bi translated">无服务器功能:AWS Lambda，云功能</li><li id="bc52" class="mq mr iq kt b ku mz kx na la nb le nc li nd lm mv mw mx my bi translated">火花工作:电子病历，数据处理…</li><li id="bdba" class="mq mr iq kt b ku mz kx na la nb le nc li nd lm mv mw mx my bi translated">一个查询:BigQuery，Redshift，ClickHouse，Trino，Databend …</li><li id="38d2" class="mq mr iq kt b ku mz kx na la nb le nc li nd lm mv mw mx my bi">…</li></ul><p id="5840" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为在Airflow中直接运行作业(执行大量的CPU、内存或IO操作)会给airflow_workers带来压力。气流应该只运行操作员在单独的处理解决方案中运行的启动和断言任务。</p><p id="999d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 2)不要在你的工作中使用PythonOperator(和其他魔法:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/e3747e55f8f101a82ee5d66b7a90d194.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*tl-xlrcOuVAMxgTMJwtbsQ.jpeg"/></div></figure><p id="7ab8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你使用PythonOperator，那么只运行<strong class="kt ir">非常非常简单的代码</strong>，那必须只做简单的IO操作(比如转换一个小的XCOM)，否则用规则1的操作符运行你的作业。</p><p id="920f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">不要使用VirtualVenvOperator或ExternalPythonOperator或BashOperator或DockerOperator </strong>(除非您在不属于您的气流部署的主机中触发运行)，<strong class="kt ir">您应该使用KubernetesPodOperator、EmrCreateJobFlowOperator等运算符… </strong></p><p id="2da0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">不使用任务流装饰器</strong>(<strong class="kt ir"><em class="ls">@ task . kubernetes</em></strong>...)这对于POC来说是个不错的魔术，但是它缺少<strong class="kt ir">关注点分离</strong>(将您的作业逻辑(代码)放在调度逻辑(代码)中是高度耦合的，这会降低您管理气流DAGS的能力</p><p id="dd74" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">明智地选择运算符</p><p id="2954" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 3.1)在创建一个</strong>之前，检查现有的操作员</p><p id="09d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在99%的情况下，您不应该创建新的气流操作符，请仔细查找现有的操作符。检查您尝试执行的操作是否可能与现有操作符组合在一起(例如，第一个任务是SubmitXXOperator，第二个任务是SensorXXOperator)</p><p id="8eee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你真的觉得需要一个新的运营商，问问GitHub或slack上的Airflow社区，大多数情况下他们会给你一个现有运营商的办法。</p><p id="2936" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您绝对需要定制一个现有的操作符，扩展一个现有的类，不要从零开始重新创建一切。</p><p id="74ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ls">在我目前的公司中，我们只创建了1个操作符一个KubernetesResourceOperator(像configmap一样将yaml补丁应用到kubernetes资源)和一个BigQueryToXCOMOperator(在XCOM return_value中存储查询的第一行小结果)</em></p><p id="369e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 3.2)不要使用每一个现有的运营商(许多是低效的)</strong></p><p id="8509" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一些开源的airflow操作符只是助手(直接运行python代码，不触发对外部解决方案的操作)</p><p id="6801" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">示例如果您没有使用KubernetesExecutor或celerykubernetexecutor，则<strong class="kt ir"> SimpleHttpOperator </strong>或<strong class="kt ir"> GCSToGoogleDriveOperator </strong>使用python代码直接在您的airflow _ worker<em class="ls">上运行操作。</em></p><p id="4e3a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这种情况下，最好使用KubernetesPodOperator(运行一个容器来完成所需的操作),而不要使用这类操作符。</p><p id="fda9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 3.3)使用可延迟模式(异步操作器)</strong></p><p id="acd9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所有长时间运行的操作符<strong class="kt ir">(KubernetesPodOperator…)</strong>在被触发任务的整个运行过程中都在使用一个airflow_worker槽。因此，如果您想要同时运行50个<strong class="kt ir"> KubernetesPodOperator </strong>，并且您的airflow_worker最多可以运行6个操作符，那么您将需要9个airflow_worker节点。</p><p id="bed8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，如果您在可推迟模式下使用50<strong class="kt ir">KubernetesPodOperator</strong>，那么您只需要1个airflow _ triggerer节点和1个airflow_worker节点</p><p id="e2f1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 4)不要在您的气流部署中安装任何自定义依赖:</strong></p><p id="5adc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">唯一允许的依赖项是Airflow社区支持的提供者<strong class="kt ir">Apache-air flow-providers-XXX</strong></p><p id="2e7b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">比如:</p><p id="1385" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">-阿帕奇-气流供应商-cncf-kubernetes <br/> -阿帕奇-气流供应商-谷歌<br/> -阿帕奇-气流供应商-slack</p><p id="68d0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为只有这些软件包，气流社区才能确保与气流本身的良好兼容性。安装任何其他依赖项都会将部署置于危险的状态，并且在升级时会导致依赖项地狱。</p><p id="e951" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我不建议安装不属于<a class="ae ne" href="https://airflow.apache.org/docs/#providers-packages-docs-apache-airflow-providers-index-html" rel="noopener ugc nofollow" target="_blank">官方列表</a>的定制气流提供程序(也因为它们大多数是低效的助手操作程序，直接在你的气流工作程序中运行代码) :</p><p id="3e1b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">-https://pypi.org/project/airflow-dbt/<br/>-https://github . com/great-expectations/air flow-provider-great-expectations</p><p id="2dfa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 5) Airflow不是数据沿袭解决方案:</strong></p><p id="4eab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Airflow是一个运行操作符中定义的任务的调度程序，目前Airflow确实具有非常有限的(测试版)沿袭功能。这些允许气流与使用开放血统标准(如Marquez)的第三方解决方案集成。<br/>您应该绝对避免为此重新实施定制/自制的解决方案，无论这有多么诱人。</p><p id="b3fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 6) Airflow不是数据存储解决方案:</strong></p><p id="5444" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Airflow操作人员可以返回数据，Airflow会将这些数据存储在其内部数据库airflow_db中(由Postgresql等传统RDBS提供支持)。我们把airflow_db中存储的数据称为<strong class="kt ir"> XCOM </strong>。</p><p id="dcc3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是airflow_DB不应该存储定制数据，而应该只存储非常小的元数据(比如我们的BigQueryToXCOMOperator通常返回一个值，比如时间戳)。</p><p id="6954" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最佳实践是不从操作符返回数据。如果你有一个<strong class="kt ir">特例</strong>，其中操作者必须返回数据(比如一个多行的复杂json)，你需要使用一个定制的<strong class="kt ir"> xcom_backend </strong>来写数据，不是在airflow_db中，而是在另一个地方(比如S3或GCS)</p><p id="73d0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您的<strong class="kt ir"> custom_xcom_backend </strong>必须仅用于您明确选择的任务(注意，默认情况下，所有xcom都将使用xcom_backend)</p><p id="b3a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在所有情况下，如果您使用外部处理解决方案(如<strong class="kt ir"> KubernetesPodOperator)运行一个作业，那么该作业负责将结果写入存储</strong>(如S3、GCS)，路径取决于调度程序提供的上下文。</p><p id="927c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 7)不要将秘密放在气流变量或连接中:</strong></p><p id="17f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Airflow可以存储DAG可以使用模板访问的变量，因此DAG将总是在运行时检索变量的最新版本，对于连接也是如此。</p><p id="e1f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是如果一个变量或者一个连接存储了一个秘密值(比如一个私钥)，不要直接在Airflow中注册这个变量或者连接，你必须在一个秘密存储(金库，GCP秘密管理器……)中注册这个变量或者连接，并且在Airflow中使用一个<strong class="kt ir"> secret_backend </strong>。</p><p id="f14e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您的<strong class="kt ir"> custom_secret_backend </strong>必须仅检索您定义的变量或连接(注意，默认情况下，Airflow会首先尝试在custom_secret_backend中查找所有变量和连接的秘密，并给出正常Airflow变量或连接的警告日志)</p><p id="d8db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 8)你的工作必须在最大程度上不可知的调度:</strong></p><p id="4243" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你重新运行一个任务，它必须是<strong class="kt ir">幂等的</strong>，并且你必须能够在气流之外运行你的任务。</p><p id="2c5d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">示例:如果您有一个在S3上爬行API并编写结果的小作业，您必须能够在您计算机上的容器中运行该作业，因为该作业从env_vars或args获取所有上下文。这确保了气流和实际计算的完全解耦(调度器和任务实现之间的清晰边界)。</p><p id="982b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一个好的做法是在与Dag分开的存储库中对作业进行编码(因为Dag只需要知道实现作业的容器的名称和版本)。</p><p id="6c41" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后在作业存储库中:为每个作业关联一个小docker-compose，以便能够在固定的上下文中运行作业。</p><p id="2e49" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 9)不要将不同的气流元素一起展开:</strong></p><p id="6fbb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你用官方的头盔文件在K8S中部署气流，这是默认行为。</p><p id="3d31" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是如果您选择手动部署，那么您必须隔离airflow_scheduler、airflow_webserver和airflow_workers，以便您可以根据您的使用情况对它们进行扩展。</p><p id="5e34" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 10) LocalExecutor和KubernetesExecutor不灵活:</strong></p><p id="aaf8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">LocalExecutor只能垂直扩展，因为您将在与调度程序相同的位置运行任务(具有多个调度程序的HA并不意味着您应该有N个调度程序来水平扩展您的气流堆栈)。因此，不鼓励在生产环境中使用。</p><p id="59dd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">KubernetesExecutor会直接给K8S集群施加压力(每个任务一个新的pod！非常过分)，用那个执行器更难检测和解决伸缩问题。</p><p id="0b37" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> CeleryExecutor </strong>是一个很好的权衡，所有的操作符都将直接在airflow_workers中运行，并且只有当您使用KubernetesPodOperator时才在您的K8S中创建pod。</p><p id="c784" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">关于-&gt; <a class="ae ne" href="https://airflow.apache.org/docs/apache-airflow/stable/executor/index.html#executor-types" rel="noopener ugc nofollow" target="_blank">气流e </a> <a class="ae ne" href="https://airflow.apache.org/docs/apache-airflow/stable/executor/index.html#executor-types" rel="noopener ugc nofollow" target="_blank">执行器</a> <a class="ae ne" href="https://airflow.apache.org/docs/apache-airflow/stable/executor/index.html#executor-types" rel="noopener ugc nofollow" target="_blank">文档</a>的更多详细信息</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="64aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">谢谢，非常感谢所有阿帕奇气流委员会成员<br/>我的Github-&gt;<a class="ae ne" href="https://github.com/raphaelauv" rel="noopener ugc nofollow" target="_blank">https://github.com/raphaelauv</a></p><p id="5f27" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">*所有图片由作者提供*</p></div></div>    
</body>
</html>