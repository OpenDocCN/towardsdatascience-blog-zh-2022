<html>
<head>
<title>Building a Credit Card Fraud Detection Online Training Pipeline with River ML and Apache Flink</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用River ML和Apache Flink构建信用卡欺诈检测在线培训渠道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-credit-card-fraud-detection-online-training-pipeline-with-river-ml-and-apache-flink-25549b89583d#2022-04-30">https://towardsdatascience.com/building-a-credit-card-fraud-detection-online-training-pipeline-with-river-ml-and-apache-flink-25549b89583d#2022-04-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d781" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在本教程中，我们将回顾如何编写实时python Apache Flink应用程序来训练一个在线模型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/27eb1ef2a1798cde1c3b8664d0fb25b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kiiQmXyj-mnmQzF_vafZrw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://www.pexels.com/photo/natwest-atm-card-45111/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">的照片</a></p></figure><p id="e5da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，我们将使用的主要框架是:</p><ul class=""><li id="9ef1" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://flink.apache.org/flink-architecture.html" rel="noopener ugc nofollow" target="_blank"> Flink </a>:全分布式实时批处理框架</li><li id="5686" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">RiverML :在线学习图书馆</li><li id="0770" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://opensource.com/article/18/4/flask" rel="noopener ugc nofollow" target="_blank"> Flask </a>:用于构建RESTful微服务的开源python包</li></ul><p id="df9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">TL；DR:代码在</strong><a class="ae ky" href="https://github.com/BogdanCojocar/medium-articles/tree/master/pyflink_riverml" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">GitHub</strong></a><strong class="lb iu">上。</strong></p><h2 id="0036" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated"><strong class="ak">使用Apache Flink构建在线培训渠道的优势</strong></h2><p id="e0bb" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">通常我们在处理ML管道时至少有两个独立的过程。在第一阶段，我们用一段时间内收集的一些数据训练一个新的ML模型。这通常称为批量训练，根据数据量的不同，这可能是一个更慢、计算更密集的过程。在第二阶段，我们采用我们在训练中产生的模型，并在新数据上使用它来标记它，这一过程称为推理。近年来，一种新的范式出现了，它试图将训练和推理结合起来，它被称为<strong class="lb iu">在线训练</strong>。这有两个主要的好处。首先，我们不需要那么多的计算能力来进行训练，因此成本较低，并且ML流水线被简化。其次，用更多数据训练的改进的ML模型立即可用，并且在某些情况下，例如欺诈检测，这是非常重要的，因为它可以减少假阳性的情况，从而更快更好地检测欺诈。</p><p id="91aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的ML管道将有两个组件:使用Apache Flink完成的实时摄取部分，以及使用Flask和RiverML的ML服务部分，后者负责在线培训。我们将使用Apache Flink来读取数据，因为它是一个低延迟、高度可伸缩的平台，可用于大数据应用程序。Apache Flink最初是为JVM语言开发的，现在对python有了很好的支持，这就是我们将在本教程中使用的。所以让我们开始吧。</p><h2 id="50b5" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">步骤1:为所有依赖项设置python环境</h2><p id="e769" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我们将使用<code class="fe nh ni nj nk b">pipenv</code>在一个单独的环境中安装我们需要的所有python包。在我提供的github链接中，有一个我们将使用的Pipfile:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="97d2" class="mj mk it nk b gy np nq l nr ns">[[source]]<br/>url = "<a class="ae ky" href="https://pypi.org/simple" rel="noopener ugc nofollow" target="_blank">https://pypi.org/simple</a>"<br/>verify_ssl = true<br/>name = "pypi"</span><span id="f7c7" class="mj mk it nk b gy nt nq l nr ns">[packages]<br/>apache-flink = "*"<br/>river = "*"<br/>flask = "*"</span><span id="5198" class="mj mk it nk b gy nt nq l nr ns">[dev-packages]</span><span id="bd40" class="mj mk it nk b gy nt nq l nr ns">[requires]<br/>python_version = "3.6"</span></pre><p id="200c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，我们在python版本中使用了<code class="fe nh ni nj nk b">flink, river and flask</code>，这是一个很好的选择，可以让所有的依赖项相互兼容。</p><p id="e9a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要安装<code class="fe nh ni nj nk b">pipenv</code>只需运行:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="b545" class="mj mk it nk b gy np nq l nr ns">pip install --user pipenv</span></pre><p id="f48d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后在我们项目的根目录中，我们可以安装所有的库:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="b528" class="mj mk it nk b gy np nq l nr ns">pipenv install</span></pre><p id="c01d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了激活环境，我们使用shell命令:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="9d05" class="mj mk it nk b gy np nq l nr ns">pipenv shell</span></pre><p id="d16a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一切运行成功，您应该会看到环境被激活，如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/1b250d8fd37ccf933381d0081fbb022f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*w50Ez9Za-B3FciR5Zbj3xw.png"/></div></figure><h2 id="b6f1" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">步骤2:创建Apache Flink python消费者</h2><p id="15b7" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我们将为这一步创建一个简单的python脚本，它将读取输入的信用卡交易，并将调用RiverML欺诈检测系统，算法的结果将存储在一个文件中。对于输入数据，我们将使用包含2013年9月欧洲持卡人信用卡交易的数据集。该数据集显示了两天内发生的交易，其中284，807笔交易中有492笔欺诈。数据集高度不平衡，正类(欺诈)占所有交易的0.172%。这些数据可以在RiverML库中找到。</p><p id="2589" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先创建一个Apache Flink环境，这是我们摄取应用程序的入口点。这适用于我们想要创建的任何Apache Flink应用程序:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="5d9f" class="mj mk it nk b gy np nq l nr ns">env = StreamExecutionEnvironment.get_execution_environment()<br/># write all the data to one file<br/>env.set_parallelism(1)</span></pre><p id="3694" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一个完全分布式的框架，处理可以在多个线程上完成，但对于本教程的范围，我们将只使用一个线程，作为直接结果，只创建一个文件作为输出。</p><p id="3399" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将从信用卡数据中读取一些行，并将它们存储在一个列表中。我们将使用<code class="fe nh ni nj nk b">env.from_collection</code>将列表读入一个Flink数据流。对于本教程来说，这已经足够好了，但在生产环境中，我们可能会从Apache Kafka或AWS Kinesis等事件存储中读取这些数据，这将确保我们获得连续的记录流:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="b0a1" class="mj mk it nk b gy np nq l nr ns"># get the credit card data<br/>dataset = datasets.CreditCard()</span><span id="088d" class="mj mk it nk b gy nt nq l nr ns"># create a small collection of items<br/>i = 0<br/>num_of_items = 2000<br/>items = []<br/>for x, y in dataset:<br/>  if i == num_of_items:<br/>    break<br/>  i+=1<br/>  items.append((json.dumps(x), y))</span><span id="3f46" class="mj mk it nk b gy nt nq l nr ns">credit_stream = env.from_collection(<br/>        collection=items,<br/>        type_info=Types.ROW([Types.STRING(), Types.STRING()]))</span></pre><p id="cbe4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还会注意到，当我们创建Flink数据流时，我们还需要定义一个模式。在我们的例子中，我们使用代表两个字符串的<code class="fe nh ni nj nk b"> Types.ROW([Types.STRING(), Types.STRING()])</code>，第一个包含交易值，第二个是标签，可以是0(无欺诈)和1(欺诈)。一个交易记录的示例:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="78af" class="mj mk it nk b gy np nq l nr ns">'{Time=0.0, V21=-0.018306777944153, V20=0.251412098239705, V23=-0.110473910188767, V22=0.277837575558899, V25=0.128539358273528, V24=0.0669280749146731, V27=0.133558376740387, V26=-0.189114843888824, V1=-1.3598071336738, V2=-0.0727811733098497, V28=-0.0210530534538215, V3=2.53634673796914, V4=1.37815522427443, V5=-0.338320769942518, V6=0.462387777762292, V7=0.239598554061257, V8=0.0986979012610507, V9=0.363786969611213, Amount=149.62, V10=0.0907941719789316, V12=-0.617800855762348, V11=-0.551599533260813, V14=-0.311169353699879, V13=-0.991389847235408, V16=-0.470400525259478, V15=1.46817697209427, V18=0.0257905801985591, V17=0.207971241929242, V19=0.403992960255733}'</span></pre><p id="6956" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们使用数据流中的<code class="fe nh ni nj nk b">map</code>方法来调用欺诈服务。在本教程的后面，我们将回顾微服务的创建和启动，但现在我们需要知道端点是<code class="fe nh ni nj nk b"><a class="ae ky" href="http://localhost:9000/predict'" rel="noopener ugc nofollow" target="_blank">http://localhost:9000/predict</a></code>，我们发送的有效负载是<code class="fe nh ni nj nk b">{x: feature, y:label}</code>:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="4886" class="mj mk it nk b gy np nq l nr ns"># detect fraud in transactions<br/>fraud_data = credit_stream.map(lambda data: \<br/>        json.dumps(requests.post('<a class="ae ky" href="http://localhost:9000/predict'" rel="noopener ugc nofollow" target="_blank">http://localhost:9000/predict'</a>, \<br/>                   json={'x': data[0], 'y': data[1]}).json()),\ <br/>                   output_type=Types.STRING())</span></pre><p id="7ceb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后我们写出结果。我们可以注意到，我们使用<code class="fe nh ni nj nk b">fraud_data.sink_to</code>来写入文件。最后，我们还告诉Flink，我们已经准备好使用<code class="fe nh ni nj nk b">env.execute()</code>来执行流水线:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="0301" class="mj mk it nk b gy np nq l nr ns"># save the results to a file<br/>fraud_data.sink_to(<br/>  sink=FileSink.for_row_format(<br/>            base_path=output_path,<br/>            encoder=Encoder.simple_string_encoder())<br/>        .build())</span><span id="a3c0" class="mj mk it nk b gy nt nq l nr ns"># submit for execution<br/>env.execute()</span></pre><p id="653b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该文件应包含<code class="fe nh ni nj nk b">ROCAUC</code>指标和结果，false表示没有检测到欺诈:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="b23e" class="mj mk it nk b gy np nq l nr ns">{"performance": {"ROCAUC": 0.4934945788156797}, "result": false}</span></pre><h2 id="2df5" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">第三步:编写Flask在线培训微服务</h2><p id="7a7e" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我们将构建一个标准的REST服务来包装ML欺诈模型。这样做通常是为了让算法与摄取层松散耦合。如果我们需要部署另一个版本的模型，我们只需要在不干扰Flink消费者的情况下更新微服务。</p><p id="3fbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最初，我们创建一个包含所有ML对象的类，我们将使用这些对象与发送到服务的新数据进行交互。<code class="fe nh ni nj nk b">model</code>由一个标准定标器和一个逻辑回归分类器组成，前者将数据转换为零均值和单位方差，后者是检测欺诈等二元任务的最佳选择。我们还使用<code class="fe nh ni nj nk b">ROCAUC</code>度量来确定算法在当前迭代中的表现。</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="48b6" class="mj mk it nk b gy np nq l nr ns">class RiverML:<br/>    # fraud detection model<br/>    model = compose.Pipeline(<br/>        preprocessing.StandardScaler(),<br/>        linear_model.LogisticRegression()<br/>    )</span><span id="e20e" class="mj mk it nk b gy nt nq l nr ns">    # ROCAUC metric to score the model as it trains<br/>    metric = metrics.ROCAUC()<br/>fraud_model = RiverML()</span></pre><p id="d589" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们实际编写预测端点。这将是一个<code class="fe nh ni nj nk b">POST</code>，因为我们需要从用户那里检索数据。这里有几个重要的步骤。<code class="fe nh ni nj nk b">fraud_model.model.predict_one(x_data)</code>将对新交易进行预测。正如我们稍后将看到的，最初的预测不会很好，但是随着越来越多的数据被输入到模型中，它将给出更好的结果。然后，我们使用<code class="fe nh ni nj nk b">fraud_model.metric.update(y_data, y_pred)</code>来计算<code class="fe nh ni nj nk b">ROCAUC</code>指标，使用<code class="fe nh ni nj nk b">fraud_model.model.learn_one(x_data, y_data)</code>来更新带有正确标签的模型。如你所见，预测和学习都在一个应用程序中完成。</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="b0c5" class="mj mk it nk b gy np nq l nr ns"><a class="ae ky" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/predict', methods=['POST'])<br/>def predict():<br/>    # convert into dict<br/>    request_data = request.get_json()<br/>    x_data = json.loads(request_data['x'])<br/>    y_data = json.loads(request_data['y'])</span><span id="5ee7" class="mj mk it nk b gy nt nq l nr ns">    # do the prediction and score it<br/>    y_pred = fraud_model.model.predict_one(x_data)<br/>    metric = fraud_model.metric.update(y_data, y_pred)</span><span id="9ba7" class="mj mk it nk b gy nt nq l nr ns">    # update the model<br/>    model = fraud_model.model.learn_one(x_data, y_data)</span><span id="690e" class="mj mk it nk b gy nt nq l nr ns">    return jsonify({'result': y_pred, 'performance': {'ROCAUC': fraud_model.metric.get()}})</span></pre><p id="5531" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们发回一个JSON，其中包含实际的预测和模型的表现。</p><h2 id="d36d" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">第四步:全部运行</h2><p id="f56b" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">要运行我们刚刚编写的ML管道，首先我们需要运行flask应用程序。要在单独的终端运行中这样做:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="e41c" class="mj mk it nk b gy np nq l nr ns">python fraud_river_ml.py</span></pre><p id="9a59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该会看到类似下图的内容，flask告诉我们该服务可用:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/cb2a4fb42e1f95ace4abbc5a117a46b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jW5V-ys1qxAgvT8QoQIHBw.png"/></div></div></figure><p id="3252" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们还可以在单独的终端窗口中运行Apache Flink消费者:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="817b" class="mj mk it nk b gy np nq l nr ns">python flink_consumer.py --output data</span></pre><p id="9927" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个python脚本将使用<code class="fe nh ni nj nk b">--output</code>参数来定义我们存储结果的位置。这应该需要一分钟左右的时间，但是在这之后，脚本将完成运行，我们应该会在我们的位置找到一个文件。再次请注意，在生产环境中，flink消费者脚本不应该停止运行，因为它会消耗无限的数据。</p><p id="e6dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们查看输出文件，我们将会看到模型是如何随时间演变的。第一次迭代将有<code class="fe nh ni nj nk b">ROCAUC</code> -0.0:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="b736" class="mj mk it nk b gy np nq l nr ns">{"performance": {"ROCAUC": -0.0}, "result": false}<br/>{"performance": {"ROCAUC": -0.0}, "result": false}<br/>{"performance": {"ROCAUC": -0.0}, "result": true}<br/>{"performance": {"ROCAUC": -0.0}, "result": false}<br/>{"performance": {"ROCAUC": -0.0}, "result": true}<br/>{"performance": {"ROCAUC": -0.0}, "result": false}<br/>{"performance": {"ROCAUC": -0.0}, "result": false}<br/>{"performance": {"ROCAUC": -0.0}, "result": false}<br/>{"performance": {"ROCAUC": -0.0}, "result": false}<br/>{"performance": {"ROCAUC": -0.0}, "result": false}</span></pre><p id="cc68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，随着我们将越来越多的数据输入逻辑回归算法，这种情况将会得到改善:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="75e9" class="mj mk it nk b gy np nq l nr ns">{"performance": {"ROCAUC": 0.4992462311557789}, "result": false}<br/>{"performance": {"ROCAUC": 0.4992466097438473}, "result": false}<br/>{"performance": {"ROCAUC": 0.4992469879518072}, "result": false}<br/>{"performance": {"ROCAUC": 0.4992473657802308}, "result": false}<br/>{"performance": {"ROCAUC": 0.49924774322968907}, "result": false}<br/>{"performance": {"ROCAUC": 0.4992481203007519}, "result": false}<br/>{"performance": {"ROCAUC": 0.499248496993988}, "result": false}<br/>{"performance": {"ROCAUC": 0.4992488733099649}, "result": false}<br/>{"performance": {"ROCAUC": 0.49924924924924924}, "result": false}</span></pre><p id="20c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！我希望你喜欢这个教程，并发现它很有用！我们看到了如何使用Apache Flink编写python应用程序，如何使用River ML训练在线分类器，以及如何通过结合训练层和推理层来降低成本。这是可靠和可扩展的大数据ML应用程序的主干，我们可以在众多提供可扩展基础设施的云提供商(如AWS、GCP或Azure)之一的生产中部署这些应用程序。</p></div></div>    
</body>
</html>