<html>
<head>
<title>Kubeflow MLOps : Automatic pipeline deployment with CI / CD / CT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubeflow MLOps:通过CI / CD / CT实现自动管道部署</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/kubeflow-mlops-automatic-pipeline-deployment-with-ci-cd-ct-64aeec46cc33#2022-04-26">https://towardsdatascience.com/kubeflow-mlops-automatic-pipeline-deployment-with-ci-cd-ct-64aeec46cc33#2022-04-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="140b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">创建先进的Kubeflow管道，并通过持续集成、部署和培训实现其部署和更新的自动化</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b981e59d29b873c481281d744b7b62ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6k5eURomcpoZ_76M.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://pixabay.com/users/pcb-tech-2044000/" rel="noopener ugc nofollow" target="_blank"> PCB-Tech </a>在<a class="ae kv" href="https://pixabay.com/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄的照片</p></figure><p id="f6f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的<a class="ae kv" rel="noopener" target="_blank" href="/tutorial-basic-kubeflow-pipeline-from-scratch-5f0350dc1905">上一篇kubeflow文章</a>中，我们经历了以下几个必要的步骤来建立一个有效的管道:</p><ul class=""><li id="6a6a" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">创建一个Kuberneter集群</li><li id="537a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">安装Kubeflow</li><li id="1dac" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">创建容器注册表</li><li id="077c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">构建一个容器映像，并将其推送到您的注册表中</li><li id="a74d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">让Kubeflow访问您的S3桶</li><li id="68ee" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">用输入和输出工件创建Kubeflow组件</li><li id="fb06" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">创建一个Kubeflow管道，上传并运行它</li></ul><p id="9975" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您已经有一个安装了Kubeflow的功能正常的Kubernetes集群，您可以直接遵循本指南。如果你不知道，我强烈建议你看看我以前的文章。</p><p id="5aec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一次，我们将更进一步:</p><ul class=""><li id="a235" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">制作一个包含预处理、建模、推理和性能评估的高级流水线</li><li id="251c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">使用GitHub动作执行CI和CD</li><li id="5b6e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">将GitHub Actions连接到Kubeflow端点，并启动更新后的管道</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mg"><img src="../Images/b5cad11c81bf98dc87bd9ab9e2215be4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fJPFY4OqrJcu4s8QXlkkFw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">您将通过本文构建的Kubeflow管道。作者图片</p></figure><h1 id="c2a9" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">源数据集和GitHub报告</h1><p id="e0d0" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">在本文中，我们将使用来自西雅图建筑能源基准的数据，这些数据可以在<a class="ae kv" href="https://www.kaggle.com/datasets/city-of-seattle/sea-building-energy-benchmarking" rel="noopener ugc nofollow" target="_blank"> this Kaggle page </a>上找到，并建立一个模型来预测温室效应气体的总排放量，如<code class="fe ne nf ng nh b">TotalGHGEmissions.</code>栏所示</p><p id="5bb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个数据集由两个表组成，分别是2015年和2016年的观测值。我们将把它们储存在一个S3桶里，我们的管道将从这个桶里获得资源。如果您遵循了我以前的文章，那么您的Kubeflow服务器应该可以访问您的bucket。</p><p id="0775" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本指南中显示的所有代码都可以在<a class="ae kv" href="https://github.com/Anvil-Late/Kubeflow_advanced_pipeline" rel="noopener ugc nofollow" target="_blank">这个公共库</a>中找到。</p><h1 id="4776" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">高级管道—步骤1:组件</h1><blockquote class="ni nj nk"><p id="8e6b" class="kw kx nl ky b kz la jr lb lc ld ju le nm lg lh li nn lk ll lm no lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="iq">如果您已经知道如何创建Kubeflow组件和管道，可以直接进入本文的“上传管道”一章。</em> </strong></p></blockquote><p id="bc80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的管道将有以下步骤:</p><ul class=""><li id="b8fb" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">合并2015年和2016年的数据，并将结果分为训练集和测试集</li><li id="8cd7" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">数据清理、NaN填充和特征工程</li><li id="4b8d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">数据预处理和准备</li><li id="53f9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">模型建筑:SVM、随机森林和XGBoost</li><li id="5ecc" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">评估结果，选择最佳模型，训练并保存它</li><li id="7fae" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">预测</li></ul><p id="d166" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，所有这些步骤的代码都可以在我的repo的kf_utils文件夹中找到，但让我们详细说明其中一个，以便我们可以更好地理解Kubeflow的“语法”:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="a5ca" class="nr mi iq bd mj ns nt dn mn nu nv dp mr lf nw nx mt lj ny nz mv ln oa ob mx oc bi translated">这里发生了什么？</h2><p id="8bfa" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">我们要做的第一件事是导入描述op所需的包，并定义将成为op的<code class="fe ne nf ng nh b">evaluate_models()</code>函数。<br/>结构如下:</p><pre class="kg kh ki kj gt od nh oe of aw og bi"><span id="419d" class="nr mi iq nh b gy oh oi l oj ok">def function(input_1 : type, input_2 : type, …) -&gt; Output</span></pre><p id="073c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，输出是一个命名的元组，您可以在其中声明构成op输出的几个元素。这些是您稍后必须在代码中使用的名称，以保存工件。</p><p id="a325" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，对于csv文件这样的经典输出，这种简化的结构就足够了:</p><pre class="kg kh ki kj gt od nh oe of aw og bi"><span id="251b" class="nr mi iq nh b gy oh oi l oj ok">import kfp.components as comp<br/>def function(input_1 : type, input_2 : type, …, <br/>             csv_output : comp.OutputPath('csv')</span></pre><p id="7387" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，我们导入这个组件所必需的包，比如matplotlib。我在第一篇文章中解释了为什么导入是在函数内部而不是之前进行的。<br/>我还定义了我的easy_bar_plot函数；注意，一个好的做法是在repo内部的一个模块中定义它，但是这里我直接在函数中定义它，以使代码片段具有更好的可读性。</p><p id="7471" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">性能和最佳超参数是先前库伯流分量的伪影输出，它们被存储在字典中并被绘制。保存绘图，并根据最佳R2分数选择最佳模型。<br/>由于Kubeflow还不接受任何类型的绘图作为工件输出，一个变通的解决方案是将绘图上传到s3 bucket，这就是我们在第116和119行中所做的。</p><p id="31ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，当我定义函数时，我将输出指定为命名元组:<code class="fe ne nf ng nh b">NamedTuple('Outputs', [('best_model' : str), ('hyperparams' : dict)])</code>。Kubeflow将理解我的工件输出由2个元素组成，因此期望op函数返回2个对象。<br/>在第123行，我们确实返回了两个对象:<br/> <code class="fe ne nf ng nh b">return (best_model, best_models_hyperparams)</code> <br/> <code class="fe ne nf ng nh b">best_model</code>作为第一个返回的对象，它将被匹配到<code class="fe ne nf ng nh b">NamedTuple</code>的第一个元素，并被Kubeflow自动认为是一个字符串。</p><p id="5bf7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的最后一个代码块使用<code class="fe ne nf ng nh b">create_component_from_func</code>函数将python函数转换为实际的Kubeflow op，该函数以yaml文件的形式，将要转换的函数、输出路径和基本docker图像作为参数。在这里，我提供了一个我创建的光公众形象，如果你读了我以前的文章，你现在应该知道如何创建一个。</p><p id="7033" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的回购中，我所有的Kubeflow组件(他们的。py文件及其结果。yaml文件)存储在kf_utils目录中。</p><h1 id="8ec2" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">高级管道—步骤2:从组件到管道</h1><p id="5047" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">一旦创建了完成上述步骤的所有组件，您就可以创建下面的管道。由于我在上一篇文章中已经谈到了管道创建，所以我不会在这里过多地讨论细节。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="dd70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将把这段代码保存在“管道”目录中。</p><h1 id="9f93" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">上传管道</h1><p id="7d0c" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">我们现在需要将这个管道上传到Kubeflow。我们将上传的不是python文件，而是用shell命令创建的编译后的yaml文件:</p><pre class="kg kh ki kj gt od nh oe of aw og bi"><span id="ba07" class="nr mi iq nh b gy oh oi l oj ok">dsl-compile --py pipeline/pipeline.py --output pipeline/pipeline.yaml</span></pre><p id="fff1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在在“管道”目录中有了管道yaml。在我的上一篇文章中，我向您展示了如何使用中央仪表板将它上传到Kubeflow，但是这里我们将从python命令中完成。</p><p id="920d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是棘手的地方。连接到Kubeflow pipelines管理器的最简单、最不受平台限制的方法是打开一个客户端会话，如下所示:</p><pre class="kg kh ki kj gt od nh oe of aw og bi"><span id="ff1c" class="nr mi iq nh b gy oh oi l oj ok">client = kfp.Client(host=host, cookies=cookies)</span></pre><p id="1c8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">韩国自由党。Client()函数有两个参数，它们是:</p><ul class=""><li id="3d93" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">kubeflow主机端点应该是这样的:<br/> <code class="fe ne nf ng nh b">123-isitiosystem-istio-2af2-456.us-west-2.elb.amazonaws.com/pipeline</code> <br/>，这是您的中央仪表板的URL，后跟<code class="fe ne nf ng nh b">/pipeline</code></li><li id="78c5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">当您使用登录名和密码登录中央控制面板时，存储在浏览器中的身份验证cookie</li></ul><p id="6ab2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在代码中复制并粘贴cookie值来打开客户端会话，但这意味着每个人都可以清楚地看到它，而且cookie不可避免地会过期。为了弥补这一点，我们将使用beautiful soup登录仪表板并检索cookie。<br/>最后，我们希望使用GitHub动作来启动管道——这意味着登录、密码和URL可以作为秘密保存，并作为环境变量传递给python脚本。因此，我们的管道启动脚本将如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="2fad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行该脚本将创建或更新并启动您的Kubeflow管道。请注意，要实现这一点，您需要已经创建了一个Kubeflow实验，但这在中央仪表板中很容易做到，并且它们是可重用的。</p><p id="1a65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的回购协议中，这个脚本叫做<code class="fe ne nf ng nh b">run_pipeline.py</code>，在主目录中。</p><p id="ef1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在拥有了实现全自动流程所需的所有工具。</p><h1 id="dc0c" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">自动化—步骤1:准备GitHub秘密</h1><p id="3cf2" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated"><code class="fe ne nf ng nh b">run_pipeline.py</code>脚本将使用4个秘密值:</p><ul class=""><li id="24c3" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">URL:你的Kubeflow服务器URL，应该是这样的:<br/> <code class="fe ne nf ng nh b">123-isitiosystem-istio-2af2-456.us-west-2.elb.amazonaws.com</code></li><li id="9064" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">端点:kubeflow主机端点，看起来应该是这样的:<br/> <code class="fe ne nf ng nh b">123-isitiosystem-istio-2af2-456.us-west-2.elb.amazonaws.com/pipeline</code></li><li id="1753" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">电子邮件和密码:您的Kubeflow Dashboard Center日志</li></ul><p id="93d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">进入GitHub repo，进入设置，然后进入密码:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/bf6b362595973546360a6e370c8a545a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6bevPTgY64KHKkk8q5o_YA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">GitHub行动秘密。作者图片</p></figure><p id="778f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从那里，添加您的秘密。我们分别称之为KBFL_URL、KBFL_ENDPOINT、KBFL_LOGIN、KBFL_PASSWORD。</p><h1 id="8c9f" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">自动化—步骤2:设置GitHub操作</h1><p id="6f2b" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">点击“行动”。您应该在此页面上显示建议的操作。选择其中任何一个，例如名为“Python应用程序”的应用程序，然后单击“配置”。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/581e27e830f2619eb1343c8029638cfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*thOy11kaObMZRvGNlTey4w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">GitHub操作主页。作者图片</p></figure><p id="6ce3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的配置窗口中，用以下代码替换yaml代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="b759" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个动作做什么在主分支上的每个提交或合并请求上，GitHub动作将创建一个环境，安装python及其依赖项，安装kfp，用<code class="fe ne nf ng nh b">dsl-compile</code>重建管道，并使用从GitHub secrets导入的适当环境变量启动<code class="fe ne nf ng nh b">run_pipeline.py</code>脚本。</p><p id="a3a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在构建所有这些资产时，GitHub actions将执行CI / CD步骤，Kubeflow管道中的任何不一致将在<code class="fe ne nf ng nh b">dsl-compile</code>步骤中被检测到，并返回一个错误。</p><p id="a7ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果要实现连续训练(CT)，可以将<code class="fe ne nf ng nh b">run_pipeline.py</code>脚本中的<code class="fe ne nf ng nh b">client.run_pipeline()</code>调用改为<code class="fe ne nf ng nh b">client.create_recurring_run()</code>。</p><p id="7f3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在你知道了！当您需要修改管道的任何组件时，您可以创建一个分支，修改组件，运行组件脚本以重新创建op，提交并创建一个合并请求。GitHub将重新创建和上传管道，并在Kubeflow上发布，这都是自动化的。</p><h1 id="6b93" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">后续步骤</h1><p id="2dd4" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">就MLOps良好实践而言，这里的自动化并不是真正的CD和CT，但是您现在已经拥有了完成这项工作的所有必要工具。</p><p id="4ec0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从那里开始，下一步将是只有一个模型定期用<code class="fe ne nf ng nh b">client.create_recurring_run()</code>重新培训，这将使我们刚刚建立的您的培训管道。<br/>然后，您应该创建一个推理管道，该管道只加载模型并进行预测，这将允许您设置另一种类型的循环(或按需)运行，而不必每次都重新训练模型。最后，您还应该有一个监视管道，当它检测到模型性能下降时，就会触发训练管道。<br/>您还可以在您的CD中添加一个性能标准，这样您的GitHub操作只有在新添加的特性提高了模型的性能时才会成功。</p></div></div>    
</body>
</html>