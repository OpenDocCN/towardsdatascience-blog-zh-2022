<html>
<head>
<title>Sampling from a population of unknown size</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从未知规模的总体中抽样</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sampling-from-a-population-of-unknown-size-1b48fbfb3b33#2022-04-20">https://towardsdatascience.com/sampling-from-a-population-of-unknown-size-1b48fbfb3b33#2022-04-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1923" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">流式项目的统一采样算法介绍</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f008a49d08b8d57cbfee88dce9bb1462.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hsz8LI-kswBXjP03XH9JbA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">迪伦·诺尔特在<a class="ae kv" href="https://unsplash.com/s/photos/lottery?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h2 id="8046" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">取样任务</h2><p id="83b7" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">鲍勃在一家电子元件工厂从事质量控制工作。在他的任务中，每天他必须检查不同的产品，以识别可能的缺陷，并评估生产过程的整体平稳性。必须随机选择产品，并遵循统一的抽取概率(即<strong class="lu ir">统一抽样</strong>)。</p><p id="8d1c" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">但是产品出厂的数量<em class="ml"> N </em>每天都在变化，无法提前设定。此外，Bob不能等待所有的<em class="ml"> N </em>产品都出来:他必须在产品出来时进行检查，因此取样过程必须在线进行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/6c1a071afff4ba2cbf40801793f72f7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R-zeB7UNm_1EcakTbLQiuA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们需要采样流项目——按作者排序的图像</p></figure><p id="081a" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">显然，Bob需要一个策略来有效地完成他的任务。我们正在讨论从未知规模的总体中均匀抽样的问题。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h2 id="679a" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">问题的定义</h2><blockquote class="mz na nb"><p id="2756" class="ls lt ml lu b lv mm jr lx ly mn ju ma nc mo mc md nd mp mf mg ne mq mi mj mk ij bi translated">为了解决采样问题，我们需要一种算法，通过对先验未知的大小为<em class="iq"> n </em>的群体进行一次遍历，能够随机采样<em class="iq"> k </em>个对象而无需替换。</p></blockquote><p id="6cd0" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">作为附加要求，我们还将假设:</p><ul class=""><li id="7c84" class="nf ng iq lu b lv mm ly mn lf nh lj ni ln nj mk nk nl nm nn bi translated"><em class="ml"> n </em>是一个比<em class="ml"> k </em> ( <em class="ml"> n≫ k </em>)大得多的数，因此不可能将所有<em class="ml"> n </em>项存储在内存中并对其进行提取；</li><li id="2c02" class="nf ng iq lu b lv no ly np lf nq lj nr ln ns mk nk nl nm nn bi translated">该算法无法提取已经通过的项目。</li></ul><p id="d660" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">换句话说，该算法一次按顺序处理一个项目，并决定是否提取它。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h2 id="2e3e" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">该算法</h2><p id="a682" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">这种算法是存在的，它包括以下步骤:</p><ol class=""><li id="ffca" class="nf ng iq lu b lv mm ly mn lf nh lj ni ln nj mk nt nl nm nn bi translated">最初，Bob提取所有第一个<em class="ml"> k </em>项目(记住<em class="ml">n≫k</em>)；</li><li id="0422" class="nf ng iq lu b lv no ly np lf nq lj nr ln ns mk nt nl nm nn bi translated">然后，对于<em class="ml"> i &gt; k+1 </em>，他以等于<em class="ml"> k/n. </em>的概率提取第<em class="ml"> n个</em>乘积</li><li id="4db1" class="nf ng iq lu b lv no ly np lf nq lj nr ln ns mk nt nl nm nn bi translated">当一个新项目被添加到样本中时，在当前样本中随机选择的另一个项目相应地被丢弃。</li></ol><p id="baca" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">在此过程之后，每次迭代中提取的样本结果(以及一些近似值)在<em class="ml"> 1 </em>和<em class="ml"> n </em>之间均匀分布。</p><h2 id="3ded" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">算法的证明</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c82b1a9c040d6c21934000521db34cf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XJomkYtsiYr5nWIlDMnabQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@aaronburden?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Aaron Burden </a>在<a class="ae kv" href="https://unsplash.com/s/photos/writing?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="2c7c" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">有趣的是，我们可以把算法想象成一个<strong class="lu ir">马尔可夫链</strong>。按照这种方法，在步骤<em class="ml">的<strong class="lu ir">状态</strong>n</em>是包含到目前为止收集的项目的样本。处理新项目时，无论新项目是否添加到样本中，都会发生状态转换。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/f73bc89dc72b5017f2b11f36f17d2e1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z0q1Sx4PipCplY7aQM5jbA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">步骤n中的样本是介于1和n之间的自然数的子集-图片由作者提供</p></figure><p id="e29d" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">基于我们的算法如何工作，对于<em class="ml"> n &gt; k </em>的<strong class="lu ir">转移概率</strong>由下式给出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/99b5604a37c0940829cca223bf758b4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qsn-eZUaiL9_Ux20Y193LA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">步骤k后的转移概率-按作者分类的图像</p></figure><p id="4169" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">现在我们需要证明对于每一步<em class="ml"> n≥k </em>所有的状态都有相同的概率成为样本。我们可以通过<strong class="lu ir">归纳</strong>来证明。</p><p id="2b5e" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">因此，让我们假设在步骤<em class="ml"> n≥k </em>所有子集<em class="ml"> Sn </em>有相等的机会成为样本。因此，每个状态<em class="ml"> S </em>成为步骤<em class="ml"> n </em>的样本的概率为:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/08d87935be69eb133080e3003307b564.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MY-JD0R6dt6RLhHWLo654A.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">子集成为给定步骤中样本的概率-作者图片</p></figure><p id="fbca" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">在步骤<em class="ml"> n+1 </em>中，新样本<em class="ml"> S </em>可以与之前相同，也可以包含新项目。在第一种情况下，我们有一个概率:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/bf6b060778406a5d7a90d738259ba7f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t7A8A10kn6MDtXnmgBmRUw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">新样本与之前样本相同的概率-图片由作者提供</p></figure><p id="cab7" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">在第二种情况下，获得新样本的概率由下式给出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/5fddc12a4c968092e77cf8b7e0b51f0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xzLDfjBR1mtlQW4k3ItwsA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">新样本包含新项目的概率—按作者排序的图像</p></figure><p id="5235" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">因子<em class="ml"> 1/(n+1) </em>作为<em class="ml">k/(n+1)</em>——即提取新项目的概率——和<em class="ml">1/k</em>——给定样本元素被新项目替换的概率的乘积来获得。</p><p id="f913" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">公式中的因子<em class="ml"> n-k+1 </em>考虑了样本中第<em class="ml"> i个</em>项(以及该样本中不包含的<em class="ml"> n-k个</em>项之一)被新项<em class="ml"> n+1 </em>替换的所有可能子集。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/2cb5de103da98e2bd19ebea70ea429ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LSBAXVd1WPSkcPczYaQ-pw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">每个新样本都可以从以前的多个样本中派生出来——图片由作者提供</p></figure><p id="22fd" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">所以在每一步<em class="ml"> n≥k </em>我们都有总的<em class="ml"> n-k+2 </em>个新的可能样本，并且它们中的每一个都有相同的概率被选中。</p><p id="6c0a" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">作为归纳基础，我们在<em class="ml"> n=k </em>选取样本，根据我们的概率函数，选择概率为1(这是正确的，因为我们这里只有一个可能的子集)。神盾局。</p><h2 id="55d8" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">一个基本实现:算法R</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d1cb068d6ca5be7be21b1c72df0ea280.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xuYXa_IkVisFtyQlKvNV1w.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">劳拉·奥克尔在<a class="ae kv" href="https://unsplash.com/s/photos/gears?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="8109" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">记住了它的定义，就可以非常容易地编写一个工作算法，如下面的Python代码片段所示。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="2d68" class="kw kx iq nx b gy ob oc l od oe">import numpy as np</span><span id="6b0b" class="kw kx iq nx b gy of oc l od oe"># Sampling parameters.<br/>n_items = 1000<br/>sample_size = 10</span><span id="f096" class="kw kx iq nx b gy of oc l od oe">sample = np.zeros(sample_size, dtype = int)<br/>steps = np.arange(n_items)</span><span id="5fbe" class="kw kx iq nx b gy of oc l od oe"># Initial sample.<br/>for nn in range(sample_size):<br/>    sample[nn] = nn</span><span id="5d87" class="kw kx iq nx b gy of oc l od oe">for nn in range(sample_size, n_items):</span><span id="3304" class="kw kx iq nx b gy of oc l od oe"># Compute the current item.<br/>    ii = np.random.randint(0, nn, dtype = int)</span><span id="520f" class="kw kx iq nx b gy of oc l od oe">if ii &lt; sample_size:<br/>    sample[ii] = nn</span></pre><p id="a1ed" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">图中显示了<em class="ml"> n=1000 </em>和<em class="ml"> k=10 </em>的结果。我们可以看到，在项目被处理时，样本的元素随机地从一个索引迁移到另一个索引，尽管一些最早的元素可能会随着时间的推移而持续存在。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/de0e722469e942a788f2c12d89ab2001.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nGsdomKh4kUFYVyJP82QwA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">运行算法-按作者分类的图像</p></figure><p id="255c" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">上面讨论的实现通常被称为<strong class="lu ir">算法R </strong>，最初由A. Waterman提出，并由J. Vitter在[3]中讨论。由于每一项都需要一次计算，无论是否保留，这个算法的复杂度都是<strong class="lu ir"> <em class="ml"> O(n) </em> </strong> <em class="ml">。</em></p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h2 id="e9e4" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">一个优化的变体:算法L</h2><p id="543a" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">算法R属于<strong class="lu ir">储层取样</strong>系列，该系列包括设计用于从未知数量<em class="ml"> n </em>的总体中选择一个简单随机样本<em class="ml"> k </em>项目的算法，无需替换。</p><p id="b74f" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">所谓的<strong class="lu ir">算法L </strong>给出了算法R的优化变体。在【4】<a class="ae kv" href="https://en.wikipedia.org/wiki/Reservoir_sampling#cite_note-li-2" rel="noopener ugc nofollow" target="_blank"/>中讨论，该变量计算在下一个物品进入储槽之前有多少物品被丢弃:这是可能的，因为丢弃物品的数量根据<strong class="lu ir">几何分布</strong>分布，因此可以提前计算。这样一来，这个算法的复杂度降低到了<strong class="lu ir"><em class="ml">O(k(log(n/k)+1))</em></strong>。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h2 id="8c0a" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">其他变体:带权重的随机抽样</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ebdcd3dc6560b331eca23cbdbc12f7f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oi0v87kbv3YV2vNUJIte1A.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@saltsup?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Piret Ilver </a>在<a class="ae kv" href="https://unsplash.com/s/photos/balance?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="c73e" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">还有其他处理加权项目的变体。在这种情况下，权重与每个权重相关联。例如，一个人可能需要对Twitter上的帖子进行抽样，这些帖子的权重基于收到的浏览量(或互动量)。</p><p id="d9f3" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">我们可以看看为每一步定义两个不同选择概率的权重:</p><ol class=""><li id="1308" class="nf ng iq lu b lv mm ly mn lf nh lj ni ln nj mk nt nl nm nn bi translated">一个<strong class="lu ir">未被选中的项目</strong>被选中的概率与其权重与所有未被选中项目的权重之和的比值成正比；</li><li id="c5b2" class="nf ng iq lu b lv no ly np lf nq lj nr ln ns mk nt nl nm nn bi translated">任何<strong class="lu ir">项</strong>被选中的概率与其权重和<strong class="lu ir">所有权重之和的比值成正比。</strong></li></ol><p id="52da" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">基于所使用的定义，已经开发了几种具有不同效率的算法。仅提及其中的一些，算法<strong class="lu ir"> A-Res </strong>和<strong class="lu ir"> A-ExpJ </strong>用于定义1，<strong class="lu ir"> A-Chao </strong>和<strong class="lu ir"> A-Chao带跳转</strong>用于定义2。</p><p id="0647" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">对于这个问题的广泛评论，特别是从编程的角度，我推荐Startin的这个博客。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><p id="7c96" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">和往常一样，本文使用的代码可以在这里找到:<a class="ae kv" href="https://github.com/andrea-ci/misc-stuff" rel="noopener ugc nofollow" target="_blank">https://github.com/andrea-ci/misc-stuff</a>。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h2 id="52aa" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">参考</h2><p id="a666" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">[1]维基百科，<a class="ae kv" href="https://en.wikipedia.org/wiki/Reservoir_sampling" rel="noopener ugc nofollow" target="_blank">油藏取样</a></p><p id="cbd8" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">[2] StackExchange，<a class="ae kv" href="https://stats.stackexchange.com/questions/569647/algorithm-for-sampling-fixed-number-of-samples-from-a-finite-population" rel="noopener ugc nofollow" target="_blank">从有限总体中抽取固定数量样本的算法</a></p><p id="1e5c" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">[3] Vitter，Jeffrey S .，<a class="ae kv" href="http://www.cs.umd.edu/~samir/498/vitter.pdf" rel="noopener ugc nofollow" target="_blank">“储层随机抽样”</a>，1985年</p><p id="bfe0" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">[4]李，金鸿，<a class="ae kv" href="https://dl.acm.org/doi/10.1145/198429.198435" rel="noopener ugc nofollow" target="_blank">时间复杂度为O(n(1+log(N/n))) </a>，1994</p><p id="1ef7" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">[5]理查德·斯塔廷，<a class="ae kv" href="https://richardstartin.github.io/posts/reservoir-sampling" rel="noopener ugc nofollow" target="_blank">油藏取样</a></p></div></div>    
</body>
</html>