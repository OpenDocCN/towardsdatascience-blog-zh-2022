<html>
<head>
<title>Building a CRUD App with Flask and SQLAlchemy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Flask和SQLAlchemy构建CRUD应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-crud-app-with-flask-and-sqlalchemy-1d082741bc2b#2022-04-19">https://towardsdatascience.com/building-a-crud-app-with-flask-and-sqlalchemy-1d082741bc2b#2022-04-19</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="f429" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">关于构建书店CRUD应用程序后端的深入教程</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/7e7683e423e11bebdd1c7076c745070b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5QZ7z6FhVTzpk8xg9tHn1g.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">汤姆·赫曼斯在<a class="ae kz" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="8800" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">CRUD应用程序是一个网络应用程序，允许你创建、读取、更新和删除东西。这是web开发中非常常见的任务，对于学习如何构建web应用程序非常有用。</p><p id="9b82" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本教程中，你将学习如何在<a class="ae kz" href="https://flask.palletsprojects.com/en/2.1.x/" rel="noopener ugc nofollow" target="_blank"> Flask </a>中构建一个CRUD应用程序，结果将是一个书店web应用程序的工作后端。我们将定义服务来处理CRUD操作；RESTful bookshop API的获取、发布、上传和删除请求。</p><p id="73bb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">构建书店应用程序有助于学习，因为这是一个真实的例子，而不是一个玩具项目。</p><p id="a274" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">本教程基于<a class="ae kz" href="https://flask.palletsprojects.com/en/2.1.x/" rel="noopener ugc nofollow" target="_blank"> Flask </a>和<a class="ae kz" href="https://flask-sqlalchemy.palletsprojects.com/en/2.x/" rel="noopener ugc nofollow" target="_blank"> Flask-SQLAlchemy扩展</a>。</p><p id="5398" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Flask是一个使用Python构建web应用的微框架。这是一个非常轻量级的框架，易于学习和使用。</p><p id="e426" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">轻量级并不意味着Flask不强大。每当您想在应用程序中使用类似于<a class="ae kz" href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping" rel="noopener ugc nofollow" target="_blank"> ORM(对象关系映射)</a>的东西时，您可以使用Flask提供的扩展。在本教程中，我使用Flask-SQLAlchemy扩展创建了一个数据库和一个存储书籍的表。</p><p id="b79b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">SQLAlchemy是一个Python ORM(对象关系映射)库，它使得使用数据库变得容易。</p><p id="72f8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">目录:</p><ul class=""><li id="414a" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated"><a class="ae kz" href="#3d4c" rel="noopener ugc nofollow">设计数据库</a></li><li id="6f13" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><a class="ae kz" href="#2f79" rel="noopener ugc nofollow">构建API </a></li><li id="1c39" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><a class="ae kz" href="#e65d" rel="noopener ugc nofollow">安装依赖关系</a></li><li id="47b6" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><a class="ae kz" href="#776c" rel="noopener ugc nofollow">创建数据库模型</a></li><li id="b380" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><a class="ae kz" href="#9838" rel="noopener ugc nofollow">配置你的烧瓶应用</a></li><li id="9f35" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><a class="ae kz" href="#c8fc" rel="noopener ugc nofollow">设置获取请求</a></li><li id="ac34" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><a class="ae kz" href="#9e9a" rel="noopener ugc nofollow">向SQLAlchemy添加数据</a></li><li id="9f1c" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><a class="ae kz" href="#62b2" rel="noopener ugc nofollow">运行烧瓶应用程序</a></li><li id="a3dd" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><a class="ae kz" href="#d480" rel="noopener ugc nofollow">删除一本书</a></li><li id="d975" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><a class="ae kz" href="#d881" rel="noopener ugc nofollow">添加新书</a></li><li id="fd79" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><a class="ae kz" href="#fec5" rel="noopener ugc nofollow">更新一本书</a></li><li id="e61e" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><a class="ae kz" href="#d20e" rel="noopener ugc nofollow">结论</a></li></ul><h1 id="3d4c" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">设计数据库</h1><p id="bab7" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">在创建数据库之前，我们需要定义数据库模式和表。模式是数据库的元数据结构，而表是我们想要存储的实际数据。</p><p id="64fa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个项目的设计很简单:我们有一个名为<code class="fe nh ni nj nk b">books</code>的表来存储图书字段:isbn(图书的ISBN号)、标题、作者和价格。</p><p id="b208" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这些字段将通过SQLAlchemy ORM存储在数据库中。Flask API将使用这些字段作为CRUD操作的数据模型。</p><p id="e359" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面是一个UML图，显示了依赖于数据库模式的API中使用的函数:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nl"><img src="../Images/c314556280a1ea6060f19da6e7b61825.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/0*_vRkFY6NcR9xt0i0"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Flask应用程序调用了依赖于Book表的函数。(作者在Plantuml上设计的)</p></figure><p id="0d39" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">正如我们所见，Flask API有5个依赖于Book表的函数。您将看到这些函数如何从SQLAlchemy调用适当的方法。让我们首先看看我们是如何构造API函数的。这些函数将被Flask API调用，并用<code class="fe nh ni nj nk b">@app.route</code>装饰器进行装饰。每个的映射如下所示:</p><ul class=""><li id="7939" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated"><code class="fe nh ni nj nk b">get_books()</code>使用GET请求列出所有映射到<code class="fe nh ni nj nk b">/book/list</code> URL的书籍。</li><li id="dfb6" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><code class="fe nh ni nj nk b">get_book(isbn)</code>获取由我们传递给函数的URL参数<code class="fe nh ni nj nk b">isbn</code>定义的指定书籍。这个函数使用GET请求映射到<code class="fe nh ni nj nk b">/book/&lt;isbn&gt;</code> URL。</li><li id="8dd1" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><code class="fe nh ni nj nk b">create_book()</code>向数据库添加新书。这个函数使用POST请求映射到<code class="fe nh ni nj nk b">/book</code> URL。</li><li id="e2a1" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><code class="fe nh ni nj nk b">update_book(isbn)</code>使用PUT请求更新映射到<code class="fe nh ni nj nk b">/book/&lt;isbn&gt;</code> URL的指定图书。</li><li id="9e39" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><code class="fe nh ni nj nk b">delete_book(isbn)</code>使用删除请求删除映射到<code class="fe nh ni nj nk b">/book/&lt;isbn&gt;</code> URL的指定图书。</li></ul><h1 id="2f79" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">构建API</h1><p id="bcfe" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">为了跟进这个项目，您可以创建一个文件并将代码转储到其中。您还可以创建多个文件，并从这些文件中导入代码来分离关注点。</p><p id="c5a4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我更喜欢将API代码组织在多个文件中。原因是它有助于你保持代码的组织性，也有助于你保持代码的整洁。</p><p id="de28" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们创建一个名为<code class="fe nh ni nj nk b">bookshop</code>的文件夹。在该文件夹中，该项目的结构如下所示:</p><pre class="kk kl km kn gu nm nk nn no aw np bi"><span id="3508" class="nq ml iu nk b gz nr ns l nt nu"><strong class="nk iv">.</strong><br/><strong class="nk iv">├──</strong> app<br/><strong class="nk iv">│  </strong> ├── __init__.py<br/><strong class="nk iv">│  </strong> ├── models.py<br/><strong class="nk iv">│  </strong> └── routes.py<br/><strong class="nk iv">├──</strong> bookshop.py<br/><strong class="nk iv">├──</strong> config.py</span></pre><p id="686b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我试图在不使用<a class="ae kz" href="https://flask.palletsprojects.com/en/2.1.x/blueprints/" rel="noopener ugc nofollow" target="_blank">蓝图</a>的情况下将结构做得尽可能的小，我认为这对这个小应用来说太过了。以下是每个文件的分类:</p><ul class=""><li id="c776" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated"><code class="fe nh ni nj nk b">bookshop.py</code>是包含Flask API的主文件。</li><li id="00e8" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><code class="fe nh ni nj nk b">config.py</code>包含API的配置。</li><li id="52b9" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><code class="fe nh ni nj nk b">app/__init__.py</code>是包含数据库和应用程序实例的文件。</li><li id="858b" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><code class="fe nh ni nj nk b">app/models.py</code>包含数据库模式和ORM。</li><li id="d550" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><code class="fe nh ni nj nk b">app/routes.py</code>包含将由API调用的API函数。</li></ul><p id="23a9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们从<code class="fe nh ni nj nk b">app/models.py</code>文件开始创建数据库。</p><h1 id="e65d" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">安装依赖项</h1><p id="40c9" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">在创建db模型之前，让我们安装Flask和Flask-SQLAlchemy扩展。</p><p id="c246" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们也安装数据库引擎。在本教程中，您将使用MySQL，但也可以随意使用任何其他数据库引擎。SQLAlchemy支持MySQL、SQLite、Postgres等等。</p><p id="602c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于MySQL，安装PyMySQL库。</p><p id="1eeb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们全部安装:</p><pre class="kk kl km kn gu nm nk nn no aw np bi"><span id="9e93" class="nq ml iu nk b gz nr ns l nt nu"><strong class="nk iv">$</strong> pip install flask flask-sqlalchemy PyMySQL</span></pre><p id="dd39" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在是时候创建数据库了。</p><h1 id="776c" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">创建数据库模型</h1><p id="05cd" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">让我们如下定义<code class="fe nh ni nj nk b">app/models.py</code>文件中的数据库模型:</p><pre class="kk kl km kn gu nm nk nn no aw np bi"><span id="9224" class="nq ml iu nk b gz nr ns l nt nu">from . import db<br/></span><span id="1f02" class="nq ml iu nk b gz nv ns l nt nu"><strong class="nk iv">class</strong> Book(db.Model):<br/>    __tablename__ = 'books'<br/>    isbn = db.Column(db.Integer, primary_key=True)<br/>    author = db.Column(db.String(100), nullable=False)<br/>    title = db.Column(db.String(100), nullable=False)<br/>    price = db.Column(db.Float)</span><span id="4696" class="nq ml iu nk b gz nv ns l nt nu">    <strong class="nk iv">def</strong> to_json(self):<br/>        <strong class="nk iv">return</strong> {<br/>            'isbn': self.isbn,<br/>            'author': self.author,<br/>            'title': self.title,<br/>            'price': self.price<br/>        }</span></pre><p id="b150" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在该文件中，我们将表名定义为<code class="fe nh ni nj nk b">books</code>，将字段定义为:</p><ul class=""><li id="9f25" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated"><code class="fe nh ni nj nk b">isbn</code>:表格的主键。</li><li id="0a8d" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><code class="fe nh ni nj nk b">author</code>:图书作者，字符串字段，不可为空。它的长度限制在100个字符以内。</li><li id="79fe" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><code class="fe nh ni nj nk b">title</code>:书名，为必填字段，长度为100个字符。</li><li id="914a" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><code class="fe nh ni nj nk b">price</code>:书的价格，是一个浮点字段，可以为空。</li></ul><p id="00f6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里使用的<code class="fe nh ni nj nk b">to_json()</code>函数将Book对象转换为JSON对象，该对象可以在浏览器上返回给客户机。我们将在接下来的章节中看到更好的方法。</p><p id="37d3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">注意，<code class="fe nh ni nj nk b">Book</code>类是<code class="fe nh ni nj nk b">db.Model</code>类的子类。该<code class="fe nh ni nj nk b">db</code>实例在<code class="fe nh ni nj nk b">app/__init__.py</code>文件中定义如下:</p><pre class="kk kl km kn gu nm nk nn no aw np bi"><span id="1a7e" class="nq ml iu nk b gz nr ns l nt nu">from flask_sqlalchemy import SQLAlchemy</span><span id="050c" class="nq ml iu nk b gz nv ns l nt nu">db = SQLAlchemy()</span></pre><h1 id="9838" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">配置您的烧瓶应用程序</h1><p id="41b5" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">现在我们有了数据库模型，让我们为SQLAlchemy扩展配置Flask应用程序。</p><p id="80d4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">配置应用程序的最佳实践是创建并定义一个父配置类，该类将保存所有环境的通用配置。然后为您的环境创建子配置类的实例。在我们的例子中，我们将创建三个环境:开发、测试和生产。</p><p id="0efa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们看看实际情况:</p><pre class="kk kl km kn gu nm nk nn no aw np bi"><span id="95d9" class="nq ml iu nk b gz nr ns l nt nu">import os<br/></span><span id="3c2f" class="nq ml iu nk b gz nv ns l nt nu"><strong class="nk iv">class</strong> Config:<br/>    SQLALCHEMY_TRACK_MODIFICATIONS = False</span><span id="7a87" class="nq ml iu nk b gz nv ns l nt nu">    @staticmethod<br/>    <strong class="nk iv">def</strong> init_app(app):<br/>        <strong class="nk iv">pass</strong><br/></span><span id="75b4" class="nq ml iu nk b gz nv ns l nt nu"><strong class="nk iv">class</strong> DevelopmentConfig(Config):<br/>    DEBUG = True<br/>    SQLALCHEMY_DATABASE_URI = os.getenv("DEV_DATABASE_URL")<br/></span><span id="4f72" class="nq ml iu nk b gz nv ns l nt nu"><strong class="nk iv">class</strong> TestingConfig(Config):<br/>    TESTING = True<br/>    SQLALCHEMY_DATABASE_URI = os.getenv("TEST_DATABASE_URL")<br/></span><span id="679a" class="nq ml iu nk b gz nv ns l nt nu"><strong class="nk iv">class</strong> ProductionConfig(Config):<br/>    SQLALCHEMY_DATABASE_URI = os.getenv("DATABASE_URL")<br/></span><span id="e115" class="nq ml iu nk b gz nv ns l nt nu">config = {<br/>    "development": DevelopmentConfig,<br/>    "testing": TestingConfig,<br/>    "production": ProductionConfig,<br/>    "default": DevelopmentConfig<br/>}</span></pre><p id="c1e1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此<code class="fe nh ni nj nk b">Config</code>类保存了应用程序的全局配置，它们是:</p><ul class=""><li id="e510" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated"><code class="fe nh ni nj nk b">SQLALCHEMY_TRACK_MODIFICATIONS</code>设置为False，禁用修改跟踪系统。这是避免跟踪从Flask-SQLAlchemy到SQLAlchemy库的变化的开销的好方法。</li><li id="0baa" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><code class="fe nh ni nj nk b">init_app()</code>是一个静态方法，用于初始化应用程序配置。</li></ul><p id="924f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这个<code class="fe nh ni nj nk b">Config</code>父类之后，我们为每个环境创建了三个子类。每个环境都定义了适合该环境的配置。</p><p id="92a4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，我们有了<code class="fe nh ni nj nk b">config</code>字典，它将环境名映射到配置类。默认环境是我们将在本教程中使用的开发环境。</p><p id="7627" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe nh ni nj nk b">DevelopmentConfig</code>类将<code class="fe nh ni nj nk b">DEBUG</code>属性设置为True，因为如果API中有任何错误，我们希望在浏览器中看到调试消息。</p><p id="c989" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，它的<code class="fe nh ni nj nk b">SQLALCHEMY_DATABASE_URI</code>属性设置了数据库URL，这是我们为连接到数据库而定义的。</p><p id="6ae7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在我们的例子中，我们将数据库URL设置为环境变量<code class="fe nh ni nj nk b">DEV_DATABASE_URL</code>，这是MySQL数据库的URL。在终端上运行以下命令来定义env变量:</p><pre class="kk kl km kn gu nm nk nn no aw np bi"><span id="e2b0" class="nq ml iu nk b gz nr ns l nt nu"><strong class="nk iv">$</strong> export DEV_DATABASE_URL=mysql+pymysql://&lt;username&gt;:&lt;password&gt;@localhost:3306/flaskapp</span></pre><p id="9b1b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">其中<code class="fe nh ni nj nk b">&lt;username&gt;</code>和<code class="fe nh ni nj nk b">&lt;password&gt;</code>是MySQL数据库的凭证，<code class="fe nh ni nj nk b">flaskapp</code>是数据库的名称。请随意用您自己的值替换任何值。</p><p id="051c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您正在使用另一个数据库引擎，您可以将<code class="fe nh ni nj nk b">DEV_DATABASE_URL</code>更改为该数据库的适当URL。例如，如果您正在使用sqlite，您可以将其设置为<code class="fe nh ni nj nk b">sqlite:///&lt;path_to_db&gt;</code>。</p><p id="a8be" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在让我们导入配置字典并开始创建Flask应用程序。现在，<code class="fe nh ni nj nk b">app/__init__.py</code>文件如下所示:</p><pre class="kk kl km kn gu nm nk nn no aw np bi"><span id="1ace" class="nq ml iu nk b gz nr ns l nt nu">from flask import Flask<br/>from flask_sqlalchemy import SQLAlchemy<br/>from config import config</span><span id="7ec0" class="nq ml iu nk b gz nv ns l nt nu">db = SQLAlchemy()<br/></span><span id="8f24" class="nq ml iu nk b gz nv ns l nt nu"><strong class="nk iv">def</strong> create_app(config_name):<br/>    app = Flask(__name__)<br/>    app.config.from_object(config[config_name])<br/>    config[config_name].init_app(app)</span><span id="ad5a" class="nq ml iu nk b gz nv ns l nt nu">    db.init_app(app)<br/>    <strong class="nk iv">return</strong> app</span></pre><p id="3f37" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe nh ni nj nk b">create_app()</code>函数用于创建基于环境的应用实例，该环境通过<code class="fe nh ni nj nk b">config_name</code>参数作为变量传递给函数。</p><p id="91e5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe nh ni nj nk b">app.config.from_object()</code>方法用于从<code class="fe nh ni nj nk b">config</code>字典加载配置。然后，该配置用于初始化应用程序。</p><p id="78e2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，用app实例初始化SQLAlchemy实例<code class="fe nh ni nj nk b">db</code>。</p><p id="aa8f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们为API设置第一个端点，它们是GET请求。</p><h1 id="c8fc" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">设置获取请求</h1><p id="1487" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">让我们将GET请求函数添加到<code class="fe nh ni nj nk b">app/routes.py</code>文件中:</p><pre class="kk kl km kn gu nm nk nn no aw np bi"><span id="c476" class="nq ml iu nk b gz nr ns l nt nu">import os<br/>from . import create_app<br/>from .models import Book<br/>from flask import jsonify</span><span id="17a9" class="nq ml iu nk b gz nv ns l nt nu">app = create_app(os.getenv('FLASK_CONFIG') <strong class="nk iv">or</strong> 'default')<br/></span><span id="efc9" class="nq ml iu nk b gz nv ns l nt nu">@app.route("/book/list", methods=["GET"])<br/><strong class="nk iv">def</strong> get_books():<br/>    books = Book.query.<strong class="nk iv">all</strong>()<br/>    <strong class="nk iv">return</strong> jsonify([book.to_json() <strong class="nk iv">for</strong> book <strong class="nk iv">in</strong> books])<br/></span><span id="0937" class="nq ml iu nk b gz nv ns l nt nu">@app.route("/book/&lt;int:isbn&gt;", methods=["GET"])<br/><strong class="nk iv">def</strong> get_book(isbn):<br/>    book = Book.query.get(isbn)<br/>    <strong class="nk iv">if</strong> book <strong class="nk iv">is</strong> None:<br/>        abort(404)<br/>    <strong class="nk iv">return</strong> jsonify(book.to_json())</span></pre><p id="3516" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe nh ni nj nk b">create_app()</code>函数实例化应用程序实例，然后使用<code class="fe nh ni nj nk b">app.route()</code>装饰器注册端点。在<code class="fe nh ni nj nk b">get_books()</code>方法中，我们使用<code class="fe nh ni nj nk b">Book.query.all()</code>查询所有书籍的数据库，然后使用<code class="fe nh ni nj nk b">jsonify()</code>函数返回所有书籍的JSON表示；它是一个帮助器函数，将Python对象序列化为JSON。</p><p id="cd73" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，让我们在运行应用程序之前通过SQLAlchemy添加一些数据。</p><h1 id="9e9a" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">向SQLAlchemy添加数据</h1><p id="08a1" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">向数据库添加数据的一种方法是打开一个Flask交互式shell，然后创建一个新的<code class="fe nh ni nj nk b">Book</code>模型实例。</p><p id="201a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们通过运行:</p><pre class="kk kl km kn gu nm nk nn no aw np bi"><span id="5dd5" class="nq ml iu nk b gz nr ns l nt nu">$ flask shell</span></pre><p id="a67a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此命令为您打开一个交互式会话来执行Python命令。这对调试和测试您的代码很有帮助。</p><p id="b423" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们现在在壳里面。让我们导入<code class="fe nh ni nj nk b">db</code>实例和<code class="fe nh ni nj nk b">Book</code>模型:</p><pre class="kk kl km kn gu nm nk nn no aw np bi"><span id="f840" class="nq ml iu nk b gz nr ns l nt nu">&gt;&gt;&gt; from app import db<br/>&gt;&gt;&gt; db<br/>&lt;SQLAlchemy engine=mysql+pymysql://root:***@localhost:3306/flaskapp?charset=utf8&gt;<br/>&gt;&gt;&gt; from app.models import Book<br/>&gt;&gt;&gt; Book<br/>&lt;<strong class="nk iv">class</strong> 'app.models.Book'&gt;</span></pre><p id="7c0a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">假设已经在您的机器上创建了<code class="fe nh ni nj nk b">flaskapp</code>数据库，让我们在数据库中创建<code class="fe nh ni nj nk b">Book</code>表，然后定义一个新的book:</p><pre class="kk kl km kn gu nm nk nn no aw np bi"><span id="e03f" class="nq ml iu nk b gz nr ns l nt nu">&gt;&gt;&gt; db.create_all()<br/>&gt;&gt;&gt; book = Book(author="Ezz", title="Cleaner Python", price=0.0)<br/>&gt;&gt;&gt; book<br/>&lt;app.models.Book <strong class="nk iv">object</strong> at 0x7f404a052e50&gt;<br/>&gt;&gt;&gt; db.session.add(book)<br/>&gt;&gt;&gt; db.session.commit()</span></pre><p id="b957" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以现在已经用<code class="fe nh ni nj nk b">db.create_all()</code>创建了<code class="fe nh ni nj nk b">Book</code>表，它创建了所有属于<code class="fe nh ni nj nk b">db.Model</code>子类的表。</p><p id="963c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用<code class="fe nh ni nj nk b">db.session.add()</code>将<code class="fe nh ni nj nk b">book</code>变量添加到数据库中。注意，将book对象添加到数据库中并不意味着您可以查询它。它还没有<em class="nw">提交</em>到数据库。这就是为什么我们需要运行<code class="fe nh ni nj nk b">db.session.commit()</code>来提交我们对数据库所做的更改。</p><p id="f9f3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们再创作一本书:</p><pre class="kk kl km kn gu nm nk nn no aw np bi"><span id="08ba" class="nq ml iu nk b gz nr ns l nt nu">&gt;&gt;&gt; book2 = Book(author="Ahmed", title="Python", price=10.99)<br/>&gt;&gt;&gt; db.session.add(book2)<br/>&gt;&gt;&gt; db.session.commit()</span></pre><p id="67dc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以现在我们书店里有两本书。这将足以演示如何列出和使用API。</p><p id="02ca" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们用<code class="fe nh ni nj nk b">Ctrl+C</code>(或<code class="fe nh ni nj nk b">CMD+C</code>)关闭外壳，返回我们的终端运行app。</p><h1 id="62b2" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">运行烧瓶应用程序</h1><p id="7cfb" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">您可以通过在终端上运行以下命令来运行该应用程序:</p><pre class="kk kl km kn gu nm nk nn no aw np bi"><span id="c583" class="nq ml iu nk b gz nr ns l nt nu"><strong class="nk iv">$</strong> export FLASK_APP=bookshop.py<br/><strong class="nk iv">$</strong> flask run</span></pre><p id="54a0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">第一个命令定义了<code class="fe nh ni nj nk b">FLASK_APP</code>环境变量指向<code class="fe nh ni nj nk b">bookshop.py</code>文件。但是当你做<code class="fe nh ni nj nk b">flask run</code>的时候，你会发现一个预期的错误。那个<code class="fe nh ni nj nk b">bookshop.py</code>文件是空的。让我们解决这个问题，从<code class="fe nh ni nj nk b">app/routes.py</code>文件导入<code class="fe nh ni nj nk b">app</code>变量:</p><pre class="kk kl km kn gu nm nk nn no aw np bi"><span id="4156" class="nq ml iu nk b gz nr ns l nt nu">from app.routes import app</span></pre><p id="e329" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，您可以运行应用程序并在<code class="fe nh ni nj nk b"><a class="ae kz" href="http://localhost:5000/book/list." rel="noopener ugc nofollow" target="_blank">http://localhost:5000/book/list</a></code> <a class="ae kz" href="http://localhost:5000/book/list." rel="noopener ugc nofollow" target="_blank">公开API端点。</a></p><p id="2be5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这种情况下，您会发现以下JSON响应:</p><pre class="kk kl km kn gu nm nk nn no aw np bi"><span id="0875" class="nq ml iu nk b gz nr ns l nt nu">[<br/>  {<br/>    "author": "Ezz", <br/>    "isbn": 1, <br/>    "price": 0.0, <br/>    "title": "Cleaner Python"<br/>  }, <br/>  {<br/>    "author": "Ahmed", <br/>    "isbn": 2, <br/>    "price": 10.99, <br/>    "title": "Python"<br/>  }<br/>]</span></pre><p id="349f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当您调用这个端点<code class="fe nh ni nj nk b">http://localhost:5000/book/1</code>时，您将得到第一本书:</p><pre class="kk kl km kn gu nm nk nn no aw np bi"><span id="5c97" class="nq ml iu nk b gz nr ns l nt nu">{<br/>  "author": "Ezz", <br/>  "isbn": 1, <br/>  "price": 0.0, <br/>  "title": "Cleaner Python"<br/>}</span></pre><p id="d6cf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">将<code class="fe nh ni nj nk b">1</code>替换为图书的ISBN，您将得到与您查询的图书相关的响应。</p><h1 id="d480" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">删除图书</h1><p id="b029" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">删除请求类似于我们对GET请求所做的。</p><p id="9ad7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们打开<code class="fe nh ni nj nk b">app/routes.py</code>文件并添加以下代码片段:</p><pre class="kk kl km kn gu nm nk nn no aw np bi"><span id="a568" class="nq ml iu nk b gz nr ns l nt nu">from . import db<br/>...</span><span id="771a" class="nq ml iu nk b gz nv ns l nt nu">@app.route("/book/&lt;int:isbn&gt;", methods=["DELETE"])<br/><strong class="nk iv">def</strong> delete_book(isbn):<br/>    book = Book.query.get(isbn)<br/>    <strong class="nk iv">if</strong> book <strong class="nk iv">is</strong> None:<br/>        abort(404)<br/>    db.session.delete(book)<br/>    db.session.commit()<br/>    <strong class="nk iv">return</strong> jsonify({'result': True})</span></pre><p id="28b3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里，我们使用<code class="fe nh ni nj nk b">db.session.delete(book)</code>从数据库中删除这本书，然后使用<code class="fe nh ni nj nk b">db.session.commit()</code>提交修改。</p><p id="d46f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你可能想知道如何测试，特别是因为<code class="fe nh ni nj nk b">DELETE</code>路线与<code class="fe nh ni nj nk b">GET</code>路线相同。要删除一本书，您需要使用<code class="fe nh ni nj nk b">curl</code>并选择<code class="fe nh ni nj nk b">DELETE</code>方法，因为默认情况下它会将请求视为<code class="fe nh ni nj nk b">GET</code>请求。</p><p id="3fa1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">例如，如果要删除第二本书，可以使用以下命令:</p><pre class="kk kl km kn gu nm nk nn no aw np bi"><span id="5d07" class="nq ml iu nk b gz nr ns l nt nu"><strong class="nk iv">$</strong> curl http://localhost:5000/book/2 -X DELETE<br/><strong class="nk iv">{</strong><br/>  "result"<strong class="nk iv">:</strong> true<br/><strong class="nk iv">}</strong></span></pre><p id="ba82" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它成功地返回了一个JSON响应，其中的<code class="fe nh ni nj nk b">result</code>键被设置为<code class="fe nh ni nj nk b">True</code>。</p><p id="da7e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以再次调用GET端点，通过查看URL: <code class="fe nh ni nj nk b">http://localhost:5000/book/list</code>或使用<code class="fe nh ni nj nk b">curl</code>命令来检查第二本书是否已经完成:</p><pre class="kk kl km kn gu nm nk nn no aw np bi"><span id="bf6e" class="nq ml iu nk b gz nr ns l nt nu"><strong class="nk iv">$</strong> curl http://localhost:5000/book/list<br/><strong class="nk iv">[</strong><br/>  {<br/>    "author": "Ezz", <br/>    "isbn": <strong class="nk iv">1,</strong> <br/>    "price"<strong class="nk iv">:</strong> 0.0, <br/>    "title"<strong class="nk iv">:</strong> "Cleaner Python"<br/>  }<br/><strong class="nk iv">]</strong></span></pre><p id="5bc7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它只给出了一本书的列表。第一个。</p><h1 id="d881" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">添加新书</h1><p id="6158" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">我们还可以通过使用<code class="fe nh ni nj nk b">POST</code>方法调用一个函数来向数据库添加一本新书。</p><pre class="kk kl km kn gu nm nk nn no aw np bi"><span id="f210" class="nq ml iu nk b gz nr ns l nt nu">from flask import request<br/>...</span><span id="63a1" class="nq ml iu nk b gz nv ns l nt nu">@app.route('/book', methods=['POST'])<br/><strong class="nk iv">def</strong> create_book():<br/>    <strong class="nk iv">if</strong> <strong class="nk iv">not</strong> request.json:<br/>        abort(400)<br/>    book = Book(<br/>        title=request.json.get('title'),<br/>        author=request.json.get('author'),<br/>        price=request.json.get('price')<br/>    )<br/>    db.session.add(book)<br/>    db.session.commit()<br/>    <strong class="nk iv">return</strong> jsonify(book.to_json()), 201</span></pre><p id="d081" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了测试添加一本新书，让我们使用<code class="fe nh ni nj nk b">curl</code>程序:</p><pre class="kk kl km kn gu nm nk nn no aw np bi"><span id="0cb6" class="nq ml iu nk b gz nr ns l nt nu"><strong class="nk iv">$</strong> curl -H "Content-Type: application/json" -X POST -d '{"title": "Learning", "author": "Ibrahim", "price": "3.44"}' http://localhost:5000/book<br/><strong class="nk iv">{</strong><br/>  "author"<strong class="nk iv">:</strong> "Ibrahim", <br/>  "isbn"<strong class="nk iv">:</strong> 3, <br/>  "price"<strong class="nk iv">:</strong> 3.44, <br/>  "title"<strong class="nk iv">:</strong> "Learning"<br/><strong class="nk iv">}</strong></span></pre><p id="466e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当然，我们也可以使用<code class="fe nh ni nj nk b">flask shell</code>添加新书。这种方法的问题是您必须导入<code class="fe nh ni nj nk b">db</code>和<code class="fe nh ni nj nk b">Book</code>实例。为了避免这种情况，现在的<code class="fe nh ni nj nk b">bookshop.py</code>文件应该如下所示(在添加了一个代码片段之后):</p><pre class="kk kl km kn gu nm nk nn no aw np bi"><span id="e872" class="nq ml iu nk b gz nr ns l nt nu">from app import db<br/>from app.routes import app<br/>from app.models import Book<br/></span><span id="c99f" class="nq ml iu nk b gz nv ns l nt nu">@app.shell_context_processor<br/><strong class="nk iv">def</strong> make_shell_context():<br/>    <strong class="nk iv">return</strong> <strong class="nk iv">dict</strong>(db=db, Book=Book)</span></pre><p id="84e6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe nh ni nj nk b">@app.shell_context_processor</code>装饰器用于注册一个函数，该函数将被调用来向shell会话注入变量。</p><p id="dc9c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe nh ni nj nk b">make_shell_context()</code>函数返回一个字典，其中包含我们需要添加到shell会话中的<code class="fe nh ni nj nk b">db</code>和<code class="fe nh ni nj nk b">Book</code>实例，这样我们就可以在shell中使用它们，而不必导入它们。</p><h1 id="fec5" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">更新图书</h1><p id="5a07" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">更新一本书类似于增加一本新书，除了我们使用<code class="fe nh ni nj nk b">PUT</code>方法而不是<code class="fe nh ni nj nk b">POST</code>。</p><p id="98ad" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们将以下内容添加到<code class="fe nh ni nj nk b">app/routes.py</code>文件中:</p><pre class="kk kl km kn gu nm nk nn no aw np bi"><span id="9e7b" class="nq ml iu nk b gz nr ns l nt nu">@app.route('/book/&lt;int:isbn&gt;', methods=['PUT'])<br/><strong class="nk iv">def</strong> update_book(isbn):<br/>    <strong class="nk iv">if</strong> <strong class="nk iv">not</strong> request.json:<br/>        abort(400)<br/>    book = Book.query.get(isbn)<br/>    <strong class="nk iv">if</strong> book <strong class="nk iv">is</strong> None:<br/>        abort(404)<br/>    book.title = request.json.get('title', book.title)<br/>    book.author = request.json.get('author', book.author)<br/>    book.price = request.json.get('price', book.price)<br/>    db.session.commit()<br/>    <strong class="nk iv">return</strong> jsonify(book.to_json())</span></pre><p id="3343" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了测试图书更新，让我们再次使用<code class="fe nh ni nj nk b">curl</code>:</p><pre class="kk kl km kn gu nm nk nn no aw np bi"><span id="8aa6" class="nq ml iu nk b gz nr ns l nt nu"><strong class="nk iv">$</strong> curl http://localhost:5000/book/3 -X PUT -H "Content-Type: application/json" -d '{"author": "Ahmed", "title": "Python for Beginners", "price": 12.99}'<br/><strong class="nk iv">{</strong><br/>  "author"<strong class="nk iv">:</strong> "Ahmed", <br/>  "isbn"<strong class="nk iv">:</strong> 3, <br/>  "price"<strong class="nk iv">:</strong> 12.99, <br/>  "title"<strong class="nk iv">:</strong> "Python for Beginners"<br/><strong class="nk iv">}</strong></span></pre><h1 id="d20e" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">结论</h1><p id="892b" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">本教程介绍了如何通过真实应用程序使用Flask创建RESTful API的基础知识。</p><p id="15bd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们已经看到了如何使用SQLAlchemy连接到数据库，如何创建模型，如何将模型映射到表，如何创建路由，如何使用<code class="fe nh ni nj nk b">curl</code>程序调用和测试API，以及如何使用<code class="fe nh ni nj nk b">flask shell</code>调试应用程序。</p><p id="9009" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们还讲述了如何从CRUD bookshop应用程序中读取、创建、更新和删除一本书。</p><p id="d4cb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你可以从<a class="ae kz" href="https://github.com/EzzEddin/tutorials/tree/master/backend_crud_flask_sqlalchemy" rel="noopener ugc nofollow" target="_blank">这个链接</a>获得本教程的完整代码。</p><p id="3414" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">想用Python写出干净的代码？</strong> <a class="ae kz" href="https://ezzeddin.gumroad.com/l/cleaner-python" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iv">下载免费清理器Python电子书</strong> </a> <strong class="lc iv">。它提供了5种方法来编写高效的Python代码。</strong></p></div></div>    
</body>
</html>