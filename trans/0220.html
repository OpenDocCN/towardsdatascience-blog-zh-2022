<html>
<head>
<title>Why Type Your Arguments In Python?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么用Python输入你的参数？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/why-type-your-arguments-in-python-5bf24d7201eb#2022-02-09">https://towardsdatascience.com/why-type-your-arguments-in-python-5bf24d7201eb#2022-02-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3649" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么在Python中提供参数类型是有意义的一些令人信服的理由</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1b7ace6ab1a188b97c8436d704626ac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NSmTaiprWV4-NxnwdboLSQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由<a class="ae ky" href="https://pixabay.com/images/id-419043/" rel="noopener ugc nofollow" target="_blank"> sipa </a>在<a class="ae ky" href="http://pixabay.com" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上提供)</p></figure><h1 id="60e7" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">键入参数</h1><p id="1d74" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">与许多其他编程语言相比，无论何时用Python编写函数，你都不需要考虑类型。当然，对于在函数体中进行的任何函数调用或属性调用，仍然要考虑这些类型，但是不管怎样，在不需要将它们放入代码的情况下，考虑这些事情是很容易的。例如，下面的函数只打印一个值:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="3f6d" class="ms la it mo b gy mt mu l mv mw">def printer(x):<br/>    print(x)</span></pre><p id="4f2e" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">我们可以在任何数据类型上调用print，所以这个函数可以处理任何数据类型。我们真的根本不需要考虑提供什么类型。如果我们想指定x应该是某种类型，我们可以用一个冒号后跟一个类型来实现，例如</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="bfe5" class="ms la it mo b gy mt mu l mv mw">def printer(x : int):<br/>    print(x)</span></pre><p id="a3fa" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">从语法上来说，这不会对我们的代码产生任何影响。从执行的各个方面来看，这两个函数都会做完全相同的事情。如果我们通过这个函数传递一个浮点数或者一个字符串，我们不会得到一个错误。老实说，我认为Python肯定可以从Julian MethodError中受益，因为虽然可能不存在多重分派的预期，但仍然限制类型确实很有意义。MethodErrors可以提供关于所提供的参数的大量信息，使事情更容易检查或“猜测”,而无需文档。</p><p id="c7a1" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">我喜欢Julia的一点是，Julia的方法错误提供了你做错了什么的背景。Python只有ArgumentErrors，我想这可以被认为是类似的东西，但是想象一下如果你得到了类似的东西</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="f30c" class="ms la it mo b gy mt mu l mv mw">ArgumentError No method matching printer(x : int)<br/>closest candidates are<br/>printer(x : float)</span></pre><blockquote class="nc"><p id="dd73" class="nd ne it bd nf ng nh ni nj nk nl mm dk translated">或者我只是想让Python成为Julia，我不知道。</p></blockquote><p id="e164" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">在这两种情况下，ArgumentError与MethodError在语义上是不同的，尽管在这种情况下，我认为名称可以互换，因为是参数和方法共同造成了错误。</p><h1 id="d09f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">为什么要输入参数？</h1><p id="3fa3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">既然我们已经介绍了如何输入参数，并确定它在语言与数据的交互方面确实没有做很多事情，我们可能应该问为什么。我的意思是，如果为我们的参数设置一个类型除了占用空白空间之外没有任何作用，那么我们为什么还要花时间输入这些内容呢？</p><p id="8eb3" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">需要考虑的一件重要的事情是，大多数项目会被不止一个人阅读。在上面printer()函数的例子中，有一些类不能被这个函数打印。也就是说，所提供的这些类型的值很可能会导致一些令人困惑的错误输出，其中函数内部的另一个调用是用错误的类型调用的。此外，如果我们没有输入我们的参数，而其他人正在读取这个函数，除了参数的命名和函数调用之外，我们预期的类型就不明显了。也就是说，由于构造函数的原因，并不是所有的Python对象都包含在Python中，有些类型可能会导致很多问题。</p><p id="7bed" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">键入参数的另一个原因是它将为文档提供这些信息。Python有很多自动化的文档工具，大多数都利用了这一点。为了使用一个函数，人们需要知道的最重要的事情之一就是参数，以及参数的类型。考虑到这一点，文档指出应该为哪些参数提供什么类型可能是非常重要的。</p><p id="d167" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">我输入参数的最后一个原因是，通过函数装饰器，它使函数更加元可编程。一个很好的例子就是多调度模块，它实际上是一个非常棒的模块。如果您想了解更多关于该模块的信息，我实际上写了一整篇文章，以下是链接:</p><div class="nr ns gp gr nt nu"><a rel="noopener follow" target="_blank" href="/flawless-parametric-polymorphism-in-python-with-multipledispatch-f26b75d69c5f"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd iu gy z fp nz fr fs oa fu fw is bi translated">用multipledispatch实现Python中完美的参数多态性</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">使用Python的多重调度模块使我的生活多样化</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">towardsdatascience.com</p></div></div><div class="od l"><div class="oe l of og oh od oi ks nu"/></div></div></a></div><blockquote class="oj ok ol"><p id="db9f" class="lr ls om lt b lu mx ju lw lx my jx lz on mz mc md oo na mg mh op nb mk ml mm im bi translated">没有什么比多态更让我开心了。</p></blockquote></div><div class="ab cl oq or hx os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="im in io ip iq"><h1 id="da68" class="kz la it bd lb lc ox le lf lg oy li lj jz oz ka ll kc pa kd ln kf pb kg lp lq bi translated">结束语</h1><p id="5479" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi pc translated">在句法方面，我感到奇怪的是，来自其他语言的论元类型被公然忽略了。我觉得让Python解释器与参数类型进行更多的交互会很好，就像它与多分派模块的交互一样，但是我认为这有点主观，因为这是由Julia程序员提出的。也就是说，不管它实际上对您的Python代码做了什么，我确实认为将参数键入您的函数是一个好主意。</p><p id="2cd6" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">键入参数为函数提供了大量的上下文。我以前说过这句话，但现在我要再说一遍，函数最重要的部分是输入和输出。每当我想分解一个函数时，这总是我要去的地方——它需要什么，它给出什么，然后我们如何从它需要什么到它给出什么——这个概念表面上很简单。对这类事情有更多的背景是很好的，尤其是在我们与他人共享代码的情况下。这也包含在文档中，这更是键入你的论点的理由。感谢您的阅读，我希望现在有了这些阐述，您的功能最终会得到某种程度的改进！</p></div></div>    
</body>
</html>