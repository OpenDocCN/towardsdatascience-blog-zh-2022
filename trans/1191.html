<html>
<head>
<title>Optimize Python Performance with Better Data Storage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过更好的数据存储优化 Python 性能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/optimize-python-performance-with-better-data-storage-d119b43dd25a#2022-03-27">https://towardsdatascience.com/optimize-python-performance-with-better-data-storage-d119b43dd25a#2022-03-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8aae" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用更快更轻便的数据格式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eeda4c81e5c147b482de663a4833703a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gsb8vkmx7x-vzXgb"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">弗兰克·麦肯纳在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="93b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于其简单性，<strong class="lb iu"> CSV </strong>文件格式已经在许多 Python 项目中被普遍用作数据存储。不过，是<strong class="lb iu">大</strong>和<strong class="lb iu">慢</strong>！因此，如果您的项目变得更加广泛，那么不再使用 CSV 可能不是一个好主意。</p><p id="93ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为文本文件，<strong class="lb iu"> CSV </strong>占用<strong class="lb iu">更大的磁盘空间</strong>和<strong class="lb iu">更长的</strong> <strong class="lb iu">加载时间</strong> = &gt; <strong class="lb iu">性能更低。</strong>在本文中，两种更好的数据格式(<strong class="lb iu"> Parquet </strong>和<strong class="lb iu"> Feather) </strong>已经被证明在各个方面(读取时间、写入时间、磁盘存储)都优于 CSV，如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/f2f1fd2584499df9ed1d66e0f232f20b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jg_lIaYBuwtxwm06oi9HLQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd lw">CSV |拼花|羽毛性能概述—数据:500 万行&amp; 5 列</strong>(作者)</p></figure><p id="a0b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是[CSV]和[拼花地板或羽毛]之间的巨大差异。我们稍后将回到这次表演的细节。现在，让我们开始介绍拼花地板/羽毛文件格式。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h2 id="e8ea" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">拼花格式</h2><p id="f321" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">Parquet 是一种面向列的数据文件格式，提供了高效的数据压缩和编码方案，增强了批量处理复杂数据的性能。它最初是在 Apache Hadoop 生态系统中开发和使用的。后来，它被 Apache Spark 采用，并被 Amazon、Google 和 Microsoft 等云供应商广泛用于数据仓库。</p><p id="8fd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 Python 中，Pandas 模块本来就支持 Parquet，所以您可以直接在项目中集成 Parquet 的使用，如下例所示。</p><p id="ae47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nc">例如:</em></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="15ad" class="me mf it ne b gy ni nj l nk nl"># Import module<strong class="ne iu"><br/>import</strong> <strong class="ne iu">pandas</strong> <strong class="ne iu">as</strong> <strong class="ne iu">pd</strong></span><span id="be46" class="me mf it ne b gy nm nj l nk nl"># Read a Parquet file as df<br/><strong class="ne iu">df = pd.read_parquet('&lt;filename&gt;.parquet')</strong></span><span id="de8e" class="me mf it ne b gy nm nj l nk nl"># do something with df ...</span><span id="682d" class="me mf it ne b gy nm nj l nk nl"># Write df as a Parquet file<br/><strong class="ne iu">df.to_parquet(‘name.parquet’)</strong></span></pre></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h2 id="6787" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">羽化格式</h2><p id="3fb4" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">它是使用 Apache Arrow 开发的，用于快速、可互操作的帧存储。从 Pandas 1 . 1 . 0 版本开始，它原生支持羽毛格式。您可以像 CSV/Parquet 一样读取/写入羽毛文件格式。</p><p id="6a97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nc">例如:</em></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="107a" class="me mf it ne b gy ni nj l nk nl"># Import module<strong class="ne iu"><br/>import pandas as pd</strong></span><span id="907f" class="me mf it ne b gy nm nj l nk nl"># Read a Feather file as df<br/><strong class="ne iu">df = pd.read_feather('&lt;filename&gt;.feather')</strong></span><span id="480b" class="me mf it ne b gy nm nj l nk nl"># do something with df ...</span><span id="44f3" class="me mf it ne b gy nm nj l nk nl"># Write df as a Feature file<br/><strong class="ne iu">df = pd.to_feather('&lt;filename&gt;.feather')</strong></span></pre></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="e9bf" class="nn mf it bd mg no np nq mj nr ns nt mm jz nu ka mp kc nv kd ms kf nw kg mv nx bi translated">特性试验</h1><p id="6768" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">一个由五列五百万行随机数组成的数据帧被用来做性能测试(大约 500 Mb 大小的 CSV)。它是用 Numpy 模块生成的，如下面的脚本所示。测试是在谷歌实验室进行的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/6909c65cb1616bac64cb2344d16605b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G1Giyrm1npVpdOaVk2zZXw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd lw">为性能测试生成一个随机 df。</strong>(作者)</p></figure><h2 id="1379" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">书写时间比较</h2><p id="6e54" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">现在，让我们检查一下将随机生成的 500 万行数据帧写入 CSV |Parquet | Feather 所用的时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/bffb0f2c2c49377645462d0ac39c2c35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cafErDVPfuBEL8uj8g_EKw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将 500 万行熊猫的 df 写入 CSV | Parquet | Feather 文件。(作者)</p></figure><p id="06a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，我们可以看到，编写一个<strong class="lb iu">拼花和羽毛文件</strong>只需要大约 2 秒钟，而编写 CSV 文件需要 50 多秒钟！！<strong class="lb iu"> </strong> <br/> ( <strong class="lb iu"> ~快 25 倍</strong>)</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h2 id="5be6" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">阅读时间对比</h2><p id="6c29" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">接下来，我们来对比一下阅读速度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/f6cac2890ada03f573f5d16c7f19fda2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d3rqw8UZcNpj6HD8LpnrnA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd lw">读取时间对比— CSV |拼花|羽毛文件。</strong>(作者)</p></figure><p id="f8ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很明显，<strong class="lb iu">拼花和羽毛的</strong> <strong class="lb iu">读</strong>性能<strong class="lb iu">比 CSV<strong class="lb iu"/>好</strong>(快~12 倍)。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h2 id="1272" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">存储比较</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/fcc3007dfa8ccd7c48a98627fc3d1554.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G9V8Mk_wHu9ggTrlVnH8SQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd lw">储物对比— CSV |拼花|羽毛</strong>(作者)</p></figure><p id="cd65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">拼花和羽毛</strong>在磁盘空间上更轻<strong class="lb iu"> (~2.6 倍轻)</strong>。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="3804" class="nn mf it bd mg no np nq mj nr ns nt mm jz nu ka mp kc nv kd ms kf nw kg mv nx bi translated">拼花地板与羽毛</h1><h2 id="db55" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">用哪个？</h2><ul class=""><li id="2475" class="oc od it lb b lc mx lf my li oe lm of lq og lu oh oi oj ok bi translated"><strong class="lb iu">羽毛</strong>根据我在 Google Colab 的测试环境，读写性能略好。</li><li id="9a20" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated"><strong class="lb iu"> Parquet </strong>从网络读取时读取性能更好。</li><li id="9933" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated"><strong class="lb iu">羽</strong>搭配固态硬盘(SSD)性能更好。</li><li id="70b0" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">Parquet 与 Hadoop 系统有更好的互操作性。</li></ul><p id="f577" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，如果你的项目主要是在 Python 或者 R 上(没有集成 Hadoop)，并且有 SSD 作为数据存储，那就用 Feather 吧。否则，使用拼花地板。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="e4cf" class="nn mf it bd mg no np nq mj nr ns nt mm jz nu ka mp kc nv kd ms kf nw kg mv nx bi translated">结论</h1><p id="38c4" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">在 Python 中使用 Parquet 或 Feather 格式可以显著提高数据写入、读取和存储性能。</p><p id="0fc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢它，并发现它对你的日常工作或项目有用。如果你有任何问题，请随时联系我。</p><p id="3995" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于我和我所有的博客内容:<a class="ae ky" href="https://joets.medium.com/about-me-table-of-content-bc775e4f9dde" rel="noopener">链接</a></p><p id="e17a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">平安健康！</strong> <br/> <strong class="lb iu">感谢阅读。👋😄</strong></p></div></div>    
</body>
</html>