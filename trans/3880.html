<html>
<head>
<title>5 Things I Wish the Pandas Library Could Do</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我希望熊猫图书馆能做的5件事</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-things-i-wish-the-pandas-library-could-do-e9017c127779#2022-08-29">https://towardsdatascience.com/5-things-i-wish-the-pandas-library-could-do-e9017c127779#2022-08-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e72b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">讨论熊猫的五个微妙局限</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f038c88d23e2707aced13fe26b6ca0cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*V4eRjCCJ3g1OaYU3"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Georg Bommeli 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6a82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">多亏了<a class="ae kv" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Pandas </a>库，用Python处理、分析和处理表格数据从来没有像今天这样轻松和直接。</p><p id="390e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目前，Pandas API提供了广泛的功能集合来管理表格数据，旨在为几乎每个数据科学项目服务，例如:</p><ul class=""><li id="46a9" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">输入输出操作</li><li id="8d2d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">数据过滤</li><li id="5b93" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">表连接</li><li id="8781" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">数据可视化</li><li id="4a73" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">重复数据处理，等等，你可以在这里阅读<a class="ae kv" href="https://pandas.pydata.org/docs/user_guide/10min.html" rel="noopener ugc nofollow" target="_blank"/>。</li></ul><p id="2ce6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然Pandas确实是几乎所有使用表格数据的数据科学家的首选工具，但在我的项目中使用它让我意识到了它的一些主要警告/限制，我希望在本文中讨论这些。</p><p id="e01b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，这篇文章提出了我希望熊猫在现实世界的表格数据集领域能够做的五件事。</p><p id="3a74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文的亮点如下:</p><p id="23d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="#982d" rel="noopener ugc nofollow"> <strong class="ky ir"> #1我希望熊猫可以并行读取一个CSV文件</strong></a><strong class="ky ir"><br/></strong><a class="ae kv" href="#f012" rel="noopener ugc nofollow"><strong class="ky ir"># 2我希望熊猫可以一次读取多个CSV文件</strong></a><strong class="ky ir"><br/></strong><a class="ae kv" href="#f88c" rel="noopener ugc nofollow"><strong class="ky ir"># 3我希望熊猫数据帧使用更少的内存</strong></a><strong class="ky ir"><br/></strong><strong class="ky ir"># 4我希望熊猫可以用于大型数据集</strong> </p><p id="ed0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们开始吧🚀！</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="982d" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">#1我希望熊猫可以并行读取CSV文件</h1><p id="fa65" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">不幸的是，Pandas对CSV文件的输入/输出操作是序列化的，这意味着Pandas没有固有的多线程支持。</p><p id="8738" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，读取CSV文件上下文中的序列化意味着Pandas一次只能读取CSV文件中的一行(或一行)数据。下面的动画演示了这一点:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/3c3efad1c72c5520be75f0ff2f3b4337.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/1*2cE0tW6MpSL9o21DzWvsIw.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在熊猫中阅读CSV(GIF by author)注意:CSV文件是一个文本文件，上图并不是CSV的样子。这是为了直观地阐述观点。</p></figure><p id="8c1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和输入操作类似，输出操作也好不到哪里去。Pandas也以序列化的方式将数据帧存储到CSV文件中。</p><p id="99a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">串行输入和输出操作的过程使它变得非常低效和耗时。</p><h2 id="0462" class="nl mo iq bd mp nm nn dn mt no np dp mx lf nq nr mz lj ns nt nb ln nu nv nd nw bi translated">可能的替代方案</h2><p id="0e41" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">根据我的研究，有两种潜在的解决方案可以用来提高总的输入输出运行时间。</p><ul class=""><li id="99f1" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">更喜欢使用其他文件格式，如<strong class="ky ir">泡菜</strong>、<strong class="ky ir">拼花</strong>和<strong class="ky ir">羽毛</strong>来读取和存储数据帧。</li></ul><p id="3146" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了速度快之外，这些格式存储数据占用的磁盘内存也更少。请在下面我的博客中阅读有关这些文件格式的更多信息:</p><div class="nx ny gp gr nz oa"><a rel="noopener follow" target="_blank" href="/why-i-stopped-dumping-dataframes-to-a-csv-and-why-you-should-too-c0954c410f8f"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">为什么我停止向CSV转储数据帧，为什么您也应该这样做</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">是时候告别pd.to_csv()和pd.read_csv()了</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">towardsdatascience.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo kp oa"/></div></div></a></div><ul class=""><li id="cb4d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">使用像<a class="ae kv" href="https://datatable.readthedocs.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> DataTable </strong> </a>这样的库，它们不像Pandas，拥有并行化能力。</li></ul><p id="e585" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面我的博客中阅读更多关于数据表的内容:</p><div class="nx ny gp gr nz oa"><a rel="noopener follow" target="_blank" href="/its-time-to-say-goodbye-to-pd-read-csv-and-pd-to-csv-27fbc74e84c5"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">是时候告别pd.read_csv()和pd.to_csv()了</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">讨论熊猫的另一个重要警告</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">towardsdatascience.com</p></div></div><div class="oj l"><div class="op l ol om on oj oo kp oa"/></div></div></a></div><h1 id="f012" class="mn mo iq bd mp mq oq ms mt mu or mw mx jw os jx mz jz ot ka nb kc ou kd nd ne bi translated">#2我希望熊猫可以一次读取多个CSV文件</h1><p id="5daa" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">假设您有一个包含多个CSV文件的文件夹，您需要读取这些文件并将其作为Pandas数据帧导入。</p><p id="469f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Pandas中实现这一点的唯一方法是遍历文件列表，一个接一个地读取它们，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/0906d9ea588091bc0cff789889a04c22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*9cPCbiuow73SBR4kWHlpAg.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用熊猫读取多个CSV文件(GIF由作者提供)</p></figure><p id="3065" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的图示可以通过编程方式演示如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="13e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于Pandas中缺乏多线程支持，一组可能并行读取的文件应该一个接一个地读取，导致运行时间增加和资源利用不足。</p><h2 id="2cdf" class="nl mo iq bd mp nm nn dn mt no np dp mx lf nq nr mz lj ns nt nb ln nu nv nd nw bi translated">可能的替代方案</h2><p id="a026" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">DataTable库再次成为Pandas的一个很好的替代方案来解决这个限制。</p><p id="4173" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用DataTable，您可以高效地读取多个CSV文件。下面演示了这一点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oy ox l"/></div></figure><p id="4469" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面我的博客中阅读更多关于运行时性能的内容:</p><div class="nx ny gp gr nz oa"><a rel="noopener follow" target="_blank" href="/how-to-read-multiple-csv-files-non-iteratively-and-without-pandas-984fd954999c"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">如何非迭代地读取多个CSV文件(并且没有熊猫)</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">对熊猫的读CSV方法说不！</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">towardsdatascience.com</p></div></div><div class="oj l"><div class="oz l ol om on oj oo kp oa"/></div></div></a></div><h1 id="f88c" class="mn mo iq bd mp mq oq ms mt mu or mw mx jw os jx mz jz ot ka nb kc ou kd nd ne bi translated">#3我希望熊猫数据帧使用更少的内存</h1><p id="79bd" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">Pandas数据帧非常庞大，而且内存使用效率很低。例如，假设我们创建了一个包含两列的数据帧，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa ox l"/></div></figure><p id="28a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，让我们使用<code class="fe pb pc pd pe b">dtypes</code>属性确定Pandas分配给上述数据帧<code class="fe pb pc pd pe b">df</code>的两列的数据类型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pf ox l"/></div></figure><p id="10ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认情况下，Pandas总是将最高的内存数据类型分配给列。例如，一旦熊猫将上面的<code class="fe pb pc pd pe b">colA</code>解释为整数值，就有四个可能的子类别(有符号)可供选择:</p><ul class=""><li id="f3b5" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe pb pc pd pe b">int8</code> : 8位整数数据类型，跨越来自2⁷].-2⁷的整数</li><li id="b6a3" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe pb pc pd pe b">int16</code> : 16位整数数据类型，跨越从[-2 ⁵，2 ⁵].]的整数</li><li id="14c1" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe pb pc pd pe b">int32</code> : 32位整数数据类型，跨度为[-2，2 ]的整数。</li><li id="c7fc" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe pb pc pd pe b">int64</code> : 64位整数数据类型，跨越来自【2⁶-2⁶】的整数。</li></ul><p id="a042" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，Pandas将<code class="fe pb pc pd pe b">int64</code>指定为整数值列的数据类型，而不考虑列中当前值的范围。我们注意到<code class="fe pb pc pd pe b">colB</code>有类似的数据类型行为。</p><h2 id="8a81" class="nl mo iq bd mp nm nn dn mt no np dp mx lf nq nr mz lj ns nt nb ln nu nv nd nw bi translated">可能的替代方案</h2><p id="40bb" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">为了优化内存利用率，您可以探索一个方向，我称之为<strong class="ky ir"> min-max-reduce </strong>分析。</p><p id="61a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一步是找到感兴趣的列中的最小值和最大值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pg ox l"/></div></figure><p id="a78e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一步是删节(<strong class="ky ir"> reduce </strong>)列的数据类型。</p><p id="e9d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于当前范围的值可以被压缩到<code class="fe pb pc pd pe b">int16</code>数据类型中(因为-2 ⁵ &lt; 10000(最小值)&lt; 30000(最大值)&lt; 2 ⁵)，我们将使用<code class="fe pb pc pd pe b">astype()</code>方法将数据类型从<code class="fe pb pc pd pe b">int64</code>转换为<code class="fe pb pc pd pe b">int16</code>，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ph ox l"/></div></figure><p id="aa24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这个简单的单行数据类型转换，<code class="fe pb pc pd pe b">colA</code>列使用的总内存减少了大约<strong class="ky ir"> 40% </strong>。</p><p id="30be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过类似的<strong class="ky ir"> min-max-reduce </strong>分析，您还可以改变其他整型和浮点型列的数据类型。</p><p id="d885" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的博客中阅读更多关于内存优化技术的内容:</p><div class="nx ny gp gr nz oa"><a rel="noopener follow" target="_blank" href="/seven-killer-memory-optimization-techniques-every-pandas-user-should-know-64707348ab20"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">每个熊猫用户都应该知道的七个黑仔内存优化技术</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">优化熊猫记忆利用的简单技巧</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">towardsdatascience.com</p></div></div><div class="oj l"><div class="pi l ol om on oj oo kp oa"/></div></div></a></div><h1 id="f495" class="mn mo iq bd mp mq oq ms mt mu or mw mx jw os jx mz jz ot ka nb kc ou kd nd ne bi translated">#4我希望熊猫可以用于大型数据集</h1><p id="363e" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">如上所述，Pandas没有固有的多线程支持。因此，无论数据的规模如何，Pandas将始终坚持单核利用率，从而导致运行时间增加，这与数据的大小成正比。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/abf3564e0b46c3b33e5805314cb225db.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*ErJOmojNgn7naA4JNtyz3Q.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者的Doge meme(使用<a class="ae kv" href="https://imgflip.com/" rel="noopener ugc nofollow" target="_blank">imgflip.com</a>创建)</p></figure><p id="d167" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，考虑一个实验来研究数据帧大小和在数据帧上执行函数的运行时间之间的相关性。</p><p id="4c80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们从包含一千行和两列的随机数据帧开始。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pk ox l"/></div></figure><p id="7394" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们定义一个函数，它接受数据帧的一行并返回其总和。该功能实现如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pl ox l"/></div></figure><p id="0fe8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在每次迭代中，我们确定计算数据帧中每行总和的时间。为了消除随机性，我们将重复每次迭代<code class="fe pb pc pd pe b">runs</code>次。在每次迭代结束时，我们将把数据帧的大小增加两倍。</p><p id="14db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该实验在下面实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pm ox l"/></div></figure><p id="be0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下图描绘了迭代与运行时的关系图。随着每次迭代，数据帧的大小加倍，Pandas的运行时间也加倍，这表明Pandas的运行时间总是与数据帧的大小成比例，并且它从不采用并行化。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/88c0d1fc6068cb46a999ed5db1533c0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*xKvLI1RMohmNYHv1K0d1hA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">数据帧与运行时图(图片由作者提供)</p></figure><h2 id="2ea1" class="nl mo iq bd mp nm nn dn mt no np dp mx lf nq nr mz lj ns nt nb ln nu nv nd nw bi translated">可能的替代方案</h2><p id="1298" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">Pandas非常适合处理小型数据集。然而，随着数据规模和管道复杂性的增加，作为一名数据科学家，您应该避免利用它，因为上面讨论了其深刻的运行时警告。</p><p id="3b30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您的目标是将项目投入生产，PySpark是理想的方法。其他备选方案包括Terality、Vaex、DataTable和Dask——主要推荐用于大型数据集上Pandas的本地计算。</p><h1 id="f0fb" class="mn mo iq bd mp mq oq ms mt mu or mw mx jw os jx mz jz ot ka nb kc ou kd nd ne bi translated">#5我希望熊猫支持像SQL这样的条件连接(不知何故)</h1><p id="021c" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">使用SQL的人喜欢编写复杂的连接条件来合并表的自由，不是吗？</p><p id="ca1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顾名思义，条件连接超越了简单的基于等式的合并条件。换句话说，您可以在多个表的字段之间建立基于条件而不是相等的连接。</p><p id="b1e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，假设您有两个表，<code class="fe pb pc pd pe b">table1</code>和<code class="fe pb pc pd pe b">table2</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="po ox l"/></div></figure><p id="9318" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目标是基于以下条件连接这些表</p><pre class="kg kh ki kj gt pp pe pq pr aw ps bi"><span id="a5be" class="nl mo iq pe b gy pt pu l pv pw">(table1.col1 = table2.col1 + 2) and (table2.col2 &gt;= table2.col2 - 2) and (table2.col2 &lt;= table2.col2 + 2)</span></pre><h2 id="6ec2" class="nl mo iq bd mp nm nn dn mt no np dp mx lf nq nr mz lj ns nt nb ln nu nv nd nw bi translated">SQL连接</h2><p id="cabd" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">上面的条件连接在SQL中非常简单。SQL查询在下面实现，生成查询后的输出:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="px ox l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="py ox l"/></div></figure><h2 id="0dc8" class="nl mo iq bd mp nm nn dn mt no np dp mx lf nq nr mz lj ns nt nb ln nu nv nd nw bi translated">熊猫加入</h2><p id="4714" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">Pandas只能在数据帧上执行基于等式的连接。换句话说，只有当连接列中的值相同时，Pandas <code class="fe pb pc pd pe b">merge()</code>方法才会连接两个记录——消除了条件连接的范围。</p><p id="b1dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，使用Pandas的<code class="fe pb pc pd pe b">merge()</code>方法执行条件连接的几种方法是:</p><ol class=""><li id="a296" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr pz ly lz ma bi translated">使用联接条件中定义的操作创建联接列，并对新列执行合并。</li><li id="b5ff" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr pz ly lz ma bi translated">执行交叉连接并过滤数据帧。在大型数据集的情况下，这可能极具挑战性。</li></ol><p id="72f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面展示了方法1和方法2的组合。</p><p id="a2ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们创建两个数据帧来合并并定义连接条件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pl ox l"/></div></figure><pre class="kg kh ki kj gt pp pe pq pr aw ps bi"><span id="ddab" class="nl mo iq pe b gy pt pu l pv pw">(table1.col1 = table2.col3 + 2) and (table2.col2 &gt;= table2.col4 - 2) and (table2.col2 &lt;= table2.col4 + 2)</span></pre><p id="8eed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于连接条件由不等式组成，让我们暂时把它们放在一边，先对等式执行连接<code class="fe pb pc pd pe b">(table1.col1 = table2.col3 + 2)</code>。之后，我们将过滤结果，以纳入接下来的两个条件。</p><p id="0a00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们将在<code class="fe pb pc pd pe b">table2</code>中创建一个新列。姑且称之为<code class="fe pb pc pd pe b">col3_1</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="qa ox l"/></div></figure><p id="4ad8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们将对来自<code class="fe pb pc pd pe b">table1</code>的<code class="fe pb pc pd pe b">col1</code>和来自<code class="fe pb pc pd pe b">table2</code>的<code class="fe pb pc pd pe b">col3_1</code>执行连接，然后根据连接条件中剩余的条件过滤得到的记录。这在下面实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="qb ox l"/></div></figure><h2 id="1a92" class="nl mo iq bd mp nm nn dn mt no np dp mx lf nq nr mz lj ns nt nb ln nu nv nd nw bi translated">可能的替代方案</h2><p id="26bb" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">PandaSQL 是一个流行的python包，它混合了Pandas和SQL，允许您在python环境中利用SQL语法的强大功能。</p><p id="9ab8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，PandaSQL使您能够使用SQL语法查询pandas数据帧。要执行类似SQL的连接，可以探索PandaSQL。</p><p id="3114" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，在Pandas数据帧中使用SQL的便利性是以运行时间为代价的。我在之前的博文中讨论过这个问题:</p><div class="nx ny gp gr nz oa"><a rel="noopener follow" target="_blank" href="/the-downsides-of-pandasql-that-no-one-talks-about-9b63c664bef4"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">PandaSQL简介:没人谈论的缺点</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">熊猫+ SQL = PandaSQL =一塌糊涂</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">towardsdatascience.com</p></div></div><div class="oj l"><div class="qc l ol om on oj oo kp oa"/></div></div></a></div></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="1102" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">结论</h1><p id="8784" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">总之，在这篇文章中，我讨论了熊猫的五个主要局限性，以及如果你陷入其中任何一种情况时的解决方法。</p><p id="1f2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Pandas非常适合处理日常的表格数据分析、管理和处理。</p><p id="1615" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，假设您正在开发一个生产级别的解决方案，或者有大量的数据要处理。在这种情况下，Pandas将不会对您有太大的帮助，因为它没有并行化和资源利用不足的限制。</p><p id="3f7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">感谢阅读！</strong></p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qd"><img src="../Images/c66a749b792cc56b8a2515cd892afe9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/0*kXuZiiZ4_vls0Rie.jpg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者的迷因(使用<a class="ae kv" href="https://imgflip.com/" rel="noopener ugc nofollow" target="_blank">imgflip.com</a>创建)</p></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="a6f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://subscribepage.io/450q" rel="noopener ugc nofollow" target="_blank"> 🧑‍💻<strong class="ky ir">成为数据科学专家！获取包含450多个熊猫、NumPy和SQL问题的免费数据科学掌握工具包。</strong>T15】</a></p><p id="a47a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">✉️ <a class="ae kv" href="https://medium.com/subscribe/@avi_chawla" rel="noopener"> <strong class="ky ir">注册我的电子邮件列表</strong> </a>不要错过另一篇关于数据科学指南、技巧和提示、机器学习、SQL、Python等的文章。Medium会将我的下一篇文章直接发送到你的收件箱。</p></div></div>    
</body>
</html>