<html>
<head>
<title>Behind Oracles: Grover’s Algorithm &amp; Amplitude Amplification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">神谕背后:格罗弗算法和振幅放大</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/behind-oracles-grovers-algorithm-amplitude-amplification-46b928b46f1e#2022-08-24">https://towardsdatascience.com/behind-oracles-grovers-algorithm-amplitude-amplification-46b928b46f1e#2022-08-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="42c0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">捕捉高层次的想法以及如何为SAT实例实施oracle</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9eb9ad9e9a0fafbc4b828c89514f11e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Fa-QlTRZN0yaw2_p"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">特里·维里斯迪斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="fc1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi ls translated"><span class="l lt lu lv bm lw lx ly lz ma di">在我开始量子计算之旅的时候，我对“甲骨文”是什么感到困惑。通常，您会读到这样的内容:</span></p><blockquote class="mb"><p id="dcbd" class="mc md iq bd me mf mg mh mi mj mk lr dk translated">“(……)然后，多亏了神谕，你才能够找到解决办法。”</p></blockquote><p id="1a1e" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">最后，我唯一明白的是:</p><blockquote class="mb"><p id="e0f8" class="mc md iq bd me mf mg mh mi mj mk lr dk translated">“它能够(以某种方式)捕捉给定问题的解决方案”。</p></blockquote><p id="afa9" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">然而，我不知道怎么做。因此，出现了如下问题。</p><blockquote class="mq mr ms"><p id="f802" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated"><strong class="ky ir">这个“甲骨文”长什么样？</strong></p><p id="52ad" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated"><strong class="ky ir">如何识别我先验不知道的东西？</strong></p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">？？？。[ <a class="ae kv" href="https://giphy.com/" rel="noopener ugc nofollow" target="_blank"> Gif via Giphy </a> ]</p></figure><p id="58fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">这些都是合理的问题！</strong>我们会找出所有这些问题的答案！特别是:</p><ul class=""><li id="98eb" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated">我们将理解为什么神谕是重要的。</li><li id="f011" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">我们将抓住神谕背后的高层次直觉。</li><li id="31b3" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">我们将展示如何定义一个能够解决布尔可满足性问题(SAT)的预言</li><li id="f6e0" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">此外，将提供Qiskit中的实现！</li></ul></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="7b12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mt">在开始之前，你只需要几个先决条件:</em> </strong></p><ul class=""><li id="1d52" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated"><em class="mt">叠加是什么。</em></li><li id="4f8f" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated"><em class="mt">H，X，CX这样的量子门是什么？</em></li><li id="27f7" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated"><em class="mt">什么是量子电路。</em></li></ul></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><blockquote class="mq mr ms"><p id="e3f3" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">本文的<strong class="ky ir">目标</strong>是提供Grover算法的<strong class="ky ir">自包含</strong>表示。我们将<strong class="ky ir">尽可能避免数学细节</strong>，从而提供这种量子算法能力的实际想法。</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu my l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">开始吧！[ <a class="ae kv" href="https://giphy.com/" rel="noopener ugc nofollow" target="_blank"> Gif via Giphy </a> ]</p></figure></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="8934" class="nv nw iq bd nx ny nz oa ob oc od oe of jw og jx oh jz oi ka oj kc ok kd ol om bi translated">为什么这么重要？</h1><p id="be6a" class="pw-post-body-paragraph kw kx iq ky b kz on jr lb lc oo ju le lf op lh li lj oq ll lm ln or lp lq lr ij bi translated">“神谕”是格罗弗算法的一部分:最具破坏性的量子算法之一，也是量子计算吸引大量兴趣的原因之一。</p><h2 id="f711" class="os nw iq bd nx ot ou dn ob ov ow dp of lf ox oy oh lj oz pa oj ln pb pc ol pd bi translated">格罗弗算法的实力如何？</h2><p id="a469" class="pw-post-body-paragraph kw kx iq ky b kz on jr lb lc oo ju le lf op lh li lj oq ll lm ln or lp lq lr ij bi translated">假设我们需要在一组非结构化的<strong class="ky ir"> N </strong>元素中找到一个特定的目标元素。</p><p id="fdc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<strong class="ky ir">经典计算</strong>中，由于我们没有<strong class="ky ir">关于这个目标元素位置的先验知识</strong>，我们需要查看每一个元素。</p><p id="c5bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mt">例如，假设在一个未排序的数组中寻找数字3(图1)。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pe"><img src="../Images/66d2b3eeaab6b74416c001012a6cfd43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*MxxwHEVoxAXMHN_bwv2Xwg.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd pf">图一。</strong>寻找数字3。[作者Gif</p></figure><p id="bb3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代价是<em class="mt">O(</em><strong class="ky ir"><em class="mt">N</em></strong><em class="mt">)</em>(即在最坏的情况下，我们需要扫描所有的<strong class="ky ir"> N </strong>元素)。</p><p id="16f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<strong class="ky ir">量子</strong> <strong class="ky ir">计算</strong>中，得益于Grover算法，可以在<strong class="ky ir"> O </strong> (√N) <strong class="ky ir">中检索到解。</strong>相对于经典计算，我们实现了<strong class="ky ir">二次加速</strong>(图2)！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/849025ca6025d262cc1e93c0b8702b87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*IvRs1XxgLIA2mPgtTKoeGg.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd pf">图二。</strong>二次Vs线性加速。[图片由作者提供]</p></figure><h2 id="551c" class="os nw iq bd nx ot ou dn ob ov ow dp of lf ox oy oh lj oz pa oj ln pb pc ol pd bi translated">一点背景</h2><p id="4fe7" class="pw-post-body-paragraph kw kx iq ky b kz on jr lb lc oo ju le lf op lh li lj oq ll lm ln or lp lq lr ij bi translated">通常，量子计算机必须运行给定的量子算法不止一次。有时它们会返回正确的输出，有时则不会。</p><p id="cbf6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们的目标是增加(或"<strong class="ky ir">放大</strong>")获得正确输出的机会(图3)。</p><blockquote class="mq mr ms"><p id="4b0a" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated"><strong class="ky ir">重点是:</strong></p><p id="900b" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">我们想要量子计算机输出的概率分布，使得在算法的给定运行中获得<strong class="ky ir">解</strong>的<strong class="ky ir">概率</strong>比获得<strong class="ky ir">无效</strong> <strong class="ky ir">输出</strong>的<strong class="ky ir">高</strong> <strong class="ky ir">。</strong></p><p id="1de9" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">..因为得到错误输出的概率是非零的，所以可能需要更多的运行。</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/01971211ed8f51e7b8dc86ccb5dafec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*u2yAu-vPPEUMjl8GaL-d4A.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd pf">图三。</strong>概率分布。[图片由作者提供]</p></figure><h1 id="2d86" class="nv nw iq bd nx ny pi oa ob oc pj oe of jw pk jx oh jz pl ka oj kc pm kd ol om bi translated">格罗弗的积木</h1><p id="bbd8" class="pw-post-body-paragraph kw kx iq ky b kz on jr lb lc oo ju le lf op lh li lj oq ll lm ln or lp lq lr ij bi translated">格罗弗的算法由两部分组成:一个<strong class="ky ir">甲骨文</strong>和一个<strong class="ky ir">扩散器</strong>。</p><h2 id="c5d7" class="os nw iq bd nx ot ou dn ob ov ow dp of lf ox oy oh lj oz pa oj ln pb pc ol pd bi translated"><strong class="ak">甲骨文</strong></h2><ul class=""><li id="a28f" class="mz na iq ky b kz on lc oo lf pn lj po ln pp lr ne nf ng nh bi translated"><strong class="ky ir"> Oracle </strong>“标记”解决方案(图4)。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/884017bd6e11c7bf24cbe9f1d6d1ff47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*Z3DsB4O3ebJkVDtRfLRaVA.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd pf">图4。</strong>甲骨文标记解决方案。[图片由作者提供]</p></figure><p id="7e81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢oracle，我们能够在非结构化数据集的所有N个元素中标记出正确的元素。(<em class="mt">不要爪子！我将很快告诉你神谕是什么样子的</em> ❤)</p><blockquote class="mb"><p id="2d6c" class="mc md iq bd me mf mg mh mi mj mk lr dk translated">然而，仅有神谕是不够的。</p></blockquote><p id="49b0" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">其实神谕只是标记了正确的元素，并没有增加得到这个元素作为量子算法输出的概率。事实上，单独的神谕是没有用的，因为得到这个元素的概率是1/N(也就是随机的！).</p><h2 id="0c0b" class="os nw iq bd nx ot ou dn ob ov ow dp of lf ox oy oh lj oz pa oj ln pb pc ol pd bi translated">视觉示例</h2><p id="5cd9" class="pw-post-body-paragraph kw kx iq ky b kz on jr lb lc oo ju le lf op lh li lj oq ll lm ln or lp lq lr ij bi translated">假设我们有N=7个元素，我们寻找元素“三角形矩形”(即我们的解)。于是，我们套用了标注“三角形长方形”的甲骨文。</p><p id="2e87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是得到<strong class="ky ir">三角形矩形</strong>的概率是<strong class="ky ir"> 1/7 </strong>(图5)，和得到其他所有元素中的一个是一样的！:(</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/f99f570e3ec60aed9c57e8acb5b739b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*853tHs9tCMFD3cqAfN4rZg.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd pf">图5。</strong>甲骨文不影响得到解的概率。[图片由作者提供]</p></figure><p id="9053" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">扩散器来救援了！其实是能够增加得到<strong class="ky ir">三角形长方形</strong>的几率的！</p><h2 id="3827" class="os nw iq bd nx ot ou dn ob ov ow dp of lf ox oy oh lj oz pa oj ln pb pc ol pd bi translated">扩散器</h2><ul class=""><li id="e570" class="mz na iq ky b kz on lc oo lf pn lj po ln pp lr ne nf ng nh bi translated"><strong class="ky ir">扩散器</strong>“放大”溶液(图6)。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/8cdf4f72d9aa4ecab80e2b243cace950.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*bw3U7IX5hN9ij7gfAnj6pA.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd pf">图六。</strong>扩散器放大溶液。[图片由作者提供]</p></figure><p id="1e58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么扩散工程，是超出了本文的范围。对于那些好奇的人，我会在本文的最后给你提供一些参考。</p><p id="aeae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关键是它增加了oracle将元素标记为输出的机会(图7)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/5d64d906ffd8917c4cd8dcc28fe65430.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*7oqXzH0Ju_nRX8o5y8HvkQ.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd pf">图7。</strong>扩散器增加了将溶液作为输出的机会。[图片由作者提供]</p></figure><p id="1b31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，不要慌！每个oracle的扩散器实现都是相同的，我将在最后提供代码！保证！</p><p id="4a04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">我们可以将扩散器放在一边，然后回答这个问题:</strong></p><blockquote class="mb"><p id="f0c3" class="mc md iq bd me mf mg mh mi mj mk lr dk translated"><strong class="ak">“神谕长什么样”？</strong></p></blockquote><figure class="pr ps pt pu pv kk"><div class="bz fp l di"><div class="pw my l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">是我！[ <a class="ae kv" href="https://giphy.com/" rel="noopener ugc nofollow" target="_blank"> Gif via Giphy </a> ]</p></figure><h2 id="f7ab" class="os nw iq bd nx ot ou dn ob ov ow dp of lf ox oy oh lj oz pa oj ln pb pc ol pd bi translated">神谕背后</h2><p id="b755" class="pw-post-body-paragraph kw kx iq ky b kz on jr lb lc oo ju le lf op lh li lj oq ll lm ln or lp lq lr ij bi translated">我发现“甲骨文”这个名字有点误导。似乎有人只要问一句:“解决方案是什么？”就能给你解决方案。</p><p id="f513" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我更喜欢在脑海中描绘一个滤镜的形象！您可以手工制作一个过滤器，它具有您所寻找的元素的精确形状(图8)！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi px"><img src="../Images/43ee401ca3ce661ab189a8e05088303c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C7XkkMmQd4PdKXS8qP4Fxg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd pf">图8。</strong>甲骨文作为过滤器。[图片由作者提供]</p></figure><blockquote class="mq mr ms"><p id="6289" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">为什么是过滤器？</p></blockquote><p id="3d33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，在运行Grover的算法之前，在某种意义上，你拥有所有的元素(我将在后面解释<strong class="ky ir"> <em class="mt">如何</em> </strong>，但这相当简单)，你想过滤掉那些不是你的解的元素。</p><p id="5a08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">但是，请记住，你</strong>、<em class="mt">并且只有你</em>，仔细定义这个过滤器。</p><p id="ebc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，可能会出现一个问题</p><blockquote class="mq mr ms"><p id="d785" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">我必须设计一个能够捕捉解决方案并拒绝所有其他元素的过滤器。但是为了能找到答案，我需要知道答案，对吗？</p><p id="d645" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">因此，这意味着我已经知道了解决方案。所以…</p><p id="411b" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">这个算法有什么意义？</p></blockquote><p id="4f3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个合理的担忧！</p><h2 id="9f2c" class="os nw iq bd nx ot ou dn ob ov ow dp of lf ox oy oh lj oz pa oj ln pb pc ol pd bi translated">后退一步</h2><p id="c8e6" class="pw-post-body-paragraph kw kx iq ky b kz on jr lb lc oo ju le lf op lh li lj oq ll lm ln or lp lq lr ij bi translated">格罗弗算法的原名是“<em class="mt">一种用于数据库搜索的快速量子力学算法</em>”因此，我找到的例子是在一组数字中寻找一个数字。</p><p id="00c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想在一个数据集中找到数字3，你已经事先知道了答案。您正在定义一个oracle，它捕捉到数字3，输出是3。一开始没什么太激动人心的，对吧？</p><blockquote class="mq mr ms"><p id="f660" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated"><strong class="ky ir">【小注1】</strong>在Grover算法中，你需要先验地知道一个解的存在(实际上，你需要知道解的确切个数)。</p><p id="2059" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated"><strong class="ky ir">【小注2】</strong>还有其他的量子算法，找出给定问题的解的个数。然后，你可以使用格罗弗的算法。</p></blockquote></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h2 id="287d" class="os nw iq bd nx ot ou dn ob ov ow dp of lf ox oy oh lj oz pa oj ln pb pc ol pd bi translated">向前两步</h2><p id="f281" class="pw-post-body-paragraph kw kx iq ky b kz on jr lb lc oo ju le lf op lh li lj oq ll lm ln or lp lq lr ij bi translated"><strong class="ky ir">转折点是神谕可以是一个函数</strong>，而不仅仅是一个数字！在这种情况下，我们指的是幅度放大算法，我们可以将其想象为广义的Grover算法。</p><blockquote class="mq mr ms"><p id="095b" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">你对“神谕可以是一种功能”有什么打算？</p></blockquote><p id="cd18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">比如我们可以问我们的量子计算机:“<em class="mt">那个大于5小于6的元素</em>是什么？</p><blockquote class="mb"><p id="3158" class="mc md iq bd me mf mg mh mi mj mk lr dk translated">x &gt; 5 <strong class="ak"> ∧ </strong> x &lt; 6</p></blockquote><p id="7913" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">精神上的一步很小，但重点是我们不需要知道解决方案，这将是你的神谕！因此，获得了相对于经典强力算法的二次加速！现在是时候停止空谈，开始行动了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="py my l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们走吧！[ <a class="ae kv" href="https://giphy.com/" rel="noopener ugc nofollow" target="_blank"> Gif via Giphy </a> ]</p></figure><h1 id="6176" class="nv nw iq bd nx ny pi oa ob oc pj oe of jw pk jx oh jz pl ka oj kc pm kd ol om bi translated">用二次加速法求解SAT</h1><p id="9f08" class="pw-post-body-paragraph kw kx iq ky b kz on jr lb lc oo ju le lf op lh li lj oq ll lm ln or lp lq lr ij bi translated">SAT问题在于找到一个变量赋值，使得它满足一个给定的布尔公式。(我回忆你SAT属于<a class="ae kv" href="https://en.wikipedia.org/wiki/NP-completeness" rel="noopener ugc nofollow" target="_blank"> NP-complete </a>类，一个很有意思的问题！)</p><p id="ccae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如在(<strong class="ky ir"> </strong> x1 <strong class="ky ir"> ∧ </strong> x2)中，满足布尔公式的赋值为:</p><blockquote class="mb"><p id="7a4d" class="mc md iq bd me mf mg mh mi mj mk lr dk translated"><strong class="ak"><em class="pz">x1 =假，x2 =真</em> </strong></p></blockquote><p id="18fa" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">特别地，我们关注布尔公式的一种特殊形式，即<strong class="ky ir">合取范式</strong> ( <strong class="ky ir"> CNF </strong>)或<strong class="ky ir">子句范式。</strong></p><h2 id="8940" class="os nw iq bd nx ot ou dn ob ov ow dp of lf ox oy oh lj oz pa oj ln pb pc ol pd bi translated">CNF刷新</h2><p id="57b5" class="pw-post-body-paragraph kw kx iq ky b kz on jr lb lc oo ju le lf op lh li lj oq ll lm ln or lp lq lr ij bi translated">CNF由一个或多个<strong class="ky ir">从句的<strong class="ky ir">连接词</strong>组成。</strong></p><ul class=""><li id="83e3" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated">每个子句包含一个或多个文字(布尔变量)。</li><li id="8613" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">一个CNF只包含运算符:<strong class="ky ir"> </strong> (not) <strong class="ky ir">，∨ </strong> (or)，<strong class="ky ir"> ∧ </strong> (and)。</li><li id="5ebb" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">子句的<strong class="ky ir">连接词</strong>通过<strong class="ky ir"> ∧ </strong>运算符获得。</li><li id="ee40" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">每个<strong class="ky ir">子句</strong>的文字由<strong class="ky ir">∩</strong>操作符关联</li><li id="880b" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated"><strong class="ky ir"> </strong>运算符只能用作文字的一部分。</li></ul><h2 id="ee65" class="os nw iq bd nx ot ou dn ob ov ow dp of lf ox oy oh lj oz pa oj ln pb pc ol pd bi translated">CNF的示例:</h2><p id="b908" class="pw-post-body-paragraph kw kx iq ky b kz on jr lb lc oo ju le lf op lh li lj oq ll lm ln or lp lq lr ij bi translated"><strong class="ky ir"> (x ∨ y) ∧ y </strong></p><p id="c0fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解决方案分配是:x =真，y =假</p><blockquote class="mq mr ms"><p id="b15b" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">我们将定义解决上述CNF的量子电路。</p></blockquote><p id="5569" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在开始之前，让我们根据并使用德摩根规则重写上面的CNF实例(图9)。<strong class="ky ir"> <em class="mt">为什么？</em> </strong>只是因为后面会更容易描述神谕:)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qa"><img src="../Images/ce09fc4026504233e691fe3068692342.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*kPMonmRvD82XR9VJ37XKEg.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd pf">图九。</strong>德摩根规则。[图片由作者提供]</p></figure><p id="3db9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">于是，我们将<strong class="ky ir"> (x ∨ y) ∧ y </strong>改写为<strong class="ky ir"> ( x ∧ y) ∧ y </strong>。</p><p id="af62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">具体来说，我们将定义一个甲骨文，它标志着:</strong>的解决方案</p><blockquote class="mb"><p id="3b0b" class="mc md iq bd me mf mg mh mi mj mk lr dk translated"><strong class="ak"> ( x ∧ y) ∧ y </strong></p></blockquote><blockquote class="mq mr ms"><p id="3cad" class="kw kx mt ky b kz ml jr lb lc mm ju le mu mn lh li mv mo ll lm mw mp lp lq lr ij bi translated">为了简单起见，让我们假设我们已经知道上面的实例有一个单一的解决方案。在文章的最后，我会解释为什么我们会做出这样的假设。</p></blockquote><h1 id="fa3b" class="nv nw iq bd nx ny pi oa ob oc pj oe of jw pk jx oh jz pl ka oj kc pm kd ol om bi translated"><strong class="ak">量子电路</strong></h1><ul class=""><li id="fa60" class="mz na iq ky b kz on lc oo lf pn lj po ln pp lr ne nf ng nh bi translated">1)为布尔公式生成所有可能的赋值:<strong class="ky ir"> ( x ∧ y) ∧ y </strong>。</li><li id="763b" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">2)应用神谕。</li><li id="8cc1" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">3)应用扩散器。</li><li id="7cf4" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">4)进行测量。</li></ul><blockquote class="mq mr ms"><p id="6e11" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated"><strong class="ky ir">注</strong></p><p id="9adf" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">通常，我们需要根据以下公式多次重复步骤2)和3):</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qb"><img src="../Images/5231cadfcf11b1bb05f0f96ae7bde657.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/1*_axUL_5vZF83jz9luzoDKg.jpeg"/></div></figure><blockquote class="mq mr ms"><p id="1e0f" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">其中<strong class="ky ir"> n </strong>是变量的个数。</p><p id="ba5e" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">在我们的例子中，<strong class="ky ir"> n=2 </strong>(即<strong class="ky ir"> x </strong>和<strong class="ky ir"> y </strong> ) <strong class="ky ir">。</strong>因此，重复次数为<strong class="ky ir"> 1 </strong>。也就是说，我们只应用一次神谕和扩散器。</p><p id="28f3" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">如果你想进一步了解这个公式是如何得到的，我会在文章底部给你留一些参考资料。</p></blockquote><h2 id="2695" class="os nw iq bd nx ot ou dn ob ov ow dp of lf ox oy oh lj oz pa oj ln pb pc ol pd bi translated">步骤1:为布尔公式生成所有可能的赋值</h2><p id="b75f" class="pw-post-body-paragraph kw kx iq ky b kz on jr lb lc oo ju le lf op lh li lj oq ll lm ln or lp lq lr ij bi translated">我们通过哈达玛门(图10)将所有的量子位叠加起来！也就是说，我们为布尔公式生成所有可能的赋值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/24f187db3bfb02d4a94de919fc03f88c.png" data-original-src="https://miro.medium.com/v2/resize:fit:372/format:webp/1*rD3VWLdn4PaatkbHe5eYJg.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd pf">图10。哈达玛城门。[图片由作者提供]</strong></p></figure><p id="4936" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们知道一个解存在，<strong class="ky ir">，那么我们的解就在我们通过将所有量子位进行相等叠加而生成的赋值</strong>(图11)内。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/4f19ea80b53799feb6c04ffcd539ce36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*3pq0BphBwVbsvABm7z-fwQ.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd pf">图11。</strong>所有可能作业的叠加。[图片由作者提供]</p></figure><h2 id="9bab" class="os nw iq bd nx ot ou dn ob ov ow dp of lf ox oy oh lj oz pa oj ln pb pc ol pd bi translated">步骤2:应用Oracle</h2><p id="a2f6" class="pw-post-body-paragraph kw kx iq ky b kz on jr lb lc oo ju le lf op lh li lj oq ll lm ln or lp lq lr ij bi translated">我想强调的是，在这个例子中，我们不知道像例子“寻找数字3”中的解决方案。</p><blockquote class="mb"><p id="cd09" class="mc md iq bd me mf mg mh mi mj mk lr dk translated">一般来说，通过定义SAT实例，我们只是定义了输入必须满足的<strong class="ak">条件</strong>作为我们的解决方案(即，您的<strong class="ak">oracl</strong>e/您的函数！)</p></blockquote><p id="58cb" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">遵循oracle电路(图12)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qd"><img src="../Images/cf6893c6986081cdc8c3942ae0a0cabc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w9lMvNWVvWERvYV0_xNd8Q.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd pf">图12。</strong>甲骨文电路。[图片由作者提供]</p></figure><p id="b962" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要慌！我们将详细分析❤的整个电路</p><h2 id="4d79" class="os nw iq bd nx ot ou dn ob ov ow dp of lf ox oy oh lj oz pa oj ln pb pc ol pd bi translated">细节</h2><p id="7274" class="pw-post-body-paragraph kw kx iq ky b kz on jr lb lc oo ju le lf op lh li lj oq ll lm ln or lp lq lr ij bi translated">我们在甲骨文电路中分别观察到3个额外的量子位:</p><ul class=""><li id="e3ac" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated">2个工作量子位<strong class="ky ir"> w. </strong></li><li id="f0ed" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">一个量子位<strong class="ky ir">检测器。</strong></li></ul><h2 id="7149" class="os nw iq bd nx ot ou dn ob ov ow dp of lf ox oy oh lj oz pa oj ln pb pc ol pd bi translated">工作量子位</h2><blockquote class="mq mr ms"><p id="7007" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">我们添加了和CNF实例的子句数量一样多的工作量子位。工作量子位的范围是临时存储给定子句的输出。</p></blockquote><p id="db0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，<strong class="ky ir"> ( x ∧ y) ∧ y </strong>，我们有2个子句，那么需要2个工作量子位<strong class="ky ir"> w </strong>。</p><h2 id="166d" class="os nw iq bd nx ot ou dn ob ov ow dp of lf ox oy oh lj oz pa oj ln pb pc ol pd bi translated">检验量子位</h2><p id="11e5" class="pw-post-body-paragraph kw kx iq ky b kz on jr lb lc oo ju le lf op lh li lj oq ll lm ln or lp lq lr ij bi translated">量子位<strong class="ky ir">检验器</strong>的目的是<strong class="ky ir">标记</strong>正确的解。也就是说，当一个变量赋值满足oracle条件时，那么<strong class="ky ir">检查器</strong>被翻转到<strong class="ky ir"> 1 </strong>。</p><h2 id="162c" class="os nw iq bd nx ot ou dn ob ov ow dp of lf ox oy oh lj oz pa oj ln pb pc ol pd bi translated"><strong class="ak">条款</strong></h2><p id="c186" class="pw-post-body-paragraph kw kx iq ky b kz on jr lb lc oo ju le lf op lh li lj oq ll lm ln or lp lq lr ij bi translated">我们将<strong class="ky ir"> ( x ∧ y) ∧ y </strong>分解成三个部分(图13):</p><ul class=""><li id="98c1" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated"><strong class="ky ir">第1条。</strong> w0 = x ∧ y</li><li id="c68a" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated"><strong class="ky ir">第2条。</strong> w1 = y</li><li id="5491" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated"><strong class="ky ir">结果。</strong> w0 ∧ w1</li></ul><blockquote class="mq mr ms"><p id="8968" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">注意<strong class="ky ir"> w0 </strong>对应的是<strong class="ky ir"> x ∧ y </strong>而不是<strong class="ky ir"> ( x ∧ y) </strong>！</p><p id="102f" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">我们把第一个<strong class="ky ir"> </strong>推迟到<strong class="ky ir"> </strong> w0 ∧ w1 <strong class="ky ir">。</strong></p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qe"><img src="../Images/3bcc3a2e0722b53c13a9639612505e52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qdKoPvG-0LfpQiskg6eeuA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd pf">图十三。</strong>分解<strong class="bd pf"> ( x ∧ y) ∧ y. </strong>【图片由作者提供】</p></figure><h2 id="5b53" class="os nw iq bd nx ot ou dn ob ov ow dp of lf ox oy oh lj oz pa oj ln pb pc ol pd bi translated">第1条<strong class="ak">。w0 = x ∧ y </strong></h2><p id="d4c1" class="pw-post-body-paragraph kw kx iq ky b kz on jr lb lc oo ju le lf op lh li lj oq ll lm ln or lp lq lr ij bi translated">条款1检查条件<strong class="ky ir"> x ∧ y </strong>(图14)。通过<em class="mt">多控X门</em>实现，其中:</p><ul class=""><li id="1a54" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated"><strong class="ky ir"> x </strong>和<strong class="ky ir"> y </strong>是控制量子位，</li><li id="f15c" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated"><strong class="ky ir"> w0 </strong>是存储条件<strong class="ky ir"> x ∧ y. </strong>结果的目标量子位</li></ul><p id="350b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，<em class="mt">多控X门必须在<strong class="ky ir"> x </strong>和<strong class="ky ir">y</strong>时</em>触发，为此，我们将<strong class="ky ir"> </strong>前置并附加<strong class="ky ir">两个</strong> <strong class="ky ir"> X门</strong>分别到<strong class="ky ir"> x </strong>和<strong class="ky ir"> y、</strong>，从而取消它们。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qf"><img src="../Images/91f031a7752f3e5cedf78e918f1df507.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*gqxcJxXws5K0iLUGkJI6Tw.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd pf">图14。</strong> X门否定X和y【图片由作者提供】</p></figure><h2 id="5f1a" class="os nw iq bd nx ot ou dn ob ov ow dp of lf ox oy oh lj oz pa oj ln pb pc ol pd bi translated"><strong class="ak">第二条。</strong> w1 = y</h2><p id="45f7" class="pw-post-body-paragraph kw kx iq ky b kz on jr lb lc oo ju le lf op lh li lj oq ll lm ln or lp lq lr ij bi translated">条款2检查条件<strong class="ky ir"> y </strong>(图15)。通过<em class="mt">受控X门</em>实现，其中:</p><ul class=""><li id="f254" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated"><strong class="ky ir"> y </strong>是控制量子位，</li><li id="aa23" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated"><strong class="ky ir"> w1 </strong>是存储条件<strong class="ky ir"> y. </strong>结果的目标量子位</li></ul><p id="56a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如前所述，由于我们寻找子句<strong class="ky ir"> y </strong>，因此我们否定受控X门中的量子位<strong class="ky ir"> y </strong>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qf"><img src="../Images/cf658e08c262c927841c34a193db9b30.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*oKoxpvVM84YRC2XkhbU1eA.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd pf">图15。</strong> X门否定y【图片由作者提供】</p></figure><h2 id="be71" class="os nw iq bd nx ot ou dn ob ov ow dp of lf ox oy oh lj oz pa oj ln pb pc ol pd bi translated">结果<strong class="ak">。</strong> w0 ∧ w1</h2><p id="1317" class="pw-post-body-paragraph kw kx iq ky b kz on jr lb lc oo ju le lf op lh li lj oq ll lm ln or lp lq lr ij bi translated">结果检查与我们的CNF实例<strong class="ky ir"> ( x ∧ y) ∧ y </strong>相对应的条件<strong class="ky ir"> w0 ∧ w1 </strong>(图16)。条件<strong class="ky ir"> w0 ∧ w1 </strong>通过<em class="mt">多控X门</em>实现，其中:</p><ul class=""><li id="f42f" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated"><strong class="ky ir"> w0 </strong>和<strong class="ky ir"> w1 </strong>是控制量子位，</li><li id="9198" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated"><strong class="ky ir"> checker </strong>是当<strong class="ky ir"> w0 ∧ w1 </strong>满足时<strong class="ky ir">翻转到1 </strong>的目标量子位。</li></ul><p id="2fdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们回忆一下<strong class="ky ir"> w0 </strong>对应的是<strong class="ky ir"> x ∧ y </strong>而不是<strong class="ky ir"> ( x ∧ y)。</strong></p><p id="e968" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">因此，我们需要对w0进行否定:(x ∧ y) = w0。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qf"><img src="../Images/a6a2271e88926d191217e972d7ccad33.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*o5G_5TAcmqYMaFosDCLkmQ.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd pf">图16。</strong> X门求反w0。[图片由作者提供]</p></figure><h2 id="12c3" class="os nw iq bd nx ot ou dn ob ov ow dp of lf ox oy oh lj oz pa oj ln pb pc ol pd bi translated"><strong class="ak">未计算</strong></h2><p id="fbb5" class="pw-post-body-paragraph kw kx iq ky b kz on jr lb lc oo ju le lf op lh li lj oq ll lm ln or lp lq lr ij bi translated">甲骨文的最后一步是释放工作量子位<strong class="ky ir"> w0 </strong>和<strong class="ky ir"> w1 </strong>。这是通过执行不计算来实现的(图17)。</p><p id="567e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了不计算<strong class="ky ir"> w0 </strong>和<strong class="ky ir"> w1 </strong>，以相反的顺序应用实现条款1和条款2的门就足够了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qf"><img src="../Images/d96ef2ab8bca291f1cd58c54530052d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*BWEcuRM_zffRFZB2_MXCOw.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd pf">图17。</strong>未计算w0和w1。[图片由作者提供]</p></figure><blockquote class="mb"><p id="9eb3" class="mc md iq bd me mf qg qh qi qj qk lr dk translated">最终，我们手工制作了我们的神谕！魔力已经显现！</p></blockquote><figure class="pr ps pt pu pv kk"><div class="bz fp l di"><div class="pw my l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">哒哒。[ <a class="ae kv" href="https://giphy.com/" rel="noopener ugc nofollow" target="_blank"> Gif via Giphy </a> ]</p></figure><h2 id="93d5" class="os nw iq bd nx ot ou dn ob ov ow dp of lf ox oy oh lj oz pa oj ln pb pc ol pd bi translated">步骤3:应用扩散器</h2><p id="9462" class="pw-post-body-paragraph kw kx iq ky b kz on jr lb lc oo ju le lf op lh li lj oq ll lm ln or lp lq lr ij bi translated">最后，我们应用<strong class="ky ir">扩散器</strong>算子，它放大了正确的解(图18)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ql"><img src="../Images/763b2fd8031b6b897c0f01370873489e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mW7C0Te1FNeJZn3G2tBjeg.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd pf">图18。</strong>扩散器电路。[图片由作者提供]</p></figure><h2 id="105b" class="os nw iq bd nx ot ou dn ob ov ow dp of lf ox oy oh lj oz pa oj ln pb pc ol pd bi translated"><strong class="ak">第四步:测量</strong></h2><p id="74ea" class="pw-post-body-paragraph kw kx iq ky b kz on jr lb lc oo ju le lf op lh li lj oq ll lm ln or lp lq lr ij bi translated">最终，我们测量量子位<strong class="ky ir"> x </strong>和<strong class="ky ir"> y </strong>(图20) <strong class="ky ir">。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qm"><img src="../Images/ed5c696d5d26053d4dcfc4943ef18d0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lyKDcTeo-4pFDfYhwSvfIg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd pf">图20。</strong>测量。[图片由作者提供]</p></figure><p id="8fcc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出分布如图21所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qn"><img src="../Images/139932ad554db89bf412daef64ad7ae0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TRBW_t461aEQkZXcJrxLDA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd pf">图21。</strong>输出分配。[图片由作者提供]</p></figure><p id="fda5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最高概率对应赋值<strong class="ky ir"> y=0(假)，x=1(真)(即01)。</strong></p><p id="5018" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">特别是赋值01 <strong class="ky ir"> </strong>满足我们的CNF实例<strong class="ky ir"> ( x ∧ y) ∧ y！</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="qo my l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">哇哦。[ <a class="ae kv" href="https://giphy.com/" rel="noopener ugc nofollow" target="_blank"> Gif via Giphy </a> ]</p></figure><h1 id="a766" class="nv nw iq bd nx ny pi oa ob oc pj oe of jw pk jx oh jz pl ka oj kc pm kd ol om bi translated"><strong class="ak">结论</strong></h1><p id="c3dd" class="pw-post-body-paragraph kw kx iq ky b kz on jr lb lc oo ju le lf op lh li lj oq ll lm ln or lp lq lr ij bi translated">本文的主要目的是给出一个oracles的自包含演示，以及如何使用<strong class="ky ir"> Qiskit </strong>实现它们。特别是:</p><ul class=""><li id="2138" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated">我们理解了神谕是什么。</li><li id="3629" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">扩散器的用途。</li><li id="ffc1" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">如何在Qiskit中有效地实现一个Oracle和一个扩散器？</li></ul><p id="10bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的参考资料中，您可以找到我的带有Qiskit实现的Github库，以便您可以使用它:)</p><blockquote class="mq mr ms"><p id="e08c" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated"><strong class="ky ir">啊！在给出的例子中，解的数量正好是1。然而，对于一个给定的问题，我们可以有多个解决方案！在这些情况下，我们需要对计算Oracle-Diffuser对的重复次数的公式做一点小小的修改。特别是，公式变成:</strong></p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qp"><img src="../Images/357f30843887c03ff47958c537fffecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:388/format:webp/1*gEMZM_5-1FFzQk12VySySw.jpeg"/></div></figure><blockquote class="mq mr ms"><p id="6483" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">在Github资源库中，您还会发现一个CNF实例的例子，其中有多个解决方案可供使用。🎉</p></blockquote></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h2 id="0086" class="os nw iq bd nx ot ou dn ob ov ow dp of lf ox oy oh lj oz pa oj ln pb pc ol pd bi translated">结束语</h2><p id="a81f" class="pw-post-body-paragraph kw kx iq ky b kz on jr lb lc oo ju le lf op lh li lj oq ll lm ln or lp lq lr ij bi translated">我故意避开技术细节，让你掌握大意💡。</p><p id="a68a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我开始研究量子计算时，我会很欣赏这种概述。这就是我决定写这篇❤.文章的原因</p><p id="ce79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我真的希望你也欣赏它！万一，请随意留下掌声或评论。任何一种反馈都会超级重视！</p><p id="3c6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在<a class="ae kv" href="https://www.linkedin.com/in/aleberti/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上保持联系吧！</p><h2 id="9abf" class="os nw iq bd nx ot ou dn ob ov ow dp of lf ox oy oh lj oz pa oj ln pb pc ol pd bi translated">参考</h2><ul class=""><li id="cc0e" class="mz na iq ky b kz on lc oo lf pn lj po ln pp lr ne nf ng nh bi translated">💻Qiskit实现<a class="ae kv" href="https://github.com/Brotherhood94/behind_oracles_medium" rel="noopener ugc nofollow" target="_blank">这里的<strong class="ky ir"/></a><strong class="ky ir"/>👈</li><li id="aba2" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">🔍格罗弗算法的详细介绍<a class="ae kv" href="https://quantum.country/search" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">此处</strong> </a> <strong class="ky ir"> </strong>👈</li><li id="c924" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">📚<a class="ae kv" href="https://www.amazon.it/Quantum-Computation-Information-10th-Anniversary/dp/1107002176" rel="noopener ugc nofollow" target="_blank">为综合本书<strong class="ky ir">此处</strong>为</a>👈</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pw my l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">拜拜！ [ <a class="ae kv" href="https://giphy.com/" rel="noopener ugc nofollow" target="_blank"> Gif via Giphy </a></p></figure></div></div>    
</body>
</html>