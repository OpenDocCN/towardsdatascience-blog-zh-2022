<html>
<head>
<title>What the Hash</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这是什么</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/what-the-hash-d678538b313#2022-08-15">https://towardsdatascience.com/what-the-hash-d678538b313#2022-08-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0153" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">陷入不可避免的类型错误</h2></div><p id="f170" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有Python开发人员在某个时候(或者实际上，很多时候)都面临的一个共同问题是带有神奇单词<strong class="kh ir">的<code class="fe lb lc ld le b">TypeError</code>不可销毁类型</strong>。我们都同意，如果没有适当的背景，这听起来并不好，而且可能接近可怕。</p><p id="a607" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python是一种大量建立在字典之上的语言。例如，<em class="lf">名称空间</em>或<em class="lf">类</em>就是这样存储它们的功能和属性的。理解字典如何在Python的API之外工作可以帮助我们理解这种数据结构并避免常见错误。</p><p id="cc94" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章将深入探讨<strong class="kh ir">映射</strong>类型，它们在内部做什么，以及这些知识如何帮助我们更多地了解<em class="lf">不可修复的</em>异常。</p><h1 id="8a1c" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">映射</h1><p id="120d" class="pw-post-body-paragraph kf kg iq kh b ki ly jr kk kl lz ju kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">数据访问有两种方式:</p><ul class=""><li id="329b" class="md me iq kh b ki kj kl km ko mf ks mg kw mh la mi mj mk ml bi translated"><strong class="kh ir">全扫描</strong>，该过程需要遍历数据结构的所有元素。在Python中，一个例子就是<code class="fe lb lc ld le b">List</code>。虽然我们可以通过<em class="lf">索引</em>来访问一个条目，但是没有办法直接识别容器中的特定元素，而且索引可能会随着时间而改变。</li><li id="4218" class="md me iq kh b ki mm kl mn ko mo ks mp kw mq la mi mj mk ml bi translated"><strong class="kh ir">键查找</strong>，其中流程知道如何直接识别和检索特定的项目。<strong class="kh ir">映射</strong>是支持这种数据访问策略的数据结构。一个<code class="fe lb lc ld le b">dict</code>将是Python的一个映射类型的实现。</li></ul><p id="bc6b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这两种方法的主要区别在于，对于映射，存储在容器中的数据需要提供一个<strong class="kh ir">键</strong>，它将用于标识一个项目，以及一个<strong class="kh ir">值</strong>，它是包含我们想要检索的数据的元素。</p><p id="9ab2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使键查找一致，需要满足几个属性(如果我们不修改容器):</p><ol class=""><li id="e3da" class="md me iq kh b ki kj kl km ko mf ks mg kw mh la mr mj mk ml bi translated">一个值应该只能通过<strong class="kh ir">一个键</strong>访问。唯一值可以避免冲突，并有助于确保没有数据被不同的元素覆盖。</li><li id="2549" class="md me iq kh b ki mm kl mn ko mo ks mp kw mq la mr mj mk ml bi translated">在键-值对的整个生命周期中，键应该总是返回相同的值。</li></ol><h1 id="3f2f" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">哈希函数</h1><p id="5406" class="pw-post-body-paragraph kf kg iq kh b ki ly jr kk kl lz ju kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">将<a class="ae ms" href="https://en.wikipedia.org/wiki/Hash_function" rel="noopener ugc nofollow" target="_blank"> <em class="lf"> hashable </em> </a>键映射到存储在容器中的值确保上述属性成立。当我们向字典中添加一个新的对时，键本身不会用来存储值，而是存储对它应用散列函数的结果。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi mt"><img src="../Images/b4feb777820e8134d515a4a2cb7be27f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i64NRInzx-ENI-dHUjGqMg.png"/></div></div><p class="nf ng gj gh gi nh ni bd b be z dk translated">散列一个键来存储值。图片由作者提供。</p></figure><p id="b410" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据图表，散列函数帮助我们在密钥的整个生命周期内基于密钥唯一地获得所需的值。让我们想象一下，如果哈希函数不具备这些属性，会发生什么情况:</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nj"><img src="../Images/0426bd55bf470fc410aa5d1a9a5d6c24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RMlnWo2yeE1m8DNu_zXElg.png"/></div></div><p class="nf ng gj gh gi nh ni bd b be z dk translated">哈希未保存属性混乱。图片由作者提供。</p></figure><ol class=""><li id="3226" class="md me iq kh b ki kj kl km ko mf ks mg kw mh la mr mj mk ml bi translated">我们从产生相同散列的两个密钥<code class="fe lb lc ld le b">k1</code>和<code class="fe lb lc ld le b">k2</code>开始<code class="fe lb lc ld le b">H1</code></li><li id="1923" class="md me iq kh b ki mm kl mn ko mo ks mp kw mq la mr mj mk ml bi translated">使用<code class="fe lb lc ld le b">k1</code>我们可以检索<code class="fe lb lc ld le b">v1</code>或<code class="fe lb lc ld le b">v2</code>，最终导致数据不一致。</li><li id="9498" class="md me iq kh b ki mm kl mn ko mo ks mp kw mq la mr mj mk ml bi translated">插入一个新的对<code class="fe lb lc ld le b">(k3, v3)</code>，其中<code class="fe lb lc ld le b">k3</code>被散列为<code class="fe lb lc ld le b">H0</code>，这意味着我们丢失了<code class="fe lb lc ld le b">v0</code>的内容，因为我们用<code class="fe lb lc ld le b">v3</code>覆盖了它。</li></ol><blockquote class="nk"><p id="db08" class="nl nm iq bd nn no np nq nr ns nt la dk translated">如果没有适当的保证，我们会得到意想不到的结果，甚至会丢失数据。</p></blockquote><h1 id="3c8f" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw nu jx ls jz nv ka lu kc nw kd lw lx bi translated">易变性</h1><p id="a297" class="pw-post-body-paragraph kf kg iq kh b ki ly jr kk kl lz ju kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">然而，散列函数并不是键查找中唯一涉及的函数。实际的关键对象也是等式的一部分。因此，为了确保满足两个主要的查找属性，我们需要引入一个重要的主题:<strong class="kh ir">可变性</strong>。</p><p id="14f4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们说一个对象是<a class="ae ms" href="https://en.wikipedia.org/wiki/Immutable_object" rel="noopener ugc nofollow" target="_blank">不可变的</a>，如果它的状态在创建后不能被改变，否则就是可变的。</p><p id="c8ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使散列函数是定义良好的，如果我们将散列函数应用于那些在其生命周期中拥有多种状态的可变对象，也会产生不同的结果。然后，我们在上面展示的混乱的映射中结束。</p><p id="ad25" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了讨论方便，我们假设<code class="fe lb lc ld le b">length</code>是一个合适的哈希函数。如果我们想使用一个<code class="fe lb lc ld le b">list</code>作为键，我们将应用<code class="fe lb lc ld le b">len(list)</code>来访问容器。通过添加或删除元素(改变列表)来更新列表的状态意味着我们不能正确地从映射中存储和获取数据。</p><h1 id="2bc6" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">不耐洗型</h1><p id="cc76" class="pw-post-body-paragraph kf kg iq kh b ki ly jr kk kl lz ju kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">上面的例子展示了为什么Python只允许<strong class="kh ir">不可变的</strong>对象成为映射键。字符串或整数是不可变的，所以开发人员可以安全地用它们创建<code class="fe lb lc ld le b">dict</code>:</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="0b00" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是尝试使用诸如<code class="fe lb lc ld le b">list</code>或<code class="fe lb lc ld le b">set</code>这样的类型，会引发<code class="fe lb lc ld le b">TypeError: unhashable type</code>。为什么？因为这两个是可变的。我们可以随意添加和删除元素，因此哈希函数的结果会有所不同。</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="5b81" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不可哈希类型错误告诉我们，我们正在尝试创建一个字典，其值不适合成为正确的键，因为我们无法确保哈希函数将总是为同一对象返回相同的输出。</p><h1 id="8bf4" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">不可变类型</h1><p id="0a6a" class="pw-post-body-paragraph kf kg iq kh b ki ly jr kk kl lz ju kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">而<code class="fe lb lc ld le b">str</code>和<code class="fe lb lc ld le b">int</code>是典型的字典键；在某些时候，我们可能需要其他数据类型。幸运的是，Python为表带来了一些不可变的集合:</p><ul class=""><li id="27b9" class="md me iq kh b ki kj kl km ko mf ks mg kw mh la mi mj mk ml bi translated"><code class="fe lb lc ld le b">list</code> vs. <code class="fe lb lc ld le b">tuple</code>:虽然列表是一个通用的有序集合，但是元组通常为它们的元素带来意义和结构。此外，元组是不可变的，由于它们不能被更新，每个位置保存一条特定的信息(推荐<a class="ae ms" href="https://stackoverflow.com/questions/626759/whats-the-difference-between-lists-and-tuples" rel="noopener ugc nofollow" target="_blank">来源</a>)。</li><li id="b652" class="md me iq kh b ki mm kl mn ko mo ks mp kw mq la mi mj mk ml bi translated"><code class="fe lb lc ld le b">set</code> vs. <code class="fe lb lc ld le b">frozenset</code>:这两个结构共享了C <a class="ae ms" href="https://stackoverflow.com/questions/36555214/set-vs-frozenset-performance" rel="noopener ugc nofollow" target="_blank">实现</a>的大部分，但是<code class="fe lb lc ld le b">frozenset</code>是不可变的。</li><li id="8372" class="md me iq kh b ki mm kl mn ko mo ks mp kw mq la mi mj mk ml bi translated"><code class="fe lb lc ld le b">frozenmap</code>:这个还没有实现，但是有一个<a class="ae ms" href="https://peps.python.org/pep-0603/" rel="noopener ugc nofollow" target="_blank"> PEP-603 </a>正在考虑为映射添加一个持久数据结构。</li></ul><h1 id="2f8e" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">结论</h1><p id="c864" class="pw-post-body-paragraph kf kg iq kh b ki ly jr kk kl lz ju kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">有时候，跳到一个主题的根本来理解Python为什么以这种方式工作是既有价值又令人兴奋的。</p><p id="2d9a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本帖中，我们回顾了:</p><ul class=""><li id="1f61" class="md me iq kh b ki kj kl km ko mf ks mg kw mh la mi mj mk ml bi translated">映射数据类型的工作原理。</li><li id="d310" class="md me iq kh b ki mm kl mn ko mo ks mp kw mq la mi mj mk ml bi translated">散列函数和不变性如何在存储和访问数据时确保一致性和安全性。</li><li id="7214" class="md me iq kh b ki mm kl mn ko mo ks mp kw mq la mi mj mk ml bi translated">不同的可变和不可变Python类型。</li></ul></div></div>    
</body>
</html>