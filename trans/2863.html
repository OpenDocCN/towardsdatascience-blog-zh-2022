<html>
<head>
<title>*args and **kwargs in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">* Python中的args和**kwargs</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/args-kwargs-python-d9c71b220970#2022-06-22">https://towardsdatascience.com/args-kwargs-python-d9c71b220970#2022-06-22</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="e477" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">讨论位置参数和关键字参数之间的区别，以及如何在Python中使用*args和**kwargs</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/62f6235dbe68ff042af8ca420eb00c9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Nlf3_yO4IHtiExsvn22wg.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@panyunbo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">潘云波</a>在<a class="ae kz" href="https://unsplash.com/t/3d-renders?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><h2 id="cf01" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">介绍</h2><p id="3a26" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">在Python中，函数调用中提供的参数通过赋值传递(即通过对象引用)。这意味着每当调用一个函数时，每个参数都将变成一个指向指定值的变量。显然，这些变量的范围将限于被调用的函数。</p><p id="f870" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">这意味着函数和调用者通过引用共享对象，没有名称别名。因此，通过改变函数中的参数名，我们不应该期望调用者的名字也会改变。然而，只要我们的可变对象在一个函数中发生变化，我们就应该预料到这会对调用者产生影响，因为它们共享相同的对象引用。</p><p id="1c53" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">在今天的文章中，我们将讨论在用Python编写(或调用)函数时，位置参数和关键字参数之间的区别。此外，我们将通过几个例子来演示如何在您的代码中使用<code class="fe mu mv mw mx b">*args</code>和<code class="fe mu mv mw mx b">**kwargs</code>,以使代码更加有效和Pythonic化。</p></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h2 id="4748" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Python中的位置参数与关键字参数</h2><p id="e598" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">Python函数(或方法)的参数可以通过关键字名称或位置传递，该语言能够在一次调用中收集位置和/或关键字参数。</p><p id="8017" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated"><strong class="ly iv">位置参数</strong>指的是当感兴趣的函数或方法被调用时，基于它们被提供的位置索引被解析的参数类型。因此，提供位置参数的顺序很重要，因为它们<strong class="ly iv">从左到右</strong>匹配。</p><p id="2e68" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">作为一个例子，让我们考虑内置的Python函数<code class="fe mu mv mw mx b"><a class="ae kz" href="https://docs.python.org/3/library/functions.html#round" rel="noopener ugc nofollow" target="_blank">round()</a></code>，它用于将输入数字四舍五入到小数点后指定的<em class="nf"> </em>精度。函数的定义是<code class="fe mu mv mw mx b"><strong class="ly iv">round</strong>(<em class="nf">number</em>[, <em class="nf">ndigits</em>])</code>，这意味着输入<code class="fe mu mv mw mx b">number</code>是强制的，而<code class="fe mu mv mw mx b">ndigits</code>参数是可选的，对应于期望的精度。</p><p id="633f" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">现在让我们假设我们有一个浮点变量<code class="fe mu mv mw mx b">a = 10.2254</code>,我们想把它的精度限制在小数点后两位。我们可以通过调用<code class="fe mu mv mw mx b">round()</code>函数来这样做，并提供两个参数作为位置参数。</p><pre class="kk kl km kn gu ng mx nh ni aw nj bi"><span id="1da9" class="la lb iu mx b gz nk nl l nm nn">&gt;&gt;&gt; a = 10.2254<br/>&gt;&gt;&gt; round(a, 2)<br/>10.23</span></pre><p id="5966" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">由于我们提供了位置参数(即，我们没有为调用者中提供的每个值指定关键字参数)，根据函数定义，第一个位置参数将对应于<code class="fe mu mv mw mx b">number</code>，第二个位置参数将对应于选项<code class="fe mu mv mw mx b">ndigits</code>参数。</p><p id="0767" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">另一方面，<strong class="ly iv">关键字参数</strong>通过以<code class="fe mu mv mw mx b">name=value</code>的形式指定关键字被传递给一个函数。因此，这些参数在调用者中传递的顺序并不重要，因为它们是由参数名匹配的<strong class="ly iv">。</strong></p><p id="2b7f" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">回到使用<code class="fe mu mv mw mx b">round()</code>函数的例子，我们可以通过传递关键字参数来调用它。</p><pre class="kk kl km kn gu ng mx nh ni aw nj bi"><span id="9fdd" class="la lb iu mx b gz nk nl l nm nn">&gt;&gt;&gt; a = 10.2254<br/>&gt;&gt;&gt; round(number=a, ndigits=2)<br/>10.23</span></pre><p id="f9a3" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">如前所述，我们提供关键字参数的顺序并不重要:</p><pre class="kk kl km kn gu ng mx nh ni aw nj bi"><span id="8661" class="la lb iu mx b gz nk nl l nm nn">&gt;&gt;&gt; a = 10.2254<br/>&gt;&gt;&gt; round(ndigits=2, number=a)<br/>10.23</span></pre><p id="3a82" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">注意，我们甚至可以将位置参数和关键字参数结合起来，后者应该在前者之后指定——</p><pre class="kk kl km kn gu ng mx nh ni aw nj bi"><span id="d77b" class="la lb iu mx b gz nk nl l nm nn">&gt;&gt;&gt; a = 10.2254<br/>&gt;&gt;&gt; round(a, ndigits=2)<br/>10.23</span></pre><p id="ee83" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">但是请注意，如果在位置参数之前提供关键字参数，将会引发一个<code class="fe mu mv mw mx b">SyntaxError</code>。</p><pre class="kk kl km kn gu ng mx nh ni aw nj bi"><span id="e5da" class="la lb iu mx b gz nk nl l nm nn">SyntaxError: positional argument follows keyword argument</span></pre></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h2 id="c2ee" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">位置参数和*参数</h2><p id="cc04" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">现在让我们假设我们想用Python写一个函数，它接受任意数量的参数。一种选择是在一个集合中传递参数——比如一个列表——但是在大多数情况下这并不方便。此外，这个想法不太符合Pythonic但这正是任意参数列表发挥作用的地方。</p><p id="3d23" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">我们可以在定义函数时利用<code class="fe mu mv mw mx b">*args</code>习语来指定它实际上可以接受任意数量的参数。实际上，正确处理所提供的参数取决于实现。</p><p id="89fc" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">星号<code class="fe mu mv mw mx b">*</code>被称为<strong class="ly iv">解包操作符</strong>，并将<strong class="ly iv">返回一个包含调用者提供的所有参数的元组</strong>。</p><p id="1bfb" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">例如，让我们考虑一个相当简单的函数，它接受任意数量的整数并返回它们的和</p><pre class="kk kl km kn gu ng mx nh ni aw nj bi"><span id="a0ac" class="la lb iu mx b gz nk nl l nm nn">def sum_nums(*args):<br/>    sum = 0<br/>    for n in args:<br/>        sum += n<br/>    return sum</span></pre><p id="1fd3" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">现在，我们可以使用任意数量的参数来调用上面的函数:</p><pre class="kk kl km kn gu ng mx nh ni aw nj bi"><span id="5980" class="la lb iu mx b gz nk nl l nm nn">&gt;&gt;&gt; sum_nums(10, 20)<br/>30<br/>&gt;&gt;&gt; sum_nums(10, 20, 30)<br/>60<br/>&gt;&gt;&gt; sum_nums(5)<br/>5</span></pre><p id="61a5" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">请注意，您可以在函数定义中组合普通参数和任意参数:</p><pre class="kk kl km kn gu ng mx nh ni aw nj bi"><span id="7627" class="la lb iu mx b gz nk nl l nm nn">def my_func(param, *args):<br/>    ...</span></pre></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h2 id="ba80" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">关键字参数和* *关键字</h2><p id="6345" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">同样，我们有时可能想要编写能够接受任意数量关键字参数的函数。</p><p id="04c3" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">当解包来自<code class="fe mu mv mw mx b">**</code>的关键字参数时，结果将是一个Python字典，其中键对应于关键字名称，值对应于所提供的实际参数值。</p><pre class="kk kl km kn gu ng mx nh ni aw nj bi"><span id="ec09" class="la lb iu mx b gz nk nl l nm nn">def my_func(**kwargs):<br/>    for key, val in kwargs.items():<br/>        print(key, val)</span></pre><p id="a919" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">现在我们可以用任意多的关键字参数来调用函数:</p><pre class="kk kl km kn gu ng mx nh ni aw nj bi"><span id="bf17" class="la lb iu mx b gz nk nl l nm nn">&gt;&gt;&gt; my_func(a='hello', b=10)<br/>a hello<br/>b 10<br/>&gt;&gt;&gt; my_func(param1=True, param2=10.5)<br/>param1 True<br/>param2 10.5</span></pre><p id="a38b" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">再次提醒一下，任意关键字参数习语可以与普通参数和任意位置参数结合使用:</p><pre class="kk kl km kn gu ng mx nh ni aw nj bi"><span id="8236" class="la lb iu mx b gz nk nl l nm nn">def my_func(param, *args, **kwargs):<br/>    ...</span></pre></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h2 id="857b" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">何时使用*args和**kwargs</h2><p id="cd8b" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">装饰者是一个很好的实际例子，其中<code class="fe mu mv mw mx b">*args</code>和/或<code class="fe mu mv mw mx b">**kwargs</code>通常很有用。在Python中，decorator是一个函数，它接受另一个函数作为参数，修饰它(即丰富它的功能)并最终返回它。</p><p id="63f2" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">假设我们想要创建一个装饰器，负责向标准输出报告函数的执行时间。</p><pre class="kk kl km kn gu ng mx nh ni aw nj bi"><span id="1154" class="la lb iu mx b gz nk nl l nm nn">import functools<br/>import time<br/> <br/>def execution_time(func):</span><span id="4415" class="la lb iu mx b gz no nl l nm nn">    @functools.wraps(func)<br/>    def wrapper(*args, **kwargs):<br/>        start_time = time.time()<br/>        func(*args, **kwargs)<br/>        end_time = time.time()<br/>        print(f'{func.__name__} took {end - start}s to run.')</span><span id="a3c8" class="la lb iu mx b gz no nl l nm nn">    return wrapper</span></pre><p id="9e1c" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">包装函数将简单地接受任意的位置和关键字参数，然后将这些参数传递给被修饰的函数。</p></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h2 id="c0e4" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">最后的想法</h2><p id="6d71" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">在今天的文章中，我们讨论了位置参数和关键字参数，以及它们在用Python编写或调用函数时的主要区别。</p><p id="fe10" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">此外，我们还讨论了<code class="fe mu mv mw mx b">*args</code>和<code class="fe mu mv mw mx b">**kwargs</code>之间的主要区别，以及如何根据您想要实现的目标，在您自己的职能中利用它们。此外，我们展示了如何在实践中使用来自<code class="fe mu mv mw mx b">*args</code>和<code class="fe mu mv mw mx b">**kwargs</code>的位置和关键字参数。</p><p id="bf98" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">最后，我们通过一个实例展示了<code class="fe mu mv mw mx b">*args</code>和<code class="fe mu mv mw mx b">**kwargs</code>在函数包装器(即装饰器)环境中的应用。</p><p id="32df" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">值得一提的是，<strong class="ly iv">实际符号使用星形符号</strong> ( <code class="fe mu mv mw mx b">*</code>和<code class="fe mu mv mw mx b">**</code>)，并且都对应于<strong class="ly iv">任意参数列表</strong>。<code class="fe mu mv mw mx b"><strong class="ly iv">*args</strong></code><strong class="ly iv"/><code class="fe mu mv mw mx b"><strong class="ly iv">**kwargs</strong></code><strong class="ly iv">这两个名字无非是一个约定</strong>(在社区中相当流行，通常用来描述任意的参数列表)。因此，您不必这样引用它们——例如，您甚至可以在函数定义中将它们命名为<code class="fe mu mv mw mx b">*hello</code>和<code class="fe mu mv mw mx b">**hey</code>,尽管我不建议您使用这样的命名约定:)。</p></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><p id="5d58" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated"><a class="ae kz" href="https://gmyrianthous.medium.com/membership" rel="noopener"> <strong class="ly iv">成为会员</strong> </a> <strong class="ly iv">阅读介质上的每一个故事。你的会员费直接支持我和你看的其他作家。你也可以在媒体上看到所有的故事。</strong></p><div class="np nq gq gs nr ns"><a href="https://gmyrianthous.medium.com/membership" rel="noopener follow" target="_blank"><div class="nt ab fp"><div class="nu ab nv cl cj nw"><h2 class="bd iv gz z fq nx fs ft ny fv fx it bi translated">通过我的推荐链接加入Medium-Giorgos Myrianthous</h2><div class="nz l"><h3 class="bd b gz z fq nx fs ft ny fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="oa l"><p class="bd b dl z fq nx fs ft ny fv fx dk translated">gmyrianthous.medium.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og kt ns"/></div></div></a></div></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><p id="676e" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated"><strong class="ly iv">你可能也会喜欢</strong></p><div class="np nq gq gs nr ns"><a rel="noopener follow" target="_blank" href="/pycache-python-991424aabad8"><div class="nt ab fp"><div class="nu ab nv cl cj nw"><h2 class="bd iv gz z fq nx fs ft ny fv fx it bi translated">Python中__pycache__是什么？</h2><div class="nz l"><h3 class="bd b gz z fq nx fs ft ny fv fx dk translated">了解运行Python代码时创建的__pycache__文件夹</h3></div><div class="oa l"><p class="bd b dl z fq nx fs ft ny fv fx dk translated">towardsdatascience.com</p></div></div><div class="ob l"><div class="oh l od oe of ob og kt ns"/></div></div></a></div></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu ns"><a rel="noopener follow" target="_blank" href="/python-gil-e63f18a08c65"><div class="nt ab fp"><div class="nu ab nv cl cj nw"><h2 class="bd iv gz z fq nx fs ft ny fv fx it bi translated">什么是Python全局解释器锁(GIL)？</h2><div class="nz l"><h3 class="bd b gz z fq nx fs ft ny fv fx dk translated">理解Python中全局解释器锁的用途以及它如何影响多线程</h3></div><div class="oa l"><p class="bd b dl z fq nx fs ft ny fv fx dk translated">towardsdatascience.com</p></div></div><div class="ob l"><div class="oi l od oe of ob og kt ns"/></div></div></a></div></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu ns"><a rel="noopener follow" target="_blank" href="/duck-typing-python-7aeac97e11f8"><div class="nt ab fp"><div class="nu ab nv cl cj nw"><h2 class="bd iv gz z fq nx fs ft ny fv fx it bi translated">Python中的鸭式打字是什么？</h2><div class="nz l"><h3 class="bd b gz z fq nx fs ft ny fv fx dk translated">理解动态类型编程语言(如Python)中鸭类型的概念</h3></div><div class="oa l"><p class="bd b dl z fq nx fs ft ny fv fx dk translated">towardsdatascience.com</p></div></div><div class="ob l"><div class="oj l od oe of ob og kt ns"/></div></div></a></div></div></div>    
</body>
</html>