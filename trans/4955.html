<html>
<head>
<title>Creating a Multi-Well Integrated Well Log and Formation Tops Dataframe in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python创建多井综合测井和地层顶部数据框架</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/creating-an-multi-well-integrated-well-log-and-formation-tops-dataframe-in-python-469670550aaf#2022-11-03">https://towardsdatascience.com/creating-an-multi-well-integrated-well-log-and-formation-tops-dataframe-in-python-469670550aaf#2022-11-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1342" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Python中结合多口井的地层数据和测井测量</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/91d646d8d7474c295ae4980836006235.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H8vNKZphb9HBnVMdIBzFuA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由Quintin Gellar拍摄:<a class="ae ky" href="https://www.pexels.com/photo/rock-formation-wallpaper-612893/" rel="noopener ugc nofollow" target="_blank">https://www . pexels . com/photo/rock-formation-wallpaper-612893/</a></p></figure><p id="0ebe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当处理测井测量和地下数据时，我们经常要处理不同的文件格式和采样率。例如，测井记录测量值通常在内存储和传输。las文件或<a class="ae ky" rel="noopener" target="_blank" href="/loading-well-log-data-from-dlis-using-python-9d48df9a23e2"> <strong class="lb iu"> dlis文件</strong> </a>并且每0.1米或0.5英尺采样一次。另一方面，地质构造顶部是单个离散深度点。这需要对地层数据进行插值，以匹配测井测量的采样率。</p><p id="8a65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/p/8c29589ec132" rel="noopener"> <strong class="lb iu">在我之前的教程</strong> </a>中，我们看到了如何合并单井的测井数据和地层数据。在本教程中，我们将了解如何对多口井进行此操作。</p><h1 id="78b2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">导入库</h1><p id="5afe" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">该过程的第一步是导入我们将使用的库。</p><p id="ea41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于本教程，我们将使用<a class="ae ky" href="https://lasio.readthedocs.io" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> lasio </strong> </a>来加载。las文件，<a class="ae ky" href="https://docs.python.org/3/library/os.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> os </strong> </a>从目录中读取文件，<a class="ae ky" href="https://pandas.pydata.org" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">熊猫</strong> </a>使我们能够处理数据帧，<a class="ae ky" href="https://docs.python.org/3/library/csv.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> csv </strong> </a>加载csv文件中存储的地层数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="94c6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用LASIO导入测井LAS文件</h1><p id="fc42" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">接下来，我们将开始导入数据。</p><p id="9f20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本教程中使用的数据是从<a class="ae ky" href="https://www.nlog.nl/en/welcome-nlog" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> NLOG.nl </strong> </a>下载的，该网站包含北海整个荷兰区块的测井数据。这些数据可以免费下载和使用。数据许可证的全部细节可在<a class="ae ky" href="https://www.nlog.nl/en/disclaimer" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">此处</strong> </a>找到，但此处提供了知识产权部分的使用摘要:</p><blockquote class="mu mv mw"><p id="beb8" class="kz la mx lb b lc ld ju le lf lg jx lh my lj lk ll mz ln lo lp na lr ls lt lu im bi translated">NLOG。NL对本网站上或通过本网站提供的信息不主张任何权利(域名、商标权、专利和其他知识产权除外)。未经NLOG事先书面许可，用户可以复制、下载和以任何方式披露、分发或简化本网站提供的信息。NL或有权方的合法同意。如果提供NLOG，用户也可以复制、复制、处理或编辑信息和/或布局。引用NL作为来源。</p></blockquote><p id="5936" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从<a class="ae ky" href="https://www.nlog.nl/en/welcome-nlog" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">nlog . nl</strong></a><strong class="lb iu"/>网站，我们将使用三口井的数据:L07–01、L07–05和L07–04。</p><p id="fa86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当加载单个文件时，我们可以很容易地将文件位置传递给<code class="fe nb nc nd ne b">lasio.read()</code>函数。然而，由于我们正在与多个。las文件，我们需要分别读取它们，并将它们一起添加到一个列表中。</p><p id="f01d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后使用<code class="fe nb nc nd ne b">pd.concat()</code>将存储在该列表中的数据帧连接在一起。</p><p id="b993" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码将读取所有以。阿联在一个名为<code class="fe nb nc nd ne b">Data/Notebook 36</code>的目录内。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b5a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦获得了完整的文件名(第8行),它将与存储它的目录路径结合起来。然后las文件被读取(第11行)并被转换成一个<a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">熊猫数据帧</strong> </a>(第12行)。</p><p id="4fac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了区分数据来自哪口井，我们可以在dataframe中添加一个名为<code class="fe nb nc nd ne b">WELL</code>的新列。其值将被设置为las文件的井标题部分中包含的井名称(第15–16行)。</p><p id="2e82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<a class="ae ky" href="https://lasio.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> LASIO </strong> </a>加载文件并将其转换为数据帧时，数据帧的索引将被设置为深度曲线。我们可以改变这一点，使我们有一个简单的整数索引和深度作为数据帧中的实际列。这是通过使用pandas中的<code class="fe nb nc nd ne b">.reset_index()</code>函数实现的(第19行)。</p><p id="dd0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要对数据帧进行排序，使其从最浅的深度测量到最深的深度测量(第20行)。这样做会打乱索引的顺序，所以我们需要再次重置索引，但是这一次，我们不希望索引转换成列(第20行),所以我们需要将<code class="fe nb nc nd ne b">drop</code>参数设置为True。</p><p id="7504" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦数据帧被排序，我们就可以把它添加到我们的数据帧列表中:<code class="fe nb nc nd ne b">df_list</code>(第21行)。</p><p id="e0c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重复这个过程，直到所有可用。las文件已在指定目录中读取。</p><p id="1189" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，使用<code class="fe nb nc nd ne b">pd.concat()</code>(第24行)将存储在列表中的数据帧连接在一起。</p><p id="6325" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们调用<code class="fe nb nc nd ne b">well_df</code> dataframe时，我们得到了前5行和后5行的视图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/5802573ea40bffc1146f99da9aac4746.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*2ndl3zNmVwKDsEY-r7ZqBA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">加载多个后的数据帧内容。las文件，并将它们连接成一个数据帧。图片由作者提供。</p></figure><h2 id="2a50" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">从CSV加载地层顶部数据</h2><p id="2681" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">地层顶部数据通常以表格形式存储，最常见的是。csv文件。这些文件将包含地质构造的名称，以及相关的顶部和底部深度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/47e4c05198cc2440eb78e4abf98e934a.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*nmSXlWmITvQdQiT--4VQVg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">csv文件中存储的地层数据示例。图片由作者提供。</p></figure><p id="0119" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本例的csv文件已经有一个名为Well的列，其中包含了井的名称。在将它们加载到Python之前做这些是有帮助的，但不是必需的。如果不这样做，您可能需要从文件名中提取井名，这可能会更加耗时。</p><p id="45a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的代码示例中，我们再次创建一个空白列表(第2行)来存储数据帧。</p><p id="b81a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们遍历所有以。csv文件并使用<code class="fe nb nc nd ne b">pd.read_csv()</code>读取它们，然后将它们添加到名为<code class="fe nb nc nd ne b">df_formation_list</code>的列表中</p><p id="9111" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦所有文件都被读取，我们就可以调用<code class="fe nb nc nd ne b">pd.concat()</code>将数据帧连接在一起。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b726" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们调用<code class="fe nb nc nd ne b">formations_df</code>数据帧时，我们得到以下视图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/fd40479a50526c8f23b5a543694d1a70.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*xpM9LstaaNG0WgcNYCJ2Bg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">存储在多口井的pandas数据框架中的地层数据。图片由作者提供。</p></figure><h2 id="cc59" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">创建地层数据字典</h2><p id="76ff" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">既然我们在一个简单的pandas数据帧中有了这些信息，我们现在需要将这个数据帧转换成一个嵌套的字典。</p><p id="b746" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得合并两个数据集的过程更加容易，并允许我们创建一个连续的列，其中包含每个深度级别的地层名称。</p><p id="e4d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过使用字典理解来做到这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="7c6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们运行了上面的代码，我们就可以调用<code class="fe nb nc nd ne b">formations_dict</code>,并返回下面的结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/a301aec9e25a9dda836797f5b8ec84a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*jJ0i2Bno_l7rAWM0PvvRng.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">地层名称和深度的嵌套词典。图片由作者提供。</p></figure><p id="7baf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从中我们可以看到，主键是井名，在每个井内我们都有一个子字典，深度作为键，地层名作为值。</p><p id="1035" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能想知道为什么我们使用深度作为关键字，而不是地层名称。这样做将允许我们检查我们当前所处的深度(在我们将在下一节讨论的循环中)是否在两个键之间。如果是，那么我们可以简单地得到编队名称。</p><p id="1ca7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想查看特定井的顶部，我们可以在字典调用中调用特定的井，如下所示:</p><pre class="kj kk kl km gt nv ne nw nx aw ny bi"><span id="315e" class="ng lw it ne b gy nz oa l ob oc">formations_dict['L07-01']</span></pre><p id="adb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将返回该特定井的地层数据:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/b8a7ba84273c37742a06343c41658d45.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*PQPZ03McLKJoCwY51wzUrw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">特定井的地层深度和名称。图片由作者提供。</p></figure><h1 id="77f0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">将地层数据与测井数据合并</h1><p id="09dc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在，处理和设置已经完成，我们可以继续将地层顶部字典与测井数据框架集成。</p><p id="1275" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们将使用以下函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="7107" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数首先获取传入的井(<code class="fe nb nc nd ne b">well_name</code>)地层的深度(键来自<code class="fe nb nc nd ne b">formations_dict</code>)。</p><p id="c30c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们需要捕捉一些边缘情况。</p><p id="0866" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要看看我们是否处于队形字典中的最后一个队形。如果是，那么我们将设置一个标志<code class="fe nb nc nd ne b">at_last_formation</code>为真，否则，我们将创建一个名为<code class="fe nb nc nd ne b">below</code>的新变量，它将是当前深度(<code class="fe nb nc nd ne b">depth</code>)以下最近的地层深度。</p><p id="abcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要看看我们是否在字典中的第一个结构(第12-17行)。在这种情况下，我们正在检查在列出的第一个地层之上是否有任何深度值。如果我们只有特定深度的地层而不是表面的地层，这种情况就会发生。如果当前深度高于(浅于)第一个地层深度，那么我们将把地层名称设置为一个空字符串(第19–20行)。否则，我们将从当前深度以上获得地层的深度值。</p><p id="e5dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们需要检查当前深度值在地层深度中的位置。如果我们不这样做，那么就不会设置正确的编队名称。如果当前深度等于地层字典中包含的深度，那么我们将把它设置为所列深度的地层名称。</p><p id="2412" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦编写了函数，我们可以在pandas中使用<code class="fe nb nc nd ne b">apply</code>方法调用它。这允许我们迭代数据帧中的每一行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="04a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们调用<code class="fe nb nc nd ne b">well_df</code>时，我们得到数据帧的如下视图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/25fd1185ce77e6ee8da6e33cebdfaa57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*jtiT8OjdPf8naz6cDIDMRA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">包含测井数据和地层数据的组合数据框架结果。图片由作者提供。</p></figure><h1 id="b012" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">检查最终结果</h1><p id="2b74" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当做这样的事情时，近距离检查结果是很重要的。例如，我们可以检查其中一口井的结果，在我们预期地层变化的深度之间。</p><p id="6536" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以这样做。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/a2e2626bc7fcad1b59daa4927f5bf547.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W063Mg6hwDj2i2vQ2b8nVg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">pandas数据帧中的地层数据和csv文件中的原始数据特写。图片由作者提供。</p></figure><p id="65ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的原始地层tops csv文件中，我们可以看到布鲁塞尔泥灰岩段和Ieper段之间的过渡发生在930英尺处。这发生在组合数据帧内的同一点。</p><p id="b33d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有助于我们获得信心，相信这个过程是有效的。</p><p id="f996" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以肯定的是，以这种方式检查多口井和井段，或者通过生成测井曲线，总是明智的。</p><h1 id="e17c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">摘要</h1><p id="c47f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在Python中，整合多口井的测井数据和地层数据是一项挑战。在这篇短文中，我们看到了如何加载多个las文件和地层数据文件，并将它们组合成一个数据帧。</p><p id="0b59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将允许我们将地层数据和测井数据集成到机器学习模型或测井显示中。</p><p id="33ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想处理单井，请务必查看以下文章:</p><div class="og oh gp gr oi oj"><a rel="noopener follow" target="_blank" href="/combining-formation-data-with-well-log-measurements-in-pandas-8c29589ec132"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">在熊猫中将地层数据与测井测量相结合</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">用Python集成地下测量</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">towardsdatascience.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox ks oj"/></div></div></a></div></div><div class="ab cl oy oz hx pa" role="separator"><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd"/></div><div class="im in io ip iq"><p id="ec7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mx">感谢阅读。在你走之前，你一定要订阅我的内容，把我的文章放到你的收件箱里。</em> <a class="ae ky" href="https://andymcdonaldgeo.medium.com/subscribe" rel="noopener"> <strong class="lb iu"> <em class="mx">你可以在这里做！</em></strong></a><strong class="lb iu"><em class="mx"/></strong><em class="mx">或者，您也可以</em> <a class="ae ky" href="https://fabulous-founder-2965.ck.page/2ca286e572" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="mx">注册我的简讯</em> </strong> </a> <em class="mx">免费将更多内容直接发送到您的收件箱。</em></p><p id="6c2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其次，通过注册会员，你可以获得完整的媒介体验，并支持我和其他成千上万的作家。每月只需花费你5美元，你就可以接触到所有精彩的媒体文章，也有机会通过写作赚钱。如果你用 <a class="ae ky" href="https://andymcdonaldgeo.medium.com/membership" rel="noopener"> <strong class="lb iu"> <em class="mx">我的链接</em></strong></a><strong class="lb iu"><em class="mx"/></strong><em class="mx">报名，你直接用你的一部分费用支持我，不会多花你多少钱。如果你这样做了，非常感谢你的支持！</em></p></div></div>    
</body>
</html>