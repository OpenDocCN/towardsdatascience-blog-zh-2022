<html>
<head>
<title>How to Dockerize Machine Learning Applications Built with H2O, MLflow, FastAPI, and Streamlit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何对接用H2O、MLflow、FastAPI和Streamlit构建的机器学习应用</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-dockerize-machine-learning-applications-built-with-h2o-mlflow-fastapi-and-streamlit-a56221035eb5#2022-06-07">https://towardsdatascience.com/how-to-dockerize-machine-learning-applications-built-with-h2o-mlflow-fastapi-and-streamlit-a56221035eb5#2022-06-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3563" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Docker容器化多服务ML应用的简单指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f50fda81bdfc932eceb05002ede53240.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Mp3hi92avIMi2vNL"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Philippe Oursel 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="92ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">鉴于Docker在可靠地构建、发布和运行机器学习(ML)应用程序方面令人印象深刻的能力，它在数据科学领域的采用呈爆炸式增长并继续激增也就不足为奇了。</p><p id="9850" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文解释了如何利用Docker来封装一个用H2O AutoML、MLflow、FastAPI和Streamlit构建的多服务ML应用程序。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6b01" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">内容</h1><blockquote class="mu mv mw"><p id="7657" class="kz la mx lb b lc ld ju le lf lg jx lh my lj lk ll mz ln lo lp na lr ls lt lu im bi translated"><strong class="lb iu"><em class="it">(1)</em></strong><a class="ae ky" href="#8d02" rel="noopener ugc nofollow"><em class="it">Docker</em><em class="it"><br/></em><strong class="lb iu"><em class="it">(2)</em></strong></a><a class="ae ky" href="#df7f" rel="noopener ugc nofollow"><em class="it">ML应用概述</em></a><em class="it"><br/></em><strong class="lb iu"><em class="it">(3)</em></strong><a class="ae ky" href="#bf2e" rel="noopener ugc nofollow"><em class="it">后端设置— H2O、 ml flow&amp;FastAPI</em></a><em class="it"><br/></em><strong class="lb iu"><em class="it">(4)</em></strong><a class="ae ky" href="#9fda" rel="noopener ugc nofollow"><em class="it">前端设置—Streamlit</em></a><em class="it"><br/></em><strong class="lb iu"><em class="it">(5)</em></strong><a class="ae ky" href="#8c3e" rel="noopener ugc nofollow"><em class="it">设置Docker撰写</em><em class="it"><br/></em><strong class="lb iu"><em class="it"><em class="it"/></em></strong></a></p></blockquote><p id="646b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这里 找到这个项目<a class="ae ky" href="https://github.com/kennethleungty/End-to-End-AutoML-Insurance/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">的GitHub回购。</strong></a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8d02" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">(1)码头上的底漆</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/bf21c5340d79ba198b72e0101f800040.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2yxNsNauHVp9ZpTP"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@rubaitulazad?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Rubaitul Azad </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="ff81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Docker </strong> </a> <strong class="lb iu"> </strong>是一个开源平台服务，它让我们可以使用容器轻松地构建、打包、部署和运行应用程序。</p><p id="0b4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它的工作原理是将应用程序组件(即源代码、依赖项、库)打包成一个单独的可移植包(即容器)。</p><p id="bc8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了容器，任何使用不同机器的人只需几行代码就可以可靠地启动和运行相同的应用程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/fe816037ac81685b581d2a7b61bf4f8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cjseQOWgrBgDPA7kRZkyUQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Docker容器与底层基础设施的分离|按作者分类的图片</p></figure><p id="a6dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些容器将应用程序从底层基础设施中分离出来，允许团队在不同的环境中快速一致地交付软件。</p><p id="9236" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是该项目的关键Docker组件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/7ec5f2ce21eb442d3e716502bbc426a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V2W5b9U5hxFdx751RtA0mA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Docker关键组件的概述和流程|按作者分类的图片</p></figure><ul class=""><li id="9fef" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">Dockerfile :一个文本文档，包含关于构建Docker图像的说明。它可以被视为具有Docker引擎组装映像的特定命令的配方，例如下载要求、复制文件等。</li><li id="2114" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu"> Docker Image </strong>:一个只读模板，包含可执行源代码以及应用程序运行所需的库和依赖项。当您运行Docker映像时，它会生成容器的一个实例。</li><li id="2183" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu"> Docker容器</strong>:Docker图像的一个实时运行实例。</li><li id="694e" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu"> Docker Compose </strong>:定义和编排多个容器的构建和共享的配置文件。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="793f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Docker最简单的方法是使用<strong class="lb iu"> Docker Desktop </strong>，它<strong class="lb iu"> </strong>提供了一个简单的用户界面来构建和共享容器化的应用程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/c4bb99f68b8b42fdff962455da2c9289.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gKM8-pZoe2udcWdExWamZQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Docker桌面|图片作者登陆页面截图</p></figure><p id="cadc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像GitHub Desktop如何用Git简化开发一样，Docker Desktop让我们使用Docker变得很容易。</p><p id="a583" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以根据您的操作系统安装合适的Docker桌面版本，即<a class="ae ky" href="https://docs.docker.com/desktop/windows/install/" rel="noopener ugc nofollow" target="_blank"> Windows </a>、<a class="ae ky" href="https://docs.docker.com/desktop/mac/install/" rel="noopener ugc nofollow" target="_blank"> Mac </a>或<a class="ae ky" href="https://docs.docker.com/desktop/linux/install/" rel="noopener ugc nofollow" target="_blank"> Linux </a>。</p><p id="33fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本项目中使用的其他工具包括:</p><ul class=""><li id="1b22" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><a class="ae ky" href="https://code.visualstudio.com/download" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">【Visual Studio代码(VSCode) </strong> </a> <strong class="lb iu"> </strong> —编写Python脚本的代码编辑器</li><li id="dfdb" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" href="https://www.anaconda.com/products/distribution" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Anaconda Powershell提示</strong></a><strong class="lb iu">——</strong>命令行界面(CLI)运行Python任务并与Docker交互</li><li id="d55f" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">Python 3.9(附带了<a class="ae ky" href="https://www.anaconda.com/products/distribution" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Anaconda发行版</strong> </a>)</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="df7f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">(2)ML应用概述</h1><p id="13da" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">我们将使用的应用程序基于一个早期的项目，在该项目中，我们构建了一个端到端的ML管道，以<strong class="lb iu">对购买额外车辆保险的可能性较高的健康保险客户进行分类</strong>(即交叉销售)。</p><div class="ny nz gp gr oa ob"><a rel="noopener follow" target="_blank" href="/end-to-end-automl-train-and-serve-with-h2o-mlflow-fastapi-and-streamlit-5d36eedfe606"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">H2O AutoML、MLflow、FastAPI和Streamlit的端到端AutoML管道</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">关于使用一系列功能强大的工具来培训和服务AutoML管道的简单易懂的综合指南</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">towardsdatascience.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op ks ob"/></div></div></a></div><p id="2c33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将不讨论管道构建，因此请参考上面的文章了解详细信息。</p><p id="e9ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是该应用程序中组件的概述:</p><ul class=""><li id="d7dd" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><strong class="lb iu"> H2O汽车— </strong>在一系列实验中自动训练ML模型</li><li id="308d" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu"> MLflow — </strong>跟踪每个AutoML实验的结果和工件，并根据性能指标选择最佳模型</li><li id="dc16" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu"> FastAPI — </strong>(通过<a class="ae ky" href="https://www.uvicorn.org/" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">uvicon</strong></a><strong class="lb iu"/>服务器)部署和公开最佳模型作为API端点</li><li id="c6d4" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu"> Streamlit — </strong>将API端点作为一个web应用程序，为模型预测请求提供一个简单的用户界面</li></ul><p id="db94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终产品是一个用户友好的web应用程序，用户可以上传数据并检索每个客户相应的交叉销售预测。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/86c09b684cb7c0af9142e1b5c8e5b5ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*eutmzDx_Pzht4GJnThRPHw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Streamlit web界面上传客户数据并检索模型预测|作者Gif</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="7ed4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如下图所示，整个应用程序可以分为两个服务(<strong class="lb iu">前端</strong>和<strong class="lb iu">后端</strong>)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/533b9e21b6f14e35103ff578bc30d7cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cNHaTe8HftQRXYdDmH3Gfw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">应用程序组件概述|按作者分类的图片(通过公共许可证获得的徽标)</p></figure><p id="8a4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一点上，我们有了各种组件的源代码和工件(即，预先训练的模型、API端点、web应用程序接口)。让我们学习如何用<strong class="lb iu"> Docker </strong>封装整个应用程序。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bf2e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">(3)后端设置— H2O、MLflow和FastAPI</h1><p id="77b1" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">应用程序有两个部分(即<strong class="lb iu">前端</strong>和<strong class="lb iu">后端</strong>)，所以我们将它们打包到两个独立的容器中，然后将它们链接到同一个网络中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/1e8fc704901eeb0b329cec13375422a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oK-aD7nrGqsx9TutRzQyPg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">后端和前端服务的分类|按作者分类的图片</p></figure><p id="73f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从探索如何容器化<strong class="lb iu">后端</strong>设置开始。后端目录结构如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/f5efdf2b7956b9c000788c5cad657b44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*o0uWAobmf1coMSWsHd2LKA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">后端目录结构|作者图片</p></figure><p id="e9cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">后端设置的源代码可以在<a class="ae ky" href="https://github.com/kennethleungty/End-to-End-AutoML-Insurance/blob/main/backend/main.py" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> main.py </strong> </a>中找到，它在这里执行以下任务:</p><ul class=""><li id="a8e6" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">初始化FastAPI、H2O和MLflow客户端的实例</li><li id="7778" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">使用MLflow客户端从<code class="fe ou ov ow ox b">/mlruns</code>中存储的预训练模型集合中跟踪并加载最佳H2O ML模型(基于测井损失)</li><li id="e435" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">创建一个FastAPI POST端点，该端点获取并处理上传的数据，将数据提供给ML模型，并以JSON格式返回模型预测</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="ad98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">dockerizing的第一步是构建<strong class="lb iu"> Dockerfile </strong>，我们将使用它来创建应用程序的<strong class="lb iu"> Docker映像和容器</strong>。</p><p id="5cf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将专门为后端设置创建一个Dockerfile，并将其保存在<code class="fe ou ov ow ox b">/backend</code>目录中。后端设置的<strong class="lb iu">文件</strong>如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="2228" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们了解一下Dockerfile文件的内容:</p><ul class=""><li id="fe2d" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><strong class="lb iu">来自python:3.9 </strong> —从Docker Hub获取python映像(3.9版)，并创建构建Docker映像的基础层。</li><li id="13cb" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu">工作目录/应用</strong> —定义Docker容器的工作目录</li><li id="072f" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu">运行</strong> —执行特定命令，例如安装pip依赖关系。</li><li id="fbca" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu">复制</strong> —将文件从源文件夹(即Docker客户端的当前目录)复制到目标文件夹</li><li id="e8f3" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu"> EXPOSE </strong> —表示容器监听连接的端口</li><li id="88ee" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu"> CMD </strong> —指定在Docker容器中运行的命令:</li></ul><pre class="kj kk kl km gt pa ox pb pc aw pd bi"><span id="637e" class="pe md it ox b gy pf pg l ph pi">uvicorn main:app --host 0.0.0.0 --port 8000</span></pre><p id="540c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的命令指示机器启动并托管位于<a class="ae ky" href="https://superuser.com/questions/502625/what-is-ip-address-0-0-0-0" rel="noopener ugc nofollow" target="_blank"> IP地址0.0.0.0 </a>(端口8000)的uvicorn服务器，并在<strong class="lb iu"> main.py </strong>文件(即main <strong class="lb iu"> : </strong> app)中定位FastAPI ASGI应用程序。</p><p id="4d58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为H2O服务器需要Java，我们还需要运行下面的命令在我们的容器中安装一个<a class="ae ky" href="https://www.digitalocean.com/community/tutorials/how-to-install-java-with-apt-on-ubuntu-22-04" rel="noopener ugc nofollow" target="_blank"> Java运行时环境(JRE) </a>。</p><pre class="kj kk kl km gt pa ox pb pc aw pd bi"><span id="e38d" class="pe md it ox b gy pf pg l ph pi">RUN apt-get update &amp;&amp; apt-get install -y <strong class="ox iu">default-jre</strong></span></pre><p id="3253" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果不执行上述操作，我们将会遇到H2OStartupError，此时H2O服务器找不到Java。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="b878" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们后端设置的docker文件现在已经准备好了。构建Docker映像和运行容器的经典方法分别是使用<code class="fe ou ov ow ox b">docker build</code>和<code class="fe ou ov ow ox b">docker run</code>。</p><p id="c450" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除非是为了测试目的，否则我会避免在这个阶段单独构建容器。原因是我们将在步骤5中学习如何使用<strong class="lb iu"> Docker Compose </strong>来构建和并发运行多个容器。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9fda" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">(4)前端设置—简化</h1><p id="edfb" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">让我们把注意力转向构建前端接口。前端目录结构如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/20e7689312f24a6b40186e47f75d13f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*S3pgI4T3VD7vUfzTrUX5_A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">前端目录结构|作者图片</p></figure><p id="97fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前端设置的源代码可在<a class="ae ky" href="https://github.com/kennethleungty/End-to-End-AutoML-Insurance/blob/main/frontend/app.py" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> app.py </strong> </a>中找到，它在其中执行以下任务:</p><ul class=""><li id="806b" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">定义前端接口与后端FastAPI端点通信的端点位置，即<code class="fe ou ov ow ox b">endpoint = 'http://<strong class="lb iu">host.docker.internal</strong>:8000/predict'</code></li><li id="42e8" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">构建Streamlit web界面，包括用于CSV文件上传、数据预览和预测下载的组件</li><li id="7d25" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">将CSV数据转换为要解析到FastAPI端点的bytes对象</li></ul><p id="8515" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前端设置的<strong class="lb iu">文件</strong>如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8c3e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">(5)设置Docker组件</h1><p id="200a" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">虽然我们可以单独构建后端和前端容器，但这并不是创建像我们这样的互连多容器应用程序的最佳方式。</p><p id="6c3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以利用<a class="ae ky" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"> Docker Compose </a>的功能来定义和运行多容器应用程序。Docker Desktop已经安装了撰写插件，所以不需要额外安装。</p><p id="7f7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker Compose是在YAML配置文件(<code class="fe ou ov ow ox b">docker-compose.yml</code>)中定义的，它指定了构建应用程序的设置和指令。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/9c46280b7efb90760bb36eb41a6dbe09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*hW6Qdee4PZP-Q0hk-2p6_A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">docker-compose.yml放在根文件夹| Image by author中</p></figure><p id="b2b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/kennethleungty/End-to-End-AutoML-Insurance/blob/main/docker-compose.yml" rel="noopener ugc nofollow" target="_blank"><em class="mx">docker-compose . yml</em></a>文件如下图所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="7021" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们了解一下<em class="mx"> docker-compose </em>文件的内容:</p><ul class=""><li id="c52b" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><strong class="lb iu">服务</strong> —定义组成应用程序的服务(即后端和前端)，以便它们可以在一个隔离的环境中一起运行</li><li id="b4ed" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu">构建</strong> —指定构建Docker图像的文件夹。由于我们从根文件夹运行<em class="mx"> docker-compose </em>，我们将指定要构建的子目录，即<code class="fe ou ov ow ox b">backend</code>或<code class="fe ou ov ow ox b">frontend</code>。对于我们直接从根文件夹构建的情况，我们可以指定<code class="fe ou ov ow ox b">.</code></li><li id="1de5" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu"> image </strong> —指定从中启动服务容器的图像。由于我们在<strong class="lb iu">构建</strong>部分从头开始构建映像(而不是从注册表中提取)，这里的值将是新映像的名称，例如<em class="mx">e2e-自动-前端:最新</em></li><li id="1586" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu">端口</strong> —暴露容器端口。该配置将容器端口映射到主机端口，以便我们可以通过web浏览器上的localhost URL访问应用程序。例如，<code class="fe ou ov ow ox b">8501:8501</code>是指主机端口8501到容器端口8501的映射(即<code class="fe ou ov ow ox b">HOST:CONTAINER</code>)。对于后端服务，我们有两个公开的端口，其中8000用于FastAPI端点，而54321用于H2O服务器。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/ab8912cd35dd3b926fc6f1b5c59660ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v1dCJtHCr1CA0OPG4g8SRQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">端口映射图|作者图片</p></figure><ul class=""><li id="d268" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><strong class="lb iu">卷</strong> —定义一个<a class="ae ky" href="https://docs.docker.com/storage/volumes/" rel="noopener ugc nofollow" target="_blank">卷</a>，用于保存Docker容器生成的数据。它是以<code class="fe ou ov ow ox b">VOLUME:CONTAINER_PATH</code>的形式出现的。例如，<code class="fe ou ov ow ox b">./backend:/app/backend</code>是指从相对路径<strong class="lb iu"> <em class="mx">挂载卷内容。/backend </em> </strong> <em class="mx"> </em>(我们的后台目录)放入<strong class="lb iu"> <em class="mx"> /app/backend </em> </strong>容器中。</li><li id="c710" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu">依赖于</strong> —表示服务之间的启动(和关闭)依赖关系。在我们的例子中，我们希望在前端服务之前创建后端服务。因此，我们在前端服务中包含了一个<em class="mx"> depends_on: backend </em>语句。</li><li id="393d" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu">网络</strong> —定义容器所连接的网络，引用顶级<code class="fe ou ov ow ox b">networks</code>键下的条目。我们通过将两个服务连接在同一个<code class="fe ou ov ow ox b">project_network</code>网络下，使它们相互通信。</li></ul><p id="b334" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mx">注意:基于最新的</em> <a class="ae ky" href="https://docs.docker.com/compose/compose-file/" rel="noopener ugc nofollow" target="_blank"> <em class="mx">编写规范</em> </a> <em class="mx">，不再需要在YAML文件中定义顶层版本属性(如v2、v3)。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e2c4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">(6)本地运行Docker Compose</h1><p id="a4a0" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">是时候执行我们的<em class="mx"> docker-compose </em>文件来构建我们的多服务应用程序了。我们通过从根文件夹运行以下命令来实现这一点:</p><pre class="kj kk kl km gt pa ox pb pc aw pd bi"><span id="4a96" class="pe md it ox b gy pf pg l ph pi">docker-compose up -d --build</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/9b6d6711ca41ed107d823958aa94d6b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YTZwz3MDOUppYR7TujisVQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运行docker-compose命令| Image by author后的CLI输出</p></figure><p id="0d5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以检查Docker Desktop，看看我们是否已经成功地为两个服务构建了映像，并让应用程序在本地运行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/34912aa54f4d2870c27e00740fb19658.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JgllGTal3S9I_GT7zerQUw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Docker桌面上成功创建图像和容器的截图|作者图片</p></figure><p id="f73a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们可以通过在web浏览器上访问<code class="fe ou ov ow ox b">localhost:8501</code>来测试我们的应用程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/49c368fb54d0d5afe921defc8a59ecfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GwnfDiTruDpo3xbfD5R2sQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">after化后成功加载前端界面|图片由作者提供</p></figure><p id="1d0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这里，我们还可以通过运行<code class="fe ou ov ow ox b">docker-compose down</code>轻松地停止和删除容器、网络、卷和映像</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3917" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">(7)在AWS上部署Docker容器</h1><p id="f85d" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">已经学会了如何在本地对接和运行我们的ML应用程序，直观的下一步是在云上部署这个容器化的应用程序<strong class="lb iu">，例如AWS。</strong></p><p id="2ace" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我想演示这个云部署，但是Docker文档已经很好地解释了在Amazon ECS上部署Docker容器。</p><div class="ny nz gp gr oa ob"><a href="https://docs.docker.com/cloud/ecs-integration/" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">在ECS上部署Docker容器</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">Docker Compose CLI使开发人员能够使用本地Docker命令在Amazon ECS中运行应用程序</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">docs.docker.com</p></div></div><div class="ok l"><div class="pp l om on oo ok op ks ob"/></div></div></a></div><p id="c205" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管如此，我打算很快就这个项目在其他云平台上的部署写一个指南，所以请继续关注这个中型页面！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="52f3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">包装它</h1><p id="5340" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">通过上面的简单演练，我们已经了解了如何使用Docker来封装基于H2O、MLflow、FastAPI和Streamlit构建的多服务ML应用程序。</p><p id="1f45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这个<a class="ae ky" href="https://github.com/kennethleungty/End-to-End-AutoML-Insurance/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> GitHub repo </strong> </a>中找到这个项目的源代码和文件。</p><h1 id="ebe7" class="mc md it bd me mf pq mh mi mj pr ml mm jz ps ka mo kc pt kd mq kf pu kg ms mt bi translated">在你走之前</h1><p id="557b" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">欢迎您<strong class="lb iu">加入我的数据科学学习之旅！</strong>点击此<a class="ae ky" href="https://kennethleungty.medium.com/" rel="noopener">媒体</a>页面，查看我的<a class="ae ky" href="https://github.com/kennethleungty" rel="noopener ugc nofollow" target="_blank"> GitHub </a>，了解更多令人兴奋的数据科学内容。同时，祝你的ML应用程序归档愉快！</p><div class="ny nz gp gr oa ob"><a rel="noopener follow" target="_blank" href="/build-an-anomaly-detection-pipeline-with-isolation-forest-and-kedro-db5f4437bfab"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">使用隔离林和Kedro构建异常检测管道</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">开发和管理用于检测欺诈性信用卡交易的数据科学管道</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">towardsdatascience.com</p></div></div><div class="ok l"><div class="pv l om on oo ok op ks ob"/></div></div></a></div><div class="ny nz gp gr oa ob"><a rel="noopener follow" target="_blank" href="/micro-macro-weighted-averages-of-f1-score-clearly-explained-b603420b292f"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">F1分数的微观、宏观和加权平均值，解释清楚</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">理解F1分数的微观平均值、宏观平均值和加权平均值背后的概念</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">towardsdatascience.com</p></div></div><div class="ok l"><div class="pw l om on oo ok op ks ob"/></div></div></a></div><div class="ny nz gp gr oa ob"><a href="https://kennethleungty.medium.com/membership" rel="noopener follow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">通过我的推荐链接加入媒体-梁建华</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">作为一个媒体会员，你的会员费的一部分给了你阅读的作家，你可以完全阅读肯尼斯写的每一个故事</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">kennethleungty.medium.com</p></div></div><div class="ok l"><div class="px l om on oo ok op ks ob"/></div></div></a></div></div></div>    
</body>
</html>