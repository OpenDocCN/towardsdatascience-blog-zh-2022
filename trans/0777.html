<html>
<head>
<title>Translate long PDF-Reports in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python 翻译长 PDF 报告</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/translate-long-pdf-reports-in-python-eab3be08ceb4#2022-03-04">https://towardsdatascience.com/translate-long-pdf-reports-in-python-eab3be08ceb4#2022-03-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="96da" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><strong class="ak">免费自动提取和翻译完整的德国央行报告</strong></h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d51e89e520b77d573cddb9abbadcc034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cHe8bDeb0GWnFOPR"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@mbaumi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米卡·鲍梅斯特</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3c05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了工作，我最近不得不翻译许多经合组织国家央行的旧报告。幸运的是，乱码在线翻译已经成为过去，当处理许多长文档时，常见的手动解决方案通常不可行。有许多有用的 Python 包可以帮助完成这项任务，在各种优秀的现有文章<a class="ae kv" rel="noopener" target="_blank" href="/pdf-text-extraction-in-python-5b6ab9e92dd">中有介绍。然而，当面对这项任务时，我发现常用的例子往往太<em class="ls">风格化</em>，并且许多已建立的工具不再被维护<em class="ls">以支持社区构建的后续项目。</em></a></p><p id="0e50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么在这篇文章中，我想<strong class="ky ir"> 1) </strong>提供一个 PDF 翻译的真实世界的例子，并<strong class="ky ir"> 2) </strong>提供一个最好的软件包的更新。</p><h1 id="42e1" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak"> 2 + 1 任务</strong></h1><p id="9911" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">因此，我们将一起翻译一份央行报告，就像代码一样，你可以在我的<a class="ae kv" href="https://github.com/pcschreiber1/PDF_Extraction-Translation" rel="noopener ugc nofollow" target="_blank"> Git 库</a>上找到。首先，我们需要清楚地知道自己想做什么。在我们的例子中，我们需要以某种方式提取 pdf 的内容，翻译它，然后(潜在地)将它转换成人类易于阅读的格式:<strong class="ky ir">提取- &gt;翻译- &gt;编写。</strong>我们分别处理每项任务，最后把它们结合在一起。</p><h2 id="6d87" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">提取</h2><p id="394a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">正如您可能已经体验过的，从 PDF 中检索文本可能相当棘手。原因是 pdf 只存储字符的<em class="ls">位置</em>，而<em class="ls">不记录</em>构成<em class="ls">的单词或行</em>。我们选择的库是新的<strong class="ky ir">pdf plumb</strong>项目，它建立在非常好的<strong class="ky ir"> pdfminer.six </strong>库(它本身取代了<strong class="ky ir"> PDFMiner </strong>)之上，但是拥有更好的文档和令人兴奋的新特性。我们将在这里使用的一个特性是表格过滤。为了完整性，请注意流行的<strong class="ky ir"> PyPDF2 </strong>包更适合 PDF 合并，而不是文本提取。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="2439" class="mq lu iq nd b gy nh ni l nj nk">import pdfplumber</span><span id="f1ab" class="mq lu iq nd b gy nl ni l nj nk">pdf = pdfplumber.open(“src/examples/1978-geschaeftsbericht-data.pdf”)</span></pre><p id="4d5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们导入库并打开所需的文档。<strong class="ky ir">pdf plumb</strong>的中心对象是<strong class="ky ir">页面类</strong>，它允许我们单独访问每个页面及其内容。请注意，虽然我们可以简单地一次提取所有文本，但是将 pdf 缩减为一个大字符串会导致我们丢失许多有用的信息。</p><p id="7236" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是如何通过应用<strong class="ky ir"> extract_text() </strong>方法，使用索引来访问单个页面并轻松访问它们的文本。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="a176" class="mq lu iq nd b gy nh ni l nj nk">page11 = pdf.pages[11]<br/>page11.extract_text()<br/>&gt;&gt;&gt; 2  schließlich diese Wende in ihrer Politik durch die Heraufsetzung des Diskont- und Lom \nbardsatzes.</span></pre><p id="d5e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这看起来已经很好了(作为比较，查看 PDF 的第 12 页)，但我们看到句子被行尾符打断，我们可以预测这会给翻译带来问题。由于段落在句号之后自然会有换行符，我们将利用这一点只保留想要的换行符。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="5863" class="mq lu iq nd b gy nh ni l nj nk">def extract(page):<br/>  """Extract PDF text and Delete in-paragraph line breaks."""</span><span id="6c7f" class="mq lu iq nd b gy nl ni l nj nk">  # Get text</span><span id="cd0a" class="mq lu iq nd b gy nl ni l nj nk">  extracted = page.extract_text()</span><span id="22bf" class="mq lu iq nd b gy nl ni l nj nk">  # Delete in-paragraph line breaks</span><span id="7239" class="mq lu iq nd b gy nl ni l nj nk">  extracted = extracted.replace(".\n", "**/m" # keep par breaks<br/>                      ).replace(". \n", "**/m" # keep par breaks<br/>                      ).replace("\n", "" # delete in-par breaks     <br/>                      ).replace("**/m", ".\n\n") # restore par break<br/> return extracted</span><span id="d1df" class="mq lu iq nd b gy nl ni l nj nk">print(extract(page11)[:500])<br/>&gt;&gt;&gt; 2  schließlich diese Wende in ihrer Politik durch die Heraufsetzung des Diskont- und Lom bardsatzes.</span></pre><p id="1b14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好多了！但是看下一页，我们发现文档中的表格有问题。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="fdf0" class="mq lu iq nd b gy nh ni l nj nk">page12 = pdf.pages[12]</span><span id="6db5" class="mq lu iq nd b gy nl ni l nj nk">print(extract(page12)[:500])<br/>&gt;&gt;&gt; 1  3 Zur Entwicklung des Wirtschaftswachstums Jährliche Veränderung in o;o Zum Vergleich: I  Bruttoin-Brutto- I ...</span></pre><p id="5910" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">过滤掉表格</strong></p><p id="851c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">pdf plumb</strong>包的一个亮点是<strong class="ky ir">滤镜</strong>方法。该库带有查找表格的内置功能，但是将它与<strong class="ky ir">过滤器</strong>结合起来需要一些<a class="ae kv" href="https://github.com/jsvine/pdfplumber/issues/242#issuecomment-668448246" rel="noopener ugc nofollow" target="_blank">独创性</a>。本质上，<strong class="ky ir">pdf plumb</strong>将每个字符分配到所谓的“盒子”中，其坐标被<strong class="ky ir">过滤器</strong>作为输入。为了简洁起见，我将不解释<strong class="ky ir"> not_within_bboxes </strong>函数，而是指向最初的<a class="ae kv" href="https://github.com/jsvine/pdfplumber/blob/stable/pdfplumber/table.py#L404" rel="noopener ugc nofollow" target="_blank"> Git 问题</a>。我们传递已识别的属于表格的字符，并用<strong class="ky ir"> not_within_bboxes </strong>函数将它们组合起来。重要的是，由于 filter 方法只接受没有参数的函数，我们使用<strong class="ky ir">部分</strong>冻结了 box 参数。这是我们在上面创建的<strong class="ky ir">提取</strong>函数的前一步。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="0efb" class="mq lu iq nd b gy nh ni l nj nk">from functools import partial</span><span id="ef2f" class="mq lu iq nd b gy nl ni l nj nk">def not_within_bboxes(obj, bboxes):<br/>"""Check if the object is in any of the table's bbox."""<br/>  def obj_in_bbox(_bbox):<br/>    """Find Bboxes of objexts."""<br/>    v_mid = (obj["top"] + obj["bottom"]) / 2<br/>    h_mid = (obj["x0"] + obj["x1"]) / 2<br/>    x0, top, x1, bottom = _bbox</span><span id="3e4e" class="mq lu iq nd b gy nl ni l nj nk">    return (h_mid &gt;= x0) and (h_mid &lt; x1) and (v_mid &gt;= top) and (v_mid &lt; bottom)</span><span id="fea8" class="mq lu iq nd b gy nl ni l nj nk">  return not any(obj_in_bbox(__bbox) for __bbox in bboxes)</span><span id="0f31" class="mq lu iq nd b gy nl ni l nj nk">def extract(page):<br/>  """Extract PDF text, Filter tables and delete in-par breaks."""<br/>  # Filter-out tables<br/>  if page.find_tables() != []:</span><span id="1bfb" class="mq lu iq nd b gy nl ni l nj nk">  # Get the bounding boxes of the tables on the page.<br/>  bboxes = [table.bbox for table in page.find_tables()]<br/>  bbox_not_within_bboxes = partial(not_within_bboxes, bboxes=bboxes)</span><span id="fd94" class="mq lu iq nd b gy nl ni l nj nk">  # Filter-out tables from page<br/>  page = page.filter(bbox_not_within_bboxes)</span><span id="459d" class="mq lu iq nd b gy nl ni l nj nk">  # Extract Text<br/>  extracted = page.extract_text()</span><span id="3637" class="mq lu iq nd b gy nl ni l nj nk">  # Delete in-paragraph line breaks<br/>  extracted = extracted.replace(".\n", "**/m" # keep par breaks<br/>                      ).replace(". \n", "**/m" # keep par breaks<br/>                      ).replace("\n", "" # delete in-par breaks<br/>                      ).replace("**/m", ".\n\n") # restore par break<br/> return extracted</span><span id="b0bf" class="mq lu iq nd b gy nl ni l nj nk">print(extract(page12)[:500])<br/>&gt;&gt;&gt; 3 des Produktionspotentials anzusehen. Die statistischen Möglichkeiten lassen es nur an näherungsweise zu, ...</span></pre><p id="d520" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太棒了。表格被成功地过滤掉了，我们现在可以看到页面以一个被分页符分成两半的句子开始。我们把它留给了提取，但是我鼓励你尝试更多的特性，比如提取页码，改进段落分隔和修复经常出现的错误，比如识别“%”的“0/o”。</p><h2 id="b05f" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">翻译</h2><p id="978c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">AWS 和 DeepL 为高质量的文本翻译提供了两个突出的 API，但是如果我们想要翻译几个长报告，基于字符的定价方案会变得非常昂贵。为了免费翻译，我们使用 Google Api 和一个关键的变通方法，实现了长文本的翻译。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="2f91" class="mq lu iq nd b gy nh ni l nj nk">from deep_translator import GoogleTranslator</span></pre><p id="5e0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于 GoogleTranslate API 不是由 Google 维护的，所以社区在翻译方面已经多次遇到问题。这就是为什么我们在这里使用<strong class="ky ir"> deep_translator </strong>包，它充当 API 的一个有用的包装器，使我们能够在翻译引擎之间无缝切换，如果我们希望的话。重要的是，GoogleTranslator 可以自动识别源语言(在我们的例子中是德语)，所以我们只需要指定我们的目标语言:英语。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="05db" class="mq lu iq nd b gy nh ni l nj nk">translate = GoogleTranslator(source=’auto’, target=’en’).translate</span></pre><p id="7931" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这个包装器，翻译变得非常简单，如下例所示。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="7c78" class="mq lu iq nd b gy nh ni l nj nk">translate("Ich liebe Python programmieren.")<br/>&gt;&gt;&gt; 'I love Python programming.'</span></pre><p id="e635" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，关键问题是大多数翻译引擎有 5000 字节的上传限制。如果一个作业超过了这个时间，连接就会被终止——例如，这会阻止<strong class="ky ir">第 11 页</strong>的翻译。当然，我们可以单独翻译每个单词/句子，然而，这降低了翻译质量。这就是为什么我们收集低于上传限制的句子并一起翻译。</p><p id="3a54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原来，我在这里找到了这个变通办法<a class="ae kv" href="https://aws.amazon.com/de/blogs/media/how-to-translate-large-text-documents-with-amazon-translate/" rel="noopener ugc nofollow" target="_blank"/>。它使用流行的自然语言处理工具<strong class="ky ir"> nltk </strong>来识别句子。这个包的文档非常棒，我推荐任何感兴趣的人尝试一下。这里，我们将注意力限制在包的<strong class="ky ir">标记器</strong>上。重要的是，tt 一再强调，只有高质量的输入才能带来高质量的翻译输出，因此在这些准备步骤中付出更多努力将会很容易获得回报！</p><p id="48df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为这对于第一次使用的用户来说是令人畏惧的，所以我在这里展示了安装相关的<strong class="ky ir"> nltk </strong>功能的 shell 脚本(在 Windows OS 上)。“popular”子集包括现在将使用的<strong class="ky ir"> nltk.tokenize </strong>包。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="66a0" class="mq lu iq nd b gy nh ni l nj nk"># Shell script</span><span id="5a41" class="mq lu iq nd b gy nl ni l nj nk">pip install nltk<br/>python -m nltk.downloader popular</span></pre><p id="802a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如下所示，<strong class="ky ir"> sent_tokenize </strong>函数创建了一个句子列表。语言参数默认为英语，这对于大多数欧洲语言来说很好。请查看 nltk 文档，看看你需要的语言是否被支持。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="6f16" class="mq lu iq nd b gy nh ni l nj nk">from nltk.tokenize import sent_tokenize</span><span id="012f" class="mq lu iq nd b gy nl ni l nj nk">text = "I love Python. " * 2<br/>sent_tokenize(text, language = "english")<br/>&gt;&gt;&gt; ['I love Python.', 'I love Python.']</span></pre><p id="39e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们需要的第二个要素是收集低于上传限制的句子块的算法。一旦我们发现添加另一个句子将超过 5k 字节，我们翻译集合，并从当前句子开始一个新的块。重要的是，如果一个句子本身应该超过 5k 字节(记住，这大约相当于一页)，我们只需丢弃它，并提供一个文本注释。结合 I)翻译客户端的设置，ii)句子标记化，以及 iii)组块式翻译，我们最终得到以下翻译函数。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="b837" class="mq lu iq nd b gy nh ni l nj nk">def translate_extracted(Extracted):<br/>  """Wrapper for Google Translate with upload workaround."""<br/>  # Set-up and wrap translation client<br/>  translate = GoogleTranslator(source='auto', target='en').translate</span><span id="dd81" class="mq lu iq nd b gy nl ni l nj nk">  # Split input text into a list of sentences<br/>  sentences = sent_tokenize(Extracted)</span><span id="5002" class="mq lu iq nd b gy nl ni l nj nk">  # Initialize containers<br/>  translated_text = ''<br/>  source_text_chunk = ''</span><span id="934e" class="mq lu iq nd b gy nl ni l nj nk">  # collect chuncks of sentences, translate individually<br/>  for sentence in sentences:<br/>    # if chunck + current sentence &lt; limit, add the sentence<br/>    if ((len(sentence.encode('utf-8')) +  len(source_text_chunk.encode('utf-8')) &lt; 5000)):<br/>      source_text_chunk += ' ' + sentence</span><span id="0541" class="mq lu iq nd b gy nl ni l nj nk">    # else translate chunck and start new one with current sentence<br/>    else:<br/>      translated_text += ' ' + translate(source_text_chunk)</span><span id="c02a" class="mq lu iq nd b gy nl ni l nj nk">     # if current sentence smaller than 5000 chars, start new chunck<br/>     if (len(sentence.encode('utf-8')) &lt; 5000):<br/>       source_text_chunk = sentence</span><span id="6e53" class="mq lu iq nd b gy nl ni l nj nk">     # else, replace sentence with notification message<br/>     else:<br/>       message = "&lt;&lt;Omitted Word longer than 5000bytes&gt;&gt;"<br/>       translated_text += ' ' + translate(message)</span><span id="2f00" class="mq lu iq nd b gy nl ni l nj nk">       # Re-set text container to empty<br/>       source_text_chunk = ''</span><span id="8068" class="mq lu iq nd b gy nl ni l nj nk">  # Translate the final chunk of input text, if there is any valid   text left to translate<br/>  if translate(source_text_chunk) != None:<br/>    translated_text += ' ' + translate(source_text_chunk)</span><span id="1aa0" class="mq lu iq nd b gy nl ni l nj nk">  return translated_text</span></pre><p id="54ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了看看它是否有效，我们将我们的翻译功能应用于我们之前已经处理过的页面。对于不讲德语的人来说，显然每小时生产率在 1978 年提高了大约 4%。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="0553" class="mq lu iq nd b gy nh ni l nj nk">extracted = extract(pdf.pages[12])<br/>translated = translate_extracted(extracted)[:500]</span><span id="c860" class="mq lu iq nd b gy nl ni l nj nk">print(translated)<br/>&gt;&gt;&gt;3 of the production potential. The statistical possibilities allow only an approximation of the closures that still occur physically due to long-term shrinkage ...</span></pre><h2 id="a901" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">写作</h2><p id="f1e0" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们几乎有我们需要的一切。像我一样，你可能需要将提取的文本转换成人类容易阅读的格式。虽然很容易将字符串保存到<strong class="ky ir">。在 Python 中，缺少换行符使得它们不适合长报告。相反，我们将在这里使用<strong class="ky ir"> fpdf2 </strong> <a class="ae kv" href="https://pyfpdf.github.io/fpdf2/index.html" rel="noopener ugc nofollow" target="_blank">库</a>将它们写回 PDF，该库显然继承了不再维护的<strong class="ky ir"> pyfpdf </strong>包。</strong></p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="7b90" class="mq lu iq nd b gy nh ni l nj nk">from fpdf import FPDF</span></pre><p id="aab0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在初始化一个 FPDF 对象后，我们可以为我们翻译的每一页添加一个页面对象，并将它们写在那里。这将帮助我们保持原始文档的结构。需要注意两点:首先，在<strong class="ky ir"> multi_cell </strong>中，我们将宽度设置为零以获得全宽，并选择高度为<em class="ls"> 5 </em>以获得细线间距。其次，由于预装字体与 Unicode 不兼容，我们将编码改为“<em class="ls"> latin-1 </em>”。有关下载和使用 Unicode 兼容字体的说明，请参见<strong class="ky ir">FPD F2</strong>T18】网站上的说明。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="03a0" class="mq lu iq nd b gy nh ni l nj nk">fpdf = FPDF()<br/>fpdf.set_font("Helvetica", size = 7)</span><span id="2977" class="mq lu iq nd b gy nl ni l nj nk">fpdf.add_page()<br/>fpdf.multi_cell(w=0,h=5,<br/>               txt= translated.encode("latin-1",errors = "replace"<br/>                             ).decode("latin-1")<br/>                )<br/>fpdf.output("output/page12.pdf")</span></pre><p id="5b3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，就像在提取中一样，显然你可以用<strong class="ky ir"> fpdf2 </strong>做更多的事情，比如添加页码、标题布局等等。然而，对于本文的目的来说，这个最小的设置就足够了。</p><h1 id="79a7" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">把所有东西绑在一起</strong></h1><p id="587a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">现在，我们将把所有内容汇集到一个管道中。请记住，为了避免丢失太多信息，我们对每个页面进行单独操作。重要的是，我们对翻译做了两处修改:由于一些页面是空的，但是空字符串对于<strong class="ky ir"> GoogleTranslator </strong>来说不是有效的输入，我们在翻译之前放置了一个 if 条件。其次，因为<strong class="ky ir"> nltk </strong>将我们的分段符(即“<em class="ls"> \n\n </em>”)分配到句子后面的<em class="ls">的开头，<strong class="ky ir"> GoogleTranslate </strong>忽略这些。这就是为什么我们用列表理解法单独翻译每一段。耐心点，翻译 150 页可能需要 7 分钟！</em></p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="6a56" class="mq lu iq nd b gy nh ni l nj nk"># Open PDF<br/>with pdfplumber.open(“src/examples/1978-geschaeftsbericht-data.pdf”) as pdf:<br/>  # Initialize FPDF file to write on<br/>  fpdf = FPDF()<br/>  fpdf.set_font(“Helvetica”, size = 7)</span><span id="e3c6" class="mq lu iq nd b gy nl ni l nj nk">  # Treat each page individually<br/>  for page in pdf.pages:<br/>    # Extract Page<br/>    extracted = extract(page)</span><span id="a8d5" class="mq lu iq nd b gy nl ni l nj nk">    # Translate Page<br/>    if extracted != “”:<br/>      # Translate paragraphs individually to keep breaks<br/>      paragraphs = extracted.split(“\n\n”)<br/>      translated = “\n\n”.join(<br/>        [translate_extracted(paragraph) for paragraph in paragraphs]<br/>        )<br/>    else:<br/>      translated = extracted</span><span id="e465" class="mq lu iq nd b gy nl ni l nj nk">    # Write Page<br/>    fpdf.add_page()<br/>    fpdf.multi_cell(w=0, h=5,<br/>                   txt= translated.encode(“latin-1”,<br/>                                          errors = “replace”<br/>                                 ).decode(“latin-1”))</span><span id="4c81" class="mq lu iq nd b gy nl ni l nj nk"> # Save all FPDF pages<br/> fpdf.output(“output/trans_1978-geschaeftsbericht-data.pdf.pdf”)</span></pre><h1 id="8584" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">结论</h1><p id="78f1" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">谢谢你坚持到最后。我希望这篇文章能给你一个关于如何翻译 pdf 和什么是最先进的软件包的实例。在整篇文章中，我指出了这个基本示例的各种潜在扩展(例如，添加页码、布局等。)，所以请分享你的方法——我很想听听。当然，我也总是渴望听到关于如何改进代码的建议。</p><p id="31ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意安全，保持联系！</p></div></div>    
</body>
</html>