<html>
<head>
<title>ArXiv Scientific Papers Vector Similarity Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ArXiv科学论文向量相似性搜索</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/arxiv-scientific-papers-vector-similarity-search-15059970a73a#2022-08-09">https://towardsdatascience.com/arxiv-scientific-papers-vector-similarity-search-15059970a73a#2022-08-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f93f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>的&lt;50ms using Dask, SBERT SPECTRE, and Milvus Vector database</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5e94081a2d487f410be6893e1a0e7a09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wyGMrC1gbHT941p4"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Photo by <a class="ae ky" href="https://unsplash.com/@rosssneddon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ross Sneddon </a>上对大约64万篇论文进行语义搜索查询</p></figure><h1 id="fe0b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="bf96" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">了解任何最新数据科学主题的最佳方式之一是阅读关于arxiv.org<a class="ae ky" href="https://arxiv.org/" rel="noopener ugc nofollow" target="_blank">的开源研究论文。然而，即使对于最有经验的研究人员来说，大量的研究论文也可能让人不知所措。像</a><a class="ae ky" href="https://www.connectedpapers.com/" rel="noopener ugc nofollow" target="_blank"> connected papers </a>这样的工具可以有所帮助，但它们基于论文之间共享的<a class="ae ky" href="https://www.connectedpapers.com/about" rel="noopener ugc nofollow" target="_blank">引文和参考书目</a>来衡量相似性，而不是这些文档中文本的语义。</p><p id="3360" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这篇文章中，我开始构建一个语义相似性搜索引擎，它以单个“查询”论文作为输入，并使用最先进的NLP从arxiv语料库中大约64万篇计算机科学论文中找到前K篇最相似的论文！搜索运行时使用&lt;50ms latency on a single laptop! Specifically, in this post, I’ll cover</p><ol class=""><li id="93e0" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated"><a class="ae ky" href="https://medium.com/p/15059970a73a/#1955" rel="noopener">设置环境并从Kaggle </a>下载arXiv数据</li><li id="14dc" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><a class="ae ky" href="https://medium.com/p/15059970a73a/#93a7" rel="noopener">使用Dask </a>将数据加载到Python中</li><li id="62be" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><a class="ae ky" href="https://medium.com/p/15059970a73a/#ac96" rel="noopener">使用Milvus矢量数据库实现科学论文语义相似性搜索应用</a></li></ol><p id="7c3b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这篇文章中使用的技术可以作为模板来构建任何NLP语义相似性搜索引擎，而不仅仅是科学论文。唯一的区别是所使用的预训练模型。</p><p id="c1ab" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这篇文章中，我们将使用来自Kaggle 的<a class="ae ky" href="https://www.kaggle.com/datasets/Cornell-University/arxiv" rel="noopener ugc nofollow" target="_blank"> arXiv数据集，它是作者在</a><a class="ae ky" href="https://creativecommons.org/publicdomain/zero/1.0/" rel="noopener ugc nofollow" target="_blank"> CC0: Public Domain </a>许可下发布的。</p><p id="6a5f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我在下面的上一篇文章中概述了生产规模的向量相似性搜索的注意事项。所有这些考虑也适用于这个项目。Milvus vector database设计得非常好，许多步骤都完全相同，这里重复只是为了完整。</p><div class="ng nh gp gr ni nj"><a href="https://medium.com/unstructured-data-service/supercharged-semantic-similarity-search-in-production-f2a3c35c4e00" rel="noopener follow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">生产中的超级语义相似性搜索</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">利用剪辑嵌入和Milvus实现超高速、高度可扩展的文本到图像搜索</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">medium.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx ks nj"/></div></div></a></div><h1 id="1955" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">设置环境并从Kaggle下载arxiv数据。</h1><p id="6088" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">康奈尔大学已经将整个arXiv语料库上传到一个<a class="ae ky" href="https://www.kaggle.com/datasets/Cornell-University/arxiv" rel="noopener ugc nofollow" target="_blank"> Kaggle数据集</a>，并根据<a class="ae ky" href="https://creativecommons.org/publicdomain/zero/1.0/" rel="noopener ugc nofollow" target="_blank"> CC0:公共领域</a>许可对其进行许可。我们可以使用Kaggle API直接下载数据集。如果您还没有这样做，请按照这些说明<a class="ae ky" rel="noopener" target="_blank" href="/powering-semantic-similarity-search-in-computer-vision-with-state-of-the-art-embeddings-f6c183fff134#072e">在您的系统上设置ka ggle API</a>。</p><p id="19c3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将在这篇文章中使用一个名为semantic_similarity的conda环境。如果你的系统上没有安装conda，你可以从<a class="ae ky" href="https://github.com/conda-forge/miniforge" rel="noopener ugc nofollow" target="_blank">这里</a>安装开源的mini forge。下面的步骤创建必要的目录和conda环境，安装所需的Python库，并从Kaggle 下载<a class="ae ky" href="https://www.kaggle.com/datasets/Cornell-University/arxiv" rel="noopener ugc nofollow" target="_blank"> arxiv数据集。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者代码</p></figure><h1 id="93a7" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">使用Dask将数据加载到Python</h1><p id="4203" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们从Kaggle下载的数据是一个3.3GB的JSON文件，包含大约200万篇论文！为了有效地处理如此大的数据集，使用pandas将整个数据集加载到内存中并不是一个好主意。相反，我们可以使用Dask将数据分成多个分区，并且在任何给定时间只将几个分区加载到内存中。</p><h2 id="c808" class="oa la it bd lb ob oc dn lf od oe dp lj ma of og ll me oh oi ln mi oj ok lp ol bi translated">达斯克</h2><p id="c6e2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><a class="ae ky" href="https://dask.org/" rel="noopener ugc nofollow" target="_blank"> Dask </a>是一个开源库，它允许我们使用类似于熊猫的API轻松应用并行计算。在本地机器上运行<code class="fe om on oo op b">"pip install dask[complete]"</code>进行设置很简单，如设置部分所示。让我们首先导入必要的库。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者代码</p></figure><p id="0b5c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将使用Dask的两个组件来高效地处理大型arxiv JSON文件。</p><ol class=""><li id="da45" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated"><a class="ae ky" href="https://docs.dask.org/en/latest/bag.html" rel="noopener ugc nofollow" target="_blank"> Dask Bag </a>:它让我们以固定大小的块加载JSON文件，并对每行数据运行一些预处理函数。</li><li id="9d9c" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">dask数据框架:我们可以将dask包转换成Dask数据框架来访问类似熊猫的API</li></ol><h2 id="7681" class="oa la it bd lb ob oc dn lf od oe dp lj ma of og ll me oh oi ln mi oj ok lp ol bi translated">步骤1:将JSON文件装入Dask包中</h2><p id="04aa" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们将JSON文件加载到一个dask包中，其中每个块的大小为10MB。您可以调整<code class="fe om on oo op b">blocksize</code>参数来控制每个块的大小。然后我们将<code class="fe om on oo op b">json.loads</code>函数应用到dask包的每一行，使用<code class="fe om on oo op b">.map()</code>函数将JSON字符串解析到Python字典中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者代码</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/db10f34bdf554b895bc9c1cf76d43edb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PboUrKUTQtyzsDIWJH-fdA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="ea60" class="oa la it bd lb ob oc dn lf od oe dp lj ma of og ll me oh oi ln mi oj ok lp ol bi translated">步骤2:编写预处理助手函数</h2><p id="817e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">从打印输出中，我们看到每一行都包含几个与论文相关的元数据。让我们编写三个助手函数来帮助我们预处理数据集。</p><ol class=""><li id="c222" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated">v1_date():这个函数用于提取作者将论文的第一个版本上传到arXiv的日期。我们将把日期转换为UNIX时间，并将其作为一个新字段存储在该行中。</li><li id="edc3" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">text_col():这个函数使用一个“[SEP]”标记来组合“title”和“abstract”字段，这样我们就可以将这些文本输入到<a class="ae ky" href="https://arxiv.org/abs/2004.07180" rel="noopener ugc nofollow" target="_blank"> SPECTRE嵌入模型</a>中。我们将在下一节详细讨论SPECTRE。</li><li id="2b58" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">filters():这个函数只保留满足某些条件的行，比如各列中的最大文本长度和计算机科学类别中的论文。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者代码</p></figure><h2 id="2367" class="oa la it bd lb ob oc dn lf od oe dp lj ma of og ll me oh oi ln mi oj ok lp ol bi translated">步骤3:在Dask包上运行预处理助手函数</h2><p id="0769" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们可以很容易地使用<code class="fe om on oo op b">.map()</code>和<code class="fe om on oo op b">.filter()</code>函数在Dask包的每一行上运行助手函数，如下所示。因为Dask支持方法链接，所以我们利用这个机会只保留Dask包中的几个重要列，而丢弃其余的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者代码</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/b71f36d986638724761a0c59aafdde7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gC5p8Fo3sS58MFXqc-wBNA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="de56" class="oa la it bd lb ob oc dn lf od oe dp lj ma of og ll me oh oi ln mi oj ok lp ol bi translated">步骤4:将Dask包转换为Dask数据帧</h2><p id="ffef" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">数据加载的最后一步是将Dask包转换成Dask数据帧，以便在数据的每个块或分区上使用类似熊猫的API。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者代码</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/e97b011a2e84b0fe882ef41b7d304bf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tRRD9igiho57wFnVCaf-UQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="ac96" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">使用Milvus向量数据库实现科技论文语义相似性搜索应用</h1><p id="cc9d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Milvus 是最受欢迎的开源矢量数据库之一，为高度可伸缩和极快的矢量相似性搜索而构建。因为我们只在本地机器上运行Milvus，所以在这篇文章中我们将使用独立的Milvus。</p><h2 id="67cb" class="oa la it bd lb ob oc dn lf od oe dp lj ma of og ll me oh oi ln mi oj ok lp ol bi translated">步骤1:在本地安装Milvus vector数据库</h2><p id="eaae" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">使用Docker安装Milvus矢量数据库轻而易举，因此我们首先需要安装<a class="ae ky" href="https://docs.docker.com/engine/install/" rel="noopener ugc nofollow" target="_blank"> Docker </a>和<a class="ae ky" href="https://docs.docker.com/compose/install/" rel="noopener ugc nofollow" target="_blank"> Docker Compose </a>。然后，我们需要做的就是下载一个<code class="fe om on oo op b">docker-compose.yml</code>并启动docker容器，如下面的代码片段所示！milvus.io网站提供了许多其他选项来安装milvus单机版和Milvus集群；如果您需要将其安装在<a class="ae ky" href="https://milvus.io/docs/v2.1.x/install_cluster-docker.md" rel="noopener ugc nofollow" target="_blank"> Kubernetes集群上</a>或<a class="ae ky" href="https://milvus.io/docs/v2.1.x/install_offline-docker.md" rel="noopener ugc nofollow" target="_blank">离线安装</a>，请查看。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者代码</p></figure><h2 id="ff64" class="oa la it bd lb ob oc dn lf od oe dp lj ma of og ll me oh oi ln mi oj ok lp ol bi translated">步骤2:创建Milvus系列</h2><p id="cffa" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们已经在本地机器上运行了Milvus vector数据库服务器，我们可以使用<code class="fe om on oo op b">pymilvus</code>库与它进行交互。首先，让我们导入必要的模块并连接到运行在<code class="fe om on oo op b">localhost</code>上的Milvus服务器。随意更改<code class="fe om on oo op b">alias</code>和<code class="fe om on oo op b">collection_name</code>参数。我们用来将文本转换成嵌入的模型决定了<code class="fe om on oo op b">emb_dim</code>参数的值。在SPECTRE的情况下，嵌入是768d。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者代码</p></figure><p id="2689" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">或者，您可以检查由<code class="fe om on oo op b">collection_name</code>指定的集合是否已经存在于您的Milvus服务器上。对于这个例子，如果集合已经可用，我就删除它。但是在生产服务器中，您不会这样做，而是会跳过下面的集合创建代码。</p><p id="7a33" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Milvus集合类似于传统数据库中的表。为了创建一个集合来存储数据，我们首先需要指定集合的<code class="fe om on oo op b">schema</code>。在本例中，我们利用<a class="ae ky" href="https://milvus.io/blog/2022-06-23-How-Short-video-Platform-Likee-Removes-Duplicate-Videos-with-Milvus.md#String-and-scalar-index-support" rel="noopener ugc nofollow" target="_blank"> Milvus 2.1存储字符串索引和字段</a>的能力来存储与每篇论文相关的所有必要元数据。主键<code class="fe om on oo op b">idx</code>和其他字段<code class="fe om on oo op b">categories, title, abstract</code>具有合理最大长度的<code class="fe om on oo op b">VARCHAR</code>数据类型，而<code class="fe om on oo op b">embedding</code>是包含<code class="fe om on oo op b">emb_dim</code>维度嵌入的<code class="fe om on oo op b">FLOAT_VECTOR </code>字段。Milvus支持多种数据类型，如这里的<a class="ae ky" href="https://milvus.io/docs/v2.0.x/field_schema.md#Supported-data-type" rel="noopener ugc nofollow" target="_blank">所示</a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者代码</p></figure><p id="8c51" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一旦创建了一个集合，我们现在就可以上传我们的文本和向量到其中了。</p><h2 id="bc90" class="oa la it bd lb ob oc dn lf od oe dp lj ma of og ll me oh oi ln mi oj ok lp ol bi translated">步骤3:迭代我们的Dask dataframe的分区，使用SPECTER嵌入文本，并将它们上传到Milvus矢量数据库。</h2><p id="8272" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">首先，我们需要将Dask数据帧中的文本转换成嵌入向量，以运行语义相似性搜索。我下面的帖子分享了我们如何将文本转换成嵌入。特别是，我们将使用名为SPECTRE的SBERT双编码器模型将科学论文转换为嵌入内容。</p><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/semantic-textual-similarity-83b3ca4a840e"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">语义文本相似度</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">从Jaccard到OpenAI，为您的语义文本相似性项目实现最佳的NLP算法</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="ot l nu nv nw ns nx ks nj"/></div></div></a></div><p id="8a20" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">SPECTER</strong>[<a class="ae ky" href="http://arxiv.org/abs/2004.07180" rel="noopener ugc nofollow" target="_blank">Paper</a>][<a class="ae ky" href="https://github.com/allenai/specter" rel="noopener ugc nofollow" target="_blank">Github</a>]:使用引文通知转换器的科学论文嵌入是将科学论文转换为嵌入的模型。</p><ul class=""><li id="a4ca" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm ou my mz na bi translated">每篇论文的标题和摘要文本都用[SEP]标记连接起来，并使用预训练的Transformer模型(SciBERT)的[CLS]标记转换为嵌入内容。</li><li id="6916" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm ou my mz na bi translated">使用引文作为文档间相关性的代理信号。如果一篇论文引用了另一篇，我们可以推断它们是相关的。</li><li id="4887" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm ou my mz na bi translated">三重损失训练目标:我们训练变压器模型，因此具有共享引用的论文在嵌入空间中更接近。</li><li id="982a" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm ou my mz na bi translated">换句话说，正面论文是被查询论文引用的论文，负面论文是未被查询论文引用的论文。随机抽样的底片是“容易”底片。</li><li id="d0e8" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm ou my mz na bi translated">为了提高性能，我们使用未被查询论文引用但被肯定论文引用的论文来创建“硬”否定。</li><li id="6e52" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm ou my mz na bi translated">推理时我们只需要标题和摘要。不需要引用，因此SPECTER甚至可以为没有任何引用的新论文生成嵌入！</li><li id="dd21" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm ou my mz na bi translated">SPECTER在主题分类、引用预测和科学论文推荐方面提供了出色的性能(优于SciBERT)。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/5abd6f8c3e97a5bc51e94f486473b4c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BOJpwXkfk00xWYI4i4dMqQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者使用来自开源<a class="ae ky" href="https://arxiv.org/abs/2004.07180" rel="noopener ugc nofollow" target="_blank"> SPECTER论文</a>的截图制作</p></figure><p id="7e5a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">通过句子转换器库，使用预先训练的SPECTRE模型很简单。我们只需一行代码就可以下载预先训练好的模型，如下所示。我们还编写了一个简单的助手函数，将Dask dataframe分区中的一整列文本转换成嵌入文本。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者代码</p></figure><p id="f606" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们需要遍历Dask dataframe的分区，将数据上传到我们的Milvus集合中。在每次迭代中，我们只将该分区中的行加载到内存中，并将元数据列中的数据添加到变量<code class="fe om on oo op b">data</code>中。我们可以使用dask <code class="fe om on oo op b">.map_partitions()</code> API将嵌入生成应用于分区中的每一行，并将结果追加回同一个<code class="fe om on oo op b">data</code>变量。最后，我们可以用<code class="fe om on oo op b">collection.insert</code>将数据上传到Milvus。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者代码</p></figure><p id="559e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">请注意，添加到<code class="fe om on oo op b">data</code>变量中的列的顺序必须与我们在模式创建期间定义的<code class="fe om on oo op b">fields</code>变量的顺序相同！</p><h2 id="3182" class="oa la it bd lb ob oc dn lf od oe dp lj ma of og ll me oh oi ln mi oj ok lp ol bi translated">步骤4:在上传的数据上创建近似最近邻(ANN)索引</h2><p id="c57c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我们将所有的嵌入插入Milvus向量数据库之后，我们需要创建一个ANN索引来加速搜索。在本例中，我使用的是<code class="fe om on oo op b">HNSW</code>索引类型，<a class="ae ky" href="https://pub.towardsai.net/knn-k-nearest-neighbors-is-dead-fc16507eb3e" rel="noopener ugc nofollow" target="_blank">是最快、最准确的人工神经网络索引</a>之一。查看<a class="ae ky" href="https://milvus.io/docs/v2.1.x/index.md#HNSW" rel="noopener ugc nofollow" target="_blank"> Milvus文档</a>了解更多关于<code class="fe om on oo op b">HNSW</code>索引及其参数的信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者代码</p></figure><h2 id="e016" class="oa la it bd lb ob oc dn lf od oe dp lj ma of og ll me oh oi ln mi oj ok lp ol bi translated">第五步:运行你的向量相似性搜索查询！</h2><p id="2db8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最后，我们的Milvus集合中的数据已经可以进行查询了。首先，我们必须将集合加载到内存中，以便对其运行查询。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者代码</p></figure><p id="6867" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">接下来，我创建了一个简单的助手函数，它接收一个query_text，将其转换为SPECTRE嵌入，在Milvus集合中执行ANN搜索，并打印出结果。我们可以使用这里描述的search _ params<a class="ae ky" href="https://milvus.io/docs/v2.1.x/index.md#HNSW" rel="noopener ugc nofollow" target="_blank">来控制搜索质量和速度。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者代码</p></figure><p id="d365" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，我们只需一行代码就可以使用helper函数对存储在我们的Milvus收藏中的大约64万篇计算机科学论文进行语义arXiv论文搜索。例如，我正在搜索一些类似于我在<a class="ae ky" rel="noopener" target="_blank" href="/semantic-textual-similarity-83b3ca4a840e#373c">上一篇文章</a>中详细讨论的<a class="ae ky" href="https://arxiv.org/abs/2104.08821" rel="noopener ugc nofollow" target="_blank"> SimCSE论文</a>的论文。前10个结果与我的搜索查询非常相关，因为它们大多与句子嵌入的对比学习有关！更令人印象深刻的是，整个搜索仅在我的笔记本电脑上运行了30毫秒，这完全符合大多数应用程序的典型使用要求！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者代码</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/75e137010f8c0deeab75a24db5fd2eb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VbhLyj7J0UFbmVmj8EIDXw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="e2a5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果我们不需要运行更多的查询，我们可以释放集合来释放我们机器的内存。从内存中删除收藏不会导致数据丢失，因为它仍然存储在我们的磁盘上，并可以在需要时再次加载。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者代码</p></figure><p id="bb3a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你想停止Milvus服务器并删除磁盘上的所有数据，你可以按照这里的说明<a class="ae ky" href="https://milvus.io/docs/v2.1.x/install_standalone-docker.md#Stop-Milvus" rel="noopener ugc nofollow" target="_blank">操作</a>。当心！此操作不可逆，将删除Milvus群集中的所有数据。</p><h1 id="2566" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="3f3c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在这篇文章中，我们通过几个简单的步骤，使用SPECTRE embeddings和Milvus vector database实现了一个超可扩展的科学论文语义搜索服务。这种方法在生产中可扩展到数亿甚至数十亿个载体。我们使用一个简单的纸质查询测试了这个搜索，仅用了30毫秒就返回了前10个结果！Milvus作为一个高度可扩展和高速矢量相似性搜索数据库的声誉是当之无愧的！</p><p id="980f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要获得更多关于Milvus应用的灵感，请前往<a class="ae ky" href="https://milvus.io/milvus-demos/" rel="noopener ugc nofollow" target="_blank"> Milvus </a>矢量数据库<a class="ae ky" href="https://milvus.io/milvus-demos/" rel="noopener ugc nofollow" target="_blank">演示</a>和<a class="ae ky" href="https://github.com/milvus-io/bootcamp/tree/master/solutions/reverse_image_search" rel="noopener ugc nofollow" target="_blank"> Bootcamp </a>。</p></div><div class="ab cl ox oy hx oz" role="separator"><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc"/></div><div class="im in io ip iq"><p id="d5e1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="pe">最初发表于</em><a class="ae ky" href="https://zilliz.com/blog/Arxiv-scientific-papers-vector-similarity-search" rel="noopener ugc nofollow" target="_blank"><em class="pe">zilliz.com</em></a></p></div></div>    
</body>
</html>