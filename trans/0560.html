<html>
<head>
<title>How to Download and Explore Movie Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何下载和浏览电影数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-download-and-explore-movie-data-1948a887c530#2022-02-22">https://towardsdatascience.com/how-to-download-and-explore-movie-data-1948a887c530#2022-02-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/d142e4c659a1739495c1ef6c70cbc88d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_GPVfHUwrfdKdJwO2eCAng.png"/></div></div></figure><div class=""/><div class=""><h2 id="e2fb" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">使用TMDB API和python通过网络分析探索2022年奥斯卡提名</h2></div><p id="1516" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">又到了莫伊拉·罗斯最喜欢的季节——颁奖！我认为这将是一个很好的机会来对2022年奥斯卡提名做一些网络分析，并与TMDB API玩玩。本教程将带您了解:</p><ul class=""><li id="dee3" class="lq lr je kv b kw kx kz la lc ls lg lt lk lu lo lv lw lx ly bi translated">向TMDB API查询所有2022奥斯卡提名电影的演员和工作人员的完整列表，</li><li id="3250" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">从数据中提取网络，</li><li id="d0f8" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">并对提取的图形做一些简单的数据分析和网络分析</li></ul><p id="25b9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">请尽情享受，并随时在底部提出您的任何问题或疑问！<a class="ae lp" href="https://github.com/SteveHedden/FilmClub/tree/master/2022OscarNoms" rel="noopener ugc nofollow" target="_blank">如果你想作为参考，这里有一个链接</a>指向我的GitHub上的代码。</p><h1 id="7108" class="me mf je bd mg mh mi mj mk ml mm mn mo kk mp kl mq kn mr ko ms kq mt kr mu mv bi translated">查询TMDB API</h1><p id="5e6c" class="pw-post-body-paragraph kt ku je kv b kw mw kf ky kz mx ki lb lc my le lf lg mz li lj lk na lm ln lo im bi translated">首先，感谢<a class="ae lp" href="https://dev.to/m0nica" rel="noopener ugc nofollow" target="_blank"> Monica Powell </a>撰写了<a class="ae lp" href="https://dev.to/m0nica/how-to-use-the-tmdb-api-to-find-films-with-the-highest-revenue-82p" rel="noopener ugc nofollow" target="_blank">这篇文章</a>，它帮助我理解了TMDB API。</p><p id="b35d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">要开始，你需要去<a class="ae lp" href="https://www.themoviedb.org/" rel="noopener ugc nofollow" target="_blank"> TMDB站点</a>获取一个API密匙。要获得API密钥，只需访问该网站，注册一个新帐户，并使用您的新帐户生成一个新的API密钥。它们让事情变得非常简单，我很快就能拿到钥匙。</p><p id="2fb2" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">有了密钥后，创建一个config.py文件，将密钥与代码放在一起:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="8b28" class="nk mf je ng b gy nl nm l nn no">tmdb_api_key = "YOUR API KEY”</span></pre><p id="464e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这不是绝对必要的，但是养成将API键存储在配置文件中而不是直接存储在代码中的习惯是一个好主意，尤其是如果您打算将它发布在GitHub上的话。你不想与任何人共享你的API密匙，所以把密匙放在一个单独的文件中允许你共享你的代码而不共享你的密匙。</p><p id="9e6f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在我们可以开始从TMDB提取数据，并在Jupyter笔记本上进行处理。首先，让我们导入我们的包:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="5d24" class="nk mf je ng b gy nl nm l nn no">import config # to hide TMDB API keys<br/>import requests # to make TMDB API calls<br/>locale.setlocale( locale.LC_ALL, '' )</span><span id="5fdf" class="nk mf je ng b gy np nm l nn no">import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import itertools<br/>from pandas import json_normalize <br/>import networkx as nx<br/>import datetime</span><span id="a3a3" class="nk mf je ng b gy np nm l nn no">api_key = config.tmdb_api_key # get TMDB API key from config.py file</span></pre><p id="16fc" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">电影数据库API有很棒的文档<a class="ae lp" href="https://developers.themoviedb.org/3/getting-started/introduction" rel="noopener ugc nofollow" target="_blank">在这里。</a>我发现<a class="ae lp" rel="noopener" target="_blank" href="/this-tutorial-will-make-your-api-data-pull-so-much-easier-9ab4c35f9af">Tessa Xie</a><a class="nq nr ep" href="https://medium.com/u/dadb1d33c05a?source=post_page-----1948a887c530--------------------------------" rel="noopener" target="_blank">的这篇教程</a>对于理解如何使用这个API运行不同的查询非常有帮助。</p><p id="6013" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">出于本教程的目的，我们对电影的“演职员表”感兴趣，即演员和工作人员的完整列表。要获得这些信息，我们可以使用如下查询:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="956a" class="nk mf je ng b gy nl nm l nn no">#Test API by pulling full credits for "Dune"<br/>query = "<a class="ae lp" href="https://api.themoviedb.org/3/movie/" rel="noopener ugc nofollow" target="_blank">https://api.themoviedb.org/3/movie/</a>" + "438631" + "/credits?api_key=" + api_key + "&amp;language=en-US"<br/>response =  requests.get(query)<br/>array = response.json()</span></pre><p id="04a5" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这将从TMDB获得电影'<a class="ae lp" href="https://www.themoviedb.org/movie/438631-dune?language=en-US" rel="noopener ugc nofollow" target="_blank"> Dune </a>'的所有演职员表，并将其转换为JSON格式。JSON有两个组件:演职人员和工作人员。我们可以使用以下代码将完整的演员表提取到pandas数据帧中:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="fb74" class="nk mf je ng b gy nl nm l nn no">#Get full cast and put into a pandas DF<br/>temp_cast = json_normalize(array, 'cast')</span></pre><p id="f523" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在我们有了《沙丘》全体演员的数据框架。要将这些数据视为一个网络，我们需要转换这些数据。我们想把演员名单上的每个人和其他人联系起来。我发现最快的方法是使用下面的代码:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="5acc" class="nk mf je ng b gy nl nm l nn no">#Turn dataframe into a dyadic dataset that we can turn into a graph<br/>dyads_cast = pd.DataFrame(list(itertools.combinations(temp_cast['name'], 2)))<br/>dyads_cast = dyads_cast.drop_duplicates()<br/>dyads_cast.columns = ['source','target']</span></pre><p id="9085" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这就创建了一个“边缘”的数据框架——每个参与者都与其他参与者建立了联系。对于一部电影来说，这并不有趣。我们可以通过使用NetworkX包将数据帧转换为图形，并使用matplotlib进行可视化，来创建这个网络的简单可视化。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="7c6b" class="nk mf je ng b gy nl nm l nn no">#Turn df into graph using NetworkX<br/>G = nx.from_pandas_edgelist(dyads_cast, 'source', 'target')<br/>pos = nx.spring_layout(G)<br/></span><span id="1439" class="nk mf je ng b gy np nm l nn no">f, ax = plt.subplots(figsize=(10, 10))<br/>plt.style.use('ggplot')</span><span id="a4b8" class="nk mf je ng b gy np nm l nn no">nodes = nx.draw_networkx_nodes(G, pos,<br/>                               alpha=0.8)<br/>nodes.set_edgecolor('k')<br/>nx.draw_networkx_labels(G, pos, font_size=18)</span><span id="85f1" class="nk mf je ng b gy np nm l nn no">nx.draw_networkx_edges(G, pos, width=1.0, alpha=0.2)</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ns"><img src="../Images/41ffbf9a80fff34f61cf199c460f2f99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sw-BimLJMLU5Fw__Q1WALw.png"/></div></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">作者图片</p></figure><h1 id="dcda" class="me mf je bd mg mh mi mj mk ml mm mn mo kk mp kl mq kn mr ko ms kq mt kr mu mv bi translated">从API中提取所有奥斯卡提名</h1><p id="0b17" class="pw-post-body-paragraph kt ku je kv b kw mw kf ky kz mx ki lb lc my le lf lg mz li lj lk na lm ln lo im bi translated">就像我说的，一部电影看这种网络没什么意思。我们需要奥斯卡提名者的完整名单。据我所知，没有一种简单的方法可以将这些列表转换成可以进行TMDB查询的格式，所以我手工制作了自己的列表。如果你想在本教程中使用它，我已经把它附在了<a class="ae lp" href="https://github.com/SteveHedden/FilmClub/tree/master/2022OscarNoms" rel="noopener ugc nofollow" target="_blank">我的GitHub </a>上。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="1015" class="nk mf je ng b gy nl nm l nn no">movies = pd.read_csv("oscars.csv")<br/>#There is no data for the movie Ascension so I exclude to avoid errors later<br/>movies = movies.loc[movies['original_title'] != "Ascension"]</span></pre><p id="4ed2" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在是有趣的部分。我们想遍历2022年奥斯卡提名的列表，并获得每个提名的全部演员和工作人员，然后将每个提名附加到一个数据帧中。下面的代码遍历我们制作的电影列表，查询TMDB，提取演员和工作人员的数据帧，然后将它们附加到full_cast_df和full_crew_df。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="45af" class="nk mf je ng b gy nl nm l nn no">#Create empty DataFrames to append to<br/>full_cast_df = pd.DataFrame()<br/>full_crew_df = pd.DataFrame()</span><span id="d8fd" class="nk mf je ng b gy np nm l nn no">#Loop through movie list<br/>for index, row in movies.iterrows():<br/>    movie_id = row['id']<br/>    #Query TMDB for cast and crew for movie<br/>    query = "<a class="ae lp" href="https://api.themoviedb.org/3/movie/" rel="noopener ugc nofollow" target="_blank">https://api.themoviedb.org/3/movie/</a>" + str(movie_id) + "/credits?api_key=" + api_key + "&amp;language=en-US"<br/>    response =  requests.get(query)<br/>    if response.status_code==200: <br/>    #status code ==200 indicates the API query was successful<br/>        array = response.json()<br/>        title = row['original_title']<br/>        #Create DataFrames for this movies cast and crew lists<br/>        temp_cast = json_normalize(array, 'cast')<br/>        temp_crew = json_normalize(array, 'crew')<br/>        #Create a new column called 'movie' where we put the title of the movie<br/>        temp_cast = temp_cast.assign(movie=title)<br/>        temp_crew = temp_crew.assign(movie=title)<br/>        <br/>        #Append individual movies cast and crew list to the main dataframe so we have one with all of them<br/>        full_cast_df = pd.concat([full_cast_df, temp_cast])<br/>        full_crew_df = pd.concat([full_crew_df, temp_crew])</span></pre><p id="c3b5" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">你可能想分别研究演职人员和工作人员列表，但是在本教程中，我将把他们合并成一个完整的演职人员列表:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="60d2" class="nk mf je ng b gy nl nm l nn no">fullCastAndCrewDF = pd.concat([full_cast_df,full_crew_df])</span></pre><p id="9e90" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">将这些组合在一起的一个问题是，剧组有一个名为“角色”的栏目，描述他们在电影中的角色，而演员有一个名为“角色”的栏目，列出他们角色的名字。我们希望有一个专栏可以让我们知道这个人在电影中的角色是什么:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="8761" class="nk mf je ng b gy nl nm l nn no">def getRole(x):<br/>    if pd.isnull(x['character']) == True:<br/>        return(x['movie'] + ": " + x['job'])<br/>    else:<br/>        return(x['movie'] + ": " + "Actor " + x['character'])</span><span id="f710" class="nk mf je ng b gy np nm l nn no">fullCastAndCrewDF['role'] = fullCastAndCrewDF.apply(lambda x: getRole(x), axis = 1)</span></pre><h1 id="fa2a" class="me mf je bd mg mh mi mj mk ml mm mn mo kk mp kl mq kn mr ko ms kq mt kr mu mv bi translated">我们数据的一些数据分析</h1><p id="b6d1" class="pw-post-body-paragraph kt ku je kv b kw mw kf ky kz mx ki lb lc my le lf lg mz li lj lk na lm ln lo im bi translated">在我们开始创建所有这些人的大网络并在图上运行网络分析之前，我们可以使用这个DF来回答一些问题，例如，“谁在2022年奥斯卡提名最多的电影中？”</p><p id="341b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">下面的代码按照名字和角色对DF进行分组(跨所有电影)，然后按照最多产的人进行排序。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="50b0" class="nk mf je ng b gy nl nm l nn no">prolifics = fullCastAndCrewDF.groupby(['name']).agg({'movie':lambda x: list(x), 'role':lambda x: list(x)})<br/>prolifics['freq'] = prolifics['movie'].apply(lambda x: len(x))<br/>pd.set_option("display.max_colwidth", -1)<br/>prolifics.sort_values('freq',ascending=False).head(10)</span></pre><p id="7d9a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">以下是我的结果:</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nx"><img src="../Images/7174723f81b608e09df908f91939655b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*acUAyX5_iCX2QeuZ4jor1Q.png"/></div></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">作者图片</p></figure><p id="2bbf" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们名单上最多产的人是林·曼努尔·米兰达。他监制，导演，在《滴答，滴答，嘣》里有个小角色！，同时也为恩坎托写歌作曲。他还在纪录片《自我的灵魂之夏》中扮演了一个角色，在2022年奥斯卡提名中获得了6个学分。</p><p id="1d20" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这份名单上有几个人在同一部电影中有多个演职员表。例如，保罗·托马斯·安迪生是《甘草披萨》的制片人、导演、编剧和摄影师。如果我们排除同一部电影中的多个角色呢？</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="bce0" class="nk mf je ng b gy nl nm l nn no">fullCastAndCrewDF_noDupes = fullCastAndCrewDF.drop_duplicates(['name','movie'])<br/>prolifics2 = fullCastAndCrewDF_noDupes.groupby(['name']).agg({'movie':lambda x: list(x), 'role':lambda x: list(x)})<br/>prolifics2['freq'] = prolifics2['movie'].apply(lambda x: len(x))<br/>pd.set_option("display.max_colwidth", -1)<br/>prolifics2.sort_values('freq',ascending=False).head(15)</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ny"><img src="../Images/f94af5435351eeacb4e413532cd46306.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1nCiQDbKqNTNzGCt4KsRaA.png"/></div></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">作者图片</p></figure><p id="1056" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这是三部奥斯卡提名电影的完整名单。只有三个演员演过三部电影:玛娅·鲁道夫、安德鲁·加菲尔德和本尼迪特·王。约翰尼·格林伍德是三部电影的作曲家，这太不可思议了，但其他几个人也为三部不同的奥斯卡提名电影工作。</p><h1 id="9f41" class="me mf je bd mg mh mi mj mk ml mm mn mo kk mp kl mq kn mr ko ms kq mt kr mu mv bi translated">从数据中提取网络</h1><p id="bc65" class="pw-post-body-paragraph kt ku je kv b kw mw kf ky kz mx ki lb lc my le lf lg mz li lj lk na lm ln lo im bi translated">现在我们已经有了一个包含我们想要的所有内容的数据框架，我们可以提取一个网络并在其上运行一些网络分析。我们有两种方法可以提取这个网络:我们可以把电影看作节点，把人看作它们之间的连接(或边)，也可以把人看作节点，把电影看作边。首先，让我们创建一个以电影为节点的网络。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="c70b" class="nk mf je ng b gy nl nm l nn no">#Create a list of all people<br/>fullCastAndCrew = list(fullCastAndCrewDF['name'].drop_duplicates())</span><span id="012f" class="nk mf je ng b gy np nm l nn no">#Create an empty DataFrame to append to<br/>movie_network = pd.DataFrame()<br/>for x in fullCastAndCrew:<br/>    #Filter DF for this person<br/>    temp = fullCastAndCrewDF.loc[fullCastAndCrewDF['name'] == x]<br/>    #Create a dyadic dataset for this person between the movies they are in<br/>    dyads = pd.DataFrame(list(itertools.combinations(temp['movie'], 2)))<br/>    #Create a column called 'name' for the person's name<br/>    dyads = dyads.assign(name = x) <br/>    #Concat this person's data onto our master DF<br/>    movie_network = pd.concat([movie_network,dyads])<br/>    <br/>#Rename columns<br/>movie_network.columns = ['name','source','target']</span><span id="1a86" class="nk mf je ng b gy np nm l nn no">#Get rid of self references<br/>movie_network = movie_network[movie_network['source'] != movie_network['target']]</span></pre><p id="e369" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">上面的代码创建了一个我们所有电影的列表(fullCastAndCrew)，遍历列表并创建了一个电影之间链接的二元数据集，其中每个链接都是在两部电影中扮演角色或有工作的人。创建后，DF应该看起来像这样:</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nz"><img src="../Images/b2ebfbcf9303c436813beb711217a67c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KuXy5nG_rGcBFqsZgSz87Q.png"/></div></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">作者图片</p></figure><p id="ac39" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这意味着凯特·布兰切特同时出现在《别抬头》和《噩梦小巷》中。有了这个数据集，我们可以创建一个网络的可视化。首先，将网络导出为csv文件:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="9df9" class="nk mf je ng b gy nl nm l nn no">movie_network.to_csv("movie_network.csv")</span></pre><p id="9a6c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我使用Gephi来可视化网络，因为这比编写所有代码更容易，而且它们看起来非常棒。<a class="ae lp" href="https://gephi.org/" rel="noopener ugc nofollow" target="_blank"> Gephi </a>是一款开源的网络分析和可视化软件。你应该可以很容易地从他们的网站上免费安装。它很容易开始，并允许一些真正美丽的可视化。如果你从未用过Gephi，这里的<a class="ae lp" href="https://medium.com/@Luca/guide-analyzing-twitter-networks-with-gephi-0-9-1-2e0220d9097d" rel="noopener"/>是从<a class="ae lp" href="https://medium.com/u/f41b88c25359?source=post_page-----f009dbbf107b-----------------------------------" rel="noopener">卢卡·哈默</a>开始入门的好教程。</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/d142e4c659a1739495c1ef6c70cbc88d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_GPVfHUwrfdKdJwO2eCAng.png"/></div></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">作者图片</p></figure><p id="dcbe" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">看起来我们列表中的大多数电影之间确实有联系，但是有没有一些电影与这张图完全没有联系呢？为了检查这些“孤儿”电影，我们首先在网络中创建一个电影列表，并删除重复的电影。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="2710" class="nk mf je ng b gy nl nm l nn no">#Create a list of all movies in the network to see if any are not connected at all<br/>movie_network_movies = movie_network['source'].tolist() + movie_network['target'].tolist()</span><span id="301b" class="nk mf je ng b gy np nm l nn no">#Remove duplicates<br/>movie_network_movies = set(movie_network_movies)</span></pre><p id="64bb" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">然后，我们将这份名单与所有奥斯卡提名电影的原始名单进行比较:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="721d" class="nk mf je ng b gy nl nm l nn no">#Compare network list of movies to original list to find orphans<br/>originalList = movies['original_title'].tolist()<br/>non_connected_movies = list(set(originalList) - set(movie_network_movies))<br/>non_connected_movies</span></pre><p id="350f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">有四部孤儿电影:《平行母亲》、《露娜娜:教室里的一头牦牛》、《开我的车》、《用火写作》。还有两部电影《逃离》和《世界上最糟糕的人》(The Worst Person in the World)有关联，但与其他电影没有关联——埃斯基尔·沃格特写过《世界上最糟糕的人》(The Worst Person in the World)，也是《逃离》的剧本顾问</p><p id="f76e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果您想创建一个列来描述这两部影片中每个人的工作，我编写了以下函数:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="2eb2" class="nk mf je ng b gy nl nm l nn no">#Put description of person's role in both movies into a new column<br/>def getDescription(x):<br/>    name = x['name']<br/>    roleInSource = fullCastAndCrewDF.loc[(fullCastAndCrewDF['name'] == name) &amp; (fullCastAndCrewDF['movie'] == x['source'])]['role'].values[0]<br/>    roleInTarget = fullCastAndCrewDF.loc[(fullCastAndCrewDF['name'] == name) &amp; (fullCastAndCrewDF['movie'] == x['target'])]['role'].values[0]<br/>    roles = [roleInSource,roleInTarget]<br/>    return(roles)</span><span id="0a1d" class="nk mf je ng b gy np nm l nn no">movie_network['connection_description'] = movie_network.apply(lambda x: getDescription(x), axis = 1)</span></pre><p id="4f4e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这给了我们如下所示的输出:</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oa"><img src="../Images/c70bf3f4e9710179ea6b40b9873fa098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qANXBAlGFgiAWFiJAxBHfQ.png"/></div></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">作者图片</p></figure><p id="5eaf" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在这里，我们可以看到凯特·布兰切特在《不要抬头》中扮演了布里·伊万特里，在《噩梦小巷》中扮演了莉莉斯·里特。我刚刚发现自己对发现一个人如何与多部电影联系在一起很感兴趣，这个专栏让这变得简单了一些。</p><p id="f895" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">那么，哪部电影与其他奥斯卡提名电影最有“关联”？有几种方法可以回答这个问题。首先，我们可以找到哪两部电影联系最紧密。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="c0af" class="nk mf je ng b gy nl nm l nn no">#Which movies are most connected?<br/>movie_network = movie_network.groupby(["source", "target"]).size().reset_index(name="freq")<br/>movie_network.sort_values('freq',ascending=False).head(10)</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oc"><img src="../Images/8298e0705fab4b5b45936e9583d7a7e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PeTSfU79smfZJ9kSa19HWA.png"/></div></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">作者图片</p></figure><p id="aa5b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">也许毫不奇怪，这两部迪士尼动画电影之间的联系最多。</p><p id="be9f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们还可以计算每个节点的“度”的总数，即每部电影中同时出现在至少一部其他奥斯卡提名电影中的人数:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="20fa" class="nk mf je ng b gy nl nm l nn no">#Turn df into graph using NetworkX<br/>G = nx.from_pandas_edgelist(movie_network, 'source', 'target', edge_attr='freq')</span><span id="97db" class="nk mf je ng b gy np nm l nn no">#Find the degree of everyone in the network<br/>G_sorted = pd.DataFrame(sorted(G.degree, key=lambda x: x[1], reverse=True))<br/>G_sorted.columns = ['movie','degree']<br/>G_sorted.head()</span></pre><p id="8f7d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这为我们提供了以下列表:</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div class="gh gi od"><img src="../Images/aed2fff5a71fa3b52e9aace3890d17fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*2WSNGB95Wldt6zSGguSBAw.png"/></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">作者图片</p></figure><p id="9766" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">甘草披萨的演员和工作人员名单中有15个联系人，他们也出现在我们名单上的其他电影中。如果你想看到甘草比萨和其他电影之间的联系的完整列表，你可以使用这个代码(或转到我的GitHub上的笔记本):</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="6650" class="nk mf je ng b gy nl nm l nn no">#Show all connections between Licorice Pizza and all the other movies on our list <br/>movie_network.loc[(movie_network['source'] == "Licorice Pizza") | (movie_network['target'] == "Licorice Pizza")]</span></pre><h2 id="998d" class="nk mf je bd mg oe of dn mk og oh dp mo lc oi oj mq lg ok ol ms lk om on mu oo bi translated">创建一个网络，人是节点，电影是边</h2><p id="6405" class="pw-post-body-paragraph kt ku je kv b kw mw kf ky kz mx ki lb lc my le lf lg mz li lj lk na lm ln lo im bi translated">现在让我们创建一个网络，其中人是节点，他们的连接是电影。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="e738" class="nk mf je ng b gy nl nm l nn no">#Create an empty DataFrame<br/>people_network = pd.DataFrame()</span><span id="5b97" class="nk mf je ng b gy np nm l nn no">#Loop through movies and create dyads between all people in each movie<br/>for x in movies['original_title']:<br/>    #Filter df for movie<br/>    temp = fullCastAndCrewDF.loc[fullCastAndCrewDF['movie'] == x]<br/>    #Create pairs of all people in the movie<br/>    dyads = pd.DataFrame(list(itertools.combinations(temp['name'], 2)))<br/>    #Create a new column called 'movie'<br/>    dyads = dyads.assign(movie = x)<br/>    #Concat network to master df<br/>    people_network = pd.concat([people_network,dyads])</span></pre><p id="204d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">上面的代码遍历所有电影，并在每部电影中创建所有人的配对——这些配对就是我们在图中的“边”。然后，我们可以重命名这些列，并去掉自我引用，即当一个人与自己相关联时。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="41e2" class="nk mf je ng b gy nl nm l nn no">#Rename columns<br/>people_network.columns = ['source','target','movie']<br/>#Get rid of self references<br/>people_network = people_network[people_network['source'] != people_network['target']]</span></pre><p id="5b3f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">类似于上面的问题——如果我们想找到他们之间联系最多的两个人呢？</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="41c3" class="nk mf je ng b gy nl nm l nn no">#Which two people are the most connected?<br/>people_network = people_network.groupby(["source", "target"]).size().reset_index(name="freq")<br/>people_network.sort_values('freq',ascending=False).head(10)</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi op"><img src="../Images/7cc78052aa7012c9f6761aa8b48f54a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mnInESDm-WcYAMcdk1q7xw.png"/></div></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">作者图片</p></figure><p id="bccd" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们可以看到唐纳德·莫瓦特和丹尼斯·维伦纽瓦之间有12个联系。这是因为丹尼斯·维伦纽瓦在《沙丘》中有三个角色(编剧、导演和制片人)，唐纳德·莫瓦特在《沙丘》中有四个角色(化妆部门主管、发型设计师、化妆设计师和假肢设计师)。这可能会引起误解，因为这两个人虽然身兼多职，但实际上只是两个人。如果我们在同一部电影中删除重复的角色，并再次计算连接的频率，会怎么样？</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="e4b6" class="nk mf je ng b gy nl nm l nn no">#Drop duplicates<br/>people_network_no_dupes = people_network.drop_duplicates()</span><span id="34ad" class="nk mf je ng b gy np nm l nn no">#Which two people are the most connected?<br/>people_network_freq = people_network_no_dupes.groupby(["source", "target"]).size().reset_index(name="freq")<br/>people_network_freq.sort_values('freq',ascending=False).head(10)</span></pre><p id="8177" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在我们得到了一个非常不同的列表:</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/12b557b771c568942e209c977e708342.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*ZctDKiQ4GDaZ-vIdVbrz1A.png"/></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">作者图片</p></figure><p id="0187" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在我们的列表中，有很多成对的人合作过两部不同的电影。没有两个人合作过两部以上不同的电影。</p><p id="6f0b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在，我们可以使用NetworkX将这个DF转换成图形，并运行一些网络分析。下面的代码从我们的边列表中提取一个网络，并按照每个节点的度数进行排序。在这个图表中，这意味着每个人拥有的联系数量。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="a032" class="nk mf je ng b gy nl nm l nn no">#Turn df into graph using NetworkX<br/>G = nx.from_pandas_edgelist(people_network_freq, 'source', 'target',edge_attr='freq')</span><span id="03f5" class="nk mf je ng b gy np nm l nn no">#Find the degree of everyone in the network<br/>G_sorted = pd.DataFrame(sorted(G.degree, key=lambda x: x[1], reverse=True))<br/>G_sorted.columns = ['movie','degree']<br/>G_sorted.head()</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div class="gh gi or"><img src="../Images/50bec2564125a162819768d5ca6bb843.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*jGM6EHPtKrPpkS7Z2yGiZA.png"/></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">作者图片</p></figure><p id="8c10" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在我们的数据中，人脉最广的人是维多利亚·西奥多。她在《滴答，滴答，嘣！》中扮演了“TTB乐队2号成员——键盘手”的角色她是电影《尾声》剧组的一名音乐家。由于这两部电影拥有我们名单上所有电影中最大的三个演员和工作人员中的两个，维多利亚·西奥多是唯一一个为这两部电影工作的人，她有最多的联系。</p><p id="1318" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在我们有了一个图表，我们可以从NetworkX运行任何内置函数。<a class="ae lp" href="https://networkx.org/" rel="noopener ugc nofollow" target="_blank">如果你想四处看看，这里有</a>NetworkX文档。我们可以用下面的代码找到这个网络中的总人数和总连接数:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="fcd7" class="nk mf je ng b gy nl nm l nn no">#Number of movies in our network<br/>print(str(G.number_of_nodes()) + " people in the network")</span><span id="6803" class="nk mf je ng b gy np nm l nn no">#Number of connections in the network<br/>print(str(G.number_of_edges()) + " connections (movies) in the network")</span></pre><p id="ab6d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这个网络有3414人，245939个连接！这是网络最酷的地方之一——尽管原始数据集可能并不庞大(我们从37部电影开始)，但网络分析让我们能够提取成千上万的联系和见解，这些在标准数据分析中是无法获得的。</p><p id="fb4e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果我们没有提到中心性测量，这就不是一篇关于网络分析的文章。中心性测量本质上是一种测量网络中节点重要性的方法。衡量重要性的一种方法是计算连接的数量——就像我们上面计算每个节点的度数一样。另一种方法是寻找中间中心性。这是我在<a class="ae lp" rel="noopener" target="_blank" href="/who-is-the-most-important-person-in-the-film-industry-61d4fd6980be">以前的一篇文章中对中间中心性的描述。</a></p><blockquote class="os ot ou"><p id="6a75" class="kt ku ob kv b kw kx kf ky kz la ki lb ov ld le lf ow lh li lj ox ll lm ln lo im bi translated"><strong class="kv jf">“中间中心性</strong>通过寻找每组两个节点之间的最短路径来计算。对于任意两个节点，它们之间都存在一条最短路径。通过一个节点的最短路径越多，它的介数中心性就越高。在许多节点或节点群之间充当“桥”或“代理”的节点具有较高的“介数中心性”。例如，在一个电力网络中，节点是变电站，链路是电流，位于许多其他变电站之间最短路径上的变电站将有大量电流通过，因此具有更高的介数中心性。”</p></blockquote><p id="5684" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们可以使用下面的代码计算中间中心性:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="7291" class="nk mf je ng b gy nl nm l nn no">#Calculate bc on our Graph<br/>bc = nx.betweenness_centrality(G,k=1000,weight='freq')</span><span id="8677" class="nk mf je ng b gy np nm l nn no">#Get nodes from graph and sort by highest betweenness<br/>bc = pd.DataFrame([bc.keys(), bc.values()]).T<br/>bc.columns= ['names', 'values']  # call them whatever you like<br/>bc = bc.sort_values(by='values', ascending=False)</span></pre><p id="11ad" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">请注意，计算介数可能需要一段时间。</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/2b87a762a0a0ab4dca5f0fd8d6524497.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*rOoE5kduDq1hF_fWWyPwyg.png"/></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">作者图片</p></figure><p id="ee59" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这是输出。正如你所看到的，在这个网络中具有最高介数中心性的人是安德鲁·加菲尔德——他出演了其中的三部电影。同样，约翰尼·格林伍德为三部电影配乐，所以他有很高的中间中心性。玛娅·鲁道夫参与了甘草披萨的制作，也参与了卢卡和米切尔夫妇与机器的对决。阿西尔·哈德森是一名舞蹈演员，曾出演过《成为里卡多夫妇》和《未来美国》由于他是《未来2美国》和其他电影之间仅有的两个联系之一，他具有非常高的中间中心性。《即将到来的美国2》的另一个关联是<a class="ae lp" href="https://www.imdb.com/name/nm1775466/?ref_=nv_sr_srsg_0" rel="noopener ugc nofollow" target="_blank">约翰·传奇，</a>，他在动画电影《米切尔一家大战机器》中饰演自己。如果你想看介数最高的人的直观表现，这是我在Gephi制作的一个图表。</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oz"><img src="../Images/54e0afeb9f662c8e1ffe445bf2767623.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*prxoSNkl2FSFdkyUgc_JlQ.png"/></div></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">作者图片</p></figure><p id="b002" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">要在Gephi中构建这个图，您需要将一个边列表和一个节点列表导出为csv文件，然后将它们导入Gephi。下面是导出这两个文件的代码:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="98c8" class="nk mf je ng b gy nl nm l nn no">#Get list of nodes from graph<br/>G_nodes = pd.DataFrame(sorted(G.degree, key=lambda x: x[1], reverse=True))<br/>G_nodes.columns = ['names','degree']</span><span id="ae79" class="nk mf je ng b gy np nm l nn no">#Merge betweenness scores into node list<br/>people_nodes = pd.merge(G_nodes,bc, how='left', left_on="names",right_on="names")<br/>#Rename 'names' column -- Gephi is weird about that<br/>people_nodes = people_nodes.rename(columns={'names': 'Id'})</span><span id="e30e" class="nk mf je ng b gy np nm l nn no">#Export to csvs<br/>people_nodes.to_csv("peopleNodes.csv")<br/>people_network_freq.to_csv("peopleEdges.csv")</span></pre><h1 id="bf06" class="me mf je bd mg mh mi mj mk ml mm mn mo kk mp kl mq kn mr ko ms kq mt kr mu mv bi translated">结论</h1><h2 id="dd52" class="nk mf je bd mg oe of dn mk og oh dp mo lc oi oj mq lg ok ol ms lk om on mu oo bi translated">TMDB数据库的好处</h2><p id="e4c9" class="pw-post-body-paragraph kt ku je kv b kw mw kf ky kz mx ki lb lc my le lf lg mz li lj lk na lm ln lo im bi translated">TMDB API是一个丰富的电影数据资源。<a class="ae lp" rel="noopener" target="_blank" href="/who-is-the-most-important-person-in-the-film-industry-61d4fd6980be">几年前，我写了一篇文章</a>，用IMDb数据库对电影数据进行网络分析，但是这些数据有严重的局限性。IMDb只为每部电影列出7-10个“负责人”——通常是导演、几个制片人、作曲家和几个演员。有了TMDB的数据库，我们就能得到每部电影的全部演员和工作人员。这让我们可以建立更大、更完整、更有趣的网络。</p><p id="e320" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">TMDB数据库也可以通过API获得。所有的IMDb数据集都是静态文件，可点击<a class="ae lp" href="https://www.imdb.com/interfaces/" rel="noopener ugc nofollow" target="_blank">这里</a>下载。这些文件非常庞大，需要进行大量的处理和过滤，才能方便地进行查询。然而，使用那些大的静态文件的好处是，我们从一个地方开始所有的数据。如果我们想要TMDB数据库中所有电影的完整列表，我们必须运行额外的电影列表查询——我还没有这样做过。</p><h2 id="85f0" class="nk mf je bd mg oe of dn mk og oh dp mo lc oi oj mq lg ok ol ms lk om on mu oo bi translated">关于电影网络的思考</h2><p id="1f21" class="pw-post-body-paragraph kt ku je kv b kw mw kf ky kz mx ki lb lc my le lf lg mz li lj lk na lm ln lo im bi translated">名单上所有的美国电影都是相连的，但一些国际电影是断开的。有四部电影与图表完全无关(《平行母亲》、《鲁娜娜:教室里的一头牦牛》、《开我的车》和《用火写作》)——都是国际电影。两部获得提名的国际电影(《世界上最坏的人》和《逃离》)相互关联，但没有其他电影。《上帝之手》(The Hand of God)是一部获得最佳国际电影提名的意大利电影，但它是由网飞制作的，因此与《别抬头》(Don't Look Up)(也是一部网飞电影)共用一个制片人，与《古驰之家》(House of America)的艺术总监也是同一个人</p><p id="e923" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在我几年前用IMDb数据写的一篇文章中，我运行了一个社区检测算法，将网络分成紧密分组的节点或社区。这个网络很自然地沿着地理界线瓦解了——有一个中国电影社区，一个西班牙社区等等。充当这些社区和中心“好莱坞”社区之间桥梁的节点具有最高的中间中心性。例如，Penélope Cruz具有很高的中间中心性，因为她通常是好莱坞和西班牙电影界之间的桥梁。这种地理/语言上的划分在2022年奥斯卡的分析中也很明显，即国际电影联系更少。</p><p id="642a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">那么这张图中的密度是多少呢？换句话说，奥斯卡是乱伦、裙带关系、沾沾自喜的骗局吗？我开始这个分析的原因之一是，它<em class="ob">看起来</em>像一个密集的图形。我看的每一部奥斯卡提名电影都让我看到另一部奥斯卡提名电影中的人物——《T4》一定是一个非常小的世界，对吗？例如，尽管《法国派遣》没有获得任何奥斯卡提名，但它有<a class="ae lp" href="https://www.imdb.com/name/nm2244205/?ref_=tt_cl_i_4" rel="noopener ugc nofollow" target="_blank">蕾雅·赛杜</a>、<a class="ae lp" href="https://www.imdb.com/name/nm0910607/?ref_=nv_sr_srsg_0" rel="noopener ugc nofollow" target="_blank">克里斯托弗·沃尔兹</a>和<a class="ae lp" href="https://www.imdb.com/name/nm0942482/" rel="noopener ugc nofollow" target="_blank">杰弗里·赖特</a>——所有这些演员也都出演了<a class="ae lp" href="https://www.imdb.com/title/tt2382320/?ref_=nm_flmg_act_7" rel="noopener ugc nofollow" target="_blank">死亡时间</a>。我觉得我最近看的电影中有一半都有蒂莫西·柴勒梅德的身影。还是仅仅因为每部电影都有那么多人贡献，所以几乎任何两部电影都会有一个共同的人？</p><p id="ac92" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">对于一个技术性的回答，我们可以计算我们两个网络的<strong class="kv jf">图密度</strong>和<strong class="kv jf">聚类系数</strong>。Omar Lizardo和Isaac Jilbert在《社交网络:简介<a class="ae lp" href="https://bookdown.org/omarlizardo/_main/" rel="noopener ugc nofollow" target="_blank">》一书中给图密度下了一个很好的定义。</a></p><blockquote class="os ot ou"><p id="e3cf" class="kt ku ob kv b kw kx kf ky kz la ki lb ov ld le lf ow lh li lj ox ll lm ln lo im bi translated">“图的密度是对参与者之间存在多少联系与参与者之间可能存在多少联系的度量。”</p></blockquote><p id="995b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们电影网的<a class="ae lp" href="https://en.wikipedia.org/wiki/Dense_graph" rel="noopener ugc nofollow" target="_blank">图密度</a>为0.15，人民网的图密度为0.042。这意味着电影之间存在大约15%的潜在联系，而人与人之间只有4%的联系。那是高还是低？要回答这个问题，我们真的需要一些东西来与之比较。这张图可能比大脑中的神经通路连接更稀疏，但与电影中的其他网络相比呢？下一步，我想将这样一个网络与一个由37部随机选择的电影组成的网络进行比较，看看奥斯卡提名者与随机选择的电影之间的联系是多还是少。</p><p id="8c06" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">从这一分析中可以得出一个结论:参与三部奥斯卡提名电影的工作人员比演员还多。只有三个演员出演了三部电影，但是有八个工作人员出演了三部电影。</p><p id="0ef7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">对于聚类系数，<a class="ae lp" href="https://en.wikipedia.org/wiki/Clustering_coefficient" rel="noopener ugc nofollow" target="_blank">维基百科提供了这样的定义</a>:</p><blockquote class="os ot ou"><p id="5e6d" class="kt ku ob kv b kw kx kf ky kz la ki lb ov ld le lf ow lh li lj ox ll lm ln lo im bi translated">“在<a class="ae lp" href="https://en.wikipedia.org/wiki/Graph_theory" rel="noopener ugc nofollow" target="_blank">图论</a>中，<strong class="kv jf">聚类系数</strong>是对图中节点倾向于聚集在一起的程度的度量。”</p></blockquote><p id="bf84" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们的电影图<a class="ae lp" href="https://en.wikipedia.org/wiki/Clustering_coefficient" rel="noopener ugc nofollow" target="_blank">聚类系数</a>为0.3，人物图聚类系数为0.98。人际网络的聚类系数要高得多，但根据我们提取该图的方式，这是意料之中的。对于每部电影，每个参与电影制作的人都与其他参与电影制作的人建立了联系。这意味着我们有37个完整的图表，根据定义，每部电影一个。同样，如果没有与之比较的东西，很难说0.3的聚类系数是高还是低。</p><p id="600d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我的一些后续问题是:与其他(非提名)电影相比，0.3的聚类系数高吗？与其他(非提名)电影相比，这些图形密度测量值是高还是低？电影的分类是基于制作公司、导演还是其他变量？我们可以使用网络分析来衡量奥斯卡的代表性吗，也就是说，这37部电影是否代表了整个行业？代表性差距在哪里？随着时间的推移，奥斯卡提名者的代表性有所增加吗？随着时间的推移，哪几对人被提名的次数最多？</p><p id="dad6" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">从电影数据中提取图表让我们能够提出通过传统数据分析无法回答的问题。就连这篇文章中回答的简单问题也是如此，比如“有没有哪部电影没有获得奥斯卡提名？”只能通过把我们的数据连接成图表来回答。一旦我们将数据转换成图表，我们就可以回答更多的问题，其中一些我已经在上面列出来了。也许最重要的是，将数据转化为网络提供了对数据结构更直观的感觉，并允许我们以不同的方式更有创造性地思考我们可能会提出的问题。</p><p id="03d1" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果你觉得这个教程很有帮助和有趣，请跟随:)</p><p id="8861" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">请随意评论任何问题，我会尽力回答。</p></div></div>    
</body>
</html>