<html>
<head>
<title>Evolving Elixir Code: Genetic Programming with the Elixir AST</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">进化的长生不老药密码:用长生不老药AST进行遗传编程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/evolving-elixir-code-genetic-programming-with-the-elixir-ast-fffffe19a170#2022-09-15">https://towardsdatascience.com/evolving-elixir-code-genetic-programming-with-the-elixir-ast-fffffe19a170#2022-09-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="86e5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用Elixir的宏系统&amp;抽象语法树进行遗传编程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/33760a045e2ec6cf709f133063ac2180.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DjzDxO48_K0RuGUX"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@3dparadise?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Braňo </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="ab6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">遗传编程是一种强大的技术，它使用<em class="ls">进化和自然选择</em>作为搜索技术来创建能够解决问题的算法。</p><p id="3a37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我描述了Elixir的内置宏系统和抽象语法树(AST)表示如何使实现可以解决现实世界问题的基本遗传编程系统变得简单。</p><p id="2550" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你已经了解了基因编程，并且只是想自己尝试一下代码，那么<a class="ae kv" href="https://github.com/jonklein/quotegp" rel="noopener ugc nofollow" target="_blank">前往GitHub查看QuoteGP </a>。</p><h1 id="84e2" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">进化解决方案——什么是遗传编程？</h1><p id="a18a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><em class="ls">遗传编程</em>是一种人工智能技术，在这种技术中，我们试图<em class="ls">进化出</em>一种解决特定问题的算法。我们从几个<em class="ls">随机</em>解决方案开始，然后使用进化技术来引导我们在许多代中找到越来越好的解决方案。如果一切按预期进行，我们会找到一个完全适合我们问题的解决方案。</p><h2 id="a8ed" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">适者生存</h2><p id="7130" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">遗传编程的工作方式是从几个(也许是几千个)随机的代码片段开始。我们根据问题集评估每个程序，以评估一个<em class="ls">适应值</em>——一个告诉我们程序在解决问题方面有多好的数字。当我们开始使用随机算法时，它们几乎总是非常糟糕(即，具有非常低的适应值)。但有些，只是偶然，比其他人略胜一筹。因此，我们使用<em class="ls"/><em class="ls">选择过程</em>来选择最好的，并对它们进行轻微的进化，以产生新一代的解决方案。</p><p id="04ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">新一代的解决方案可能仍然不好，但是比我们开始使用的解决方案稍微好一点。如果我们一遍又一遍地重复这个过程，我们最终会得到非常好的解决方案——如果我们坚持足够长的时间，我们可能最终会得到一个完美的解决方案。</p><h2 id="dfa6" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">遗传算子</h2><p id="1cd9" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">那么，我们如何从现有的解决方案中产生新的解决方案呢？我们使用各种各样的遗传算子来实现。在我们的QuoteGP系统中，我们使用了几个不同的遗传算子来产生新一代的解决方案:</p><ul class=""><li id="2516" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">遗传交叉:从上一代中取出两个解决方案，并将它们混合(结合两者的一部分)以产生一个新的候选解决方案</li><li id="70c8" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">变异:从上一代中取出一个解决方案，随机改变它以产生一个新的解决方案</li><li id="984f" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">复制:取一个解决方案，然后“按原样”复制</li><li id="e527" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">随机:生成一个完全随机的新解</li></ul><p id="aae9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了“随机”操作符之外，所有这些操作符在选择对哪个程序进行操作时，都使用基于适合度的<em class="ls">选择</em>过程。这意味着在执行交叉或变异时，我们更喜欢操作“更好”的解决方案。</p><p id="5546" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在更广泛的遗传编程领域中，在选择过程和遗传算子的选择上有无限的变化，但是我们在QuoteGP中保持它的简单并使用上面描述的方案。</p><h1 id="8695" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">如何表示可进化的程序</h1><p id="f3f1" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">为了建立和测试这个系统，我们将考虑一类被称为<em class="ls">符号回归、</em>的问题，在这些问题中，我们试图找到一个数学公式来最好地表示一些训练数据。</p><p id="fcd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">构建GP系统最重要的考虑之一是<em class="ls">程序表示</em>:可执行基因组看起来像什么？</p><p id="3f32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可能会尝试一种常用的真实世界编程语言，如C、Python或Ruby。尽管人类程序员最熟悉这些语言，但他们并不特别擅长进化:在所有可表示的文本字符串的搜索空间中，几乎没有一个字符串是语法上有效的程序！</p><p id="7c83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在设计一个GP系统(或者实际上，任何一种进化算法)时，表示是关键:我们想要一种表示，其中所有可表示的状态都是有效的程序，并且对于诸如变异和交叉之类的遗传操作符是健壮的。这在很大程度上排除了我们习惯使用的文本编程语言。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/d6d4876656aa9dc0b8806d674a20a3d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*cY_XmY7J8Z7dn8Hvdk2Kng.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">GP系统中使用的基于树的程序表示。图片来自<a class="ae kv" href="https://geneticprogramming.com/about-gp/tree-based-gp/" rel="noopener ugc nofollow" target="_blank">geneticprogramming.com</a>。</p></figure><p id="08f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑到这一点，一种常见的GP方法是基于<em class="ls">树的遗传编程</em>，其中我们将程序表示为<em class="ls">表达式树。</em>给定一组允许的节点和终端值，我们可以确保任何树都是有效的程序，并且诸如变异和交叉的遗传算子也将生成有效的程序。</p><p id="f886" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有一些其他的表示类型，如线性GP，其特点是类似于机器字节码或基于堆栈的GP的线性指令系列，其中类型化堆栈用于存储中间值，但对于这个项目，我们将专注于基于树的表示。</p><p id="5a73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，用C、Java或Python这样的语言构建一个基于树的GP，需要构建某种新颖的表示和解释器。但是有些语言，比如Elixir，有一个语法树和解释器作为一级概念内置。在这种情况下，我们可以使用语言本身进行基因编程。</p><h1 id="d958" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">同形语言与遗传编程</h1><p id="dbff" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">一些编程语言是<em class="ls">同形，</em>意味着<strong class="ky ir">代码是数据，数据是代码</strong>。在这些语言中，例如Lisp，遗传编程系统可以非常简单地实现，因为程序表示<em class="ls">是数据表示</em>:进化的程序可以在语言中本地执行。</p><p id="3589" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管Elixir语言并不完全是同形异义的，但它确实提供了对内置抽象语法树(AST)的本地访问和操作，而抽象语法树<em class="ls">具有<em class="ls"> </em>这些同形异义的特性。虽然Elixir代码通常不是以普通数据的形式编写的，<strong class="ky ir">但它很容易转换成普通数据表示形式</strong>。</em></p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="c1c5" class="mq lu iq ns b gy nw nx l ny nz"># Turn an Elixir expression into an AST:<br/>iex(1)&gt; quote(do: 1 * 3)<br/>{:*, [context: Elixir, import: Kernel], [1, 3]}</span><span id="08fd" class="mq lu iq ns b gy oa nx l ny nz"># Turn an AST into an Elixir expression:<br/>iex(2)&gt; Macro.to_string({:*, [context: Elixir, import: Kernel], [1, 3]})<br/>"1 * 3"</span></pre><p id="3a54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着我们可以使用Elixir ASTs作为本地遗传编程表示来进化Elixir代码。我们可以生成随机的灵丹妙药(受我们指定的保持它们有效的约束)，评估它们的适合度，然后对它们执行一般操作以产生新的。如果我们找到一个解决方案或其他我们感兴趣的程序，我们可以把它<em class="ls">转换回仙丹</em>来读取或执行它。</p><h1 id="9f5d" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">样本问题—符号回归</h1><p id="62c3" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">一个<em class="ls">符号回归</em>问题是一个曲线拟合问题，在这个问题中，我们试图确定一个数学表达式，它将为一系列给定的输入产生一系列输出值。为了测试我们的系统&amp;演示它是如何工作的，我们将挑选一些<em class="ls">玩具</em>符号回归问题，这些问题系统应该能够轻松解决，但是仍然需要一些搜索&amp;进化。</p><p id="3f0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设给了我们一组数据，代表对某个过程的观察，我们试图找出一个公式来生成这样的数据。例如，这里有一个输入和输出值的列表:</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="108c" class="mq lu iq ns b gy nw nx l ny nz">[<br/>  [10, 138],<br/>  [11, 162],<br/>  [12, 188],<br/>  [13, 216],<br/>  [14, 246],<br/>  [15, 278],<br/>  ...<br/>]</span></pre><p id="65ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们希望我们的系统接受这些数据，并进化出产生这些数据的程序表达式。在这种情况下，我们要找的表达式是<code class="fe ob oc od ns b">x*x + 3x + 8</code>。我们知道这一点，因为我们自己编造了数据，但我们想看看我们的基因编程系统是否能自己解决这个问题。</p><p id="a91a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">注:尽管我们之前讨论过</em> <strong class="ky ir"> <em class="ls">适应值</em> </strong> <em class="ls">值越高越好，但在许多实现中(包括本例)，我们使用</em> <strong class="ky ir"> <em class="ls">误差值</em> </strong> <em class="ls">来表示我们离实际解有多远。这些代表相同的东西，只是我们试图进化更小的误差值，而不是更高的适应值。这只是实现细节，对系统如何工作没有影响。</em></p><p id="a014" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看QuoteGP系统的典型输出是什么样的:</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="7ee7" class="mq lu iq ns b gy nw nx l ny nz">=== Generation 0 best fitness: 252.0 - program: (10 - 1 + 7 * -1 + input) * (input + (3 - -8 / -4))<br/>=== Generation 1 best fitness: 252.0 - program: (10 - 1 + 7 * -1 + input) * (input + (3 - -8 / -4))<br/>=== Generation 2 best fitness: 1008 - program: (input + 4) * (input + -1)<br/>=== Generation 3 best fitness: 203 - program: (7 + -3 - input * -1) * input<br/>=== Generation 4 best fitness: 22.75 - program: input * (input + (3 - -8 / -4 / -4))<br/>=== Generation 5 best fitness: 22.75 - program: input * (input + (3 - -8 / -4 / -4))<br/>=== Generation 6 best fitness: 8.75 - program: -5 - -6 + input * input + (input - input * (-3 - 8 - 9)) / (1 - 1 - -6)<br/>=== Generation 7 best fitness: 2.5968626643538126 - program: -7 + (input + 4) * (input + -1) + (-5 - input * (-3 - 8 - 9)) / input<br/>=== Generation 8 best fitness: 4.861111111111127 - program: input + input * input + (6 * (10 + 7) + 4 - input - input * (-8 - 8 - 9)) / (7 - 1 - -6)<br/>=== Generation 9 best fitness: 1.6155871338926322e-27 - program: input * (input + (3 - -8 / input))<br/>=== Generation 10 best fitness: 1.6155871338926322e-27 - program: input * (input + (3 - -8 / input))<br/>=== Generation 11 best fitness: 0 - program: input + (4 - -4) + input * input + (input + input)</span></pre><p id="ad35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个输出中，我们看到了遗传编程系统经过许多代的结果。在每一步，我们看到最佳的适应度(或误差值)和最佳的解决方案。我们从误差值252开始，告诉我们最佳起始解离“正确”解有多远。</p><p id="5397" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还看到了产生最佳输出的程序。请注意，尽管这些表达式看起来简单而普通，但它们是完全有效的灵丹妙药，只要我们设置了预期的绑定(在本例中为<code class="fe ob oc od ns b">value</code>)。</p><p id="8b05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在12代的过程中(当然，从0开始)，这些误差值稳步下降，直到误差值为0——完全匹配！我们看到了输出，一个有效的长生不老药程序:</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="fe56" class="mq lu iq ns b gy nw nx l ny nz">input + (4 - -4) + input * input + (input + input)</span><span id="4d81" class="mq lu iq ns b gy oa nx l ny nz"># which simplifies to...<br/>input + 8 + input*input + input + input<br/>input*input + 3*input + 8</span></pre><h1 id="77b6" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">你自己试试</h1><p id="a6da" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在这一点上，你可能想自己尝试一下这个系统。你可以通过<a class="ae kv" href="https://github.com/jonklein/quotegp" rel="noopener ugc nofollow" target="_blank">在GitHub </a>上试用QuoteGP，并查看<code class="fe ob oc od ns b">samples</code>目录中的例子。</p><p id="203a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你玩它的时候，你可能会注意到一些事情——这些都是使用遗传编程(以及更普遍的人工智能搜索技术)的真实世界挑战。</p><h2 id="dfcf" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">适应性有时会上升而不是下降</h2><p id="344d" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">因为通用运算符是随机应用的，所以有时“最佳”候选项不会延续到下一代。围绕选拔过程有大量的研究，但没有正确的答案。虽然总是倾向于将<em class="ls">最好的</em>程序一代一代地复制下来似乎很直观，但这是一个悬而未决的问题——一些研究表明，随着时间的推移，这种方法实际上会产生更差的结果。(注意:当我现在研究这个声明时，我看到了更多支持这种方法的最新证据——也许我应该把它添加到QuoteGP中！)</p><h2 id="ac15" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">有时问题没有得到完全解决</h2><p id="b287" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">是的，这是常有的事。</p><p id="0d11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基因编程实际上只是一种特殊的搜索技术，并不能保证一定会找到解决方案。事实上，大多数个体真实世界的基因编程运行<em class="ls">不会</em>找到一个问题的完美解决方案，因为你是在大海捞针。需要多次尝试才能找到正确的解决方案，这种情况并不少见。</p><p id="7e78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，在这些示例问题中，我们使用0的停止标准，换句话说，一个完全完美的解决方案。这在现实世界中并不典型——对于许多问题来说，通常<em class="ls">并不是</em>完全完美的解决方案。相反，找到具有微小误差值的东西是一个有效且有用的现实世界解决方案。</p><h2 id="32f3" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">节目越来越长了！</h2><p id="ebdf" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">“膨胀”是基因编程中的另一个常见问题，也有一个研究机构致力于解决这个问题。简而言之，膨胀是程序长度随着时间的推移而增加，但由于“死”或残留代码而没有增加适应性。在这个简单的系统中，我们没有采用任何膨胀控制技术，所以这并不奇怪。</p><h1 id="94c3" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">结论和未来工作</h1><p id="0276" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">那么，考虑到可进化代码与Elixir的完美契合，它是遗传编程的最佳系统和语言吗？老实说:不。大多数GP系统不使用正常的人类编程语言，因为没有必要。他们倾向于使用一些其他的内部表示，只有在需要的时候才被翻译成人类可读的表达式。它们甚至可能包含语言特征，这将使它们对人类编程来说<em class="ls">可怕</em>，但对进化却非常有用。</p><p id="3044" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，大多数GP系统远比这个简单的例子复杂。更多阅读请见<a class="ae kv" href="https://geneticprogramming.com/software/" rel="noopener ugc nofollow" target="_blank">系统列表</a>。我个人很喜欢(并且已经开发过)PushGP系统，但是还有很多其他的系统。</p><p id="949f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，使用Elixir进行遗传编程的好处在于，它非常容易实现、检查和理解，这使它成为修补遗传编程、理解其工作原理和尝试新想法的优秀教学工具。</p><p id="93f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想自己尝试代码，请前往GitHub 。</p></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><p id="6196" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://blog.devgenius.io/@jonnystartup" rel="noopener ugc nofollow" target="_blank"><em class="ls">Jonathan</em></a><em class="ls">在大型创业公司&amp;小型企业中拥有超过20年的工程领导经验。如果你喜欢这篇文章，请考虑加入Medium来支持</em> <a class="ae kv" href="https://medium.com/@jonnystartup/membership" rel="noopener"> <em class="ls">乔纳森和其他成千上万的作者</em> </a> <em class="ls">。</em></p></div></div>    
</body>
</html>