<html>
<head>
<title>4 SQL Filtering Concepts to improve your Data Wrangling Game</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">4个SQL过滤概念，改善您的数据争论游戏</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/4-sql-filtering-concepts-to-improve-your-data-wrangling-game-91284393356c#2022-04-08">https://towardsdatascience.com/4-sql-filtering-concepts-to-improve-your-data-wrangling-game-91284393356c#2022-04-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c841" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们了解一些常见的SQL过滤技巧，数据科学家可以用它们来加快查询速度</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/539912f79f52ecf6b8d11ee774d601ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-baz3_xbwsjJQBpV"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由贾费尔·尼扎米@unsplash.com拍摄</p></figure><p id="7b32" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为数据科学家，我们大多数人习惯于使用<em class="lu"> pandas </em>(在Python上)<em class="lu"> </em>或<em class="lu"> dplyr </em>(在R上)<em class="lu">来过滤表格。</em>事实上，在两个库中，以及在我们用来编写算法的语言环境中，都有一些更方便的争论操作。</p><p id="b329" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如果您的数据源位于某个数据库中(并且您可能使用一些SQL接口来访问它)，那么使用SQL代码并在服务器端执行这些操作，一些过滤器和表操作会更有效。</p><p id="501d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">过滤表格是使用SQL时最常见的操作之一。从表面上看，它们似乎很简单，你只要加上一个子句就行了。但是..过滤器不只是看起来那么简单，而且会很快变得复杂。</strong></p><p id="5291" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">学习如何应用不同的过滤方法并利用带有<code class="fe lv lw lx ly b">IN</code>、<code class="fe lv lw lx ly b">AND</code>、<code class="fe lv lw lx ly b">OR</code>、优先级和通配符的<code class="fe lv lw lx ly b">WHERE</code>子句将极大地改进您的SQL游戏。在本帖中，我们将探索在从表中过滤行时可以应用的那些额外的技巧。<strong class="la iu">在这篇文章结束时，你应该能够理解大多数SQL查询中最复杂的</strong> <code class="fe lv lw lx ly b">WHERE</code> <strong class="la iu">语句。</strong></p><p id="5603" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将使用一个包含学校学生数据的示例表——该表完全是虚构的，所有姓名和信息都是虚构的。我正在一个<code class="fe lv lw lx ly b">sandbox</code>数据库中创建这个表:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="0953" class="md me it ly b gy mf mg l mh mi">create table sandbox.students (<br/> student_id integer auto_increment primary key,<br/>    student_full_name varchar(30),<br/>    favorite_classes varchar(150),<br/>    student_age integer,<br/>    birth_date date,<br/>    degree varchar(30)<br/>    );<br/>    <br/>insert into sandbox.students (<br/> student_full_name, favorite_classes, student_age, birth_date, degree<br/>) values ('John Smith', 'Mathematics, Political Science, Biology', 23, '1999-03-01', 'Engineering'),<br/> ('Amy Smith', 'History, Political Science, Biology', 23, '1999-03-01', 'History'),<br/>    ('Joe Adams', 'History, Mathematics', 23, '1999-06-01', 'History'),<br/>    ('Joe Williams', 'Biology, Chemistry', 22, '2000-03-01', 'Chemistry'),<br/>    ('Anne Williams', 'Mathematics, Arts', 22, '2000-03-16', 'Mathematics'),<br/>    ('May Taylor', 'History, Geography', 22, '2000-05-19', 'History'),<br/>    ('Zoe Brown', 'Physical Education, History', 21, '2001-02-18', 'Physical Education'),<br/>    ('Jennifer Davies', 'Biology, Chemistry', 21, '2001-03-19', 'Chemistry'),<br/>    ('Robert Jones', 'Chemistry, Biology, Mathematics', 21, '2001-06-02', 'Chemistry');</span></pre><p id="c03a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的学生表包含9名大学生的数据——虽然样本很少，但这应该足以理解我们将探讨的过滤概念之间的主要差异。</p><p id="f314" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们改进我们的SQL游戏！</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="4b8c" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">和/或</h1><p id="8b3d" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">这两个子句之间的区别——<code class="fe lv lw lx ly b">AND</code>、<code class="fe lv lw lx ly b">OR</code>——在过滤器中非常重要，并且考虑到了其他编程语言中常用的逻辑操作。</p><p id="3f00" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">想象一下，从我们的<em class="lu">学生</em>表中，我们想要对“化学”专业的所有学生进行分组。使用标准的<code class="fe lv lw lx ly b">WHERE</code>子句很容易做到，比如:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="6575" class="md me it ly b gy mf mg l mh mi">select * from sandbox.students<br/>where degree = 'Chemistry'</span></pre><p id="ed30" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将输出所有的<em class="lu">化学</em>学生，在本例中为3:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/1c6123de1140753c3a69e014f65c25e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hn02iTUwB_GAy7DdElfgPg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">返回数据-化学专业学生-作者图片</p></figure><p id="edc8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如果我们只是想对21岁的化学系学生进行分组呢？我们可以用一个<code class="fe lv lw lx ly b">AND</code>子句做到这一点:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="b510" class="md me it ly b gy mf mg l mh mi">select * from sandbox.students<br/>where degree = 'Chemistry' AND student_age = 21;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/2f3b35a696d6510f9b16a5f56018bbd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zZD67io5-uSpIPqGg-jcfQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">返回数据—21岁的化学专业学生—图片由作者提供</p></figure><p id="5b7c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">AND</code>子句使我们能够选择两个条件<strong class="la iu">并且只选择</strong>与两个条件完全匹配的行。在这种情况下，我们只选择<code class="fe lv lw lx ly b">degree = 'Chemistry'</code> <strong class="la iu">和</strong> <code class="fe lv lw lx ly b">student_age = 21</code> —这两个条件都必须与输出集中要返回的行相匹配。</p><p id="2605" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很自然，一个问题出现了。如果我们只想匹配其中一个条件呢？这意味着我们希望选择匹配第一个条件<strong class="la iu">或第二个条件</strong>的行——这在SQL中也非常简单，使用<code class="fe lv lw lx ly b">OR</code>子句:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="d222" class="md me it ly b gy mf mg l mh mi">select * from sandbox.students<br/>where degree = 'Chemistry' OR student_age = 21;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/af7eb1c6e5f53a97e026a7c7733f417f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OZTo_KOsHCIq5GcxkvRlXw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">返回数据—化学或21岁学生—作者图片</p></figure><p id="5ca7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，我们在这个结果中有4名学生，这是因为我们选择了有<code class="fe lv lw lx ly b">degree = 'Chemistry'</code> <strong class="la iu">或</strong> <code class="fe lv lw lx ly b">student_age = 21</code>的学生。在这种情况下，学生只能匹配<code class="fe lv lw lx ly b">WHERE</code>子句中的一个条件。</p><p id="acf8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是为什么我们有一个体育生在那里，那个学生21岁，只符合那个条件。</p><p id="5e5b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是SQL过滤器中最简单有效的概念之一。然而，您会注意到，当您开始使用多个<code class="fe lv lw lx ly b">AND</code>和<code class="fe lv lw lx ly b">OR</code>子句时，事情会变得相当混乱。这就是过滤优先级进入画面的地方。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="663b" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">运算符优先级</h1><p id="9780" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">SQL允许在同一个<code class="fe lv lw lx ly b">WHERE</code>中组合多个<code class="fe lv lw lx ly b">AND</code>和<code class="fe lv lw lx ly b">OR</code>条件。这真的很酷，但是也增加了我们查询的复杂性。</p><p id="524e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">幸运的是，通过学习过滤优先级，我们能够浏览更复杂的过滤器背后的逻辑。运算符优先逻辑模仿了我们从数学方程中了解到的内容，例如，想象以下SQL查询与我们的学生表:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="b66b" class="md me it ly b gy mf mg l mh mi">select * from sandbox.students<br/>where degree = 'Chemistry' OR student_age = 23 AND favorite_classes = 'History, Mathematics';</span></pre><p id="deb0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个查询的输出是什么？</p><p id="86f8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您直接阅读该查询，您认为SQL会选择所有拥有化学学位或23岁但同时他们最喜欢的课程是历史和数学的学生吗？</p><p id="91b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">哇，这句话真让人费解。让我们把它拆开。</p><p id="a814" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">极其重要— <code class="fe lv lw lx ly b">AND</code>优先于<code class="fe lv lw lx ly b">OR</code>！这意味着与<code class="fe lv lw lx ly b">AND</code>相关的子句将作为一个子句连接在一起，因此我们正在搜索:</p><ul class=""><li id="1047" class="np nq it la b lb lc le lf lh nr ll ns lp nt lt nu nv nw nx bi translated">23岁的学生最喜欢的课是“历史、数学”；</li></ul><p id="f3bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于<code class="fe lv lw lx ly b">AND</code>这两个子句是同时处理的，我们姑且把这个<strong class="la iu">子句称为1 </strong>。</p><p id="8ca1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好的，那么<code class="fe lv lw lx ly b">degree = 'Chemistry'</code>会从哪里进入画面呢？这个子句是我们在搜索中包含的另一个子句:</p><ul class=""><li id="a28a" class="np nq it la b lb lc le lf lh nr ll ns lp nt lt nu nv nw nx bi translated">每个有<code class="fe lv lw lx ly b">degree = 'Chemistry'</code>的学生</li></ul><p id="f0d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">姑且称之为<strong class="la iu">第二条款。</strong></p><p id="aeee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">继续，我们正在搜索所有符合条款1 <code class="fe lv lw lx ly b">OR</code>条款2的学生。<strong class="la iu">这意味着一个不是23岁的学生，如果他最喜欢的学位是化学，那么在我们的查询中仍然可以选择他最喜欢的课程是历史和数学。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/9c778c36138ea3d17f49bb8d4d62900f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7cuUASR5H1XIjEJvc0ryDg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">返回数据-喜欢历史和数学的化学系学生+ 23岁-图片由作者提供</p></figure><p id="110b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">底线是，SQL过滤的第一条戒律是:<code class="fe lv lw lx ly b">AND</code>优先于<code class="fe lv lw lx ly b">OR</code>。第二条戒律是，我们可以使用括号来覆盖这些规则，就像我们在数学方程中所做的那样:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="8bb6" class="md me it ly b gy mf mg l mh mi">select * from sandbox.students<br/>where (degree = 'Chemistry' OR student_age = 23) AND favorite_classes = 'History, Mathematics';</span></pre><p id="4cb9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，操作略有不同— <strong class="la iu">条款1 </strong>将是:</p><ul class=""><li id="71ae" class="np nq it la b lb lc le lf lh nr ll ns lp nt lt nu nv nw nx bi translated">拥有化学学位或23岁的学生。</li></ul><p id="2c53" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">而<strong class="la iu">第二条</strong>是:</p><ul class=""><li id="ca94" class="np nq it la b lb lc le lf lh nr ll ns lp nt lt nu nv nw nx bi translated">喜欢历史和数学课的学生。</li></ul><p id="3ab4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，我们希望:“每个有历史和数学课的学生，无论是化学还是23岁。<strong class="la iu">在这种情况下，只有一个学生符合条件:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/ca66884d0247fcdedf5e2f5bb71b9379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KQUdUqPopFks_ldivKqrRw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">返回数据-喜欢历史和数学的23岁或化学专业的学生-图片由作者提供</p></figure><p id="cf14" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意一个括号是如何改变整个查询结果的！运算符优先级非常重要，会完全改变返回数据的结果。总之:</p><ul class=""><li id="db54" class="np nq it la b lb lc le lf lh nr ll ns lp nt lt nu nv nw nx bi translated"><code class="fe lv lw lx ly b">AND</code>优先于<code class="fe lv lw lx ly b">OR</code></li><li id="97e5" class="np nq it la b lb nz le oa lh ob ll oc lp od lt nu nv nw nx bi translated">括号改变了优先级，并人为地为括号内的代码创建了一个优先级。</li></ul><p id="d126" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不错！让我们继续另一个概念，用多个<code class="fe lv lw lx ly b">OR</code>条件减少我们代码的重要部分。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="c554" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">在/不在</h1><p id="38e1" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated"><code class="fe lv lw lx ly b">IN</code>和<code class="fe lv lw lx ly b">NOT IN</code>操作符是编写需要同时匹配多个元素的条件的非常酷的方式。例如，假设我要求您从表中筛选出以下学生:“乔·亚当斯”、“约翰·史密斯”和“艾米·亚当斯”。</p><p id="f67a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">知道了<code class="fe lv lw lx ly b">OR</code>条件，您可以立即编写以下查询:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="8c34" class="md me it ly b gy mf mg l mh mi">select * from sandbox.students<br/>where student_full_name = 'Joe Adams' or student_full_name = 'John Smith' or student_full_name = 'Amy Smith';</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/bd925921cc9cd18d8d2c4dc68ab33a35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dvkHOBfPL0wjSJ4qNraM1g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">返回数据-约翰·史密斯、艾米·史密斯或乔·亚当斯-作者图片</p></figure><p id="3950" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这似乎是一个合理的结果，但是..假设你想从20个名字中挑选一个？真的要把<code class="fe lv lw lx ly b">OR</code>条件写20遍吗？我觉得不是！</p><p id="31e5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">幸运的是，我们有<code class="fe lv lw lx ly b">IN</code>操作员来帮助我们！</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="b4e5" class="md me it ly b gy mf mg l mh mi">select * from sandbox.students<br/>where student_full_name IN ('Joe Adams','John Smith','Amy Smith');</span></pre><p id="97d0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">IN</code>操作符作为一个多重<code class="fe lv lw lx ly b">OR</code>条件，但是以一种更优雅的方式编写。在<code class="fe lv lw lx ly b">IN</code>内部，我们可以添加多个元素进行匹配，而无需多次重复<code class="fe lv lw lx ly b">"or student_full_name ="</code>。</p><p id="28b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">NOT IN</code>的工作方式完全相同，但它不包括括号内的元素:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="e518" class="md me it ly b gy mf mg l mh mi">select * from sandbox.students<br/>where student_full_name NOT IN ('Joe Adams','John Smith','Amy Smith');</span></pre><p id="d836" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将选择所有学生<strong class="la iu">，除了</strong>在<code class="fe lv lw lx ly b">IN</code>子句中的学生:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/daae00392631794dcf70d307011bfde0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*go9O6hsOK9n0uJqH1IhhDQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">返回数据-约翰·史密斯、艾米·史密斯或乔·亚当斯-作者图片</p></figure><p id="c3ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">IN</code>子句非常酷和方便——我们可以用它来避免编写非常长的SQL语句。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="18d1" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">通配符</h1><p id="8838" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">我们最后的SQL过滤概念是通配符。通配符对于基于“子集”条件过滤非常有用。</p><p id="96d2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，假设我们希望选择姓氏为“Smith”的所有学生—当然，我们可以拆分列来实现这一点，但是，如果我们知道如何应用通配符，这将是不需要的额外代码。</p><p id="73fe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通配符以三个不同的元素为中心:</p><ul class=""><li id="d2da" class="np nq it la b lb lc le lf lh nr ll ns lp nt lt nu nv nw nx bi translated"><code class="fe lv lw lx ly b">LIKE</code>条款；</li><li id="467f" class="np nq it la b lb nz le oa lh ob ll oc lp od lt nu nv nw nx bi translated"><code class="fe lv lw lx ly b">%</code>人物；</li><li id="d303" class="np nq it la b lb nz le oa lh ob ll oc lp od lt nu nv nw nx bi translated"><code class="fe lv lw lx ly b">_</code>字符；</li></ul><p id="3df5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从我们的示例开始—选择姓氏为“Smith”的所有学生:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="2259" class="md me it ly b gy mf mg l mh mi">select * from sandbox.students<br/>where student_full_name LIKE '%Smith';</span></pre><p id="304f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个通配符选择中，<code class="fe lv lw lx ly b">%</code>的作用是“不管Smith之前是什么”。将这个查询转换成一个句子，我们选择“全名以“Smith”结尾的每一行，不管前面是什么”。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/b176aaad6e73c7fb3b58520a045487a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-xZ6NoVudLFyU_0c50zSZg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">返回数据-所有姓“Smith”的学生-图片由作者提供</p></figure><p id="2a3d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们想从表中选择所有的“Joe ”,该怎么办？那很简单！我们只是将通配符<code class="fe lv lw lx ly b">%</code>放在我们正在搜索的元素的末尾:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="267b" class="md me it ly b gy mf mg l mh mi">select * from sandbox.students<br/>where student_full_name LIKE 'Joe%';</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/be35441ff3e8c0878e5439afc1f2e43e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8NvniTD1X1QA5W2Jnws7hg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">返回数据-名字为“Joe”的所有学生-作者图片</p></figure><p id="1117" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">酷！所以<code class="fe lv lw lx ly b">%</code>总是以这种方式工作——它使得我们的查询不知道我们正在搜索的字符串之前或之后是什么。我们也可以使用双面<code class="fe lv lw lx ly b">%</code>:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="b148" class="md me it ly b gy mf mg l mh mi">select * from sandbox.students<br/>where student_full_name LIKE '%am%';</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/7516115d80b8e705ab027f563a819da4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sSS1mHWp9Yvn2IQz1OeYIw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">返回数据-姓名中带有“am”的所有学生-按作者分类的图片</p></figure><p id="4b10" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后一个查询将搜索姓名中包含“am”的所有学生。<strong class="la iu"> Am </strong> y Smith，Joe Ad <strong class="la iu"> am </strong> s，Joe Willi <strong class="la iu"> am </strong> s，Anne Willi <strong class="la iu"> am </strong> s，双面<code class="fe lv lw lx ly b">%</code>不关心我们同时搜索的字符串之前或之后的内容。</p><p id="b34e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们来检查一下<code class="fe lv lw lx ly b">_</code>人物:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="a6be" class="md me it ly b gy mf mg l mh mi">select * from sandbox.students<br/>where student_full_name LIKE '_o%';</span></pre><p id="b587" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">_</code>明确指出了我们搜索特定字母或字符串的位置。例如，这里我们搜索第二个位置包含“o”的所有名称，这将产生:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/ee02a45e2582b5a28746acdbb8c9e89f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tL2ocYjudb34VMKBjQJBUA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">返回数据-姓名第二个字母为“o”的所有学生-作者图片</p></figure><p id="1d05" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有这些学生的第二个字母都是“o”。如果我们只想要名字的第三个字母有“e”的学生呢？有了<code class="fe lv lw lx ly b">_</code>这个角色也很容易！</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="bb7c" class="md me it ly b gy mf mg l mh mi">select * from sandbox.students<br/>where student_full_name LIKE '__e%';</span></pre><p id="c2e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我们现在想要“名字”的第三个位置——我们添加了两个下划线:<code class="fe lv lw lx ly b">__</code>。该查询产生:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/f67bd437265b11c4721c5cdc54e624c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*37BRWHEcwbcx8PuiCMtIZA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">返回数据-姓名第三个字母为“e”的所有学生-作者图片</p></figure><p id="0b20" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通配符是非常酷的过滤元素！掌握通配符将简化您的查询，并使它们真正高效。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="beaf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们完事了。感谢你花时间阅读这篇文章。SQL是一种非常酷的语言，可以为我们的数据争论游戏打气。</p><p id="ed59" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为一名数据科学家，很有可能最终会使用存储在数据库中的数据——掌握其中一些概念将会提高您的生产率和代码效率。</p><p id="72f8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="lu">我在</em></strong><a class="ae ok" href="https://www.udemy.com/course/sql-for-absolute-beginners/?referralCode=23E560A160F7202E026F" rel="noopener ugc nofollow" target="_blank"><strong class="la iu"><em class="lu">Udemy</em></strong></a><strong class="la iu"><em class="lu">上开设了一门关于从零开始学习SQL的课程，我在其中深入探讨了这些概念以及更多内容——这门课程适合绝对的初学者，我希望你能在我身边！</em> </strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/5301705d3dd6b6e4e0d353ac1103cace.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*7MlLJhXRLWIG89AtaXvp3g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ok" href="https://www.udemy.com/course/sql-for-absolute-beginners/?referralCode=23E560A160F7202E026F" rel="noopener ugc nofollow" target="_blank"> SQL绝对初学者</a> —图片由作者提供</p></figure><div class="om on gp gr oo op"><a href="https://ivopbernardo.medium.com/membership" rel="noopener follow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">通过我的推荐链接加入Medium-Ivo Bernardo</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">ivopbernardo.medium.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd ks op"/></div></div></a></div></div></div>    
</body>
</html>