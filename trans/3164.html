<html>
<head>
<title>Do Not Use If-Else For Validating Data Objects In Python Anymore — Colander</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要再使用If-Else来验证Python中的数据对象——Colander</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/do-not-use-if-else-for-validating-data-objects-in-python-anymore-colander-7dd66c435118#2022-07-12">https://towardsdatascience.com/do-not-use-if-else-for-validating-data-objects-in-python-anymore-colander-7dd66c435118#2022-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/400eb41a0c64c789eb06bfa66d9a4f1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*so7Ev1GjnaYIRcJphHaiSQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://pixabay.com/users/irenna86-233597/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=7305172" rel="noopener ugc nofollow" target="_blank"> Irenna86 </a>来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=7305172" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><div class=""/><div class=""><h2 id="d0a4" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">使用定制的类以灵活的模式定义你的数据结构</h2></div><p id="d5fa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">几周前，我介绍了一个名为Cerberus的Python库。它可以让我们编写一个“模式”,以简洁易读的方式验证我们的数据对象(JSON/Dictionary ),而不是使用无尽的if-else条件。</p><div class="is it gp gr iu lu"><a rel="noopener follow" target="_blank" href="/do-not-use-if-else-for-validating-data-objects-in-python-anymore-17203e1d65fe"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd jk gy z fp lz fr fs ma fu fw ji bi translated">不要再使用If-Else来验证Python中的数据对象</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">Cerberus——一种简洁易读的验证字典属性的方式。</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">towardsdatascience.com</p></div></div><div class="md l"><div class="me l mf mg mh md mi ja lu"/></div></div></a></div><p id="2629" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将介绍另一个令人惊叹的第三方库— Colander。然而，它做了一件非常相似的事情，只是方式非常不同。它使用类，而不是在字典中定义验证规则。这听起来有点庞大，但是如果我们有一个非常复杂的数据结构需要验证，这可能会更有组织性。此外，当我们在类中编写所有的验证规则时，有一个显著的好处。也就是说，我们可以将它导出为一个可以导入的独立模块。换句话说，它在另一个层面上提供了灵活性和可重用性。</p><div class="is it gp gr iu lu"><a href="https://docs.pylonsproject.org/projects/colander/en/latest/index.html" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd jk gy z fp lz fr fs ma fu fw ji bi translated">漏勺-漏勺1.8.3文件</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">Colander是一个非常有用的系统，可以用来验证和反序列化通过XML、JSON、HTML表单post或任何其他方式获得的数据</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">docs.pylonsproject.org</p></div></div></div></a></div><h1 id="eb3f" class="mj mk jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">1.基础</h1><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/858ff1877024620953374a603d817d0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*13r5pjuZvYPRPm9oiuurDg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/users/pexels-2286921/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1840300" rel="noopener ugc nofollow" target="_blank">像素</a>来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1840300" rel="noopener ugc nofollow" target="_blank">像素</a></p></figure><p id="cdcb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像往常一样，让我们从一个不成熟但基本的例子开始，看看这个库是如何工作的。在我们可以使用这个库之前，别忘了安装它。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="eb56" class="nk mk jj ng b gy nl nm l nn no">pip install colander</span></pre><p id="96ca" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们需要一个样本JSON，或者Python字典。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="a3a0" class="nk mk jj ng b gy nl nm l nn no">my_json = {<br/>    'name': 'Chris',<br/>    'age': '34',<br/>    'skills': [<br/>        ('1', 'Python'), ('2', 'Data Science'), ('3', 'DevOps')<br/>    ]<br/>}</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi np"><img src="../Images/fc8ad6520bf8db732974b06daf1af034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*39jy0ZxYJFq8tx-SzQ71cw.png"/></div></div></figure><p id="9609" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，所有的属性和值都是字符串。当我们以消息的形式从另一个系统获取数据对象时，这是一种很常见的情况。</p><p id="725c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们需要导入我们刚刚安装的colander模块，然后如下定义3个类。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="5d6f" class="nk mk jj ng b gy nl nm l nn no">import colander</span><span id="8d37" class="nk mk jj ng b gy nq nm l nn no">class Skill(colander.TupleSchema):<br/>    rank = colander.SchemaNode(colander.Int())<br/>    name = colander.SchemaNode(colander.String())</span><span id="0ee7" class="nk mk jj ng b gy nq nm l nn no">class Skills(colander.SequenceSchema):<br/>    skill = Skill()</span><span id="5253" class="nk mk jj ng b gy nq nm l nn no">class Person(colander.MappingSchema):<br/>    name = colander.SchemaNode(colander.String())<br/>    age = colander.SchemaNode(colander.Int())<br/>    skills = Skills()</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nr"><img src="../Images/c6a75098d45865d2e79ca0e940ffd059.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sZ08MQ-h5hI5wpC8vJAHkg.png"/></div></div></figure><h2 id="024d" class="nk mk jj bd ml ns nt dn mp nu nv dp mt lh nw nx mv ll ny nz mx lp oa ob mz oc bi translated">Colander模式类</h2><p id="28a8" class="pw-post-body-paragraph ky kz jj la b lb od kk ld le oe kn lg lh of lj lk ll og ln lo lp oh lr ls lt im bi translated">Person类定义了总体模式。它有3个属性，属性“技能”来自另一个类。然后，技能类只有一个属性—技能。技能类别定义了个人技能的结构。</p><p id="e463" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管我们需要定义多个类，但这可以保持代码整洁。在某些情况下，它甚至比使用字典更好，就像我们在Cerberus中所做的那样。</p><h2 id="6f8e" class="nk mk jj bd ml ns nt dn mp nu nv dp mt lh nw nx mv ll ny nz mx lp oa ob mz oc bi translated">Colander模式类型</h2><p id="15f5" class="pw-post-body-paragraph ky kz jj la b lb od kk ld le oe kn lg lh of lj lk ll og ln lo lp oh lr ls lt im bi translated">所有的类都需要从Colander继承模式类型。在上面的例子中，<code class="fe oi oj ok ng b">TupleSchema</code>指的是元组，<code class="fe oi oj ok ng b">SequenceSchema</code>指的是顺序重要的集合类型，<code class="fe oi oj ok ng b">MappingSchema</code>指的是字典。</p><p id="ec34" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了示例中的这些，还有更多可用的模式类型。请参考官方文档。</p><h2 id="b091" class="nk mk jj bd ml ns nt dn mp nu nv dp mt lh nw nx mv ll ny nz mx lp oa ob mz oc bi translated">Colander模式节点</h2><p id="7cf0" class="pw-post-body-paragraph ky kz jj la b lb od kk ld le oe kn lg lh of lj lk ll og ln lo lp oh lr ls lt im bi translated">顾名思义，每个colander模式节点都引用原始数据结构中的一个原子属性。例如，字符串属性“name”应该是字符串类型的模式节点，而age属性应该是整数模式节点。</p><h2 id="3547" class="nk mk jj bd ml ns nt dn mp nu nv dp mt lh nw nx mv ll ny nz mx lp oa ob mz oc bi translated">反序列化JSON对象</h2><p id="dc4a" class="pw-post-body-paragraph ky kz jj la b lb od kk ld le oe kn lg lh of lj lk ll og ln lo lp oh lr ls lt im bi translated">现在，我们已经定义了模式，这是Person类。在使用它之前，我们需要将其实例化为一个模式对象。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="6d4c" class="nk mk jj ng b gy nl nm l nn no">person_schema = Person()</span></pre><p id="83bb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们可以使用这个模式对象去序列化JSON对象。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="e5b0" class="nk mk jj ng b gy nl nm l nn no">person_object = person_schema.deserialize(my_json)</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/1849b94436c98a8d665ffa0ba339949d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*40UdjZL-pMeTIKDVXscUTw.png"/></div></div></figure><p id="ea31" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在去军事化过程中至少发生了两件事。首先，JSON对象经过了这个“漏勺”，所有的验证器都通过了。其次，那些整数类型的属性被正确地从字符串转换成整数。</p><p id="e44b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可以看出，理解JSON结构是如何被验证的，以及Colander将字符串值反序列化为目标数据类型的机制是什么是很重要的。</p><h1 id="b7f0" class="mj mk jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">2.验证者和准备者</h1><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/a9f044a19bee067a61f6351914444b99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vyPSRRSN7DOvXEj4IcM3TA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1839626" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/pexels-2286921/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1839626" rel="noopener ugc nofollow" target="_blank">像素</a></p></figure><p id="73c9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了演示验证器是如何工作的，我们可以使用一个相对简单的例子。假设我们有下面的字典。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="4545" class="nk mk jj ng b gy nl nm l nn no">my_json = {<br/>    'name': 'Chris',<br/>    'age': -1,<br/>    'gender': 'Male'<br/>}</span></pre><p id="51a5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们可以尝试向模式中添加一些验证器。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="87ef" class="nk mk jj ng b gy nl nm l nn no">class Person(colander.MappingSchema):<br/>    name = colander.SchemaNode(colander.String())<br/>    age = colander.SchemaNode(<br/>        colander.Int(),<br/>        validator=colander.Range(0,150)<br/>    )<br/>    gender = colander.SchemaNode(<br/>        colander.String(),<br/>        validator=colander.OneOf(['M', 'F', 'Other'])<br/>    )</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi om"><img src="../Images/9950bcfa7ef40ca977648957a9d30eb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2hFkDrDmuUqVDwuBmVuEsQ.png"/></div></div></figure><p id="f860" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的例子中，为<code class="fe oi oj ok ng b">age</code>和<code class="fe oi oj ok ng b">gender</code>属性添加了两个<strong class="la jk">内置的</strong>验证器。Colander提供了许多内置的验证器，因此我们可以轻松地利用它们。</p><p id="f585" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于属性<code class="fe oi oj ok ng b">age</code>，我们想把它限制在一个整数范围内，在0到150之间。</p><p id="311d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于属性<code class="fe oi oj ok ng b">gender</code>，我们希望它是数组中预定义的值之一。</p><p id="aa87" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们再次尝试去序列化它，看看验证器是如何工作的。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="0112" class="nk mk jj ng b gy nl nm l nn no">person_schema = Person()<br/>person_object = person_schema.deserialize(my_json)</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi on"><img src="../Images/c1c6b6ebffa9a9e540e55c987e6fd0fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GhGIeSKqebXtn9BN-9r0cQ.png"/></div></div></figure><p id="d2c5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如图所示，两个验证器都抱怨了，并且给出了具体的错误消息，这对理解发生了什么非常有帮助。</p><h2 id="ad8e" class="nk mk jj bd ml ns nt dn mp nu nv dp mt lh nw nx mv ll ny nz mx lp oa ob mz oc bi translated">将错误消息作为字典获取</h2><p id="cb29" class="pw-post-body-paragraph ky kz jj la b lb od kk ld le oe kn lg lh of lj lk ll og ln lo lp oh lr ls lt im bi translated">您可能已经注意到，错误消息实际上是JSON格式的。这使得返回到下游组件进行显示变得更加容易。</p><p id="ddbe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用try-except块，我们可以很容易地将这个错误消息作为一个字典来“捕捉”。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="4fa4" class="nk mk jj ng b gy nl nm l nn no">try:<br/>    person_object = person_schema.deserialize(my_json)<br/>except colander.Invalid as e:<br/>    print(e.asdict())</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oo"><img src="../Images/fee1a903a1314dcae273d66894424941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pjc7_wNIVIUOPd_QD_7Kww.png"/></div></div></figure><h2 id="9433" class="nk mk jj bd ml ns nt dn mp nu nv dp mt lh nw nx mv ll ny nz mx lp oa ob mz oc bi translated">定制验证者和准备者</h2><p id="aca5" class="pw-post-body-paragraph ky kz jj la b lb od kk ld le oe kn lg lh of lj lk ll og ln lo lp oh lr ls lt im bi translated">现在，让我们看看如何定制一个验证器。尽管有许多内置的验证器，有时我们可能仍然对我们的数据结构有非常特殊的要求。</p><p id="6f3f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要定制一个Colander模式节点来拥有一个定制的验证器。要定义一个定制的Colander模式节点，我们需要编写一个类，并让它从<code class="fe oi oj ok ng b">colander.SchemaNode</code>继承，如下所示。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="d65f" class="nk mk jj ng b gy nl nm l nn no">class GenderString(colander.SchemaNode):<br/>    schema_type = colander.String<br/>    title = 'Gender String'</span><span id="10b5" class="nk mk jj ng b gy nq nm l nn no">    def preparer(self, value):<br/>        if value == 'Female':<br/>            return 'F'<br/>        elif value == 'Male':<br/>            return 'M'<br/>        else:<br/>            return value</span><span id="6663" class="nk mk jj ng b gy nq nm l nn no">    def validator(self, node, value):<br/>        if value not in ['F', 'M', 'Other']:<br/>            raise colander.Invalid(value, 'is not a valid gender string')</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi op"><img src="../Images/988b17d8bf85e652599591e55225951e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d-ug5OqqfnVkIyiSOcAtuA.png"/></div></div></figure><p id="08f0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的代码中，我们定义了一个名为<code class="fe oi oj ok ng b">GenderString</code>的类，这将是一个定制的Colander模式节点。在这个类中，我们需要指定模式类型，它是一个字符串。然后，我们实现了两个方法<code class="fe oi oj ok ng b">preparer</code>和<code class="fe oi oj ok ng b">validator</code>。</p><p id="e8dd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe oi oj ok ng b">preparer()</code>方法中，我们定义了类似“魔法”的东西。即当性别字符串为“男性”时，会转换为单字母缩写“M”，所以为“女性”。这个方法将在验证器之前执行，它也将改变这个节点的值。</p><p id="a736" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在验证器中，我们使用简单的if-else条件定义了验证方法。如果无效，将引发“无效”错误，并且消息也是定制的。</p><p id="83ac" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">定义了这个模式节点后，我们可以在模式定义中使用它，如下所示。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="a654" class="nk mk jj ng b gy nl nm l nn no">class Person(colander.MappingSchema):<br/>    name = colander.SchemaNode(colander.String())<br/>    age = colander.SchemaNode(colander.Int())<br/>    gender = GenderString()</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oq"><img src="../Images/af9391602bb9034b0eb126beb8bdf837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4EhioEYjDAMtHsl58pH-SQ.png"/></div></div></figure><p id="7d13" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，<code class="fe oi oj ok ng b">gender</code>属性已经被分配了一个<code class="fe oi oj ok ng b">GenderString</code>实例。</p><p id="f04c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们更正原始JSON的<code class="fe oi oj ok ng b">age</code>属性，看看验证器是否能通过。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="f823" class="nk mk jj ng b gy nl nm l nn no">my_json['age'] = 34</span><span id="d888" class="nk mk jj ng b gy nq nm l nn no">person_schema = Person()<br/>person_object = person_schema.deserialize(my_json)</span><span id="5a53" class="nk mk jj ng b gy nq nm l nn no">print(my_json)<br/>print(person_object)</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi or"><img src="../Images/9f62aeaf51aa22769f3cd7b776d1a319.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hIErsOxyHlkLK221neftag.png"/></div></div></figure><p id="4ca7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">酷！JSON对象已经通过了验证器，性别字符串也已经从“男性”转换为“M”。</p><h1 id="c2d8" class="mj mk jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">3.漏测值</h1><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/921a339205aa3b9b568ac648b131bc58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rnbzWY6GarVmBY4KA6fIYg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2343224" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/malinbatmastar-5460879/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2343224" rel="noopener ugc nofollow" target="_blank">Malin btm star</a></p></figure><p id="f155" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">处理缺少值的情况很重要。有时，我们不允许缺少值，默认情况下Colander支持这一点。</p><p id="0adb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们再次定义模式，只是使用一些简单的定义。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="89ef" class="nk mk jj ng b gy nl nm l nn no">class Person(colander.MappingSchema):<br/>    name = colander.SchemaNode(colander.String())<br/>    age = colander.SchemaNode(colander.Int())<br/>    gender = colander.SchemaNode(colander.String())</span></pre><p id="336b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，让我们有一个新的JSON对象，并且其中没有属性。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="1bd1" class="nk mk jj ng b gy nl nm l nn no">my_json = {'name': 'Chris', 'age': 34}</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi os"><img src="../Images/f1a5b2b15db57378d010e8d60c5d9456.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hcrCHF3WhifcTiIvkIBw_Q.png"/></div></div></figure><p id="a8fd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们再次尝试去非军事化。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="0edf" class="nk mk jj ng b gy nl nm l nn no">person_schema = Person()<br/>person_object = person_schema.deserialize(my_json)</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ot"><img src="../Images/fc72d3b68049812de7ca48a4d797ecc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9OC2EFg9jn5hWY0S6K_lpw.png"/></div></div></figure><p id="47cf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如错误消息所示，模式假设所有属性都是必需的，只要我们已经定义了它们。</p><p id="6d2b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这很好，因为我们确实需要验证器来帮助验证一个必填字段是否存在。但是，如果这应该是一个可选属性呢？实际上，我们只需要在schema节点中添加一个<code class="fe oi oj ok ng b">missing</code>参数，如下所示。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="cfdf" class="nk mk jj ng b gy nl nm l nn no">class Person(colander.MappingSchema):<br/>    name = colander.SchemaNode(colander.String())<br/>    age = colander.SchemaNode(colander.Int())<br/>    gender = colander.SchemaNode(<br/>        colander.String(), <br/>        missing='Unknown'<br/>    )</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ou"><img src="../Images/65b4b866d836aa929a5132d35f286222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-sJtViVVpJRASsdiDaQJqw.png"/></div></div></figure><p id="d59a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如图所示，<code class="fe oi oj ok ng b">missing</code>参数的值将用于填充属性，如果没有给出的话。但是，如果我们不想给一个回退值呢？我们可以使用<code class="fe oi oj ok ng b">colander.drop</code>作为<code class="fe oi oj ok ng b">missing</code>参数，表示如果在源代码中没有给出这个属性，就不要包含它。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="eacd" class="nk mk jj ng b gy nl nm l nn no">class Person(colander.MappingSchema):<br/>    name = colander.SchemaNode(colander.String())<br/>    age = colander.SchemaNode(colander.Int())<br/>    gender = colander.SchemaNode(<br/>        colander.String(), <br/>        missing=colander.drop<br/>    )</span><span id="c893" class="nk mk jj ng b gy nq nm l nn no">person_schema = Person()<br/>person_object = person_schema.deserialize(my_json)</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ov"><img src="../Images/b18ebce5f440ea1a3af15bd7e4d896a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v8diGAlFQIS3COsVSBlp9Q.png"/></div></div></figure><h1 id="bc9e" class="mj mk jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">4.数据结构扁平化</h1><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/b063b030c0c179b4fc84622f9feec541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y6o_l7iazUlt_LstP3Zi2g.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1903316" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/ulleo-1834854/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1903316" rel="noopener ugc nofollow" target="_blank"> Ulrike Leone </a></p></figure><p id="473a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后我想介绍的是Colander库的扁平化特性。这可能是一个非常有用的方法。</p><p id="9537" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们回到最初的JSON。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="1dd8" class="nk mk jj ng b gy nl nm l nn no">my_json = {<br/>    'name': 'Chris',<br/>    'age': '34',<br/>    'skills': [<br/>        ('1', 'Python'), ('2', 'Data Science'), ('3', 'DevOps')<br/>    ]<br/>}</span></pre><p id="b723" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，让我们把原来的模式找回来。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="178f" class="nk mk jj ng b gy nl nm l nn no">class Skill(colander.TupleSchema):<br/>    rank = colander.SchemaNode(colander.Int())<br/>    name = colander.SchemaNode(colander.String())</span><span id="9bd4" class="nk mk jj ng b gy nq nm l nn no">class Skills(colander.SequenceSchema):<br/>    skill = Skill()</span><span id="91ab" class="nk mk jj ng b gy nq nm l nn no">class Person(colander.MappingSchema):<br/>    name = colander.SchemaNode(colander.String())<br/>    age = colander.SchemaNode(colander.Int())<br/>    skills = Skills()</span></pre><p id="e29e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这次让我们跳过反序列化，使用模式中的<code class="fe oi oj ok ng b">flatten()</code>方法。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="852b" class="nk mk jj ng b gy nl nm l nn no">person_object = person_schema.flatten(my_json)</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ow"><img src="../Images/e4c9869d8002041438e63230a0512bcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EJOMUagn-zTA68sYaDwAsQ.png"/></div></div></figure><p id="9a2c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">JSON文档被简化成一维的键值对字典。</p><p id="c99d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实上，我们也可以使用这种符号从数据结构中获取特定的值，如下所示。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="59d6" class="nk mk jj ng b gy nl nm l nn no">person_schema.get_value(my_json, 'skills.0.name')</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ox"><img src="../Images/ecd3a0168a9956f3a87512370ef16f72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JJRGB_mtMa-Pl_nzb-yaaw.png"/></div></div></figure><h1 id="891d" class="mj mk jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">摘要</h1><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/7aab11bbfb59f82932934805775cdc67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*psFFwXnD8fv7DPMC-OH7lQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=7302776" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/iemlee-5726489/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=7302776" rel="noopener ugc nofollow" target="_blank"> myungho lee </a></p></figure><p id="52e9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我介绍了另一个用于数据验证的库——Colander。和我之前介绍过的Cerberus库相比，很难说哪个更好。这取决于使用案例和个人偏好。</p><p id="d1b3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总的来说，我认为Colander更适合需要非常复杂的验证和特殊需求的用例。它使我们能够编写更可读的代码。然而，Colander中的所有东西都必须被定义为一个类。所以，如果用例不是那么复杂，这就有点过度设计了。</p><div class="is it gp gr iu lu"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd jk gy z fp lz fr fs ma fu fw ji bi translated">通过我的推荐链接加入灵媒-陶</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">谢谢你看我的文章！如果你不介意，请给我买杯咖啡:)你的会员费支持几千…</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">medium.com</p></div></div><div class="md l"><div class="oy l mf mg mh md mi ja lu"/></div></div></a></div><p id="2954" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你觉得我的文章有帮助，请考虑加入Medium会员来支持我和成千上万的其他作者！(点击上面的链接)</p><blockquote class="oz"><p id="f7fc" class="pa pb jj bd pc pd pe pf pg ph pi lt dk translated"><em class="pj">除非另有说明，所有图片均出自作者之手</em></p></blockquote></div></div>    
</body>
</html>