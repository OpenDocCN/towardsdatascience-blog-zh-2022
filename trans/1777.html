<html>
<head>
<title>Differential Evolution: An alternative to nonlinear convex optimization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">差分进化:非线性凸优化的替代方案</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/differential-evolution-an-alternative-to-nonlinear-convex-optimization-690a123f3413#2022-04-26">https://towardsdatascience.com/differential-evolution-an-alternative-to-nonlinear-convex-optimization-690a123f3413#2022-04-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5da1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解差分进化的基础知识及其在Python中的应用</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dc6617966d73e3a610a44a0776654047.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7_UvtuoNUDfsRgLT"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">阿曼德·库利在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><blockquote class="kw kx ky"><p id="8060" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">优化是一种决策制定，或者更具体地说，是决策制定机制中的主要量化工具之一，其中必须做出决策，以在一些规定的情况下优化一个或多个目标(Bilal等人，2020)。</p></blockquote><p id="2308" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">差分进化(DE) (Storn &amp; Price，1997)是一种进化算法(EA)，最初设计用于解决连续域上的优化问题。它实现简单，但解决问题的质量很好，这使它成为最受欢迎的基于群体的算法之一，有几个成功的应用报告。</p><p id="5b4d" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">从最初的概念来看，DE的设计是为了满足一些使其特别有用的要求:</p><ol class=""><li id="5af9" class="lz ma iq lc b ld le lg lh lw mb lx mc ly md lv me mf mg mh bi translated">处理不可微、非线性和多模态成本函数的能力。</li><li id="1753" class="lz ma iq lc b ld mi lg mj lw mk lx ml ly mm lv me mf mg mh bi translated">处理计算密集型成本函数的并行性。</li><li id="77a4" class="lz ma iq lc b ld mi lg mj lw mk lx ml ly mm lv me mf mg mh bi translated">易于使用:很少的控制变量来控制最小化。这些变量也应该是稳健的和易于选择的。</li><li id="5a2b" class="lz ma iq lc b ld mi lg mj lw mk lx ml ly mm lv me mf mg mh bi translated">良好的收敛性:在连续的独立试验中一致收敛到全局最小值。</li></ol><p id="c830" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在整篇文章中，我们将看到差分进化的基础知识以及对单目标优化问题的应用——尽管它对多目标优化也有一些扩展。它将与传统的基于凸梯度的算法进行比较，以评估每种算法何时更合适。所有这些都将使用<em class="lb"> scipy.optimize </em> Python模块来执行。感兴趣的可以在我的<a class="ae kv" href="https://github.com/bruscalia/optimization-demo-files/blob/main/nonconvex/de_scipy.ipynb" rel="noopener ugc nofollow" target="_blank">示例笔记本</a>中找到实现细节。</p><p id="4993" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">如果你对非线性优化不熟悉，建议阅读我之前的文章<a class="ae kv" rel="noopener" target="_blank" href="/nonlinear-programming-theory-and-applications-cfe127b6060c"> <em class="lb">非线性规划:理论与应用</em> </a>。</p><div class="mn mo gp gr mp mq"><a rel="noopener follow" target="_blank" href="/nonlinear-programming-theory-and-applications-cfe127b6060c"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd ir gy z fp mv fr fs mw fu fw ip bi translated">非线性规划:理论与应用</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">详细解释了基于梯度的线搜索优化算法，并用Python从头开始实现</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">towardsdatascience.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne kp mq"/></div></div></a></div><p id="3b6a" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">下坡过程在当时是一个很好的类比…然而，搜索空间在本文中可能会变得更加混乱。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="d7e1" class="nm nn iq bd no np nq nr ns nt nu nv nw jw nx jx ny jz nz ka oa kc ob kd oc od bi translated"><strong class="ak">算法解释</strong></h1><blockquote class="kw kx ky"><p id="c6f0" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">就像自然界一样，进化算子对进化算法种群进行操作，试图产生适应度越来越高的解。与这些算法相关的三个主要算子是突变、重组(交叉)和选择(存活)<em class="iq"> (Coello等人，2007) </em>。</p></blockquote><p id="cda7" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">下面表示了DE算法的基本结构，接下来将描述其中的主要算子和它们各自的控制参数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/62f752f100faacb3854ce59eb1289aaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FGCAhZPxbEbkKmzQ33w0DQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">差异进化的基本结构。(图片由作者提供)。</p></figure><p id="dc38" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">该算法首先基于用户指定的个体数量<em class="lb"> N </em>和问题的每个决策变量的边界来初始化<em class="lb">群体</em>。每个个体对应一个优化变量的<em class="lb">向量</em>。在5到10倍的决策变量之间选择<em class="lb"> N </em>可能是一个好的开始。</p><p id="4bfe" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">基于个体对应的目标函数值和可能的约束值，个体被分配一个适应值。最初，DE没有约束处理的规则，这是后来几篇文章的焦点。Lampinen (2002年)提出了一种有用的方法，因为它表现出有竞争力的性能，并且在实施时不需要额外的控制参数。这是在<em class="lb"> scipy </em> DE实现中采用的方法。</p><p id="b55e" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">然后，种群在连续的世代中迭代，直到满足某些停止标准。在每一次迭代中，新的试验向量通过称为<em class="lb">突变</em>和<em class="lb">交叉</em>的操作产生。然后，将试验向量与其对应的相同索引的父向量进行比较，并将每对中的最佳向量传递给下一代。停止标准通常基于目标函数和代数的改进。</p><p id="dbf0" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">已经为DE提出了几种复制方案。通常用DE/x/y/z表示，其中<em class="lb"> x </em>对应变异亲本选择方案，<em class="lb"> y </em>对应差异向量个数，<em class="lb"> z </em>对应交叉策略。</p><p id="19d7" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">可能最流行的<em class="lb">突变方案</em>是DE/rand/1，由下面的等式表示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/15b55405805cb2ce8ead9bd1d9f4644e.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*FmFt8GUWGWd1BieI8pmqPA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">差异进化的突变。(图片由作者提供)。</p></figure><p id="1bfe" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">其中，<strong class="lc ir"> <em class="lb"> v </em> </strong>对应一个索引为<em class="lb"> i </em>的突变载体，<em class="lb"> r1 </em>、<em class="lb"> r2 </em>、<em class="lb"> r3 </em>为互不相同且与<em class="lb"> i </em>不同的三个索引。参数<em class="lb"> F </em>是用户自定义的控制参数，表示为<em class="lb">突变</em>参数或<em class="lb">比例因子</em>。</p><p id="69fe" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">一些策略可能会强制<em class="lb">开发</em>超过<em class="lb">探索</em>，这取决于如何选择父向量。加强<em class="lb">利用</em>的一种常用策略是最佳/1策略，其中基本向量对应于种群中具有最佳适应值的个体。根据我的经验，这种策略通常会导致过早收敛，这也是我通常避免这种策略的原因。</p><p id="39f6" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><em class="lb">开发</em>与<em class="lb">探索</em>之间的权衡也存在于<em class="lb">突变</em>参数<em class="lb"> F. </em>的选择中。例如，当需要强调<em class="lb">探索</em>时，例如在具有不连续决策空间的问题中，使用更高的值可能是有用的。相反，为了强调<em class="lb">利用</em>，使用较低的限制值可以改善结果。</p><p id="c6f5" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">此阶段通常执行的其他操作有<em class="lb">抖动</em>和<em class="lb">抖动</em>。<em class="lb">抖动</em>根据用户指定值的范围，为每个创建的突变向量单独随机化<em class="lb"> F </em>。一开始，一个好的选择可以是[0.3，1.0]。<em class="lb">抖动</em>将每个差向量的每个分量乘以一个随机值，从而加上旋转。</p><p id="8e28" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">最常见的<em class="lb">交叉</em>策略是<em class="lb">二项式交叉</em>或仅<em class="lb"> bin </em>，这在下面的等式中描述。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/51667eb436889c886b7865d53b26c0e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*HawI0-AqJcTvoujtb5KUPw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">差分进化中的二项式交叉。(图片由作者提供)。</p></figure><p id="8df6" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">其中<strong class="lc ir"><em class="lb"/></strong>对应于结合相应突变载体<strong class="lc ir"> <em class="lb"> v </em> </strong>和目标<strong class="lc ir"> <em class="lb"> x </em> </strong>的元素而创建的试验载体。参数<em class="lb"> CR </em>控制从每一个继承一个属性的概率，并且附加的规则规定<strong class="lc ir"><em class="lb"/></strong>的至少一个属性必须从<strong class="lc ir"> <em class="lb"> v </em> </strong>继承以避免重复。</p><p id="505b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">根据Price等人(2005)的观点，在低<em class="lb"> CR </em>值下表现良好的目标函数是可分解的——可以写成一维函数的和，而那些需要接近1的值的目标函数是不可分解的。Zaharie (2009)对差分进化算法中交叉算子的影响进行了详细的研究，我建议对算法细节感兴趣的人进一步阅读。</p><p id="79f9" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">以我的经验来看，大部分非线性现实问题都是不可分的，其中高<em class="lb"> CR </em>值，比如0.7-0.9，是个不错的选择。例外情况包括具有周期性项和强多模态的问题，其中沿着独立坐标轴的搜索可能是有利的。在这类问题中，选择0.2–0.5可能会产生更好的结果。</p><p id="f572" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">接下来让我们看一些应用。在我们的实现中，将使用来自<em class="lb"> scipy.optimize </em>的<em class="lb"> differential_evoluton </em>函数。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="8d0a" class="nm nn iq bd no np nq nr ns nt nu nv nw jw nx jx ny jz nz ka oa kc ob kd oc od bi translated">凸问题</h1><p id="0b3a" class="pw-post-body-paragraph kz la iq lc b ld oh jr lf lg oi ju li lw oj ll lm lx ok lp lq ly ol lt lu lv ij bi translated">在第一个例子中，让我们尝试在<a class="ae kv" rel="noopener" target="_blank" href="/nonlinear-programming-theory-and-applications-cfe127b6060c"> <em class="lb">上一篇文章</em> </a> <em class="lb">中使用的相同目标函数。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi om"><img src="../Images/0afa49453e4877aaf73541d6411765a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*EG1KLJuhqle9bGf8F9w2Dw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">凸问题的目标函数。(图片由作者提供)。</p></figure><p id="a429" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">用Python代码。</p><pre class="kg kh ki kj gt on oo op bn oq or bi"><span id="ede5" class="os nn iq oo b be ot ou l ov ow"># Defining the objective function<br/>def obj_fun(x):<br/>    return (x[0] - 0.5) ** 2 + 0.7 * x[0] * x[1]\<br/>        + 1.2 * (x[1] + 0.7) ** 2<br/><br/># Defining the gradient function<br/>def gradient_fun(x):<br/>    return np.array([2 * (x[0] - 0.5) + 0.7 * x[1],\<br/>        0.7 * x[0] + 2 * 1.2 * (x[1] + 0.7)])</span></pre><p id="4d29" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">看起来像这样。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/d99a557028990855424a141b7ce44d5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m8QMVLG1DzSR4UEJ1tnChA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">决策空间与凸问题的真最优。(图片由作者提供)。</p></figure><p id="75a6" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们将使用<em class="lb">拟牛顿BFGS </em>方法和DE来解决这个问题。</p><pre class="kg kh ki kj gt on oo op bn oq or bi"><span id="9d61" class="os nn iq oo b be ot ou l ov ow"># Optimization using BFGS (gradient-based method)<br/>sol_cvx = minimize(obj_fun, [2.5, 0.0], jac=gradient_fun,<br/>                   method="BFGS")<br/><br/># Otimization using Differential Evolution<br/>sol_de = differential_evolution(<br/>    obj_fun,<br/>    bounds=[(-5., 5.), (-5., 5.)],<br/>    popsize=50, strategy="rand1bin",<br/>    mutation=(0.3, 1.0),<br/>    recombination=0.7,<br/>    tol=1e-8,<br/>    maxiter=200,<br/>    updating="deferred",<br/>    polish=False<br/>)</span></pre><p id="61ba" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">请注意，第一个区别是指定决策变量的界限，而不是初始估计值<em class="lb"> x0 </em>。这些界限用于创建初始群体。</p><p id="928c" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">自变量<em class="lb"> popsize </em>对应于<em class="lb"> N </em>人口数量；<em class="lb">策略</em>为DE/x/y/z策略；<em class="lb">突变</em>为<em class="lb"> F </em>参数；<em class="lb">重组</em>到<em class="lb">CR</em>；<em class="lb"> tol </em>对停止准则方面的改进；和<em class="lb"> maxiter </em>到最大代数。通过将<em class="lb">上升</em>设置为“延迟”，我选择使用最初的策略，即每一代只更新当前群体一次。参数<em class="lb"> polish </em>定义了在当前最佳解决方案的每次迭代中是否使用局部优化器，我选择不使用。</p><p id="13f6" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在真正的最优解中，这些解基本上是重叠的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/a9fa3be283f9708a7a0f697167935772.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6WQi6EYes9ohZ0dG3Yl8Ug.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">凸问题的结果。(图片由作者提供)。</p></figure><p id="1e72" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">主要缺点是DE使用50的种群大小花费了56代来收敛，因此它进行了几个目标函数评估，这可能是计算上昂贵的。相反，<em class="lb"> BFGS </em>进行了6次迭代和7次函数评估。</p><p id="6c0c" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">理解问题是至关重要的，这样选择的算法才是有效的，而不会导致不必要的函数计算。在第一个问题中，基于凸梯度的算法显然是比DE更有效的选择，尽管两者导致完全相同的最终结果。</p><p id="70d2" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">让我们看看它会如何改变…</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="7e68" class="nm nn iq bd no np nq nr ns nt nu nv nw jw nx jx ny jz nz ka oa kc ob kd oc od bi translated">多模态问题</h1><p id="37f6" class="pw-post-body-paragraph kz la iq lc b ld oh jr lf lg oi ju li lw oj ll lm lx ok lp lq ly ol lt lu lv ij bi translated">如果搜索空间有几个局部最优怎么办？基于凸梯度的算法是局部搜索方法，因此它们很可能陷入这些点。当局部最优不够时，差分进化是一个更有效的工具。</p><p id="5f4c" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">让我们给我们的目标函数添加一些多模态术语。</p><pre class="kg kh ki kj gt on oo op bn oq or bi"><span id="2177" class="os nn iq oo b be ot ou l ov ow"># In the nonconvex problem we add some periodical terms<br/>def obj_fun_2(x):<br/>    A = np.array([[1, 0.3],<br/>                 [0.3, 0.7]])<br/>    xt = x.dot(A)<br/>    rugosity_1 = (xt[0] * np.sin(15 * xt[0]) - 0.5) ** 2\<br/>        + (xt[1] * np.sin(15 * xt[1]) - 2) ** 2<br/>    rugosity_2 = np.sin(15 * x[0]) ** 2 + np.sin(25 * x[1]) ** 2<br/>    convex = obj_fun(x)<br/>    return 5 * rugosity_2 + rugosity_1 + convex</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/a2033fef9bad6a339a9e665b4ad12517.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HIpbb2QUVb_UGA5U6Anlhg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">非凸例子。(图片由作者提供)。</p></figure><p id="3182" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我觉得这张图片很漂亮，尽管相当混乱，而且基于梯度的搜索方向肯定不会带我们去任何地方。让我们试着解决这个问题来看看。</p><pre class="kg kh ki kj gt on oo op bn oq or bi"><span id="abbb" class="os nn iq oo b be ot ou l ov ow">sol_cvx_2 = minimize(obj_fun_2, [2.5, 0.0], method="BFGS")<br/><br/>sol_de_2 = differential_evolution(<br/>    obj_fun_2,<br/>    bounds=[(-5., 5.), (-5., 5.)],<br/>    popsize=50, strategy="rand1bin",<br/>    mutation=(0.2, 1.0),<br/>    recombination=0.7,<br/>    tol=1e-8, maxiter=200,<br/>    updating="deferred", polish=False)</span></pre><p id="98aa" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">使用预先指定的初始估计，<em class="lb"/>已经实现了12.12的目标函数，比DE实现的1.613差得多(这很可能是全局最优)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/d6a39a286359582f619633d07dbf72b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S49ST2KTV9QjSRiVt-c34Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">非凸问题的结果。(图片由作者提供)。</p></figure><p id="0eb1" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们可以尝试几种不同的初始估计，在二维问题中，可能会导致我们满意的结果。在这个问题中，我尝试了500种不同的初始估计，得到的最高结果是1.855。然而，高维搜索空间的稀疏性使得这样的过程非常无效。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="e6a4" class="nm nn iq bd no np nq nr ns nt nu nv nw jw nx jx ny jz nz ka oa kc ob kd oc od bi translated">工程压力容器设计</h1><p id="cd38" class="pw-post-body-paragraph kz la iq lc b ld oh jr lf lg oi ju li lw oj ll lm lx ok lp lq ly ol lt lu lv ij bi translated">下一个问题由Sandgren (1990)提出，它使压力容器设计的成本最小化。由于材料供应标准，该问题有两个离散变量<em class="lb"> x1 </em>和<em class="lb"> x2 </em>，因此在其原始公式中是不可微的。然而，在本节中，我们将首先解决问题的连续实值变体，然后解决原问题。</p><p id="d348" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">目标函数由下面的等式描述。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/b4cf7398955b42f7d2653ecb9c820652.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lj-7t51GyIqPr4EcVvFQIg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">压力容器设计的目标函数。(图片由作者提供)。</p></figure><p id="8b0f" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">和边界约束由下面的等式来表示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/9773d45092aae828bb0110746b9655bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*dyZhYPEd_8_K45suqfx2QA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">压力容器设计的功能限制。(图片由作者提供)。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/5856d3ecc2f2ebdcdab1b463672835a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:392/format:webp/1*wSgYbgzeebHZgbxqeIZRWg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">压力容器设计的界限。(图片由作者提供)。</p></figure><p id="0618" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">用Python代码。</p><pre class="kg kh ki kj gt on oo op bn oq or bi"><span id="5ad3" class="os nn iq oo b be ot ou l ov ow">def f_vessel(x):<br/>    return 0.6224 * x[0] * x[2] * x[3]\<br/>        + 1.7781 * x[1] * x[2] ** 2\<br/>        + 3.1611 * x[0] ** 2 * x[3]\<br/>        + 19.84 * x[0] ** 2 * x[2]<br/><br/>def c1_vessel(x):<br/>    return - (0.0193 * x[2] - x[0])<br/><br/>def c2_vessel(x):<br/>    return - (0.00954 * x[2] - x[1])<br/><br/>def c3_vessel(x):<br/>    return - (750 * 1728 - \<br/>        np.pi * x[2] ** 2 * x[3]\<br/>        - 4/3 * np.pi * x[2] ** 3)</span></pre><p id="b8d1" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">第一次尝试是使用<em class="lb"> SLSQP </em>解决问题。注意，我提到了目标函数的梯度，我已经在示例笔记本中实现了。这里我决定省略这些定义，因为它们太长了。</p><pre class="kg kh ki kj gt on oo op bn oq or bi"><span id="0039" class="os nn iq oo b be ot ou l ov ow">sol_cvx_vessel = minimize(<br/>    f_vessel, [2, 2, 50, 50],<br/>    jac=grad_vessel,<br/>    bounds=bounds_vessel,<br/>    constraints=cons_vessel,<br/>    method="SLSQP"<br/>)</span></pre><p id="3647" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">不幸的是，由于第三个约束的非线性性质，<em class="lb"> SLSQP </em>无法找到合适的解决方案。</p><pre class="kg kh ki kj gt on oo pc pd aw pe bi"><span id="4c69" class="pf nn iq oo b gy pg ph l pi ow">message: 'Positive directional derivative for linesearch'</span></pre><p id="0ac8" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">然而，差分进化算法并不是解决连续变量问题的唯一合适算法… <em class="lb">信赖域</em>方法也是<em class="lb">线搜索</em>方法的替代方法，两者都使用在由某个规则定义的搜索方向上迭代地采取步骤的概念。并且两者都可以使用梯度信息来定义搜索方向。这可以通过仅仅改变<em class="lb">方法</em>参数来完成。这将导致一个可行点，具有很大的目标函数值。</p><pre class="kg kh ki kj gt on oo op bn oq or bi"><span id="d298" class="os nn iq oo b be ot ou l ov ow">sol_tr_vessel = minimize(<br/>    f_vessel, [2, 2, 50, 50],<br/>    jac=grad_vessel,<br/>    bounds=bounds_vessel,<br/>    constraints=cons_vessel,<br/>    method="trust-constr"<br/>)</span></pre><p id="70d1" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">现在，让我们实现DE，看看它的性能如何。</p><pre class="kg kh ki kj gt on oo op bn oq or bi"><span id="98d0" class="os nn iq oo b be ot ou l ov ow">sol_de_vessel = differential_evolution(<br/>    f_vessel, bounds=bounds_vessel,<br/>    constraints=cons_vessel,<br/>    popsize=50, strategy="rand1bin",<br/>    recombination=0.7, mutation=(0.3, 1.0),<br/>    maxiter=300, seed=12,<br/>    init='latinhypercube', polish=False<br/>)</span></pre><p id="d013" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">虽然找到了可行解，但是DE(没有finding)并不能产生低至<em class="lb">trust-const</em>的目标函数值，仍然取了更多的函数调用。</p><p id="e261" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">因此，在DE之前尝试其他<em class="lb">凸</em>算法仍然是有用的，特别是如果没有多模态或不可微项的证据。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="8c81" class="nm nn iq bd no np nq nr ns nt nu nv nw jw nx jx ny jz nz ka oa kc ob kd oc od bi translated">添加离散变量</h1><p id="d996" class="pw-post-body-paragraph kz la iq lc b ld oh jr lf lg oi ju li lw oj ll lm lx ok lp lq ly ol lt lu lv ij bi translated">增加离散变量使得这个问题不可微。因此，在这种情况下，预期DE是必要的。使用基于树的模型来映射目标函数的情况在实践中并不罕见。这些也是不可微的问题，DE为解决它们提供了一个有用的选择。</p><p id="281b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">让我们修改我们的目标函数，它将连续的实变量<em class="lb"> x1 </em>和<em class="lb"> x2 </em>解释为0.0625的离散倍数。</p><pre class="kg kh ki kj gt on oo op bn oq or bi"><span id="d2ca" class="os nn iq oo b be ot ou l ov ow">def integer_x(x):<br/>    x[0] = int(x[0] / 0.0625 + 1) * 0.0625<br/>    x[1] = int(x[1] / 0.0625 + 1) * 0.0625<br/>    return x<br/><br/>def f_vessel_minlp(x):<br/>    x = integer_x(x)<br/>    return f_vessel(x)</span></pre><p id="aed9" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">以及实施…</p><pre class="kg kh ki kj gt on oo op bn oq or bi"><span id="ae33" class="os nn iq oo b be ot ou l ov ow">sol_de_minlp = differential_evolution(<br/>    f_vessel_minlp, bounds=bounds_vessel,<br/>    constraints=cons_vessel,<br/>    popsize=50, strategy="rand1bin",<br/>    recombination=0.7, mutation=(0.3, 1.0),<br/>    maxiter=300, seed=12,<br/>    init='latinhypercube', tol=1e-8, polish=False,<br/>)</span></pre><p id="61f9" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这与Lampinen &amp; Storn (2004)报告的结果完全相同，因此可以认为是成功的。</p><pre class="kg kh ki kj gt on oo pc pd aw pe bi"><span id="4153" class="pf nn iq oo b gy pg ph l pi ow">constr_violation: 0.0<br/>fun: 7197.731584692868<br/>Real x: [ 1.125       0.625      58.29011889 43.69286662]</span></pre></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="7a65" class="nm nn iq bd no np nq nr ns nt nu nv nw jw nx jx ny jz nz ka oa kc ob kd oc od bi translated">进一步阅读</h1><p id="0b3c" class="pw-post-body-paragraph kz la iq lc b ld oh jr lf lg oi ju li lw oj ll lm lx ok lp lq ly ol lt lu lv ij bi translated">差分进化是众多基于种群的<em class="lb">算法中的一种，这种算法在解决优化问题时非常有效。我建议感兴趣的读者探索<em class="lb">粒子群优化</em>和<em class="lb">遗传算法</em>作为两个强大的替代方案。</em></p><p id="eadb" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">此外，在本文中，我们已经看到了差分进化算法在单目标问题中的一些应用。但是如果我们追求多个相互冲突的目标呢？DE有几个扩展来处理<em class="lb">多目标</em>优化，在这些情况下非常有用。感兴趣的人会发现python库<em class="lb"> pymoode </em>非常有用。在另一篇媒体文章中有一个概述:</p><div class="mn mo gp gr mp mq"><a rel="noopener follow" target="_blank" href="/pymoode-differential-evolution-in-python-78e4221e5cbe"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd ir gy z fp mv fr fs mw fu fw ip bi translated">pymoode:Python中的差异进化</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">用差分进化算法求解单目标和多目标优化问题</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">towardsdatascience.com</p></div></div><div class="mz l"><div class="pj l nb nc nd mz ne kp mq"/></div></div></a></div></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="9e1f" class="nm nn iq bd no np nq nr ns nt nu nv nw jw nx jx ny jz nz ka oa kc ob kd oc od bi translated">结论</h1><p id="e650" class="pw-post-body-paragraph kz la iq lc b ld oh jr lf lg oi ju li lw oj ll lm lx ok lp lq ly ol lt lu lv ij bi translated">在本文中，使用<em class="lb"> scipy </em>实现，用实际的实现例子解释和说明了差分进化的基本理论方面。提出了凸的、多峰的和不可微的问题，其中DE与其他优化方法相比具有其性能。所使用的代码在这个<a class="ae kv" href="https://github.com/bruscalia/optimization-demo-files/blob/main/nonconvex/de_scipy.ipynb" rel="noopener ugc nofollow" target="_blank"> GIT </a>资源库中对读者完全可用。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="b7bf" class="nm nn iq bd no np nq nr ns nt nu nv nw jw nx jx ny jz nz ka oa kc ob kd oc od bi translated">参考</h1><p id="7585" class="pw-post-body-paragraph kz la iq lc b ld oh jr lf lg oi ju li lw oj ll lm lx ok lp lq ly ol lt lu lv ij bi translated">Bilal等人，2020年。二十多年研究的回顾。英国工程师。应用程序Artif。智能。，第90卷，第103479页。</p><p id="3115" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">Lampinen，2002年。差分进化算法的约束处理方法。2002年进化计算大会会议录。CEC'02，第2卷，第1468–1473页。</p><p id="ddd1" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">兰皮宁，j .和斯托恩，r .，2004年。差异进化。<em class="lb">工程中的新优化技术。柏林，海德堡:施普林格出版社，第123-166页。</em></p><p id="994b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">普莱斯，K. V .，Storn，R. M .和Lampinen，J. A .，2005年。差分进化:一种实用的全局优化方法。第1版。柏林。</p><p id="ad80" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">桑德格伦，1990年。机械设计优化中的非线性整数和离散规划。<em class="lb">《机械设计学报》，</em> 112(2)，第223–229页。</p><p id="dd0f" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">storn r .和Price k .，1997年。差分进化——连续空间全局优化的简单有效的启发式算法。<em class="lb"> J。Optim。，</em>第11卷第4期，第359—341页。</p></div></div>    
</body>
</html>