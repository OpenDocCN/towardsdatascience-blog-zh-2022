<html>
<head>
<title>Plotting Bar Charts in BigQuery Using a SQL User Defined Function (UDF)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 SQL 用户定义函数在 BigQuery 中绘制条形图(UDF)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/plotting-bar-charts-in-bigquery-using-a-sql-user-defined-function-udf-ca6056aac680#2022-03-15">https://towardsdatascience.com/plotting-bar-charts-in-bigquery-using-a-sql-user-defined-function-udf-ca6056aac680#2022-03-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8c71" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">最大限度地减少上下文切换，加快工作流程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0d7957b11f308596f07cb37edb2a368a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gl9cClAr_ys1jSDD"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@chaseelliottclark?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Chase Clark </a>拍摄的照片</p></figure><p id="6e0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有许多令人敬畏的新工具旨在为 SQL 工作流带来更多的交互性、可视化、协作和共享:<a class="ae ky" href="https://hex.tech/" rel="noopener ugc nofollow" target="_blank"> HEX </a>、<a class="ae ky" href="https://count.co/" rel="noopener ugc nofollow" target="_blank"> Count </a>和<a class="ae ky" href="https://www.hyperquery.ai/" rel="noopener ugc nofollow" target="_blank"> Hyperquery </a>是三个很好的例子。</p><p id="782d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但有时你只想专注于在一个基本的控制台上工作，用一些额外的功能来帮助加快你的洞察力和工作流程。我喜欢将 BigQuery 查询编辑器想象成类似于命令行记事本——您可以使用数据定义语言(<a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language" rel="noopener ugc nofollow" target="_blank"> DDL </a>)使用类似命令行的功能，但是比命令行更加灵活。</p><p id="5311" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将解释如何使用纯 SQL 构建一个条形图，然后将它打包成一个简单的函数，您可以在数据探索中使用它。我们将通过将函数构建为简单的脚本查询来开始这个过程，并一步一步地添加到查询中，直到我们有一个工作的、有用的函数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5f19" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">输入</h1><p id="5fa7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们要做的第一件事是考虑我们想要传递给函数的输入，因为这决定了它将如何工作。SQL 中的脚本和函数开发可能有点不直观，所以最好的方法是从最简单的版本开始，然后根据需要变得更复杂。</p><p id="bc67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我希望我的函数接受一个数值，并返回字符串中的确切字符数。我不想限制太多，所以我将接受整数<em class="mz">或</em>浮点数，在这个简单的例子中，我想将它们限制为正数，这样我就不需要处理移动轴或其他复杂的东西。</p><p id="2cf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我将这些输入声明为变量，需要在任何 BigQuery 脚本的开头声明。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="b712" class="nf md it nb b gy ng nh l ni nj">DECLARE input_value FLOAT64;<br/>DECLARE character STRING;</span></pre><p id="df29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，因为我在测试这个函数，所以我要用一些测试值来初始化它们。这意味着对于我的函数的输出，我想要一个包含 100 个竖线的字符串。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="0a26" class="nf md it nb b gy ng nh l ni nj">DECLARE input_value FLOAT64 DEFAULT 100;<br/>DECLARE character STRING DEFAULT "|";</span></pre><p id="c9e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，从哪里开始？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c21b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">方法</h1><p id="fa50" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，我想强调几件事:</p><ul class=""><li id="bdc6" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">您可以在用户定义的函数(UDF)中编写 SQL，只要它返回标量值(即它不能返回许多行和列，它需要是单个值)。实际上，您可以通过使用结构和数组聚合来解决这个问题，但是在这种情况下，我们并不要求这样做。</li><li id="6bfe" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">您应该使用公共表表达式(cte)来编写 SQL，因为它使您的代码更具可读性，更易于理解、调试和扩展。好的代码应该清晰地传达逻辑，不要让读者感到困惑。</li><li id="7b16" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">您可以在 SQL 脚本中使用可以在查询中引用的变量，但是在编写本文时，您不能将其保存为视图。但是，您可以在 UDF 中使用变量，这些变量将作为参数传递给函数。</li></ul><p id="690c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还要注意，所有代码块都可以在您的控制台中复制和执行。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="efe0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">构建查询</h1><p id="4d51" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我要做的第一件事是使用<a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/mathematical_functions#abs" rel="noopener ugc nofollow" target="_blank"> ABS </a>函数，确保负输入将被转换为正输入，并且不会产生错误。将来我可能想做一些更聪明的事情，但是让我们从简单的开始。我将通过将默认的<strong class="lb iu">输入值</strong>更改为-100 来测试它的工作情况:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="c1c1" class="nf md it nb b gy ng nh l ni nj">DECLARE input_value FLOAT64 DEFAULT -100;<br/>DECLARE character STRING DEFAULT "|";</span><span id="2b95" class="nf md it nb b gy ny nh l ni nj">WITH <br/><strong class="nb iu">convert_input_to_positive AS (<br/>SELECT ABS(input_value)<br/>)</strong></span><span id="c804" class="nf md it nb b gy ny nh l ni nj">SELECT *<br/>FROM convert_input_to_positive</span></pre><p id="b874" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了，这个管用。现在我想创建 100 个字符，我最终可以将它们构建成一个字符串。我不能在 UDF 中使用像循环这样的控制结构，但是我可以使用数组，这可能有点难以理解，但是非常强大。为了从输入值生成一个数组，我将使用<a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/array_functions#generate_array" rel="noopener ugc nofollow" target="_blank"> GENERATE_ARRAY </a>函数，在 1 和我的输入值之间，步长为 1:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="94df" class="nf md it nb b gy ng nh l ni nj">DECLARE input_value FLOAT64 DEFAULT 100;<br/>DECLARE character STRING DEFAULT "|";</span><span id="9bb4" class="nf md it nb b gy ny nh l ni nj">WITH <br/>convert_input_to_positive AS (<br/>SELECT ABS(input_value) AS abs_input_value<br/>),</span><span id="4172" class="nf md it nb b gy ny nh l ni nj"><strong class="nb iu">generate_numbers_array AS (<br/>SELECT <br/>GENERATE_ARRAY(1, abs_input_value, 1) AS numbers_array<br/>FROM convert_input_to_positive<br/>)</strong></span><span id="fa5a" class="nf md it nb b gy ny nh l ni nj">SELECT *<br/>FROM generate_numbers_array</span></pre><p id="f01c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太棒了，我现在有一个 100 项的数组(包含升序数字)，但是由于我想将每个数组元素转换为一个字符(最终)，我需要访问每个元素，这意味着我需要取消数组嵌套。</p><p id="6622" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">UNNEST 有一点奇怪的语法，需要一点时间来适应，但是在处理嵌套结构时，这是一个基本的模式。这些在 Google Analytics 和 Firebase 数据中非常常见，因此值得考虑一下，尤其是在处理这些类型的数据源时。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="39d3" class="nf md it nb b gy ng nh l ni nj">DECLARE input_value FLOAT64 DEFAULT 100;<br/>DECLARE character STRING DEFAULT "|";</span><span id="cc31" class="nf md it nb b gy ny nh l ni nj">WITH <br/>convert_input_to_positive AS (<br/>SELECT ABS(input_value) AS abs_input_value<br/>),</span><span id="5771" class="nf md it nb b gy ny nh l ni nj">generate_numbers_array AS (<br/>SELECT <br/>GENERATE_ARRAY(1, abs_input_value, 1) AS numbers_array<br/>FROM convert_input_to_positive<br/>),</span><span id="8730" class="nf md it nb b gy ny nh l ni nj"><strong class="nb iu">unnest_numbers_array AS (<br/>SELECT numbers<br/>FROM generate_numbers_array <br/>CROSS JOIN UNNEST(numbers_array) AS numbers<br/>)</strong></span><span id="7475" class="nf md it nb b gy ny nh l ni nj">SELECT * <br/>FROM unnest_numbers_array</span></pre><p id="844b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以用左连接替换交叉连接(如果数据中可能有空值，这是更好的选择)，或者您也可以使用逗号作为隐式交叉连接，但我认为这可能会造成混乱，所以我更喜欢显式连接。</p><p id="1243" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前面的结果在一行中给出了一个数组，但是现在我有 100 行，所以我可以直接访问它们，并把它们转换成我需要的输出格式。可能有一百万种不同的方法可以做到这一点，但是因为我想要做的是将所有的行更改为相同的值，所以我将从使用非常方便的<a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/mathematical_functions#least" rel="noopener ugc nofollow" target="_blank"> LEAST </a>函数开始。这将返回较低的值(人们通常认为<a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/aggregate_functions#min" rel="noopener ugc nofollow" target="_blank"> MIN </a>会这样做，但这并不是这样，因为它是一个聚合函数。这是一种奇特的说法，它跨<em class="mz">行</em>，而不是列进行操作。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="eb10" class="nf md it nb b gy ng nh l ni nj">DECLARE input_value FLOAT64 DEFAULT 100;<br/>DECLARE character STRING DEFAULT "|";</span><span id="0d41" class="nf md it nb b gy ny nh l ni nj">WITH <br/>convert_input_to_positive AS (<br/>SELECT ABS(input_value) AS abs_input_value<br/>),</span><span id="5063" class="nf md it nb b gy ny nh l ni nj">generate_numbers_array AS (<br/>SELECT <br/>GENERATE_ARRAY(1, abs_input_value, 1) AS numbers_array<br/>FROM convert_input_to_positive<br/>),</span><span id="5d97" class="nf md it nb b gy ny nh l ni nj">unnest_numbers_array AS (<br/>SELECT numbers<br/>FROM generate_numbers_array <br/>CROSS JOIN UNNEST(numbers_array) AS numbers<br/>),</span><span id="725b" class="nf md it nb b gy ny nh l ni nj"><strong class="nb iu">set_all_numbers_to_ones AS (<br/>SELECT<br/>LEAST(1, numbers) AS ones<br/>FROM unnest_numbers_array<br/>)</strong></span><span id="0b01" class="nf md it nb b gy ny nh l ni nj">SELECT *<br/>FROM set_all_numbers_to_ones</span></pre><p id="3dbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是必需的，因为数组由 FLOAT64 数据类型组成，我想在下一步中用字符串替换它们。这意味着我需要<a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#cast" rel="noopener ugc nofollow" target="_blank">转换</a>值，但是我使用<a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#safe_casting" rel="noopener ugc nofollow" target="_blank"> SAFE_CAST </a>是因为这是一个好习惯。如果 CAST 遇到一个无法转换为目标类型的值，查询将失败，但是 SAFE_CAST 将简单地返回 NULL，查询将成功。</p><p id="06f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下不是绝对必要的，但仍然是一个好习惯。该查询的输出将是 100 行，每行包含数字 1 的字符串表示。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="0b35" class="nf md it nb b gy ng nh l ni nj">DECLARE input_value FLOAT64 DEFAULT 100;<br/>DECLARE character STRING DEFAULT "|";</span><span id="19aa" class="nf md it nb b gy ny nh l ni nj">WITH <br/>convert_input_to_positive AS (<br/>SELECT ABS(input_value) AS abs_input_value<br/>),</span><span id="c10c" class="nf md it nb b gy ny nh l ni nj">generate_numbers_array AS (<br/>SELECT <br/>GENERATE_ARRAY(1, abs_input_value, 1) AS numbers_array<br/>FROM convert_input_to_positive<br/>),</span><span id="0f60" class="nf md it nb b gy ny nh l ni nj">unnest_numbers_array AS (<br/>SELECT numbers<br/>FROM generate_numbers_array <br/>CROSS JOIN UNNEST(numbers_array) AS numbers<br/>),</span><span id="8b27" class="nf md it nb b gy ny nh l ni nj">set_all_numbers_to_ones AS (<br/>SELECT<br/>LEAST(1, numbers) AS ones<br/>FROM unnest_numbers_array<br/>),</span><span id="375d" class="nf md it nb b gy ny nh l ni nj"><strong class="nb iu">cast_all_numbers_to_strings AS (<br/>SELECT <br/>SAFE_CAST(ones AS STRING) AS ones_strings<br/>FROM set_all_numbers_to_ones<br/>)</strong></span><span id="fb6f" class="nf md it nb b gy ny nh l ni nj">SELECT *<br/>FROM cast_all_numbers_to_strings</span></pre><p id="d103" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我可以使用一个简单的<a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/conditional_expressions#case" rel="noopener ugc nofollow" target="_blank"> CASE </a>语句，用我的变量定义的字符替换字符串，我们就快完成了:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="e7b5" class="nf md it nb b gy ng nh l ni nj">DECLARE input_value FLOAT64 DEFAULT 100;<br/>DECLARE character STRING DEFAULT "|";</span><span id="2ff9" class="nf md it nb b gy ny nh l ni nj">WITH <br/>convert_input_to_positive AS (<br/>SELECT ABS(input_value) AS abs_input_value<br/>),</span><span id="7a99" class="nf md it nb b gy ny nh l ni nj">generate_numbers_array AS (<br/>SELECT <br/>GENERATE_ARRAY(1, abs_input_value, 1) AS numbers_array<br/>FROM convert_input_to_positive<br/>),</span><span id="28fa" class="nf md it nb b gy ny nh l ni nj">unnest_numbers_array AS (<br/>SELECT numbers<br/>FROM generate_numbers_array <br/>CROSS JOIN UNNEST(numbers_array) AS numbers<br/>),</span><span id="9143" class="nf md it nb b gy ny nh l ni nj">set_all_numbers_to_ones AS (<br/>SELECT<br/>LEAST(1, numbers) AS ones<br/>FROM unnest_numbers_array<br/>),</span><span id="17dc" class="nf md it nb b gy ny nh l ni nj">cast_all_numbers_to_strings AS (<br/>SELECT <br/>SAFE_CAST(ones AS STRING) AS ones_strings<br/>FROM set_all_numbers_to_ones<br/>),</span><span id="942d" class="nf md it nb b gy ny nh l ni nj"><strong class="nb iu">replace_ones_with_specified_character AS (<br/>SELECT <br/>CASE WHEN ones_strings = '1' THEN character END AS characters<br/>FROM cast_all_numbers_to_strings<br/>)</strong></span><span id="37fd" class="nf md it nb b gy ny nh l ni nj">SELECT *<br/>FROM replace_ones_with_specified_character</span></pre><p id="25b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个技巧非常有用，尤其是如果您正在构建从各种<a class="ae ky" href="https://cloud.google.com/bigquery/docs/information-schema-intro" rel="noopener ugc nofollow" target="_blank">INFORMATION _ SCHEMA</a>big query 选项编写 SQL 的函数。本质上，您要将一个特定列中的所有值聚合到一个数组中，然后从所有数组元素创建一个字符串，但在一个空字符串上分隔。这将具有将一行中的值转换成水平连接的字符串的效果，这正是我们在这里试图实现的。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="0025" class="nf md it nb b gy ng nh l ni nj">DECLARE input_value FLOAT64 DEFAULT 100;<br/>DECLARE character STRING DEFAULT "|";</span><span id="953e" class="nf md it nb b gy ny nh l ni nj">WITH <br/>convert_input_to_positive AS (<br/>SELECT ABS(input_value) AS abs_input_value<br/>),</span><span id="c39a" class="nf md it nb b gy ny nh l ni nj">generate_numbers_array AS (<br/>SELECT <br/>GENERATE_ARRAY(1, abs_input_value, 1) AS numbers_array<br/>FROM convert_input_to_positive<br/>),</span><span id="f939" class="nf md it nb b gy ny nh l ni nj">unnest_numbers_array AS (<br/>SELECT numbers<br/>FROM generate_numbers_array <br/>CROSS JOIN UNNEST(numbers_array) AS numbers<br/>),</span><span id="281d" class="nf md it nb b gy ny nh l ni nj">set_all_numbers_to_ones AS (<br/>SELECT<br/>LEAST(1, numbers) AS ones<br/>FROM unnest_numbers_array<br/>),</span><span id="51e1" class="nf md it nb b gy ny nh l ni nj">cast_all_numbers_to_strings AS (<br/>SELECT <br/>SAFE_CAST(ones AS STRING) AS ones_strings<br/>FROM set_all_numbers_to_ones<br/>),</span><span id="8e88" class="nf md it nb b gy ny nh l ni nj">replace_ones_with_specified_character AS (<br/>SELECT <br/>CASE WHEN ones_strings = '1' THEN character END AS characters<br/>FROM cast_all_numbers_to_strings<br/>),</span><span id="1139" class="nf md it nb b gy ny nh l ni nj"><strong class="nb iu">aggregate_characters_into_array AS (<br/>SELECT ARRAY_AGG(characters) AS characters_array<br/>FROM replace_ones_with_specified_character<br/>),</strong></span><span id="6fd9" class="nf md it nb b gy ny nh l ni nj"><strong class="nb iu">convert_array_to_string AS (<br/>SELECT ARRAY_TO_STRING(characters_array, "") AS bar<br/>FROM aggregate_characters_into_array<br/>)</strong></span><span id="3bad" class="nf md it nb b gy ny nh l ni nj">SELECT bar<br/>FROM convert_array_to_string</span></pre><p id="64d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些通常会合并到一个步骤中，但是为了清晰和一致，我将它们分开。执行这段代码，您将看到长度为 100 的单个条被写入控制台中的查询结果。太棒了。</p><p id="cce7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我到底该怎么用它呢？我不想为了绘制一个单行条形图而不得不重新复制这段代码！</p><p id="f794" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再走一步，我们就可以把它简化成一行代码和一个可移植的、可重用的函数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9d41" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">打包成用户定义的函数(UDF)</h1><p id="3b50" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">将查询转换成 UDF 非常简单，因为我们已经定义了参数名称和数据类型，并且查询返回一个标量值。</p><p id="d925" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只需要使用 CREATE[或 REPLACE]函数语法，定义输入参数，并确保将 SQL 查询放在双括号中，因为它是一个<a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/subqueries#scalar_subquery_concepts" rel="noopener ugc nofollow" target="_blank">标量子查询</a>:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="def2" class="nf md it nb b gy ng nh l ni nj"><strong class="nb iu">CREATE OR REPLACE FUNCTION flowfunctions.plot.bar(<br/>input_value FLOAT64, character STRING<br/>)<br/>AS ((</strong></span><span id="e633" class="nf md it nb b gy ny nh l ni nj">WITH <br/>convert_input_to_positive AS (<br/>SELECT ABS(input_value) AS abs_input_value<br/>),</span><span id="0e25" class="nf md it nb b gy ny nh l ni nj">generate_numbers_array AS (<br/>SELECT <br/>GENERATE_ARRAY(1, abs_input_value, 1) AS numbers_array<br/>FROM convert_input_to_positive<br/>),</span><span id="4d45" class="nf md it nb b gy ny nh l ni nj">unnest_numbers_array AS (<br/>SELECT numbers<br/>FROM generate_numbers_array <br/>CROSS JOIN UNNEST(numbers_array) AS numbers<br/>),</span><span id="f5b9" class="nf md it nb b gy ny nh l ni nj">set_all_numbers_to_ones AS (<br/>SELECT<br/>LEAST(1, numbers) AS ones<br/>FROM unnest_numbers_array<br/>),</span><span id="5da1" class="nf md it nb b gy ny nh l ni nj">cast_all_numbers_to_strings AS (<br/>SELECT <br/>SAFE_CAST(ones AS STRING) AS ones_strings<br/>FROM set_all_numbers_to_ones<br/>),</span><span id="b1f1" class="nf md it nb b gy ny nh l ni nj">replace_ones_with_specified_character AS (<br/>SELECT <br/>CASE WHEN ones_strings = '1' THEN character END AS characters<br/>FROM cast_all_numbers_to_strings<br/>),</span><span id="81c0" class="nf md it nb b gy ny nh l ni nj">aggregate_characters_into_array AS (<br/>SELECT ARRAY_AGG(characters) AS characters_array<br/>FROM replace_ones_with_specified_character<br/>),</span><span id="8faf" class="nf md it nb b gy ny nh l ni nj">convert_array_to_string AS (<br/>SELECT ARRAY_TO_STRING(characters_array, "") AS bar<br/>FROM aggregate_characters_into_array<br/>)</span><span id="e201" class="nf md it nb b gy ny nh l ni nj">SELECT bar<br/>FROM convert_array_to_string<br/><strong class="nb iu">))</strong></span></pre><p id="008d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们结束了。运行此语句将创建函数，可以使用典型的 SELECT 语法调用该函数，并传递之前定义为变量的参数:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="ceff" class="nf md it nb b gy ng nh l ni nj">SELECT flowfunctions.plot.bar(100, "|")</span></pre><p id="fa6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且结果将与上面的完整查询相同！最好的一点是，您可以使用该函数快速直观地查看概要数据，因为将为每一行生成一个条形。请注意，这最适合 100(即百分比)以下的值，否则条形可能会超出屏幕。</p><p id="a6b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">试试这件，看看大小</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="2752" class="nf md it nb b gy ng nh l ni nj">SELECT <br/>animal, count,<br/>flowfunctions.plot.bar(count, '|') As count_bar<br/>FROM `flowfunctions.examples.zoo_animal_counts`</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/712ae7c2b84fe319e90fd53270f882ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*ReNrwGV_GK8wGW1YcSqKgQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个稍微琐碎的例子，但你得到了要点。</p></figure><p id="320a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，如果你想制作一个由大象(或任何其他<a class="ae ky" href="https://unicode.org/emoji/charts/full-emoji-list.html" rel="noopener ugc nofollow" target="_blank">表情符号</a>)组成的条，你可以简单地将它作为参数传递。我女儿喜欢大象。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="f4c4" class="nf md it nb b gy ng nh l ni nj">SELECT animal, count, <br/>flowfunctions.plot.bar(count, emoji) As count_bar<br/>FROM `flowfunctions.examples.zoo_animal_summary`</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/a7eb3746d1af1879f82eedb579f822fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U1vuxApGeiXsTnECvfiFnA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">好的，这很酷。</p></figure><p id="5fe3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个示例数据和函数应该可供美国地区的任何经过身份验证的 BigQuery 用户使用，所以请随意尝试(或者如果您在欧盟，请用<strong class="lb iu"> floweu </strong>替换<strong class="lb iu"> flowfunctions </strong>)，但是这个库正在积极开发中，因此可能随时发生变化。</p><p id="e1a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在您自己的项目中复制该函数，只需更新<strong class="lb iu">创建中的引用或将函数</strong>代码<strong class="lb iu"> </strong>替换为您的<strong class="lb iu"> project_id </strong>，确保数据集绘图存在于正确的区域中。</p><p id="3397" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="8911" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您觉得这(以及其他相关材料)有用和/或有趣，请跟我来！</p><p id="41d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您还不是会员，请加入 Medium<a class="ae ky" href="https://jim-barlow.medium.com/membership" rel="noopener">这个活跃、充满活力和激情的数据人社区，每月只需 5 美元，就能获得无限的故事。也有很多其他人，但是如果你对数据感兴趣，那么这里就是你要去的地方…</a></p></div></div>    
</body>
</html>