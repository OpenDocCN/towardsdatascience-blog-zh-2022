<html>
<head>
<title>How to Make Pandas Functions More Useful</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何让熊猫的功能更有用</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-make-pandas-functions-more-useful-25649f71cc21#2022-03-04">https://towardsdatascience.com/how-to-make-pandas-functions-more-useful-25649f71cc21#2022-03-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c8b4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">充分利用它。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b7f130b7bab9c0366f6d06c204b0fcc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bQoAPNyMo69x4UO0xWWm6A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">亚历杭德罗·皮涅罗·阿梅里奥在<a class="ae ky" href="https://unsplash.com/s/photos/useful?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="45fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas 可以说是数据科学生态系统中最常用的库。它的功能使复杂的数据清理和分析任务变得简单易行。</p><p id="552c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们经常使用熊猫功能的默认设置，这使我们无法充分利用它们。在大多数情况下，参数使函数更灵活或更强大。</p><p id="7761" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，通过正确使用参数，我们可以在一个步骤中完成一个包含多个步骤的任务。因此，我们的代码变得更加高效和干净。</p><p id="721a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将通过一些例子来展示使用参数的额外好处。让我们从导入库和创建示例数据帧开始。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d7d3" class="ma mb it lw b gy mc md l me mf">import pandas as pd<br/>import numpy as np<br/>import random</span><span id="25f7" class="ma mb it lw b gy mg md l me mf"># create a DataFrame with mock data<br/>pg = ["A","B","C","D","E","F","G"]<br/>sales = np.arange(1,1000)</span><span id="7e48" class="ma mb it lw b gy mg md l me mf">df = pd.DataFrame({</span><span id="2eed" class="ma mb it lw b gy mg md l me mf">"product_group":random.choices(pg, weights=[12,10,8,5,1,1,1],k=300),<br/>"product_code":np.arange(1000,1300),<br/>"sales_qty":random.choices(sales, k=300)</span><span id="a545" class="ma mb it lw b gy mg md l me mf">})</span><span id="bc81" class="ma mb it lw b gy mg md l me mf"># add some missing values<br/>df.loc[150:170, "product_group"] = np.nan<br/>df.loc[210:230, "sales_qty"] = np.nan</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/b07a80a2ed1f6579f44093a4e2fb00a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GS1FAetBshl07GsQz9rRLA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">df 前五行(图片由作者提供)</p></figure><p id="ee95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DataFrame 包含一些产品及其产品组，以及随机生成的销售数量值。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="25a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想要计算每组中产品的数量。最简单的方法是 value_counts 函数。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="fff4" class="ma mb it lw b gy mc md l me mf">df["product_group"].value_counts()</span><span id="3ce4" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu"># output</strong><br/>A    88<br/>B    69<br/>C    56<br/>D    37<br/>F    11<br/>E     9<br/>G     9<br/>Name: product_group, dtype: int64</span></pre><p id="24ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">product group 列中应该有一些缺失的值，但是我们在输出中看不到它们。原因是 value_counts 函数默认情况下会忽略缺失的值。</p><p id="75bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某些任务中忽略缺失值可能会产生误导。我们总是可以使用 isna 函数来检查丢失的值。然而，value_counts 函数能够为我们提供关于缺失值的信息。我们只需要使用<strong class="lb iu"> dropna </strong>参数。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="17fb" class="ma mb it lw b gy mc md l me mf">df["product_group"].value_counts(dropna=False)</span><span id="3595" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu"># output</strong><br/>A      88<br/>B      69<br/>C      56<br/>D      37<br/>NaN    21<br/>F      11<br/>E       9<br/>G       9<br/>Name: product_group, dtype: int64</span></pre><p id="a01b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有 21 种产品的产品组信息缺失。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="71a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们快速看一下上一个例子的输出。a 组有 88 个产品。</p><p id="0160" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">A 组拥有最多的产品，但是 A 在整个数据框架中的百分比份额是多少？我们可以用一个简单的数学运算来计算它，但是有一个更简单的方法:<strong class="lb iu">规范化</strong>参数。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="954d" class="ma mb it lw b gy mc md l me mf">df["product_group"].value_counts(normalize=True, dropna=False)</span><span id="8da6" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu"># output<br/></strong>A      0.293333<br/>B      0.230000<br/>C      0.186667<br/>D      0.123333<br/>NaN    0.070000<br/>F      0.036667<br/>E      0.030000<br/>G      0.030000<br/>Name: product_group, dtype: float64</span></pre><p id="b1b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">A 组占整个产品系列的 29%。</p><p id="e83f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">normalize 参数对于许多任务来说很方便。假设我们正在处理一项任务，并且希望只包含产品组，以涵盖整个产品系列的 75%。通过使用 value_counts 和 cumsum 函数，我们可以轻松找到范围内的产品组，如下所示:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b2ec" class="ma mb it lw b gy mc md l me mf">df["product_group"].value_counts(normalize=True).cumsum()</span><span id="4804" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu"># output<br/></strong>A    0.315412<br/>B    0.562724<br/>C    0.763441<br/>D    0.896057<br/>F    0.935484<br/>E    0.967742<br/>G    1.000000<br/>Name: product_group, dtype: float64</span></pre><p id="294a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有产品中的 76%属于产品组 A、B 或 c。您可能已经注意到百分比份额与上一个示例不同。原因是我们这次忽略了缺失的值。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="3f7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据数量对观察值(即行)进行排序是一项非常常见的任务，可以使用 Pandas 的 sort_values 函数来完成。让我们根据销售量对行进行降序排序。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="439a" class="ma mb it lw b gy mc md l me mf">df = df.sort_values(by="sales_qty", ascending=False)</span><span id="3e5f" class="ma mb it lw b gy mg md l me mf">df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/73affcd7c5611eaf5d9758fd28a89f2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WQWqwWfSlPIb1JeeCrPGzA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">df 前五行(图片由作者提供)</p></figure><p id="77d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">行被排序，但是它们的索引保持与原始数据帧中的相同。在许多情况下，这可能不是问题，但是有一个合适的索引总是更好。我们可以使用 reset_index 函数更新索引，但是 sort_values 函数有一个用于此任务的参数:<strong class="lb iu"> ignore_index </strong>。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="cf66" class="ma mb it lw b gy mc md l me mf">df = df.sort_values(by="sales_qty", ascending=False, ignore_index=True)</span><span id="eb98" class="ma mb it lw b gy mg md l me mf">df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/778019e711d00fc052adf61397954ab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sBMJzxSZ1b4Iiu_aa7vVHQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">df 前五行(图片由作者提供)</p></figure><p id="9b70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在看起来好多了。</p><blockquote class="mp mq mr"><p id="ec34" class="kz la ms lb b lc ld ju le lf lg jx lh mt lj lk ll mu ln lo lp mv lr ls lt lu im bi translated">组合多个数据帧的 concat 函数也有 ignore_index 参数。</p></blockquote></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="5a7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">groupby 是数据分析中最常用的 Pandas 函数之一。它根据给定列中的不同值对行进行分组。然后，我们可以计算每个组的合计值。</p><p id="82b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以计算每组的平均销售量，如下所示:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ef97" class="ma mb it lw b gy mc md l me mf">df.groupby("product_group").agg(avg_sales=("sales_qty","mean"))</span><span id="d7bf" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu"># output</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/910ae9446f3a92cdf8d39bd802f4d5e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*XhgpbKglNsEA2PZLVBzFMw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="a9d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出是数据帧，组显示为索引。但是，将组作为数据帧中的一列更好也更实用。当我们有嵌套组时(即，当按多列分组时)，这尤其有用。</p><p id="58a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用 reset_index 函数将索引中的组移到新列中。但是，groupby 函数为此提供了一个参数:<strong class="lb iu"> as_index </strong>。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="001d" class="ma mb it lw b gy mc md l me mf">df.groupby("product_group", as_index=False).agg(avg_sales=("sales_qty","mean"))</span><span id="fddc" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu"># output</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/b02dfa787a186ad04553a443961323cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*H836IiQcVd355_h-9aOp6A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="465d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我觉得现在好多了。稍后我们可能需要使用 group 列。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="a122" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经看到了一些改变函数行为的参数。它们帮助我们调整功能以更好地满足我们的需求或添加新功能。</p><p id="60b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几个参数使函数更加灵活、实用和有用。我强烈建议在使用函数之前检查参数。</p><p id="408e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ms">你可以成为</em> <a class="ae ky" href="https://sonery.medium.com/membership" rel="noopener"> <em class="ms">媒介会员</em> </a> <em class="ms">解锁我的全部写作权限，外加其余媒介。如果你已经是了，别忘了订阅</em><a class="ae ky" href="https://sonery.medium.com/subscribe" rel="noopener"><em class="ms"/></a><em class="ms">如果你想在我发表新文章时收到电子邮件。</em></p><div class="my mz gp gr na nb"><a href="https://sonery.medium.com/membership" rel="noopener follow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd iu gy z fp ng fr fs nh fu fw is bi translated">通过我的推荐链接加入 Medium-Soner yl DRM</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">sonery.medium.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np ks nb"/></div></div></a></div><p id="763a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。如果您有任何反馈，请告诉我。</p></div></div>    
</body>
</html>