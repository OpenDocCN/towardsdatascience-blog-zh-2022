<html>
<head>
<title>How to Compare Two or More Distributions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何比较两个或多个分布</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-compare-two-or-more-distributions-9b06ee4d30bf#2022-06-20">https://towardsdatascience.com/how-to-compare-two-or-more-distributions-9b06ee4d30bf#2022-06-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="3fbe" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/causal-data-science" rel="noopener" target="_blank">因果数据科学</a></h2><div class=""/><div class=""><h2 id="b037" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated"><em class="ko">比较分布的完整指南，从可视化到统计测试</em></h2></div><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/41cbdd9e8afb972a0d4c6e1a1c5439c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kr6hYPO1vXvrSnDMTIQBlQ.jpeg"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">封面图片，由作者使用<a class="ae lf" href="https://creator.nightcafe.studio/" rel="noopener ugc nofollow" target="_blank">nightcafe</a>生成</p></figure><p id="ccb8" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">比较变量在不同组中的经验分布是数据科学中的一个常见问题。特别是，在因果推断中，当我们不得不<strong class="li ja">评估随机化的质量</strong>时，问题经常出现。</p><p id="357e" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">当我们想要评估一项政策(或UX特色、广告活动、药物……)的因果效应时，因果推断的黄金标准是<a class="ae lf" href="https://en.wikipedia.org/wiki/Randomized_controlled_trial" rel="noopener ugc nofollow" target="_blank"><strong class="li ja"/></a>随机对照试验，也称为<a class="ae lf" href="https://de.wikipedia.org/wiki/A/B-Test" rel="noopener ugc nofollow" target="_blank"> <strong class="li ja"> A/B测试</strong> </a>。在实践中，我们选择一个样本进行研究，并将其随机分为<strong class="li ja">对照组</strong>和<strong class="li ja">治疗组</strong>，并比较两组之间的结果。随机化确保两组之间的唯一差异是平均治疗，因此我们可以将结果差异归因于治疗效果。</p><p id="dbf4" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">T21的问题是，尽管进行了随机分组，两组人永远不会完全相同。然而，有时候，他们甚至不“相似”。例如，我们可能在一个群体中有更多的男性，或者老年人，等等..(我们通常称这些特征为<em class="mc">协变量</em>或<em class="mc">控制变量</em>)。当这种情况发生时，我们不能再确定结果的差异仅仅是由于治疗，而不是由于<strong class="li ja">不平衡的协变量</strong>。因此，在随机化之后，检查所有观察到的变量在各组之间是否平衡以及是否没有系统性差异总是很重要的。另一个选择是<a class="ae lf" href="https://en.wikipedia.org/wiki/Stratified_sampling" rel="noopener ugc nofollow" target="_blank">分层抽样</a>，为了事先确定某些协变量是平衡的。</p><p id="3b94" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">在这篇博文中，我们将看到比较两个(或更多)分布的不同方法，并评估它们之间差异的大小和重要性。我们将考虑两种不同的方法，<strong class="li ja">视觉</strong>和<strong class="li ja">统计</strong>。这两种方法通常在<strong class="li ja">直觉</strong>和<strong class="li ja">严谨</strong>之间进行权衡:从图中，我们可以快速评估和探索差异，但很难判断这些差异是系统性的还是由噪声造成的。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="5dce" class="mk ml iq bd mm mn mo mp mq mr ms mt mu kf mv kg mw ki mx kj my kl mz km na nb bi translated">例子</h1><p id="b477" class="pw-post-body-paragraph lg lh iq li b lj nc ka ll lm nd kd lo lp ne lr ls lt nf lv lw lx ng lz ma mb ij bi translated">让我们假设我们需要对一组个体进行一项实验，我们已经将他们随机分成了T21治疗组和对照组。我们希望它们尽可能具有可比性，以便将两组之间的任何差异仅归因于治疗效果。我们还将治疗组分成不同的<em class="mc">组</em>，用于测试不同的治疗方法(例如同一药物的微小变化)。</p><p id="e760" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">对于这个例子，我模拟了一个1000人的数据集，我们观察到他们的一系列特征。我从<code class="fe nh ni nj nk b"><a class="ae lf" href="https://github.com/matteocourthoud/Blog-Posts/blob/main/notebooks/src/dgp.py" rel="noopener ugc nofollow" target="_blank">src.dgp</a></code>导入数据生成过程<code class="fe nh ni nj nk b">dgp_rnd_assignment()</code>，从<code class="fe nh ni nj nk b"><a class="ae lf" href="https://github.com/matteocourthoud/Blog-Posts/blob/main/notebooks/src/utils.py" rel="noopener ugc nofollow" target="_blank">src.utils</a></code>导入一些绘图函数和库。</p><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="5748" class="np ml iq nk b gy nq nr l ns nt">from src.utils import *<br/>from src.dgp import dgp_rnd_assignment<br/><br/>df = dgp_rnd_assignment().generate_data()<br/>df.head()</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nu"><img src="../Images/e6de58508dbc278d82a87fecf6acaeee.png" data-original-src="https://miro.medium.com/v2/format:webp/1*HBrr7YDQoStJuElXvKah-A.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">数据快照，图片由作者提供</p></figure><p id="fbc5" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们有1000个人的信息，为此我们观察<code class="fe nh ni nj nk b">gender</code>、<code class="fe nh ni nj nk b">age</code>和每周<code class="fe nh ni nj nk b">income</code>。每个个体被分配到治疗组或对照组<code class="fe nh ni nj nk b">group</code>，接受治疗的个体被分配到四个治疗组<code class="fe nh ni nj nk b">arms</code>。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="6369" class="mk ml iq bd mm mn mo mp mq mr ms mt mu kf mv kg mw ki mx kj my kl mz km na nb bi translated">两组——地块</h1><p id="430c" class="pw-post-body-paragraph lg lh iq li b lj nc ka ll lm nd kd lo lp ne lr ls lt nf lv lw lx ng lz ma mb ij bi translated">让我们从最简单的设置开始:我们想要比较<code class="fe nh ni nj nk b">treatment</code>和<code class="fe nh ni nj nk b">control</code>组的收入分布。我们首先探索<strong class="li ja">视觉</strong>方法，然后<strong class="li ja">统计</strong>方法。第一个的优势是<strong class="li ja">直觉</strong>而第二个的优势是<strong class="li ja">严谨</strong>。</p><p id="4fdf" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">对于大多数可视化，我将使用Python的<code class="fe nh ni nj nk b"><a class="ae lf" href="https://seaborn.pydata.org/" rel="noopener ugc nofollow" target="_blank">seaborn</a></code>库。</p><h2 id="3ae7" class="np ml iq bd mm nv nw dn mq nx ny dp mu lp nz oa mw lt ob oc my lx od oe na iw bi translated">箱线图</h2><p id="9e44" class="pw-post-body-paragraph lg lh iq li b lj nc ka ll lm nd kd lo lp ne lr ls lt nf lv lw lx ng lz ma mb ij bi translated">第一种视觉方法是<a class="ae lf" href="https://en.wikipedia.org/wiki/Box_plot" rel="noopener ugc nofollow" target="_blank"> <strong class="li ja">箱线图</strong> </a>。箱线图是汇总统计和数据可视化之间的一个很好的折衷。<strong class="li ja">框</strong>的中心代表<em class="mc">中位数</em>，而边界分别代表第一(Q1)和第三<a class="ae lf" href="https://en.wikipedia.org/wiki/Quartile" rel="noopener ugc nofollow" target="_blank">四分位数</a> (Q3)。相反,<strong class="li ja">须状物</strong>延伸到框外超过1.5倍<em class="mc">四分位数间距</em> (Q3 — Q1)的第一个数据点。胡须外的点被单独标绘，通常被认为是<a class="ae lf" href="https://en.wikipedia.org/wiki/Outlier" rel="noopener ugc nofollow" target="_blank"> <strong class="li ja">异常值</strong> </a>。</p><p id="3cda" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">因此，箱线图提供了汇总统计数据(方框和胡须)和直接的数据可视化(异常值)。</p><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="cdc1" class="np ml iq nk b gy nq nr l ns nt">sns.boxplot(data=df, x='Group', y='Income');<br/>plt.title("Boxplot");</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nu"><img src="../Images/3eed611c524f39ee1903813164d6e9db.png" data-original-src="https://miro.medium.com/v2/format:webp/1*KTiHK6XLIZK7N6TXDJf2nQ.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">治疗组和对照组的收入分布，按作者分类</p></figure><p id="d11e" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">看起来<code class="fe nh ni nj nk b">treatment</code>组中的<code class="fe nh ni nj nk b">income</code>分布稍微分散一些:橙色的盒子更大，它的须覆盖的范围更广。然而，箱线图的<strong class="li ja">问题</strong>在于它隐藏了数据的形状，告诉我们一些汇总统计数据，但不显示实际的数据分布。</p><h2 id="52ea" class="np ml iq bd mm nv nw dn mq nx ny dp mu lp nz oa mw lt ob oc my lx od oe na iw bi translated">柱状图</h2><p id="40d1" class="pw-post-body-paragraph lg lh iq li b lj nc ka ll lm nd kd lo lp ne lr ls lt nf lv lw lx ng lz ma mb ij bi translated">绘制分布图最直观的方式是<strong class="li ja">直方图</strong>。直方图将数据分组到等宽的<strong class="li ja">箱</strong>中，并绘制每个箱内的观察数量。</p><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="5cfa" class="np ml iq nk b gy nq nr l ns nt">sns.histplot(data=df, x='Income', hue='Group', bins=50);<br/>plt.title("Histogram");</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nu"><img src="../Images/304505b13501bad2edfbf3728843a4a3.png" data-original-src="https://miro.medium.com/v2/format:webp/1*kvlf_2oqGNZjCMXMcgpaYA.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">治疗组和对照组的收入分布，按作者分类</p></figure><p id="0641" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">这个情节有多个<strong class="li ja">问题</strong>:</p><ul class=""><li id="805d" class="of og iq li b lj lk lm ln lp oh lt oi lx oj mb ok ol om on bi translated">由于两组有不同数量的观察值，这两个直方图是不可比的</li><li id="7f0e" class="of og iq li b lj oo lm op lp oq lt or lx os mb ok ol om on bi translated">箱的数量是任意的</li></ul><p id="2cea" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们可以解决第一个问题，使用<code class="fe nh ni nj nk b">stat</code>选项来绘制<code class="fe nh ni nj nk b">density</code>而不是计数，并将<code class="fe nh ni nj nk b">common_norm</code>选项设置为<code class="fe nh ni nj nk b">False</code>来分别归一化每个直方图。</p><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="41c9" class="np ml iq nk b gy nq nr l ns nt">sns.histplot(data=df, x='Income', hue='Group', bins=50, stat='density', common_norm=False);<br/>plt.title("Density Histogram");</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nu"><img src="../Images/ce8298c2a20ef05d5efbbfbe0b5e81a1.png" data-original-src="https://miro.medium.com/v2/format:webp/1*RVcXo74VkAJ6lqE3DAvSPg.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">治疗组和对照组的收入分布，按作者分类</p></figure><p id="fd32" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">现在两个直方图有可比性了！</p><p id="82a1" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">然而，一个重要的<strong class="li ja">问题</strong>仍然存在:箱子的大小是任意的。在极端情况下，如果我们将数据聚集得更少，我们最终会得到最多一个观测值的箱，如果我们将数据聚集得更多，我们最终会得到单个箱。在这两种情况下，如果我们夸大，情节就失去了信息性。这是一个经典的<a class="ae lf" href="https://en.wikipedia.org/wiki/Bias%E2%80%93variance_tradeoff" rel="noopener ugc nofollow" target="_blank">偏差-方差权衡</a>。</p><h2 id="ffc8" class="np ml iq bd mm nv nw dn mq nx ny dp mu lp nz oa mw lt ob oc my lx od oe na iw bi translated">内核密度</h2><p id="fc3c" class="pw-post-body-paragraph lg lh iq li b lj nc ka ll lm nd kd lo lp ne lr ls lt nf lv lw lx ng lz ma mb ij bi translated">一种可能的解决方案是使用<a class="ae lf" href="https://en.wikipedia.org/wiki/Kernel_density_estimation" rel="noopener ugc nofollow" target="_blank"> <strong class="li ja">核密度函数</strong> </a>，该函数试图用连续函数近似直方图，使用<a class="ae lf" href="https://en.wikipedia.org/wiki/Kernel_density_estimation" rel="noopener ugc nofollow" target="_blank">核密度估计(KDE) </a>。</p><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="f1c5" class="np ml iq nk b gy nq nr l ns nt">sns.kdeplot(x='Income', data=df, hue='Group', common_norm=False);<br/>plt.title("Kernel Density Function");</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nu"><img src="../Images/16b56536603d164a2defbb73d3d3bc13.png" data-original-src="https://miro.medium.com/v2/format:webp/1*BGQdAtWTiQqj2jeHyb82VQ.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">治疗组和对照组的收入分布，按作者分类</p></figure><p id="38a2" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">从图中可以看出，<code class="fe nh ni nj nk b">income</code>的估计核密度在<code class="fe nh ni nj nk b">treatment</code>组中似乎具有“更厚的尾部”(即更高的方差)，而各组之间的平均值似乎相似。</p><p id="9e28" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">内核密度估计的<strong class="li ja">问题</strong>是它有点像黑盒，可能会掩盖数据的相关特征。</p><h2 id="4412" class="np ml iq bd mm nv nw dn mq nx ny dp mu lp nz oa mw lt ob oc my lx od oe na iw bi translated">累积分布</h2><p id="fd65" class="pw-post-body-paragraph lg lh iq li b lj nc ka ll lm nd kd lo lp ne lr ls lt nf lv lw lx ng lz ma mb ij bi translated">两个分布的更透明的表示是它们的<a class="ae lf" href="https://en.wikipedia.org/wiki/Cumulative_distribution_function" rel="noopener ugc nofollow" target="_blank"> <strong class="li ja">累积分布函数</strong> </a>。在x轴的每个点(<code class="fe nh ni nj nk b">income</code>)，我们绘制了具有相等或更低值的数据点的百分比。累积分布函数的主要<strong class="li ja">优点</strong>是</p><ul class=""><li id="3ffa" class="of og iq li b lj lk lm ln lp oh lt oi lx oj mb ok ol om on bi translated">我们不需要做出任何任意的选择(例如，箱的数量)</li><li id="f561" class="of og iq li b lj oo lm op lp oq lt or lx os mb ok ol om on bi translated">我们不需要执行任何近似(例如，用KDE)，但是我们代表所有的数据点</li></ul><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="575a" class="np ml iq nk b gy nq nr l ns nt">sns.histplot(x='Income', data=df, hue='Group', bins=len(df), stat="density",<br/>             element="step", fill=False, cumulative=True, common_norm=False);<br/>plt.title("Cumulative distribution function");</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nu"><img src="../Images/3f8d47e432938a1648340057398d5af4.png" data-original-src="https://miro.medium.com/v2/format:webp/1*3FlKfDzVmKs2p2NEbCy1jA.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">治疗组和对照组的累积收入分布，按作者分类的图像</p></figure><p id="584a" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们应该如何解释这个图表？</p><ul class=""><li id="4cb8" class="of og iq li b lj lk lm ln lp oh lt oi lx oj mb ok ol om on bi translated">由于两条线在0.5 (y轴)处交叉，这意味着它们的中值是相似的</li><li id="df58" class="of og iq li b lj oo lm op lp oq lt or lx os mb ok ol om on bi translated">由于橙色线位于左侧蓝线的上方和右侧蓝线的下方，这意味着<code class="fe nh ni nj nk b">treatment</code>组的分布为较粗的尾部</li></ul><h2 id="d159" class="np ml iq bd mm nv nw dn mq nx ny dp mu lp nz oa mw lt ob oc my lx od oe na iw bi translated">Q-Q图</h2><p id="ec2d" class="pw-post-body-paragraph lg lh iq li b lj nc ka ll lm nd kd lo lp ne lr ls lt nf lv lw lx ng lz ma mb ij bi translated">一个相关的方法是<strong class="li ja">Q-Q</strong>T24】plot，其中<em class="mc"> q </em>代表分位数。Q-Q图绘制了两种分布的分位数。如果分布相同，我们应该得到一条45度线。</p><p id="adbe" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">Python中没有原生的Q-Q plot函数，尽管<code class="fe nh ni nj nk b">statsmodels</code>包提供了一个<code class="fe nh ni nj nk b"><a class="ae lf" href="https://www.statsmodels.org/dev/generated/statsmodels.graphics.gofplots.qqplot.html" rel="noopener ugc nofollow" target="_blank">qqplot</a></code> <a class="ae lf" href="https://www.statsmodels.org/dev/generated/statsmodels.graphics.gofplots.qqplot.html" rel="noopener ugc nofollow" target="_blank">函数</a>，但它相当麻烦。所以，我们就手工做。</p><p id="a9dd" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">首先，我们需要使用<code class="fe nh ni nj nk b">percentile</code>函数计算两组的四分位数。</p><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="1b7d" class="np ml iq nk b gy nq nr l ns nt">income = df['Income'].values<br/>income_t = df.loc[df.Group=='treatment', 'Income'].values<br/>income_c = df.loc[df.Group=='control', 'Income'].values<br/><br/>df_pct = pd.DataFrame()<br/>df_pct['q_treatment'] = np.percentile(income_t, range(100))<br/>df_pct['q_control'] = np.percentile(income_c, range(100))</span></pre><p id="a5b1" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">现在我们可以绘制两个分位数分布图，加上45度线，代表基准完美拟合。</p><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="3a73" class="np ml iq nk b gy nq nr l ns nt">plt.figure(figsize=(8, 8))<br/>plt.scatter(x='q_control', y='q_treatment', data=df_pct, label='Actual fit');<br/>sns.lineplot(x='q_control', y='q_control', data=df_pct, color='r', label='Line of perfect fit');<br/>plt.xlabel('Quantile of income, control group')<br/>plt.ylabel('Quantile of income, treatment group')<br/>plt.legend()<br/>plt.title("QQ plot");</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nu"><img src="../Images/e446540dd53d6da7cbf56aed356a216f.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Ol1uJfn55KXnvxO3McoPOw.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">Q-Q图，作者图片</p></figure><p id="e182" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">Q-Q图提供了与累积分布图非常相似的洞察<strong class="li ja">:治疗组的收入具有相同的中值(线在中心交叉),但尾部更宽(点在左端线的下方，右端线的上方)。</strong></p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="8265" class="mk ml iq bd mm mn mo mp mq mr ms mt mu kf mv kg mw ki mx kj my kl mz km na nb bi translated">两组—测试</h1><p id="457e" class="pw-post-body-paragraph lg lh iq li b lj nc ka ll lm nd kd lo lp ne lr ls lt nf lv lw lx ng lz ma mb ij bi translated">到目前为止，我们已经看到了不同的方式来<em class="mc">可视化</em>分布之间的差异。可视化的主要优势是<strong class="li ja">直觉</strong>:我们可以观察差异并直观地评估它们。</p><p id="4992" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">然而，我们可能希望更加<strong class="li ja">严谨</strong>并尝试评估分布之间差异的<strong class="li ja">统计显著性</strong>，即回答问题“<em class="mc">观察到的差异是系统性的还是由于采样噪声？</em>”。</p><p id="fe9f" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们现在要分析不同的测试来区分两个分布。</p><h2 id="c124" class="np ml iq bd mm nv nw dn mq nx ny dp mu lp nz oa mw lt ob oc my lx od oe na iw bi translated">t检验</h2><p id="b172" class="pw-post-body-paragraph lg lh iq li b lj nc ka ll lm nd kd lo lp ne lr ls lt nf lv lw lx ng lz ma mb ij bi translated">第一个也是最常见的测试是<a class="ae lf" href="https://en.wikipedia.org/wiki/Student's_t-test" rel="noopener ugc nofollow" target="_blank">学生t测试</a>。t检验一般用于<strong class="li ja">比较均值</strong>。在这种情况下，我们想要测试<code class="fe nh ni nj nk b">income</code>分布的平均值在两组中是否相同。两均值比较检验的检验统计量由下式给出:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ot"><img src="../Images/704a581c8eeb8d2bf5f18f050762a73f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tCnvcGUm9QWlKxoQ8miTUw.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">t检验统计，作者图片</p></figure><p id="a782" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">其中<em class="mc"> x̅ </em>是样本均值，而<em class="mc"> s </em>是样本标准差。在温和条件下，检验统计量渐近分布为<a class="ae lf" href="https://en.wikipedia.org/wiki/Student's_t-distribution" rel="noopener ugc nofollow" target="_blank">学生t </a>分布。</p><p id="d01c" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们使用来自<code class="fe nh ni nj nk b">scipy</code>的<code class="fe nh ni nj nk b">ttest_ind</code>函数来执行t检验。该函数返回测试统计和隐含的<a class="ae lf" href="https://en.wikipedia.org/wiki/P-value" rel="noopener ugc nofollow" target="_blank"> p值</a>。</p><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="582c" class="np ml iq nk b gy nq nr l ns nt">from scipy.stats import ttest_ind<br/><br/>stat, p_value = ttest_ind(income_c, income_t)<br/>print(f"t-test: statistic={stat:.4f}, p-value={p_value:.4f}")</span><span id="2fbc" class="np ml iq nk b gy ou nr l ns nt">t-test: statistic=-1.5549, p-value=0.1203</span></pre><p id="433e" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">检验的p值为0.12，因此我们<strong class="li ja">不拒绝</strong>治疗组和对照组的<em class="mc">无差异的零假设意味着</em>。</p><blockquote class="ov ow ox"><p id="116e" class="lg lh mc li b lj lk ka ll lm ln kd lo oy lq lr ls oz lu lv lw pa ly lz ma mb ij bi translated"><strong class="li ja">注意</strong>:t检验假设两个样本中的方差相同，因此它的估计是在联合样本上计算的。<a class="ae lf" href="https://en.wikipedia.org/wiki/Welch%27s_t-test" rel="noopener ugc nofollow" target="_blank">韦尔奇的t检验</a>允许两个样本中的<strong class="li ja">不等方差</strong>。</p></blockquote><h2 id="2189" class="np ml iq bd mm nv nw dn mq nx ny dp mu lp nz oa mw lt ob oc my lx od oe na iw bi translated">标准化平均差(SMD)</h2><p id="58d4" class="pw-post-body-paragraph lg lh iq li b lj nc ka ll lm nd kd lo lp ne lr ls lt nf lv lw lx ng lz ma mb ij bi translated">一般来说，当我们进行随机对照试验或A/B试验时，最好始终对治疗组和对照组的所有变量<strong class="li ja">进行均值差异测试。</strong></p><p id="aff6" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">然而，由于t-检验统计的分母取决于样本量，t-检验受到了<strong class="li ja">批评</strong>，因为它使得p值很难跨研究进行比较。事实上，我们可能在差异非常小但样本量很大的实验中获得显著结果，而在差异很大但样本量很小的实验中获得不显著结果。</p><p id="e283" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">已经提出的一个解决方案是<strong class="li ja">标准化平均差异(SMD) </strong>。顾名思义，这不是一个适当的测试统计，而只是一个标准化的差异，可以计算如下:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi pb"><img src="../Images/c223d4e11b9b1dd092f303fdc0ecf2a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XuXDj7ZllFHP5rK0_m2WJg.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">标准化平均差异，作者图像</p></figure><p id="1471" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">通常，低于0.1的值被认为是“小”差异。</p><p id="e822" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">良好的做法是收集所有治疗组和对照组变量的平均值，以及两者之间的距离测量值——t检验或SMD——到一个名为<strong class="li ja">平衡表</strong>的表格中。我们可以使用<code class="fe nh ni nj nk b"><a class="ae lf" href="https://causalml.readthedocs.io/en/latest/about.html" rel="noopener ugc nofollow" target="_blank">causalml</a></code>库中的<code class="fe nh ni nj nk b"><a class="ae lf" href="https://causalml.readthedocs.io/en/latest/causalml.html#module-causalml.match" rel="noopener ugc nofollow" target="_blank">create_table_one</a></code>函数来生成它。正如这个函数的名字所暗示的，平衡表应该总是你在执行A/B测试时出现的第一个表。</p><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="e137" class="np ml iq nk b gy nq nr l ns nt">from causalml.match import create_table_one<br/><br/>df['treatment'] = df['Group']=='treatment'<br/>create_table_one(df, 'treatment', ['Gender', 'Age', 'Income'])</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nu"><img src="../Images/e9d8f3c8c08a4ec76d6b0b7a3a81b862.png" data-original-src="https://miro.medium.com/v2/format:webp/1*1PSHitUXsQ8r_FlHMRgbbQ.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">平衡表，作者图片</p></figure><p id="a003" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">在前两列中，我们可以看到治疗组和对照组不同变量的平均值，标准误差在括号中。在<strong class="li ja">最后一列</strong>中，SMD值显示所有变量的标准化差异超过0.1，表明两组可能不同。</p><h2 id="5271" class="np ml iq bd mm nv nw dn mq nx ny dp mu lp nz oa mw lt ob oc my lx od oe na iw bi translated">曼恩-惠特尼U检验</h2><p id="0ac7" class="pw-post-body-paragraph lg lh iq li b lj nc ka ll lm nd kd lo lp ne lr ls lt nf lv lw lx ng lz ma mb ij bi translated">另一种测试是<a class="ae lf" href="https://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U_test" rel="noopener ugc nofollow" target="_blank">曼-惠特尼U测试</a>。此检验的零假设是两组具有相同的分布，而另一个假设是一组比另一组具有更大(或更小)的值。</p><p id="2c65" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">与我们到目前为止看到的其他检验不同，Mann–Whitney U检验对异常值不可知，并且集中于分布的中心。</p><p id="25f6" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">测试<strong class="li ja">程序</strong>如下。</p><ol class=""><li id="312c" class="of og iq li b lj lk lm ln lp oh lt oi lx oj mb pc ol om on bi translated">合并所有数据点并对其进行排序(按升序或降序)</li><li id="78f9" class="of og iq li b lj oo lm op lp oq lt or lx os mb pc ol om on bi translated">计算<em class="mc">u₁=r₁n₁(n₁+1)/2</em>，其中<em class="mc"> R₁ </em>为第一组数据点的排名之和，<em class="mc"> n₁ </em>为第一组的点数。</li><li id="7260" class="of og iq li b lj oo lm op lp oq lt or lx os mb pc ol om on bi translated">为第二组类似地计算<em class="mc"> U₂ </em>。</li><li id="3831" class="of og iq li b lj oo lm op lp oq lt or lx os mb pc ol om on bi translated">测试统计数据由u₂).min(u₁给出</li></ol><p id="db83" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">在两个分布之间没有系统性等级差异的零假设下(即，相同的中值)，检验统计量是具有已知均值和方差的渐近正态分布。</p><p id="2c97" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">计算<em class="mc"> R </em>和<em class="mc"> U </em>背后的<strong class="li ja">直觉</strong>如下:如果第一个样本中的值都大于第二个样本中的值，那么<em class="mc"> R₁ = n₁(n₁ + 1)/2 </em>，因此<em class="mc"> U₁ </em>将为零(可达到的最小值)。否则，如果两个样本相似，<em class="mc"> U₁ </em>和<em class="mc"> U₂ </em>将非常接近<em class="mc"> n₁ n₂ / 2 </em>(可达到的最大值)。</p><p id="7708" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们使用来自<code class="fe nh ni nj nk b">scipy</code>的<code class="fe nh ni nj nk b">mannwhitneyu</code>函数来执行测试。</p><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="fdd3" class="np ml iq nk b gy nq nr l ns nt">from scipy.stats import mannwhitneyu<br/><br/>stat, p_value = mannwhitneyu(income_t, income_c)<br/>print(f" Mann–Whitney U Test: statistic={stat:.4f}, p-value={p_value:.4f}")</span><span id="c4f6" class="np ml iq nk b gy ou nr l ns nt">Mann–Whitney U Test: statistic=106371.5000, p-value=0.6012</span></pre><p id="4949" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们得到的p值为0.6，这意味着我们没有拒绝治疗组和对照组中<code class="fe nh ni nj nk b">income</code>分布相同的无效假设。</p><blockquote class="ov ow ox"><p id="870e" class="lg lh mc li b lj lk ka ll lm ln kd lo oy lq lr ls oz lu lv lw pa ly lz ma mb ij bi translated"><strong class="li ja">注</strong>:关于t检验，对于两个样本中的<strong class="li ja">不等方差</strong>存在一个版本的曼恩-惠特尼U检验，即<a class="ae lf" href="https://www.statisticshowto.com/brunner-munzel-test-generalized-wilcoxon-test/" rel="noopener ugc nofollow" target="_blank">布鲁纳-芒泽尔检验</a>。</p></blockquote><h2 id="ddf9" class="np ml iq bd mm nv nw dn mq nx ny dp mu lp nz oa mw lt ob oc my lx od oe na iw bi translated">排列测试</h2><p id="244c" class="pw-post-body-paragraph lg lh iq li b lj nc ka ll lm nd kd lo lp ne lr ls lt nf lv lw lx ng lz ma mb ij bi translated">一个非参数的替代方法是排列测试。这个想法是，在零假设下，两个分布应该是相同的，因此<strong class="li ja">洗牌</strong>标签<code class="fe nh ni nj nk b">group</code>不应该显著改变任何统计数据。</p><p id="7810" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们可以选择任何统计数据，并检查其在原始样本中的值与其在<code class="fe nh ni nj nk b">group</code>标签排列中的分布相比如何。例如，让我们使用治疗组和对照组之间的样本均值的<strong class="li ja">差异作为检验统计量。</strong></p><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="15c7" class="np ml iq nk b gy nq nr l ns nt">sample_stat = np.mean(income_t) - np.mean(income_c)</span><span id="2db5" class="np ml iq nk b gy ou nr l ns nt">stats = np.zeros(1000)<br/>for k in range(1000):<br/>    labels = np.random.permutation((df['Group'] == 'treatment').values)<br/>    stats[k] = np.mean(income[labels]) - np.mean(income[labels==False])<br/>p_value = np.mean(stats &gt; sample_stat)<br/><br/>print(f"Permutation test: p-value={p_value:.4f}")</span><span id="eb57" class="np ml iq nk b gy ou nr l ns nt">Permutation test: p-value=0.0530</span></pre><p id="ead3" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">排列测试给出的p值为0.053，意味着在5%的水平上零假设的弱<strong class="li ja">非拒绝</strong>。</p><p id="ef0b" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们如何<strong class="li ja">解读</strong>p值？这意味着数据中的均值差异大于置换样本均值差异的1–0.0560 = 94.4%。</p><p id="3694" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们可以<strong class="li ja">可视化</strong>测试，通过绘制测试统计量相对于样本值的排列分布。</p><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="92be" class="np ml iq nk b gy nq nr l ns nt">plt.hist(stats, label='Permutation Statistics', bins=30);<br/>plt.axvline(x=sample_stat, c='r', ls='--', label='Sample Statistic');<br/>plt.legend();<br/>plt.xlabel('Income difference between treatment and control group')<br/>plt.title('Permutation Test');</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nu"><img src="../Images/28e77dd8bb5ce87d8ca75322daa472a9.png" data-original-src="https://miro.medium.com/v2/format:webp/1*xzn_spfGbRmWpUFvyQY6AA.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">排列的平均差异分布，按作者分类的图像</p></figure><p id="90e8" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">正如我们所看到的，样本统计量相对于置换样本中的值来说非常极端，但并不过分。</p><h2 id="094c" class="np ml iq bd mm nv nw dn mq nx ny dp mu lp nz oa mw lt ob oc my lx od oe na iw bi translated">卡方检验</h2><p id="4ed3" class="pw-post-body-paragraph lg lh iq li b lj nc ka ll lm nd kd lo lp ne lr ls lt nf lv lw lx ng lz ma mb ij bi translated"><a class="ae lf" href="https://matteocourthoud.github.io/post/chisquared/" rel="noopener ugc nofollow" target="_blank">卡方检验</a>是一种非常强大的检验，主要用于检验频率差异。</p><p id="bd33" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">卡方检验的<strong class="li ja">最不为人知的应用</strong>之一是测试两个分布之间的相似性。<strong class="li ja">的想法</strong>是将两个组的观察结果结合起来。如果两个分布是相同的，我们将期望在每个箱中观察到相同的频率。重要的是，为了使测试有效，我们需要在每个箱中有足够的观察值。</p><p id="9aec" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我生成与<em class="mc">控制</em>组中<code class="fe nh ni nj nk b">income</code>的十分位数分布相对应的箱，然后计算<em class="mc">处理</em>组中每个箱中的预期观察数，如果两个分布相同的话。</p><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="c169" class="np ml iq nk b gy nq nr l ns nt"># Init dataframe<br/>df_bins = pd.DataFrame()<br/><br/># Generate bins from control group<br/>_, bins = pd.qcut(income_c, q=10, retbins=True)<br/>df_bins['bin'] = pd.cut(income_c, bins=bins).value_counts().index<br/><br/># Apply bins to both groups<br/>df_bins['income_c_observed'] = pd.cut(income_c, bins=bins).value_counts().values<br/>df_bins['income_t_observed'] = pd.cut(income_t, bins=bins).value_counts().values<br/><br/># Compute expected frequency in the treatment group<br/>df_bins['income_t_expected'] = df_bins['income_c_observed'] / np.sum(df_bins['income_c_observed']) * np.sum(df_bins['income_t_observed'])<br/><br/>df_bins</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nu"><img src="../Images/973c5d753c74820e6b513dcbaeebb069.png" data-original-src="https://miro.medium.com/v2/format:webp/1*9QaJwLoD3CT7Kk5fhw4ryg.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">按作者分类的媒体夹和频率、图像</p></figure><p id="a15b" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们现在可以通过比较治疗组中预期的(E)和观察到的(O)数量来进行测试。测试统计由下式给出</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi pb"><img src="../Images/a838083a3ea656680dca6c593bfaa80c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BGf27e96gUi8dYQJoH9z2Q.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">卡方检验统计，图片由作者提供</p></figure><p id="d448" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">其中由<em class="mc"> i </em>和<em class="mc"> O </em>索引的面元是面元<em class="mc"> i </em>中的观察数据点数，而<em class="mc"> E </em>是面元<em class="mc"> i </em>中的预期数据点数。由于我们使用对照组中<code class="fe nh ni nj nk b">income</code>分布的十分位数来生成箱，我们预计治疗组中每个箱的观察数量在所有箱中是相同的。检验统计量渐近分布为<a class="ae lf" href="https://en.wikipedia.org/wiki/Chi-squared_distribution" rel="noopener ugc nofollow" target="_blank">卡方</a>分布。</p><p id="3c1c" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">为了计算测试的统计量和p值，我们使用了来自<code class="fe nh ni nj nk b">scipy</code>的<code class="fe nh ni nj nk b">chisquare</code>函数。</p><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="32cd" class="np ml iq nk b gy nq nr l ns nt">from scipy.stats import chisquare<br/><br/>stat, p_value = chisquare(df_bins['income_t_observed'], df_bins['income_t_expected'])<br/>print(f"Chi-squared Test: statistic={stat:.4f}, p-value={p_value:.4f}")</span><span id="c16d" class="np ml iq nk b gy ou nr l ns nt">Chi-squared Test: statistic=32.1432, p-value=0.0002</span></pre><p id="11b7" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">与迄今为止所有其他测试不同，卡方检验<strong class="li ja">强烈拒绝</strong>两个分布相同的无效假设。为什么？</p><p id="8a69" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">原因在于两个分布具有相似的中心但不同的尾部，卡方检验沿着<strong class="li ja">整个分布</strong>测试相似性，而不仅仅是在中心，就像我们在之前的测试中所做的那样。</p><p id="f9e6" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">这个结果告诉了一个<strong class="li ja">警示故事</strong>:在从p值得出盲目的结论之前，理解<em class="mc">你实际测试的是什么</em>是非常重要的！</p><h2 id="1a01" class="np ml iq bd mm nv nw dn mq nx ny dp mu lp nz oa mw lt ob oc my lx od oe na iw bi translated">科尔莫戈罗夫-斯米尔诺夫试验</h2><p id="4f80" class="pw-post-body-paragraph lg lh iq li b lj nc ka ll lm nd kd lo lp ne lr ls lt nf lv lw lx ng lz ma mb ij bi translated"><a class="ae lf" href="https://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test" rel="noopener ugc nofollow" target="_blank"> Kolmogorov-Smirnov检验</a>可能是比较分布的最流行的非参数检验。Kolmogorov-Smirnov测试的想法是<strong class="li ja">比较两组的累积分布</strong>。特别地，Kolmogorov-Smirnov检验统计量是两个累积分布之间的最大绝对差。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi pd"><img src="../Images/50969e3aaa6ebf2125751a11f04fd2d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p93GVnGv7D6K0JwO9cnQCg.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">Kolmogorov-Smirnov检验统计，图片由作者提供</p></figure><p id="41a5" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">其中<em class="mc"> F₁ </em>和<em class="mc"> F₂ </em>是两个累积分布函数，而<em class="mc"> x </em>是基础变量的值。Kolmogorov-Smirnov检验统计量的渐近分布是<a class="ae lf" href="https://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test#Kolmogorov_distribution" rel="noopener ugc nofollow" target="_blank"> Kolmogorov分布</a>。</p><p id="d095" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">为了更好地理解测试，让我们画出累积分布函数和测试统计量。首先，我们计算累积分布函数。</p><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="ba6f" class="np ml iq nk b gy nq nr l ns nt">df_ks = pd.DataFrame()<br/>df_ks['Income'] = np.sort(df['Income'].unique())<br/>df_ks['F_control'] = df_ks['Income'].apply(lambda x: np.mean(income_c&lt;=x))<br/>df_ks['F_treatment'] = df_ks['Income'].apply(lambda x: np.mean(income_t&lt;=x))<br/>df_ks.head()</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nu"><img src="../Images/bc93b5e5769536fd204cc8e09ff74d76.png" data-original-src="https://miro.medium.com/v2/format:webp/1*QawU7Qwet86ZIHr8PQit1w.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">累积分布数据集快照，按作者分类的图像</p></figure><p id="fb9a" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们现在需要找到累积分布函数之间的绝对距离最大的点。</p><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="fb15" class="np ml iq nk b gy nq nr l ns nt">k = np.argmax( np.abs(df_ks['F_control'] - df_ks['F_treatment']))<br/>ks_stat = np.abs(df_ks['F_treatment'][k] - df_ks['F_control'][k])</span></pre><p id="5d67" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">通过绘制两个累积分布函数和检验统计量的值，我们可以直观地看到检验统计量的值。</p><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="928d" class="np ml iq nk b gy nq nr l ns nt">y = (df_ks['F_treatment'][k] + df_ks['F_control'][k])/2<br/>plt.plot('Income', 'F_control', data=df_ks, label='Control')<br/>plt.plot('Income', 'F_treatment', data=df_ks, label='Treatment')<br/>plt.errorbar(x=df_ks['Income'][k], y=y, yerr=ks_stat/2, color='k',<br/>             capsize=5, mew=3, label=f"Test statistic: {ks_stat:.4f}")<br/>plt.legend(loc='center right');<br/>plt.title("Kolmogorov-Smirnov Test");</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nu"><img src="../Images/459940ccb68e705f8c9a411a1faabea2.png" data-original-src="https://miro.medium.com/v2/format:webp/1*hyXRjbpVrGtzDdC8Nn4JdQ.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">Kolmogorov-Smirnov检验统计，图片由作者提供</p></figure><p id="91a4" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">从图中我们可以看到，在<code class="fe nh ni nj nk b">income</code> ~650处，检验统计量的值对应于两个累积分布之间的距离。对于<code class="fe nh ni nj nk b">income</code>值，我们在两组之间有最大的不平衡。</p><p id="9269" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们现在可以使用<code class="fe nh ni nj nk b">scipy</code>中的<code class="fe nh ni nj nk b">kstest</code>功能进行实际测试。</p><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="fd99" class="np ml iq nk b gy nq nr l ns nt">from scipy.stats import kstest<br/><br/>stat, p_value = kstest(income_t, income_c)<br/>print(f" Kolmogorov-Smirnov Test: statistic={stat:.4f}, p-value={p_value:.4f}")</span><span id="8fef" class="np ml iq nk b gy ou nr l ns nt">Kolmogorov-Smirnov Test: statistic=0.0974, p-value=0.0355</span></pre><p id="b43d" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">p值低于5%:我们<strong class="li ja">拒绝</strong>两个分布相同的零假设，有95%的置信度。</p><blockquote class="ov ow ox"><p id="cb1d" class="lg lh mc li b lj lk ka ll lm ln kd lo oy lq lr ls oz lu lv lw pa ly lz ma mb ij bi translated"><strong class="li ja">注1</strong>:KS检验<strong class="li ja">过于保守</strong>并且很少拒绝零假设。<a class="ae lf" href="https://en.wikipedia.org/wiki/Lilliefors_test" rel="noopener ugc nofollow" target="_blank"> Lilliefors检验</a>使用检验统计的不同分布，即Lilliefors分布，来纠正这种偏差。</p><p id="1b54" class="lg lh mc li b lj lk ka ll lm ln kd lo oy lq lr ls oz lu lv lw pa ly lz ma mb ij bi translated"><strong class="li ja">注2</strong>:KS测试<strong class="li ja">使用非常少的信息</strong>，因为它只比较一个点的两个累积分布:最大距离点。<a class="ae lf" href="https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test" rel="noopener ugc nofollow" target="_blank"> Anderson-Darling测试</a>和<a class="ae lf" href="https://en.wikipedia.org/wiki/Cram%C3%A9r%E2%80%93von_Mises_criterion" rel="noopener ugc nofollow" target="_blank"> Cramér-von Mises测试</a>则通过积分比较整个区域的两种分布(两者之间的差异在于平方距离的加权)。</p></blockquote></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="15a6" class="mk ml iq bd mm mn mo mp mq mr ms mt mu kf mv kg mw ki mx kj my kl mz km na nb bi translated">多组-图</h1><p id="8332" class="pw-post-body-paragraph lg lh iq li b lj nc ka ll lm nd kd lo lp ne lr ls lt nf lv lw lx ng lz ma mb ij bi translated">到目前为止，我们只考虑了两组的情况:治疗组和对照组。但是如果我们有<strong class="li ja">多组</strong>？我们在上面看到的一些方法可以很好地扩展，而另一些则不行。</p><p id="834a" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">作为一个工作示例，我们现在将检查<code class="fe nh ni nj nk b">income</code>的分布在处理<code class="fe nh ni nj nk b">arms</code>中是否相同。</p><h2 id="1f2e" class="np ml iq bd mm nv nw dn mq nx ny dp mu lp nz oa mw lt ob oc my lx od oe na iw bi translated">箱线图</h2><p id="4652" class="pw-post-body-paragraph lg lh iq li b lj nc ka ll lm nd kd lo lp ne lr ls lt nf lv lw lx ng lz ma mb ij bi translated">当我们有许多个一位数的组时，盒图<strong class="li ja">可以很好地缩放，因为我们可以并排放置不同的盒子。</strong></p><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="888a" class="np ml iq nk b gy nq nr l ns nt">sns.boxplot(x='Arm', y='Income', data=df.sort_values('Arm'));<br/>plt.title("Boxplot, multiple groups");</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nu"><img src="../Images/98d30e0ac15b2bc220ce9daa0bbbea62.png" data-original-src="https://miro.medium.com/v2/format:webp/1*odXrWrGif7th9xsjqfRABA.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">按作者分列的各治疗部门的收入分布图</p></figure><p id="8723" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">从图中可以看出，<code class="fe nh ni nj nk b">income</code>在不同治疗组中的分布是不同的，编号越高的治疗组平均收入越高。</p><h2 id="3db5" class="np ml iq bd mm nv nw dn mq nx ny dp mu lp nz oa mw lt ob oc my lx od oe na iw bi translated">小提琴情节</h2><p id="8b79" class="pw-post-body-paragraph lg lh iq li b lj nc ka ll lm nd kd lo lp ne lr ls lt nf lv lw lx ng lz ma mb ij bi translated">结合汇总统计和内核密度估计的箱线图的一个非常好的扩展是<strong class="li ja">小提琴图</strong>。violin图沿y轴显示单独的密度，这样它们就不会重叠。默认情况下，它还在内部添加了一个微型箱线图。</p><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="732e" class="np ml iq nk b gy nq nr l ns nt">sns.violinplot(x='Arm', y='Income', data=df.sort_values('Arm'));<br/>plt.title("Violin Plot, multiple groups");</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nu"><img src="../Images/a3f54474483ec720e0eabb9b3a5821e5.png" data-original-src="https://miro.medium.com/v2/format:webp/1*WRRiGpEoyYdpMVhnY5Br8A.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">按作者分列的各治疗部门的收入分布图</p></figure><p id="635a" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">至于箱线图，小提琴图表明不同治疗部门的收入是不同的。</p><h2 id="72c8" class="np ml iq bd mm nv nw dn mq nx ny dp mu lp nz oa mw lt ob oc my lx od oe na iw bi translated">脊线图</h2><p id="5f25" class="pw-post-body-paragraph lg lh iq li b lj nc ka ll lm nd kd lo lp ne lr ls lt nf lv lw lx ng lz ma mb ij bi translated">最后，<strong class="li ja">脊线图</strong>绘制了沿x轴的多个核密度分布，比小提琴图更直观，但部分重叠。不幸的是，<code class="fe nh ni nj nk b">matplotlib</code>和<code class="fe nh ni nj nk b">seaborn</code>都没有默认的脊线图。我们需要从<code class="fe nh ni nj nk b"><a class="ae lf" href="https://github.com/leotac/joypy" rel="noopener ugc nofollow" target="_blank">joypy</a></code>导入。</p><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="0832" class="np ml iq nk b gy nq nr l ns nt">from joypy import joyplot<br/><br/>joyplot(df, by='Arm', column='Income', colormap=sns.color_palette("crest", as_cmap=True));<br/>plt.xlabel('Income');<br/>plt.title("Ridgeline Plot, multiple groups");</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nu"><img src="../Images/9f1c61a70435c85bd1b8f9e985b09390.png" data-original-src="https://miro.medium.com/v2/format:webp/1*EVofWiOM52G8bodhIlgpdw.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">按作者分列的各治疗部门的收入分布图</p></figure><p id="2e18" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">脊线图再次表明，编号越高的治疗组收入越高。从该图中，也更容易理解不同形状的分布。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="3335" class="mk ml iq bd mm mn mo mp mq mr ms mt mu kf mv kg mw ki mx kj my kl mz km na nb bi translated">多组—测试</h1><p id="b4a7" class="pw-post-body-paragraph lg lh iq li b lj nc ka ll lm nd kd lo lp ne lr ls lt nf lv lw lx ng lz ma mb ij bi translated">最后，让我们考虑比较多组的假设检验。为了简单起见，我们将集中讨论最流行的一种:f检验。</p><h2 id="f684" class="np ml iq bd mm nv nw dn mq nx ny dp mu lp nz oa mw lt ob oc my lx od oe na iw bi translated">f检验</h2><p id="b495" class="pw-post-body-paragraph lg lh iq li b lj nc ka ll lm nd kd lo lp ne lr ls lt nf lv lw lx ng lz ma mb ij bi translated">在多个小组中，最受欢迎的测试是<a class="ae lf" href="https://en.wikipedia.org/wiki/F-test" rel="noopener ugc nofollow" target="_blank"> <strong class="li ja"> F-test </strong> </a>。f检验比较不同组间变量的方差。这种分析也称为<a class="ae lf" href="https://en.wikipedia.org/wiki/Analysis_of_variance" rel="noopener ugc nofollow" target="_blank">方差分析，或<strong class="li ja"> ANOVA </strong> </a>。</p><p id="aa57" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">实际上，f检验统计量由下式给出</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi pe"><img src="../Images/b5bd02d4b45505371155a00f9c4b78ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5rhEb-sJkVd8Yd4iMceuyw.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">f检验统计，按作者分类的图像</p></figure><p id="555d" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">其中<em class="mc"> G </em>为组数，<em class="mc"> N </em>为观察次数，<em class="mc"> x̅ </em>为总体平均值，<em class="mc"> x̅g </em>为组内平均值<em class="mc"> g </em>。在组独立性的零假设下，F统计量为<a class="ae lf" href="https://en.wikipedia.org/wiki/F-distribution" rel="noopener ugc nofollow" target="_blank"> F分布</a>。</p><pre class="kq kr ks kt gt nl nk nm nn aw no bi"><span id="e6b4" class="np ml iq nk b gy nq nr l ns nt">from scipy.stats import f_oneway<br/><br/>income_groups = [df.loc[df['Arm']==arm, 'Income'].values for arm in df['Arm'].dropna().unique()]<br/>stat, p_value = f_oneway(*income_groups)<br/>print(f"F Test: statistic={stat:.4f}, p-value={p_value:.4f}")</span><span id="b40a" class="np ml iq nk b gy ou nr l ns nt">F Test: statistic=9.0911, p-value=0.0000</span></pre><p id="4505" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">测试p值基本为零，意味着<strong class="li ja">强烈拒绝</strong>跨治疗组<code class="fe nh ni nj nk b">income</code>分布无差异的零假设。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="3e15" class="mk ml iq bd mm mn mo mp mq mr ms mt mu kf mv kg mw ki mx kj my kl mz km na nb bi translated">结论</h1><p id="922d" class="pw-post-body-paragraph lg lh iq li b lj nc ka ll lm nd kd lo lp ne lr ls lt nf lv lw lx ng lz ma mb ij bi translated">在这篇文章中，我们已经看到了很多不同的方法来比较两个或更多的分布，包括视觉上的和统计上的。这是许多应用中的主要问题，尤其是在因果推断中，我们使用随机化使治疗组和对照组尽可能具有可比性。</p><p id="869f" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们也看到了不同的方法可能更适合不同的情况。视觉方法有助于建立直觉，但统计方法对于决策是必不可少的，因为我们需要能够评估差异的大小和统计意义。</p><h2 id="97ed" class="np ml iq bd mm nv nw dn mq nx ny dp mu lp nz oa mw lt ob oc my lx od oe na iw bi translated">参考</h2><p id="d933" class="pw-post-body-paragraph lg lh iq li b lj nc ka ll lm nd kd lo lp ne lr ls lt nf lv lw lx ng lz ma mb ij bi translated">[1]学生，<a class="ae lf" href="https://www.jstor.org/stable/2331554" rel="noopener ugc nofollow" target="_blank">一个平均数的可能误差</a> (1908)，<em class="mc">生物计量学</em>。</p><p id="d9d9" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">[2] F. Wilcoxon，<a class="ae lf" href="https://www.jstor.org/stable/3001968" rel="noopener ugc nofollow" target="_blank">用等级方法进行个体比较</a> (1945)，<em class="mc">生物统计学通报</em>。</p><p id="1199" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">[3] B. L .韦尔奇，<a class="ae lf" href="https://academic.oup.com/biomet/article/34/1-2/28/210174" rel="noopener ugc nofollow" target="_blank">涉及几个不同总体方差时“学生”问题的推广</a> (1947)，<em class="mc"> Biometrika </em>。</p><p id="81e9" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">[4] H. B. Mann，D. R. Whitney，<a class="ae lf" href="https://www.jstor.org/stable/2236101" rel="noopener ugc nofollow" target="_blank">关于两个随机变量中的一个是否随机大于另一个的检验</a> (1947)，<em class="mc">《数理统计年鉴》</em>。</p><p id="e8be" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">[5] E. Brunner，U. Munzen，<a class="ae lf" href="https://onlinelibrary.wiley.com/doi/abs/10.1002/(SICI)1521-4036(200001)42:1%3C17::AID-BIMJ17%3E3.0.CO;2-U" rel="noopener ugc nofollow" target="_blank">《非参数伯伦斯-费希尔问题:渐近理论和小样本近似法》</a> (2000年)，<em class="mc">《生物统计学杂志》</em>。</p><p id="6a57" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">[6] A. N. Kolmogorov，<a class="ae lf" href="https://link.springer.com/chapter/10.1007/978-94-011-2260-3_15" rel="noopener ugc nofollow" target="_blank">Sulla determinizione empirica di una legge di distribuzione</a>(1933年)，<em class="mc"> Giorn .Ist。斜体的阿图尔。</em>。</p><p id="a2cb" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">[7] H. Cramér，<a class="ae lf" href="https://www.tandfonline.com/doi/abs/10.1080/03461238.1928.10416862" rel="noopener ugc nofollow" target="_blank">论基本错误的构成</a> (1928)，<em class="mc">斯堪的纳维亚精算杂志</em>。</p><p id="2fd7" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">[8] R. von Mises，<a class="ae lf" href="https://www.ams.org/journals/bull/1937-43-05/S0002-9904-1937-06520-7/" rel="noopener ugc nofollow" target="_blank">Wahrscheinlichkeit statistik und wahrheit</a>(1936)，《美国数学学会公报<em class="mc"/>。</p><p id="082b" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">[9] T. W. Anderson，D. A. Darling，<a class="ae lf" href="https://projecteuclid.org/journals/annals-of-mathematical-statistics/volume-23/issue-2/Asymptotic-Theory-of-Certain-Goodness-of-Fit-Criteria-Based-on/10.1214/aoms/1177729437.full" rel="noopener ugc nofollow" target="_blank">基于随机过程的某些“拟合优度”标准的渐近理论</a> (1953)，<em class="mc">《数理统计年鉴》</em>。</p><h2 id="3857" class="np ml iq bd mm nv nw dn mq nx ny dp mu lp nz oa mw lt ob oc my lx od oe na iw bi translated">相关文章</h2><ul class=""><li id="53ad" class="of og iq li b lj nc lm nd lp pf lt pg lx ph mb ok ol om on bi translated"><a class="ae lf" rel="noopener" target="_blank" href="/b63dc69e3d8c">再见散点图，欢迎入库散点图</a></li></ul><h2 id="15c4" class="np ml iq bd mm nv nw dn mq nx ny dp mu lp nz oa mw lt ob oc my lx od oe na iw bi translated">密码</h2><p id="26fa" class="pw-post-body-paragraph lg lh iq li b lj nc ka ll lm nd kd lo lp ne lr ls lt nf lv lw lx ng lz ma mb ij bi translated">你可以在这里找到Jupyter的原始笔记本:</p><div class="pi pj gp gr pk pl"><a href="https://github.com/matteocourthoud/Blog-Posts/blob/main/notebooks/distr.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd ja gy z fp pq fr fs pr fu fw iz bi translated">Blog-Posts/dist . ipynb at main matter courthoud/Blog-Posts</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">我博客文章的代码和笔记本。通过在…上创建帐户，为matteocourthoud/Blog-Posts的发展做出贡献</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">github.com</p></div></div><div class="pu l"><div class="pv l pw px py pu pz kz pl"/></div></div></a></div></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h2 id="87af" class="np ml iq bd mm nv nw dn mq nx ny dp mu lp nz oa mw lt ob oc my lx od oe na iw bi translated">感谢您的阅读！</h2><p id="c259" class="pw-post-body-paragraph lg lh iq li b lj nc ka ll lm nd kd lo lp ne lr ls lt nf lv lw lx ng lz ma mb ij bi translated">我真的很感激！🤗<em class="mc">如果你喜欢这个帖子并且想看更多，可以考虑</em> <a class="ae lf" href="https://medium.com/@matteo.courthoud" rel="noopener"> <strong class="li ja"> <em class="mc">关注我</em> </strong> </a> <em class="mc">。我每周发布一次与因果推断和数据分析相关的主题。我尽量让我的帖子简单而精确，总是提供代码、例子和模拟。</em></p><p id="6bdd" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated"><em class="mc">还有，一个小小的</em> <strong class="li ja"> <em class="mc">免责声明</em> </strong> <em class="mc">:我写作是为了学习所以错误是家常便饭，尽管我尽力了。当你发现他们的时候，请告诉我。也很欣赏新话题的建议！</em></p><p id="1195" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated"><em class="mc">最后但同样重要的是，热烈感谢</em><a class="ae lf" href="https://www.linkedin.com/in/adrianolszewski/" rel="noopener ugc nofollow" target="_blank"><em class="mc">Adrian Olszewski</em></a><em class="mc">的许多有用的评论！</em></p></div></div>    
</body>
</html>