<html>
<head>
<title>Pandas Ground Zero — Selection and Projection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫归零地——选择与投影</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pandas-ground-zero-selection-and-projection-3827f74ae6c5#2022-05-03">https://towardsdatascience.com/pandas-ground-zero-selection-and-projection-3827f74ae6c5#2022-05-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="967f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Python熊猫数据框架和系列的数据索引、选择和投影的核心概念</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e8cfd5af15d38723250d8234d0203000.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D8t-wIK5kCxpAVyZLvLhCg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/s/photos/slicing-and-dicing?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/@maxdelsid?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Max Delsid </a>拍摄的照片</p></figure><p id="dc7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">朋友们，有抱负的数据分析师、崭露头角的数据科学家和Python新秀们，请听我说……</em></p><h1 id="c4eb" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">动机</h1><p id="b3f9" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">本章的目的是描述熊猫数据框架的一些核心概念，这些概念是数据选择和预测的基础。我们将在此尝试回答的典型问题有:</p><ul class=""><li id="a31c" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><em class="ls">如何索引数据帧以支持访问？</em></li><li id="3980" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><em class="ls">数据帧的基本组成部分是什么？</em></li><li id="98d8" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><em class="ls">如何从数据帧中访问数据:切片和切块？</em></li><li id="c388" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><em class="ls">如何编写更新数据帧中特定行或列的函数？</em></li></ul><p id="e000" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在某个时候会用到这些概念，了解这些基础知识对我们打下坚实的基础确实有所帮助。</p><h1 id="dad6" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">首先是踏脚石—索引和轴</h1><p id="786a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">让我们从定义开始:</p><p id="b32c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">系列</em> </strong> <em class="ls">是一个</em> <strong class="ky ir"> <em class="ls">一维</em> </strong> <em class="ls">标签数组，能够存放任何类型的数据(整数、字符串、浮点、python对象等)。).将</em> <strong class="ky ir"> <em class="ls">轴</em> </strong> <em class="ls">标签</em> <strong class="ky ir"> <em class="ls"> </em> </strong> <em class="ls">统称为</em> <strong class="ky ir"> <em class="ls">索引</em> </strong> <em class="ls">。</em></p><p id="12af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">一个</em> <strong class="ky ir"> <em class="ls">数据帧</em> </strong> <em class="ls">是一个</em> <strong class="ky ir"> <em class="ls">二维数据结构</em> </strong> <em class="ls">，即数据以表格方式按行和列对齐，因此有两个</em><strong class="ky ir"><em class="ls"/></strong><em class="ls"/><strong class="ky ir"><em class="ls">轴</em> </strong> <em class="ls"> — row</em></p><p id="4ef6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">毫无疑问，这对读者来说并不新鲜！！但是让我们后退一步，看看上面的一些具体的单词:</p><ul class=""><li id="1e29" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">轴:系列轴是行指针，数据框轴是行和列指针。</li><li id="abe3" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">索引:一种特殊类型的列表，存储指向每一行的指针。</li></ul><p id="4247" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们探索这些概念，以便理解如何访问这些数据结构。</p><h2 id="c9d7" class="ne lu iq bd lv nf ng dn lz nh ni dp md lf nj nk mf lj nl nm mh ln nn no mj np bi translated">指数——核心概念:</h2><p id="f0a4" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">数据结构Series和DataFrame都被索引为<em class="ls"/>。Pandas使用一种称为索引的特殊序列来指向这些数据结构中的一组特定数据。让我们看一些索引创建的例子，以及为什么它是特殊的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="eb47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">关于指数的重要提示</strong>:</p><ul class=""><li id="e36c" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">根据索引中包含的元素的数据类型，索引可以有多种类型。代码片段显示了三种类型的索引，但是可以有许多其他类型的索引，如在<a class="ae kv" href="https://pandas.pydata.org/docs/reference/api/pandas.Index.html" rel="noopener ugc nofollow" target="_blank">文档</a>中提到的。</li><li id="f3f4" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">这些指数有什么特别之处？我们可以通过为我们想要的元素的位置(索引)指定布尔值来从索引中选择元素。这就是上面代码片段中“选择器”的作用——如果选择器在位置I有一个True值，那么在索引中位置I的元素被选中。</li><li id="d2bd" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">选择器数组必须是与索引大小相同的布尔数组。它可以是硬编码的，或者由如上所示的布尔函数来确定。</li></ul><h2 id="4bdf" class="ne lu iq bd lv nf ng dn lz nh ni dp md lf nj nk mf lj nl nm mh ln nn no mj np bi translated">轴和索引:</h2><p id="8a8f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">显然，系列有一个引用其行的轴，而数据帧有两个轴——一个用于行，一个用于列。所有这些轴都是不同类型的索引。让我们看看它们是什么，以及它们与索引的关系。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="de9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">关于轴和索引的重要提示</strong>:</p><ul class=""><li id="db8d" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">序列的(行)轴由RangeIndex表示(参见它是一个包含开始、停止和步进值的范围)。</li><li id="b654" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">DataFrame有两个轴——行轴由RangeIndex表示，就像Series一样，还有一个附加索引——Columns——它是一个基本索引类型，具有列名。</li><li id="4c59" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">可以根据需要修改、设置或重置索引。</li></ul><h1 id="a656" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">访问数据帧中的行和列</h1><p id="7617" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">很好地理解了索引和轴的概念后，我们现在可以继续探索如何访问数据帧的元素。</p><h2 id="513e" class="ne lu iq bd lv nf ng dn lz nh ni dp md lf nj nk mf lj nl nm mh ln nn no mj np bi translated">使用本机索引支持</h2><p id="0797" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">下图显示了如何使用<code class="fe ns nt nu nv b">df[ &lt;something&gt; ]</code>形式的选择器访问数据帧</p><p id="4101" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果<something>是一个选择器的布尔列表，其大小与数据帧的索引大小相同，那么Pandas理解使用前面部分描述的索引选择技术来请求行选择。</something></p><p id="2e57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果<something>只是一个列名，Pandas只是创建一个序列，该列的索引与DataFrame的索引相同。</something></p><p id="9821" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果<something>是一个列名列表，Pandas认为它是数据帧中请求的列的子集，没有对行进行任何过滤。</something></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/6d6acdc8e767fa72952d8dbf72fcfdc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jg8qQAXMGy1atdCszQUlDg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者创建的图像</p></figure><h2 id="5e10" class="ne lu iq bd lv nf ng dn lz nh ni dp md lf nj nk mf lj nl nm mh ln nn no mj np bi translated">使用带标签的索引定位器:loc和iloc</h2><p id="2551" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Pandas在其DataFrame对象中使用两个强大的索引定位器——loc和iloc——来选择行或项目列。</p><h2 id="a690" class="ne lu iq bd lv nf ng dn lz nh ni dp md lf nj nk mf lj nl nm mh ln nn no mj np bi translated"><strong class="ak">定位</strong>:通过标签定位</h2><p id="865b" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">语法是:<code class="fe ns nt nu nv b">df.loc [&lt;row_labels&gt;,&lt;column_labels&gt;]</code></p><p id="e562" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">row_labels可以是下列之一:</p><ul class=""><li id="0e3a" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">与数据帧索引长度相同的布尔选择器:这可用于行选择。布尔选择器通常由一些过滤函数生成</li><li id="9cf9" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">要检索的单个索引值或实际索引值列表。这些应该是实际的索引标签。</li><li id="5c43" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">形式为start:end的行索引值范围(slice对象)</li></ul><p id="81bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">column_labels是可选的。如果未指定任何内容，它将列出所有列。否则，如果指定了某个内容，它可以是以下内容之一:</p><ul class=""><li id="6592" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">长度小于用于列选择的数据帧列索引(列计数)长度的布尔选择器。</li><li id="873d" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">要检索的单个列名或列名列表。这些应该是实际的列名。</li><li id="e988" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">格式为start:end的列索引值范围(slice对象)</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="690f" class="ne lu iq bd lv nf ng dn lz nh ni dp md lf nj nk mf lj nl nm mh ln nn no mj np bi translated">iloc:按位置定位(基于整数的位置)</h2><p id="50a6" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">语法是:<code class="fe ns nt nu nv b">df.iloc [&lt;row_locations&gt;,&lt;column_locations&gt;]</code></p><p id="dc38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，使用行的默认RangeIndex，loc可以做得很好，如上所示。</p><p id="aefa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果数据帧的索引不是默认的RangeIndex，而是数据帧中的某个其他列，如时间戳索引或某个唯一的ID，则很难记住行标签。因此，有时索引数据帧就像编程语言中的数组一样变得很重要:<code class="fe ns nt nu nv b">df[i , j]</code>这有助于基于位置的检索。iloc前来救援。iloc的一个很好的用途是基于行子集上的过滤器更新数据帧——我们稍后会检查它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h1 id="12cb" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">数据框架“工具包”</h1><h2 id="c121" class="ne lu iq bd lv nf ng dn lz nh ni dp md lf nj nk mf lj nl nm mh ln nn no mj np bi translated"><strong class="ak">基本操作</strong></h2><p id="1e54" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">下面是对数据帧及其数据类型进行的一些关键操作</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="565a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">关于基本操作的重要提示</strong>:</p><ul class=""><li id="977e" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">数据帧的一列可以被投影为一个系列(具有相同的索引)或一个具有单列的数据帧(具有相同的索引)。</li><li id="ac28" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">当投影为类似<code class="fe ns nt nu nv b">df['RecruitmentSource'],</code>的系列时，可以应用不同的函数来生成新的系列(如value_counts)或一些标量(nunique)。</li><li id="b040" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">可以使用参数更改函数的默认行为，比如包含NaN和排序顺序。</li></ul><h2 id="b0fe" class="ne lu iq bd lv nf ng dn lz nh ni dp md lf nj nk mf lj nl nm mh ln nn no mj np bi translated"><strong class="ak">字符串操作</strong></h2><p id="9121" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">对Object(String)类型的列的操作有时需要一个称为String访问器的特殊对象，它允许Python对一系列元素进行字符串操作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="ea42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">管柱作业重要注意事项</strong>:</p><ul class=""><li id="06e9" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">当一个字符串列像<code class="fe ns nt nu nv b">df['RecruitmentSource'],</code>一样被投影为一个序列时，常规的Python字符串函数不能直接应用于每个元素；相反，需要一个字符串访问器来将序列中的每个元素转换成字符串，并使它们适合字符串操作。</li></ul><h2 id="de49" class="ne lu iq bd lv nf ng dn lz nh ni dp md lf nj nk mf lj nl nm mh ln nn no mj np bi translated">两个强大的函数— any()和all()</h2><p id="bffe" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">数据帧有两个非常强大的过滤/检查数据的功能:</p><p id="1660" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> any() </strong> —返回任何元素是否为真，<strong class="ky ir">潜在地在一个轴上</strong>。返回False，除非在一个序列中或沿着DataFrame轴至少有一个元素为真或等效(例如非零或非空)</p><p id="5e49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> all() </strong> —返回所有元素是否为真，<strong class="ky ir">潜在地在一个轴上</strong>。返回True，除非序列中或DataFrame轴上至少有一个元素为False或等效(例如零或空)。</p><p id="c146" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里重要的一点是:“<strong class="ky ir">潜在轴上”</strong></p><p id="e79f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">any()和all()都有一个名为axis的参数。根据文件:</p><pre class="kg kh ki kj gt nx nv ny nz aw oa bi"><span id="7705" class="ne lu iq nv b gy ob oc l od oe"><strong class="nv ir">axis</strong><em class="ls">{0 or ‘index’, 1 or ‘columns’, None}, </em><strong class="nv ir"><em class="ls">default 0<br/></em></strong>Indicate which axis or axes should be reduced.</span><span id="2370" class="ne lu iq nv b gy of oc l od oe"><strong class="nv ir">0</strong> / <strong class="nv ir">‘index’</strong> : reduce the index, return a Series whose index is the original column labels.<br/><strong class="nv ir">1 / ‘columns’ </strong>: reduce the columns, return a Series whose index is the original index.<br/><strong class="nv ir">None</strong> : reduce all axes, return a scalar.</span></pre><p id="411d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一点解释如下。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/61da0255ade63f30a53f7d66029d04ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gcv5x_1q1seG-CmKpC6-Tw.png"/></div></div></figure><p id="40a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看一些例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="3077" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">关于any()和all() </strong>的重要提示:</p><ul class=""><li id="e5ad" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">any()和all()验证某个轴上的真值。要扫描的轴(行或列)可以指定为参数。</li><li id="8df1" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">any()遵循OR逻辑，而all()遵循轴的真值的AND逻辑。</li><li id="6517" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">any()和all()都返回一个序列。对于轴=0，系列的索引有列名，而对于轴= 1，系列的索引是行索引。</li><li id="0449" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">在上面的例子中，<code class="fe ns nt nu nv b">df.isnull()</code>用于生成真值，但是它可以扩展到任何行/列子集上的任何函数，只要该函数测试某些条件并生成真值。</li></ul><h2 id="f407" class="ne lu iq bd lv nf ng dn lz nh ni dp md lf nj nk mf lj nl nm mh ln nn no mj np bi translated">对元素应用函数—使用lambda应用()</h2><p id="c2f3" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><code class="fe ns nt nu nv b">apply()</code>是Series和DataFrame的另一个强大方法，用于对其元素应用函数。最简单的形式是这样的:</p><pre class="kg kh ki kj gt nx nv ny nz aw oa bi"><span id="0876" class="ne lu iq nv b gy ob oc l od oe"><em class="ls"># Define a function </em><br/>def my_function(x):<br/>    do something with x</span><span id="ac2f" class="ne lu iq nv b gy of oc l od oe"><em class="ls"># </em><strong class="nv ir"><em class="ls">Apply to DataFrame</em></strong><em class="ls"> - apply this function to all elements of df</em><br/>df.apply(my_function)   <br/>df.apply(my_function , axis = 0)   --this is default<br/>df.apply(my_function , axis = 1)</span><span id="4948" class="ne lu iq nv b gy of oc l od oe"><em class="ls"># </em><strong class="nv ir"><em class="ls">Apply to Series</em></strong><em class="ls"> - apply function to only one column or one row</em><br/>df[&lt;column&gt;].apply(my_function)<br/>df.loc[&lt;row index&gt;].apply(my_function)</span></pre><p id="d386" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得注意的是，<code class="fe ns nt nu nv b">apply()</code> — <strong class="ky ir">在与DataFrame一起使用时，只有</strong> —可以接受一个“轴”作为参数来控制函数的应用方式——沿着行还是沿着列。这不适用于系列。</p><pre class="kg kh ki kj gt nx nv ny nz aw oa bi"><span id="e123" class="ne lu iq nv b gy ob oc l od oe"><strong class="nv ir">axis</strong><em class="ls">{0 or ‘index’, 1 or ‘columns’}, default 0 </em></span><span id="3e9a" class="ne lu iq nv b gy of oc l od oe">0 or ‘index’: apply function to each column.<br/>1 or ‘columns’: apply function to each row.</span></pre><p id="b4c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在看到了<code class="fe ns nt nu nv b">apply()</code>的一些典型用法</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="4d49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">关于</strong> <code class="fe ns nt nu nv b"><strong class="ky ir">apply()</strong></code>的重要观点</p><ul class=""><li id="f34f" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">它可以使用Python的<code class="fe ns nt nu nv b">lambda</code>构造处理未命名函数——我们可能不总是需要像上面所示的“printme”这样的命名函数，除非该函数太复杂。这是最常见的用法。</li></ul><p id="38e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ns nt nu nv b">df.apply(lambda x: &lt;do something with x&gt;, axis = &lt;some axis&gt;)</code></p><ul class=""><li id="3c17" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">apply还可以使用数据类型的本地转换函数:比如它也可以使用len、np.log等函数。</li><li id="fdb8" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">当应用于DataFrame时，它将“逐行”/“逐列”作为一个序列读取，并将该序列传递给函数。</li><li id="6725" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">它返回一个系列，其索引取决于坐标轴规格。如果我们想要基于现有的列插入或更新行或列，这是很有帮助的。</li></ul><p id="1c98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意</strong>:<em class="ls">“primt me”函数不“返回”任何东西，它只是为了演示数据是如何处理的。这就是为什么我们看到返回序列的结果在值和索引中均为“None”。但在现实世界中，我们会使用</em> <code class="fe ns nt nu nv b"><em class="ls">apply()</em></code> <em class="ls">实际返回序列中的一些值，并使用返回的序列向数据帧添加新内容或过滤数据帧。</em></p></div><div class="ab cl oh oi hu oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="ij ik il im in"><h1 id="a411" class="lt lu iq bd lv lw oo ly lz ma op mc md jw oq jx mf jz or ka mh kc os kd mj mk bi translated">经常被谷歌搜索的话题</h1><p id="581a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">好了，我们准备起飞了！！让我们将这些概念应用于一些最常见的感兴趣的话题。</p><p id="07a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们使用一个非常简单的数据集—人力资源数据—您可以在这里找到<a class="ae kv" href="https://www.kaggle.com/datasets/rhuebner/human-resources-data-set" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="a031" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果读者试图根据上面说明的基本概念来证明或解释每个结果，那将是最好的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h1 id="ff14" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">结束想法…</h1><p id="f49c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">虽然有大量的书籍、博客和知识库承载着大量关于熊猫的知识及其官方文档，但有时合并关于核心概念的笔记是值得的。我试图传达我自己学习基础知识的方式，这可能对某个地方的人有益，在他们陷入更深更黑的水域之前。</p><p id="8a0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以快乐学习。万事如意。</p><p id="4a18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">如果有任何改进/错误需要添加/纠正，您可以随时通过我的链接个人资料联系我，或者在本页的这里写下您的意见。</em></p><p id="2bd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">感谢您的耐心阅读。</em> </strong></p></div></div>    
</body>
</html>