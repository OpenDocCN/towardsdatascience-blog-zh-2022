<html>
<head>
<title>5 Things That Will Instantly Make Your Python Code More Pythonic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让你的Python代码更加Python化的5件事</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-things-that-will-instantly-make-your-python-code-more-pythonic-198c6d371c80#2022-04-27">https://towardsdatascience.com/5-things-that-will-instantly-make-your-python-code-more-pythonic-198c6d371c80#2022-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ae1d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解语言的规则</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/90f2fe6c1d97f625f151164117efee04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RPSrSXQCVIgQrXU3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@ralexnder?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亚历克斯·丘马克</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="79dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何会说多种语言的人都明白，一种语言的规则不一定适用于另一种语言；我的母语是英语，但我也会说Twi语，这是加纳阿坎部落的一种方言。每当我在加纳的时候，我都强迫自己说Twi语——我犯了很多错误，但是当地人很友好，他们帮我解决了问题。</p><p id="f36d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我犯的错误不一定会破坏我所说的意思，这通常只是对Twi语言的糟糕练习，他们在说英语时经常犯同样的错误。例如，加纳人用Twi语交流时，通常会在开始说“请”,所以他们在说英语时也会这样做。</p><p id="801b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然“请是”不一定是英语语法的坏用法，但你可能不会说它。但这个错误源于试图将英语的规则应用于Twi。许多用各种语言编写代码的程序员也陷入了这个陷阱。</p><p id="9786" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的代码可能不会抛出错误，但是当其他程序员试图理解您所写的内容时，您会让他们的日子更难过。花时间去理解一门语言的最佳实践不仅对你自己有益，对那些必须与你合作的人也有益。因此，我们将讨论编写Pythonic代码的五种标准方法。</p><h1 id="e2f6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">#1枚举()而不是范围()</h1><p id="0e5d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">您将看到的最常见的Python误用之一是程序员使用<code class="fe ms mt mu mv b">range()</code>和<code class="fe ms mt mu mv b">len()</code>函数循环遍历一个列表[或序列]并生成索引。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="c227" class="na lw it mv b gy nb nc l nd ne">names = ["john", "doe", "jane", "plane"]<br/><strong class="mv iu">for </strong>idx <strong class="mv iu">in </strong>range(<strong class="mv iu">len</strong>(names)): <br/>    <strong class="mv iu">print</strong>(idx, names[idx])</span><span id="2346" class="na lw it mv b gy nf nc l nd ne">0 john<br/>1 doe<br/>2 jane<br/>3 plane</span></pre><p id="bfe7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您会发现上面的代码是有效的，并且运行良好，那么为什么这是一个问题呢？这违背了Python成为如此成功的编程语言的一个原因:<strong class="lb iu">可读性</strong>。</p><p id="5dfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe ms mt mu mv b">range(len(names))</code>约定很容易做到，但是不太理想，因为它牺牲了可读性。执行相同功能的更好方法是将列表传递给内置的<code class="fe ms mt mu mv b">enumerate()</code>函数，该函数将返回序列中索引和元素的整数。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="faa3" class="na lw it mv b gy nb nc l nd ne">names = ["john", "doe", "jane", "plane"]<br/><strong class="mv iu">for </strong>idx, name <strong class="mv iu">in enumerate</strong>(names): <br/>    <strong class="mv iu">print</strong>(idx, name)</span><span id="788a" class="na lw it mv b gy nf nc l nd ne">0 john<br/>1 doe<br/>2 jane<br/>3 plane</span></pre><p id="48d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不需要索引，那么您仍然可以按如下方式遍历元素:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="58d3" class="na lw it mv b gy nb nc l nd ne">names = ["john", "doe", "jane", "plane"]<br/><strong class="mv iu">for </strong>name <strong class="mv iu">in </strong>names: <br/>    <strong class="mv iu">print</strong>(name)</span><span id="f20f" class="na lw it mv b gy nf nc l nd ne">john <br/>doe<br/>jane<br/>plane</span></pre><h1 id="e885" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">#2使用“with”语句</h1><p id="9630" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">你可能正在编写一个要求你读写文件的程序。<code class="fe ms mt mu mv b">open()</code>和<code class="fe ms mt mu mv b">close()</code>内置函数允许开发者分别打开和关闭文件。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="9428" class="na lw it mv b gy nb nc l nd ne">requirements = open("requirements.txt", "w")<br/>requirements.write(<br/>  "scikit-learn &gt;= 0.24.2, &lt; 0.25.0", <br/>  "numpy &gt;= 1.21.2, &lt; 1.22.0",<br/>  "pandas &gt;= 1.3.3, &lt; 1.4.0"<br/>)<br/>requirements.close() </span></pre><p id="3121" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们打开了一个名为<code class="fe ms mt mu mv b">requirements.txt</code>的文本文件，写了一些内容，然后在完成后关闭它。这段代码是完全有效的，但是Python程序员会称之为<strong class="lb iu"> <em class="ng">不协调</em> </strong>。</p><p id="e57a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也很危险，因为很容易忘记关闭一个文件，有时这是我们无法控制的——比如当一个<code class="fe ms mt mu mv b">try</code>子句发生错误，程序跳过对<code class="fe ms mt mu mv b">except</code>子句的<code class="fe ms mt mu mv b">close()</code>调用。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="203a" class="na lw it mv b gy nb nc l nd ne"><strong class="mv iu">try</strong>: <br/>    requirements = open("requirements.txt", "w")<br/>    requirements.write(<br/>      "scikit-learn &gt;= 0.24.2, &lt; 0.25.0", <br/>      "numpy &gt;= 1.21.2, &lt; 1.22.0",<br/>      "pandas &gt;= 1.3.3, &lt; 1.4.0"<br/>    )<br/>    random_error = 25 / 0 # raises a 0 divide exception<br/>    requirements.close() # this is skipped <br/><strong class="mv iu">except</strong>: <br/>   <strong class="mv iu">print</strong>("An error occurred.")</span></pre><p id="a059" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的场景是不太可能的:我无法想象你写依赖关系，然后除以一些数字的例子。但是灾难的威胁是真实存在的。</p><p id="bec8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，跳过了<code class="fe ms mt mu mv b">close()</code>方法，因为在我们的代码中发现了一个错误，这使得它跳到了<code class="fe ms mt mu mv b">except</code>块。这可能会导致非常难以跟踪的文件损坏错误。</p><p id="8ec2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比较好的方法是<code class="fe ms mt mu mv b">open()</code>和<code class="fe ms mt mu mv b">close()</code>文件如下:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="54b3" class="na lw it mv b gy nb nc l nd ne"><strong class="mv iu">with </strong>open("requirements.txt", "w") as requirements:<br/>    requirements.write(<br/>      "scikit-learn &gt;= 0.24.2, &lt; 0.25.0", <br/>      "numpy &gt;= 1.21.2, &lt; 1.22.0",<br/>      "pandas &gt;= 1.3.3, &lt; 1.4.0"<br/>    )<br/>    requirements.close()</span></pre><p id="50e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码更Pythonic化，也更安全，因为一旦执行离开了<code class="fe ms mt mu mv b">with</code>语句块，文件总是关闭的。</p><h1 id="8c3d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">#3将`<code class="fe ms mt mu mv b">None`</code>值与`<code class="fe ms mt mu mv b">is`</code>值进行比较</h1><p id="fa97" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">将<code class="fe ms mt mu mv b">None</code>值与<code class="fe ms mt mu mv b">is</code>恒等运算符进行比较优于等式运算符<code class="fe ms mt mu mv b">==</code>。</p><blockquote class="nh"><p id="585e" class="ni nj it bd nk nl nm nn no np nq lu dk translated">"应该总是用<code class="fe ms mt mu mv b">is</code>或<code class="fe ms mt mu mv b">is not</code>来比较像None这样的单元组，而不是相等运算符."<br/> -人教版8</p></blockquote><p id="354c" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">原因在于他们如何进行比较:</p><ul class=""><li id="a0a2" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated">相等运算符<code class="fe ms mt mu mv b">==</code>比较两个对象的值。</li><li id="00c0" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><code class="fe ms mt mu mv b">is</code>标识运算符比较两个对象的标识。因此，它是对等式的引用，这意味着它决定了两个对象是否有相同的身份。</li></ul><p id="bffb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这听起来像是行话，简单的说就是在Python中有相同值的两个对象不一定是相同的。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="6f5b" class="na lw it mv b gy nb nc l nd ne"><strong class="mv iu"># Example of equal values and identities</strong><br/>a = [1, 2, 3, 4, 5] <br/>b = a </span><span id="0470" class="na lw it mv b gy nf nc l nd ne"><strong class="mv iu">id</strong>(a) <br/>"""<br/>140049469156864<br/>"""</span><span id="3b39" class="na lw it mv b gy nf nc l nd ne"><strong class="mv iu">id</strong>(b)<br/>"""<br/>140049469156864<br/>"""</span><span id="b510" class="na lw it mv b gy nf nc l nd ne">a is b<br/>"""<br/>True<br/>"""</span><span id="f65f" class="na lw it mv b gy nf nc l nd ne">a == b<br/>"""<br/>True<br/>"""</span><span id="65df" class="na lw it mv b gy nf nc l nd ne"><strong class="mv iu"># Example of equal values but different identities </strong><br/>a = [1, 2, 3, 4, 5] <br/>b = a[:] </span><span id="0967" class="na lw it mv b gy nf nc l nd ne"><strong class="mv iu">id</strong>(a) <br/>"""<br/>139699152256576<br/>"""</span><span id="fe82" class="na lw it mv b gy nf nc l nd ne"><strong class="mv iu">id</strong>(b)<br/>"""<br/>139699151636672<br/>"""</span><span id="528c" class="na lw it mv b gy nf nc l nd ne">a is b<br/>"""<br/>False<br/>"""</span><span id="5d97" class="na lw it mv b gy nf nc l nd ne">a == b<br/>"""<br/>True<br/>"""</span></pre><p id="8e4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你比较一个值和<code class="fe ms mt mu mv b">None</code>时，你应该总是使用<code class="fe ms mt mu mv b">is</code>，因为相等运算符<code class="fe ms mt mu mv b">==</code>仍然可以计算为<code class="fe ms mt mu mv b">True</code>，即使对象实际上是<code class="fe ms mt mu mv b">None</code>。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="6e3b" class="na lw it mv b gy nb nc l nd ne"><strong class="mv iu">class </strong>Example: <br/>    <strong class="mv iu">def</strong> __eq__(self, other=None):<br/>        <strong class="mv iu">return </strong>True</span><span id="8e5d" class="na lw it mv b gy nf nc l nd ne">example = Example()<br/>example == None<br/>"""<br/>True<br/>"""</span><span id="8ae6" class="na lw it mv b gy nf nc l nd ne">example is None<br/>"""<br/>False<br/>"""</span></pre><p id="d757" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种可能性是由于<code class="fe ms mt mu mv b">==</code>操作符过载造成的。执行<code class="fe ms mt mu mv b">example is None</code>会检查<code class="fe ms mt mu mv b">example</code>标识符中的值是否为<code class="fe ms mt mu mv b">None</code>。基本上，如果一个变量被设置为<code class="fe ms mt mu mv b">None</code>，那么比较它，看看它<code class="fe ms mt mu mv b">is None</code>是否总是评估为<code class="fe ms mt mu mv b">True</code>——因为行为是可预测的，所以它是首选的。</p><h1 id="5fc9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">原始字符串有其用途</h1><p id="7974" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Python中以<code class="fe ms mt mu mv b">r</code>或<code class="fe ms mt mu mv b">R</code>为前缀的字符串称为原始字符串。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="4fdc" class="na lw it mv b gy nb nc l nd ne"><strong class="mv iu">print</strong>(r"This is a raw string") <br/>"""<br/>This is a raw string<br/>"""</span><span id="43a5" class="na lw it mv b gy nf nc l nd ne"><strong class="mv iu">print</strong>(R"This is also a raw string")<br/>"""<br/>This is also a raw string<br/>"""</span></pre><p id="34e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原始字符串最常见的用法是当我们处理使用几个转义字符<code class="fe ms mt mu mv b">\</code>的字符串时(即windows路径、正则表达式，或者如果我们想要将文本插入到字符串文字中，否则像<code class="fe ms mt mu mv b">'</code>这样是不可能的)。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="29d4" class="na lw it mv b gy nb nc l nd ne"><strong class="mv iu"><em class="ng"># without raw strings </em></strong></span><span id="32e9" class="na lw it mv b gy nf nc l nd ne"><strong class="mv iu">print</strong>("This is Kurtis\' phone")<br/>"""<br/>This is Kurtis' phone<br/>"""</span><span id="4a0f" class="na lw it mv b gy nf nc l nd ne"><strong class="mv iu">print</strong>("C:\\Users\\kurtis\\documents") <br/>"""<br/>C:\Users\kurtis\documents<br/>"""</span><span id="ff53" class="na lw it mv b gy nf nc l nd ne"><strong class="mv iu"><em class="ng"># with raw strings</em></strong> </span><span id="cca7" class="na lw it mv b gy nf nc l nd ne"><strong class="mv iu">print</strong>(r"This is Kurtis' phone")<br/>"""<br/>This is Kurtis' phone<br/>"""</span><span id="5e4a" class="na lw it mv b gy nf nc l nd ne"><strong class="mv iu">print</strong>(r"C:\Users\kurtis\documents")"""<br/>C:\Users\kurtis\documents<br/>"""</span></pre><p id="c21e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原始字符串不应该被认为是不同类型的字符串数据类型——它不是。这只是键入包含几个反斜杠的字符串的一种便捷方式。</p><h1 id="3182" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">f字符串更适合格式化代码</h1><p id="df94" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Python 3.6中添加的新特性之一是f字符串(格式字符串的简写)。它们提供了一种更简洁、更方便的方法来格式化字符串——也符合Python的可读性对象。</p><p id="6b61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解它的有用性，我们必须了解它的发展历程。最初<code class="fe ms mt mu mv b">+</code>操作符用于连接字符串:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="5e3e" class="na lw it mv b gy nb nc l nd ne">name = "John"<br/>age = "30"<br/>city = "London"</span><span id="6170" class="na lw it mv b gy nf nc l nd ne"><strong class="mv iu">print</strong>("Hi, my name is " + name + " and I'm " + age + " years old. I live in " + city )</span></pre><p id="7890" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管这种方法可行，但它包含了几个引号和<code class="fe ms mt mu mv b">+</code>操作符，这会影响可读性。</p><p id="5810" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python随后引入了转换说明符<code class="fe ms mt mu mv b">%s</code>使其更加具体:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="3b60" class="na lw it mv b gy nb nc l nd ne">name = "John"<br/>age = "30"<br/>city = "London"</span><span id="e544" class="na lw it mv b gy nf nc l nd ne"><strong class="mv iu">print</strong>("Hi, my name is %s and I'm %s years old. I live in %s" % (name, age, city))</span></pre><p id="8b56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也是可行的，但是对于可读性来说仍然不是最好的。</p><p id="b71b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们如何用f弦做同样的事情:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="0648" class="na lw it mv b gy nb nc l nd ne">name = "John"<br/>age = "30"<br/>city = "London"</span><span id="2ef5" class="na lw it mv b gy nf nc l nd ne"><strong class="mv iu">print</strong>(f"Hi, my name is {name} and I'm {age} years old. I live in {city}")</span></pre><p id="23a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">干净多了，也更像蟒蛇了。</p><p id="5973" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ng">感谢您的阅读。</em></p><p id="2a1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">联系我:</strong><br/><a class="ae ky" href="https://www.linkedin.com/in/kurtispykes/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a><br/><a class="ae ky" href="https://twitter.com/KurtisPykes" rel="noopener ugc nofollow" target="_blank">Twitter</a><br/><a class="ae ky" href="https://www.instagram.com/kurtispykes/" rel="noopener ugc nofollow" target="_blank">insta gram</a></p><p id="a9ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢阅读这样的故事，并希望支持我的写作，可以考虑成为一名灵媒。每月支付5美元，你就可以无限制地阅读媒体上的故事。如果你使用<a class="ae ky" href="https://kurtispykes.medium.com/membership" rel="noopener">我的注册链接</a>，我会收到一小笔佣金。</p><p id="657c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">已经是会员了？<a class="ae ky" href="https://kurtispykes.medium.com/subscribe" rel="noopener">订阅</a>在我发布时得到通知。</p><div class="ok ol gp gr om on"><a href="https://kurtispykes.medium.com/subscribe" rel="noopener follow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">每当Kurtis Pykes发表文章时都收到一封电子邮件。</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">每当Kurtis Pykes发表文章时都收到一封电子邮件。通过注册，您将创建一个中型帐户，如果您还没有…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">kurtispykes.medium.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb ks on"/></div></div></a></div></div></div>    
</body>
</html>