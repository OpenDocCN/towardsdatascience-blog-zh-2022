<html>
<head>
<title>DISTINCT is not a SQL Function</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DISTINCT不是SQL函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sql-select-distinct-277c61012800#2022-09-09">https://towardsdatascience.com/sql-select-distinct-277c61012800#2022-09-09</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="bb95" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">在SQL中使用DISTINCT关键字时，括号的使用如何会导致混淆</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/5f4e7b536a1bf6537ef0056878368c84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WSvJyEN0RLmIfERtNchRZQ.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">斯科特·韦伯在<a class="ae kz" href="https://unsplash.com/s/photos/unique?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="c5ba" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">许多SQL用户(甚至是更有经验的用户)最常犯的一个错误是将<code class="fe lw lx ly lz b">DISTINCT</code>应用于指定列的方式。常见的情况是，SQL查询试图对查询需要返回的列子集应用一个<code class="fe lw lx ly lz b">SELECT DISTINCT</code>子句。</p><p id="c206" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">误解在于这样一种观点，即<code class="fe lw lx ly lz b">DISTINCT</code>是一个基本上接受它将要应用的列名的函数，而在计算结果时不会考虑在“函数调用”之外指定的列。</p><p id="92ab" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是在现实中，当试图使用圆括号来使<code class="fe lw lx ly lz b">DISTINCT</code>只对圆括号中的列有效时，并不会像你期望的那样工作。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><p id="3afd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在让我们创建一个示例表，我们将在本文中引用它来演示一些概念，并帮助我们准确地阐明<code class="fe lw lx ly lz b">DISTINCT</code>关键字在SQL中是如何工作的。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mh mi l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">创建示例租赁表—来源:作者</p></figure><p id="7339" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在让我们在新创建的<code class="fe lw lx ly lz b">address</code>表中添加一些记录。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mh mi l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">将示例行添加到我们的示例租赁表中—来源:Author</p></figure><p id="0c8b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在让我们查询结果以查看最终的示例表:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mh mi l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">示例租赁表的内容—来源:作者</p></figure></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h2 id="d688" class="mj mk iu bd ml mm mn dn mo mp mq dp mr lj ms mt mu ln mv mw mx lr my mz na nb bi translated">对SQL中DISTINCT的误解</h2><p id="bc59" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">现在假设我们想从我们的<code class="fe lw lx ly lz b">rental</code>表中获得不同的行，使用两个不同的字段，即<code class="fe lw lx ly lz b">customer_id</code>和<code class="fe lw lx ly lz b">store_id</code>。换句话说，我们想回答以下问题:</p><blockquote class="nh ni nj"><p id="42b8" class="la lb nk lc b ld le jv lf lg lh jy li nl lk ll lm nm lo lp lq nn ls lt lu lv in bi translated">我们的租赁表中<code class="fe lw lx ly lz b">customer_id</code>和<code class="fe lw lx ly lz b">store_id</code>有哪些独特的组合？</p></blockquote><p id="d93c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了回答上面的查询，我们可以简单地查询我们的表并获取<code class="fe lw lx ly lz b">customer_id</code>和<code class="fe lw lx ly lz b">store_id</code>列的<code class="fe lw lx ly lz b">DISTINCT</code>值:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mh mi l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">选择租赁表中customer_id和store_id字段的唯一组合-来源:作者</p></figure><p id="f74e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，如果我们只想检索一组唯一的客户，这样在上面的查询结果中，我们只能看到每个客户的一行，那么我们需要细化我们的查询来做到这一点。</p><p id="0f47" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这正是对<code class="fe lw lx ly lz b">DISTINCT</code>的误解所在。很多用户，都有(错！)印象中，<code class="fe lw lx ly lz b">DISTINCT</code>是一个函数，在这个函数中，我们可以指定在将它应用于目标表时要考虑的列。</p><p id="3dcc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您在“调用”时试图将<code class="fe lw lx ly lz b">customer_id</code>括在圆括号中(这里不是正确的动词，因为这不是一个函数)<code class="fe lw lx ly lz b">DISTINCT</code>，您会注意到它根本不起作用:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mh mi l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用括号中的列选择DISTINCT来源:作者</p></figure><p id="4e7e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们仍然可以在查询结果中看到“重复的”客户id。这是因为<code class="fe lw lx ly lz b">SELECT DISTINCT</code>子句，将总是考虑所有指定的列名，不管它们是否被括在括号中。</p><p id="f4aa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">事实上，下面显示的所有表达式确实是等价的:</p><ul class=""><li id="e59a" class="no np iu lc b ld le lg lh lj nq ln nr lr ns lv nt nu nv nw bi translated"><code class="fe lw lx ly lz b">SELECT DISTINCT customer_id, store_id FROM rental;</code></li><li id="248a" class="no np iu lc b ld nx lg ny lj nz ln oa lr ob lv nt nu nv nw bi translated"><code class="fe lw lx ly lz b">SELECT DISTINCT (customer_id), store_id FROM rental;</code></li><li id="5bbe" class="no np iu lc b ld nx lg ny lj nz ln oa lr ob lv nt nu nv nw bi translated"><code class="fe lw lx ly lz b">SELECT DISTINCT (customer_id), (store_id) FROM rental;</code></li><li id="0012" class="no np iu lc b ld nx lg ny lj nz ln oa lr ob lv nt nu nv nw bi translated"><code class="fe lw lx ly lz b">SELECT DISTINCT (store_id), customer_id FROM rental;</code></li><li id="de78" class="no np iu lc b ld nx lg ny lj nz ln oa lr ob lv nt nu nv nw bi translated"><code class="fe lw lx ly lz b">SELECT DISTINCT ((customer_id)), store_id FROM rental;</code></li></ul><p id="3dcd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，我强烈建议<strong class="lc iv">在将</strong> <code class="fe lw lx ly lz b"><strong class="lc iv">SELECT</strong></code> <strong class="lc iv">子句与</strong> <code class="fe lw lx ly lz b"><strong class="lc iv">DISTINCT</strong></code> <strong class="lc iv">限定词</strong>一起使用时避免使用括号，因为这可能会使其他人(他们可能不知道我们今天讨论的内容)误解查询，并意外地认为您的意图是在单个列上应用<code class="fe lw lx ly lz b">DISTINCT</code>，尽管我们已经演示过这是不可能的。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h2 id="3ad6" class="mj mk iu bd ml mm mn dn mo mp mq dp mr lj ms mt mu ln mv mw mx lr my mz na nb bi translated">PostgreSQL和DISTINCT ON</h2><p id="8fac" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">如果您正在使用Postgres，并且希望将<code class="fe lw lx ly lz b">DISTINCT</code>仅应用于您想要在结果中检索的列的子集，那么您可以利用<code class="fe lw lx ly lz b">DISTINCT ON</code>。</p><blockquote class="nh ni nj"><p id="9299" class="la lb nk lc b ld le jv lf lg lh jy li nl lk ll lm nm lo lp lq nn ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">SELECT DISTINCT</code>从结果中删除重复行。</p><p id="66c5" class="la lb nk lc b ld le jv lf lg lh jy li nl lk ll lm nm lo lp lq nn ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">SELECT DISTINCT ON</code>消除与所有指定表达式匹配的行。</p><p id="03d6" class="la lb nk lc b ld le jv lf lg lh jy li nl lk ll lm nm lo lp lq nn ls lt lu lv in bi translated">— Postgres <a class="ae kz" href="https://www.postgresql.org/docs/current/sql-select.html" rel="noopener ugc nofollow" target="_blank">文档</a></p></blockquote><p id="f674" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是建立在标准SQL的<code class="fe lw lx ly lz b">DISTINCT</code>之上的扩展，它返回匹配指定表达式的每组行的第一行。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mh mi l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">SQL中带有DISTINCT ON子句的示例—来源:作者</p></figure><p id="dbf0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是请注意，当使用<code class="fe lw lx ly lz b">DISTINCT ON</code>时，使用<code class="fe lw lx ly lz b">ORDER BY</code>子句也是有意义的。这样，您将能够指定从冲突的行中挑选所需结果的条件。例如，如果有两行匹配您的表达式(在上面的例子中，我们有两条记录符合id为<code class="fe lw lx ly lz b">100</code>的客户)。</p><p id="77a2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，让我们假设我们想要获取具有相应商店ID的唯一客户ID，但是这一次，如果存在多个竞争行，我们想要获取具有最小数量的行:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mh mi l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">选择DISTINCT ON with ORDER BY来源:作者</p></figure><p id="bee3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">请注意，对应于<code class="fe lw lx ly lz b">customer_id=100</code>的<code class="fe lw lx ly lz b">store_id</code>已经更改，因为金额最小的租赁行已经不同，因为我们已经按金额升序对结果进行了排序。</p><p id="ab91" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是一般来说，如果你真的不在乎顺序，那么你可以忽略它。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h2 id="4acd" class="mj mk iu bd ml mm mn dn mo mp mq dp mr lj ms mt mu ln mv mw mx lr my mz na nb bi translated">最后的想法</h2><p id="f311" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">理解SQL中的<code class="fe lw lx ly lz b">DISTINCT</code>关键字如何与<code class="fe lw lx ly lz b">SELECT</code>语句一起工作是很重要的，因为这对许多用户来说是一个困惑的来源——我甚至可以说对有经验的用户来说也是如此。</p><p id="3ed9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当编写带有<code class="fe lw lx ly lz b">SELECT DISTINCT</code>子句的查询时，许多用户倾向于像使用适当的SQL函数一样使用<code class="fe lw lx ly lz b">DISTINCT</code>。换句话说，它们将一列括在括号中，同时在子句后提供更多的列名，例如<code class="fe lw lx ly lz b">SELECT DISTINCT(user_id), first_name FROM ...</code>。</p><p id="7418" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当阅读这样的查询时(显然还有编写它们的人)，您可能最终会认为<code class="fe lw lx ly lz b">SELECT DISTINCT</code>只适用于指定的列(例如<code class="fe lw lx ly lz b">user_id</code>)，而不适用于剩余的列(例如<code class="fe lw lx ly lz b">first_name</code>)。正如我们在今天的文章中看到的，在编写查询时，这是一个误解和非常危险的假设。</p><p id="acc1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，我们讨论了PostgreSQL数据库中的一个特例，它允许用户使用特殊的<code class="fe lw lx ly lz b">DISTINCT ON</code>子句明确指定在应用<code class="fe lw lx ly lz b">DISTINCT</code>时要考虑的列。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><p id="1b77" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><a class="ae kz" href="https://gmyrianthous.medium.com/membership" rel="noopener"> <strong class="lc iv">成为会员</strong> </a> <strong class="lc iv">阅读介质上的每一个故事。你的会员费直接支持我和你看的其他作家。你也可以在媒体上看到所有的故事。</strong></p><div class="oc od gq gs oe of"><a href="https://gmyrianthous.medium.com/membership" rel="noopener follow" target="_blank"><div class="og ab fp"><div class="oh ab oi cl cj oj"><h2 class="bd iv gz z fq ok fs ft ol fv fx it bi translated">通过我的推荐链接加入Medium-Giorgos Myrianthous</h2><div class="om l"><h3 class="bd b gz z fq ok fs ft ol fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="on l"><p class="bd b dl z fq ok fs ft ol fv fx dk translated">gmyrianthous.medium.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot kt of"/></div></div></a></div></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><p id="676e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">相关文章你可能也喜欢</strong></p><div class="oc od gq gs oe of"><a rel="noopener follow" target="_blank" href="/ddl-dml-e802a25076c6"><div class="og ab fp"><div class="oh ab oi cl cj oj"><h2 class="bd iv gz z fq ok fs ft ol fv fx it bi translated">DDL和DML是什么？</h2><div class="om l"><h3 class="bd b gz z fq ok fs ft ol fv fx dk translated">理解SQL中DDL和DML的区别</h3></div><div class="on l"><p class="bd b dl z fq ok fs ft ol fv fx dk translated">towardsdatascience.com</p></div></div><div class="oo l"><div class="ou l oq or os oo ot kt of"/></div></div></a></div></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu of"><a rel="noopener follow" target="_blank" href="/star-schema-924b995a9bdf"><div class="og ab fp"><div class="oh ab oi cl cj oj"><h2 class="bd iv gz z fq ok fs ft ol fv fx it bi translated">事实与维度表</h2><div class="om l"><h3 class="bd b gz z fq ok fs ft ol fv fx dk translated">在星型模式和数据仓库的上下文中理解事实表和维度表之间的区别</h3></div><div class="on l"><p class="bd b dl z fq ok fs ft ol fv fx dk translated">towardsdatascience.com</p></div></div><div class="oo l"><div class="ov l oq or os oo ot kt of"/></div></div></a></div></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu of"><a rel="noopener follow" target="_blank" href="/standard-vs-legacy-sql-bigquery-6d01fa3046a9"><div class="og ab fp"><div class="oh ab oi cl cj oj"><h2 class="bd iv gz z fq ok fs ft ol fv fx it bi translated">BigQuery中的标准SQL与传统SQL</h2><div class="om l"><h3 class="bd b gz z fq ok fs ft ol fv fx dk translated">理解标准SQL和遗留SQL在Google Cloud BigQuery环境中的区别</h3></div><div class="on l"><p class="bd b dl z fq ok fs ft ol fv fx dk translated">towardsdatascience.com</p></div></div><div class="oo l"><div class="ow l oq or os oo ot kt of"/></div></div></a></div></div></div>    
</body>
</html>