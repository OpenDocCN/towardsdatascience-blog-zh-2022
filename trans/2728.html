<html>
<head>
<title>Docker for Data Science</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学码头工人</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/docker-for-data-science-7927fb3c70d3#2022-06-13">https://towardsdatascience.com/docker-for-data-science-7927fb3c70d3#2022-06-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0fbb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">每个数据科学家都应该了解的Docker</h2></div><h2 id="93fb" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Docker是什么？</h2><p id="330a" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">想象一下，你是一名在空间站的宇航员，打算去外面欣赏风景。你将面临敌对的环境。温度、氧气和辐射都不是你生来的目的。人类需要特定的环境才能茁壮成长。为了在任何其他场景中正常工作，比如在深海或高空，我们需要一个系统来重现这种环境。无论是宇航服还是潜艇，我们都需要隔离，以及确保我们所依赖的氧气、压力和温度水平的东西。</p><p id="7ab4" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">换句话说，我们需要一个容器。</p><p id="4008" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">任何软件都面临着和宇航员一样的问题。一旦我们离开家，来到外面的世界，环境变得充满敌意，一种复制我们自然环境的保护机制是强制性的。Docker容器是程序的宇航服。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/53119b3016a7619188996f9a2b7612d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/0*-8cSGy2pQHXJyIhH.png"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">作者图片</p></figure><p id="cb49" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">Docker将软件与同一系统上的所有其他东西隔离开来。在“宇航服”内运行的程序通常不知道自己穿着宇航服，也不受外界发生的任何事情的影响。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ml"><img src="../Images/b013e43a5b34f80e8410fa868831e2a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tw2fh40uVV0FoTGJ.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">作者图片</p></figure><p id="eace" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">集装箱堆栈</p><ul class=""><li id="9609" class="mq mr iq ld b le lu lh lv ko ms ks mt kw mu lt mv mw mx my bi translated"><strong class="ld ir">应用:</strong>高层应用(你的数据科学项目)</li><li id="c1af" class="mq mr iq ld b le mz lh na ko nb ks nc kw nd lt mv mw mx my bi translated"><strong class="ld ir">依赖:</strong>低级通用软件(想想Tensorflow或Python)</li><li id="6aad" class="mq mr iq ld b le mz lh na ko nb ks nc kw nd lt mv mw mx my bi translated"><strong class="ld ir"> Docker容器:</strong>隔离层</li><li id="0e2a" class="mq mr iq ld b le mz lh na ko nb ks nc kw nd lt mv mw mx my bi translated"><strong class="ld ir">操作系统:</strong>与硬件交互的低级接口和驱动程序</li><li id="9b61" class="mq mr iq ld b le mz lh na ko nb ks nc kw nd lt mv mw mx my bi translated"><strong class="ld ir">硬件:</strong> CPU、内存、硬盘、网络等。</li></ul><p id="38c4" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">基本思想是将应用程序及其依赖项打包到一个可重用的工件中，该工件可以在不同的环境中可靠地实例化。</p><h1 id="fd08" class="ne kg iq bd kh nf ng nh kk ni nj nk kn jw nl jx kr jz nm ka kv kc nn kd kz no bi translated">如何创建容器？</h1><p id="6026" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">创建Docker容器的流程:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi np"><img src="../Images/502b75212f9cae26b6910cded3588edb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5xh0hEBdWXbuJB8w.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">作者图片</p></figure><ol class=""><li id="d562" class="mq mr iq ld b le lu lh lv ko ms ks mt kw mu lt nq mw mx my bi translated"><strong class="ld ir"> Dockerfile: </strong>编译图像的说明</li><li id="0cb3" class="mq mr iq ld b le mz lh na ko nb ks nc kw nd lt nq mw mx my bi translated"><strong class="ld ir">图片:</strong>编译好的神器</li><li id="bc44" class="mq mr iq ld b le mz lh na ko nb ks nc kw nd lt nq mw mx my bi translated"><strong class="ld ir">容器:</strong>图像的执行实例</li></ol><h1 id="46a4" class="ne kg iq bd kh nf ng nh kk ni nj nk kn jw nl jx kr jz nm ka kv kc nn kd kz no bi translated">Dockerfile文件</h1><p id="ee3b" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">首先，我们需要说明。</p><p id="e5db" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">我们可以定义宇航服的温度、辐射和氧气水平，但我们需要的是说明，而不是要求。Docker是基于指令的，而不是基于需求的。我们将描述如何，而不是什么。为此，我们创建了一个文本文件，并将其命名为Dockerfile。</p><pre class="ma mb mc md gt nr ns nt nu aw nv bi"><span id="4201" class="kf kg iq ns b gy nw nx l ny nz"># Dockerfile<br/>FROM python:3.9<br/>RUN pip install tensorflow==2.7.0<br/>RUN pip install pandas==1.3.3</span></pre><p id="5109" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated"><code class="fe oa ob oc ns b">FROM</code>命令描述了一个基础环境，所以我们不需要从头开始。从<a class="ae od" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> DockerHub </a>或通过谷歌搜索可以找到大量的基础图片。</p><p id="2d9e" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated"><code class="fe oa ob oc ns b">RUN</code>命令是改变环境的指令。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/cd44c694cdd837b1091a6e9fd00b0746.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/0*qsv2VrHr8vUjV9uZ.png"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">作者图片</p></figure><p id="a703" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">注意:虽然我们的例子是一个接一个地安装Python库，但不推荐这样做。最佳实践是利用<code class="fe oa ob oc ns b">requirements.txt</code>，它定义了Python的依赖性。</p><pre class="ma mb mc md gt nr ns nt nu aw nv bi"><span id="f9f8" class="kf kg iq ns b gy nw nx l ny nz"># Dockerfile with requirements.txt<br/>FROM python:3.9<br/>COPY requirements.txt /tmp<br/>RUN pip install -r /tmp/requirements.txt</span></pre><p id="457b" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated"><code class="fe oa ob oc ns b">COPY</code>命令将本地磁盘上的一个文件(如<code class="fe oa ob oc ns b">requirements.txt</code>)复制到映像中。这里的<code class="fe oa ob oc ns b">RUN</code>命令一次性安装了在<code class="fe oa ob oc ns b">requirements.txt</code>中定义的所有Python依赖项。</p><p id="0084" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">注意:使用RUN时，所有熟悉的Linux命令都由您支配。</p><h1 id="eb03" class="ne kg iq bd kh nf ng nh kk ni nj nk kn jw nl jx kr jz nm ka kv kc nn kd kz no bi translated">Docker图像</h1><p id="8916" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">现在我们有了我们的<code class="fe oa ob oc ns b">Dockerfile</code>，我们可以把它编译成一个叫做图像的二进制工件。</p><p id="3b7a" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">这一步的原因是使它更快和可重复。如果我们不编译它，每个需要宇航服的人都需要找到一台缝纫机，并费力地运行每次太空行走的所有指令。这太慢了，而且不确定。你的缝纫机可能和我的不同。速度和质量的权衡是图像可能相当大，通常是千兆字节，但无论如何，2022年的千兆字节是微不足道的。</p><p id="a8d2" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">要进行编译，请使用build命令:</p><pre class="ma mb mc md gt nr ns nt nu aw nv bi"><span id="3835" class="kf kg iq ns b gy nw nx l ny nz">docker build . -t myimage:1.0</span></pre><p id="6997" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">这将构建一个存储在本地机器上的映像。t参数将图像名称定义为“myimage”，并给它一个标记“1.0”。要列出所有图像，请运行:</p><pre class="ma mb mc md gt nr ns nt nu aw nv bi"><span id="503b" class="kf kg iq ns b gy nw nx l ny nz">docker image list<br/>REPOSITORY          TAG                 IMAGE ID            SIZE<br/>&lt;none&gt;              &lt;none&gt;              85eb1ea6d4be        2.9GB<br/>myimagename         1.0                 ff732d925c6e        2.9GB<br/>myimagename         1.1                 ff732d925c6e        2.9GB<br/>myimagename         latest              ff732d925c6e        2.9GB<br/>python              3.9                 f88f0508dc46        912MB</span></pre><h1 id="5801" class="ne kg iq bd kh nf ng nh kk ni nj nk kn jw nl jx kr jz nm ka kv kc nn kd kz no bi translated">码头集装箱</h1><p id="9b00" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">最后，我们为太空行走做好了准备。容器是宇航服的真实实例。它们在衣柜里没什么用处，所以宇航员应该穿着它们执行一两项任务。</p><p id="3b5c" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">指令可以嵌入到映像中，或者在启动容器之前及时提供。让我们做后者。</p><pre class="ma mb mc md gt nr ns nt nu aw nv bi"><span id="8731" class="kf kg iq ns b gy nw nx l ny nz">docker run myimagename:1.0 echo "Hello world"</span></pre><p id="0a06" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">这将启动容器，运行一个echo命令，然后关闭它。</p><p id="3b1b" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">现在我们有了一个可重现的方法，可以在任何支持Docker的环境中执行我们的代码。这在数据科学中非常重要，因为每个项目都有许多依赖项，而可再现性是这个过程的核心。</p><p id="8749" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">容器在执行完指令后会自动关闭，但是容器可以运行很长时间。尝试在后台启动一个很长的命令(使用shell的<code class="fe oa ob oc ns b">&amp;</code>操作符):</p><pre class="ma mb mc md gt nr ns nt nu aw nv bi"><span id="fff8" class="kf kg iq ns b gy nw nx l ny nz">docker run myimagename:1.0 sleep 100000000000 &amp;</span></pre><p id="c6e0" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">您可以看到我们当前运行的容器:</p><pre class="ma mb mc md gt nr ns nt nu aw nv bi"><span id="edc8" class="kf kg iq ns b gy nw nx l ny nz">docker container list</span></pre><p id="f58c" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">要停止这个容器，从表中取出容器ID并调用:</p><pre class="ma mb mc md gt nr ns nt nu aw nv bi"><span id="4128" class="kf kg iq ns b gy nw nx l ny nz">docker stop &lt;CONTAINER ID&gt;</span></pre><p id="f610" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">这停止了容器，但是它的状态保持不变。如果你打电话</p><pre class="ma mb mc md gt nr ns nt nu aw nv bi"><span id="3546" class="kf kg iq ns b gy nw nx l ny nz">docker ps -a</span></pre><p id="ef31" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">您可以看到容器已停止，但仍然存在。彻底摧毁它:</p><pre class="ma mb mc md gt nr ns nt nu aw nv bi"><span id="fcb8" class="kf kg iq ns b gy nw nx l ny nz">docker rm &lt;CONTAINER ID&gt;</span></pre><p id="bbb8" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">结合停止和删除的单一命令:</p><pre class="ma mb mc md gt nr ns nt nu aw nv bi"><span id="23ab" class="kf kg iq ns b gy nw nx l ny nz">docker rm -f &lt;CONTAINER_ID&gt;</span></pre><p id="2c81" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">要移除所有停止的剩余容器:</p><pre class="ma mb mc md gt nr ns nt nu aw nv bi"><span id="4421" class="kf kg iq ns b gy nw nx l ny nz">docker container prune</span></pre><p id="041c" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">提示:您也可以使用交互式shell启动容器:</p><pre class="ma mb mc md gt nr ns nt nu aw nv bi"><span id="9303" class="kf kg iq ns b gy nw nx l ny nz">$ docker run -it myimagename:1.0 /bin/bash<br/>root@9c4060d0136e:/# echo "hello"<br/>hello<br/>root@9c4060d0136e:/# exit<br/>exit<br/>$ &lt;back in the host shell&gt;</span></pre><p id="5891" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">当您可以自由地交互运行所有Linux命令时，这对于调试映像的内部工作非常有用。通过运行<code class="fe oa ob oc ns b">exit</code>命令返回到您的主机shell。</p><h1 id="7ffb" class="ne kg iq bd kh nf ng nh kk ni nj nk kn jw nl jx kr jz nm ka kv kc nn kd kz no bi translated">术语和命名</h1><p id="a934" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated"><strong class="ld ir">注册表</strong> =托管和分发图像的服务。默认的注册中心是Docker Hub。</p><p id="3db8" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated"><strong class="ld ir">存储库</strong> =名称相同但标签不同的相关图像的集合。通常，同一应用程序或服务的不同版本。</p><p id="042b" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated"><strong class="ld ir">标签</strong> =附加到存储库中图像的标识符(例如，14.04或stable)</p><p id="6483" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated"><strong class="ld ir"> ImageID </strong> =为每个图像生成的唯一标识符哈希</p><p id="d264" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">官方文件宣称:</p><p id="25ce" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated"><em class="of">映像名称由斜杠分隔的名称组成，可以选择以注册表主机名作为前缀。</em></p><p id="d218" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">这意味着您可以将注册表主机名和一串斜杠分隔的“名称组件”编码成您的映像的名称。老实说，这很复杂，但这就是生活。</p><p id="85db" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">基本格式是:</p><pre class="ma mb mc md gt nr ns nt nu aw nv bi"><span id="3db4" class="kf kg iq ns b gy nw nx l ny nz">&lt;name&gt;:&lt;tag&gt;</span></pre><p id="1898" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">但实际上是:</p><pre class="ma mb mc md gt nr ns nt nu aw nv bi"><span id="39a1" class="kf kg iq ns b gy nw nx l ny nz">&lt;registry&gt;/&lt;name-component-1&gt;/&lt;name-component-2&gt;:&lt;tag&gt;</span></pre><p id="286d" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">它可能因平台而异。对于谷歌云平台(GCP)，惯例是:</p><pre class="ma mb mc md gt nr ns nt nu aw nv bi"><span id="7e89" class="kf kg iq ns b gy nw nx l ny nz">&lt;registry&gt;/&lt;project-id&gt;/&lt;repository-name&gt;/&lt;img&gt;@&lt;img-digest&gt;:&lt;tag&gt;</span></pre><p id="8d01" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">为您的案例找出正确的命名方案取决于您。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/dda8763f4e0f57e934247e5516947d3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/0*2rgduDu2ScZMqszx.png"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">作者图片</p></figure><p id="0221" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">注意:如果你拉一个没有任何标签的图像，将使用<code class="fe oa ob oc ns b">latest</code>标签。切勿在生产中使用此<code class="fe oa ob oc ns b">latest</code>标签。始终使用具有唯一版本或散列的标签，因为有人不可避免地会更新“最新”图像并破坏您的构建。今天最新的，明天不再最新！宇航员不关心最新的花里胡哨。他们只是想要一套适合他们的宇航服，让他们活下去。和<code class="fe oa ob oc ns b">latest</code>在一起，你可能得不到你想要的。</p><h1 id="0109" class="ne kg iq bd kh nf ng nh kk ni nj nk kn jw nl jx kr jz nm ka kv kc nn kd kz no bi translated">码头工人的形象和秘密</h1><p id="c406" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">就像将秘密放入git存储库是一种可怕的做法一样，您也不应该将它们放入Docker映像中！</p><p id="c36f" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">图像被放入储存库并被随意传递。正确的假设是，进入图像的任何内容在某个时候都可能是公开的。它不是存放用户名、密码、API令牌、密钥代码、TLS证书或任何其他敏感数据的地方。</p><p id="bb84" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">机密和docker图像有两种情况:</p><ol class=""><li id="b3c2" class="mq mr iq ld b le lu lh lv ko ms ks mt kw mu lt nq mw mx my bi translated">在构建时你需要一个秘密</li><li id="b7ab" class="mq mr iq ld b le mz lh na ko nb ks nc kw nd lt nq mw mx my bi translated">运行时你需要一个秘密</li></ol><p id="a830" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">这两种情况都不能通过把事情永久地放入图像中来解决。让我们看看如何以不同的方式来做这件事。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi og"><img src="../Images/6c1ff7ca056d20a52041e525fab862e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/0*aj_WF-x43JT7m-mu.png"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">作者图片</p></figure><h1 id="c5c9" class="ne kg iq bd kh nf ng nh kk ni nj nk kn jw nl jx kr jz nm ka kv kc nn kd kz no bi translated">构建时秘密</h1><p id="80de" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">如果您需要一些私有的东西——比如一个私有的GitHub存储库——在构建时放入映像中，您需要确保您使用的SSH密钥不会泄漏到映像中。</p><p id="54a7" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">不要使用复制指令将密钥或密码移动到映像中！即使你事后把它们拿掉，它们还是会留下痕迹！</p><p id="0f8e" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">快速搜索会给你很多不同的选择来解决这个问题，比如使用多阶段构建，但是最好和最现代的方法是使用BuildKit。BuildKit随Docker一起提供，但是需要通过设置环境变量<code class="fe oa ob oc ns b">DOCKER_BUILDKIT</code>来启用构建。</p><p id="b229" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">例如:</p><pre class="ma mb mc md gt nr ns nt nu aw nv bi"><span id="7854" class="kf kg iq ns b gy nw nx l ny nz">DOCKER_BUILDKIT=1 docker build .</span></pre><p id="ed04" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">BuildKit提供了一种机制，使秘密文件在构建过程中安全可用。</p><p id="be60" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">让我们首先用内容创建<code class="fe oa ob oc ns b">secret.txt</code>:</p><pre class="ma mb mc md gt nr ns nt nu aw nv bi"><span id="52c4" class="kf kg iq ns b gy nw nx l ny nz">TOP SECRET ASTRONAUT PASSWORD</span></pre><p id="7638" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">然后创建一个新的<code class="fe oa ob oc ns b">Dockerfile</code>:</p><pre class="ma mb mc md gt nr ns nt nu aw nv bi"><span id="85cc" class="kf kg iq ns b gy nw nx l ny nz">FROM alpine<br/>RUN --mount=type=secret,id=mypass cat /run/secrets/mypass</span></pre><p id="22cd" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated"><code class="fe oa ob oc ns b">--mount=type=secret,id=mypass</code>通知Docker，对于这个特定的命令，我们需要访问一个名为mypass的秘密(其内容我们将在下一步告诉Docker build)。Docker将通过临时挂载一个文件<code class="fe oa ob oc ns b">/run/secrets/mypass</code>来实现这一点。</p><p id="8427" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated"><code class="fe oa ob oc ns b">cat /run/secrets/mypass</code>是实际的指令，其中cat是将文件内容输出到终端的Linux命令。我们称之为验证我们的秘密确实可用。</p><p id="9cb2" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">让我们构建图像，添加<code class="fe oa ob oc ns b">--secret</code>来通知<code class="fe oa ob oc ns b">docker build</code>在哪里可以找到这个秘密:</p><pre class="ma mb mc md gt nr ns nt nu aw nv bi"><span id="a1e3" class="kf kg iq ns b gy nw nx l ny nz">DOCKER_BUILDKIT=1 docker build . -t myimage \<br/>    --secret id=mypass,src=secret.txt</span></pre><p id="8ea2" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">一切正常，但是我们并没有像预期的那样看到secret.txt的内容在我们的终端中打印出来。原因是默认情况下，BuildKit不会记录每一次成功。</p><p id="54c0" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">让我们使用附加参数来构建图像。我们添加了<code class="fe oa ob oc ns b">BUILDKIT_PROGRESS=plain</code>来获得更详细的日志记录，添加了<code class="fe oa ob oc ns b">--no-cache</code>来确保缓存不会破坏日志记录:</p><pre class="ma mb mc md gt nr ns nt nu aw nv bi"><span id="5a2d" class="kf kg iq ns b gy nw nx l ny nz">DOCKER_BUILDKIT=1 BUILDKIT_PROGRESS=plain docker build . \<br/>    --no-cache --secret id=mypass,src=secret.txt</span></pre><p id="ae89" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">在所有打印出来的日志中，您应该会发现这一部分:</p><pre class="ma mb mc md gt nr ns nt nu aw nv bi"><span id="739b" class="kf kg iq ns b gy nw nx l ny nz">5# [2/2] RUN --mount=type=secret,id=mypass cat /run/secrets/mypass 5# sha256:7fd248d616c172325af799b6570d2522d3923638ca41181fab4ea143 5# 0.248 TOP SECRET ASTRONAUT PASSWORD</span></pre><p id="148d" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">这证明构建步骤可以访问<code class="fe oa ob oc ns b">secret.txt</code>。</p><p id="d8a1" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">使用这种方法，您现在可以安全地将秘密装载到构建过程中，而不用担心将密钥或密码泄漏到生成的映像中。</p><h1 id="4f1e" class="ne kg iq bd kh nf ng nh kk ni nj nk kn jw nl jx kr jz nm ka kv kc nn kd kz no bi translated">运行时秘密</h1><p id="5a21" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">当容器在生产环境中运行时，如果您需要一个秘密(比如数据库凭证)，您应该使用环境变量将秘密传递到容器中。</p><p id="4291" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">不要在构建时将任何秘密直接放入映像中！</p><pre class="ma mb mc md gt nr ns nt nu aw nv bi"><span id="c287" class="kf kg iq ns b gy nw nx l ny nz">docker run --env MYLOGIN=johndoe --env MYPASSWORD=sdf4otwe3789</span></pre><p id="2dad" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">这些可以用Python访问，比如:</p><pre class="ma mb mc md gt nr ns nt nu aw nv bi"><span id="7207" class="kf kg iq ns b gy nw nx l ny nz">os.environ.get('MYLOGIN')<br/>os.environ.get('MYPASSWORD')</span></pre><p id="42e3" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">提示:你也可以从像哈希公司金库这样的秘密商店获取秘密！</p><h1 id="bf90" class="ne kg iq bd kh nf ng nh kk ni nj nk kn jw nl jx kr jz nm ka kv kc nn kd kz no bi translated">GPU支持</h1><p id="5bb9" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">带有GPU的Docker可能比较棘手。从头构建映像超出了本文的范围，但是现代GPU (NVIDIA)容器有五个先决条件。</p><p id="e162" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated"><strong class="ld ir">图像:</strong></p><ul class=""><li id="1154" class="mq mr iq ld b le lu lh lv ko ms ks mt kw mu lt mv mw mx my bi translated">CUDA/cuDNN库</li><li id="11f7" class="mq mr iq ld b le mz lh na ko nb ks nc kw nd lt mv mw mx my bi translated">框架的GPU版本，如Tensorflow(需要时)</li></ul><p id="71a1" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated"><strong class="ld ir">主机:</strong></p><p id="5325" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">最好的方法是找到一个已经包含了大多数先决条件的基础映像。像Tensorflow这样的框架通常会提供像<code class="fe oa ob oc ns b">tensorflow/tensorflow:latest-gpu</code>这样的图片，这是一个很好的起点。</p><p id="02a3" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">排除故障时，您可以首先尝试测试您的主机:</p><pre class="ma mb mc md gt nr ns nt nu aw nv bi"><span id="26e7" class="kf kg iq ns b gy nw nx l ny nz">nvidia-smi</span></pre><p id="1533" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">然后在容器中运行相同的命令:</p><pre class="ma mb mc md gt nr ns nt nu aw nv bi"><span id="3d9c" class="kf kg iq ns b gy nw nx l ny nz">docker run --gpus all tensorflow/tensorflow:latest-gpu nvidia-smi</span></pre><p id="9aa3" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">对于这两个命令，您应该得到类似这样的结果:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi oh"><img src="../Images/2155fdd3a9a87af3d5e9fabf0ba7fc01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tt5RVVm_Oe3JLYox.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">作者图片</p></figure><p id="ed2e" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">如果您从任何一个地方得到一个错误，您将知道问题是在容器内部还是外部。</p><p id="cc29" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">测试你的框架也是一个好主意。例如Tensorflow:</p><pre class="ma mb mc md gt nr ns nt nu aw nv bi"><span id="ccf4" class="kf kg iq ns b gy nw nx l ny nz">docker run --gpus all -it --rm \<br/>    tensorflow/tensorflow:latest-gpu \<br/>    python -c \<br/>    "import tensorflow as tf;print(tf.reduce_sum(tf.random.normal([1000, 1000])))"</span></pre><p id="68df" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">输出可能很详细，并有一些警告，但它应该以类似如下的内容结束:</p><pre class="ma mb mc md gt nr ns nt nu aw nv bi"><span id="5a53" class="kf kg iq ns b gy nw nx l ny nz">Created device /job:localhost/replica:0/task:0/device:GPU:0 with 3006 MB memory: -&gt; device: 0, name: NVIDIA GeForce GTX 970, pci bus id: 0000:01:00.0, compute capability: 5.2 tf.Tensor(-237.35098, shape=(), dtype=float32)</span></pre><h1 id="184d" class="ne kg iq bd kh nf ng nh kk ni nj nk kn jw nl jx kr jz nm ka kv kc nn kd kz no bi translated">Docker容器与Python虚拟环境</h1><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/d7d478d0e768b41b1559c457e238b69e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/0*7hDUNNFi3JK8inlt.png"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">作者图片</p></figure><p id="d86c" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">Python虚拟环境在本地开发环境中的不同Python项目之间创建了一个安全气泡。Docker容器解决了一个类似的问题，但是在不同的层面上。</p><p id="1b89" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">虽然Python虚拟环境在所有与Python相关的事物之间创建了隔离层，但是Docker容器为整个软件栈实现了这一点。Python虚拟环境和Docker容器的用例是不同的。根据经验，虚拟环境足以在本地机器上开发东西，而Docker容器是为在云中运行生产作业而构建的。</p><p id="aa5f" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">换句话说，对于本地开发来说，虚拟环境就像在沙滩上涂防晒霜，而Docker容器就像穿着宇航服——通常不舒服，而且大多不实用。</p><h1 id="26b9" class="ne kg iq bd kh nf ng nh kk ni nj nk kn jw nl jx kr jz nm ka kv kc nn kd kz no bi translated">想要更多实用的工程技巧吗？</h1><p id="7a42" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">数据科学家越来越多地成为R&amp;D团队的一部分，并致力于生产系统，这意味着数据科学和工程领域正在发生碰撞。我想让没有工程背景的数据科学家更容易理解，就这个主题写了一本免费电子书。</p><p id="a9fd" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">下载电子书:<a class="ae od" href="https://valohai.com/engineering-practices-ebook/" rel="noopener ugc nofollow" target="_blank"> <em class="of">数据科学家的工程实践</em> </a></p></div><div class="ab cl oj ok hu ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ij ik il im in"><p id="9859" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">【https://valohai.com】最初发表于<a class="ae od" href="https://valohai.com/blog/docker-for-data-science/" rel="noopener ugc nofollow" target="_blank"><em class="of"/></a><em class="of">。</em></p></div></div>    
</body>
</html>