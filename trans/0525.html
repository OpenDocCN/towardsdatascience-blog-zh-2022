<html>
<head>
<title>Python Context Managers in 10 Minutes — using the ‘with’ keyword</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python上下文管理器10分钟—使用“with”关键字</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-context-managers-in-10-minutes-using-the-with-keyword-51eb254c1b89#2022-02-21">https://towardsdatascience.com/python-context-managers-in-10-minutes-using-the-with-keyword-51eb254c1b89#2022-02-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d8d6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用示例简化上下文管理器</h2></div><p id="cc4b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上下文管理器本质上是产生单个值的生成器。这个主题现在可能对您来说很陌生，但是您以前很可能使用过上下文管理器。最常用的上下文管理器是Python内置的打开文件的<code class="fe le lf lg lh b">open</code>命令，通常与关键字<code class="fe le lf lg lh b">with</code>一起使用，</p><pre class="li lj lk ll gt lm lh ln bn lo lp bi"><span id="7007" class="lq lr it lh b be ls lt l lu lv">with open("file.txt", "r") as file:<br/>    data = file.read()</span></pre><p id="31b0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类似的用法是使用<code class="fe le lf lg lh b">open</code>命令打开文件，读取数据，然后使用<code class="fe le lf lg lh b">close</code>命令关闭文件。为了防止用户忘记关闭文件并释放资源，使用<code class="fe le lf lg lh b">with</code>关键字将利用上下文管理器并自动处理文件关闭。这个例子被称为<code class="fe le lf lg lh b">open-close</code>模式。上下文管理器也可以用于其他模式，如<code class="fe le lf lg lh b">lock-release</code>、<code class="fe le lf lg lh b">change-reset</code>、<code class="fe le lf lg lh b">enter-exit</code>、<code class="fe le lf lg lh b">start-stop</code>、<code class="fe le lf lg lh b">setup-teardown</code>、<code class="fe le lf lg lh b">connect-disconnect</code>。</p><p id="49ca" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇文章将涉及编写你自己的上下文管理器，高级行为，例如将上下文管理器分配给一个变量，错误处理，接受参数，嵌套上下文管理器，最后是上下文管理器的一些示例用法。</p><p id="1e32" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="lw">更新</em> </strong> <em class="lw">:本文是系列文章的一部分。查看其他“10分钟内”话题</em> <a class="ae lx" href="https://medium.com/@kayjanwong/list/in-10-minutes-eeaa9aa67055" rel="noopener"> <em class="lw">此处</em> </a> <em class="lw">！</em></p><h1 id="aee8" class="ly lr it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">目录</h1><ul class=""><li id="bc3c" class="mp mq it kk b kl mr ko ms kr mt kv mu kz mv ld mw mx my mz bi translated"><a class="ae lx" href="https://medium.com/p/51eb254c1b89/#104b" rel="noopener">上下文管理器的结构</a></li><li id="6cc5" class="mp mq it kk b kl na ko nb kr nc kv nd kz ne ld mw mx my mz bi translated"><a class="ae lx" href="https://medium.com/p/51eb254c1b89/#08f4" rel="noopener">情境经理的高级行为</a></li><li id="d603" class="mp mq it kk b kl na ko nb kr nc kv nd kz ne ld mw mx my mz bi translated"><a class="ae lx" href="https://medium.com/p/51eb254c1b89/#d87e" rel="noopener">用途:连接数据库</a></li><li id="d883" class="mp mq it kk b kl na ko nb kr nc kv nd kz ne ld mw mx my mz bi translated"><a class="ae lx" href="https://medium.com/p/51eb254c1b89/#9754" rel="noopener">用途:捕获打印报表</a></li></ul></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="104b" class="ly lr it bd lz ma nm mc md me nn mg mh jz no ka mj kc np kd ml kf nq kg mn mo bi translated">上下文管理器的结构</h1><p id="06d4" class="pw-post-body-paragraph ki kj it kk b kl mr ju kn ko ms jx kq kr nr kt ku kv ns kx ky kz nt lb lc ld im bi translated">上下文管理器可以定义为一个函数或一个类。下面是作为功能实现的上下文管理器的结构，</p><pre class="li lj lk ll gt lm lh ln bn lo lp bi"><span id="0d3d" class="lq lr it lh b be ls lt l lu lv">import contextlib<br/><br/><br/>@contextlib.contextmanager<br/>def sample_context():<br/>    # Enter context manager<br/>    # Performs &lt;do-something-here&gt;<br/>    yield<br/>    # Exit context manager<br/><br/><br/>with sample_context():<br/>    # &lt;do-something-here&gt;<br/>    pass</span></pre><p id="8a9c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上下文管理器函数使用<code class="fe le lf lg lh b">contextlib.contextmanager</code>装饰器，它将函数转换成上下文管理器。你可以在我的另一篇文章中找到更多关于装饰者的信息。还有一个<code class="fe le lf lg lh b">yield</code>关键字，它现在什么也不做，但是作为命令的分隔符，这些命令将在进入和退出上下文管理器时运行。</p><p id="c3d7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了将上下文管理器实现为一个类，在进入和退出上下文管理器时运行的命令将分别在<code class="fe le lf lg lh b">__enter__</code>和<code class="fe le lf lg lh b">__exit__</code> dunder方法中定义。这不会使用任何修饰或<code class="fe le lf lg lh b">yield</code>关键字，这对于面向对象编程爱好者来说可能更容易理解。</p><pre class="li lj lk ll gt lm lh ln bn lo lp bi"><span id="f80c" class="lq lr it lh b be ls lt l lu lv">class SampleContext:<br/>    def __enter__(self):<br/>        # Enter context manager<br/>        pass<br/><br/>    def __exit__(self, *args):<br/>        # Exit context manager<br/>        pass<br/><br/><br/>with SampleContext():<br/>    # &lt;do-something&gt;<br/>    pass</span></pre><p id="6e17" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe le lf lg lh b">open-close</code>模式的情况下，文件将在进入上下文管理器时打开，在退出上下文管理器时关闭。这样，步骤和复杂性从用户那里抽象出来，并且与文件相关的资源以由用户控制的方式被释放。</p><blockquote class="nu"><p id="dd2d" class="nv nw it bd nx ny nz oa ob oc od ld dk translated">上下文管理器是一种函数或类，它为代码运行设置上下文，运行代码，然后移除上下文。上下文管理器最适合用于控制资源的分配和释放。</p></blockquote><h1 id="08f4" class="ly lr it bd lz ma mb mc md me mf mg mh jz oe ka mj kc of kd ml kf og kg mn mo bi translated">上下文经理的高级行为</h1><h2 id="2a17" class="oh lr it bd lz oi oj dn md ok ol dp mh kr om on mj kv oo op ml kz oq or mn os bi translated">将上下文管理器分配给变量</h2><p id="bd25" class="pw-post-body-paragraph ki kj it kk b kl mr ju kn ko ms jx kq kr nr kt ku kv ns kx ky kz nt lb lc ld im bi translated">可以使用关键字<code class="fe le lf lg lh b">as</code>将上下文管理器分配给一个变量，比如<code class="fe le lf lg lh b">with sample_context() as variable</code>。我们可以使用<code class="fe le lf lg lh b">as</code>关键字，仍然运行上一节中的代码，只是变量将是<code class="fe le lf lg lh b">None</code>，因为它是未定义的。</p><p id="ee54" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了定义变量，我们可以对上下文管理器函数使用<code class="fe le lf lg lh b">yield</code>关键字，或者对上下文管理器类使用<code class="fe le lf lg lh b">__enter__</code>方法中的<code class="fe le lf lg lh b">return</code>关键字。</p><pre class="li lj lk ll gt lm lh ln bn lo lp bi"><span id="dce7" class="lq lr it lh b be ls lt l lu lv"># Context Manager Function<br/>@contextlib.contextmanager<br/>def sample_context_variable():<br/>    # Enter context manager<br/>    # Performs &lt;do-something&gt;<br/>    yield "something"<br/>    # Exit context manager<br/><br/><br/>with sample_context_variable() as variable:<br/>    # &lt;do-something&gt;<br/>    print(variable)  # "something"<br/><br/><br/># Context Manager Class<br/>class SampleContextVariable:<br/>    def __enter__(self):<br/>        # Enter context manager<br/>        return "something"<br/><br/>    def __exit__(self, *args):<br/>        # Exit context manager<br/>        pass<br/><br/><br/>with SampleContextVariable() as variable:<br/>    # &lt;do-something&gt;<br/>    print(variable)  # "something"</span></pre><h2 id="946c" class="oh lr it bd lz oi oj dn md ok ol dp mh kr om on mj kv oo op ml kz oq or mn os bi translated">用于错误处理的上下文管理器</h2><p id="a87a" class="pw-post-body-paragraph ki kj it kk b kl mr ju kn ko ms jx kq kr nr kt ku kv ns kx ky kz nt lb lc ld im bi translated">上下文管理器将遇到错误，例如编码错误、文件无法打开或锁没有释放。因此，最好使用<code class="fe le lf lg lh b">try-except-finally</code>块进行错误处理。这将在下一节用一个例子来说明。</p><h2 id="6db1" class="oh lr it bd lz oi oj dn md ok ol dp mh kr om on mj kv oo op ml kz oq or mn os bi translated">接受参数的上下文管理器</h2><p id="9012" class="pw-post-body-paragraph ki kj it kk b kl mr ju kn ko ms jx kq kr nr kt ku kv ns kx ky kz nt lb lc ld im bi translated">上下文管理器本质上是一个函数或类，应该能够接受参数。我们将定义一个简单的<code class="fe le lf lg lh b">open_file</code>上下文管理器，它使用一个<code class="fe le lf lg lh b">open-close</code>模式来说明过去的三个部分——使用<code class="fe le lf lg lh b">yield</code>将上下文管理器分配给一个变量，使用<code class="fe le lf lg lh b">try-finally</code>块和接受参数的上下文管理器进行错误处理，</p><pre class="li lj lk ll gt lm lh ln bn lo lp bi"><span id="a47d" class="lq lr it lh b be ls lt l lu lv">import contextlib<br/><br/><br/>@contextlib.contextmanager<br/>def open_file(file_name):<br/>    try:<br/>        file = open(file_name, "r")<br/>        yield file<br/>        file.close()<br/>    except FileNotFoundError:<br/>        raise FileNotFoundError("File cannot be found")<br/><br/><br/>with open_file("file.txt") as file:<br/>    data = file.read()</span></pre><h2 id="92f9" class="oh lr it bd lz oi oj dn md ok ol dp mh kr om on mj kv oo op ml kz oq or mn os bi translated">嵌套上下文管理器</h2><p id="7c0a" class="pw-post-body-paragraph ki kj it kk b kl mr ju kn ko ms jx kq kr nr kt ku kv ns kx ky kz nt lb lc ld im bi translated">最后，可以堆叠上下文管理器，并且可以同时设置多个上下文。唯一需要注意的是，父上下文中的变量可以被子上下文访问，但不能被子上下文访问(根据<a class="ae lx" href="https://realpython.com/python-scope-legb-rule/#nested-functions-the-enclosing-scope" rel="noopener ugc nofollow" target="_blank"> scope </a>的概念)，所以要合理地计划嵌套。一个例子是这样的，</p><pre class="li lj lk ll gt lm lh ln bn lo lp bi"><span id="4be2" class="lq lr it lh b be ls lt l lu lv">with open(path_input) as file_input:<br/>    with open(path_output, "w") as file_output:<br/>        for line in file_input:<br/>            # Read and write lines simultaneously<br/>            file_output.write(line)</span></pre><h1 id="d87e" class="ly lr it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">用法:连接到数据库</h1><p id="fb52" class="pw-post-body-paragraph ki kj it kk b kl mr ju kn ko ms jx kq kr nr kt ku kv ns kx ky kz nt lb lc ld im bi translated">可以在一个上下文中建立到数据库的连接，其中可以有一个在进入上下文管理器时连接到数据库的设置脚本和一个在退出上下文管理器时断开数据库连接的拆卸脚本。</p><p id="4862" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的代码片段中，我们定义了一个<code class="fe le lf lg lh b">database</code>上下文管理器。进入上下文管理器后建立数据库连接，然后连接<code class="fe le lf lg lh b">cur</code>返回，代码中的<code class="fe le lf lg lh b">yield</code>关键字作为<code class="fe le lf lg lh b">db_conn</code>接收。最后，使用teardown脚本关闭数据库连接。</p><pre class="li lj lk ll gt lm lh ln bn lo lp bi"><span id="d35b" class="lq lr it lh b be ls lt l lu lv">import contextlib<br/>import psycopg2<br/><br/><br/>@contextlib.contextmanager<br/>def database(params):<br/>    print("Connecting to PostgreSQL database...")<br/>    # Setup script<br/>    conn = psycopg2.connect(**params)<br/>    cur = conn.cursor()<br/>    try:<br/>        yield cur<br/>    finally:<br/>        # Teardown script<br/>        cur.close()<br/>        conn.close()<br/>        print("Database connection closed.")<br/><br/><br/>db_params = dict(<br/>    host="localhost", database="sample_db", user="postgres", password="Abcd1234"<br/>)<br/>with database(db_params) as db_conn:<br/>    data = db_conn.execute("SELECT * FROM table")</span></pre><p id="b145" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码片段可以推广到涉及资源共享的其他用途，比如在多线程场景中实现锁。</p><h1 id="9754" class="ly lr it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">用法:捕获打印报表</h1><p id="be95" class="pw-post-body-paragraph ki kj it kk b kl mr ju kn ko ms jx kq kr nr kt ku kv ns kx ky kz nt lb lc ld im bi translated">我发现上下文管理器的另一个有用的用法是在一个列表中捕获所有打印到控制台的打印语句，在那里可以进一步处理该列表或将其保存为一个文件。这在使用外部Python包时很有用，在这种情况下，您不能修改源代码，但函数会将大量信息打印到控制台，您希望捕获这些信息或希望阻止这些信息显示出来。</p><pre class="li lj lk ll gt lm lh ln bn lo lp bi"><span id="cc5a" class="lq lr it lh b be ls lt l lu lv">import sys<br/>from io import StringIO<br/><br/><br/>def print_function():<br/>    print("Hello")<br/>    print("World")<br/>    print("New\nLine")<br/><br/><br/>class Capturing(list):<br/>    def __enter__(self):<br/>        self._stdout = sys.stdout<br/>        sys.stdout = StringIO()<br/>        self._current_string = sys.stdout<br/>        return self<br/><br/>    def __exit__(self, *args):<br/>        self.extend(self._current_string.getvalue().splitlines())<br/>        del self._current_string<br/>        sys.stdout = self._stdout<br/><br/><br/>with Capturing() as output:<br/>    print_function()<br/>    # Nothing will be printed to console since it is captured<br/><br/>print(output)<br/># ['Hello', 'World', 'New', 'Line']</span></pre><p id="5743" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="lw">更新</em> </strong>:从Python 3.4开始，可以使用<code class="fe le lf lg lh b">contextlib</code>库中的上下文管理器捕获打印语句。不同之处在于，该方法将打印语句捕获为字符串，而不是字符串列表。</p><pre class="li lj lk ll gt lm lh ln bn lo lp bi"><span id="1dc3" class="lq lr it lh b be ls lt l lu lv">import sys<br/>from io import StringIO<br/><br/><br/>def print_function():<br/>    print("Hello")<br/>    print("World")<br/>    print("New\nLine")<br/><br/>f = StringIO()<br/>with contextlib.redirect_stdout(f):<br/>    print_function()<br/><br/>output = f.getvalue()<br/># output is 'Hello\nWorld\nNew\nLine\n'</span></pre></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="64de" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">希望这篇文章已经介绍了上下文管理器的基础知识，如何创建定制的上下文管理器以及一些示例用法。有许多Python内置的上下文管理器和来自Python包的上下文管理器，所以在自己实现它之前一定要四处看看，以节省一些时间和精力。</p><p id="634b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">感谢您的阅读！</strong>如果你喜欢这篇文章，请随意分享。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="11e2" class="ly lr it bd lz ma nm mc md me nn mg mh jz no ka mj kc np kd ml kf nq kg mn mo bi translated">相关链接</h1><p id="ed3a" class="pw-post-body-paragraph ki kj it kk b kl mr ju kn ko ms jx kq kr nr kt ku kv ns kx ky kz nt lb lc ld im bi translated"><code class="fe le lf lg lh b">contextlib</code>文献:<a class="ae lx" href="https://docs.python.org/3/library/contextlib.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/contextlib.html</a></p><p id="2680" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">PostgreSQL Python文档:<a class="ae lx" href="https://www.postgresqltutorial.com/postgresql-python/connect/" rel="noopener ugc nofollow" target="_blank">https://www . PostgreSQL tutorial . com/PostgreSQL-Python/connect/</a></p><p id="a432" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">捕获打印报表:<a class="ae lx" href="https://stackoverflow.com/questions/16571150" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/questions/16571150</a></p></div></div>    
</body>
</html>