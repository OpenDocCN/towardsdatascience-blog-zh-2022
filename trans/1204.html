<html>
<head>
<title>How to Solve ODEs in MATLAB Using Runge-Kutta</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在 MATLAB 中用龙格-库塔法求解常微分方程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-solve-odes-in-matlab-without-built-in-functions-9eaa01c9fe10#2022-03-28">https://towardsdatascience.com/how-to-solve-odes-in-matlab-without-built-in-functions-9eaa01c9fe10#2022-03-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a1c5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习编写一个 Runge-Kutta 4 阶算法来求解常微分方程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/405576d3ef1d84895a61f87a1071b0e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FXqi6mryUdiAZBgR"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Joshua Woroniecki 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="52ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">常微分方程在工程和科学的各个方面都很常见。它们用于模拟物理现象，如湍流气流、卫星轨道、热传递、振动和无数其他现象。它们是人类理解物理和数学的基础。虽然我们可以基于直觉和我们对世界如何运作的基本理解来创建这些方程，但解决它们可能更具挑战性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="2e22" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">常微分方程</h2><p id="d173" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在这篇文章中，我假设你对微积分和<a class="ae ky" href="https://en.wikipedia.org/wiki/Differential_equation" rel="noopener ugc nofollow" target="_blank">微分方程</a>有基本的了解。术语常微分方程是指包含一个独立变量的函数和这些函数的导数的微分方程。对于大多数工程和科学常微分方程，独立变量是时间，方程的形式如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/d2e5f022a59ff252c9c0793a830119e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:202/1*iu0tuoJDwFjuMzCiBD4y-A.gif"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/e414d6a38b3579f74e0d1adbf6e31fc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:326/1*9mwQFgBs3BPfiI5qVrw2aw.gif"/></div></figure><p id="1a9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的<strong class="lb iu"> <em class="nc"> y </em> </strong>矢量可以是空间状态、质量、温度等。，而<strong class="lb iu"> <em class="nc"> t </em> </strong>是时间。不幸的是，大多数常微分方程不能解析求解；这意味着不能推导出一个函数来提供微分方程的精确解。求解这些微分方程的另一种方法是利用数值积分方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="68a6" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">数值积分</h2><p id="6fb6" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">数值积分这个术语最早出现在 1915 年，但是直到现代计算机的出现，它的好处才真正显现出来。数值积分是一种通过了解控制<strong class="lb iu"> <em class="nc"> y </em> </strong>随时间变化的微分方程来近似函数<strong class="lb iu"> <em class="nc"> y </em> </strong>随时间变化的方法。它们只是陈述的一个估计，所以它们只和使用的方法和技术一样好。最流行的数值积分形式之一是四阶龙格-库塔法(或 RK4)。</p><p id="e03f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">RK4 可以用下面的等式和图表来描述。通常情况下，你会有一个向量形式的常微分方程求解，所以向量形式的 RK4 显示。在等式中，<strong class="lb iu"> <em class="nc"> k </em> </strong>值是在图中所示的位置使用微分方程计算的<strong class="lb iu"> <em class="nc"> y </em> </strong>的斜率估计值。一旦确定了<strong class="lb iu"> <em class="nc"> k </em> </strong>值，它们被平均并乘以时间步长<strong class="lb iu"> <em class="nc"> h </em> </strong>。然后将其添加到当前值<strong class="lb iu"> <em class="nc"> y </em> </strong>中，得到下一个时间步长的近似值<strong class="lb iu"> <em class="nc"> y </em> </strong>。重复这一过程，直到达到所需的时间步数。请注意，所使用的<strong class="lb iu"> <em class="nc"> h </em> </strong>值越小，结果越接近真实值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/ecd0308da44ae7b3b383e33d00c1869f.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/1*HgSJ4cF5ucCxb_KhPaEDkg.gif"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/1fe23b7dfc6524c44c20627acd5cf061.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AFMiZeTPwcA6oW9d92aEjA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">斜率估计的描述[由<a class="ae ky" href="http://By HilberTraum - Own work, CC BY-SA 4.0, https://commons.wikimedia.org/w/index.php?curid=64366870" rel="noopener ugc nofollow" target="_blank"> HilberTraum </a>创建]</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="f1ce" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">MATLAB RK4 脚本</h2><p id="27ce" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">对于这个例子，假设我们有一个粒子，它的运动由下面的常微分方程描述:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/f16bf87272bf27c133e8b7e782aeba6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:204/1*K05ERjoPB_N8xQ2YeVsmjQ.gif"/></div></figure><p id="6b1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这组常微分方程是方便的，因为它可以解析求解(解决方案如下所示)。选择这些，以便我们的 RK4 算法可以与实际解决方案进行比较。请记住，当使用你自己的微分方程时，它们可能无法解析求解，所以你可能没有任何东西来比较你的结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/93b5e8442764b2aca779cb4433e87255.png" data-original-src="https://miro.medium.com/v2/resize:fit:294/1*zOtJHOjwNikI4TljsSTVww.gif"/></div></figure><p id="dcdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过定义一个函数<strong class="lb iu"> <em class="nc"> model </em> </strong>来开始代码，当值<strong class="lb iu"><em class="nc"/></strong>、<strong class="lb iu"> <em class="nc"> v </em> </strong>和<strong class="lb iu"> <em class="nc"> w </em> </strong>传递给它时，该函数将返回 ODEs 的值。确保将这个函数定义放在脚本的底部。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="444e" class="mc md it ni b gy nm nn l no np">function dydt = model(t,y)<br/>    v = y(1);<br/>    w = y(2);<br/>    dv_dt = w;<br/>    dw_dt = 6*v-w;<br/>    dydt = [dv_dt,dw_dt];<br/>end</span></pre><p id="9790" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在开始主脚本吧。我总是从清除命令窗口、清除变量和关闭数字开始。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="794e" class="mc md it ni b gy nm nn l no np">clc<br/>clear variables<br/>close all</span></pre><p id="3d15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了利用 RK4 方法，我们需要定义初始条件<strong class="lb iu"><em class="nc"/></strong>y0，以及一个时间数组<strong class="lb iu"><em class="nc"/></strong>。这里，<strong class="lb iu"> <em class="nc"> t </em> </strong>被定义为以 1000 为增量从 0 到 1，并且<strong class="lb iu"> <em class="nc"> v </em> </strong>的初始条件是 3，而<strong class="lb iu"> <em class="nc"> w </em> </strong>是 1。时间数组用于创建<strong class="lb iu"> <em class="nc"> h </em> </strong>及以后，精确值为<strong class="lb iu"> <em class="nc"> v </em> </strong>和<strong class="lb iu"> <em class="nc"> w </em> </strong>。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="4b8b" class="mc md it ni b gy nm nn l no np">% Initial Conditions and Simulation Time<br/>y0 = [3, 1];  % y0 = [v0, w0]<br/>t = linspace(0,1,1000)';</span></pre><p id="7dbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们可以创建一个数组<strong class="lb iu"><em class="nc"/></strong>，来存储每个时间步的 RK4 近似值。利用<strong class="lb iu"> <em class="nc"> v </em> </strong>和<strong class="lb iu"> <em class="nc"> w </em> </strong>的初始条件，我们可以定义 RK4 数组的第一个索引(<strong class="lb iu"> <em class="nc"> i </em> </strong> = 1，<strong class="lb iu"> <em class="nc"> t </em> </strong> =0)。我们还可以定义时间步长变量，<strong class="lb iu"><em class="nc"/></strong>。然后我们为循环引入一个<em class="nc">来遍历时间数组的长度。每次迭代我们都会给 yₖᵤₜₜₐ的<strong class="lb iu"><em class="nc"/></strong>增加一个新值，然后使用这个迭代为 yₖᵤₜₜₐ的<strong class="lb iu"><em class="nc"/></strong>创建另一个值。这个过程会一直重复，直到到达最后一个时间步(<strong class="lb iu"> <em class="nc"> t </em> </strong> = 1)。</em></p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="11d1" class="mc md it ni b gy nm nn l no np">% Runge-Kutta 4th-Order Algorithm<br/>y_Kutta = zeros(length(t), 2);<br/>y_Kutta(1, :) = y0;<br/>h = t(2)-t(1);  % Constant time step<br/>for i = 2:length(t)<br/>    k1 = model(t(i-1), y_Kutta(i-1, :));<br/>    k2 = model(t(i-1)+h/2, y_Kutta(i-1, :)+k1*h/2);<br/>    k3 = model(t(i-1)+h/2, y_Kutta(i-1, :)+k2*h/2);<br/>    k4 = model(t(i-1)+h, y_Kutta(i-1, :)+k3*h);<br/>    y_Kutta(i, :) = y_Kutta(i-1, :)+(k1/6+k2/3+k3/3+k4/6)*h;<br/>end</span></pre><p id="2bfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，这组常微分方程有一个解析解，所以让我们创建一个这些值的数组，并将其与我们从 RK4 得到的结果进行比较。为了比较，我们可以简单地计算精确解和近似解之间的差。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="62ad" class="mc md it ni b gy nm nn l no np">% Exact<br/>y_Exact = 2*exp(2*t).*[1, 2]-exp(-3.*t)*[-1, 3];</span><span id="4af1" class="mc md it ni b gy nq nn l no np">% Calculating the Difference Between Exact and RK4 Solutions<br/>diff_Kutta = y_Exact-y_Kutta;</span></pre><p id="b896" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们有了比较龙格-库塔四阶方法和精确解所需的所有数据。最后一步是绘制结果。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="701e" class="mc md it ni b gy nm nn l no np">% Comparison Subplot<br/>figure; subplot(2,1,1);  hold on;<br/>plot(y_Exact(:, 1), y_Exact(:, 2))<br/>plot(y_Kutta(:, 1), y_Kutta(:, 2))<br/>title('RK4 Compared to the Exact Solution', 'Interpreter', 'Latex')<br/>xlabel('v', 'Interpreter', 'Latex')<br/>ylabel('w', 'Interpreter', 'Latex')<br/>legend('Exact', 'RK4', 'Location', 'Best')<br/>grid on; hold off</span><span id="eea2" class="mc md it ni b gy nq nn l no np">% Difference Subplot<br/>subplot(2,1,2); hold on;<br/>plot(t, diff_Kutta(:, 1))<br/>plot(t, diff_Kutta(:, 2))<br/>xlabel('t', 'Interpreter', 'Latex')<br/>ylabel('Difference', 'Interpreter', 'Latex')<br/>legend('RK4 [v]', 'RK4 [w]', 'Location', 'Best')<br/>grid on; hold off</span></pre><p id="c67a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/75e0a1d40abcebf848fafad2e76653ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vRSvmuYdZTXk50Gdd5N0Lw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">龙格-库塔四阶结果[由作者创建]</p></figure><p id="e630" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，Runge-Kutta 4 阶方法的结果对于这个例子来说是非常精确的。RK4 结果与上图中的精确解难以区分，并且<strong class="lb iu"> <em class="nc"> v </em> </strong>和<strong class="lb iu"> <em class="nc"> w </em> </strong>的结果与精确解之间的差异实际上可以忽略不计。龙格-库塔可以扩展到 4 阶以上，以减少误差，但对于大多数应用来说，这可能是不必要的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="bb3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您阅读文章！希望你对 RK4 有所了解！给我一个关注，看看我关于 Python、数学和轨道力学的其他文章！如果您有任何意见或顾虑，请告诉我！</p></div></div>    
</body>
</html>