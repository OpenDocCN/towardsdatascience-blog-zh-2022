<html>
<head>
<title>How to Unblur Images without training Neural Networks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在不训练神经网络的情况下去除图像模糊</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-de-blur-images-without-training-neural-networks-72f8597c0014#2022-11-29">https://towardsdatascience.com/how-to-de-blur-images-without-training-neural-networks-72f8597c0014#2022-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fb13" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">背景</h2></div><p id="aeca" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我发现在点击图片时很难保持手的稳定。很自然，他们中的许多人都有模糊不清的感觉。如果你和这个问题有关，那你就来对地方了。虽然我不能教你摄影，但我可以用几行 python 代码向你展示一种消除图像模糊的技术。鉴于围绕深度学习的热潮，一个解决方案是训练一个自动编码器。但是，训练它们在计算上很昂贵，有时，经典方法工作得很好。因此，我们将使用傅立叶变换。</p><p id="f35b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">傅立叶变换在信号和图像处理中有着广泛的应用。它的性能可能不如最先进的深度学习方法令人印象深刻，但它的速度要快得多。如果你在智能手机上点击一张图片后注意到一个处理提示，那么傅立叶变换可能正在后台运行以提高图像质量。它还可以帮助更好地训练现代深度学习架构。任何模型都取决于它所依赖的数据。使用傅立叶变换，您可以应用大量的图像处理技术(降噪、边缘检测等)来提高训练数据的质量。</p><p id="832e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我不会深究傅立叶变换的数学细节。如果你对此感兴趣，你会在 youtube 上找到很多视频。我特别喜欢的一个是 3Blue1Brown 的主持人<a class="ae lj" href="https://www.youtube.com/watch?v=spUNpyF58BY" rel="noopener ugc nofollow" target="_blank">格兰特·桑德森</a>。在这篇文章中，我们将重点讨论如何使用傅立叶变换去模糊图像。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lk"><img src="../Images/ccac80bcf35dc5bfaf6ce9627ba6888e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z1iVsx9cLZNND0Kk"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated"><a class="ae lj" href="https://unsplash.com/@_shootthephoto_?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">汤姆·史密斯</a>在<a class="ae lj" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><h2 id="0548" class="ma mb iq bd mc md me dn mf mg mh dp mi kw mj mk ml la mm mn mo le mp mq mr ms bi translated">数学上模糊是什么？</h2><p id="c9d3" class="pw-post-body-paragraph kn ko iq kp b kq mt jr ks kt mu ju kv kw mv ky kz la mw lc ld le mx lg lh li ij bi translated">既然我们已经同意进入傅立叶变换的领域，我们首先需要一个图像模糊的数学定义。模糊使图像变得平滑。也就是说，图像丢失了边缘细节。我们可以通过用高斯核卷积图像来实现这一点。下面是一个(3，3)高斯核。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi my"><img src="../Images/0d069ed44a83de393ca99cf635ab7b61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*v6oZr0uo9Jff-PtKZm53aw.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">作者图片</p></figure><p id="9011" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">请注意，当我们远离中心时，内核权重会减少。因此，当与这样的矩阵卷积时，图像位置将丢失来自周围像素的信息，导致平滑(模糊)。除了高斯，还有其他类型的<a class="ae lj" href="https://quincemedia.com/2017/10/04/9-types-of-blur-effects-in-after-effects/" rel="noopener ugc nofollow" target="_blank">平滑内核</a>。这里的要点是，模糊图像(B)是对原始图像(I)进行卷积(H)的结果。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/49396693f81fbd0865c95c9eb3f32c2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:162/0*OzUumYKTqApVZ-z_"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">模糊图像方程</p></figure><p id="ea5b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果我们能以某种方式逆转这一操作，我们将能够生成原始图像(I)。这个过程称为<strong class="kp ir">去卷积</strong>，在频域(傅立叶变换)中更容易完成。</p><h2 id="c4c4" class="ma mb iq bd mc md me dn mf mg mh dp mi kw mj mk ml la mm mn mo le mp mq mr ms bi translated">图像的傅立叶变换</h2><p id="4873" class="pw-post-body-paragraph kn ko iq kp b kq mt jr ks kt mu ju kv kw mv ky kz la mw lc ld le mx lg lh li ij bi translated">傅立叶变换(<strong class="kp ir"> FT </strong>)的思想是任何函数都可以近似为无限正弦曲线的加权和。一维正弦波需要 3 个参数来定义。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi na"><img src="../Images/be922b92bed89d5edb84547203bfeb0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:304/0*l23meXEcggCqpVX3"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">正弦方程</p></figure><ol class=""><li id="0bd8" class="nb nc iq kp b kq kr kt ku kw nd la ne le nf li ng nh ni nj bi translated">振幅(A)决定了波的范围。它从-A，A 开始延伸</li><li id="41aa" class="nb nc iq kp b kq nk kt nl kw nm la nn le no li ng nh ni nj bi translated">频率(2π/λ)决定两个连续峰值之间的距离</li><li id="af2c" class="nb nc iq kp b kq nk kt nl kw nm la nn le no li ng nh ni nj bi translated">相位(φ)决定了波的水平移动</li></ol><p id="6cb3" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">因此，傅立叶变换将函数从空间域转移到频率域。</p><pre class="ll lm ln lo gt np nq nr bn ns nt bi"><span id="95c4" class="nu mb iq nq b be nv nw l nx ny">def plot_sine_1D(amp,wavelength,phase):<br/>    x = np.arange(-500, 501, 1)<br/>    y = np.sin((2 * np.pi * x / wavelength)+phase)<br/>    plt.plot(x, y)<br/>    plt.show()<br/>plot_sine_1D(1,300,0)</span></pre><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/f5d27a5ae6dd6046cbb4a0070c3939d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*EP44mErTp6xLD0_qzNqEYg.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">作者图片</p></figure><p id="5567" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">任何图像都是二维离散函数。也就是说，像素是其空间位置的函数。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/0d2f4d3fd743cd2f465b2a46b5eefd2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:240/0*ni92-ou223SQnk4c"/></div></figure><p id="6cc5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">离散傅立叶变换将图像移动到频率空间，在那里它们由 2D 正弦波表示。</p><pre class="ll lm ln lo gt np nq nr bn ns nt bi"><span id="20e4" class="nu mb iq nq b be nv nw l nx ny">def plot_sine_2D(amp,wavelength,phase,angle):<br/>    x = np.arange(-500, 501, 1)<br/>    X, Y = np.meshgrid(x, x)<br/>    wavelength = 100<br/>    sine_2D = np.sin(<br/>        2*np.pi*(X*np.cos(angle) + Y*np.sin(angle)) / wavelength<br/>    )<br/>    plt.set_cmap("gray")<br/>    plt.imshow(sine_2D)<br/>plot_sine_2D(1,200,0,np.pi)</span></pre><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/e7f5cb1bf46d88c729fd97dfda07e211.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*lfF5AOpJyN6MqvZdT8kQMg.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">2D 正弦波</p></figure><p id="667d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">2D 正弦波也可以相对于 x，y 轴旋转。下面是旋转了π/6 弧度的同一个 2D 波。</p><pre class="ll lm ln lo gt np nq nr bn ns nt bi"><span id="05cd" class="nu mb iq nq b be nv nw l nx ny">plot_sine_2D(1,200,0,np.pi/6)</span></pre><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/6af7887d44b93756ea803abbb280fff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*WumNOn2X3jBBB_jZr63QxA.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">旋转正弦波</p></figure><p id="6d13" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们设想一些傅立叶变换。我们使用 np.fft.fft2 来实现。该函数的第二行将像素 0，0 移动到图的中心，使可视化更容易。我们的数组大小为 1001，1001，因此中心移动到 500，500。同样，我们取绝对值，因为 FT 返回一个复数。</p><pre class="ll lm ln lo gt np nq nr bn ns nt bi"><span id="aba8" class="nu mb iq nq b be nv nw l nx ny">def compute_fft(f):<br/>    ft = np.fft.fft2(f)<br/>    ft = np.fft.fftshift(ft)<br/>    return ft<br/><br/>sin = plot_sine_2D(1,200,0,np.pi,False)<br/>ft = compute_fft(sin)<br/>plt.xlim([480,520])<br/>plt.ylim([520,480]) <br/>plt.imshow(abs(ft))</span></pre><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi od"><img src="../Images/d789b3a15075079f66f53c26e9359f2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*tszbSsM1Km4lCFyg6pzATg.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">角度为π的正弦波英尺</p></figure><pre class="ll lm ln lo gt np nq nr bn ns nt bi"><span id="6bd3" class="nu mb iq nq b be nv nw l nx ny">sin = plot_sine_2D(1,200,0,np.pi/6,False)<br/>ft = compute_fft(sin)<br/>plt.xlim([480,520])<br/>plt.ylim([520,480]) <br/>plt.imshow(abs(ft))</span></pre><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/c2d272937987b0b940dde25e973ce983.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*Ry-gyogDTR4QUJp3qRwAHQ.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">π/6 旋转的正弦波英尺</p></figure><p id="f87d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在第一个 FT 中，我们得到两个距离中心 10 个单位的点。离中心的距离代表频率。在第二个 FT 图中，我们得到了相同的两个点，但进行了旋转。旋转角度代表波的旋转(30 度)。两点处的像素值描述了振幅。相位信息编码在复数部分，我们不画出来。</p><pre class="ll lm ln lo gt np nq nr bn ns nt bi"><span id="6be6" class="nu mb iq nq b be nv nw l nx ny">f,ax = plt.subplots(1,2,figsize=(15,20))<br/>ax = ax.flatten()<br/>im = cv2.imread('/kaggle/input/randomimages/pic2.jpeg',-1)<br/>im = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)<br/>ax[0].imshow(im,cmap='gray')<br/>ax[1].imshow(20*np.log(abs(compute_fft(im))),cmap='gray')</span></pre><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi of"><img src="../Images/4c1de12d06a46014e34b0417bfdd9dbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pphOTt6Xee8fBzTkYyWnfg.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">资料来源:联合国人类住区规划署</p></figure><p id="3a01" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">英尺的真实图像更难想象。我们在 FT 上进行对数运算，缩小数值，以图像形式绘制出来。</p><p id="fc74" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">使用傅立叶变换的反卷积</strong></p><p id="86ce" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们已经对 FTs 大惊小怪了，但是它们对我们的情况有什么帮助呢？在频域中，卷积转换为乘法。因此，我们的等式变成了</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi og"><img src="../Images/7925eefea7830e877dbe0c8e3049b55d.png" data-original-src="https://miro.medium.com/v2/resize:fit:372/0*s1b6aL1JzSTbZop1"/></div></figure><p id="d4fc" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">或者，</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/c4b7015d14c2ff320f037b96abdeb43a.png" data-original-src="https://miro.medium.com/v2/resize:fit:268/0*NgsIhawMWsXjVcXh"/></div></figure><p id="ae76" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">对 RHS 进行逆傅立叶变换应该会产生原始图像。但是等等，如何找到正确的平滑核(H)？根据模糊程度，你可以尝试不同的内核。现在让我们坚持使用高斯函数，并用代码实现它。</p><p id="5e58" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们将读入一幅图像，并使用 sigma = 5(内核的标准偏差)的 7，7 高斯内核模糊它</p><pre class="ll lm ln lo gt np nq nr bn ns nt bi"><span id="d132" class="nu mb iq nq b be nv nw l nx ny"># Plotting image and its blurred version<br/>f,ax = plt.subplots(1,2,figsize=(15,20))<br/>ax = ax.flatten()<br/>im = cv2.imread('../input/randomimages/pic1.jpeg',-1)<br/>im = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)<br/>im_blur = cv2.GaussianBlur(im,(7,7), 5, 5)<br/>ax[0].imshow(im,cmap='gray')<br/>ax[1].imshow(im_blur,cmap='gray')</span></pre><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi oi"><img src="../Images/f03d71fc3cd983e35d92cdc202ab7f50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aoNIRJ7FGjMipd8iNmS2vw.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">资料来源:联合国人类住区规划署</p></figure><p id="1dc5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">接下来，我们将定义两个函数。一个用于生成给定大小的高斯核，另一个用于获取模糊图像并使其变得清晰。</p><pre class="ll lm ln lo gt np nq nr bn ns nt bi"><span id="cefb" class="nu mb iq nq b be nv nw l nx ny">def gaussian_filter(kernel_size,img,sigma=1, muu=0):<br/>    x, y = np.meshgrid(np.linspace(-1, 1, kernel_size),<br/>                       np.linspace(-1, 1, kernel_size))<br/>    dst = np.sqrt(x**2+y**2)<br/>    normal = 1/(((2*np.pi)**0.5)*sigma)<br/>    gauss = np.exp(-((dst-muu)**2 / (2.0 * sigma**2))) * normal<br/>    gauss = np.pad(gauss, [(0, img.shape[0] - gauss.shape[0]), (0, img.shape[1] - gauss.shape[1])], 'constant')<br/>    return gauss<br/><br/>def fft_deblur(img,kernel_size,kernel_sigma=5,factor='wiener',const=0.002):<br/>    gauss = gaussian_filter(kernel_size,img,kernel_sigma)<br/>    img_fft = np.fft.fft2(img)<br/>    gauss_fft = np.fft.fft2(gauss)<br/>    weiner_factor = 1 / (1+(const/np.abs(gauss_fft)**2))<br/>    if factor!='wiener':<br/>        weiner_factor = factor<br/>    recon = img_fft/gauss_fft<br/>    recon*=weiner_factor<br/>    recon = np.abs(np.fft.ifft2(recon))<br/>    return recon</span></pre><p id="d57c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们深入研究一下 fft_deblur 函数。</p><ol class=""><li id="4071" class="nb nc iq kp b kq kr kt ku kw nd la ne le nf li ng nh ni nj bi translated">我们生成一个给定大小和标准偏差的高斯滤波器。我们也用零填充它，这样它就和图像的形状匹配了。这对于计算频域中的除法是必要的</li><li id="553d" class="nb nc iq kp b kq nk kt nl kw nm la nn le no li ng nh ni nj bi translated">计算模糊图像的傅立叶变换</li><li id="3a82" class="nb nc iq kp b kq nk kt nl kw nm la nn le no li ng nh ni nj bi translated">计算内核的傅立叶变换</li><li id="3ff2" class="nb nc iq kp b kq nk kt nl kw nm la nn le no li ng nh ni nj bi translated">定义维纳因子。我们稍后会谈到这一点。现在，假设它是 1</li><li id="8b2c" class="nb nc iq kp b kq nk kt nl kw nm la nn le no li ng nh ni nj bi translated">将重建定义为(3)和(4)的划分</li><li id="3886" class="nb nc iq kp b kq nk kt nl kw nm la nn le no li ng nh ni nj bi translated">将(6)乘以(5)</li><li id="fdf9" class="nb nc iq kp b kq nk kt nl kw nm la nn le no li ng nh ni nj bi translated">逆傅立叶变换(7)并计算其绝对值</li></ol><p id="fbaf" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们分析一下结果。</p><pre class="ll lm ln lo gt np nq nr bn ns nt bi"><span id="1a17" class="nu mb iq nq b be nv nw l nx ny">recon = fft_deblur(im_blur,7,5,factor=1)<br/>plt.subplots(figsize=(10,8))<br/>plt.imshow(recon,cmap='gray')</span></pre><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/eba4f6c733ccd67cb292fcc9567d3055.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*gXUGvAwb2ur5Z9SphXOYxA.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">上述操作的结果</p></figure><p id="44df" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">哎呀！这不起作用。之所以如此，是因为我们没有考虑到一个至关重要的因素——噪音。噪声可以从各种来源进入图像。因此，模糊图像等式修改为</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/973a716d5e0efb7316a80898179cadfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:238/0*XPBD_xa-1l_-xImn"/></div></figure><p id="dd84" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在，在计算模糊图像(B)的傅立叶变换时，我们也隐含地计算噪声分量的傅立叶变换。噪声的傅立叶变换有很多高频值。</p><pre class="ll lm ln lo gt np nq nr bn ns nt bi"><span id="1cc2" class="nu mb iq nq b be nv nw l nx ny">noise = np.random.rand(100,100)<br/>noise_fft = np.fft.fft2(noise)<br/>noise_fft = np.fft.fftshift(noise_fft)<br/>f,ax = plt.subplots(1,2,figsize=(15,20))<br/>ax = ax.flatten()<br/>ax[0].imshow(noise,cmap='gray')<br/>ax[0].set_title('Original Image')<br/>ax[1].imshow(20*np.log(abs(compute_fft(noise_fft))),cmap='gray')<br/>ax[1].set_title('Fourier Transform')</span></pre><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi ol"><img src="../Images/ca1e33fd2cd8d6efbb1c48a2abfd938f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f-I8iB4iiFH9x5LcY5BCUg.png"/></div></div></figure><p id="f590" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">另一方面，平滑内核有很多低频值。正如你在下图中看到的，如果我们偏离中心，我们会进入一个主要是黑色的区域(0 像素)。它的原始图像也大部分是黑色的，因为我们用零填充了它。靠近左上方有一小块白色区域。</p><pre class="ll lm ln lo gt np nq nr bn ns nt bi"><span id="fa86" class="nu mb iq nq b be nv nw l nx ny">gauss = gaussian_filter(7,im,5)<br/>gauss_fft = np.fft.fft2(gauss)<br/>gauss_fft = np.fft.fftshift(gauss_fft)<br/>f,ax = plt.subplots(1,2,figsize=(15,20))<br/>ax = ax.flatten()<br/>ax[0].imshow(gauss,cmap='gray')<br/>ax[0].set_title('Original Image')<br/>ax[1].imshow(np.abs(gauss_fft),cmap='gray')<br/>ax[1].set_title('Fourier Transform')</span></pre><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi of"><img src="../Images/f48da5ffa9118059b469379196623279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3o7z5H30OkCmKYjM4PhtPw.png"/></div></div></figure><p id="220a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">本质上，FT(B)中的高频值对应于噪声。当我们将其除以 FT(H)时，大部分由零组成，我们放大了噪声。因此，我们需要一个常客。香肠因素出现了。你可以在这里找到更多关于维纳滤波器的细节。我们可以用任何其他常数值代替 0.002。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi om"><img src="../Images/289f0e51836db98c013ac1bf9d4e9637.png" data-original-src="https://miro.medium.com/v2/resize:fit:218/0*YqVFN4eVTCHa4kr_"/></div></figure><pre class="ll lm ln lo gt np nq nr bn ns nt bi"><span id="e9b7" class="nu mb iq nq b be nv nw l nx ny">f,ax = plt.subplots(1,2,figsize=(15,20))<br/>recon = fft_deblur(im_blur,7,5,factor='wiener')<br/>ax[0].imshow(im_blur,cmap='gray')<br/>ax[1].imshow(recon)<br/>ax[0].set_title('Blurry Image')<br/>ax[1].set_title('Image reconstruction')<br/>plt.show()</span></pre><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi on"><img src="../Images/889a4591f7d532cc8fae315199f1a5d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M3fGJ3yfOrIjDXzJNQlT-A.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">资料来源:联合国人类住区规划署</p></figure><p id="384f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">有了维纳因子，我们得到了更好的结果。我们现在可以用这个常数来得到更清晰的重建。</p><pre class="ll lm ln lo gt np nq nr bn ns nt bi"><span id="0588" class="nu mb iq nq b be nv nw l nx ny">f,ax = plt.subplots(1,2,figsize=(15,20))<br/>recon = fft_deblur(im_blur,7,5,factor='wiener',const=0.5)<br/>ax[0].imshow(im_blur,cmap='gray')<br/>ax[1].imshow(recon)<br/>ax[0].set_title('Blurry Image')<br/>ax[1].set_title('Image reconstruction')<br/>plt.show()</span></pre><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi oo"><img src="../Images/f57b266c6e29ba330b8396f64d598194.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AIfijYMSPbZJ-ZRob54ylA.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">资料来源:联合国人类住区规划署</p></figure><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi op"><img src="../Images/05f0cc622615bf8c1ac1aadccd88721a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_pDA5C_E1rblmSnacUHFKg.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">资料来源:联合国人类住区规划署</p></figure><p id="13e1" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们不能直接在 RGB 图像上操作 FT。为了消除 RGB 图像的模糊，我们可以在每个颜色维度上分别运行去模糊功能，然后将它们连接起来。</p><h2 id="2969" class="ma mb iq bd mc md me dn mf mg mh dp mi kw mj mk ml la mm mn mo le mp mq mr ms bi translated">结论</h2><p id="f197" class="pw-post-body-paragraph kn ko iq kp b kq mt jr ks kt mu ju kv kw mv ky kz la mw lc ld le mx lg lh li ij bi translated">这是一个关于如何使用傅立叶变换去模糊图像的简短指南。虽然去模糊本身是一种应用，但它也可以用作深度学习训练管道中的重要预处理步骤。对傅里叶变换的透彻理解将有助于从事视觉/信号科学的任何人。这是一个宏伟的算法，根据<a class="ae lj" href="https://youtu.be/nmgFG7PUHfo" rel="noopener ugc nofollow" target="_blank">真理</a>的说法，它改变了世界。</p></div><div class="ab cl oq or hu os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="ij ik il im in"><h2 id="9870" class="ma mb iq bd mc md me dn mf mg mh dp mi kw mj mk ml la mm mn mo le mp mq mr ms bi translated">参考</h2><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="fa76" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><a class="ae lj" href="https://thepythoncodingbook.com/2021/08/30/2d-fourier-transform-in-python-and-fourier-synthesis-of-images/" rel="noopener ugc nofollow" target="_blank">https://thepythoncodingbook . com/2021/08/30/2d-python 中的傅里叶变换和图像的傅里叶合成/ </a></p></div></div>    
</body>
</html>