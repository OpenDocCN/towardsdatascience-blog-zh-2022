<html>
<head>
<title>The Equivalent of SQL Left Join in Python and Its Use in Data Cleaning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中 SQL Left Join 的等价及其在数据清理中的应用</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pure-left-join-with-python-how-to-find-unreferenced-values-across-tables-7b78f77b358d#2022-11-27">https://towardsdatascience.com/pure-left-join-with-python-how-to-find-unreferenced-values-across-tables-7b78f77b358d#2022-11-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="598e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用 Python 识别表中未引用值的技巧</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/be921397c2820d6d17dfd81c1187fda6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tMFRdUzez7nbcdRhEN39Ow.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@flipboo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">菲利普·布特</a>在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="35d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你曾经使用过关系数据库，你一定知道<a class="ae kv" href="https://en.wikipedia.org/wiki/Join_(SQL)" rel="noopener ugc nofollow" target="_blank"> SQL 连接</a>——它们有很多用例，但是在这篇文章中，我将把重点放在数据清理上。</p><p id="b889" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当执行左、右或全外连接时，您创建的表要么包含所有记录，要么只包含某些表中的记录。对于没有匹配项的行，将放置一个空值。因此，连接对于识别缺失或未引用的值非常有用。</p><p id="4169" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您的数据库中有一个包含所有用户的<code class="fe ls lt lu lv b">users</code>表。此外，您还有其他几个表引用了<code class="fe ls lt lu lv b">users</code>表的 id，如<code class="fe ls lt lu lv b">posts</code>、<code class="fe ls lt lu lv b">logins</code>、<code class="fe ls lt lu lv b">subscriptions</code>等。您有兴趣找出哪些用户可以从数据库中删除，因为他们没有与您的网站进行有意义的交互。这可以通过检查 id 是否在其他地方被引用来完成。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="3e7d" class="ma mb iq lv b be mc md l me mf">SELECT <br/>  u.userID AS 'User ID', <br/>  p.userID AS 'Post table' <br/>FROM users AS u<br/>  LEFT JOIN posts AS p ON u.userID = p.userID<br/>-- as users can have multiple posts<br/>GROUP BY p.userID;</span></pre><pre class="mg lw lv lx bn ly lz bi"><span id="a87a" class="ma mb iq lv b be mc md l mh mf">User ID      Post table   <br/>---------    ----------  <br/>1            Null   <br/>2            Null   <br/>3            3<br/>4            4<br/>5            Null</span></pre><p id="8659" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上表显示用户 1、2、5 没有创建任何帖子。您可能想要进一步研究并添加<code class="fe ls lt lu lv b">logins</code>和<code class="fe ls lt lu lv b">subscriptions</code>——这很好，但是如果您有许多额外的表想要以这种方式连接，您可能会遇到一些性能问题(<strong class="ky ir">提示</strong> : <em class="mi">如果您在使用 SQL 脚本，千万不要在您的生产数据库上这样做，首先创建一个本地副本</em>)。</p><h1 id="6a75" class="mj mb iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">用 Python 分析你的表</h1><p id="1931" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">如果您遇到性能问题或者需要更好的工具来分析您的数据库，一个想法是求助于 python，因为它有一个非常好的数据生态系统。例如，您可以使用<a class="ae kv" href="https://www.sqlalchemy.org/" rel="noopener ugc nofollow" target="_blank"> SQLAlchemy </a>或 Jupyter Notebook 的 SQL magic 函数来获取记录并将它们存储在列表(或字典)中。</p><p id="c19c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了演示如何用 python 进行左外连接，在这种情况下，我们不打算连接到数据库，而是创建一些随机数据并将其存储在字典中。我们将有一个包含所有可能的用户 id 的<code class="fe ls lt lu lv b">users</code>表和五个随机引用这些 id 的其他表:</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="4c17" class="ma mb iq lv b be mc md l me mf">import random<br/>import pandas as pd<br/><br/># defining range for userIDs, one to ten<br/>r = (1, 11)<br/>s, e  = r<br/><br/># creating dict to hold 'tables' and adding all possible user IDs <br/>tables = {}<br/>tables['users'] = list(range(*r))<br/><br/># generating ten tables with random IDs from the initial defined range of userIDs<br/>for i in range(1, 6):<br/>   table = random.sample(range(*r), random.randint(s-1, e-1))<br/>   tables[f'table{i}'] = table</span></pre><h1 id="e145" class="mj mb iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">熊猫</h1><p id="fb83" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">使用 pandas 似乎是显而易见的，因为它是 python 中数据的首选包。它有两个连接表的函数，<code class="fe ls lt lu lv b">pd.merge()</code>和<code class="fe ls lt lu lv b">pd.join()</code>(还有<code class="fe ls lt lu lv b">pd.concat()</code>——注意它的工作方式有点不同)，但是如果你至少有两列，其中一列是你要连接的，另一列包含你的值，这些函数工作得最好。这不是我们的情况，因为我们只有 id 列表。</p><p id="636f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看如果我们加入这两个列表会发生什么，<code class="fe ls lt lu lv b">tables['users']</code>和<code class="fe ls lt lu lv b">tables['table1']</code>:</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="297c" class="ma mb iq lv b be mc md l me mf">df_users = pd.DataFrame(tables['users'])<br/>df_table1 = pd.DataFrame(tables['table1'])<br/><br/>pd.merge(df_users, df_table1, how='left')</span></pre><pre class="mg lw lv lx bn ly lz bi"><span id="2467" class="ma mb iq lv b be mc md l mh mf">OUTPUT:<br/><br/>     0<br/>   ---<br/> 0   1<br/> 1   2<br/> 2   3<br/> 3   4<br/> 4   5<br/> 5   6<br/> 6   7<br/> 7   8<br/> 8   9<br/> 9  10</span></pre><p id="f5ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，结果是令人失望的，它似乎没有做任何事情。默认情况下，该函数连接唯一一列上的两个数据帧，因此我们获得所有的用户 id，仅此而已(除了索引之外)。在底层，它确实执行了正确的连接，但是因为我们没有额外的列，所以没有什么可显示的。我们需要添加<code class="fe ls lt lu lv b">indicator=True</code>参数来查看结果:</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="c9a9" class="ma mb iq lv b be mc md l me mf">pd.merge(df_users, df_table1, how='left', indicator=True)</span></pre><pre class="mg lw lv lx bn ly lz bi"><span id="1684" class="ma mb iq lv b be mc md l mh mf">OUTPUT:<br/><br/>            0      _merge<br/>    ---------   ---------<br/>0           1   left_only<br/>1           2   left_only<br/>2           3        both<br/>3           4        both<br/>4           5   left_only<br/>5           6   left_only<br/>6           7        both<br/>7           8   left_only<br/>8           9   left_only<br/>9          10        both</span></pre><p id="fad6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">_merge</code>列显示记录是存在于两个列表中还是只存在于第一个列表中。通过将初始数据帧的索引设置为唯一的现有列，并连接这些列，我们可以使结果更好:</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="cfa7" class="ma mb iq lv b be mc md l me mf">pd.merge(df_users.set_index(0), df_table1.set_index(0), how='left',<br/>  left_index=True, right_index=True, indicator=True)</span></pre><pre class="mg lw lv lx bn ly lz bi"><span id="a7fb" class="ma mb iq lv b be mc md l mh mf">OUTPUT:<br/><br/>       _merge<br/>    ---------<br/>0 <br/>1   left_only<br/>2   left_only<br/>3        both<br/>4        both<br/>5   left_only<br/>6   left_only<br/>7        both<br/>8   left_only<br/>9   left_only<br/>10       both</span></pre><p id="06a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这种方法可行，但是如果您想要连接多个列表(表)，它就很笨拙。</p><h1 id="a00e" class="mj mb iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">设置</h1><p id="b6a9" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">虽然这不是一个连接，但是使用 Python <em class="mi">集合</em>(注意，<em class="mi">集合</em>不能包含重复的值)可以实现预期的结果——识别未引用的值。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="a8b9" class="ma mb iq lv b be mc md l me mf">set_users = set(tables['users'])<br/>set_table1 = set(tables['table1'])<br/><br/>unreferenced_ids = set_users - set_table1</span></pre><p id="514f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过从另一个集合中减去一个<em class="mi">集合</em>，可以找到两个<em class="mi">集合</em>之间的差异——元素出现在<code class="fe ls lt lu lv b">users</code>中，而不在<code class="fe ls lt lu lv b">table1</code>集合<em class="mi">集合</em>中。其余的表也可以重复这个过程。</p><h1 id="4585" class="mj mb iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">使用循环</h1><p id="7065" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">对我来说最有效的解决方案是遍历列表(表格)并为未引用的 id 添加<code class="fe ls lt lu lv b">None</code>值。这是可能的，因为列表是有序的，我们可以遍历所有用户 id 并检查它们是否存在于其他表中。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="98fb" class="ma mb iq lv b be mc md l me mf"># creating a new dict<br/>final_tables = {}<br/><br/># transfering user IDs<br/>final_tables['users'] = tables.pop('users')<br/><br/># looping through the tables<br/>for key, value in tables.items():<br/><br/>    # creating a new column<br/>    column = []<br/><br/>    # checking values against all user IDs<br/>    for user in final_tables['users']:<br/>        # adding True if ID is referenced<br/>        if user in value:<br/>            column.append(True)<br/>        # adding None if ID is not referenced<br/>        else:<br/>            column.append(None)<br/><br/>    final_tables[key] = column<br/> <br/># converting the new dict holding the processed tables to a dataframe<br/>df = pd.DataFrame.from_dict(final_tables).set_index('users')</span></pre><pre class="mg lw lv lx bn ly lz bi"><span id="7905" class="ma mb iq lv b be mc md l mh mf">OUTPUT:<br/><br/>         table1   table2   table3   table4   table5<br/>        ------   ------   ------   ------   ------<br/>users     <br/>    1     True     True     True     True     True<br/>    2     True     None     Nooe     True     None<br/>    3     None     True     True     None     True<br/>    4     None     None     True     True     True<br/>    5     True     None     None     True     None<br/>    6     True     True     True     None     True<br/>    7     None     None     True     True     True<br/>    8     True     True     None     True     None<br/>    9     True     None     True     None     None<br/>   10     None     None     True     True     None</span></pre><p id="70b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">…就这样。该表显示了在 pandas 数据框架中的其他表中如何引用用户 id。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="069e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总而言之，如果您习惯于在关系数据库中执行左表连接，并希望在 Python 中实现类似的功能，您有几个选择。有<em class="mi">熊猫、</em>，但是令人惊讶的是，在两个单独的列上执行连接来查找未引用的值并不简单。或者，您可以使用<em class="mi">集合</em>来获得两列的唯一值的差异。但是最好的选择可能是使用简单的循环，尤其是当您想要识别几个表中不匹配的记录时。</p></div></div>    
</body>
</html>