<html>
<head>
<title>Dataclass — Easiest Ever Object-Oriented Programming In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">data class——Python中最简单的面向对象编程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dataclass-easiest-ever-object-oriented-programming-in-python-ffd37cd2a5bf#2022-05-03">https://towardsdatascience.com/dataclass-easiest-ever-object-oriented-programming-in-python-ffd37cd2a5bf#2022-05-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/bd8a1365471078ec73b5339e997b76b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w7WJu_CxWYCscG68WWSk8Q.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://pixabay.com/users/wal_172619-12138562/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6957870" rel="noopener ugc nofollow" target="_blank"> wal_172619 </a>发自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6957870" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><div class=""/><div class=""><h2 id="1c1f" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">Python内置的装饰器降低了代码的复杂性和长度</h2></div><p id="42ad" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Python中的面向对象编程(OOP)一直是热门话题之一。这是因为Python之所以出名，是因为它的灵活性和开箱即用的特性可以在很大程度上减少开发工作，这对于OOP来说也是如此。</p><p id="478c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我写过几篇关于在面向对象的场景中使用Python的文章。以下是其中的一些，供大家参考。</p><ul class=""><li id="2261" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/probably-the-best-practice-of-object-oriented-python-attr-d8c26c0e8a4">可能是面向对象Python的最佳实践— Attr </a></li><li id="6fb3" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/the-most-elegant-python-object-oriented-programming-b38d75f4ae7b">最优雅的Python面向对象编程</a></li></ul><p id="07d7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">他们都需要利用第三方库，这仍然是很好的解决方案。</p><p id="b374" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将介绍一个Python内置模块——data class。它是在Python 3.7中引入的，这使得开发人员能够在没有任何第三方库的情况下以面向对象的方式进行编码。</p><h1 id="dbdf" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">1.为什么选择数据类</h1><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/302593a7d9d25a25f693271d0e3e303c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rWAXqHXJpVgoWotfIG4qrw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1147815" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/elasticcomputefarm-1865639/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1147815" rel="noopener ugc nofollow" target="_blank"> ElasticComputeFarm </a>的图像</p></figure><p id="dfa3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我需要回答的第一个问题可能是为什么我们需要使用Dataclass？普通的Python类有什么问题？让我们考虑这样的场景。</p><p id="18ed" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将使用Python实现一个应用程序。假设我们需要编写一个“Person”类来保存对象中某个人的一些属性。我们可以写一个如下的类。</p><figure class="na nb nc nd gt iv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9b16" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这已经简化为只有3个属性。所以，我们可以如下实例化一个人。</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="97bb" class="nl mj jj nh b gy nm nn l no np">p1 = Person('Christopher', 'Tao', 34)</span></pre><p id="a1df" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们必须实现<code class="fe nq nr ns nh b">__repr__()</code>方法，因为我们希望出于调试目的方便地打印对象。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nt"><img src="../Images/62f67fe952983cb2bf26f59e8cb4b877.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rP0NLuZ0F136nkPJES1fkg.png"/></div></div></figure><p id="a214" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还想实现<code class="fe nq nr ns nh b">__eq__()</code>方法，因为我们想比较对象以确定它们是否是同一个“人”。</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="8330" class="nl mj jj nh b gy nm nn l no np">p2 = Person('Christopher', 'Tao', 34)<br/>p1 == p2 # compare the two persons</span></pre><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nu"><img src="../Images/39b46c988b0c11f71215014a4ed0fa0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ycn9cTjQBKcXCHeENW-T9A.png"/></div></div></figure><p id="63f7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，我们需要在个人类中的一些定制功能，如<code class="fe nq nr ns nh b">greeting()</code>方法。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/853e6bef493ae5d9aba2124ffcd24abc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*mPtngiGA559Xpu_unm5USw.png"/></div></figure><p id="d781" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与大多数其他编程语言相比，它已经足够好了。这已经很简洁了。不过我们当时做的一些事情还是比较有规律的，可以在Python的“禅”的指引下跳过。</p><p id="5c73" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们看看Dataclass如何改进这一点。我们只需要导入<code class="fe nq nr ns nh b">dataclass</code>，它内置在Python 3.7及以上版本中。</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="1c02" class="nl mj jj nh b gy nm nn l no np">from dataclasses import dataclass</span></pre><p id="bf56" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们可以在定义类时使用Dataclass作为装饰器。</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="9a78" class="nl mj jj nh b gy nm nn l no np"><a class="ae jg" href="http://twitter.com/dataclass" rel="noopener ugc nofollow" target="_blank">@dataclass</a><br/>class Person:<br/>    firstname: str<br/>    lastname: str<br/>    age: int</span><span id="a05b" class="nl mj jj nh b gy nw nn l no np">    def greeting(self):<br/>        print(f'Hello, {self.firstname} {self.lastname}!')</span></pre><p id="7f2a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这样。完成了。您可以预期，我们刚刚使用装饰器定义的数据类具有我们在前面的普通类中定义的所有特性。是的，除了<code class="fe nq nr ns nh b">greeting()</code>方法是一个真正的定制类方法，其他的都是在后台自动生成的。我们可以使用相同的代码进行测试(我不会附加两次测试演示代码)，并获得相同的结果。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nx"><img src="../Images/92f6ac0ac268ec77e981323aa9290155.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lc7rweQr9sqySTZcdWo72g.png"/></div></div></figure><p id="8814" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，直接的答案是Python Dataclass会自动为我们实现<code class="fe nq nr ns nh b">__init__()</code>、<code class="fe nq nr ns nh b">__repr__()</code>和<code class="fe nq nr ns nh b">__eq__()</code>方法。</p><h1 id="c8c8" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">2.现成的实用程序</h1><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/b207b704eb9f4d2e85b22790f0d4f137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MihcQVnojIHW9y1WDBNPBQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/users/picjumbo_com-2130229/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=864983" rel="noopener ugc nofollow" target="_blank">来自www.picjumbo.com的免费库存照片</a>来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=864983" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="a050" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了上面提到的基本好处，Dataclass还提供了一些非常方便的实用程序。我不会一一介绍，但这里会展示一些例子。</p><p id="af6a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦我们定义了一个数据类，我们就可以利用<code class="fe nq nr ns nh b">dataclasses</code>包中的一些工具。因此，为了方便起见，我们需要导入它，并可能给它一个别名。</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="87fd" class="nl mj jj nh b gy nm nn l no np">import dataclasses as dc</span></pre><p id="ac1b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们可以使用<code class="fe nq nr ns nh b">fields()</code>方法检索已定义数据类的字段。不仅是类定义，它还可以处理实例。</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="0038" class="nl mj jj nh b gy nm nn l no np">dc.fields(Person)<br/>dc.fields(p1)</span></pre><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ny"><img src="../Images/61fba0583e934399df6c69d30710aa8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qXXbkUCZcjGspXv1p2BEnw.png"/></div></div></figure><p id="6607" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为这些是“数据类”，所以将它们序列化为JSON对象是很常见的。这通常需要其他编程语言(如Java)的第三方库。然而，使用Python Dataclass，就像调用内置方法一样简单。我们可以从数据类对象中获取一个Python字典。</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="e1b5" class="nl mj jj nh b gy nm nn l no np">dc.asdict(p1)</span></pre><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nz"><img src="../Images/28f86238cdd91218c3d944e0d9b8cfbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G0-UwqXaDfk0Bqk7HC0gkw.png"/></div></div></figure><p id="eb07" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们只对字段的值感兴趣，我们也可以得到一个包含所有这些值的元组。这也将允许我们轻松地将其转换为列表。</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="0a34" class="nl mj jj nh b gy nm nn l no np">dc.astuple(p1)</span></pre><figure class="na nb nc nd gt iv gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/fdec4b844e77b4754097092ea4d7e852.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*QLzYqCo5OedxRTORl0L2kg.png"/></div></figure><p id="8a99" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有时，我们可能想要定义许多类，并且一些字段或方法可能被参数化。这通常在其他编程语言中用复杂的语法来完成，比如Java中的反射。然而，在Python中，我们可以使用<code class="fe nq nr ns nh b">make_dataclass()</code>方法来生成我们想要的数量。</p><p id="4744" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是一个使用方法生成“Student”类的示例。</p><figure class="na nb nc nd gt iv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="d0ec" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们可以像使用其他数据类一样使用这个类。</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="8af5" class="nl mj jj nh b gy nm nn l no np">s = Student('Christopher', 'Tao', '10001')<br/>print(s)<br/>s.greeting()</span></pre><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ob"><img src="../Images/1cc57b0a5cedb681d43fb400175cce0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-rHYqUkk7JEM_v078ZzNNg.png"/></div></div></figure><h1 id="87bf" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">3.定制的类注释</h1><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/1f80083ee27ed2795652a3ccc1287705.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a662WZSEw1v2A2U1ZzjoXg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2246457" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="6b43" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常，这些类型的特性只满足非常常见的用例。当我们有一些特殊的需求时，它可能会迫使我们回到使用正常的解决方案。然而，在Python中并非总是如此，Dataclass也是如此。</p><p id="5223" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Dataclass允许我们注释类装饰器来定制行为。</p><h2 id="871f" class="nl mj jj bd mk oc od dn mo oe of dp ms lh og oh mu ll oi oj mw lp ok ol my om bi translated">启用比较</h2><p id="8a49" class="pw-post-body-paragraph ky kz jj la b lb on kk ld le oo kn lg lh op lj lk ll oq ln lo lp or lr ls lt im bi translated">Dataclass自动为我们实现了<code class="fe nq nr ns nh b">__eq__()</code>方法，这很棒，但是其他的比较方法呢？换句话说，我们还需要<code class="fe nq nr ns nh b">__lt__()</code>、<code class="fe nq nr ns nh b">__gt__()</code>、<code class="fe nq nr ns nh b">__le__()</code>和<code class="fe nq nr ns nh b">__ge__()</code>方法。</p><p id="5ecf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们也可以很容易地自动实现它们，只需简单地给装饰添加一个标志<code class="fe nq nr ns nh b">order=True</code>。</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="4520" class="nl mj jj nh b gy nm nn l no np"><a class="ae jg" href="http://twitter.com/dataclass" rel="noopener ugc nofollow" target="_blank">@dataclass</a>(order=True)<br/>class Person:<br/>    name: str<br/>    age: int</span><span id="67c4" class="nl mj jj nh b gy nw nn l no np">p1 = Person('Alice', 30)<br/>p2 = Person('Bob', 56)</span></pre><figure class="na nb nc nd gt iv gh gi paragraph-image"><div class="gh gi os"><img src="../Images/139203e87f6b8b88368b22d0f760f4a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*2O5z1Hrt4V49Zew_szXmSw.png"/></div></figure><p id="7394" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该逻辑将使用第一个字段作为比较对象的标准。因此，为了方便地使用<code class="fe nq nr ns nh b">order</code>注释来自动生成所有的比较方法，我们可以将“age”字段放在前面。然后，这些人可以按年龄进行比较，如下所示。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/dc02bdb7e7b8360ae053c7ef06fe4050.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*meXhWeLeWAKriXY8JU9V9g.png"/></div></figure><h2 id="55ca" class="nl mj jj bd mk oc od dn mo oe of dp ms lh og oh mu ll oi oj mw lp ok ol my om bi translated">不可变字段</h2><p id="9fdc" class="pw-post-body-paragraph ky kz jj la b lb on kk ld le oo kn lg lh op lj lk ll oq ln lo lp or lr ls lt im bi translated">有时我们可能希望数据对象的属性不可更改。在这种情况下，我们可以通过在装饰器中添加标志<code class="fe nq nr ns nh b">frozen=True</code>来“冻结”字段。</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="9210" class="nl mj jj nh b gy nm nn l no np"><a class="ae jg" href="http://twitter.com/dataclass" rel="noopener ugc nofollow" target="_blank">@dataclass</a>(frozen=True)<br/>class Person:<br/>    name: str<br/>    age: int</span><span id="bd9e" class="nl mj jj nh b gy nw nn l no np">p1 = Person('Chris', 34)<br/>print(p1)</span></pre><figure class="na nb nc nd gt iv gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/2a8593488fc7481d65e476747894da90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*Y7LPZsTI7cA62ciuCD60yA.png"/></div></figure><p id="4d87" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，如果我们试图修改属性，将会抛出一个错误。</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="0a9c" class="nl mj jj nh b gy nm nn l no np">p1.name = 'Christopher'</span></pre><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ov"><img src="../Images/cac86ce7f5645fac61a80eda77525769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*80DCHmG0oL0Pv8LYvnuprg.png"/></div></div></figure><h1 id="02d2" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">4.定制字段注释</h1><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/d17572ae71522a1b12251a68cdc62da9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wSXfBpvXU8ipmAju93Lo4w.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://pixabay.com/users/nost-3003393/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1555218" rel="noopener ugc nofollow" target="_blank"> NOST </a>来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1555218" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="ece4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不仅在类级别，数据类中的字段也可以被注释。因此，我们可以为他们添加一些定制的行为。</p><h2 id="14d4" class="nl mj jj bd mk oc od dn mo oe of dp ms lh og oh mu ll oi oj mw lp ok ol my om bi translated">默认值和默认工厂</h2><p id="00ab" class="pw-post-body-paragraph ky kz jj la b lb on kk ld le oo kn lg lh op lj lk ll oq ln lo lp or lr ls lt im bi translated">我们可以给一个属性一个默认值。如果在初始化过程中没有给出，该属性将被赋予默认值。</p><p id="86ac" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另外，默认的“值”不限于一个值，它也可以是一个函数。</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="0f9f" class="nl mj jj nh b gy nm nn l no np"><a class="ae jg" href="http://twitter.com/dataclass" rel="noopener ugc nofollow" target="_blank">@dataclass</a><br/>class Employee:<br/>    firstname: str<br/>    lastname: str<br/>    skills: list = dc.field(default_factory=list)<br/>    employee_no: str = dc.field(default='00000')</span></pre><p id="45ec" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的Employee类中，如果没有给出，雇员号将是“00000”。如果在初始化过程中没有给出技能列表，也将对其进行初始化。</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="799b" class="nl mj jj nh b gy nm nn l no np">e1 = Employee('Christopher', 'Tao')<br/>print(e1)</span></pre><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ow"><img src="../Images/161b1bf67074363cac4e0381adea80c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8QRw7OvGK_SYV-9X2wYKSA.png"/></div></div></figure><p id="fc61" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们以后想给这个员工添加一些技能，我们可以添加技能列表，而不必检查它是否已经初始化。</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="7f56" class="nl mj jj nh b gy nm nn l no np">e1.skills += ['Python', 'Writing']<br/>print(e1)</span></pre><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ox"><img src="../Images/3a31c5a93ad7b3571b519dd303572ea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-kSRia5Exi0hZRrt_eMBFg.png"/></div></div></figure><h2 id="be23" class="nl mj jj bd mk oc od dn mo oe of dp ms lh og oh mu ll oi oj mw lp ok ol my om bi translated">排除字段</h2><p id="fcbd" class="pw-post-body-paragraph ky kz jj la b lb on kk ld le oo kn lg lh op lj lk ll oq ln lo lp or lr ls lt im bi translated">有时，我们可能不希望所有的字段都使用<code class="fe nq nr ns nh b">__init__()</code>方法。在一个普通的类中，我们只是不把它们添加到方法中。在一个数据类中，如果我们不想包含它们，我们需要将其标记为<code class="fe nq nr ns nh b">init=False</code>。</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="79ea" class="nl mj jj nh b gy nm nn l no np"><a class="ae jg" href="http://twitter.com/dataclass" rel="noopener ugc nofollow" target="_blank">@dataclass</a><br/>class Employee:<br/>    firstname: str<br/>    lastname: str<br/>    test_field: str = dc.field(init=False)</span></pre><p id="3154" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们可以创建一个对象，而不需要提供第三个字段的值，如下所示。</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="a0c9" class="nl mj jj nh b gy nm nn l no np">e1 = Employee('Christopher', 'Tao')</span></pre><p id="469d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，会有一个问题。也就是说，<code class="fe nq nr ns nh b">test_field</code>属性仍将在<code class="fe nq nr ns nh b">__repr__()</code>方法中实现。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oy"><img src="../Images/cec20bbd2daf060bf373d8553f5f8241.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PGgzPVteinfnGD-RvHdoCA.png"/></div></div></figure><p id="c090" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们需要添加另一个标志来将其排除在外。</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="92a1" class="nl mj jj nh b gy nm nn l no np"><a class="ae jg" href="http://twitter.com/dataclass" rel="noopener ugc nofollow" target="_blank">@dataclass</a><br/>class Employee:<br/>    firstname: str<br/>    lastname: str<br/>    test_field: str = dc.field(init=False, repr=False)</span><span id="0728" class="nl mj jj nh b gy nw nn l no np">e2 = Employee('Christopher', 'Tao')<br/>print(e2)</span></pre><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oz"><img src="../Images/115049158c810f5fcf004a449467b214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qg1TT9PrTNG_MsOY1Wm-vw.png"/></div></div></figure><p id="dbde" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在某些情况下，我们可能仍然希望在<code class="fe nq nr ns nh b">__init__()</code>方法中有一个字段，但只是想在打印对象时将其排除在外。为了实现这一点，我们只需要<code class="fe nq nr ns nh b">repr</code>标志。</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="a29e" class="nl mj jj nh b gy nm nn l no np"><a class="ae jg" href="http://twitter.com/dataclass" rel="noopener ugc nofollow" target="_blank">@dataclass</a><br/>class Employee:<br/>    firstname: str<br/>    lastname: str<br/>    test_field: str = dc.field(repr=False)</span><span id="3b33" class="nl mj jj nh b gy nw nn l no np">e3 = Employee('Christopher', 'Tao', 'test value')<br/>print(e3)</span></pre><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pa"><img src="../Images/e2b86d968b86adfbca819363068a2570.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KW1nOlk0bD1syG3tM-2Qnw.png"/></div></div></figure><h1 id="7b89" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">5.后初始化</h1><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/cb246fce3f9b522a525b7a890b6f3534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RgwZBKvGx79QBSFna4uMaA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1388228" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/photomix-company-1546875/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1388228" rel="noopener ugc nofollow" target="_blank">照片合成</a></p></figure><p id="db79" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为我想介绍的最后一个特性，它允许我们在初始化完成后定制数据类的行为。</p><p id="38f7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们想为矩形定义一个类。所以，它需要有高度和宽度。我们也希望有一个矩形的面积，但显然，这可以从其他两个属性派生出来。此外，我们想比较矩形的面积。</p><p id="bcbb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了实现这些，我们可以在数据类中实现一个<code class="fe nq nr ns nh b">__post_init__()</code>方法，如下所示。</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="42b1" class="nl mj jj nh b gy nm nn l no np"><a class="ae jg" href="http://twitter.com/dataclass" rel="noopener ugc nofollow" target="_blank">@dataclass</a>(order=True)<br/>class Rectangle:<br/>    area: float = dc.field(init=False)<br/>    height: float<br/>    width: float</span><span id="60e9" class="nl mj jj nh b gy nw nn l no np">    def __post_init__(self):<br/>        self.area = self.height * self.width</span></pre><p id="9e92" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建对象后，将执行post init方法。我们可以测试它是否有效。</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="c1a8" class="nl mj jj nh b gy nm nn l no np">r1 = Rectangle(2,4)<br/>print(r1)</span></pre><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pb"><img src="../Images/2759762b1e9316472c2d4f50c7d69fce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7SjR6cvKRZEIG_rv4EBXRw.png"/></div></div></figure><p id="eab5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我之所以要把<code class="fe nq nr ns nh b">area</code>字段放在第一个位置，是为了让它成为比较的标准。所以，矩形物体可以通过它们的面积来比较。</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="f1c0" class="nl mj jj nh b gy nm nn l no np">Rectangle(1,8) &gt; Rectangle(2,3)</span></pre><figure class="na nb nc nd gt iv gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/47adf9abe5d96e9ba143ac1c50adce14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*sdqiAJAvn5Gxd7oBUZQCgg.png"/></div></figure><h1 id="fd71" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">摘要</h1><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/8ecdb4eeac1818d6c3c5ab410b91b770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WF7pk39mmfhW0gFNA9iLgw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3021072" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a></p></figure><p id="09ac" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我介绍了Python中的Dataclass模块。它是从3.7版本开始内置的，这可以在很大程度上降低我们代码的复杂性，并大大加快我们的开发。</p><p id="78b8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Dataclass试图概括数据类的常见需求，并提供现成的，但它也提供类级和字段级的注释，允许我们定制行为。除此之外，post init方法给了我们更多的灵活性。</p><div class="is it gp gr iu pd"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd jk gy z fp pi fr fs pj fu fw ji bi translated">通过我的推荐链接加入灵媒-陶</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">medium.com</p></div></div><div class="pm l"><div class="pn l po pp pq pm pr ja pd"/></div></div></a></div><p id="b2dd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">如果你觉得我的文章有帮助，请考虑加入灵媒会员来支持我和成千上万的其他作家！(点击上面的链接)</strong></p><blockquote class="ps"><p id="9ff1" class="pt pu jj bd pv pw px py pz qa qb lt dk translated"><em class="qc">除非另有说明，所有图片均出自作者之手</em></p></blockquote></div></div>    
</body>
</html>