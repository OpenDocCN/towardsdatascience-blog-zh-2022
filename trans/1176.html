<html>
<head>
<title>Social Network Analysis and Spectral Clustering in Graphs and Networks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图和网络中的社会网络分析和谱聚类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/social-network-analysis-and-spectral-clustering-in-graphs-and-networks-40c8d878e946#2022-03-26">https://towardsdatascience.com/social-network-analysis-and-spectral-clustering-in-graphs-and-networks-40c8d878e946#2022-03-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1b46" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">图的中心性度量和划分技术简介</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/e5e84f7db2a8ea930ad60c81bcc282ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*ztUutp8G-rRIgboaCRa-1g.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片来源——由作者使用 Jupyter 笔记本准备。</p></figure><h1 id="b000" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">1.介绍</h1><h2 id="62bd" class="lm kv it bd kw ln lo dn la lp lq dp le lr ls lt lg lu lv lw li lx ly lz lk ma bi translated">1.1 图和网络的基础</h2><p id="9f35" class="pw-post-body-paragraph mb mc it md b me mf ju mg mh mi jx mj lr mk ml mm lu mn mo mp lx mq mr ms mt im bi translated">网络被定义为由线连接的点组成的图。这些点是节点、顶点，甚至是角色，而连接被称为边。例如，当考虑大学中的学生的社交网络时，每个学生代表一个节点，并且任何一对彼此熟悉的学生表示他们之间的边(友谊)。假设我们将节点定义为 V(与顶点同义)为{V1，V2，V3，…，Vn}，那么图的大小为|V|=n，即图中节点的数量。类似地，边被定义为给定节点对之间的关系。考虑将边定义为 E = {E1，E2，E3，…..，Em}，那么边的数量表示为|E|=m。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/a12c595e1f75f66a128282c4a059808e.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/0*kTTs-pHVVV7J7f5u.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><strong class="bd mv">图一。</strong>有向图的例子。网络或图中的边可以具有方向，例如，w.w.w(万维网)是有向图。边通常使用端点来表示，并且通常被定义为弧。在无向图中，这些定义方向的箭头通常是缺失的——这是作者准备的图像。</p></figure><p id="57d1" class="pw-post-body-paragraph mb mc it md b me mw ju mg mh mx jx mj lr my ml mm lu mz mo mp lx na mr ms mt im bi translated">表示一个图很简单，但是我们需要处理某些组件。下面的网络是无向图的一个例子。对于图中的任何节点 V，例如 Sharanya，它通过边连接到的节点集被称为它的邻居，并被表示为 N(v)。例如 N(Sharanya) = {Tabish，Angel，Panini}。类似地，连接到任何节点的边的数量被称为该节点的度(在下图中表示为每个节点顶部的数量)。在下面的例子中，Sharanya 连接到三个节点，因此度为 3。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/cb737bdc16f915c8a1a8fad0fdd59395.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/0*hPeGPMi15tMYZwaw.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><strong class="bd mv">图二。</strong>说明了一个无向图。每个节点代表一个个体，而节点之间的连接则代表程度——作者准备的图像。</p></figure><h2 id="5461" class="lm kv it bd kw ln lo dn la lp lq dp le lr ls lt lg lu lv lw li lx ly lz lk ma bi translated">1.2 学位与分布</h2><p id="9f38" class="pw-post-body-paragraph mb mc it md b me mf ju mg mh mi jx mj lr mk ml mm lu mn mo mp lx mq mr ms mt im bi translated">在剩下的文章中，我们将考虑图 2 所示的无向图的例子。在无向图中，<em class="ng">度数的总和是图中边数的两倍。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/545d240fb67dc327281a324210c47de4.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*s9mpmVy9azmomwjt6_rFDw.png"/></div></figure><p id="7f7a" class="pw-post-body-paragraph mb mc it md b me mw ju mg mh mx jx mj lr my ml mm lu mz mo mp lx na mr ms mt im bi translated">例如，图 2 中的总边数是 6。如果我们对每个节点的度数求和(1+3+2+4+1+1) = 12，则定理本身成立。</p><p id="a869" class="pw-post-body-paragraph mb mc it md b me mw ju mg mh mx jx mj lr my ml mm lu mz mo mp lx na mr ms mt im bi translated">在处理可拓图时，节点的度分布是一个需要分析的关键概念，被定义为度分布。例如，让我们考虑 R(d)作为上图中可能的度数序列。R(d) ={1，2，3，4}。我们将分数定义为图中节点总数上度数为“d”的节点数。这可以用来分析<strong class="md iu">幂律度分布。许多用户在像脸书这样的社交网站上朋友较少，然而也有一小部分用户拥有大量的朋友。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/6ba5dce519734d54a13765ee34e13732.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/format:webp/1*KjoOwRfNWLPTUgt58RKylg.png"/></div></figure><p id="c392" class="pw-post-body-paragraph mb mc it md b me mw ju mg mh mx jx mj lr my ml mm lu mz mo mp lx na mr ms mt im bi translated">计算:P1=3/6 = 50%(图中 3 个节点的度数为 1，6 个节点)。P2 = 1/6 = 17% (1 个度为 2 的节点，参考上图中的 Tabish，共 6 个节点)。</p><h2 id="fa37" class="lm kv it bd kw ln lo dn la lp lq dp le lr ls lt lg lu lv lw li lx ly lz lk ma bi translated">1.3 邻接矩阵</h2><p id="04ac" class="pw-post-body-paragraph mb mc it md b me mf ju mg mh mi jx mj lr mk ml mm lu mn mo mp lx mq mr ms mt im bi translated">捕捉图中节点之间连接的矩阵表示是邻接矩阵。</p><p id="0685" class="pw-post-body-paragraph mb mc it md b me mw ju mg mh mx jx mj lr my ml mm lu mz mo mp lx na mr ms mt im bi translated">Ai，j = 1，如果在节点 Vi 和 Vj 之间有边，否则我们将其标记为 0。这是表示社会网络、学术研究中的引用网络等的常用方法。该图的邻接矩阵如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/cb737bdc16f915c8a1a8fad0fdd59395.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/0*hPeGPMi15tMYZwaw.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><strong class="bd mv">图三。</strong>说明了一个无向图。每个节点代表一个个体，而节点之间的连接则代表程度——作者准备的图像。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nj"><img src="../Images/0904434760644a11a723a58fa02f2c25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jhSVdAZyVHQyOEZel0JLwg.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><strong class="bd mv">图四。</strong>显示了上图的邻接矩阵以及每个节点的度数。图片由作者准备。</p></figure><h1 id="5cea" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">2.节点的中心性度量</h1><p id="5918" class="pw-post-body-paragraph mb mc it md b me mf ju mg mh mi jx mj lr mk ml mm lu mn mo mp lx mq mr ms mt im bi translated">中心性允许我们计算数据中每个节点的重要性。假设在墨尔本有一场澳大利亚和韩国之间的足球世界杯预选赛，组织者想向上面网络中最有影响力的人分发一些免费门票。量化中心性的一种方式是通过使用邻接矩阵计算每个节点的度，即给定行中所有 1 的总和。在上面的例子中，帕尼尼拥有最高的度，值为 4，表明他在网络中有多个连接。然而，这可能并不总是正确的方法。想象帕尼尼有多个朋友，但他的朋友只有更少的朋友。为了避免这样的问题，我们可以使用特征向量来计算中心性。</p><p id="17e3" class="pw-post-body-paragraph mb mc it md b me mw ju mg mh mx jx mj lr my ml mm lu mz mo mp lx na mr ms mt im bi translated">特征向量给每个节点一个与其所有邻居分数之和成比例的分数。给定一个邻接矩阵 A，V 是 A 的一个特征向量，如果乘以 A 并不改变 V 所指的方向，它只是将它缩放一个因子λ，即 A×V =λ×V</p><h2 id="7287" class="lm kv it bd kw ln lo dn la lp lq dp le lr ls lt lg lu lv lw li lx ly lz lk ma bi translated">2.1 Zachary 的空手道俱乐部网络数据用 Python 中的 NetworkX</h2><p id="176e" class="pw-post-body-paragraph mb mc it md b me mf ju mg mh mi jx mj lr mk ml mm lu mn mo mp lx mq mr ms mt im bi translated">在这个例子中，我们将使用 Zachary 的空手道俱乐部网络数据来学习一些图形的基本概念。我们将研究图的节点、边、度、视觉表现等。我们还将学习如何使用谱聚类算法来执行图聚类。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="536c" class="lm kv it nl b gy np nq l nr ns"># !pip install networkx</span><span id="164c" class="lm kv it nl b gy nt nq l nr ns">%matplotlib inline</span><span id="57c9" class="lm kv it nl b gy nt nq l nr ns">import networkx as nx<br/>import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns</span><span id="f979" class="lm kv it nl b gy nt nq l nr ns">import warnings<br/>warnings.filterwarnings(‘ignore’) # — — — — — — to get rid of warning messages</span><span id="bd15" class="lm kv it nl b gy nt nq l nr ns"># — — — — — — — Remove scientific notations and display numbers with 2 decimal points instead — — — — — — — </span><span id="acb6" class="lm kv it nl b gy nt nq l nr ns">pd.options.display.float_format = ‘{:,.2f}’.format</span><span id="522d" class="lm kv it nl b gy nt nq l nr ns"># — — — — — — — Update default background style of plots — — — — — — — <br/>sns.set_style(style=’darkgrid’)</span></pre><blockquote class="nu nv nw"><p id="2668" class="mb mc ng md b me mw ju mg mh mx jx mj nx my ml mm ny mz mo mp nz na mr ms mt im bi translated">L <!-- -->加载数据。请注意，数据是作为 networkx 库的一部分出现的。</p></blockquote><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="9e1d" class="lm kv it nl b gy np nq l nr ns"># — — — — — — — — — — — -Reading Data — — — — — — — — — — — </span><span id="4d5f" class="lm kv it nl b gy nt nq l nr ns">kn=nx.karate_club_graph()</span><span id="6305" class="lm kv it nl b gy nt nq l nr ns"># — — — — — — — — — — — -The example below is a network from Zachry’s Karate club — — — — — — — — — — — </span><span id="b5ca" class="lm kv it nl b gy nt nq l nr ns"># — — — — — — — — — — — -Display Number of Nodes — — — — — — — — — — — </span><span id="1066" class="lm kv it nl b gy nt nq l nr ns">num_nodes = kn.number_of_nodes()</span><span id="4582" class="lm kv it nl b gy nt nq l nr ns">print(‘number of nodes: ‘ + str(num_nodes))</span><span id="266d" class="lm kv it nl b gy nt nq l nr ns">print(“-”*50)</span><span id="4bc4" class="lm kv it nl b gy nt nq l nr ns"># — — — — — — — — — — — -Display Number of Edges — — — — — — — — — — — </span><span id="14d4" class="lm kv it nl b gy nt nq l nr ns">num_edges = kn.number_of_edges()</span><span id="dbbb" class="lm kv it nl b gy nt nq l nr ns">print(‘number of edges: ‘ + str(num_edges))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/aef5a7876151dd5d3540d6f4ce6bd1e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*n7Bg6hax5KVvs0zMTT_jww.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><strong class="bd mv">输出 1。</strong>说明了网络中节点和边的数量。图片由作者使用 Jupyter 笔记本制作。</p></figure><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="5229" class="lm kv it nl b gy np nq l nr ns">with sns.axes_style(‘darkgrid’):<br/> <br/> fig = plt.subplots(1, figsize=(12,10))<br/> <br/> nx.draw_networkx(kn, edge_color=’#a7a7a5', with_labels=True, font_color=’white’)<br/> <br/> plt.axis(‘off’)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/a211635043699f20dd23d79656616cdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*gTVZ4FjeSLoafl5NPuf9mA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><strong class="bd mv">输出 2。</strong>说明了数据的网络表示。图片由作者使用 Jupyter 笔记本制作。</p></figure><h2 id="56d1" class="lm kv it bd kw ln lo dn la lp lq dp le lr ls lt lg lu lv lw li lx ly lz lk ma bi translated">2.2 度中心性</h2><p id="4104" class="pw-post-body-paragraph mb mc it md b me mf ju mg mh mi jx mj lr mk ml mm lu mn mo mp lx mq mr ms mt im bi translated">节点 v 的度中心性是它所连接的节点的分数。度中心性值通过除以简单图 n-1 中的最大可能度来归一化，其中 n 是 g 中的节点数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/80b21fde1b5fe84c9df18abfc6252f9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*jZGs7lDIq-rTH5i2BGa90g.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><strong class="bd mv">一级方程式赛车。</strong>举例说明度中心性的计算。图片由作者使用 Jupyter 笔记本和 Latex 制作。</p></figure><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="95f4" class="lm kv it nl b gy np nq l nr ns"># — — — — — — — — — let us store the degree centralities for each nodes for a graph in a dictionary</span><span id="989e" class="lm kv it nl b gy nt nq l nr ns">deg_cen = {}</span><span id="b486" class="lm kv it nl b gy nt nq l nr ns">graphs=[kn]</span><span id="7245" class="lm kv it nl b gy nt nq l nr ns">for g in graphs:<br/> <br/> deg_cen[g] = nx.degree_centrality(g)</span><span id="fded" class="lm kv it nl b gy nt nq l nr ns">print(deg_cen)</span></pre><p id="21b2" class="pw-post-body-paragraph mb mc it md b me mw ju mg mh mx jx mj lr my ml mm lu mz mo mp lx na mr ms mt im bi translated">我们可以使用上面定义的公式进行计算。我们选择图中的第 4 个节点进行验证。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="97f4" class="lm kv it nl b gy np nq l nr ns">num_nodes = graphs[0].number_of_nodes()</span><span id="d0ba" class="lm kv it nl b gy nt nq l nr ns">print(‘number of nodes: ‘ + str(num_nodes))</span><span id="003f" class="lm kv it nl b gy nt nq l nr ns">list_nodes=list(graphs[0].nodes)</span><span id="bfa0" class="lm kv it nl b gy nt nq l nr ns">print(list_nodes)</span><span id="1e5e" class="lm kv it nl b gy nt nq l nr ns">num_neighbors = graphs[0].degree(list_nodes[4])</span><span id="9399" class="lm kv it nl b gy nt nq l nr ns">print(‘degree of node ‘, list_nodes[4], ‘is ‘, num_neighbors )</span><span id="7967" class="lm kv it nl b gy nt nq l nr ns">print(“Degree of Centrality:”, round(num_neighbors/(num_nodes-1),3))</span></pre><h2 id="6109" class="lm kv it bd kw ln lo dn la lp lq dp le lr ls lt lg lu lv lw li lx ly lz lk ma bi translated">2.3 中间性</h2><p id="1990" class="pw-post-body-paragraph mb mc it md b me mf ju mg mh mi jx mj lr mk ml mm lu mn mo mp lx mq mr ms mt im bi translated">该度量确定网络中的哪些节点充当其他节点之间的“桥梁”。这是通过首先识别所有最短路径，然后计算每个节点落在其中一条路径上的次数来实现的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi oc"><img src="../Images/e2207ee551b3b011cf8821064ab9f92b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4oIeBRymAuAESg9AgH6P9g.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><strong class="bd mv">配方二。</strong>说明了之间中心性的计算。图片由作者使用 Jupyter 笔记本和 Latex 制作。</p></figure><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="68ad" class="lm kv it nl b gy np nq l nr ns"># Betweenness Centrality</span><span id="b675" class="lm kv it nl b gy nt nq l nr ns">betw_cen = {}<br/>for g in graphs:<br/> betw_cen[g] = nx.betweenness_centrality(g)</span><span id="1c60" class="lm kv it nl b gy nt nq l nr ns">betw_cen</span></pre><p id="e5c6" class="pw-post-body-paragraph mb mc it md b me mw ju mg mh mx jx mj lr my ml mm lu mz mo mp lx na mr ms mt im bi translated">理解一个节点的最短路径序列。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="9cf4" class="lm kv it nl b gy np nq l nr ns">paths= nx.all_pairs_shortest_path(graphs[0])</span><span id="23c7" class="lm kv it nl b gy nt nq l nr ns">path_5_1=nx.all_shortest_paths(graphs[0],5,1)</span><span id="95dc" class="lm kv it nl b gy nt nq l nr ns">for p in paths:<br/> <br/> if p[0]==5:<br/> <br/> print(p)<br/> print(“-”*50)<br/> <br/>for p in path_5_1:<br/> <br/> print(p)</span></pre><h2 id="2b01" class="lm kv it bd kw ln lo dn la lp lq dp le lr ls lt lg lu lv lw li lx ly lz lk ma bi translated">2.4 紧密中心性</h2><p id="31bd" class="pw-post-body-paragraph mb mc it md b me mf ju mg mh mi jx mj lr mk ml mm lu mn mo mp lx mq mr ms mt im bi translated">图中任何节点(比如 v)的接近中心性可以通过在所有 n-1 个可到达的节点上找到到 v 的平均最短路径距离，然后取它的倒数来计算。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/b753da3d22503f8e6d7aca0b79da83c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:350/format:webp/1*RP1aL4PlNu1VqLUhDDNGMA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><strong class="bd mv">配方三。</strong>说明了亲密度中心性的计算。图片由作者使用 Jupyter 笔记本和 Latex 制作。</p></figure><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="9e55" class="lm kv it nl b gy np nq l nr ns"># Closeness Centrality</span><span id="1122" class="lm kv it nl b gy nt nq l nr ns">clo_cen = {}</span><span id="1ff4" class="lm kv it nl b gy nt nq l nr ns">for g in graphs:<br/> clo_cen[g] = nx.closeness_centrality(g)<br/> <br/>clo_cen</span></pre><p id="efe1" class="pw-post-body-paragraph mb mc it md b me mw ju mg mh mx jx mj lr my ml mm lu mz mo mp lx na mr ms mt im bi translated">我们可以使用上面定义的公式进行计算。我们选择图中的第 5 个节点进行验证。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="abf1" class="lm kv it nl b gy np nq l nr ns">s=0</span><span id="eca6" class="lm kv it nl b gy nt nq l nr ns">print(len(list_nodes))</span><span id="ea4f" class="lm kv it nl b gy nt nq l nr ns">for node in list_nodes:<br/> <br/> if node!=5:<br/> <br/> shortest_path_length=nx.shortest_path_length(graphs[0],5,node)<br/> <br/> s+=shortest_path_length<br/> <br/>print((len(list_nodes)-1)/s)</span></pre><h2 id="fe6f" class="lm kv it bd kw ln lo dn la lp lq dp le lr ls lt lg lu lv lw li lx ly lz lk ma bi translated">2.5 特征向量中心性</h2><p id="1bdd" class="pw-post-body-paragraph mb mc it md b me mf ju mg mh mi jx mj lr mk ml mm lu mn mo mp lx mq mr ms mt im bi translated">特征向量中心性使用其邻居的中心性来计算节点的中心性。对于节点 I，特征向量中心性是 A’X X =λX X，其中 A’被定义为具有λ特征值的图 G 的邻接矩阵。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="662a" class="lm kv it nl b gy np nq l nr ns"># Eigen Vector Centrality</span><span id="1b71" class="lm kv it nl b gy nt nq l nr ns">eig_cen = {}</span><span id="7ba3" class="lm kv it nl b gy nt nq l nr ns">for g in graphs:<br/> <br/> eig_cen[g] = nx.eigenvector_centrality(g)</span><span id="5b9a" class="lm kv it nl b gy nt nq l nr ns">eig_cen</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi oe"><img src="../Images/025b9d5c04736eb75965d6dbbf70f479.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RoCW_eDQ_qHUIL3A9hGYvg.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><strong class="bd mv">图 5。</strong>说明了现实世界问题中不同中心性测量的用例(迪士尼，2019)。图片由作者用 Excel 制作。</p></figure><h2 id="34aa" class="lm kv it bd kw ln lo dn la lp lq dp le lr ls lt lg lu lv lw li lx ly lz lk ma bi translated">2.6 可视化图中的重要节点</h2><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="334b" class="lm kv it nl b gy np nq l nr ns"># let us now sort the degree centrality measure and identify the important nodes.</span><span id="2412" class="lm kv it nl b gy nt nq l nr ns">for ix, g in enumerate(graphs):<br/> <br/> temp_dict = {}<br/> <br/> for w in sorted(deg_cen[g], key=deg_cen[g].get, reverse=True):<br/> <br/> temp_dict[w] = deg_cen[g][w]<br/> <br/> print(“Sorted Importance of nodes in terms of deg_cen for Graph {} is {}”.format(ix+1, list(temp_dict.keys())[:5]))<br/> <br/> print()</span></pre><p id="6236" class="pw-post-body-paragraph mb mc it md b me mw ju mg mh mx jx mj lr my ml mm lu mz mo mp lx na mr ms mt im bi translated">对于图 1，根据 deg_cen，节点的排序重要性是[33，0，32，2，1]。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="2bd7" class="lm kv it nl b gy np nq l nr ns">graph2 = kn<br/>color = []</span><span id="d12e" class="lm kv it nl b gy nt nq l nr ns">fig = plt.subplots(1, figsize=(12,10))</span><span id="7a86" class="lm kv it nl b gy nt nq l nr ns">for node in graph2:<br/> if (node == 33 or node == 0 or node == 32 or node==2 or node==1):<br/> color.append(‘red’)<br/> else:<br/> color.append(‘blue’)<br/> <br/>nx.draw_spring(graph2,node_color=color,with_labels=True)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/2d8d384cff1aa7ff5b5e0163fd641f69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*hsxTwdYfwzrazsGof5CSPg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><strong class="bd mv">输出 3。</strong>用重要节点说明数据的网络表示。图片由作者使用 Jupyter 笔记本制作。</p></figure><h1 id="58c1" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">3.谱聚类</h1><p id="d1b2" class="pw-post-body-paragraph mb mc it md b me mf ju mg mh mi jx mj lr mk ml mm lu mn mo mp lx mq mr ms mt im bi translated">谱聚类算法用于根据图的连通性将图分成 K 个组。谱聚类中涉及的步骤包括:</p><ol class=""><li id="331d" class="of og it md b me mw mh mx lr oh lu oi lx oj mt ok ol om on bi translated">预处理:构造图的拉普拉斯矩阵。拉普拉斯矩阵是邻接矩阵和对角矩阵之间的差异。L = D — A。</li><li id="6558" class="of og it md b me oo mh op lr oq lu or lx os mt ok ol om on bi translated">分解——计算拉普拉斯矩阵的特征值和特征向量，然后我们需要将每个点映射到一个更低维的表示。</li><li id="6749" class="of og it md b me oo mh op lr oq lu or lx os mt ok ol om on bi translated">k 表示算法—使用上述数据创建聚类组。</li></ol><h2 id="88b5" class="lm kv it bd kw ln lo dn la lp lq dp le lr ls lt lg lu lv lw li lx ly lz lk ma bi translated">3.1 预处理</h2><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="dc35" class="lm kv it nl b gy np nq l nr ns">G_p1=graphs[0]</span><span id="00cf" class="lm kv it nl b gy nt nq l nr ns">A=nx.adjacency_matrix(G_p1)</span><span id="432b" class="lm kv it nl b gy nt nq l nr ns">print(“ — — — — — — — — — -ADJACENCY MATRIX — — — — — — — — — — — -”)</span><span id="96df" class="lm kv it nl b gy nt nq l nr ns">print(A.todense())</span><span id="a1d8" class="lm kv it nl b gy nt nq l nr ns">print(“-”*50)</span><span id="f1db" class="lm kv it nl b gy nt nq l nr ns">print(“ — — — — — — — — — -DIAGONAL MATRIX = DEGREE OF EACH NODE — — — — — — — — — — — -”)</span><span id="5756" class="lm kv it nl b gy nt nq l nr ns">print(G_p1.degree)</span><span id="cf3e" class="lm kv it nl b gy nt nq l nr ns">L = nx.laplacian_matrix(G_p1).astype(float)</span><span id="7a57" class="lm kv it nl b gy nt nq l nr ns">print(“-”*50)</span><span id="c9d3" class="lm kv it nl b gy nt nq l nr ns">print(“ — — — — — — — — — -LAPLACIAN MATRIX — — — — — — — — — — — -”)</span><span id="96ab" class="lm kv it nl b gy nt nq l nr ns">print(L.todense())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi ot"><img src="../Images/38a224a0c22731c2cf7c15d404b98089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HtHU9-3Q2zWuvixRmPjcfA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><strong class="bd mv">输出 4。</strong>说明了网络的拉普拉斯矩阵、邻接矩阵和对角矩阵。图片由作者使用 Jupyter 笔记本制作。</p></figure><h2 id="b558" class="lm kv it bd kw ln lo dn la lp lq dp le lr ls lt lg lu lv lw li lx ly lz lk ma bi translated">3.2 分解</h2><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="512a" class="lm kv it nl b gy np nq l nr ns">import scipy as sp</span><span id="e658" class="lm kv it nl b gy nt nq l nr ns">w,v = sp.sparse.linalg.eigsh(L, k = 3, which=’SM’)</span><span id="756a" class="lm kv it nl b gy nt nq l nr ns">print(w)<br/>print(v)</span></pre><h2 id="10df" class="lm kv it bd kw ln lo dn la lp lq dp le lr ls lt lg lu lv lw li lx ly lz lk ma bi translated">3.3 K 表示聚类</h2><p id="6cf0" class="pw-post-body-paragraph mb mc it md b me mf ju mg mh mi jx mj lr mk ml mm lu mn mo mp lx mq mr ms mt im bi translated">请注意，我们已经创建了 3 个集群作为假设场景。然而，在现实世界的应用中，使用轮廓分数、间隙统计，甚至肘图来验证 K 的良好值是很重要的。对于图划分，更常见的度量是 F-Measure、Precision、Recall、Purity、Mutual Information 和 Normalized Mutual Information。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="72dd" class="lm kv it nl b gy np nq l nr ns">from sklearn.cluster import KMeans</span><span id="c982" class="lm kv it nl b gy nt nq l nr ns">X = v*w</span><span id="820f" class="lm kv it nl b gy nt nq l nr ns">kmeans = KMeans(init=’k-means++’, n_clusters=3, n_init=10)<br/>kmeans.fit_predict(X)<br/>centroids = kmeans.cluster_centers_<br/>labels = kmeans.labels_<br/>error = kmeans.inertia_</span><span id="f2bd" class="lm kv it nl b gy nt nq l nr ns">fig = plt.subplots(1, figsize=(12,10))</span><span id="2309" class="lm kv it nl b gy nt nq l nr ns">colors = ['#d7191c', '#ffffbf', '#2b83ba']<br/>node_colors = [ colors[labels[v]] for v in G_p1.nodes()]<br/>nx.draw(G_p1, node_color=node_colors, with_labels='True')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/e5e84f7db2a8ea930ad60c81bcc282ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*ztUutp8G-rRIgboaCRa-1g.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><strong class="bd mv">输出 5。</strong>用三个集群说明了数据的网络表示。图片由作者使用 Jupyter 笔记本制作。</p></figure><h1 id="348c" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">4.参考</h1><ol class=""><li id="a14b" class="of og it md b me mf mh mi lr ou lu ov lx ow mt ok ol om on bi translated">布兰德斯大学(2001 年)。中间中心性的快速算法。<em class="ng">《数理社会学杂志》</em>，<em class="ng"> 25 </em> (2)，163–177 页。<a class="ae ox" href="https://doi.org/10.1080/0022250x.2001.9990249" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.1080/0022250x.2001.9990249</a></li><li id="0818" class="of og it md b me oo mh op lr oq lu or lx os mt ok ol om on bi translated"><em class="ng">在线创建图形并寻找最短路径或使用其他算法</em>。(未注明)。https://graphonline.ru/en/</li><li id="191f" class="of og it md b me oo mh op lr oq lu or lx os mt ok ol om on bi translated">迪士尼，A. (2019 年 7 月 26 日)。<em class="ng">社交网络分析:中心性测量</em>。剑桥情报局。<a class="ae ox" href="https://cambridge-intelligence.com/keylines-faqs-social-network-analysis/" rel="noopener ugc nofollow" target="_blank">https://Cambridge-intelligence . com/keylines-FAQ-social-network-analysis/</a></li><li id="f364" class="of og it md b me oo mh op lr oq lu or lx os mt ok ol om on bi translated">NetworkX。(2022).<em class="ng">between ness _ centrality—NetworkX 2 . 7 . 1 文档</em>。Networkx.org。<a class="ae ox" href="https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.centrality.betweenness_centrality.html#networkx.algorithms.centrality.betweenness_centrality" rel="noopener ugc nofollow" target="_blank">https://networkx . org/documentation/stable/reference/algorithms/generated/networkx . algorithms . between ness _ centrality . html # networkx . algorithms . centrality . between ness _ centrality</a></li></ol></div><div class="ab cl oy oz hx pa" role="separator"><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd"/></div><div class="im in io ip iq"><p id="fcb0" class="pw-post-body-paragraph mb mc it md b me mw ju mg mh mx jx mj lr my ml mm lu mz mo mp lx na mr ms mt im bi translated"><em class="ng">关于作者:高级分析专家和管理顾问，通过对组织数据的商业、技术和数学的组合，帮助公司找到各种问题的解决方案。一个数据科学爱好者，在这里分享、学习、贡献；可以和我在</em> <a class="ae ox" href="https://www.linkedin.com/in/angel-das-9532bb12a/" rel="noopener ugc nofollow" target="_blank"> <em class="ng">上联系</em> </a> <em class="ng">和</em> <a class="ae ox" href="https://twitter.com/dasangel07_andy" rel="noopener ugc nofollow" target="_blank"> <em class="ng">推特</em></a><em class="ng">；</em></p></div></div>    
</body>
</html>