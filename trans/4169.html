<html>
<head>
<title>Crack SQL Interview Question: Join vs Case-When Statement</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">破解SQL面试问题:Join vs Case-When语句</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/crack-sql-interview-question-join-vs-case-when-statement-116d40a361f0#2022-09-15">https://towardsdatascience.com/crack-sql-interview-question-join-vs-case-when-statement-116d40a361f0#2022-09-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fd65" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用有用的程序解决SQL问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dbdf5d028adfe5c254f6e01e8454974e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OPwfuMjfik1QXXXl"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/es/@linkedinsalesnavigator?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> LinkedIn销售解决方案</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="7932" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将回顾脸书数据科学采访中的一个SQL问题。希望本文中解释的过程能够帮助您更有效地编写SQL查询。</p><p id="8767" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQL问题:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ccf0" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">Users By Average Session Time</strong></span><span id="60db" class="ma mb it lw b gy mg md l me mf">Calculate each user's average session time. A session is defined as the time difference between a page_load and page_exit. For simplicity, assume a user has only 1 session per day and if there are multiple of the same events on that day, consider only the latest page_load and earliest page_exit. Output the user_id and their average session time.</span><span id="7150" class="ma mb it lw b gy mg md l me mf">Source: <a class="ae ky" href="https://platform.stratascratch.com/coding/10352-users-by-avg-session-time?code_type=1" rel="noopener ugc nofollow" target="_blank">stratascratch.com</a></span></pre><p id="86c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">表格:facebook_web_log</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/46f02f6c4dac2c926cc79f8385c900ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WK3L2aThhf3Cbk7Gyqs6Dg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8d0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第一步</strong>:我们先看看原始数据。该表包括一系列动作，例如对于给定的用户id，带有时间戳的“页面加载”、“向下滚动”、“向上滚动”、“页面退出”。我们被指派计算每个用户的平均会话时间。让我们澄清几件事。举个例子，</p><ul class=""><li id="64b9" class="mi mj it lb b lc ld lf lg li mk lm ml lq mm lu mn mo mp mq bi translated">会话是如何定义的？根据这个问题，会话被定义为“页面加载”和“页面退出”之间的时间差。如果在给定的一天中有多个相同的事件，例如“page_load”和“page_exit”，那么考虑只使用<strong class="lb iu">最新的page_load </strong>和<strong class="lb iu">最早的page_exit </strong>。</li><li id="8129" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated">如果用户在给定的一天中只有两个事件中的一个，即“页面加载”和“页面退出”。比如2019年4月25日，user_id 2只有“page_load”事件，没有找到“page_exit”。我们应该如何处理这种情况？</li><li id="71ab" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated">同样在给定的一天中，对于用户来说，最新的page_load可能晚于最早的page_exit。如果是这样，应该怎么处理？</li><li id="329f" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated">这些是我们需要从面试官那里得到澄清的问题。在本练习中，如果两个事件中只有一个事件或者最晚的page_load比最早的page_exit晚，我们将排除这些记录。</li></ul><p id="d957" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤2 </strong>:我们需要确定解决问题所需的相关信息。举个例子，</p><ul class=""><li id="8ec1" class="mi mj it lb b lc ld lf lg li mk lm ml lq mm lu mn mo mp mq bi translated">我们只需要在“action”字段中使用值为“page_load”和“page_exit”的行，因为这就是会话时间的定义方式。</li><li id="abc5" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated">我们需要从时间戳变量中提取日期变量，因为这是会话时间的来源。</li></ul><p id="bca0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤3 </strong>:我们将准备数据并创建我们在步骤2中确定的变量。在这一步，我将使用两种不同的方法。</p><p id="a987" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">方法1:连接两个临时表，加载并退出</strong></p><ul class=""><li id="ef5c" class="mi mj it lb b lc ld lf lg li mk lm ml lq mm lu mn mo mp mq bi translated">要创建只包含“page_load”动作的加载表，我们可以使用<code class="fe mw mx my lw b">WHERE action = ‘page_load’</code>。如果一个用户在给定的日期有多个“page_load”操作，我们将只保留最新的一个。因此，我们使用<code class="fe mw mx my lw b">timestamp::DATE</code>来创建日期变量，并使用聚合函数<code class="fe mw mx my lw b">MAX(timestamp)</code>和<code class="fe mw mx my lw b">GROUP BY user_id, timestamp::DATE</code>来保存给定日期内最新的“page_load”操作。</li><li id="b6b4" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated">为了创建只包含“page_exit”动作的退出表，我们使用了<code class="fe mw mx my lw b">WHERE action = ‘page_exit’</code>。然后我们使用聚合函数<code class="fe mw mx my lw b">MIN(timestamp)</code>和<code class="fe mw mx my lw b">GROUP BY user_id, timestamp::DATE</code>来保持给定日期内最早的“page_exit”动作。</li><li id="59eb" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated">一旦使用<code class="fe mw mx my lw b">WITH</code>语句创建了加载和退出表，我们就可以基于“user_id”和“date”将这两个表连接在一起。这里我们将使用<code class="fe mw mx my lw b">INNER JOIN</code>,因为我们需要在给定的一天为用户提供“page_load”和“page_event”。</li></ul><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3789" class="ma mb it lw b gy mc md l me mf">WITH load AS(</span><span id="d00b" class="ma mb it lw b gy mg md l me mf">SELECT user_id,</span><span id="3189" class="ma mb it lw b gy mg md l me mf">timestamp::DATE AS date,</span><span id="b8e0" class="ma mb it lw b gy mg md l me mf">MAX(timestamp) AS lastest_load</span><span id="d6e2" class="ma mb it lw b gy mg md l me mf">FROM facebook_web_log</span><span id="ccf8" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">WHERE </strong>action = 'page_load'</span><span id="0fe6" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">GROUP BY</strong> user_id, timestamp::DATE</span><span id="bc0b" class="ma mb it lw b gy mg md l me mf">),</span><span id="b9c6" class="ma mb it lw b gy mg md l me mf">-- Create Exit table</span><span id="9b51" class="ma mb it lw b gy mg md l me mf">exit AS(</span><span id="79b0" class="ma mb it lw b gy mg md l me mf">SELECT user_id,</span><span id="2fbc" class="ma mb it lw b gy mg md l me mf">timestamp::DATE AS date,</span><span id="3f2f" class="ma mb it lw b gy mg md l me mf">MIN(timestamp) AS earliest_exit</span><span id="3291" class="ma mb it lw b gy mg md l me mf">FROM facebook_web_log</span><span id="8b38" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">WHERE </strong>action = 'page_exit'</span><span id="2e9f" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">GROUP BY</strong> user_id, timestamp::DATE</span><span id="e0c1" class="ma mb it lw b gy mg md l me mf">)</span><span id="b095" class="ma mb it lw b gy mg md l me mf">SELECT a.user_id,</span><span id="50b7" class="ma mb it lw b gy mg md l me mf">a.date,</span><span id="ac6f" class="ma mb it lw b gy mg md l me mf">a.lastest_load,</span><span id="67f0" class="ma mb it lw b gy mg md l me mf">b.earliest_exit</span><span id="e226" class="ma mb it lw b gy mg md l me mf">FROM LOAD a</span><span id="a6fe" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">INNER JOIN</strong> exit b</span><span id="3890" class="ma mb it lw b gy mg md l me mf">ON a.user_id = b.user_id AND</span><span id="164c" class="ma mb it lw b gy mg md l me mf">a.date = b.date</span></pre><p id="c2cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们运行上面的代码时，我们可以生成如下所示的表格:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/ea2abdd3fee7a04d43c3df2aad8498a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cb-e_q5O6or-B5j7y8BeAQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="e647" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">方法2:使用CASE-WHEN语句创建两个新列Load和Exit</strong></p><ul class=""><li id="7ead" class="mi mj it lb b lc ld lf lg li mk lm ml lq mm lu mn mo mp mq bi translated">我们可以使用<code class="fe mw mx my lw b">CASE-WHEN</code>语句，而不是使用WHERE语句来保持“page_load”和“page_exit”动作。代码<code class="fe mw mx my lw b">CASE WHEN action = ‘page_load’ THEN timestamp ELSE NULL END</code>可以创建一个只包含“page_load”动作时间戳的新列，并为其他动作将其设置为NULL。我们将为“page_exit”操作编写类似的代码。</li><li id="501f" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated">一旦我们有了这两个新列，我们就可以使用聚合函数<code class="fe mw mx my lw b">MAX()</code>和<code class="fe mw mx my lw b">MIN()</code>为具有<code class="fe mw mx my lw b">GROUP BY user_id, timestamp::DATE</code>的用户计算给定日期的“page_load”动作的最新时间戳和“page_exit”动作的最早时间戳。</li></ul><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2fba" class="ma mb it lw b gy mc md l me mf">SELECT user_id,</span><span id="0cca" class="ma mb it lw b gy mg md l me mf">timestamp::DATE AS date,</span><span id="5f2e" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">MAX</strong>(<strong class="lw iu">CASE WHEN</strong> action = 'page_load' <strong class="lw iu">THEN </strong>timestamp <strong class="lw iu">ELSE </strong>NULL END) AS latest_page_load,</span><span id="e84a" class="ma mb it lw b gy mg md l me mf">MIN(CASE WHEN action = 'page_exit' THEN timestamp ELSE NULL END) AS earliest_page_exit</span><span id="dda0" class="ma mb it lw b gy mg md l me mf">FROM facebook_web_log</span><span id="379e" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">GROUP BY</strong> user_id, timestamp::DATE</span></pre><p id="3e5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们运行上面的代码时，我们可以生成如下的表格。您将注意到此输出的不同之处——我们在2019年4月25日为user_id 2多了一条记录，因为我们使用了<code class="fe mw mx my lw b">INNER JOIN</code>来仅保留方法1中的匹配记录，而我们在此仅保留“page_load”和“page_exit”的所有可用记录。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/b77073548f64af41788bbed63c938582.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rLINXxS0A1suE2txNvHCiA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="90bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤4 </strong>:在步骤3中准备好数据后，计算每个user_id的平均会话时间应该很简单。我们只需要使用聚合函数<code class="fe mw mx my lw b">AVG()</code>和<code class="fe mw mx my lw b">GROUP BY user_id</code>。</p><p id="b1f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">使用方法1的最终解决方案:连接两个临时表，加载并退出</strong></p><p id="c7aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将代码<code class="fe mw mx my lw b">WHERE b.earliest_exit ≥ a.lastest_load</code>放在最后，因为我们希望避免最新的page_load比最早的page_exit晚的情况。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8715" class="ma mb it lw b gy mc md l me mf">WITH load AS(</span><span id="f56f" class="ma mb it lw b gy mg md l me mf">SELECT user_id,</span><span id="6e10" class="ma mb it lw b gy mg md l me mf">timestamp::DATE AS date,</span><span id="bf39" class="ma mb it lw b gy mg md l me mf">MAX(timestamp) AS lastest_load</span><span id="54e7" class="ma mb it lw b gy mg md l me mf">FROM facebook_web_log</span><span id="7bcc" class="ma mb it lw b gy mg md l me mf">WHERE action = 'page_load'</span><span id="bb19" class="ma mb it lw b gy mg md l me mf">GROUP BY user_id, timestamp::DATE</span><span id="5cac" class="ma mb it lw b gy mg md l me mf">),</span><span id="d949" class="ma mb it lw b gy mg md l me mf">-- Create Exit table</span><span id="786f" class="ma mb it lw b gy mg md l me mf">exit AS(</span><span id="7e29" class="ma mb it lw b gy mg md l me mf">SELECT user_id,</span><span id="b97c" class="ma mb it lw b gy mg md l me mf">timestamp::DATE AS date,</span><span id="c5fa" class="ma mb it lw b gy mg md l me mf">MIN(timestamp) AS earliest_exit</span><span id="71b1" class="ma mb it lw b gy mg md l me mf">FROM facebook_web_log</span><span id="0495" class="ma mb it lw b gy mg md l me mf">WHERE action = 'page_exit'</span><span id="4690" class="ma mb it lw b gy mg md l me mf">GROUP BY user_id, timestamp::DATE</span><span id="1d9a" class="ma mb it lw b gy mg md l me mf">)</span><span id="fffa" class="ma mb it lw b gy mg md l me mf">SELECT a.user_id,</span><span id="df07" class="ma mb it lw b gy mg md l me mf">AVG(b.earliest_exit - a.lastest_load) AS avg_session_time</span><span id="df44" class="ma mb it lw b gy mg md l me mf">FROM LOAD a</span><span id="5224" class="ma mb it lw b gy mg md l me mf">INNER JOIN exit b</span><span id="a68e" class="ma mb it lw b gy mg md l me mf">ON a.user_id = b.user_id AND</span><span id="ce48" class="ma mb it lw b gy mg md l me mf">a.date = b.date</span><span id="8a70" class="ma mb it lw b gy mg md l me mf">WHERE b.earliest_exit &gt;= a.lastest_load</span><span id="19c5" class="ma mb it lw b gy mg md l me mf">GROUP BY a.user_id</span></pre><p id="a619" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">使用方法2的最终解决方案:使用CASE-WHEN语句创建两个新列Load和Exit】</strong></p><p id="92f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个方法，我在代码中包含了,<code class="fe mw mx my lw b">WHERE (earliest_page_exit-latest_page_load) IS NOT NULL</code>,因为我们希望在2019年4月25日删除user_id 2的额外记录。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4219" class="ma mb it lw b gy mc md l me mf">WITH CTE AS(</span><span id="39cf" class="ma mb it lw b gy mg md l me mf">SELECT user_id,</span><span id="dc99" class="ma mb it lw b gy mg md l me mf">timestamp::DATE AS date,</span><span id="3c49" class="ma mb it lw b gy mg md l me mf">MAX(CASE WHEN action = 'page_load' THEN timestamp ELSE NULL END) AS latest_page_load,</span><span id="d24c" class="ma mb it lw b gy mg md l me mf">MIN(CASE WHEN action = 'page_exit' THEN timestamp ELSE NULL END) AS earliest_page_exit</span><span id="33b0" class="ma mb it lw b gy mg md l me mf">FROM facebook_web_log</span><span id="0908" class="ma mb it lw b gy mg md l me mf">GROUP BY user_id, timestamp::DATE</span><span id="fa03" class="ma mb it lw b gy mg md l me mf">)</span><span id="5ea6" class="ma mb it lw b gy mg md l me mf">SELECT user_id,</span><span id="e844" class="ma mb it lw b gy mg md l me mf">AVG(earliest_page_exit-latest_page_load) AS avg_session_time</span><span id="d9e6" class="ma mb it lw b gy mg md l me mf">FROM CTE</span><span id="f6a2" class="ma mb it lw b gy mg md l me mf">WHERE (earliest_page_exit-latest_page_load) IS NOT NULL AND</span><span id="1a34" class="ma mb it lw b gy mg md l me mf">earliest_page_exit &gt;= latest_page_load</span><span id="5834" class="ma mb it lw b gy mg md l me mf">GROUP BY user_id</span></pre><p id="4f17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回答:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/2dc3a4c1fdda38ee79c86cd1929279d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ajAWM8OhPpfqEoodjfW8-Q.png"/></div></div></figure><p id="377f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想探索更多的<strong class="lb iu"> SQL面试问题</strong>，请查看我的文章:</p><ul class=""><li id="7e21" class="mi mj it lb b lc ld lf lg li mk lm ml lq mm lu mn mo mp mq bi translated"><a class="ae ky" href="https://medium.com/geekculture/comprehensive-sql-cheat-sheet-f821c5abf85a" rel="noopener"> <strong class="lb iu">综合SQL备忘单</strong> </a></li><li id="ef27" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/practical-sql-questions-for-data-science-interview-3b5c9d726baa"> <strong class="lb iu">用有用的程序破解SQL面试问题</strong> </a></li><li id="6f12" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/sql-for-data-analysis-subquery-vs-cte-699ef629d9eb"> <strong class="lb iu">破解SQL面试问题:子查询vs CTE</strong></a></li><li id="f058" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/crack-sql-interview-question-join-vs-case-when-statement-116d40a361f0"> <strong class="lb iu">破解SQL面试问题:Join vs Case-When语句</strong> </a></li><li id="af79" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/crack-sql-interview-question-window-functions-with-partition-by-599d792c07c3"> <strong class="lb iu">破解SQL面试题:带分区的窗口函数——By</strong></a></li><li id="0036" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/crack-sql-interview-question-date-part-function-aff0b15478d9"> <strong class="lb iu">破解SQL面试问题:Date_Part函数</strong> </a></li><li id="1b6e" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated"><a class="ae ky" href="https://medium.com/geekculture/crack-sql-interview-questions-row-number-rank-and-dense-rank-ef439749f3ff" rel="noopener"> <strong class="lb iu">破解SQL面试题:ROW_NUMBER、RANK和DENSE_RANK </strong> </a></li><li id="deca" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated"><a class="ae ky" href="https://python.plainenglish.io/crack-sql-interview-question-unnest-string-to-array-1b75578cbe75" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">破解SQL面试问题:UNNEST，STRING_TO_ARRAY </strong> </a></li><li id="b070" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated"><a class="ae ky" href="https://medium.com/geekculture/crack-sql-interview-question-generate-series-string-agg-split-part-fbc0e5e42d7d" rel="noopener"> <strong class="lb iu">破解SQL面试问题:GENERATE_SERIES，STRING_AGG，SPLIT_PART </strong> </a></li><li id="5e50" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated"><a class="ae ky" href="https://medium.com/geekculture/crack-sql-interview-question-self-join-and-non-equi-join-1cb2a181104a" rel="noopener"> <strong class="lb iu">破解SQL面试问题:自连接和非等价连接</strong> </a></li><li id="23a7" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated"><a class="ae ky" href="https://medium.com/geekculture/crack-sql-interview-question-any-operator-d39e07e0e224" rel="noopener"> <strong class="lb iu">破解SQL面试问题:任意运算符</strong> </a></li><li id="38f5" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated"><a class="ae ky" href="https://medium.com/geekculture/crack-sql-interview-question-subquery-d9db4763eef4" rel="noopener"> <strong class="lb iu">破解SQL面试问题:子查询</strong> </a></li></ul><h2 id="f9d8" class="ma mb it bd nc nd ne dn nf ng nh dp ni li nj nk nl lm nm nn no lq np nq nr ns bi translated">感谢您的阅读！！！</h2><p id="9aff" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">如果你喜欢这篇文章，并且想<strong class="lb iu">请我喝杯咖啡，</strong>请<a class="ae ky" href="https://ko-fi.com/aaronzhu" rel="noopener ugc nofollow" target="_blank">点击这里</a>。</p><p id="f3f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以注册一个<a class="ae ky" href="https://aaron-zhu.medium.com/membership" rel="noopener"> <strong class="lb iu">会员</strong> </a>来解锁我的文章的全部访问权限，并且可以无限制地访问介质上的所有内容。如果你想在我发表新文章时收到电子邮件通知，请订阅。</p></div></div>    
</body>
</html>