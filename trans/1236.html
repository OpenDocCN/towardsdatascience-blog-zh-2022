<html>
<head>
<title>How to Create Interactive Maps Using Python GeoPy and Plotly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用 Python GeoPy 和 Plotly 创建交互式地图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/work-with-geospatial-data-and-create-interactive-maps-using-geopy-and-plotly-28178d2868f1#2022-03-29">https://towardsdatascience.com/work-with-geospatial-data-and-create-interactive-maps-using-geopy-and-plotly-28178d2868f1#2022-03-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7abe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">地理编码，<strong class="ak">反向地理编码，计算</strong>表面距离，行驶距离，用 Python 创建散点图、气泡图、Choropleth 图和动画图</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/468e67ad9f09dbd978a49ac88978810e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wY_verGNnh8hqBrRh5edcg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="9785" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">地理空间数据科学正在蓬勃发展。典型的地理空间数据集包括纬度、经度、地址、街道名称、邮政编码等数据。这些数据需要一套不同的工具来处理，并将其转化为见解。在本文中，我将分享对处理地理空间数据和创建地理空间可视化有用的<strong class="la iu"> Python 库</strong>:<strong class="la iu">GeoPy</strong>和<strong class="la iu"> Plotly </strong>。</p><h1 id="b5bd" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">一.处理地理空间数据</h1><p id="6bb6" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">GeoPy 是一个 Python 库，提供对几种流行的地理编码 web 服务的访问，如 Google Maps、Bing Maps、nomist 和 Yahoo BOSS。它是帮助我们处理地理空间数据的有用工具。</p><h2 id="4bf8" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">安装库</h2><p id="c122" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">打开 anaconda 提示符或命令提示符，并键入以下命令。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="b8cd" class="mr lv it ne b gy ni nj l nk nl">pip install geopy</span></pre><h2 id="207e" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">导入库</h2><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="03c9" class="mr lv it ne b gy ni nj l nk nl">import geopy</span></pre><h2 id="81a1" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">初始化地理编码服务 API</h2><p id="707e" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">正如我上面提到的，有许多地理编码 API 可用。可以使用免费 API，比如，<strong class="la iu"> OpenStreetMap </strong>或者付费 API，比如，<strong class="la iu"> Google Maps。这完全取决于你将如何部署你的程序。你会得到你所付出的。一个免费的 API 可能很适合你自己喜欢的项目。如果您将部署用于商业目的，您应该考虑付费 API，因为您可以扩展每日 API 配额限制。</strong></p><p id="889f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了使用谷歌地图 API，我们需要一个谷歌地图 API。你可以按照这个<a class="ae nm" href="https://yoast.com/help/generate-set-google-maps-api-key/" rel="noopener ugc nofollow" target="_blank">快速教程</a>为<strong class="la iu">免费</strong>生成自己的谷歌地图 API 密匙。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="eeaa" class="mr lv it ne b gy ni nj l nk nl"># <strong class="ne iu">OpenStreetMap API</strong><br/>from geopy.geocoders import Nominatim<br/>geolocator = Nominatim(user_agent="<a class="ae nm" href="mailto:aaron_clover@hotmail.com" rel="noopener ugc nofollow" target="_blank">Y</a>our Email")</span><span id="e3e6" class="mr lv it ne b gy nn nj l nk nl"># <strong class="ne iu">Google Maps API</strong><br/>from geopy.geocoders import GoogleV3<br/>geolocator = GoogleV3(api_key='Your Google Maps API Key')</span></pre><h2 id="e5f3" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">从原始地址中提取纬度和经度</h2><p id="f8f3" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">为了创建地图，我们需要获得每个位置的纬度和经度。通常，数据集会包含地址信息，如街道号、街道名称、城市、州、邮政编码。要获得纬度和经度，我们可以使用 GeoPy 的“<strong class="la iu"> geocode </strong>”函数。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="2f82" class="mr lv it ne b gy ni nj l nk nl">address = '5801 SW Regional Airport Blvd Bentonville AR'<br/>location = geolocator.geocode(address)<br/>print(location.latitude, location.longitude)<br/># 36.3236395 -94.255661</span></pre><p id="3d7b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae nm" rel="noopener" target="_blank" href="/transform-messy-address-into-clean-data-effortlessly-using-geopy-and-python-d3f726461225">“地理编码”功能的另一个用途是<strong class="la iu">将杂乱的地址数据转换成干净、标准化的格式</strong>。</a></p><h2 id="1cc0" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">从纬度和经度提取原始地址信息</h2><p id="d447" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">有时，数据集可能只有纬度和经度，而没有任何地址信息，例如对人类有意义的城市、州、邮政编码。<strong class="la iu">逆向地理编码</strong>是将位置坐标转换为带有位置信息的地址的重要步骤。要实现这一点，我们可以简单地使用“<strong class="la iu">反向</strong>函数来获取位置的地址信息</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="db02" class="mr lv it ne b gy ni nj l nk nl">location = geolocator.reverse('36.350885, -94.239816')<br/>print(location.address)<br/># 2658, Southwest 20th Street, Bentonville, Benton County, Arkansas, 72713, United States</span></pre><p id="bd4b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了我们上面提到的公共和商业地理编码服务 API，还有<strong class="la iu">政府地理编码 API</strong>，它们对公众开放。例如，我们可以从<a class="ae nm" href="https://geo.fcc.gov/api/census/" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu"> FCC 的 Area 和 Census Block API</strong></a><strong class="la iu"/>中提取县信息，使用经纬度。</p><p id="682e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下面的代码中，我们创建了一个<strong class="la iu">函数</strong>，“extract_location_data”，使用纬度和经度从 FCC API 返回位置信息。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="7be3" class="mr lv it ne b gy ni nj l nk nl">import requests<br/>import urllib<br/>def <strong class="ne iu">extract_location_data</strong>(lat, lon):<br/>    params = urllib.parse.urlencode({'latitude': lat, 'longitude':lon, 'format':'json'})<br/>    url = '<a class="ae nm" href="https://geo.fcc.gov/api/census/block/find?'" rel="noopener ugc nofollow" target="_blank"><strong class="ne iu">https://geo.fcc.gov/api/census</strong>/block/find?'</a> + params<br/>    response = requests.get(url)<br/>    data = response.json()<br/>    return data</span><span id="36af" class="mr lv it ne b gy nn nj l nk nl">result = extract_location_data(36.350885, -94.239816)<br/>print(result['County'])<br/>print(result['State'])<br/># {'FIPS': '05007', 'name': 'Benton County'}<br/># {'FIPS': '05', 'code': 'AR', 'name': 'Arkansas'}</span></pre><h2 id="b50c" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">测量两地之间的表面距离</h2><p id="bf82" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">两个地方之间的距离可能是许多机器学习模型中的一个基本特征。但是数据集中通常缺少这些信息。为了计算距离，我们不必自己应用数学公式。GeoPy 库中提供了<strong class="la iu">测地线</strong>函数来计算两个地方之间的表面距离。</p><p id="07d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下面的代码中，“<strong class="la iu">测地线((lat_1，lon_1)，(lat_2，lon_2)) </strong>”将返回两个坐标之间的表面距离。您可以用公里、英里或英尺来返回距离。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="5786" class="mr lv it ne b gy ni nj l nk nl">from <strong class="ne iu">geopy.distance</strong> import <strong class="ne iu">geodesic</strong><br/>point1 = (36.236984, -93.09345)<br/>point2 = (36.179905, -94.50208)<br/>distance = <strong class="ne iu">geodesic</strong>(point1, point2)<br/>print(<strong class="ne iu">distance.miles</strong>, ' miles')<br/>print(d<strong class="ne iu">istance.meters</strong>, ' meters')<br/># 78.80808645816887  miles<br/># 126829.32109293535  meters</span></pre><h2 id="8b39" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">测量两地之间的行驶距离</h2><p id="c9c7" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">表面距离仅仅是一个理论概念，它适用于两个地方之间的直线距离。我们可能需要汽车、自行车或步行的驾驶距离，这在机器学习模型中更有意义。使用 API 很容易获得行驶距离。</p><p id="a3f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">方法一</strong>:使用<a class="ae nm" href="http://project-osrm.org/docs/v5.5.1/api/#general-options" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">自由 OSRM API </strong> </a>计算行驶距离</p><p id="9943" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">OSRM 是一个免费的开源 API。用 Python 中的“<strong class="la iu">请求</strong>”函数提取信息很容易。在下面的代码中，它向 API 发送两个坐标，它将返回行驶距离和行驶时间。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="ab83" class="mr lv it ne b gy ni nj l nk nl">import requests<br/>import json<br/>lat_1, lon_1  = 36.236984, -93.09345<br/>lat_2, lon_2  = 36.179905, -94.50208</span><span id="bfb4" class="mr lv it ne b gy nn nj l nk nl">r = requests.get(f"<a class="ae nm" href="http://router.project-osrm.org/route/v1/driving/{lon_1},{lat_1};{lon_2},{lat_2}?overview=false" rel="noopener ugc nofollow" target="_blank"><strong class="ne iu">http://router.project-osrm.org/route/v1/driving/{lon_1},{lat_1};{lon_2},{lat_2}?overview=false</strong></a>""")<br/>routes = json.loads(r.content)<br/>route_1 = routes.get("routes")[0]<br/>print(route_1["duration"], ' seconds') <br/>print(route_1["distance"], ' meters') <br/># 8048.5  seconds<br/># 150883.3  meters</span></pre><p id="099a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">方法二</strong>:使用<a class="ae nm" href="https://developers.google.com/maps/documentation/distance-matrix/overview" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">谷歌距离矩阵 API </strong> </a>计算行驶距离</p><p id="3f8c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们也可以使用<strong class="la iu"> googlemaps </strong>库和<strong class="la iu"> Google 的距离矩阵 API </strong>来获取类似的信息。从下面的代码中可以看出，从谷歌的距离矩阵 API 得到的结果与从 OSRM API 得到的结果相当。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="b35a" class="mr lv it ne b gy ni nj l nk nl">import <strong class="ne iu">googlemaps</strong></span><span id="617d" class="mr lv it ne b gy nn nj l nk nl">gmap = <strong class="ne iu">googlemaps.Client</strong>(key='Your Google Maps API Key')<br/>gmap_output = gmap.distance_matrix((36.236984, -93.09345), (36.179905, -94.50208), mode='driving')<br/>print(gmap_output['rows'][0]['elements'][0]['duration']['value'], 'seconds')<br/>print(gmap_output['rows'][0]['elements'][0]['distance']['value'], 'meters')<br/># 6913 seconds<br/># 150700 meters</span></pre><h1 id="a89b" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">二。基本地图</h1><p id="afff" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">在本节中，我将讨论如何使用<strong class="la iu"> Plotly </strong>库来创建具有交互功能的漂亮地图。这些图表很容易制作，并且是独立的，可以随时展示。</p><p id="0bce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Plotly 还制作了<a class="ae nm" rel="noopener" target="_blank" href="/deploy-machine-learning-model-using-dash-and-pipenv-c543569c33a6"> <strong class="la iu"> Dash </strong>，这是一个用于创建可视化、构建 web 应用程序和部署机器学习模型的 Python 框架。</a></p><h2 id="d7bb" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">安装库</h2><p id="cd5f" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">打开 anaconda 提示符或命令提示符，并键入以下命令。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="55a5" class="mr lv it ne b gy ni nj l nk nl">pip install plotly</span></pre><h2 id="1337" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">导入库</h2><p id="b876" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">除了 Plotly 基本函数，我们还将 Plotly 使用<a class="ae nm" href="https://plotly.com/python/plotly-express/" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">。Express </strong> </a>，它是 Plotly 的一个包装器，可以用简单的语法创建复杂而丰富的交互图形。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="41fa" class="mr lv it ne b gy ni nj l nk nl">import plotly<br/>import plotly.express as px</span></pre><h2 id="433a" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">注册地图框令牌</h2><p id="d33f" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">如果你要创建一个基于 MapBox 服务的地图，那么你需要<a class="ae nm" href="https://www.mapbox.com/" rel="noopener ugc nofollow" target="_blank">注册一个免费的 MapBox 账户</a>并获得一个 MapxBox 令牌。这里 可以获得一个免费的地图框令牌<a class="ae nm" href="https://docs.mapbox.com/api/accounts/tokens/" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">。典型的令牌看起来像“PK . eyj 1 ijoyiwayb 24 ty 2 xvdmvyxxxxsi 6 imnrcgvybwd 3 atcwaxuyd 242am v9 nzfvaziifq . 8 snsj 0 JCI 1 vknued 2 finib”。</strong></a></p><p id="9c55" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果使用 Plotly.Express，您可以在<code class="fe no np nq ne b">layout.mapbox.access_token</code>或<code class="fe no np nq ne b">px.set_mapbox_access_token()</code>配置功能中注册令牌。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="53d5" class="mr lv it ne b gy ni nj l nk nl">from urllib.request import urlopen<br/><strong class="ne iu">px.set_mapbox_access_token</strong>(open('mapbox.mapbox_token').read())<br/><strong class="ne iu">mapbox_access_token </strong>= open('mapbox.mapbox_token').read()</span></pre><h2 id="b642" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">创建模拟位置数据</h2><p id="f7d2" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">对于本文，我将创建一个模拟的地理空间数据集，其中包括美国 1000 个随机生成的地点。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="358d" class="mr lv it ne b gy ni nj l nk nl">lon = []<br/>lat = []<br/>county = []<br/>state = []<br/>observation = 1</span><span id="5a11" class="mr lv it ne b gy nn nj l nk nl">while observation &lt;= 1000:<br/>        lon_0 = np.random.uniform(-120,-65)<br/>        lat_0 = np.random.uniform(26,48)<br/>        data = <strong class="ne iu">extract_location_data</strong>(lat_0, lon_0)<br/>        print(data)<br/>        if data['status'] == 'OK':<br/>            if data['County']['FIPS'] != None:<br/>                lon.append(lon_0)<br/>                lat.append(lat_0)<br/>                county.append(data['County']['FIPS'])<br/>                state.append(data['State']['code'])<br/>                observation +=1<br/>            else:<br/>                pass<br/>        else:<br/>            pass <br/>        <br/>years = [randint(2000, 2010) for i in range(1000)]<br/>        <br/>df = pd.DataFrame({'long': lon, 'lat': lat, 'state': state, 'county_fips': county, 'year': years})</span></pre><h2 id="6cf5" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">在地图中创建位置散点图</h2><p id="03da" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">首先，让我们创建一个最简单的地图，一个散点图，它在地图上显示位置。我们将使用 Plotly.Express 中的"<strong class="la iu"> scatter_mapbox </strong>。在程序中，我们需要指定位置的<strong class="la iu">纬度</strong>和<strong class="la iu">经度</strong>。</p><p id="d5f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要导出地图图形，我们可以使用“<strong class="la iu"> write_html </strong>函数将绘图保存在本地文件夹中。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="35f3" class="mr lv it ne b gy ni nj l nk nl">fig = px.<strong class="ne iu">scatter_mapbox</strong>(<br/>    df, <br/>    lat="lat", <br/>    lon="long", <br/>    zoom=4,<br/>    title = 'Simulated Locations in the US'<br/>    )</span><span id="9bdb" class="mr lv it ne b gy nn nj l nk nl">fig.write_html('Locations Map.html')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/12466ef6184bdf727497087052d8147c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6POALQp2Ip0lMdsy7a1vjw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="69c8" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">创建 Choropleth 地图</h2><p id="4e55" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">接下来，我们将创建 choropleth 地图，这是一种统计专题地图，使用颜色的强度来表示地理位置内地理特征的汇总。在下面的代码中，我们将创建两个 choropleth 地图——第一个显示美国每个州的沃尔玛商店<strong class="la iu">的数量，第二个显示每个县</strong>的沃尔玛商店<strong class="la iu">的数量。</strong></p><p id="0845" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在创建地图之前，我们需要汇总数据来计算每个州或县的沃尔玛商店数量。为此，我们在 Pandas 中使用“groupby”和“count”函数。然后可以使用“<strong class="la iu"> choropleth </strong>功能创建 Choropleth 图。</p><ul class=""><li id="220f" class="nt nu it la b lb lc le lf lh nv ll nw lp nx lt ny nz oa ob bi translated">"<strong class="la iu"> location </strong>"参数将采用地理单位(例如，州或县 FIPS 代码)。</li><li id="fb6b" class="nt nu it la b lb oc le od lh oe ll of lp og lt ny nz oa ob bi translated">"<strong class="la iu"> color </strong>"参数将采用与地理单元内的颜色强度相对应的数值(例如，沃尔玛商店的数量)。沃尔玛商店的数量越多，颜色越深。</li><li id="49cd" class="nt nu it la b lb oc le od lh oe ll of lp og lt ny nz oa ob bi translated">"<strong class="la iu"> locationmode </strong>"参数表示地图上的一组位置。它可以采用“ISO-3”、“美国-州”或“国家名称”中的一个。“ISO-3”是一个由三个字母组成的国家代码，而“美国-州”将返回带有州边界的美国地图。<strong class="la iu">县边界</strong>在“locationmode”参数中不可用。相反，我们需要在“<strong class="la iu"> geojson </strong>”参数中包含一个县<strong class="la iu"> GeoJSON </strong>文件。此 GeoJSON 文件位于'<a class="ae nm" href="https://raw.githubusercontent.com/plotly/datasets/master/geojson-counties-fips.json'" rel="noopener ugc nofollow" target="_blank">https://raw . githubusercontent . com/plot ly/datasets/master/geo JSON-counties-FIPS . JSON '</a>。</li><li id="54cb" class="nt nu it la b lb oc le od lh oe ll of lp og lt ny nz oa ob bi translated">"<strong class="la iu">范围</strong>参数表示地图中的范围。它可以取“世界”、“美国”、“欧洲”、“亚洲”、“非洲”、“北美”或“南美”中的一个</li><li id="7484" class="nt nu it la b lb oc le od lh oe ll of lp og lt ny nz oa ob bi translated">"<strong class="la iu"> color_continuous_scale </strong>"参数指定当由" color "表示的列包含数值时的连续色标</li></ul><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="5c1f" class="mr lv it ne b gy ni nj l nk nl"># by state<br/>store_by_st = df.groupby('state')['long'].count().reset_index()<br/>store_by_st.rename(columns = {'long':'Number of Locations'}, inplace = True)</span><span id="89df" class="mr lv it ne b gy nn nj l nk nl">fig = px.<strong class="ne iu">choropleth</strong>(<br/>    locations=store_by_st['state'], <br/>    color = store_by_st['Number of Locations'].astype(float), <br/>    <strong class="ne iu">locationmode</strong>="<strong class="ne iu">USA-states</strong>", <br/>    <strong class="ne iu">scope</strong>="usa", <br/>    <strong class="ne iu">color_continuous_scale </strong>= 'ylorrd', <br/>    labels={'color':'Number of Locations'},<br/>    title = 'Number of Simulated Locations by State'<br/>    )<br/>fig.write_html('Choropleth Map by state.html')</span><span id="df28" class="mr lv it ne b gy nn nj l nk nl">##################<br/># by county <br/>with urlopen('<a class="ae nm" href="https://raw.githubusercontent.com/plotly/datasets/master/geojson-counties-fips.json'" rel="noopener ugc nofollow" target="_blank"><strong class="ne iu">https://raw.githubusercontent.com/plotly/datasets/master/geojson-counties-fips.json</strong>'</a>) as response:<br/>    <strong class="ne iu">counties </strong>= json.load(response)</span><span id="f58e" class="mr lv it ne b gy nn nj l nk nl">store_by_county = df.groupby('county_fips')['long'].count().reset_index()<br/>store_by_county.rename(columns = {'long':'Number of Locations'}, inplace = True)</span><span id="1b3b" class="mr lv it ne b gy nn nj l nk nl">fig = px.choropleth(<br/>    locations=store_by_county['county_fips'], <br/>    color = store_by_county['Number of Locations'].astype(float), <br/>    <strong class="ne iu">geojson=counties, <br/>    scope="usa"</strong>, <br/>    color_continuous_scale = 'ylorrd', <br/>    labels={'color':'Number of Locations'},<br/>    title = 'Number of Simulated Locations by County'<br/>    )<br/>fig.write_html('Choropleth Map by county.html')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/c5f4a9614088faf309167d337c5434d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gMj_K0bLYy6ye-mxq2RNDw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="c6b1" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">基于列创建气泡图</h2><p id="c482" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">接下来，我们将使用“<strong class="la iu"> scatter_geo </strong>”函数创建气泡图。该功能类似于<strong class="la iu"> choropleth </strong>功能。我们需要用数字列指定“<strong class="la iu">大小</strong>参数，而不是“<strong class="la iu">颜色</strong>参数”。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="0a7e" class="mr lv it ne b gy ni nj l nk nl"># by state<br/>fig = px.<strong class="ne iu">scatter_geo</strong>(<br/>    store_by_st, <br/>    locations="state", <br/>    hover_name="state", <br/>    size="Number of Locations",<br/>    size_max = 30,<br/>    locationmode="USA-states", <br/>    scope="usa", <br/>    title = 'Number of Locations by State'<br/>    )<br/>fig.write_html('Bubble Map by state.html')</span><span id="187e" class="mr lv it ne b gy nn nj l nk nl">##################<br/># by county <br/>fig = px.<strong class="ne iu">scatter_geo</strong>(<br/>    store_by_county, <br/>    locations="county_fips", <br/>    hover_name="county_fips", <br/>    size="Number of Locations",<br/>    size_max = 30,<br/>    geojson=counties,<br/>    scope="usa", <br/>    title = 'Number of Locations by County'<br/>    )<br/>fig.write_html('Bubble Map by county.html')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/2702770cc123e51f0312f8f5627ab732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r_JBspsUVRTIzZjyzO_x8A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="5a57" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">创建一个有多个图层的地图</h2><p id="b7f5" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我们可以在 Plotly 中创建多层地图。例如，在一张地图中，我们希望同时包含散点图和 choropleth 图。为此，我们需要同时使用“<strong class="la iu"> plotly.graph_objects </strong>和“<strong class="la iu"> plot.express </strong>”。</p><p id="292a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将使用“px.choropleth”创建地图的第一层，然后使用“<strong class="la iu"> add_trace </strong>”函数和“<strong class="la iu"> go”添加第二层。散射地理</strong>”。“去吧。Scattergeo”相当于“px.scatter_mapbox”。最后，我们可以使用“<a class="ae nm" href="https://plotly.com/python-api-reference/generated/plotly.graph_objects.Layout.html" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu"> update_layout </strong> </a>”功能修改整个地图的布局，如标题、字体、字号、图例等。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="b494" class="mr lv it ne b gy ni nj l nk nl">import <strong class="ne iu">plotly.graph_objects</strong> as go</span><span id="6183" class="mr lv it ne b gy nn nj l nk nl"># by state<br/>fig = px.choropleth(<br/>    locations=store_by_st['state'], <br/>    color = store_by_st['Number of Locations'].astype(float), <br/>    locationmode="USA-states", <br/>    scope="usa", <br/>    color_continuous_scale = 'Blues', <br/>    labels={'color':'Number of Stores'},<br/>    )                  <br/>fig.add_trace(<br/>   go.Scattergeo(<br/>        lon =df['long'],<br/>        lat =df['lat'],<br/>        mode="markers",<br/>        marker_color = 'maroon',<br/>        marker_size = 4<br/>    )<br/>)<br/>fig.update_layout(<br/>    title_text ='Simulated Locations by State', <br/>    title_x =0.5,<br/>    title_font_size=30)<br/>                                 <br/>fig.write_html('Choropleth_with_locations by state.html')</span><span id="43e5" class="mr lv it ne b gy nn nj l nk nl">##################<br/># by county <br/>fig = px.choropleth(<br/>    locations=store_by_county['county_fips'], <br/>    color = store_by_county['Number of Locations'].astype(float), <br/>    geojson=counties,<br/>    scope="usa", <br/>    color_continuous_scale = 'Blues', <br/>    labels={'color':'Number of Stores'},<br/>    )</span><span id="db16" class="mr lv it ne b gy nn nj l nk nl">fig.add_trace(<br/>   go.Scattergeo(<br/>        lon =df['long'],<br/>        lat =df['lat'],<br/>        mode="markers",<br/>        marker_color = 'maroon',<br/>        marker_size = 4<br/>    )<br/>)<br/>fig.update_layout(<br/>    title_text ='Simulated Locations by County', <br/>    title_x =0.5,<br/>    title_font_size=30)<br/>                                 <br/>fig.write_html('Choropleth_with_locations by county.html')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/9a5564ff2a2f269baab5e89db04edc02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WlnRLaLvSS2L-ZCyET-EhQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="a0da" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">三。高级地图图形</h1><p id="e16d" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">在本节中，我们将讨论在 Plotly 中创建高级地图图形。通过组合不同的功能，我们可以创建丰富的交互式地图。</p><h2 id="d567" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">使用下拉菜单将多个地图合并到一个页面中</h2><p id="7412" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">有时，我们会创建多个地图，但希望在一个页面中包含所有地图。创建一个<strong class="la iu">下拉菜单</strong>是一个包含所有信息同时保持格式整洁有序的完美解决方案。</p><p id="d65b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下面的示例中，我们希望创建一个县级的 choropleth 地图，并设计一个下拉菜单来选择一个指定的州以显示 choropleth 地图。</p><p id="1a48" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在程序中，我们需要两个组件，即“<strong class="la iu">轨迹</strong>和“<strong class="la iu">按钮</strong>”。“痕迹”是一个包括所有地图图层的列表。每一层都包括特定州的 choropleth 地图。“按钮”是下拉菜单中包含元素的列表。为了使下拉菜单工作，我们需要在我们创建的“按钮”列表的“布局”中指定“<strong class="la iu">update menus”</strong>参数。当用户在下拉菜单中选择一个值时，可以通过“更新菜单<strong class="la iu">”</strong>参数自动更新“<strong class="la iu">可见</strong>”和“<strong class="la iu">标题</strong>”参数。</p><p id="622c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不要忘记在布局参数中包含我们上面提到的“<strong class="la iu">access token = map box _ access _ token</strong>”。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="7ae7" class="mr lv it ne b gy ni nj l nk nl">import numpy as np<br/>store_by_county2 = df.groupby(['state', 'county_fips'])['long'].count().reset_index()<br/>store_by_county2.rename(columns = {'long':'Number of Locations'}, inplace = True)</span><span id="0238" class="mr lv it ne b gy nn nj l nk nl"># create drop-down menu<br/>menu = store_by_county2['state'].unique().tolist()<br/>visible = np.array(menu)</span><span id="c328" class="mr lv it ne b gy nn nj l nk nl"><strong class="ne iu">traces </strong>= []<br/><strong class="ne iu">buttons </strong>= []<br/>for value in menu:<br/>    subset = store_by_county2[store_by_county2['state']==value]      <br/>    traces.append(<br/>        go.<strong class="ne iu">Choroplethmapbox</strong>(<br/>            locations=subset['county_fips'], <br/>            z = subset['Number of Locations'].astype(float), <br/>            <strong class="ne iu">geojson = counties</strong>, <br/>            colorscale = 'Blues',<br/>            colorbar_title = "Number of Stores",<br/>            <strong class="ne iu">visible</strong>= True if value==menu[0] else False<br/>            ))<br/>    buttons.append(<br/>        dict(label=value,<br/>            method="<strong class="ne iu">update</strong>",<br/>            args=[{"<strong class="ne iu">visible</strong>":list(visible==value)},<br/>                  {"<strong class="ne iu">title</strong>":f'Simulated Locations in &lt;b&gt;{value}&lt;/b&gt;'}]))</span><span id="d2e3" class="mr lv it ne b gy nn nj l nk nl"># create figure<br/>fig = go.Figure(<br/>    data=<strong class="ne iu">traces</strong>,<br/>    layout=dict(<br/>        <strong class="ne iu">updatemenus</strong>=[{"active":0, "buttons":<strong class="ne iu">buttons</strong>,}]<br/>        ))</span><span id="1752" class="mr lv it ne b gy nn nj l nk nl">first_title = menu[0]<br/>fig.update_layout(<br/>    title= f'Simulated Locations in &lt;b&gt;{first_title}&lt;/b&gt;',<br/>    autosize=True,<br/>    hovermode='closest',<br/>    showlegend=False,<br/>    mapbox=dict(<br/>    <strong class="ne iu">accesstoken=mapbox_access_token</strong>,<br/>        bearing=0,<br/>        center=dict(<br/>            lat=38,<br/>            lon=-94<br/>            ),<br/>        pitch=0,<br/>        zoom=4,<br/>        style='light'<br/>        ))</span><span id="db9e" class="mr lv it ne b gy nn nj l nk nl">fig.write_html('Maps with drop-down.html')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/e1e81af5bd83850cce8e8ec777fad12a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m0khqqedUEaDvW1BhDg_CQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="e0de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者，我们可以使用<strong class="la iu">破折号</strong>来创建一个使用<a class="ae nm" href="https://dash.plotly.com/basic-callbacks" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">回调函数</strong> </a>的下拉菜单。</p><h2 id="42b5" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">以给定的半径围绕点画一个圆</h2><p id="aa84" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我们可以使用“分散地理”功能在地图上创建气泡，但是，当我们放大或缩小地图时，气泡的大小将保持不变。要在地图上画一个给定半径的圆，我们需要一个不同的解决方案。</p><p id="bbb1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下面的例子中，我们希望包括加州大学洛杉矶分校 30 英里半径范围内的沃尔玛商店。</p><p id="4da6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了在地图中包含这个 30 英里的缓冲区，我们需要从头开始创建它。首先，我们需要中心点的纬度和经度，例如，加州大学洛杉矶分校。然后我们创建一个名为"<strong class="la iu"> geodesic_point_buffer </strong>的函数，使用"<strong class="la iu"> pyproj </strong>"和"<strong class="la iu"> shapely </strong>"库返回这个 30 英里缓冲区边界的纬度和经度列表。当缓冲区的边界上有足够多的点时，我们可以通过用直线连接这些点来创建一个看起来非常接近圆形的几何对象。</p><p id="4b5c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们只需要将刚刚在“地图框”参数中创建的 30 英里缓冲区包含在“图层=图层”中。为了使地图看起来更好，我们希望在打开地图时基于中心点将地图居中。为此，我们可以设置“<strong class="la iu"> center=dict( lat=lat，lon=lon) </strong>”，其中 lat 和 lon 是中心点的经度纬度。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="9eb2" class="mr lv it ne b gy ni nj l nk nl">from functools import partial<br/>import pyproj<br/>from shapely.ops import transform<br/>from shapely.geometry import Point</span><span id="b753" class="mr lv it ne b gy nn nj l nk nl"># define a function to create buffer around a point<br/>proj_wgs84 = pyproj.Proj('+proj=longlat +datum=WGS84')<br/>def <strong class="ne iu">geodesic_point_buffer</strong>(lat, lon, miles):<br/>    # Azimuthal equidistant projection<br/>    aeqd_proj = '+proj=aeqd +lat_0={lat} +lon_0={lon} +x_0=0 +y_0=0'<br/>    project = partial(<br/>        pyproj.transform,<br/>        pyproj.Proj(aeqd_proj.format(lat=lat, lon=lon)), <br/>        proj_wgs84)<br/>    buf = Point(0, 0).buffer(miles * 1000/0.621371)  # distance in miles<br/>    return transform(project, buf).exterior.coords[:]</span><span id="06d3" class="mr lv it ne b gy nn nj l nk nl"># Example<br/>target = geolocator.geocode('University of California, Los Angeles')<br/><strong class="ne iu">lat, lon = target.latitude, target.longitude</strong></span><span id="aedd" class="mr lv it ne b gy nn nj l nk nl"># create buffer layer <br/><strong class="ne iu">features </strong>= [{ "type": "Feature", "geometry": {"type": "LineString","coordinates": geodesic_point_buffer(lat, lon, 30)}}]<br/><strong class="ne iu">layers </strong>= [dict(<br/>        sourcetype = 'geojson',<br/>        source={"type": "FeatureCollection", 'features': <strong class="ne iu">features</strong>},           <br/>        color= 'maroon',<br/>        type = 'fill',   <br/>        opacity=0.2,<br/>        line=dict(width=1.5),<br/>        below = "state-label-sm"<br/>        )]</span><span id="0534" class="mr lv it ne b gy nn nj l nk nl"># Create the map <br/>fig = go.Figure()</span><span id="dcf5" class="mr lv it ne b gy nn nj l nk nl">fig.add_trace(go.Scattermapbox(<br/>        lat=df['lat'],<br/>        lon=df['long'],<br/>        mode='markers',<br/>        marker=go.scattermapbox.Marker(<br/>            size=5,<br/>            color='blue'<br/>        )<br/>    ))</span><span id="a205" class="mr lv it ne b gy nn nj l nk nl">fig.update_layout(<br/>    title='Simulated Locations &lt;br&gt;Within 30 Miles of UCLA',<br/>    autosize=True,<br/>    hovermode='closest',<br/>    showlegend=False,<br/>    mapbox=dict(<br/>        accesstoken=mapbox_access_token,<br/>        <strong class="ne iu">layers=layers</strong>,<br/>        bearing=0,<br/>        center=dict(<br/>            lat=lat,<br/>            lon=lon<br/>        ),<br/>        pitch=0,<br/>        zoom=6.5,<br/>        style='light'<br/>    ),<br/>)</span><span id="b6a4" class="mr lv it ne b gy nn nj l nk nl">fig.write_html('Locations Map with 30 Miles Radius.html')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/19e2ad99687d25476030d7f8f7291634.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vekzXfR6ee0uFF8_a9f4cA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="7e17" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过修改程序中的<strong class="la iu">特征</strong>和<strong class="la iu">图层</strong>列表变量，我们可以<strong class="la iu">围绕多个点</strong>创建圆或<strong class="la iu">不同颜色的圆</strong>。</p><h2 id="06fc" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">创建动画地图</h2><p id="b295" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">接下来，我们将创建一个动画地图。例如，我们想创建一个会随时间变化的<strong class="la iu">动态</strong> choropleth 图。</p><p id="dda8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">几个 Plotly Express 函数，如散点图、条形图、choropleth，通过<strong class="la iu"> animation_frame </strong>和<strong class="la iu"> animation_group </strong>参数支持动画人物的创建。</p><p id="9249" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下面的示例中，我们将创建一个动态 choropleth 地图，该地图按州显示一年中模拟位置的数量</p><p id="613f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们将聚合数据框，使用 pandas 中的“groupby”和“count”函数按州计算年度位置计数。然后“px.choropleth”被用于动画地图，带有附加参数，“animation _ frame = df[“year”]”和“animation _ group = df[“state”]”。</p><ul class=""><li id="ef5c" class="nt nu it la b lb lc le lf lh nv ll nw lp nx lt ny nz oa ob bi translated"><strong class="la iu"> animation_frame </strong>:该参数指定了一个用于创建动画帧的列。在这个例子中，我们将每年创建一个帧</li><li id="42c9" class="nt nu it la b lb oc le od lh oe ll of lp og lt ny nz oa ob bi translated"><strong class="la iu"> animation_group </strong>:该参数指定列中的相同值将被视为每帧中的相同对象。在这个例子中，我们将把每个帧中具有相同状态的行视为相同的对象。</li><li id="ce6b" class="nt nu it la b lb oc le od lh oe ll of lp og lt ny nz oa ob bi translated"><strong class="la iu"> range_color </strong>:该参数指定了 choropleth 贴图中的颜色范围。以保持所有框架的配色方案一致。我们需要用最大数值指定 range_color 参数。</li></ul><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="ecb3" class="mr lv it ne b gy ni nj l nk nl">df =df.sort_values(['state', 'year'])<br/>df = df.groupby(['state', 'year'])['long'].count().reset_index()<br/>df = df.rename(columns = {'long': 'count'})<br/>df = df.sort_values(['year'])<br/>color_max = df['count'].max()</span><span id="fb7f" class="mr lv it ne b gy nn nj l nk nl">fig = px.choropleth(<br/>    locations=df['state'], <br/>    color = df['count'].astype(float), <br/>    locationmode="USA-states", <br/>    scope="usa", <br/>    color_continuous_scale = 'ylorrd', <br/>    labels={'color':'Number of Locations'},<br/>    title = 'Number of Simulated Locations by State',<br/>    <strong class="ne iu">animation_frame</strong>=df["year"],<br/>    <strong class="ne iu">animation_group</strong>=df["state"],<br/>    range_color = [0, color_max]<br/>    )<br/>fig.update_layout(<br/>    title_x =0.5,<br/>    title_font_size=30)</span><span id="4af0" class="mr lv it ne b gy nn nj l nk nl">fig.write_html('choropleth with sliders by state.html')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/6dae1b7d11b832422f384d4505949809.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WnDB06TVbslYiv2k3Ah5iA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="99c3" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">感谢您的阅读！！！</h1><p id="1999" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">如果你喜欢这篇文章，并且想<strong class="la iu">请我喝杯咖啡，请<a class="ae nm" href="https://ko-fi.com/aaronzhu" rel="noopener ugc nofollow" target="_blank">点击这里</a>。</strong></p><p id="40ed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以注册一个<a class="ae nm" href="https://aaron-zhu.medium.com/membership" rel="noopener"> <strong class="la iu">会员</strong> </a>来解锁我的文章的全部访问权限，并且可以无限制地访问介质上的所有内容。如果你想在我发表新文章时收到电子邮件通知，请<a class="ae nm" href="https://aaron-zhu.medium.com/subscribe" rel="noopener"> <strong class="la iu">订阅</strong> </a>。</p></div></div>    
</body>
</html>