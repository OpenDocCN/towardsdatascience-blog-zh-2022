<html>
<head>
<title>Building a Dashboard in Plotly Dash</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Plotly Dash中构建仪表板</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-dashboard-in-plotly-dash-c748588e2920#2022-08-31">https://towardsdatascience.com/building-a-dashboard-in-plotly-dash-c748588e2920#2022-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b3f6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在生理网上浏览数千份心电图记录</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6291ff3bb9d9d5b07e9114a8f7fd3f31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5n0dFNwJUvfoA3hr0VZhEw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Shutterstock: ID1855544260</p></figure><p id="742b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这篇文章中，我将分享在<a class="ae lr" href="https://dash.plotly.com/" rel="noopener ugc nofollow" target="_blank"> Plotly Dash </a>中构建交互式仪表盘(app)的过程，以探索海量的在线数据集。我们将使用来自Physionet [1，2]上的<a class="ae lr" href="https://physionet.org/content/icentia11k-continuous-ecg/1.0/" rel="noopener ugc nofollow" target="_blank"> Icentia11k </a>数据库的心电图(ECG)记录，经许可使用。这篇文章的目的是帮助初学者建立他们的第一个仪表板，同时激励更有经验的读者为像Physionet这样的大规模在线数据集建立仪表板。</p><p id="c3a9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将建立的应用程序目前托管在<a class="ae lr" href="https://ecg-dashboard.thomasbury.net/" rel="noopener ugc nofollow" target="_blank">这里</a>。这个应用的源代码可以在这个<a class="ae lr" href="https://github.com/ThomasMBury/ecg-dashboard" rel="noopener ugc nofollow" target="_blank"> Github仓库</a>中找到，还有本文中显示的应用的后续版本的代码。</p><p id="a173" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">本帖组织如下:</strong></p><ol class=""><li id="2ede" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">动机:心电图是大数据</li><li id="d396" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">第一步:加载和打印数据的函数</li><li id="dc11" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">Dash样板代码:运行我们的第一个应用程序</li><li id="7c20" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">添加组件:图形</li><li id="db42" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">添加组件:下拉菜单</li><li id="7895" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">仪表板布局</li><li id="66b3" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">回调函数:让应用程序组件相互交流</li><li id="194f" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">向全世界展示我们的应用程序！</li></ol><h1 id="0514" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">动机:心电图是大数据</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/ce0f2e5050018eb23b38d905cd2c386a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2WQNHGAsY8Y3oPV1"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">亚历山大·辛恩在<a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="6589" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">心电图(ECG)是监测心脏健康的一种方便、无创的方法。随着可穿戴设备的出现，心电图可以一次持续几天，从而可以收集前所未有的大量数据。</p><p id="21e1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">具体有多少数据？典型的ECG记录频率约为250Hz(即每秒250次测量)。如果患者连续7天佩戴监护仪，监护仪将产生7*24*60*60*250=151，200，000个数据点！</p><p id="bde3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Physionet有一个<a class="ae lr" href="https://physionet.org/content/icentia11k-continuous-ecg/1.0/" rel="noopener ugc nofollow" target="_blank">公共数据库</a>，其中有来自11，000名患者的多日心电图记录，由<a class="ae lr" href="https://www.icentia.com/" rel="noopener ugc nofollow" target="_blank"> Icentia </a>公司提供。现在我们大约有10个数据点。我认为公平地说，这使我们进入了“大数据”的领域。</p><p id="c414" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">直接绘制如此大量的数据是不切实际的。一个小时内绘制的心电图，更不用说一整周了，显示的是一整面墙的墨迹:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/739f1c69963e4fe3e6dd6f6c8fbee87e.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*4rK4ruyuGzgjMhQeCt2dGw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae lr" href="https://www.physionet.org/content/icentia11k-continuous-ecg/1.0/" rel="noopener ugc nofollow" target="_blank"> Icentia11k生理网数据库</a>中0号患者的第一小时心电图。单个图的心电图太多了！</p></figure><p id="6942" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是交互式可视化派上用场的地方。它们允许我们无缝地缩放和平移记录的不同部分。通过这种方式，我们可以在记录中的任何地方查看ECG行为，但以秒为单位的时间比以小时为单位的时间更合适。将它集成到仪表板中，我们可以添加其他功能，如下拉框，以便在不同的患者之间进行选择。此外，我们可以添加其他面板来查看除ECG之外的患者特征。如果这听起来很有趣，请继续阅读，因为我们在<a class="ae lr" href="https://physionet.org/content/icentia11k-continuous-ecg/1.0/" rel="noopener ugc nofollow" target="_blank"> Physionet </a>数据库中构建了一个(最小)仪表板来探索患者的心脏动力学。</p><h1 id="2e43" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">第一步——编写加载和可视化数据的基本函数</h1><p id="0e2d" class="pw-post-body-paragraph kv kw iq kx b ky na jr la lb nb ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">在我们创建仪表板之前，我们应该写下函数来加载和显示我们希望在仪表板上看到的数据。如果你想跟随代码，在一个新的目录中建立一个虚拟环境(例如使用<em class="nf"> venv </em>)并安装Python包<em class="nf"> numpy、pandas、plotly、dash </em>和<em class="nf"> wfdb </em>。这可以通过以下方式实现</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="ec84" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在创建一个名为<code class="fe ni nj nk nl b">app.py</code>的Python脚本，并导入包，如下所示</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="f533" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Physionet数据库包含两种形式的ECG数据:1)原始信号和2)心跳注释。我们将在仪表板上显示这两种情况。</p><p id="08a0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">加载原始ECG信号。</strong>该数据库包含11000名<em class="nf">患者</em>，每个患者有大约50个<em class="nf">心电图段</em>。利用Python包<a class="ae lr" href="https://pypi.org/project/wfdb/" rel="noopener ugc nofollow" target="_blank"> wfdb </a>，我们可以编写一个函数来加载特定患者、时间段和时间间隔的ECG数据:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="dce5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，让我们在2分钟和3分钟之间加载患者18的心电图，分段0:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/c51a7e174062984142be2324c1afe59e.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/format:webp/1*J9CMPjqqdlcGhaMUJzVctw.png"/></div></figure><p id="ec66" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将使用一行程序从Physionet中检索ECG数据！我们现在需要一个函数来创建这些数据的交互式可视化:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="d2eb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">用<code class="fe ni nj nk nl b">fig = make_ecg_plot(df_ecg)</code>执行这个函数现在产生一个对象，它将成为我们仪表板的<strong class="kx ir"> <em class="nf">组件</em> </strong>。要查看该图，您可以使用<code class="fe ni nj nk nl b">fig.write_html('my_fig.html')</code>保存并在网络浏览器中打开。您应该会看到类似这样的内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/557ffba3e378e6cb882532afb27ad43b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*mtmr19XTtFml8O3PyXZM2Q.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">患者18从第2分钟到第3分钟的交互式心电图图形可视化。</p></figure><p id="e77e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如我们所见，当我们想要查看较长时间间隔的心电图时，心电图会变得非常密集。只关注节拍注释会更方便:</p><p id="e099" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">加载节拍注释。</strong>这些数据包含记录中每次心跳的发生时间和类型。我们将把重点限制在正常的窦性搏动(标为“N”)和室性早搏(标为“V”)。和以前一样，我们编写一个函数来加载这些数据:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="ca4d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们像以前一样加载相同的心电图。这次接收出现在特定样本号的节拍类型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/17d6ed4b20a1ed06ab534113ae0f502b.png" data-original-src="https://miro.medium.com/v2/resize:fit:398/format:webp/1*SkAenT7HHnRG7MWHf8wU-g.png"/></div></figure><p id="4845" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将通过绘制连续心跳之间经过的时间来可视化这些数据:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="850c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在运行<code class="fe ni nj nk nl b">make_beat_interval_plot(df_beats)</code>返回下图，对应于之前显示的原始ECG图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/7713777edb09888acc674950cf3bfa26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IK4KLgmwMLxFllnOjyvJuA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">患者18从第2分钟到第3分钟的心搏间隔图。</p></figure><p id="0a32" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，该图包含的数据要少得多。因此，我们将使用这种类型的图来扫描长时间内的心电图，并使用之前显示的原始心电图图来研究较短时间内发生的心脏动力学。</p><p id="a84c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们有了提取和绘制数据的函数，是时候开始实际构建应用程序了！</p><h1 id="c1dd" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">破折号样板代码</h1><p id="0e0f" class="pw-post-body-paragraph kv kw iq kx b ky na jr la lb nb ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">我们将使用以下样板代码作为起点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="18a3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">属性允许我们使用预定义的CSS配置。我们将使用Chris Parmer提供的<a class="ae lr" href="https://codepen.io/chriddyp/pen/bWLwgP.css" rel="noopener ugc nofollow" target="_blank"> Dash Styleguide </a>。</p><p id="2c6f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您将这个Python脚本保存为<code class="fe ni nj nk nl b">app.py</code>，并使用<code class="fe ni nj nk nl b">python app.py</code>运行它，您应该会看到以下消息</p><pre class="kg kh ki kj gt nq nl nr ns aw nt bi"><span id="c006" class="nu mh iq nl b gy nv nw l nx ny">Dash is running on http://127.0.0.1:8050/</span></pre><p id="db0a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，在您的网络浏览器中访问<a class="ae lr" href="http://127.0.0.1:8050/" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8050</a>/，您应该会看到文本“我的仪表板”。如果是这样，您已经有了一个可以运行的仪表板！现在是时候开始构建它了。</p><h1 id="2a6c" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">添加组件:图形</h1><p id="f024" class="pw-post-body-paragraph kv kw iq kx b ky na jr la lb nb ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">我们将从把我们早先做的数字相加开始。现在，我们将为一个默认的患者和段号制作数字(最终我们将能够用<em class="nf">回调函数和</em>来改变它，我们将在后面定义)。当用户首次启动应用程序时，将显示该默认患者。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="df2f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在已经制作了图形对象，但是为了在Dash应用程序上显示图形，我们必须将它放在<code class="fe ni nj nk nl b">app.layout</code>的内容分割器(Div)中。我们列出组件的顺序就是它们在应用程序中出现的顺序。我们还为每个图形分配了一个<code class="fe ni nj nk nl b">id</code>，这在我们使用<em class="nf">回调函数</em>时会变得很重要。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="6da4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">到目前为止，将代码放在一起(<code class="fe ni nj nk nl b"><a class="ae lr" href="https://github.com/ThomasMBury/ecg-dashboard/blob/main/medium/app_v1.py" rel="noopener ugc nofollow" target="_blank">app_v1.py</a></code>)并运行它，应该会产生一个如下所示的应用程序:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/301da02fb37376688ee99127d5c104f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y9TnIEDyGZDOQJQsDzphIA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">应用程序版本1:显示交互式图形。</p></figure><h1 id="b6a2" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">添加组件:下拉菜单</h1><p id="118e" class="pw-post-body-paragraph kv kw iq kx b ky na jr la lb nb ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">Dash中的<a class="ae lr" href="https://dash.plotly.com/dash-core-components/dropdown" rel="noopener ugc nofollow" target="_blank">下拉菜单</a>有很多选项。需要指定的关键是<code class="fe ni nj nk nl b">id</code>、默认的<code class="fe ni nj nk nl b">value</code>，当然还有<code class="fe ni nj nk nl b">options</code>。</p><p id="dd67" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下代码将创建一个下拉框，选项范围从0到10999，可用于选择数据库中的患者编号。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="b601" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，我们将默认值设为患者0，这与我们之前的默认值一致。</p><p id="fd3d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就像图一样，下拉菜单被认为是应用程序的<em class="nf">组件</em>，必须放在<code class="fe ni nj nk nl b">Div</code>中。我们将使用额外的<code class="fe ni nj nk nl b">html</code>组件为下拉菜单添加一个标题。完整的Div如下所示</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="0834" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以创建一个类似的Div，其中包含一个ECG段号的下拉菜单。在我们的<code class="fe ni nj nk nl b">app.layout</code>中列出这些div，给出了应用程序的更新版本(<code class="fe ni nj nk nl b"><a class="ae lr" href="https://github.com/ThomasMBury/ecg-dashboard/blob/main/medium/app_v2.py" rel="noopener ugc nofollow" target="_blank">app_v2.py</a></code>)，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/8cc182a2e8db02316d9494309ca61581.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*od2sTdA2kbWwSPoM_QBJKw.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">应用程序版本2:包含下拉菜单(仍然没有连接到应用程序的其余部分)</p></figure><h1 id="0e73" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">仪表板布局</h1><p id="f900" class="pw-post-body-paragraph kv kw iq kx b ky na jr la lb nb ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">我们app目前的布局并不理想。下拉菜单不必要的宽，而且放置不当。幸运的是，我们可以使用<code class="fe ni nj nk nl b">style</code>属性修改每个Div的布局属性。它接受任意数量的CSS属性/值对，其中有<a class="ae lr" href="https://www.dofactory.com/css/properties" rel="noopener ugc nofollow" target="_blank">多个</a>。</p><p id="492f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于这个应用程序，我们将调整div的高度、宽度和填充，以重新组织布局。它们可以被指定为绝对值，或基于用户屏幕尺寸的百分比。</p><p id="6659" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们将标题和两个下拉菜单放在应用程序顶部的同一层。我们将标题Div的宽度设置为200px，这足以容纳文本，下拉菜单的宽度设置为用户屏幕宽度的20%。我们将设置60px的固定高度。选项<code class="fe ni nj nk nl b">'display’:’inline-block’</code>将分隔线置于直线上。</p><p id="afcd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的<code class="fe ni nj nk nl b">app.layout</code>现在看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="32b5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对代码(<code class="fe ni nj nk nl b"><a class="ae lr" href="https://github.com/ThomasMBury/ecg-dashboard/blob/main/medium/app_v3.py" rel="noopener ugc nofollow" target="_blank">app_v3.py</a></code>)进行这样的调整会产生一个类似于下面这样的应用程序:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/5565b2a2dcbd77e2fc5dd83cdce96671.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BdsL3MQWiBl7zfSmrjj_qA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">应用程序版本3:下拉菜单和标题的新布局</p></figure><p id="bc31" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们已经对布局进行了排序，让我们开始连接应用程序的不同组件。目前下拉菜单与应用程序的其余部分是断开的。是时候介绍一下<em class="nf">回调函数了。</em></p><h1 id="0337" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">回调函数:让应用程序组件相互交流</h1><p id="c036" class="pw-post-body-paragraph kv kw iq kx b ky na jr la lb nb ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">回调函数是仪表板最强大的功能之一。它们允许用户在与仪表板交互时获得仪表板的实时更新。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/ec27ecffe1c6a85090b307efadf2085d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JNdvv1wex-mlvNj_"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae lr" href="https://unsplash.com/@quinoal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Quino Al </a>在<a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="2fdb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">编写回调函数时，需要仔细考虑函数的<code class="fe ni nj nk nl b">Input</code>和<code class="fe ni nj nk nl b">Output</code>应该是什么。例如，我们的下拉菜单中的一个值的变化应该反映在我们的图中。这里，<code class="fe ni nj nk nl b">Input</code>是下拉菜单中的新值，<code class="fe ni nj nk nl b">Output</code>是绘图。</p><p id="82a8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">回调函数列在<code class="fe ni nj nk nl b">app.layout</code>之后。它们的基本结构如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="5cc2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ni nj nk nl b">@app.callback</code>内部的部分被称为函数<em class="nf">装饰器</em>。它使用相关的<code class="fe ni nj nk nl b">id</code>和<code class="fe ni nj nk nl b">property</code>将函数的输入和输出链接到应用程序的组件。</p><p id="30ce" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ni nj nk nl b">output_id</code>和<code class="fe ni nj nk nl b">input_id</code>是我们已经为应用程序的每个组件设置的id。例如，患者下拉菜单的ID是<code class="fe ni nj nk nl b">'dropdown_patient_id'</code>。</p><p id="d1bf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ni nj nk nl b">input_property</code>和<code class="fe ni nj nk nl b">output_property</code>是我们希望捕获的那个组件的属性。常见的例子包括用于选择下拉菜单值的<code class="fe ni nj nk nl b">'value'</code>和用于选择绘图图形对象的<code class="fe ni nj nk nl b">'figure'</code>。我们还将看到<code class="fe ni nj nk nl b">'relayoutData'</code>专门捕捉绘图图形的当前布局。</p><p id="30c2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">关于回调函数的更多细节，请查看Dash教程。</p><p id="0ddd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于我们的应用程序，我们将编写两个回调函数。第一个将连接下拉菜单节拍间隔绘图。第二个将把心搏间期图的<em class="nf">布局</em>连接到ECG图。</p><h2 id="263f" class="nu mh iq bd mi od oe dn mm of og dp mq le oh oi ms li oj ok mu lm ol om mw on bi translated">I)下拉菜单中变化的回调函数</h2><p id="f8eb" class="pw-post-body-paragraph kv kw iq kx b ky na jr la lb nb ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">当用户改变我们的下拉菜单中的一个值时，我们希望节拍间隔图相应地更新。这将包括从Physionet加载适当的数据，然后创建绘图。这就是回调函数要做的事情。</p><p id="095c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个回调函数的输入和输出是什么？我们的输入是来自ID为<code class="fe ni nj nk nl b">'dropdown_record_id'</code>或ID为<code class="fe ni nj nk nl b">'dropdown_segment_id'</code>的下拉菜单的<code class="fe ni nj nk nl b">'value'</code>。输出将是ID为<code class="fe ni nj nk nl b">'fig_intervals'</code>的人物的<code class="fe ni nj nk nl b">'figure'</code>属性。</p><p id="c0aa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，回调装饰器(函数前的位)是</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="c97c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在来写函数——这基本上是实现我们已经写好的函数。给定一个患者ID，我们希望从生理网加载适当的数据，然后绘制搏动间隔图:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="ede2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在运行应用程序(<code class="fe ni nj nk nl b"><a class="ae lr" href="https://github.com/ThomasMBury/ecg-dashboard/blob/main/medium/app_v4.py" rel="noopener ugc nofollow" target="_blank">app_v4.py</a></code>)，我们看到更新下拉菜单产生了预期的效果——我们现在可以查看数据库中11，000名患者中任何一名患者的搏动间隔图！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/e12390e72dc46a3b5eae804f02a629dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*N2E0PCUsUs7f-nC2dNMdYg.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">应用程序版本4:下拉菜单现在连接到节拍间隔图</p></figure><h2 id="30ef" class="nu mh iq bd mi od oe dn mm of og dp mq le oh oi ms li oj ok mu lm ol om mw on bi translated">ii)绘图布局变化的回调函数</h2><p id="0ee8" class="pw-post-body-paragraph kv kw iq kx b ky na jr la lb nb ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">最后，我们将把心电图图放入图片中。我们希望当用户在“心跳间隔”图中选择足够小的时间窗口时，显示该图。因此我们将编写一个回调函数来检测节拍间隔图的<strong class="kx ir"> <em class="nf">布局数据</em> </strong>的变化。</p><p id="291a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该布局数据从绘图图形的属性<code class="fe ni nj nk nl b">'relayoutData'</code>获得。该回调函数还需要下拉菜单中的当前值，以便加载适当的ECG数据。因此，这个函数的装饰器是</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="46e2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当此功能被触发时，我们希望它加载并绘制所提供的ECG数据:</p><ol class=""><li id="dc3e" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">触发是由于<code class="fe ni nj nk nl b">fig_intervals</code>的x轴边界发生变化。</li><li id="0346" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">新的界限导致时间窗口长度小于1分钟</li></ol><p id="f08c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果触发是由于其他点击(如改变下拉菜单或其他布局选项)，我们可以使用<code class="fe ni nj nk nl b">exceptions.PreventUpdate()</code>来“取消”回调函数。这包含在下面的函数中(有一些细微差别，我就不细说了):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="209c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用这个新的回调函数(<code class="fe ni nj nk nl b"><a class="ae lr" href="https://github.com/ThomasMBury/ecg-dashboard/blob/main/medium/app_v5.py" rel="noopener ugc nofollow" target="_blank">app_v5.py</a></code>)运行应用程序，我们现在能够查看短于1分钟的时间窗的ECG图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/ed5fce3a3833e489b56cce8f9cd7dae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-bsOAoIcCea2g6vL8BwQsA.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">应用程序版本ECG图现已连接到搏动间隔图的布局</p></figure><p id="5ff8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过这一回调功能，应用程序仅在实际观察有用时加载高分辨率ECG数据(短时间内)，从而节省处理时间。</p><h1 id="af37" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">托管我们的应用</h1><p id="3699" class="pw-post-body-paragraph kv kw iq kx b ky na jr la lb nb ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">我们可以在本地运行我们的应用程序供个人使用，没有问题。然而，就其现状而言，与合作者共享并不容易，除非他们愿意建立自己的虚拟环境并通过Python运行。这些Dash应用程序的美妙之处在于，我们可以在<em class="nf">托管</em>它们，让任何有互联网连接的人都可以使用它们！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/56f40640b32f1f3a1d9888668bcacffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ICdjX1fpJJHSUkHB"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae lr" href="https://unsplash.com/@nasa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> NASA </a>在<a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="6313" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将与Heroku合作托管我们的应用，Heroku是一个提供免费托管非商业应用的云平台。在这里，我将带你通过这些步骤，让这个应用程序托管遵循Dash提供的这些<a class="ae lr" href="https://dash.plotly.com/deployment" rel="noopener ugc nofollow" target="_blank">指令</a>。</p><p id="b40e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> <em class="nf">更新2023年1月2日:</em> </strong> <em class="nf"> Heroku不再有自由层，所以我用</em> <a class="ae lr" href="https://railway.app/" rel="noopener ugc nofollow" target="_blank"> <em class="nf">铁路</em> </a> <em class="nf">代替。您可以遵循下面的步骤3–8，然后将存储库推送到Github。从那里，我有一篇</em> <a class="ae lr" href="https://medium.com/@thomasbury/migrating-your-dash-app-from-heroku-to-a-free-platform-afcda6693bc2" rel="noopener"> <em class="nf">文章</em> </a> <em class="nf">关于如何建立铁路。</em></p><ol class=""><li id="033c" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated"><a class="ae lr" href="https://signup.heroku.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">注册</strong> </a> <strong class="kx ir">成为Heroku </strong>的帐户</li></ol><p id="0c41" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2.<strong class="kx ir">安装</strong><a class="ae lr" href="https://devcenter.heroku.com/articles/heroku-cli" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir">Heroku CLI</strong></a>。这允许我们从命令行与Heroku交互。</p><p id="fc38" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">3.<strong class="kx ir">为你的<code class="fe ni nj nk nl b">app.py</code>文件创建一个干净的目录</strong>，并用</p><pre class="kg kh ki kj gt nq nl nr ns aw nt bi"><span id="4b6a" class="nu mh iq nl b gy nv nw l nx ny">git init</span></pre><p id="02eb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">4.<strong class="kx ir">创建一个虚拟环境并激活它。</strong>我们将使用<a class="ae lr" href="https://docs.python.org/3/library/venv.html" rel="noopener ugc nofollow" target="_blank"> <em class="nf"> venv </em> </a>模块创建一个名为<em class="nf"> venv的虚拟环境。</em></p><pre class="kg kh ki kj gt nq nl nr ns aw nt bi"><span id="d8ce" class="nu mh iq nl b gy nv nw l nx ny">python -m venv venv<br/>source venv/bin/activate</span></pre><p id="245e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">5.<strong class="kx ir">安装应用依赖项。</strong>最好先用以下代码更新pip</p><pre class="kg kh ki kj gt nq nl nr ns aw nt bi"><span id="9ece" class="nu mh iq nl b gy nv nw l nx ny">pip install --upgrade pip</span></pre><p id="85f1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如我们所见，我们的应用程序需要以下Python包:</p><pre class="kg kh ki kj gt nq nl nr ns aw nt bi"><span id="6fa1" class="nu mh iq nl b gy nv nw l nx ny">pip install numpy<br/>pip install pandas<br/>pip install plotly<br/>pip install dash<br/>pip install wfdb</span></pre><p id="c231" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还需要<a class="ae lr" href="https://gunicorn.org/" rel="noopener ugc nofollow" target="_blank"> gunicorn </a>包，它使所有这些Python进程能够在Heroku服务器上运行。</p><pre class="kg kh ki kj gt nq nl nr ns aw nt bi"><span id="a089" class="nu mh iq nl b gy nv nw l nx ny">pip install gunicorn</span></pre><p id="a9f2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">6.<strong class="kx ir">创建requirements.txt文件。我们刚刚安装的Python包和它们的依赖项需要在一个<code class="fe ni nj nk nl b">requirements.txt</code>文件中列出。这可以通过以下命令实现</strong></p><pre class="kg kh ki kj gt nq nl nr ns aw nt bi"><span id="6e03" class="nu mh iq nl b gy nv nw l nx ny">pip freeze &gt; requirements.txt</span></pre><p id="6c3f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">7.<strong class="kx ir">创建一个. gitignore文件。这表明我们不希望git跟踪哪些文件。我们可以创建并打开文件</strong></p><pre class="kg kh ki kj gt nq nl nr ns aw nt bi"><span id="4bba" class="nu mh iq nl b gy nv nw l nx ny">touch .gitignore<br/>open .gitignore</span></pre><p id="a804" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，为我们将不跟踪的文件输入以下行:</p><pre class="kg kh ki kj gt nq nl nr ns aw nt bi"><span id="ba71" class="nu mh iq nl b gy nv nw l nx ny">venv <br/>*.pyc <br/>.DS_Store <br/>.env</span></pre><p id="ef7a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">8.创建一个过程文件。这是部署所必需的。创建文件并使用打开它</p><pre class="kg kh ki kj gt nq nl nr ns aw nt bi"><span id="7f38" class="nu mh iq nl b gy nv nw l nx ny">touch Procfile<br/>open Procfile</span></pre><p id="7ab4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">并输入以下文本</p><pre class="kg kh ki kj gt nq nl nr ns aw nt bi"><span id="6ee0" class="nu mh iq nl b gy nv nw l nx ny">web: gunicorn app:server</span></pre><p id="8d2c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您现在应该有一个包含<code class="fe ni nj nk nl b">app.py</code>、<code class="fe ni nj nk nl b">requirements.txt</code>、<code class="fe ni nj nk nl b">.gitignore</code>、<code class="fe ni nj nk nl b">Procfile</code>和<code class="fe ni nj nk nl b">venv</code>的目录。如果是这样，你已经准备好发送这个应用程序到Heroku！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/b51bf49aef9650d46d3a7d8fc951071c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_lLoZoPrjprA6P3T"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">安妮·斯普拉特在<a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="fc1d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">9.<strong class="kx ir">创建Heroku app。</strong>使用Heroku CLI创建一个新应用程序，命令如下</p><pre class="kg kh ki kj gt nq nl nr ns aw nt bi"><span id="498e" class="nu mh iq nl b gy nv nw l nx ny">heroku create ecg-dashboard-medium</span></pre><p id="6aaf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其中<code class="fe ni nj nk nl b">ecg-dashboard-medium</code>是您的应用程序的名称。如果你打开你的Heroku <a class="ae lr" href="https://dashboard.heroku.com/apps" rel="noopener ugc nofollow" target="_blank">应用</a>，你应该会看到你的应用被列出来了。</p><p id="0067" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">10.提交更改并将git存储库推送到Heroku。这是通过以下方式实现的</p><pre class="kg kh ki kj gt nq nl nr ns aw nt bi"><span id="9d2e" class="nu mh iq nl b gy nv nw l nx ny">git add .<br/>git commit -m "Our first deployment to Heroku"<br/>git push heroku main</span></pre><p id="5f1a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在终端输出的末尾，您应该会看到</p><pre class="kg kh ki kj gt nq nl nr ns aw nt bi"><span id="9c92" class="nu mh iq nl b gy nv nw l nx ny">https://ecg-dashboard-medium.herokuapp.com/ deployed to Heroku</span></pre><p id="cc2c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是您的应用程序的URL！如果你访问它，你应该看到你的应用程序启动和运行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/239a8f0a351229e30baaa0d8ff1a6885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oKvxwg945-SqSkG-"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae lr" href="https://unsplash.com/@asoggetti?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿莱西奥·索格蒂</a>在<a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="5190" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">结论</h1><p id="67ac" class="pw-post-body-paragraph kv kw iq kx b ky na jr la lb nb ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">恭喜你坚持到了最后！在这篇文章中，我们从头到尾看到了如何在Plotly Dash中构建和部署一个仪表板。这包括编写函数来加载和绘制我们的数据，将我们的图形作为应用程序的组件，设置布局，编写回调函数，最后，将我们的应用程序部署到公共服务器。我鼓励你现在就去构建你自己的应用——祝你好运！</p><h1 id="9f69" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">承认</h1><p id="d739" class="pw-post-body-paragraph kv kw iq kx b ky na jr la lb nb ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">感谢Icentia允许本出版物使用Icentia11k数据集。除非另有说明，所有图片均为作者所有。</p><p id="0438" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[1]谭，s .，奥尔蒂斯-加涅，s .，博登-加尼翁，n .，费克图，p .，库维尔，a .，本吉奥，y .，&amp;科恩，J. P. (2022)。Icentia11k单导联连续原始心电图数据集(1.0版)。<em class="nf">生理网</em>。</p><p id="bbe7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[2] Goldberger，a .，Amaral，l .，Glass，l .，Hausdorff，j .，Ivanov，P. C .，Mark，r .，…，和Stanley，H. E. (2000年)。生理银行、生理工具包和生理网:复杂生理信号新研究资源的组成部分。循环[在线]。101 (23)，第e215–e220页。</p></div></div>    
</body>
</html>