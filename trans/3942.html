<html>
<head>
<title>Interview Question: Select a Random Line from a File (in Rust)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面试问题:从文件中随机选择一行</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/interview-question-select-a-random-line-from-a-file-in-rust-c0a8cddcddfb#2022-09-01">https://towardsdatascience.com/interview-question-select-a-random-line-from-a-file-in-rust-c0a8cddcddfb#2022-09-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="680d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个很酷很有用的算法解释和扩展</h2></div><p id="254f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">卡尔·m·卡迪和克里斯托弗·米克</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/373cb85514c29a713bfa855e00d96692.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8O1rD59qJ2z7s03ks4aYuQ.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">一只螃蟹从文件中随机选择一行文本——来源:【https://openai.com/dall-e-2/ T2】</p></figure><p id="f258" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我(卡尔)面试你在微软的工作，我可能会问你这个问题:</p><blockquote class="ls"><p id="5c57" class="lt lu iq bd lv lw lx ly lz ma mb la dk translated">如何从未知长度的文本文件中随机选择一行？</p></blockquote><p id="29f9" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">我在微软研究院，在最初的反垃圾邮件团队，在一个办公室机器学习/数据科学小组，都问过这个问题。我们喜欢这个问题，因为它涉及概率、算法和系统问题。</p><p id="b794" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使已经从微软退休，我们仍然会思考随机线问题。例如，我们最近学习了<code class="fe mh mi mj mk b"><a class="ae lr" href="https://lib.rs/crates/bytecount" rel="noopener ugc nofollow" target="_blank">bytecount</a></code>。这是一个Rust crate，它使用SIMD CPU指令来加速计算文件中的行数。正如我们稍后将描述的，我们对板条箱的了解间接导致了对随机线问题的最先进的解决方案的改进。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="b877" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将这篇文章组织成一系列的问题和提示。如果你愿意，在看到我们的回答之前，你可以试着自己回答问题。</p><blockquote class="ms mt mu"><p id="497e" class="kf kg mv kh b ki kj jr kk kl km ju kn mw kp kq kr mx kt ku kv my kx ky kz la ij bi translated">在本文中，我们将在Rust中给出答案。关于Python中的答案，参见本文的<a class="ae lr" rel="noopener" target="_blank" href="/interview-question-select-a-random-line-from-a-file-in-python-4756eac40075"> Python版。你可能也喜欢阅读这两个版本，作为比较两种语言的一种方式。</a></p></blockquote><p id="c97c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于白板面试，我们给了受访者以下建议:</p><ul class=""><li id="374c" class="mz na iq kh b ki kj kl km ko nb ks nc kw nd la ne nf ng nh bi translated">请随意提出澄清性问题。(在本文的上下文中，您可以进一步阅读，看看我们是否提供了澄清。)</li><li id="1b8c" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">首先从正确的算法开始，即使它可能不是最佳的。如果我们想要一个更好的算法，我们会用后续问题来提示您。</li><li id="3f22" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">不要担心精确的语法。例如，我们不关心你是否记得产生随机数的确切方法。</li><li id="20eb" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">如果你卡住了，我们可以提供一些提示。(还是那句话，在这篇文章的上下文中，读远一点寻找提示。)</li></ul><p id="363a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从问题开始:</p><h2 id="937e" class="nn no iq bd np nq nr dn ns nt nu dp nv ko nw nx ny ks nz oa ob kw oc od oe of bi translated">问:如何从未知长度的文本文件中随机选择一行？</h2><p id="67b0" class="pw-post-body-paragraph kf kg iq kh b ki og jr kk kl oh ju kn ko oi kq kr ks oj ku kv kw ok ky kz la ij bi translated"><strong class="kh ir">答:</strong>我们首先要明确一个“随机线”的含义。我们的意思是文本文件中的每一行都有相等的机会被返回。换句话说，我们希望算法通过均匀分布在这些线中进行选择。</p><p id="ff97" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个要求意味着你<strong class="kh ir">不能</strong>使用这个算法，我们称之为<code class="fe mh mi mj mk b">AlgoRandomSeek</code>:</p><ul class=""><li id="a239" class="mz na iq kh b ki kj kl km ko nb ks nc kw nd la ne nf ng nh bi translated">向文件系统询问文件的长度。</li><li id="770f" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">随机选择一个文件位置并查找到该位置。</li><li id="3bfb" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">在位置附近返回一条线。</li></ul><p id="159a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">Sub Q:</strong><code class="fe mh mi mj mk b">AlgoRandomSeek</code>怎么了？</p><p id="cdde" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> Sub A </strong>:虽然该算法可以返回文件中的任何行，但它返回较长行的概率比返回较短行的概率高，因此不会通过均匀分布选择行。</p><blockquote class="ms mt mu"><p id="dd00" class="kf kg mv kh b ki kj jr kk kl km ju kn mw kp kq kr mx kt ku kv my kx ky kz la ij bi translated">旁白:我们喜欢被要求澄清。它将“随机”的日常含义与统计学、数据科学、决策理论和机器学习中使用的技术含义区分开来。</p></blockquote><p id="5693" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">提示:</strong>如果你在Rust中编码，需要快速(但正确地)解决随机线问题，你会怎么做？</p><p id="1589" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们向GitHub Copilot寻求Python的解决方案。把它的答案翻译成Rust给了我们这个代码。称之为<code class="fe mh mi mj mk b">AlgoReadAll</code>:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ol om l"/></div></figure><blockquote class="ms mt mu"><p id="c26b" class="kf kg mv kh b ki kj jr kk kl km ju kn mw kp kq kr mx kt ku kv my kx ky kz la ij bi translated">旁白:完整的Rust项目，包括Cargo.toml和<code class="fe mh mi mj mk b">use</code>语句，见GitHub 上的项目<a class="ae lr" href="https://github.com/CarlKCarlK/random-line" rel="noopener ugc nofollow" target="_blank"> random-line。所有的例子都使用</a><a class="ae lr" href="https://crates.io/crates/fetch-data" rel="noopener ugc nofollow" target="_blank">获取数据箱</a>根据需要获取样本文件。</p></blockquote><p id="9e44" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个算法显然是正确且快速的。另外，如果遇到坏文件，它会使用<code class="fe mh mi mj mk b">?</code>返回一个错误结果。另一个好处是，您可以提到代码在空文件上返回<code class="fe mh mi mj mk b">None</code>。</p><p id="ff84" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不利的一面是，这段代码将整个文件读入内存，因此不能处理大文件。</p><p id="a37d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们询问一个适用于大型文件的解决方案:</p><h2 id="2d02" class="nn no iq bd np nq nr dn ns nt nu dp nv ko nw nx ny ks nz oa ob kw oc od oe of bi translated">问:使用很少的内存，如何从未知长度的文本文件中随机选择一行？</h2><p id="c5a5" class="pw-post-body-paragraph kf kg iq kh b ki og jr kk kl oh ju kn ko oi kq kr ks oj ku kv kw ok ky kz la ij bi translated"><strong class="kh ir">答:</strong>我们首先要澄清“小内存”。对于这个问题，假设您可以存储文件中的任何一行，或者几行，但不是所有的行。</p><p id="fd68" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mh mi mj mk b">AlgoTwoPass</code>用1解决问题。计算文件中的行数，2。随机选择一个行索引，3 .返回带有该索引的行。(在本文中，“索引0”是一个从0开始计数的索引。如果一个索引从1开始计数，我们称之为“index1”。)</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="b279" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的机器上，这将输出:</p><p id="ab4b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mh mi mj mk b">1,683 of 146,933: Some(“to gather material for illustrations of the poems of Robert”)</code></p><p id="a156" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mh mi mj mk b">AlgoTwoPass</code>正确。我们还会给这段代码一个奖励:</p><ul class=""><li id="370b" class="mz na iq kh b ki kj kl km ko nb ks nc kw nd la ne nf ng nh bi translated">使用带有显式种子的随机数生成器—机器学习和数据科学通常需要再现性，即使是来自随机性。</li><li id="1c11" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">提到它在应用于空文件时返回<code class="fe mh mi mj mk b">None </code>。</li><li id="235f" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">使用<code class="fe mh mi mj mk b">let item = item_result?</code>检查可能的文件错误。</li><li id="3e46" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">[非常小]用千位分隔符格式化数字。</li></ul><p id="805e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不是必需的，但有趣的是这个更具功能性的实现:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="f1ad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">旁白1: <strong class="kh ir">背景信息</strong>:这段代码使用Rust迭代器。当<code class="fe mh mi mj mk b"><em class="mv">next()</em></code>被应用到Rust迭代器时，序列中的下一个值被返回到<code class="fe mh mi mj mk b">Some</code>中，或者，如果序列是完整的，则返回<code class="fe mh mi mj mk b">None</code>。表达式<code class="fe mh mi mj mk b">BufReader::new(File::open(&amp;path)?).lines()</code>返回“行结果”上的迭代器。每一行结果要么是一个字符串(下一行)，要么是一个错误(在试图读取该行时发现)。虽然Rust在迭代器上定义了一个<code class="fe mh mi mj mk b">count()</code>方法，但是我们不应该在这里使用它。为什么？因为<code class="fe mh mi mj mk b">count()</code>方法不检查错误值。同样，Rust定义了一个<code class="fe mh mi mj mk b">nth()</code>方法，该方法增加了一个迭代器<em class="mv"> n </em> +1个值。它返回(<em class="mv"> n </em> +1)ᵗʰ值，但忽略任何中间误差值。为了检查来自<code class="fe mh mi mj mk b">.line()</code>的错误值，上面的回答定义并使用了<code class="fe mh mi mj mk b">try_count</code>和<code class="fe mh mi mj mk b">try_nth</code>函数。【感谢Reddit Rust社区在这个问题上的<a class="ae lr" href="https://www.reddit.com/r/rust/comments/wyk1l0/can_you_compose_stdiolines_with_stditercount/" rel="noopener ugc nofollow" target="_blank">帮助</a>。]</p><p id="e190" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">旁白2:我们不会因为某人在<code class="fe mh mi mj mk b"><em class="mv">rng.gen_range</em></code>或<code class="fe mh mi mj mk b"><em class="mv">nth/try_nth</em></code>上犯了一个失误而惩罚他。然而，我们可能会问，如何测试代码来检查这样的错误。</p><p id="833a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们要求一个更快的算法:</p><h2 id="1abf" class="nn no iq bd np nq nr dn ns nt nu dp nv ko nw nx ny ks nz oa ob kw oc od oe of bi translated">问:在一遍中，你能从一个未知长度的文本文件中随机选择一行吗？</h2><p id="9178" class="pw-post-body-paragraph kf kg iq kh b ki og jr kk kl oh ju kn ko oi kq kr ks oj ku kv kw ok ky kz la ij bi translated"><strong class="kh ir">答:</strong>根据提示，我们将通过一系列子问题来开发一个算法。</p><p id="a6e5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">提示:</strong>递归地想想这个。</p><p id="048d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> Sub Q: </strong>把自己放在程序的位置上。如果我们向您保证文件只包含一行，您应该怎么做？</p><p id="c2bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果文件只包含一行，就输出它。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="3184" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">子问:</strong>呜呜，我们骗了你。该文件可能只包含一行或两行，但没有其他数量的行。你该怎么办？</p><p id="a213" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> Sub A: </strong>用概率0.5，替换我们要输出的结果，用第二行。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="be5c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">子Q: </strong>对不起，我们又说谎了！该文件可能只包含一行、两行或三行。你该怎么办？每条线的入选概率是多少？这怎么能一概而论呢？</p><p id="7545" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用概率⅓，用第三行替换我们要输出的结果。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="46a2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每行的选择概率为:</p><ul class=""><li id="0de7" class="mz na iq kh b ki kj kl km ko nb ks nc kw nd la ne nf ng nh bi translated">第一行:1 × × ⅔= ⅓</li><li id="6f08" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">第二行:× ⅔= ⅓</li><li id="8bc6" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">三线:⅓= ⅓</li></ul><p id="07ef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，概率分布是均匀的。我们可以将此归纳为<code class="fe mh mi mj mk b">AlgoOnePass</code>:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="8767" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">说句题外话:</strong>我(Carl)回忆起一位受访者开始通过归纳法证明这个算法的正确性。我可以告诉他们很容易做到这一点，所以我阻止了他们，继续前进。他们获得了奖金。</p><p id="b8e3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">奖金Q: </strong>我们在面试中从来没有问过这个，但是你能递归地写<code class="fe mh mi mj mk b">AlgoOnePass</code>吗？</p><p id="d177" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">奖金A: </strong>这里是<code class="fe mh mi mj mk b">AlgoOnePassRecurse</code>:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="1a27" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果递归超过几千次，Rust就会崩溃。这段代码使用机箱<a class="ae lr" href="https://crates.io/crates/tailcall" rel="noopener ugc nofollow" target="_blank">尾调用</a>来避免崩溃。该算法的递归和非递归版本以大约相同的速度运行。该代码因跨结果迭代器通用而获得了额外的好处。另一个好处是，它接受随机数生成器<code class="fe mh mi mj mk b">rng</code>作为<code class="fe mh mi mj mk b">&amp;mut</code>，这允许继续使用<code class="fe mh mi mj mk b">rng</code>。</p><blockquote class="ms mt mu"><p id="b1ea" class="kf kg mv kh b ki kj jr kk kl km ju kn mw kp kq kr mx kt ku kv my kx ky kz la ij bi translated">旁白:实际思考一下，一次通过比两次通过重要吗？往往不会。如果你能为一条随机的线等1秒，你大概能等1到2秒。另一方面，有些数据——“流数据”——是不能二次访问的，所以<code class="fe mh mi mj mk b"><em class="iq">AlgoOnePass</em></code>有实用价值。</p></blockquote><p id="f5fa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对<code class="fe mh mi mj mk b"><em class="mv">AlgoOnePass</em></code>的一个简单概括是选择多条随机线，而不仅仅是一条线，我们不会讨论这个。维基百科在其关于<a class="ae lr" href="https://en.wikipedia.org/wiki/Reservoir_sampling#Simple:_Algorithm_R" rel="noopener ugc nofollow" target="_blank">储层采样:简单算法R </a>的文章中描述了(或多或少)<code class="fe mh mi mj mk b"><em class="mv">AlgoOnePass</em></code>和这种概括。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="3c2e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在采访中，这通常是我们说到“从文件中随机抽取一行”的地方。然而，我们最近了解了锈箱<code class="fe mh mi mj mk b"><a class="ae lr" href="https://lib.rs/crates/bytecount" rel="noopener ugc nofollow" target="_blank">bytecount</a></code>。这个<code class="fe mh mi mj mk b"><a class="ae lr" href="https://lib.rs/crates/bytecount" rel="noopener ugc nofollow" target="_blank">bytecount</a></code>机箱使用SIMD CPU指令来加速文件中的行数。这让我们再次玩起了这个问题。这导致了一种新的方法和一种改进的算法。新算法不使用<code class="fe mh mi mj mk b"><a class="ae lr" href="https://lib.rs/crates/bytecount" rel="noopener ugc nofollow" target="_blank">bytecount</a></code>。然而，在返回一个随机行的特定情况下，它确实优于维基百科中描述的更一般的<a class="ae lr" href="https://en.wikipedia.org/wiki/Reservoir_sampling#Optimal:_Algorithm_L" rel="noopener ugc nofollow" target="_blank"> Optimal: Algorithm L </a>。</p><blockquote class="ms mt mu"><p id="38cc" class="kf kg mv kh b ki kj jr kk kl km ju kn mw kp kq kr mx kt ku kv my kx ky kz la ij bi translated">旁白:我们称之为“新算法”，但它可能早就被发现了。无论如何，我们希望你会对这个算法和它的发展感兴趣。</p></blockquote><p id="2ce2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和以前一样，我们将通过一系列问题和提示来展示新算法。然而，我们从未向受访者提出过这些问题。</p><h2 id="2676" class="nn no iq bd np nq nr dn ns nt nu dp nv ko nw nx ny ks nz oa ob kw oc od oe of bi translated">问:在一次传递中，你能从一个未知长度的文本文件中选择一个随机行，使得随机数发生器的调用比行数n少得多吗？</h2><p id="1e3e" class="pw-post-body-paragraph kf kg iq kh b ki og jr kk kl oh ju kn ko oi kq kr ks oj ku kv kw ok ky kz la ij bi translated"><strong class="kh ir">答:</strong>我们必须澄清“少很多”。我们的意思是对随机数生成器的调用次数小于O( <em class="mv"> n </em>)【参见<a class="ae lr" href="https://en.wikipedia.org/wiki/Big_O_notation" rel="noopener ugc nofollow" target="_blank">大O标注—维基百科</a>】。换句话说，将通话次数减少一次或一半是不够的。所需调用的随机数应该与log( <em class="mv"> n </em>)或sqrt( <em class="mv"> n </em>)成比例增长。</p><p id="e6d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">提示:</strong>首先修改<code class="fe mh mi mj mk b">AlgoOnePass</code>打印分配给<code class="fe mh mi mj mk b">result</code>的每一项的索引。称之为“保持指数”。比如说，对100万个项目运行代码。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="fa96" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">产出:</p><pre class="lc ld le lf gt on mk oo op aw oq bi"><span id="1236" class="nn no iq mk b gy or os l ot ou">1 2 4 14 38 112 210 914 4,512 5,659 6,242 13,388 917,008</span></pre><p id="5d98" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这表示当我们以随机种子0运行时，第一项被保留为可能的最终随机项。然后是第二项，然后是第四项。然后，直到第14个项目，然后是第38个项目，才保留任何项目。如果迭代器包含917，008到1，000，000个条目，那么第917，008个条目将是最后一个被保留的条目，也是最后一个随机条目。</p><p id="c534" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">keep指数似乎大致呈指数增长。如果该猜想为真，则保留索引的数量为O(log <em class="mv"> n </em>)，其中<em class="mv"> n </em>是迭代器中项的数量。</p><p id="7960" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">子问题:我们可以直接随机生成keep索引序列吗？</strong></p><p id="35af" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> Sub A: </strong>是的！我们在一篇简短的在线技术论文中详细介绍了我们的解决方案[Meek &amp; Kadie，<a class="ae lr" href="https://cm1x.github.io/static/Attenuated_Geometric_Distribution.pdf" rel="noopener ugc nofollow" target="_blank">Streaming Random Selection Using the Attenuated Geometric Distribution</a>，2022]。我们称keep指数的分布为“衰减几何分布”。我们证明，如果<code class="fe mh mi mj mk b">index1</code>是一个keep索引号，那么我们可以用以下公式生成下一个索引号:</p><p id="7d4c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mh mi mj mk b">let r: f64 = rng.gen();<br/>index1 += ((r * (index1 as f64) / (1.0 — r)).ceil() as usize).max(1);</code></p><p id="0d08" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<code class="fe mh mi mj mk b">rng.gen()</code>生成0 .0(含)和1.0(不含)之间的统一浮点值。额外收获:<code class="fe mh mi mj mk b">(…).max(1)</code>处理随机生成0.0这种非常非常不可能的情况。此外，回想一下我们的约定，即“index1”是从1而不是从0开始计数的索引。</p><p id="d005" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在可以利用这种洞察力来创造<code class="fe mh mi mj mk b">AlgoOnePassSkip</code>:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="09ad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过使用代码在0(包括)和100(不包括)之间挑选一个数字，100，000次，来获得一些信心。(我们使用表达式<code class="fe mh mi mj mk b">(0..100).map(Ok::&lt;_, std::io::Error&gt;)</code>来创建结果值的迭代器，<code class="fe mh mi mj mk b">Ok(0)</code>，<code class="fe mh mi mj mk b">Ok(1)</code>，… <code class="fe mh mi mj mk b">Ok(99)</code>。代码需要结果值。)</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="e1b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们用Python绘图，这些图应该看起来是一致的，事实也确实如此:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ol om l"/></div></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ov"><img src="../Images/49301a8cc0d29bb730a4e4bd5ac99f58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gPSdWvWPJ-J3o9yQaGNHDg.png"/></div></div></figure><p id="156b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该算法与<a class="ae lr" href="https://en.wikipedia.org/wiki/Reservoir_sampling#Optimal:_Algorithm_L" rel="noopener ugc nofollow" target="_blank"> Optimal: Algorithm L </a>(维基百科推荐)在两个重要方面有所不同。</p><ul class=""><li id="e50b" class="mz na iq kh b ki kj kl km ko nb ks nc kw nd la ne nf ng nh bi translated"><code class="fe mh mi mj mk b">AlgoOnePassSkip</code>只能选择一个随机项，而算法L可以选择任意指定数量的随机项。</li><li id="c9f4" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">当只需要一个随机项时，<code class="fe mh mi mj mk b">AlgoOnePassSkip</code>每个keep索引需要一个随机数，而算法L需要两个。</li></ul><p id="2f58" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，对于我们只想要一个随机物品的特殊情况，<code class="fe mh mi mj mk b">AlgoOnePassSkip</code>使用算法l一半数量的随机抽取。</p><h1 id="9835" class="ow no iq bd np ox oy oz ns pa pb pc nv jw pd jx ny jz pe ka ob kc pf kd oe pg bi translated">摘要</h1><p id="f33d" class="pw-post-body-paragraph kf kg iq kh b ki og jr kk kl oh ju kn ko oi kq kr ks oj ku kv kw ok ky kz la ij bi translated">我们已经看到了从未知长度的序列中随机选择一个项目的四种方法。在文本文件的上下文中，第一种解决方案要求文件适合内存。下一个解决方案使用较少的内存，但需要两次通过文件。然后，我们使用概率计算将此减少到一遍。这种一次通过的解决方案需要每行一个随机数。最后一个解决方案需要的随机数比直线少得多。它使用的随机数也是“最优”(更一般)算法的一半。</p><p id="1644" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Rust <a class="ae lr" href="https://docs.rs/rand/" rel="noopener ugc nofollow" target="_blank"> rand crate </a>用<code class="fe mh mi mj mk b"><a class="ae lr" href="https://docs.rs/rand/latest/rand/seq/trait.IteratorRandom.html#method.choose" rel="noopener ugc nofollow" target="_blank">seq::IteratorRandom::choose</a></code>和相关方法实现相关算法和概括。与<code class="fe mh mi mj mk b">count</code>和<code class="fe mh mi mj mk b">nth</code>一样，它不会检查每个迭代结果中的错误。人们可以想象，在未来，一个<code class="fe mh mi mj mk b">try_choose</code>。此外，它使用更通用的算法L，而不是新的，在某些情况下稍微更有效的<code class="fe mh mi mj mk b">AlgoOnePassSkip</code>。</p><p id="1f8c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的代码都没有使用像<code class="fe mh mi mj mk b"><a class="ae lr" href="https://lib.rs/crates/bytecount" rel="noopener ugc nofollow" target="_blank">bytecount</a></code>这样的系统级方法来加速文件的线性传递。添加系统级优化将是一个有趣的扩展。</p><p id="d4d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mv">请</em> <a class="ae lr" href="https://medium.com/@carlmkadie" rel="noopener"> <em class="mv">跟随卡尔上媒</em> </a> <em class="mv">。我写的是Rust和Python的科学编程、机器学习和统计学。我倾向于每月写一篇文章。</em></p></div></div>    
</body>
</html>