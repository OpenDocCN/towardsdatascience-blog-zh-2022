<html>
<head>
<title>The Likelihood-Ratio Test</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">似然比检验</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-likelihood-ratio-test-463455b34de9#2022-07-19">https://towardsdatascience.com/the-likelihood-ratio-test-463455b34de9#2022-07-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a726" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过R中的一个实例直观地解释了似然比检验</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c1260be125408edb54e345a20101c843.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5sRAXOT1lto6nCmX"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">克里斯·布里格斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6038" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">本文使用的所有图片均由作者创作，除非另有说明</em></p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="3b38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">似然比检验(LRT)是一种统计检验，用于根据两个模型的似然比来比较它们的拟合优度。本文将使用LRT来比较两个旨在预测一系列硬币翻转的模型，以便直观地理解LRT是什么以及它为什么有效。我将首先回顾一下<em class="ls">可能性</em>和<em class="ls"> </em>的概念，我们如何找到一个参数的值，在这种情况下，翻转头部的概率，这使得观察我们的数据最有可能。然后，我将展示添加独立参数如何扩展我们的参数空间，以及在某些情况下，一个简单的模型如何构成一个更复杂模型的子空间。最后，我将讨论如何使用维尔克定理来评估一个更复杂的模型是否比一个更简单的模型更适合数据。</p><p id="2447" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我嵌入了用于生成本文中所有图形的R代码。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h2 id="e4c9" class="ma mb iq bd mc md me dn mf mg mh dp mi lf mj mk ml lj mm mn mo ln mp mq mr ms bi translated">抛硬币</h2><p id="8983" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">让我们从随机抛25美分硬币开始，抛正面的概率θ未知:</p><p id="8dde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">p(人头)= θ</p><p id="f200" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们把硬币翻转十次:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi na"><img src="../Images/e09c8d4683c8f4eb42c80a9c8eb1c78d.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*PBmIwgaDrCTdKYsnNRpeOA.png"/></div></figure><p id="79fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们翻转它十次，得到7个正面(表示为1)和3个反面(表示为0)。</p><p id="88a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们想知道什么参数θ使我们的数据，上面的序列，最有可能。为了找到θ的值，即翻转头部的概率，我们可以计算在给定特定θ值的情况下观察到该数据<em class="ls">的<em class="ls">可能性</em>。从数学上讲，我们将观察到数据d的可能性表示为:L(d|θ)。我们想找到使L(d|θ)最大化的θ的to值。</em></p><p id="8497" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">凭直觉，你可能会猜测，因为我们有7个头和3条尾巴，所以我们对θ的最佳猜测是7/10=.7</p><p id="1195" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们写一个函数，通过计算我们在参数空间θ中看到一些可能值的特定头尾序列的可能性，来检验这种直觉。由于每一次硬币投掷都是独立的，观察到特定硬币投掷序列的概率是观察到每一次单独硬币投掷的概率的乘积。在下面的函数中，我们从可能性1开始，每次遇到正面，我们就用可能性乘以正面的概率。每当我们遇到一条尾巴，我们就乘以1减去翻转头的概率。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="f42b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们已经有了一个函数来计算观察到一系列抛硬币的可能性，给定一个θ，即正面的概率，让我们来绘制几个不同θ值的可能性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/8ea380a0e29284deb5218fe78f85f8eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e7LO230iKBWeryBZ4QpZyg.png"/></div></div></figure><p id="3c4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在此图中，我们可以看到，当θ等于0.7时，观察数据的可能性最大。我们已经证实了我们的直觉，当θ= 0.7时，我们最有可能看到数据序列</p><p id="7c8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们做同样的实验，掷一枚新硬币，例如一便士，同样是正面着地的概率未知。我们可以将我们对25美分硬币和1美分硬币的翻转组合起来，形成一个20次翻转的单一序列。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/42e92549aab5a0e69bb5ad851473e242.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GjHRxmdgpPHIFN6XhUjKGw.png"/></div></div></figure><p id="79a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们不知道硬币是不同的，我们按照我们的程序，我们可能会更新我们的猜测，并说，因为我们有20个头像中的9个，当我们让头像的概率为. 45时，我们的最大可能性就会发生。我们用下图来证实我们的直觉。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/f785d6bfeb3abcd67b0a49f44a16466c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hlZhRs4m5E28DxLWPtgV_g.png"/></div></div></figure><p id="1b04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的场景中，我们用一个θ模拟了两个硬币的翻转。也许我们可以通过增加一个额外的参数来改进我们的模型。如果我们知道有两个硬币，并且知道我们什么时候去翻转它们，会怎么样？然后，我们可以尝试使用两个参数来模拟这一系列的翻转，每个硬币一个参数。添加一个参数也意味着向我们的参数空间添加一个维度。让我们想象一下新的参数空间:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/de9cf72280426f68f7823f97d0f1de0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4TrJ4UhjwSKosGD94Kvy5g.png"/></div></div></figure><p id="f498" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上图显示了在给定两个参数的不同值的情况下，观察我们的数据的可能性。观察使用一个参数相当于说quarter_θ和penny_θ的值相同。在上图中，quarter_θ和penny_θ沿对角线相等，因此我们可以说单参数模型构成了双参数模型的<em class="ls">子空间</em>。在这种情况下，子空间沿着对角线出现。如果我们将上面的图沿对角线切片，我们将重新创建原始的二维图。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/2f87b364d70763afd7a33ae9d50934f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yzwEnHCvy0a2fbghIxVhUw.png"/></div></div></figure><p id="726a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的图形与我们假设硬币和便士有相同的正面着地概率时生成的图形相同。我们可以把自己想象成比较两个模型，其中基础模型(掷一枚硬币)是一个更复杂的完整模型(掷两枚硬币)的子空间。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/50f64be2d87b630c3a4b1723f3651801.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KDV6cusDzJM50gu_2PXZKQ.jpeg"/></div></div></figure><p id="41e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了直观地显示当我们添加一个参数时，我们观察到数据的可能性有多大，让我们在上图中绘制两参数模型的最大可能性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/f06bcc01bc83680dfcb05d73481c26b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jxoXokgd85JLsQaNZRGQeA.png"/></div></div></figure><p id="6862" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，添加第二个参数使得观察我们的20次抛硬币序列更有可能。</p><h1 id="876f" class="ng mb iq bd mc nh ni nj mf nk nl nm mi jw nn jx ml jz no ka mo kc np kd mr nq bi translated">从似然到似然比检验</h1><p id="d4a8" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">我们可以在上面的图表中看到，在双参数模型中观察到数据的可能性比在单参数模型中高得多。然而，如果我们掷的每一枚硬币都有相同的正面概率呢？那么添加第二个参数可能没有好处。那么，我们如何量化地确定添加一个参数是否会使我们的模型更好地拟合数据呢？自然的第一步是获取<strong class="ky ir">似然比</strong>:它被定义为简单模型的最大似然比复杂模型ML_simple/ML_complex的最大似然<strong class="ky ir">T3的比值</strong></p><p id="86f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们也为我们的例子定义一个零假设和另一个假设:</p><p id="cebe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">零假设:</strong>硬币正面概率=硬币正面概率</p><p id="139d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">备选假设:</strong>正面四分之一的概率！概率头便士</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="15cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">双参数模型的ML与单参数模型的ML的似然比是:LR = 14.15558</p><p id="0bca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基于这个数字，我们可能会认为复杂模型更好，我们应该拒绝我们的零假设。但是我们还在用眼球直觉。为了进一步量化这一点，我们需要借助<strong class="ky ir">维尔克定理</strong>，该定理指出，当零假设为真时，随着样本大小(本例中为翻转次数)接近无穷大，2log(LR)呈卡方分布。(在这里阅读维尔克定理<a class="ae kv" href="https://en.wikipedia.org/wiki/Wilks%27_theorem" rel="noopener ugc nofollow" target="_blank">的局限性)。根据维尔克定理，我们将<strong class="ky ir">似然比检验统计量</strong>定义为:λ_ LR = 2[log(ML _ null)log(ML _ alternative)]</a></p><p id="d535" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么似然比检验统计量是卡方分布？首先回忆一下卡方分布是k个独立的标准正态随机变量的平方和。下面是不同自由度(k值)的卡方分布图。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/c2ff0ceabe62459e087f23b70f048759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xYXfOrvLa6pGeHpneofmGA.png"/></div></div></figure><p id="1dde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们如何转换我们的似然比，使其遵循卡方分布？首先，请注意，在上面的柱状图中，我们的每个参数图都是近似正态分布的，因此我们有正态随机变量。我们可以通过取对数把比率变成总和。</p><p id="774f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样做得到log(ML _ alternative)log(ML _ null)。</p><p id="e1e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我们不想要正态的R.V .我们想要正态变量的平方。</p><p id="de50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">log[ml_alternative^2]−log[ml_null^2]</p><p id="413f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据对数法则，我们得到:</p><p id="1f39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2∫[log(ML _ alternative)log(ML _ null)]</p><p id="1c3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者是维尔克所使用的形式</p><p id="6bea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">-2[log(ML _ null)-log(ML _ alternative)]</p><p id="038b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">维尔克定理告诉我们，上述统计量将渐近地服从卡方分布</p><p id="9470" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们用抛硬币的例子来实践这一点。</p><p id="28a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先让我们写一个函数来抛硬币，正面着地的概率为p。我们还将创建一个名为翻转的变量，在1000个独立的实验中模拟硬币翻转1000次，以创建1000个1000次翻转的序列。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="73c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们来纠正一个函数，它计算给定数量的参数的最大似然。这个函数的工作原理是将数据分成均匀的块(把每个块想象成代表它自己的硬币)，然后计算在每个块中观察到数据的最大可能性。例如，如果给定该函数十次翻转的序列:1，1，1，0，0，0，1，0，1，0，并被告知使用两个参数，则它将返回与前五次翻转(五次中的三次头部= .6)和后五次翻转(五次中的两次头部= .4)的最大似然估计相对应的向量(. 6，.. 4)。如果我们传递相同的数据，但告诉模型只使用一个参数，它将返回向量(. 5)，因为我们有10次翻转中的5次翻转。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="29cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们需要一个函数来计算在给定n个参数的情况下观察我们的数据的可能性。该函数的工作原理是根据参数的数量将数据分成均匀的块，然后计算在给定参数值的情况下观察到每个序列的可能性。例如，如果我们将序列1，1，0，1和参数(. 9，.. 5)传递给此函数，它将返回0.2025的可能性，这是通过计算得出的:假定着陆头的概率为0.9，观察到两个头的可能性为0.81，假定着陆头的概率为0.5，则一个尾巴接着一个头着陆的可能性为0.25。由于这些是独立的，我们将每个可能性相乘，得到观察数据的最终可能性，给定我们的两个参数. 81 x .25 = .2025。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="d552" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们写一个函数来求似然比:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="c170" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们可以编写一个函数，根据一组数据(我们在下面的函数中称之为翻转)和两个不同模型中的参数数量返回似然比检验统计量，从而将所有这些放在一起。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="37dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们准备证明似然比检验统计量是渐近卡方分布的。让我们在1000次实验中，每次实验投掷硬币1000次，然后绘制测试统计值的频率直方图，比较1参数模型和2参数模型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/bdcb9fe1e40ade98eab119e8e2015d87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sabrsuryoB6FFjgT3t524A.png"/></div></div></figure><p id="dad5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的密度图显示了以1个自由度收敛到卡方分布。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/b6fdb52ab733e0b3057b8eb821f7f12a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8cKihfbxMi6nbkJsxY5T_Q.png"/></div></div></figure><p id="6704" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们比较一个使用10个参数的模型和一个使用1个参数的模型，我们可以看到检验统计量的分布变化为自由度等于9的卡方分布。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/074057a79ae62a4594a470e5417e10ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HZNNG6bvhO6y6xHBe-kRsg.png"/></div></div></figure><p id="0e6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上图显示了检验统计值是卡方分布的。回到硬币和便士的例子，我们现在能够准确地量化双参数模型比单参数模型更好的拟合。回想一下我们的似然比:ML_alternative/ML_null是LR = 14.15558。如果我们取2[log(14.15558 ),我们得到一个测试统计值5.300218。</p><p id="ae80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用卡方CDF来查看，假设零假设为真，则在该值下有2.132276%的机会观察到似然比统计数据。所以在这种情况下，当α为0.05时，我们应该拒绝零假设。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/7351d7114e9f963c617a093625007bcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rfjs1jaaw_cWhhvcU7RL9g.png"/></div></div></figure><p id="380c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上图显示，假设零假设为真，并且每枚硬币与正面硬币有相同的落地概率，我们只会在大约2.13%的时间里看到5.3的测试统计。</p><h2 id="806b" class="ma mb iq bd mc md me dn mf mg mh dp mi lf mj mk ml lj mm mn mo ln mp mq mr ms bi translated">结论</h2><p id="b45a" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">本文使用模拟一枚或多枚硬币翻转的简单示例来演示如何使用似然比检验来比较两个模型对一组数据的拟合程度。我们讨论了模型“嵌套”的含义，考虑了在一个硬币对两个硬币的假设下，对一组硬币翻转进行建模的情况。最后，我们实证研究了维尔克定理，以证明LRT统计量是渐近卡方分布的，从而允许LRT作为一个正式的假设检验。</p></div></div>    
</body>
</html>