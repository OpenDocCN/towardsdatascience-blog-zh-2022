<html>
<head>
<title>Healthcare Predictive Analytics with GANs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用GANs进行医疗保健预测分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/healthcare-predictive-analytics-with-gans-f4e776dcc2c6#2022-11-07">https://towardsdatascience.com/healthcare-predictive-analytics-with-gans-f4e776dcc2c6#2022-11-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3c9f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用GANs增加不平衡的医疗再入院数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a83412946ff05d4cc5529aa8baa0d28f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JwWSISTAtdL4BZNpnaUkOQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://www.pexels.com/photo/ambulance-architecture-building-business-263402/" rel="noopener ugc nofollow" target="_blank">像素</a>上的<a class="ae ky" href="https://www.pexels.com/@pixabay/" rel="noopener ugc nofollow" target="_blank">像素</a>生成的图像</p></figure><p id="ddac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成对抗网络(GANs)是Ian Goodfellow及其同事在2014年开发的一类深度学习模型。在高层次上，gan由两个竞争的神经网络组成，这两个神经网络构成了一个零和游戏。这意味着一个神经网络代理的收益对应于另一个代理的损失。具体来说，GAN算法训练鉴别器来区分真实数据和合成数据，同时训练生成器来产生可以欺骗鉴别器的合成数据实例。</p><p id="27cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GANs有各种各样的应用，包括图像生成、图像到图像的转换、表格数据扩充等等。数据扩充用例很有趣，因为它可以用来扩充不平衡数据集，以进行离群点检测，这在行业中有广泛的应用。例如，在医疗保健空间数据中，使用GANs进行增强可用于改进预测患者再入院的机器学习模型。</p><p id="fbee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">患者再次入院对应于在特定时间间隔后，入院的患者返回同一家或另一家医院的事件。患者再入院率是衡量治疗和护理质量的一个很好的指标。高再入院率意味着较差的患者结果和较高的手术成本。事实上,《平价医疗法案》( ACA)对高再入院率的医疗服务提供者进行了处罚。也就是说，医疗保健提供者通过提供更高质量的护理来降低再入院率。</p><p id="78af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">造成高再入院率的因素有很多。这包括年龄、体重、地理位置、合并症、多种药物等等。例如，老年患者更有可能再次入院，因为他们有更多的慢性病和疾病。体重，尤其是肥胖，也起着很大的作用，因为超重和肥胖的人更有可能患有心脏病、癌症和其他严重的并发症。</p><p id="abc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前大多数降低再入院率的尝试包括理解ACA政策、识别高风险患者、药物调和、预防保健获得性感染以及良好的移交沟通。例如，ACA制定了减少再入院计划，激励医疗服务提供者提高医疗质量。此外，能够根据病史和人口统计数据识别高危人群也很重要。医疗协调包括确保患者的药物清单尽可能是最新的。这有助于降低因服用多种药物而导致的药物相关不良事件的风险。</p><p id="a4a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接受多种药物治疗的患者也很有可能再次入院。这很大程度上是由于需要这些药物治疗的合并症。多重用药还会导致药物相互作用，这可能会导致出院后的不良事件，增加再次入院的可能性。采取措施预防这些类型的感染可以降低再次入院的可能性。最后，不干涉交流很重要，因为它包含了对患者病情和治疗计划的清晰记录。如果在不干涉交流过程中遗漏了任何相关因素的信息，如多药或共病，可能会增加再入院的可能性。</p><p id="b973" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了手动监控这些再入院因素，医疗保健提供商还可以利用机器学习来帮助识别和锁定高危人群。在过去，基于各种风险因素训练的逻辑回归模型被用于预测再入院的概率。这些模型可以与人工检查配合使用，以采取预防措施来降低再入院率。</p><p id="6a63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">鉴于医疗保健数据高度敏感和机密，访问用于建模的数据源可能会很困难。尽管存在这些挑战，但仍有许多开源工具可用于创建真实代表预测建模所需因素的合成数据集。合成数据具有匿名、免费使用和公开共享的优势。尽管数据是合成的，但有了足够的领域专业知识，就可以生成一个具有高度代表性的数据集，并应用于各种用例中。</p><p id="a66a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://faker.readthedocs.io/en/master/" rel="noopener ugc nofollow" target="_blank"> Faker </a>是一款开源python工具，可用于生成各种行业垂直领域的合成数据，包括金融、零售和医疗保健。我们将了解如何使用Faker生成合成的医疗保健再入院数据，并将其用于预测建模。我们将包括许多已知的导致再入院风险的因素。然后，我们将基于高风险因素，以基于规则的方式为我们的机器学习模型定义再入院目标。</p><p id="bc81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">鉴于再入院并不常见，我们将此数据集建模为不平衡数据集，其中大部分数据由在规定时间范围内未再入院的患者组成。我们将构建一个基线catboost模型，用于比较数据扩充前后的性能。然后，我们将使用表格生成对抗网络(<a class="ae ky" href="https://github.com/Diyago/GAN-for-tabular-data" rel="noopener ugc nofollow" target="_blank"> tabgans </a>)来扩充我们的不平衡数据。最后，我们将建立一个catboost第二分类模型，用于根据我们的扩充数据预测患者再入院。</p><p id="cff0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这项工作，我将在<a class="ae ky" href="https://deepnote.com/" rel="noopener ugc nofollow" target="_blank"> Deepnote </a>中编写代码，这是一个协作数据科学笔记本，使运行可重复的实验变得非常容易。</p><h2 id="51ed" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak">用Faker生成合成数据</strong></h2><p id="71d3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">首先，让我们导航到Deepnote并创建一个新项目(如果您还没有帐户，可以免费注册)。</p><p id="86a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个名为“synthetic_data”的项目，并在这个项目中创建一个名为“tabgan_experiment”的笔记本:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/0864f82ea37f03786d547de19ed48822.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3iuYy8javizLU3R3Idl6CA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图</p></figure><p id="4e7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们安装将要使用的软件包:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="5c7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们导入Faker，并为将要生成的合成数据的大小定义一个变量。我们将生成一个包含5000行的数据集:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="10e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们定义一个Faker对象，并将其存储在一个名为“fake”的变量中:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="4bf1" class="lv lw it my b gy nc nd l ne nf">fake = Faker()</span></pre><p id="b29b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们设置一个种子，以便我们的结果是可重复的，并初始化一个名为names的列表，我们将使用它来存储我们的合成名称:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="9b23" class="lv lw it my b gy nc nd l ne nf">Faker.seed(42)<br/>names = []</span></pre><p id="1d52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们在for循环中用合成名称填充列表。为此，我们调用faker对象上的name()方法来生成合成名称:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="37cf" class="lv lw it my b gy nc nd l ne nf">for i in range(0,DATA_SIZE):<br/>    names.append(fake.name())</span></pre><p id="a3ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的单元格如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="26a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过在for循环中调用faker对象上的state()方法，我们可以为美国状态做一些类似的事情:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="a0ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的示例，我们将考虑患者被重新接纳到急诊部的场景:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="5b56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还将指定性别:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="a2a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们导入numpy并使用random.normal生成平均值为50岁、标准差为20年的正态分布年龄:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="f93e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们也生成体重的正态分布值，平均值为180磅，标准偏差为70磅:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="ecfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们对以英寸为单位的高度做同样的事情:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="1f5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以定义一个字段来指定患者是否吸烟:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="8cc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个详细说明了病人在急诊室呆了多少天:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="0e8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将使用动态提供者方法从外部列表或源中随机选择元素。让我们导入动态提供者:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="623f" class="lv lw it my b gy nc nd l ne nf">from faker.providers import DynamicProvider</span></pre><p id="6552" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们定义一个带有健康保险列表的动态提供者对象:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="351c" class="lv lw it my b gy nc nd l ne nf">health_insurance_provider = DynamicProvider(<br/>provider_name="health_insurance",<br/>elements=["UnitedHealth Group", "Anthem", "Aetna", "Cigna", "Humana", "Medicare"],<br/>)</span></pre><p id="47ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将为可再现性设置一个随机种子，并将我们的健康保险提供商对象添加到我们的faker对象中:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="520c" class="lv lw it my b gy nc nd l ne nf">Faker.seed(42)<br/>fake.add_provider(health_insurance_provider)</span></pre><p id="bef4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以将随机选择的保险附加到我们的保险列表中:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="2acd" class="lv lw it my b gy nc nd l ne nf">insurance = []<br/>for i in range(0, DATA_SIZE):<br/>    insurance.append(fake.health_insurance())</span></pre><p id="18af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的单元格如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="98d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们使用我们的列表创建一个熊猫数据框架:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="3493" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们也从我们的体重和身高值计算身体质量指数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="1627" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的目标是创建一个数据集，用于训练再入院分类模型。接下来我们需要做的是为重新接纳生成目标标签。让我们从生成一些随机分配的标签开始。这将成为我们通常在真实数据中发现的噪声:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="da8f" class="lv lw it my b gy nc nd l ne nf">df['readmission'] = [np.random.randint(0,2) for x in range(0, DATA_SIZE)]</span></pre><p id="dcb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">faker对象的names方法生成的名称不一定是惟一的，所以让我们去掉重复的名称:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="d0f5" class="lv lw it my b gy nc nd l ne nf">df.drop_duplicates('name', inplace=True)</span></pre><p id="73b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们对20%的结果数据进行采样，并将其存储在一个名为df_sample1的新数据帧中。该数据框将构成我们的阴性和阳性再入院结果的噪声值:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="7694" class="lv lw it my b gy nc nd l ne nf">df_sample1 = df.sample(frac=0.2, replace=True, random_state=1)</span></pre><p id="56fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其余80%的数据将存储在另一个名为df_sample2的数据帧中:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="14a2" class="lv lw it my b gy nc nd l ne nf">df_sample2 = df[~df['name'].isin(list(set(df_sample1['name'])))]</span></pre><p id="8c73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用df_sample 2来定义我们的基本事实标签。重新接纳值将为0或1。重新入院值为0表示患者在指定的时间段后没有重新入院。值为1表示患者已再次入院。这通常是30天或60天，但出于我们的目的，我们不必担心确切的值，因为这都是合成数据。让我们将df_sample2中的所有重新接纳值初始化为0</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="f65a" class="lv lw it my b gy nc nd l ne nf">df_sample2['readmission'] = 0</span></pre><p id="50a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们将所有身体质量指数&gt; 30、吸烟、有医疗保险且在急诊室停留&gt; 5天的患者标记为再入院值为1:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="de0e" class="lv lw it my b gy nc nd l ne nf">df_sample2.loc[(df_sample2.bmi &gt;=30) &amp; (df_sample2.smoker == 'Yes') &amp; (df_sample2.insurance == 'Medicare') &amp; (df.length_of_stay &gt;= 5), 'readmission'] = 1</span></pre><p id="c9f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们将df_sample1追加到df_sample2，并将结果存储在新变量df中:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="1e6a" class="lv lw it my b gy nc nd l ne nf">df = df_sample2.append(df_sample1)</span></pre><p id="21c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的单元格如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="8c59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们使用计数器方法来查看0和1再入院结果的数量。如我们所见，数据不平衡，517个再入院值等于1，4405个再入院值等于0:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><h2 id="1692" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">构建Catboost分类器</h2><p id="3f8d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在，我们可以开始为分类模型准备数据了。让我们将分类列转换成机器可读的代码。虽然catboost可以直接处理分类变量，但这将使以后使用tabgan更加容易:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="0956" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以为建模定义输入和输出。我们将使用“保险”、“性别”、“吸烟者”、“州”、“身高”、“体重”、“bmi”、“住院时间”来预测“再次入院”:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="9a11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们将数据分为训练和测试两部分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="7ae6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们导入catboost包:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="c733" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以定义我们的模型对象，并使它适合我们的训练数据。为简单起见，我们对catboost模型使用10次迭代(与n_estimators相同):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="7d16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们来评估我们模型的性能。由于我们的数据是不平衡的，精度是一个很好的度量标准，用于衡量模型预测代表性不足的类别的效果。精度值为1.0意味着模型具有完美的精度:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="1188" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到，该模型预测测试集中的所有值都具有0的重新接纳值，即使测试集中有146个1的基本真值。这相当于精度值为0。在不平衡数据上构建分类模型时，这是一个典型的问题。理想情况下，表格形式的GANs可以帮助我们通过数据扩充来提高模型精度。</p><h2 id="3b66" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">用Tabgan扩充数据</h2><p id="6cbb" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">让我们从导入tabgan开始:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="5783" class="lv lw it my b gy nc nd l ne nf">from tabgan.sampler import GANGenerator</span></pre><p id="38ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们定义列、输入和输出，并重置索引:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="12cf" class="lv lw it my b gy nc nd l ne nf">cols = ['insurance', 'sex', 'smoker', 'state', 'height', 'weight', 'bmi', 'length_of_stay', 'readmission']</span><span id="31c1" class="lv lw it my b gy nq nd l ne nf">X = df[cols[:-1]]<br/>y = pd.DataFrame(list(df['readmission']), columns=['readmission'])</span><span id="db5d" class="lv lw it my b gy nq nd l ne nf">X.reset_index(inplace=True, drop=True)<br/>y.reset_index(inplace=True, drop=True)</span></pre><p id="4143" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将拆分数据用于培训和测试:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="652e" class="lv lw it my b gy nc nd l ne nf">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)</span><span id="81b1" class="lv lw it my b gy nq nd l ne nf">X_train.reset_index(inplace=True, drop=True)<br/>y_train.reset_index(inplace=True, drop=True)<br/>X_test.reset_index(inplace=True, drop=True)</span></pre><p id="b773" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后用生成器生成我们的合成数据。该代码将生成输入(new_train2)和输出(new_target2)的新数据帧，其中合成输入数据被附加到X_train并存储在new_train2中，合成目标值被附加到y_train并存储在new_target2中。如果您对与GANGenerator和generate_data_pipe相关的参数感兴趣，请参见<a class="ae ky" href="https://pypi.org/project/tabgan/" rel="noopener ugc nofollow" target="_blank"> tabgan文档</a>。</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="677a" class="lv lw it my b gy nc nd l ne nf">new_train2, new_target2 = GANGenerator(cat_cols = cols, epochs=2, is_post_process=False).generate_data_pipe(X_train, y_train, X_test,use_adversarial=False, only_generated_data=False)</span></pre><p id="67de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的单元格如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="953d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以使用计数器方法来查看重新接纳的1和0的分布:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns mv l"/></div></figure><p id="f209" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到产生了更多的数据。在我们的原始数据集中，有4405个再入院值等于0，517个再入院值等于1。与上面的截图相比，我们现在有8102个值等于0，2921个值等于1:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="5d20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以显示新的输入数据new_train2:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="eae0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们在扩充数据上训练一个新的catboost模型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="4f54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并评估性能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="f6f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到我们在精度上有了一点点提高。这可以通过调节恒发生器的超参数进一步改善。例如，您可以尝试将纪元的数量从2增加到更大的数字，如50或100。</p><p id="09e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章中使用的代码可以在<a class="ae ky" href="https://github.com/spierre91/deepnote" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><h2 id="7f1c" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">结论</h2><p id="db50" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在这里，我们看了如何使用开源python包来考虑预测患者再入院的真实医疗保健用例。首先，我们使用faker软件包生成患者属性，随后我们使用这些属性来训练再入院分类模型。然后，我们看到了如何使用tabgan包来扩充我们用由我们的GANgenerator生成的合成值生成的训练数据。我们发现，通过这种数据扩充方法，我们能够提高分类模型的精度。这种数据扩充的方法也可以用于这里没有提到的医疗保健预测问题。这包括罕见疾病检测、不良药物相互作用事件、基于价值的护理的患者人群风险分类等等。</p></div></div>    
</body>
</html>