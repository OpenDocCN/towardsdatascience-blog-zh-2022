<html>
<head>
<title>Transformations on a JSON file using Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Pandas对JSON文件进行转换</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/transformations-on-a-json-file-using-pandas-eba831181a96#2022-09-22">https://towardsdatascience.com/transformations-on-a-json-file-using-pandas-eba831181a96#2022-09-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2c3b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki">一套有用的pandas工具，用于成功加载和转换JSON文件</em></h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kj"><img src="../Images/8948d32eb60cb4925a07b1090aa3f44a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-SoomFF9Mt0pRhdDHV2vLw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者使用canva提供)</p></figure><p id="08f3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在数据工程/科学领域，通过JSON (JavaScript Object Notation)文件加载和执行转换是很常见的事情。</p><p id="4be2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">JSON是一种广泛使用的存储和交换数据的格式。比如像MongoDB这样的NoSQL数据库是以JSON格式存储数据的，REST API的响应大多是以JSON的形式提供的。</p><p id="d408" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">尽管JSON非常适合通过网络交换数据，但是如果我们想要处理数据，我们需要将它转换成表格形式，也就是包含列和行的形式。</p><p id="2914" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，一般来说，我们可以在一个文件中遇到两种类型的JSON结构:</p><ol class=""><li id="8aee" class="lr ls it kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">JSON对象</li><li id="fa28" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">JSON对象的列表</li></ol><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/97370a34f9e13773282e4687515dbb6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*8t4ikyywsCyf5qOzXRUK3g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">JSON对象与JSON对象列表(图片由作者提供)</p></figure><blockquote class="mg mh mi"><p id="c377" class="kv kw mj kx b ky kz ju la lb lc jx ld mk lf lg lh ml lj lk ll mm ln lo lp lq im bi translated">在本文中，我们将关注第二个场景(JSON对象的列表)，据我所知，这是最常见的场景<strong class="kx iu">，更重要的是，</strong>通过学习处理列表场景，我们可以轻松地处理单个JSON对象。</p></blockquote><p id="9f18" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为了处理JSON对象列表，我们可以使用pandas，更具体地说，我们可以使用两个pandas函数:explode()和json_normalize()。</p><p id="3651" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们简单解释一下，然后再看完整的例子。</p><p id="7eb7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这篇文章内容如下:</p><ol class=""><li id="f0c3" class="lr ls it kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">简要解释explode()函数</li><li id="d33a" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">简要解释json_normalize()函数</li><li id="8daf" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">在完整的示例中使用这两个来创建一个<em class="mj">固化的D </em>数据帧。</li><li id="394d" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">做一些转换</li><li id="fd64" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">将转换后的数据转储为CSV格式</li></ol><p id="a9ab" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">源代码请查看<a class="ae mn" href="https://github.com/nachovrgs/data-engineering/blob/main/data-analysis/pandas/pandas-transformations-json.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>。</p><h1 id="77e7" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">1.激增</h1><p id="ef4d" class="pw-post-body-paragraph kv kw it kx b ky ng ju la lb nh jx ld le ni lg lh li nj lk ll lm nk lo lp lq im bi translated">explode()函数用于将list like值的每个元素转换为一行，并为新元素保持旧的索引值。</p><p id="166a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">像这样:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nl"><img src="../Images/ba0f16cf789731826d3c124527c7f31e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ik8sGcTCMP9VBT34_5bddA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">explode()简单示例(图片由作者提供)</p></figure><p id="a487" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">该函数使用以下语法:</p><pre class="kk kl km kn gt nq nr ns nt aw nu bi"><span id="1cbf" class="nv mp it nr b gy nw nx l ny nz">df.explode('<strong class="nr iu"><em class="mj">column_to_explode', ignore_index=False)</em></strong></span></pre><p id="d6ab" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们还可以发送要展开的列的列表:</p><pre class="kk kl km kn gt nq nr ns nt aw nu bi"><span id="c570" class="nv mp it nr b gy nw nx l ny nz">df.explode(['col_1', 'col_2'], <strong class="nr iu"><em class="mj">ignore_index=False)</em></strong></span></pre><p id="0ed7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">它看起来会像这样</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/0fcf659106fa1bc60d93c244aba13c64.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*fq3_TuD-piWztKGm5HwNZQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">分解前的基本代码示例(图片由作者提供)</p></figure><p id="6ba5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在让我们来爆一下<em class="mj"> col_2 </em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/77963adad16e874fad74d680b1347f9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*YfW5TiVtDQrEK3S6Se-ugg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">分解后的基本代码示例(图片由作者提供)</p></figure><p id="4004" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">请注意分解行的索引是如何保持的。</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h1 id="e7da" class="mo mp it bd mq mr oj mt mu mv ok mx my jz ol ka na kc om kd nc kf on kg ne nf bi translated">2.JSON正常化</h1><p id="d486" class="pw-post-body-paragraph kv kw it kx b ky ng ju la lb nh jx ld le ni lg lh li nj lk ll lm nk lo lp lq im bi translated">json_normalize()函数在半结构化列上执行我们称为<em class="mj">的扁平化</em>操作。也就是说，它为结构的每个属性创建新列。</p><p id="e060" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这是语法:</p><pre class="kk kl km kn gt nq nr ns nt aw nu bi"><span id="3013" class="nv mp it nr b gy nw nx l ny nz">data = [<br/>  {<br/>    "id": 1,<br/>    "name": {<br/>      "first": "Coleen",<br/>      "last": "Volk"<br/>    }<br/>  },<br/>  {<br/>    "name": {<br/>      "given": "Mark",<br/>      "family": "Regner"<br/>    }<br/>  },<br/>  {<br/>    "id": 2,<br/>    "name": "Faye Raker"<br/>  },<br/>  <br/>]</span><span id="c2c5" class="nv mp it nr b gy oo nx l ny nz"><strong class="nr iu">pd.json_normalize(data)</strong></span><span id="f5d4" class="nv mp it nr b gy oo nx l ny nz"><em class="mj">or within a column of your Data Frame</em></span><span id="4590" class="nv mp it nr b gy oo nx l ny nz"><strong class="nr iu">pd.json_normalize(df['a_column'])</strong></span></pre><p id="e12c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们来唱:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi op"><img src="../Images/ed643fce3508fd96c398d3981b0e70ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*7duJjqUyarDMIA_KDWwFFg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">json_normalize示例(图片由作者提供)</p></figure><p id="6bc4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">正如我们所看到的，它从我们的原始JSON创建了一个数据帧，将根中的每个属性作为一列。</p><p id="7aa6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">嵌套属性是这里有趣的部分。JSON normalize接受每一个，并创建一个保持其原始路径的列。</p><p id="036e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">即。</p><pre class="kk kl km kn gt nq nr ns nt aw nu bi"><span id="2e18" class="nv mp it nr b gy nw nx l ny nz">"name": {<br/>   "first": "Coleen",<br/>   "last": "Volk"<br/>}</span><span id="b8a2" class="nv mp it nr b gy oo nx l ny nz"><strong class="nr iu">becomes</strong></span><span id="ef33" class="nv mp it nr b gy oo nx l ny nz">name.first, name.last</span></pre><p id="d7a3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们还应该注意到，normalize接受所有找到的"<em class="mj"> name "(名、姓、名、族和一个普通字符串)</em>的子参数，并为每个子参数创建一列；用<em class="mj"> NaN </em>填充缺失值。</p><p id="5b58" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们可以选择分离器</p><pre class="kk kl km kn gt nq nr ns nt aw nu bi"><span id="a1aa" class="nv mp it nr b gy nw nx l ny nz">pd.json_normalize(data, sep="&lt;our_sep&gt;")</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/fab0bbebad256d1c2f03972a9ea68293.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*ESvyWcIfYeFG9UtuD92xlg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">标准化的自定义分隔符(按作者排序的图像)</p></figure><p id="ccf2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们还可以控制JSON的级别，直到我们想要规范化为止</p><pre class="kk kl km kn gt nq nr ns nt aw nu bi"><span id="79d1" class="nv mp it nr b gy nw nx l ny nz">pd.json_normalize(data, max_level=&lt;my_int_level&gt;)</span></pre><p id="5018" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">哪里……</strong></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi or"><img src="../Images/4753fb2283c6ed7336000fc9d758dc15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*u5z_wDJ_6l37ZtY0LOwgQw.png"/></div></figure><p id="ce7b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们看看实际情况</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi os"><img src="../Images/8b0196b806b277d75533a5a09d43109b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*mpr7cGMcwWF_asbv9rR2MA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">规格化的最大级别(按作者排序的图像)</p></figure></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h1 id="44a1" class="mo mp it bd mq mr oj mt mu mv ok mx my jz ol ka na kc om kd nc kf on kg ne nf bi translated">3.让我们看一个完整的例子</h1><blockquote class="mg mh mi"><p id="c689" class="kv kw mj kx b ky kz ju la lb lc jx ld mk lf lg lh ml lj lk ll mm ln lo lp lq im bi translated">例如，我们将使用来自电子商务商店的购物车商品列表，该列表来自于<a class="ae mn" href="https://dummyjson.com/docs/carts" rel="noopener ugc nofollow" target="_blank"> <em class="it"> dummyjson </em> api </a>。</p></blockquote><p id="51c7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">假设我们有一个需要以某种方式处理的购物车列表。</p><p id="6cf3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">假设我们在需要提取和转换的blob中有一个原始格式的JSON:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/97b12fe61e1afec2160b99e3f8b5cbbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*jvVfiPRyA3MdK_X2-7Qaig.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">取自虚拟json ( <a class="ae mn" href="https://dummyjson.com/carts" rel="noopener ugc nofollow" target="_blank">来源</a>)</p></figure><p id="3b07" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在这个例子中，我们有一个带有<em class="mj"> carts </em>属性的主对象，其中包含我们需要的列表。</p><p id="553e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">比方说，我们需要<strong class="kx iu">提取</strong>购物车产品或商品，并对其进行以下<strong class="kx iu">转换</strong>，并将结果输出到AWS S3，以便进一步处理或存储:</p><ul class=""><li id="60a8" class="lr ls it kx b ky kz lb lc le lt li lu lm lv lq ou lx ly lz bi translated">基于产品的<em class="mj">总计</em>和构成<em class="mj">大销售额</em>的阈值，创建一个名为<strong class="kx iu"> big_sale </strong>的新布尔列。</li><li id="783e" class="lr ls it kx b ky ma lb mb le mc li md lm me lq ou lx ly lz bi translated">为每一行添加一个<processed_ts>时间戳。</processed_ts></li></ul><p id="fb42" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果我们将购物车数据加载到pandas数据框中，并展开<em class="mj"> products </em>列，它看起来会像这样:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi ov"><img src="../Images/8562659071bb258076853bb7c474fa23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FNXqg6c7wwVz_vhofCrFNQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">示例-加载-数据(图片由作者提供)</p></figure><p id="7dea" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们使用请求库加载数据。然后变成熊猫:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi ow"><img src="../Images/d97b601a4388d6ebc46e9a527064f78b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6pfVnnrFkoeNmcBTu00dNw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">示例-数据框(图片由作者提供)</p></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi ox"><img src="../Images/95045df7e6dc65905761b5132bbf1d65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aSC9geA4-lS5qH4XAiZXqg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">示例-分解(图片由作者提供)</p></figure><p id="7f26" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">看起来不错，现在每个购物车中的每个产品都有一行。注意购物车id重复，这就是我们现在想要的…</p><p id="2247" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们现在需要处理产品所在的JSON格式</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi oy"><img src="../Images/622fca4db1d6b5338f30934fad480080.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MCn4c4CXjo9247S1q-Hb1g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">示例-展开-信息(图片由作者提供)</p></figure><p id="8c10" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为此，我们将使用之前的json_normalize来规范化json数据，并将结果加入到我们的分解数据框中。让我们看看那个</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi oz"><img src="../Images/4c28c9635defc8a81d12398884049afc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AkrNzirCY4wo1I_mKHgmYw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">示例-规格化(作者图片)</p></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/8142a23b9945ac1bb4eafa163e15196f.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*JtlbaVW8r6Z9x3d6JdZjtw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">示例-规格化-信息(图片由作者提供)</p></figure><p id="d201" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，对于<em class="mj">产品</em>列的每个JSON属性，我们都有了一个列</p><p id="9bf2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">接下来，我们可以连接<em class="mj">分解的</em>和<em class="mj">归一化的</em>数据帧，以在一个数据帧中获得JSON的完整表示。但是我们首先需要解决一个小问题:</p><p id="f2c7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="mj">explosed _ df</em>的索引是错误的，我们需要重置它以通过索引加入。</p><p id="cc33" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">因此，我们采取以下措施:</p><ol class=""><li id="fe8a" class="lr ls it kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">从<em class="mj">分解的</em>数据框中移除旧产品栏</li><li id="b6e0" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">重置<em class="mj">展开的</em>数据帧上的索引</li><li id="2264" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">连接<em class="mj">分解的</em>和<em class="mj">归一化的</em>数据帧</li></ol><p id="abd8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们走吧</p><p id="77a7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">首先我们删除旧的<em class="mj">产品</em>列，然后我们重置索引。</p><pre class="kk kl km kn gt nq nr ns nt aw nu bi"><span id="1873" class="nv mp it nr b gy nw nx l ny nz">exploded_df.drop(['products'], axis=1, inplace=True)</span><span id="fff3" class="nv mp it nr b gy oo nx l ny nz">exploded_df.reset_index(inplace=True)</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi pb"><img src="../Images/1d812073c7e30799d09f45f69755d8a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BJr8wu5iMstryEw7C51HNg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">示例-drop(作者提供的图片)</p></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi pc"><img src="../Images/151a7c2b7bae0bf0c759934521e79a16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t7c4bIucX8NtVgvBwQltLw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">示例-索引-匹配(图片由作者提供)</p></figure><p id="a203" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">请注意，索引现在匹配了。</p><p id="25ca" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在加入之前，我们需要处理两个重叠的列。</p><p id="7e10" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">列<em class="mj"> id </em>和<em class="mj"> total </em>存在于分解和规范化dfs中。为此，当我们加入时，我们将使用<a class="ae mn" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.join.html" rel="noopener ugc nofollow" target="_blank"> panda的加入</a>的后缀选项。</p><p id="7649" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们看看</p><pre class="kk kl km kn gt nq nr ns nt aw nu bi"><span id="b2da" class="nv mp it nr b gy nw nx l ny nz">joined_df = exploded_df.join(normalized_df, <em class="mj">lsuffix='_cart'</em>, <em class="mj">rsuffix='_product'</em>)</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi pd"><img src="../Images/1235f4e65d7614b40b8ba9b8474a5c25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y6iR2Rvr6cfbZpCPP4dY4g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">示例-已加入(图片由作者提供)</p></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/b73391ec41493761c506a694c7f94a6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*JSoQI4Q30329kIeFfcKi1g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">示例-加入信息(图片由作者提供)</p></figure><p id="a1c5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">完美，现在我们可以做一些转换…</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h1 id="d909" class="mo mp it bd mq mr oj mt mu mv ok mx my jz ol ka na kc om kd nc kf on kg ne nf bi translated">4.转换</h1><p id="33d1" class="pw-post-body-paragraph kv kw it kx b ky ng ju la lb nh jx ld le ni lg lh li nj lk ll lm nk lo lp lq im bi translated">我们需要做两件事:</p><ul class=""><li id="f983" class="lr ls it kx b ky kz lb lc le lt li lu lm lv lq ou lx ly lz bi translated">基于产品的总数<em class="mj">和构成<em class="mj">大销售额</em>的阈值，创建一个名为<strong class="kx iu"> big_sale </strong>的新布尔列。</em></li><li id="037e" class="lr ls it kx b ky ma lb mb le mc li md lm me lq ou lx ly lz bi translated">为每一行添加一个<processed_ts>时间戳。我们走吧…</processed_ts></li></ul><p id="4caf" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们将为big sale (≥ is big)设置一个阈值100，并使用pandas的<em class="mj"> apply() </em>函数为<em class="mj"> big_sale </em>列创建一个新系列。</p><blockquote class="mg mh mi"><p id="8e95" class="kv kw mj kx b ky kz ju la lb lc jx ld mk lf lg lh ml lj lk ll mm ln lo lp lq im bi translated">请注意，产品的总计列在连接后被称为total_product。</p></blockquote><pre class="kk kl km kn gt nq nr ns nt aw nu bi"><span id="8382" class="nv mp it nr b gy nw nx l ny nz">threshold = 100</span><span id="31fc" class="nv mp it nr b gy oo nx l ny nz"><em class="mj">big_sale_col</em> = joined_df.apply(lambda row: row.total_product &gt;= threshold, axis=1)</span></pre><p id="40f6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在我们可以将它添加到我们的<em class="mj">加入的</em>数据帧中</p><pre class="kk kl km kn gt nq nr ns nt aw nu bi"><span id="ed8a" class="nv mp it nr b gy nw nx l ny nz">joined_df['<em class="mj">big_sale</em>'] = <em class="mj">big_sale_col</em></span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi pf"><img src="../Images/f3eb84d92226778b3fd2fac1e1426e15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K15pT9YDfw8SfZpqvP8lww.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">示例-大甩卖(图片由作者提供)</p></figure><p id="2b6a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">很好，现在对于下一个转换，让我们简单地添加一个新列，用当前日期作为时间戳。</p><pre class="kk kl km kn gt nq nr ns nt aw nu bi"><span id="a141" class="nv mp it nr b gy nw nx l ny nz">from datetime import datetime</span><span id="6bb2" class="nv mp it nr b gy oo nx l ny nz">now = datetime.now()<br/>timestamp = datetime.timestamp(now)</span><span id="964b" class="nv mp it nr b gy oo nx l ny nz">joined_df['processed_ts'] = timestamp</span></pre><blockquote class="mg mh mi"><p id="f414" class="kv kw mj kx b ky kz ju la lb lc jx ld mk lf lg lh ml lj lk ll mm ln lo lp lq im bi translated">不要忘记导入日期时间</p></blockquote><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi pg"><img src="../Images/e30d06a91d1e1d98fcda482c2cb8a5c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2zugdzuECkRtfOoJVDaAyA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">示例-已处理(图片由作者提供)</p></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/75599fc7b2e3366a905b6b65aaa74873.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*_qctAIosALfuxEZcVpqKiA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">示例-已处理信息(图片由作者提供)</p></figure><p id="b802" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">太好了！我们什么都有。让我们导出数据</p><h1 id="f9ab" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">5.将转换后的数据转储为CSV格式</h1><p id="6a3c" class="pw-post-body-paragraph kv kw it kx b ky ng ju la lb nh jx ld le ni lg lh li nj lk ll lm nk lo lp lq im bi translated">显然，这是一个例子，在现实世界中，我们需要将处理后的数据输出到云中，可能不是CSV，而是parquet或任何其他列格式。</p><p id="6b9a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">尽管如此，按照示例，让我们在本地将其输出为一个<em class="mj"> processed.csv </em>文件</p><pre class="kk kl km kn gt nq nr ns nt aw nu bi"><span id="aa41" class="nv mp it nr b gy nw nx l ny nz">joined_df.to_csv('processed.csv', index=False)</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi pi"><img src="../Images/4beae8366139a05198c26c127fe4e331.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OIhOPgmNnJKFz_Z55vd_CQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">processed.csv文件(图片由作者提供)</p></figure></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h1 id="7a15" class="mo mp it bd mq mr oj mt mu mv ok mx my jz ol ka na kc om kd nc kf on kg ne nf bi translated">结论</h1><p id="5d53" class="pw-post-body-paragraph kv kw it kx b ky ng ju la lb nh jx ld le ni lg lh li nj lk ll lm nk lo lp lq im bi translated">处理一个原始的JSON文件是现实生活中非常常见的场景，pandas非常适合这种情况。</p><p id="7803" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">通过结合explode和normalize，我们可以将JSON文件放入数据框中进行处理。这对于处理来自例如通常为JSON格式的API的数据非常有用。</p><blockquote class="mg mh mi"><p id="0cfd" class="kv kw mj kx b ky kz ju la lb lc jx ld mk lf lg lh ml lj lk ll mm ln lo lp lq im bi translated">诚然，只有在处理对象列表时才需要exploded，但这是一个相当常见的东西。无论如何，如果您的json不需要它，json_normalize()函数足以让您处理您的JSON。</p></blockquote><p id="e4a2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们总结一下我们所做的事情:</p><ul class=""><li id="c886" class="lr ls it kx b ky kz lb lc le lt li lu lm lv lq ou lx ly lz bi translated">将JSON加载到数据框中</li><li id="3255" class="lr ls it kx b ky ma lb mb le mc li md lm me lq ou lx ly lz bi translated">像列一样展开列表</li><li id="fb75" class="lr ls it kx b ky ma lb mb le mc li md lm me lq ou lx ly lz bi translated">规范化JSON格式列</li><li id="4886" class="lr ls it kx b ky ma lb mb le mc li md lm me lq ou lx ly lz bi translated">做了一些简单的转换</li><li id="577c" class="lr ls it kx b ky ma lb mb le mc li md lm me lq ou lx ly lz bi translated">导出了数据</li></ul><p id="3738" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">感谢阅读！</p><p id="98cb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">来源请查看<a class="ae mn" href="https://github.com/nachovrgs/data-engineering/blob/main/data-analysis/pandas/pandas-transformations-json.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>。</p><h1 id="fcf1" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">参考</h1><ul class=""><li id="bc95" class="lr ls it kx b ky ng lb nh le pj li pk lm pl lq ou lx ly lz bi translated"><a class="ae mn" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.explode.html" rel="noopener ugc nofollow" target="_blank">爆炸()</a></li><li id="57b4" class="lr ls it kx b ky ma lb mb le mc li md lm me lq ou lx ly lz bi translated"><a class="ae mn" href="https://pandas.pydata.org/docs/reference/api/pandas.json_normalize.html" rel="noopener ugc nofollow" target="_blank"> json_normalize() </a></li><li id="9630" class="lr ls it kx b ky ma lb mb le mc li md lm me lq ou lx ly lz bi translated"><a class="ae mn" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.from_dict.html" rel="noopener ugc nofollow" target="_blank"> from_dict() </a></li><li id="a117" class="lr ls it kx b ky ma lb mb le mc li md lm me lq ou lx ly lz bi translated"><a class="ae mn" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.apply.html" rel="noopener ugc nofollow" target="_blank"> apply() </a></li><li id="29f1" class="lr ls it kx b ky ma lb mb le mc li md lm me lq ou lx ly lz bi translated"><a class="ae mn" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.to_csv.html" rel="noopener ugc nofollow" target="_blank"> to_csv() </a></li><li id="59fc" class="lr ls it kx b ky ma lb mb le mc li md lm me lq ou lx ly lz bi translated"><a class="ae mn" href="https://dummyjson.com/docs/carts" rel="noopener ugc nofollow" target="_blank">虚拟json </a></li></ul></div></div>    
</body>
</html>