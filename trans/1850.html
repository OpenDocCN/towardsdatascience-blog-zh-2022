<html>
<head>
<title>Building an iterative solver for linear optimization under constraints using geometry</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用几何构建约束条件下线性优化的迭代求解器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-an-iterative-solver-for-linear-optimization-under-constraints-using-geometry-d8df2a18b37e#2022-04-29">https://towardsdatascience.com/building-an-iterative-solver-for-linear-optimization-under-constraints-using-geometry-d8df2a18b37e#2022-04-29</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""/><figure class="gl gn jt ju jv jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi js"><img src="../Images/4333379851b944d7835e7c2144058f98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hkhPJuB1W6Iokuao"/></div></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">由<a class="ae kh" href="https://unsplash.com/@diggitymarketing?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">digity Marketing</a>在<a class="ae kh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="d773" class="ki kj iv bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">数据科学家的强大工具</h1><p id="cb21" class="pw-post-body-paragraph lg lh iv li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md io bi translated">优化是数据科学中的常用工具，最常用的方法之一是线性方法。</p><p id="a08b" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">尽管不是每个优化问题都可以用线性的方式来表述，但是在很多情况下，可以用线性的方式来重写。</p><p id="ca19" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">在这篇文章中，我们将使用迭代方法，为约束条件下的线性优化从头开始编写一个求解器。</p></div><div class="ab cl mj mk hz ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="io ip iq ir is"><h1 id="4501" class="ki kj iv bd kk kl mq kn ko kp mr kr ks kt ms kv kw kx mt kz la lb mu ld le lf bi translated">配料</h1><p id="1473" class="pw-post-body-paragraph lg lh iv li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md io bi translated">在约束条件下形式化优化时，需要考虑三个主要因素:</p><ul class=""><li id="cddc" class="mv mw iv li b lj me ln mf lr mx lv my lz mz md na nb nc nd bi translated">一组变量:这些是我们在优化过程中想要确定的量。</li><li id="0991" class="mv mw iv li b lj ne ln nf lr ng lv nh lz ni md na nb nc nd bi translated">目标:这是一个公式，它结合了变量，表达了一些我们想要最大化或最小化的值。由于我们把自己限制在线性优化的情况下，这个目标必须是变量的线性组合。</li><li id="09f9" class="mv mw iv li b lj ne ln nf lr ng lv nh lz ni md na nb nc nd bi translated">一组约束:这些约束将限制变量的可能值。同样，这些约束必须用线性公式表示。</li></ul><p id="9e8f" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">例如，变量可以是矩形长方体的高度<code class="fe nj nk nl nm b">H</code>、重量<code class="fe nj nk nl nm b">W, </code>和长度<code class="fe nj nk nl nm b">L </code>。目标可以是这个立体的维度之和:<code class="fe nj nk nl nm b">W + H + L</code>，我们可以对变量添加一些约束，比如<code class="fe nj nk nl nm b">W &lt; 3</code>和<code class="fe nj nk nl nm b">L &lt; 4.</code></p><p id="fe7d" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">从数学上来说，这可以写成:</p><figure class="no np nq nr gt jw gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/4ec8fc06351765b04f338c6f6c0137a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:314/format:webp/1*IltaHIXK0lgaJix3BacKlw.png"/></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">作者的系统</p></figure><p id="dafb" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">解决这个问题相当容易。可以手动完成。解决方案在于最大化<code class="fe nj nk nl nm b">W</code>和<code class="fe nj nk nl nm b">L</code>，并推导出<code class="fe nj nk nl nm b">H</code>，即:<code class="fe nj nk nl nm b">W = 3</code>、<code class="fe nj nk nl nm b">L = 4</code>和<code class="fe nj nk nl nm b">H = 4</code>，因此长方体尺寸之和为<code class="fe nj nk nl nm b">S =3 + 4 + 4 = 11.</code></p><h1 id="3078" class="ki kj iv bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">将问题可视化</h1><p id="8ccb" class="pw-post-body-paragraph lg lh iv li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md io bi translated">在进入数学细节之前，让我们试着用图形形象化我们的问题，以便我们得到一些见解。</p><p id="8bff" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">由于我们面临一个三维问题，即我们有三个变量:<code class="fe nj nk nl nm b">W, L and H</code>，我们可以使用3D几何。</p><p id="f06c" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">前两个约束很容易想象。第一种，将解空间限制在所有3D点都在<code class="fe nj nk nl nm b">W = 3</code>定义的平面之下的3D空间。第二种方法将解空间限制在由<code class="fe nj nk nl nm b">L = 4</code>定义的平面下方的所有3D点。</p><p id="7477" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">第三个问题处理起来有点复杂，但是如果我们使用下面的数学公式重新编写它:<code class="fe nj nk nl nm b">&lt;(W, L, H), (1, 1, 0)&gt; &lt;= 8</code>，其中运算符<code class="fe nj nk nl nm b">&lt;., .&gt;</code>是点积，看起来这个约束将长方体的维度投影到向量<code class="fe nj nk nl nm b">(1, 1,0)</code>上，并且这个投影的分量之和必须小于8。</p><p id="94db" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">用最小距离解释该投影的另一种方式是将该矢量<code class="fe nj nk nl nm b">(1, 1, 0)</code>视为平面图的(非标准化)法向矢量。因此，再一次，这第三个约束可以从几何学上解释为一个计划。</p><p id="35db" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">下图通过用一个法向量将平面图绘制成一个圆来说明这一点。</p><figure class="no np nq nr gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi ns"><img src="../Images/e9ee84e906be81e22642c02927717c88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GmSO_q67fAjOfPiw0l8g6A.png"/></div></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">解空间，三个约束表示为边界平面。作者图。</p></figure><p id="69d1" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">上图中，<code class="fe nj nk nl nm b">A = (3, 0, O)</code>和法向量<code class="fe nj nk nl nm b">u = (1, 0, 0)</code>具体化了第一个约束<code class="fe nj nk nl nm b">W &lt;= 3</code>；<code class="fe nj nk nl nm b">B = (0, 4, 0)</code>和<code class="fe nj nk nl nm b">v = (0, 1, 0)</code>实现第二个约束，而<code class="fe nj nk nl nm b">C = (0, 4, 4)</code>。</p></div><div class="ab cl mj mk hz ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="io ip iq ir is"><h1 id="2eb7" class="ki kj iv bd kk kl mq kn ko kp mr kr ks kt ms kv kw kx mt kz la lb mu ld le lf bi translated">解决问题</h1><h2 id="86d3" class="nt kj iv bd kk nu nv dn ko nw nx dp ks lr ny nz kw lv oa ob la lz oc od le oe bi translated">迭代方法</h2><p id="098e" class="pw-post-body-paragraph lg lh iv li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md io bi translated">让我们首先想象我们正在尝试无约束地优化目标<code class="fe nj nk nl nm b">W + H + L</code>。即使这个目标相对于<code class="fe nj nk nl nm b">W, H and L</code>是线性的，我们仍然可以使用最速下降法。</p><p id="651e" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">在线性情况下，如果没有约束，使用这种方法是不相关的，尤其是因为系统是无界的，所以没有解。然而，我们将在下一节中看到如何在这个迭代方法中集成约束。</p><p id="868a" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">这种最速下降法很简单，而且是纯几何的:想法是计算一个函数的梯度，并在梯度的方向上稍微移动。这里梯度是常数，是矢量<code class="fe nj nk nl nm b">(1, 1, 1)</code>。下面的代码说明了这种方法:</p><figure class="no np nq nr gt jw"><div class="bz fp l di"><div class="of og l"/></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">简单最速上升代码。作者代码。</p></figure><p id="e6d8" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">在这段代码中，<code class="fe nj nk nl nm b">weights</code>包含了渐变，如同在线性公式中一样，渐变只是线性组合的权重。<code class="fe nj nk nl nm b">x_0</code>为初始值，<code class="fe nj nk nl nm b">delta</code>定义步长。</p><p id="6906" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">注意停止准则是基于收敛的。在这种情况下，没有约束，系统永远不会收敛。目标会无限增加。</p><h2 id="bb32" class="nt kj iv bd kk nu nv dn ko nw nx dp ks lr ny nz kw lv oa ob la lz oc od le oe bi translated">检测不满足的约束</h2><p id="cf4e" class="pw-post-body-paragraph lg lh iv li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md io bi translated">在这一步，我们需要能够做的是确定一个点是否在一个平面之下。一个平面可以用一个点<code class="fe nj nk nl nm b">A</code>和一个法向量<code class="fe nj nk nl nm b">n</code>来定义。按照惯例，如果一个点位于半空间中，指向法向量的方向，我们就说这个点在平面之上。相反，如果一个点在另一半空间中，它就被认为在平面下。</p><p id="bb30" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">下图说明了用<code class="fe nj nk nl nm b">W = 3</code>定义的平面:</p><figure class="no np nq nr gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi oh"><img src="../Images/7432d726a958924f21fa60f3702451e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yvtojn3AQ1Gac5d8GaD7OA.png"/></div></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">绿色平面由点A和法向量定义。作者的情节。</p></figure><p id="cb5f" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">给定这两条信息，通过涉及点积的计算，就有可能知道一个点是在平面之上还是之下。</p><p id="b630" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">让我们考虑下图中的两点<code class="fe nj nk nl nm b">Aa</code>和<code class="fe nj nk nl nm b">Ab</code>:</p><figure class="no np nq nr gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi oh"><img src="../Images/93ac4420a527e4eef80b32241f7c1099.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lpKWC6z1tykDBvg9dG1jsQ.png"/></div></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">相对于法向量，Ab在平面下方，而Aa在平面上方。作者图。</p></figure><p id="3cab" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">记住，当在一个向量和一个归一化向量之间做点积时，如果两个向量指向相同的方向，那么产生的标量将是正的，而如果它们指向相反的方向，那么它将是负的。</p><p id="734e" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">因此，为了知道<code class="fe nj nk nl nm b">Ab</code>是否在平面之下，只需要在法向量<code class="fe nj nk nl nm b">n</code>和连接<code class="fe nj nk nl nm b">A</code>和<code class="fe nj nk nl nm b">Ab</code>的向量<code class="fe nj nk nl nm b">AAb</code>之间执行点积。</p><p id="8449" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">如上图所示，这两个向量指向相反的方向，因此<code class="fe nj nk nl nm b">Ab</code>位于此处定义的平面下方。</p><p id="8808" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">对面<code class="fe nj nk nl nm b">Aa</code>在飞机上方。</p><p id="d896" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">下面的截图解释了如何使用NumPy在python中实现这一点:</p><figure class="no np nq nr gt jw"><div class="bz fp l di"><div class="of og l"/></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">检测一个点是在平面的下面还是上面。作者代码。</p></figure><h2 id="d837" class="nt kj iv bd kk nu nv dn ko nw nx dp ks lr ny nz kw lv oa ob la lz oc od le oe bi translated">强制约束</h2><p id="0495" class="pw-post-body-paragraph lg lh iv li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md io bi translated">将线性约束正式定义为一个平面，由一个点和一个法向量定义，我们就有了必要的工具来检测不满足的约束。</p><p id="8d17" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">我们现在需要的是一种强制约束的方法。从几何学上讲，这意味着我们需要一种方法来将所考虑的点移动到平面上。即我们需要将该点投影到平面上。</p><p id="de93" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">再一次，点积可以帮助我们。如上所述，法向量<code class="fe nj nk nl nm b">n</code>与连接<code class="fe nj nk nl nm b">A</code>和兴趣点<code class="fe nj nk nl nm b">P</code>的向量之间的点积符号告知我们<code class="fe nj nk nl nm b">P</code>相对于平面的位置。</p><p id="a1dd" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">但更重要的是，如果法向量<code class="fe nj nk nl nm b">n</code>已经归一化，这个点积就给了我们平面和点<code class="fe nj nk nl nm b">P</code>之间的距离。知道了这一点，将<code class="fe nj nk nl nm b">P</code>投影到平面上简单地归结为将<code class="fe nj nk nl nm b">P</code>向矢量<code class="fe nj nk nl nm b">n</code>的相反方向移动由点积给出的量。</p><p id="58fd" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">一张图胜过千言万语，我们来看看下图:</p><figure class="no np nq nr gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi oh"><img src="../Images/b3ebd0e58f8fc18871088ad2bb87435b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RUL3Tgvq5RR0bxVGw4iH_A.png"/></div></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">在由A和n定义的平面上投影一个点P。</p></figure><p id="7b56" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">点<code class="fe nj nk nl nm b">P'</code>已经通过在法向量上的投影<code class="fe nj nk nl nm b">P</code>获得。投影<code class="fe nj nk nl nm b">P</code>以得到它的投影<code class="fe nj nk nl nm b">Proj</code>是通过使用向量<code class="fe nj nk nl nm b">P’A</code>平移P简单完成的。</p><p id="91ba" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">用python写的，给出了:</p><figure class="no np nq nr gt jw"><div class="bz fp l di"><div class="of og l"/></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">投影代码。作者代码。</p></figure><p id="13cc" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">请注意，这个函数<code class="fe nj nk nl nm b">project</code>在数学上实际上是一个投影仪，因为<code class="fe nj nk nl nm b">project(project(P))</code>等于<code class="fe nj nk nl nm b">project(P)</code>。这是投影仪的数学定义。</p><h2 id="2d3e" class="nt kj iv bd kk nu nv dn ko nw nx dp ks lr ny nz kw lv oa ob la lz oc od le oe bi translated">把所有的放在一起</h2><p id="63b7" class="pw-post-body-paragraph lg lh iv li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md io bi translated">我们现在有三种工具可供使用:</p><ul class=""><li id="26fe" class="mv mw iv li b lj me ln mf lr mx lv my lz mz md na nb nc nd bi translated">收敛到最优解的迭代方法</li><li id="ca6a" class="mv mw iv li b lj ne ln nf lr ng lv nh lz ni md na nb nc nd bi translated">用于检测约束是否得到充分尊重的函数</li><li id="fce6" class="mv mw iv li b lj ne ln nf lr ng lv nh lz ni md na nb nc nd bi translated">必要时强制遵守约束的投影器。</li></ul><p id="25f2" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">在约束条件下最大化目标的算法非常简单:</p><ol class=""><li id="402a" class="mv mw iv li b lj me ln mf lr mx lv my lz mz md oi nb nc nd bi translated">我们使用最陡下降法，沿着梯度向最优方向移动</li><li id="76a3" class="mv mw iv li b lj ne ln nf lr ng lv nh lz ni md oi nb nc nd bi translated">我们确保约束得到遵守</li><li id="c17b" class="mv mw iv li b lj ne ln nf lr ng lv nh lz ni md oi nb nc nd bi translated">如果不是，则实施约束</li><li id="eb43" class="mv mw iv li b lj ne ln nf lr ng lv nh lz ni md oi nb nc nd bi translated">迭代，直到我们已经收敛，即，直到该点停止移动。</li></ol><p id="380e" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">在python中，这给出了:</p><figure class="no np nq nr gt jw"><div class="bz fp l di"><div class="of og l"/></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">使用迭代方法优化系统。作者代码。</p></figure><p id="1a91" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">为了简化问题的描述，我们引入了一个<code class="fe nj nk nl nm b">Constraint</code>对象，它用一个向量、一个点和一个间隙定义了一个约束。间隙表示约束相对于平面的距离。</p><p id="3971" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">我们还引入了一个函数<code class="fe nj nk nl nm b">normalize_constraint</code>，以确保法向量是酉的，即我们确保它的范数是1.0。</p><p id="2dbf" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">正如您所看到的，这个基本求解器收敛于最优目标，并提出预期的解决方案。</p><h1 id="9ccd" class="ki kj iv bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">好吧，这在3D中是可行的，但是更高维度呢？</h1><p id="d2dc" class="pw-post-body-paragraph lg lh iv li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md io bi translated">到目前为止，我们一直使用3D几何，以方便理解。然而，我们上面所做的一切可以立即推广到任何n维空间，其中<code class="fe nj nk nl nm b">n ≥ 3</code>。</p><p id="ca57" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">这可以通过将约束视为<code class="fe nj nk nl nm b">n-dimensional</code>空间的超平面，即<code class="fe nj nk nl nm b">n-1</code>维度对象来实现。</p><p id="9929" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">例如，如果我们使用一个4维的超立方体，而不是我们的3D立方体，我们会得到下面的代码，其中只有问题定义发生了变化:</p><figure class="no np nq nr gt jw"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="cd3f" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">我们增加了另一个维度:<code class="fe nj nk nl nm b">Z</code>，并对其进行简单约束，即<code class="fe nj nk nl nm b">Z &lt;= 5</code>。因此，最大目标现在是<code class="fe nj nk nl nm b">3 + 4 + 4 + 5 = 16</code>，求解器找到了。</p></div><div class="ab cl mj mk hz ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="io ip iq ir is"><h1 id="d494" class="ki kj iv bd kk kl mq kn ko kp mr kr ks kt ms kv kw kx mt kz la lb mu ld le lf bi translated">结论</h1><p id="66b1" class="pw-post-body-paragraph lg lh iv li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md io bi translated">在这篇文章中，我们提出了一种几何的和容易理解的方法来解决约束下的线性问题。</p><p id="3df5" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">如果你看一下关于这个主题的文献，你会发现还有许多其他方法可以解决这类问题。特别是，还有另一类方法，基于工作方式完全不同的单纯形法。</p><p id="06fb" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">这种方法有一些优点，其中之一是精度，因为与这里提出的方法相反，它不收敛到解，而是找到解。</p><p id="c368" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">这也是一类较少受病态问题影响的方法。</p><p id="d490" class="pw-post-body-paragraph lg lh iv li b lj me ll lm ln mf lp lq lr mg lt lu lv mh lx ly lz mi mb mc md io bi translated">然而，迭代方法，如这里介绍的一个，具有更有效的优势，并允许控制精度和时间消耗之间的权衡。</p></div></div>    
</body>
</html>