<html>
<head>
<title>Monte Carlo Simulation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">蒙特 卡罗模拟</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/monte-carlo-simulation-2b24fc810683#2022-08-03">https://towardsdatascience.com/monte-carlo-simulation-2b24fc810683#2022-08-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="e7f4" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">第一部分:报童问题</strong></h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/e88f1e4665cd96332a4f524938e8c21a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PK0jk-2HQKOl5CMy"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">由<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae le" href="https://unsplash.com/@iammrcup?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Cup先生/杨奇煜·巴拉</a>拍摄</p></figure><p id="8378" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本系列的第一篇文章<a class="ae le" href="https://medium.com/@dar.wtz/list/simulation-with-simpy-eccba6f32306" rel="noopener">中，我们将<strong class="lh iu">模拟</strong>定义为一种数值技术，包括建立被研究系统的数学和/或逻辑模型，然后对其进行实验，收集数据，使我们能够获得一个估计器来帮助解决复杂的决策问题。</a></p><p id="8fb6" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在同一篇文章中，我们将<strong class="lh iu">模型</strong>定义为真实流程或系统的简化但有效的表示，旨在获得对其行为的一些理解。</p><p id="7233" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们还对模型进行了分类，特别区分了<strong class="lh iu">连续模型</strong>和<strong class="lh iu">离散模型</strong>，前者的行为(<strong class="lh iu">状态变量</strong>)随时间不断变化，后者的状态变量仅在单独的时间点发生变化。另一个重要的分类包括静态模型(T18)和动态模型(T20)，静态模型是系统在特定时间的代表，动态模型是随着时间的推移而发展的。</p><p id="b414" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">与上述分类相关的有三种不同类型的模拟:连续事件模拟、离散事件模拟和蒙特卡罗模拟。</p><p id="6d0a" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">关于<strong class="lh iu">离散事件模拟(DES) </strong>的原理和概念在前面指出的系列中提供。我们用<strong class="lh iu"> SimPy </strong>编写了几个例子，这是一个基于纯Python的面向对象、基于流程的离散事件模拟框架。在以后的文章中，我们将发展与连续事件模拟相关的概念和原则。</p><p id="1e70" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这篇文章中(可能在其他几篇文章中),我们正在处理蒙特卡罗模拟。</p><h1 id="af6e" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">蒙特卡罗方法</strong></h1><p id="9e50" class="pw-post-body-paragraph lf lg it lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc im bi translated">蒙特卡罗方法(<strong class="lh iu"> MCM </strong>)是一组用于解决数学问题的数值方法，其中<strong class="lh iu">随机样本</strong>的使用将它们与等效方法区分开来。</p><p id="c2d9" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这个术语是希腊裔美国物理学家尼古拉斯·米洛斯发明的，当时他正在洛斯阿拉莫斯国家实验室与T2·约翰·冯·诺依曼和T4·斯坦尼斯劳·乌拉姆一起研发第一颗原子弹。这个术语源自位于摩纳哥公国的<a class="ae le" href="https://en.wikipedia.org/wiki/Monte_Carlo_Casino" rel="noopener ugc nofollow" target="_blank">著名赌场</a>。</p><p id="8c54" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">MCM的概念思想在于通过从计算机中表示的模型中重复采样来估计某些量。两类数学问题通常用这些技术来解决:积分和优化。</p><p id="7a53" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">关于本系列文章中描述的内容，当我们提到蒙特卡罗模拟模型时，我们谈论的是试图解决优化问题的静态、离散、随机模型。</p><p id="ee70" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">从方法的角度来看，蒙特卡罗模拟是一种抽样实验，其目的是估计取决于一个或多个随机输入变量的感兴趣的量的分布。我们对计算这些量的点估计和置信区间特别感兴趣。不可避免地，我们的估计量会有抽样误差，我们的首要任务是确定重复次数，以提高估计值的确定性。</p><p id="7917" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们将通过库存模型中的一个经典例子来说明蒙特卡罗模拟:<strong class="lh iu">新闻供应商库存问题。</strong></p><h1 id="3149" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">报摊问题</strong></h1><p id="2e86" class="pw-post-body-paragraph lf lg it lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc im bi translated">这里的术语是从面临<strong class="lh iu">不确定需求的报纸销售商所面临的日常情况中创造出来的:</strong>在一天开始时有多少报纸可用，以便不至于短缺和失去销售，或者有剩余的报纸而不能在第二天出售(我希望数字本地人知道报纸是什么；以防万一这里有个<a class="ae le" href="https://en.wikipedia.org/wiki/Newspaper" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="1e6d" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">许多现实世界的系统类似于上述情况:零售店、飞机座位、时尚商品行业、制造系统。因此，通过解决报童问题获得的洞察力可能有助于在更有价值的商业环境中解决决策问题。</p><p id="96f2" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">问题的一般设置如下:有一个卖主，一个供应商，和客户。我们只考虑一个<strong class="lh iu">单周期的情况。</strong>在该阶段开始时，供应商有兴趣确定向供应商订购多少个产品(<em class="mi"> Q </em>)来满足客户需求。这个客户需求是随机的，用一个随机变量<em class="mi"> D </em>及其对应的概率密度函数<em class="mi"> f(D) </em>和累积分布函数<em class="mi"> F(D) </em>来表示。</p><p id="bac4" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">供应商完全知道以下值:购买成本；销售价格(<em class="mi">s</em>)；残值(<em class="mi"> u </em>)。残值是产品在使用寿命结束时的估计价值。典型的情况是销售价格高于购买成本，而购买成本又高于残值。</p><p id="0497" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">供应商必须考虑两种情况:1)订购数量大于日需求量(<em class="mi">Q&gt;D</em>)；2)订购数量等于或小于日需求(<em class="mi"> Q &lt; =D </em>)。在第一种情况下，<em class="mi"> Q — D </em>单位剩余，必须由卖方以低于售价的残值回收。在第二种情况下，<em class="mi"> D — Q </em>单位代表销售损失。</p><p id="65b4" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">因此，我们为卖方开发了以下利润等式:</p><p id="1b05" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="mi">利润=每次销售收入+每次回收收入-每次订单成本</em></p><p id="80ae" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在哪里</p><p id="4352" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="mi">Revenue _ per _ Sales = s * minimum(D，Q) </em></p><p id="ca1e" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Revenue_per_Salvage = u *。最大值(0，Q — D) </p><p id="9f25" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="mi">每订单成本= c * Q </em></p><p id="7ec9" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">所以，利润是<em class="mi"> Q </em> &amp; <em class="mi"> D </em>的函数。由于需求是随机变量，利润也是随机变量。为了确定向供应商订购多少单位，我们必须计算<strong class="lh iu">利润的最大期望值。</strong></p><p id="beeb" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这种计算可以使用蒙特卡罗方法以非常简单和有效的方式来完成。</p><h1 id="01f4" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">用Python进行蒙特卡洛模拟</strong></h1><p id="c99a" class="pw-post-body-paragraph lf lg it lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc im bi translated">在我们的示例中，供应商以15.50美元的价格购买产品，然后以27.00美元的价格出售。残值是2.50美元。</p><p id="9759" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下表显示了每日单位需求的分配情况:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/1a77293e1bb06213086f7d5dba30652b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*udJjCmHj7EQlxshmneZycA.png"/></div></figure><p id="da8a" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如前所述，首先我们必须确定样本中的观察值数量。</p><p id="b70d" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在<a class="ae le" href="https://medium.com/p/e27cd7b1ff47" rel="noopener">第5篇</a>中我们说过估计量的<strong class="lh iu">精度</strong>是指置信区间的半宽度(<strong class="lh iu"> HW </strong>)。它由以下等式描述:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/bae1c325349f1e33c2268fade278c21f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*AdudPz1RHNhccvkvyczjAQ.png"/></div></figure><p id="8e6e" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">其中n是样本数，<em class="mi"> tα/2，n1</em>是自由度为n<em class="mi">1</em>的t分布的上100(1-α/2)个百分点，而<em class="mi"> s </em>是样本标准偏差。</p><p id="bf44" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们希望在置信区间的半宽度值上建立一个<strong class="lh iu">界限</strong> (B)。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/104b5b2b575b64256f7f0932a1a35492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*aMABr23oQAvAfBxvXQXEIQ.png"/></div></figure><p id="c849" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">求解n的结果为:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/b90aa7e7cc65d7a0c903af3b2e4af029.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*5LyIH0D4fADMhvlxu53Acg.png"/></div></figure><p id="9553" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这是python代码，用于确定大小为n0= 100、界限为10.00、置信度为95%的导频样本的观测值数量。</p><pre class="kp kq kr ks gt mn mo mp mq aw mr bi"><span id="6348" class="ms jr it mo b gy mt mu l mv mw"><a class="ae le" href="http://twitter.com/author" rel="noopener ugc nofollow" target="_blank">@author</a>: darwt<br/>"""<br/># Import Modules<br/>import pandas as pd<br/>import numpy  as np</span><span id="344f" class="ms jr it mo b gy mx mu l mv mw">from scipy import stats<br/>from scipy.stats import uniform<br/>from scipy.stats import sem</span><span id="43b1" class="ms jr it mo b gy mx mu l mv mw">import matplotlib.pyplot as plt  <br/>your_path = 'C:/Users/darwt/desktop/'</span><span id="ae44" class="ms jr it mo b gy mx mu l mv mw">#...................................................................<br/># initialization module<br/> <br/>Price_Per_Unit   = 27.0<br/>Cost_Per_Unit    = 15.50<br/>Salvage_Per_Unit = 2.50</span><span id="5057" class="ms jr it mo b gy mx mu l mv mw">list_of_orders = [40]                 ## quantity ordered for the pilot run<br/>length = len(list_of_orders)</span><span id="9c87" class="ms jr it mo b gy mx mu l mv mw">bound = 10.0                           ## selected by the analyst <br/>confidence = 0.95                      ## selected by the analyst <br/># .........................................<br/># historical daily demand<br/>daily_demand = [5, 10, 40, 45, 50, 55, 60]</span><span id="ec7e" class="ms jr it mo b gy mx mu l mv mw"># discrete probabilities for daily demand<br/>pr1, pr2, pr3, pr4, pr5, pr6, pr7 = 0.1, 0.2, 0.3, 0.2, 0.1, 0.05, 0.05<br/> <br/>pr1 = round(pr1, 2)<br/>pr2 = round(pr1 + pr2,2)<br/>pr3 = round(pr2 + pr3,2)<br/>pr4 = round(pr3 + pr4,2)<br/>pr5 = round(pr4 + pr5,2)<br/>pr6 = round(pr5 + pr6,2)<br/>pr7 = round(pr6 + pr7,2)</span><span id="0f29" class="ms jr it mo b gy mx mu l mv mw">list_of_probs = [pr1, pr2, pr3, pr4, pr5, pr6, pr7]</span><span id="1b35" class="ms jr it mo b gy mx mu l mv mw">df1 = pd.DataFrame(daily_demand, columns = ['demand'])<br/>df2 = pd.DataFrame(list_of_probs,columns = ['range'])<br/> <br/>df_demand = pd.concat([df1, df2], axis = 1)</span><span id="3b19" class="ms jr it mo b gy mx mu l mv mw">#....<br/>Number_of_Replications = 100</span><span id="659a" class="ms jr it mo b gy mx mu l mv mw">for j in range(length):<br/>    list_of_profits = []<br/>    for run in range(Number_of_Replications):<br/>        # uniform distribution for a random variate<br/>        r_v = uniform.rvs(size=1)<br/>             <br/>        for i,row in df_demand.iterrows():<br/>            probab = df_demand.loc[i, 'range']<br/>             <br/>            if r_v &lt; probab:<br/>                Qty_Demand = df_demand.loc[i, 'demand']<br/>                break<br/>        <br/>        Qty_Ordered = 40   ##list_of_orders[j]<br/>        <br/>        Qty_Sold = np.minimum(Qty_Demand, Qty_Ordered)<br/>        Qty_Left = np.maximum(0, Qty_Ordered - Qty_Demand)<br/>         <br/>        Revenue_per_Sales = Qty_Sold * Price_Per_Unit        <br/>        Revenue_per_Salvage = Qty_Left * Salvage_Per_Unit        <br/>        Cost_per_Order =  Qty_Ordered * Cost_Per_Unit<br/>        <br/>        Profit = Revenue_per_Sales + <br/>                 Revenue_per_Salvage - Cost_per_Order        <br/>        list_of_profits.append(Profit)<br/>    <br/>    media = np.mean(list_of_profits)<br/>    stand = np.std(list_of_profits)<br/>                <br/>    dof  = Number_of_Replications - 1    <br/>    t_crit = np.abs(stats.t.ppf((1-confidence)/2,dof))</span><span id="5e58" class="ms jr it mo b gy mx mu l mv mw">numb_of_samples = int((stand *t_crit / bound) ** 2)<br/>print('')<br/>print(' The number of samples is %3s' %numb_of_samples)</span></pre><p id="f998" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在上面的代码中，特定的随机数流是不可重复的。我们进行了几次试运行，用最后一个方程计算的样本数在5000左右波动。所以，我们用这个数字进行生产。</p><p id="68eb" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">订单数量为20、30、40、45、50和60单位的新闻供应商问题的python代码如下:</p><pre class="kp kq kr ks gt mn mo mp mq aw mr bi"><span id="5ad9" class="ms jr it mo b gy mt mu l mv mw"><a class="ae le" href="http://twitter.com/author" rel="noopener ugc nofollow" target="_blank">@author</a>: darwt<br/>"""</span><span id="79e7" class="ms jr it mo b gy mx mu l mv mw"># Import Modules<br/>import pandas as pd<br/>import numpy  as np</span><span id="126c" class="ms jr it mo b gy mx mu l mv mw">from scipy import stats<br/>from scipy.stats import uniform<br/>from scipy.stats import sem</span><span id="7ea3" class="ms jr it mo b gy mx mu l mv mw">import matplotlib.pyplot as plt  <br/>your_path = 'C:/Users/darwt/desktop/'</span><span id="57c1" class="ms jr it mo b gy mx mu l mv mw">#...................................................................<br/># initialization module<br/> <br/>Price_Per_Unit   = 27.0<br/>Cost_Per_Unit    = 15.50<br/>Salvage_Per_Unit = 2.50</span><span id="e2e9" class="ms jr it mo b gy mx mu l mv mw">list_of_orders = [20,30,40,45,50,60]<br/>length = len(list_of_orders)</span><span id="b037" class="ms jr it mo b gy mx mu l mv mw">bound = 0.10                           ## selected by the analyst <br/>confidence = 0.95                      ## selected by the analyst <br/># .........................................<br/># historical daily demand<br/>daily_demand = [5, 10, 40, 45, 50, 55, 60]</span><span id="3c5e" class="ms jr it mo b gy mx mu l mv mw"># discrete probabilities for daily demand<br/>pr1, pr2, pr3, pr4, pr5, pr6, pr7 = 0.1, 0.2, 0.3, 0.2, 0.1, 0.05, 0.05<br/> <br/>pr1 = round(pr1, 2)<br/>pr2 = round(pr1 + pr2,2)<br/>pr3 = round(pr2 + pr3,2)<br/>pr4 = round(pr3 + pr4,2)<br/>pr5 = round(pr4 + pr5,2)<br/>pr6 = round(pr5 + pr6,2)<br/>pr7 = round(pr6 + pr7,2)</span><span id="0a45" class="ms jr it mo b gy mx mu l mv mw">list_of_probs = [pr1, pr2, pr3, pr4, pr5, pr6, pr7]</span><span id="2b48" class="ms jr it mo b gy mx mu l mv mw">df1 = pd.DataFrame(daily_demand, columns = ['demand'])<br/>df2 = pd.DataFrame(list_of_probs,columns = ['range'])<br/> <br/>df_demand = pd.concat([df1, df2], axis = 1)</span><span id="a838" class="ms jr it mo b gy mx mu l mv mw">column_labels = ["Order Quantity", "Mean","Std.Dev","Var.",<br/>                 "Std. Error","Median", "Skewness", "Kurtosis",<br/>                 "CI Half Width", "CI LL", 'CI UL']</span><span id="c4aa" class="ms jr it mo b gy mx mu l mv mw">df = pd.DataFrame(columns=column_labels)<br/># ...............................................<br/>Number_of_Replications = 5000</span><span id="ec43" class="ms jr it mo b gy mx mu l mv mw">for j in range(length):<br/>    list_of_profits = []<br/>    for run in range(Number_of_Replications):<br/>        # uniform distribution for a random variate<br/>        r_v = uniform.rvs(size=1)<br/>             <br/>        for i,row in df_demand.iterrows():<br/>            probab = df_demand.loc[i, 'range']<br/>             <br/>            if r_v &lt; probab:<br/>                Qty_Demand = df_demand.loc[i, 'demand']<br/>                break<br/>        <br/>        Qty_Ordered = list_of_orders[j]<br/>        <br/>        Qty_Sold = np.minimum(Qty_Demand, Qty_Ordered)<br/>        Qty_Left = np.maximum(0, Qty_Ordered - Qty_Demand)<br/>         <br/>        Revenue_per_Sales = Qty_Sold * Price_Per_Unit        <br/>        Revenue_per_Salvage = Qty_Left * Salvage_Per_Unit        <br/>        Cost_per_Order =  Qty_Ordered * Cost_Per_Unit<br/>        <br/>        Profit = Revenue_per_Sales +<br/>                 Revenue_per_Salvage - Cost_per_Order        <br/>        list_of_profits.append(Profit)<br/>    <br/>    media = np.mean(list_of_profits)<br/>    stand = np.std(list_of_profits)<br/>    var   = np.var(list_of_profits) <br/>    std_error = sem(list_of_profits)<br/>    <br/>    median = np.median(list_of_profits)<br/>    skew   = stats.skew(list_of_profits)<br/>    kurt   = stats.kurtosis(list_of_profits)<br/>    <br/>    dof  = Number_of_Replications - 1    <br/>    t_crit = np.abs(stats.t.ppf((1-confidence)/2,dof))<br/>    <br/>    half_width=round(stand*t_crit/np.sqrt(Number_of_Replications),2)  <br/>    inf = media - half_width<br/>    sup = media + half_width  <br/>                          <br/>    inf = round(float(inf),2)<br/>    sup = round(float(sup),2)    <br/>   <br/>    list_of_statistics = []<br/>    list_of_statistics.append(round(Qty_Ordered,2))<br/>    list_of_statistics.append(round(media,2))<br/>    list_of_statistics.append(round(stand,2))<br/>    list_of_statistics.append(round(var,2))<br/>    list_of_statistics.append(round(std_error,2))<br/>    <br/>    list_of_statistics.append(round(median,2))<br/>    list_of_statistics.append(round(skew,2))<br/>    list_of_statistics.append(round(kurt,2))<br/>    <br/>    list_of_statistics.append(round(half_width,2))<br/>    list_of_statistics.append(round(inf,2))<br/>    list_of_statistics.append(round(sup,2))<br/>    <br/>    df.loc[len(df)] = list_of_statistics<br/>    <br/>fig, ax = plt.subplots(1,1)<br/>ax.axis('tight')<br/>ax.axis('off')</span><span id="ccbd" class="ms jr it mo b gy mx mu l mv mw">runs_table = ax.table(cellText = df.values, <br/>                      colLabels = df.columns, <br/>                      rowLabels = df.index +1 ,<br/>                      rowColours =["skyblue"]*(length), <br/>                      colColours =["cyan"]*11, <br/>                      cellLoc='center', loc="center",<br/>                      bbox = [0.1, 0, 1.9, 1.0])<br/>ax.set_title("Monte Carlo Simulation: Profit Statistics vs Order Quantity", fontsize=18, y= 1.2 , pad = 4)</span><span id="5722" class="ms jr it mo b gy mx mu l mv mw">runs_table.auto_set_font_size(False)<br/>runs_table.set_fontsize(8)<br/>plt.savefig(your_path +'MonteCarlo.png',<br/>            bbox_inches='tight', dpi=150)                 <br/>plt.show()</span><span id="c195" class="ms jr it mo b gy mx mu l mv mw">x  = df['Order Quantity']<br/>y  = df['Mean']<br/>ci = df['CI Half Width']</span><span id="1919" class="ms jr it mo b gy mx mu l mv mw">fig, ax = plt.subplots()<br/>ax.plot(x,y)<br/>ax.fill_between(x, (y-ci), (y+ci), color='b', alpha=.1)<br/>fig.suptitle('Monte Carlo Simulation', fontsize=20)<br/>plt.xlabel('Order Quantity', fontsize=18)<br/>plt.ylabel('Profit (U$S)', fontsize=16)</span><span id="cf84" class="ms jr it mo b gy mx mu l mv mw">plt.savefig(your_path +'MonteCarlChart.png',<br/>            bbox_inches='tight', dpi=150)<br/>plt.show()</span></pre><p id="a652" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">表1总结了关键的描述性统计指标。利润的最大期望值对应于40个单位的订单数量。记住，偏斜度描述的是分布不对称的程度。我们的计算显示了适度的负偏态分布。另一方面，峰度指的是分布的峰值或平坦性。我们的计算表明，分布相对平坦，具有高度的分散性。对于我们的决策问题，我们的主点估计量的置信区间的半宽度是合理的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/16601805f2158462cccc878e93806ef2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*IkPEEi8C9w3DsE_VZOUr0Q.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">表1:由作者用Matplotlib制作</p></figure><p id="c93e" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">图1显示了20、30、40、45、50和60个单位的平均利润和相应的置信区间。可以看出，利润最大化的订货量对应Q = 40，产生的平均利润为230.09美元。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi my"><img src="../Images/6537a74f1c0e94cc16ba6adbf1a18883.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*yi7i4cEld4bigD1KyYGCYw.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图1:作者用Matplotlib制作的</p></figure><p id="5b07" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">前面的例子显示了蒙特卡罗模拟的本质:通过重复采样来估计随机输出变量的期望值的静态模拟。</p><p id="d361" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在以后的文章中，我们将继续详述MCMs的其他应用，特别是风险分析。</p><p id="6f54" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">不要忘记给作者小费，尤其是当你把这篇文章添加到列表中的时候。</p></div></div>    
</body>
</html>