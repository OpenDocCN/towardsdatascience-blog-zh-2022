<html>
<head>
<title>A Guide to Python Comprehensions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 理解指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-guide-to-python-comprehensions-4d16af68c97e#2022-12-01">https://towardsdatascience.com/a-guide-to-python-comprehensions-4d16af68c97e#2022-12-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="d860" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">PYTHON 编程</h2><div class=""/><div class=""><h2 id="f673" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">学习列表理解(listcomps)、集合理解(setcomps)、字典理解(dictcomps)甚至生成器表达式的复杂性</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/7615555c27a1ff41ebd4c48bbdfca663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4UYtQKl6AedP40we"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/es/@zuzi_ruttkay?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">祖扎娜·鲁特凯</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="2d6e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">理解可能是 Python 中最流行的语法糖。它们是如此强大，当我最终理解它们时，它们让我大吃一惊，从那以后我就一直喜欢使用它们。</p><p id="ea0f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">是的，你说得对。我第一次<em class="me">理解</em>理解，而不是<em class="me">看见</em>它们。这是因为，乍一看，它们似乎不那么可读。许多初学 Python 的人发现它们既不清晰也不容易理解。有些人可能更喜欢<code class="fe mf mg mh mi b">for</code>循环；<a class="ae lh" href="https://medium.com/towards-data-science/does-python-still-need-the-map-function-96787ea1fb05" rel="noopener">有些人可能更喜欢</a> <code class="fe mf mg mh mi b"><a class="ae lh" href="https://medium.com/towards-data-science/does-python-still-need-the-map-function-96787ea1fb05" rel="noopener">map()</a></code> <a class="ae lh" href="https://medium.com/towards-data-science/does-python-still-need-the-map-function-96787ea1fb05" rel="noopener">功能</a>；还有一些人可能更喜欢其他有用的东西——只是不喜欢理解。</p><p id="e407" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你也是其中一员，我希望这篇文章能让你相信理解在不同的情况下可以派上用场，有时比 Python 提供的任何其他工具都更具可读性。如果你不在其中，我希望这篇文章能帮助你更多地了解理解是如何工作的；这可以帮助你理解和创造简单和高级的理解。此外，我们将讨论理解的一个重要方面:当理解越过太难的界限时，在这种情况下你应该放弃使用它。有时候，为了做到这一点，您必须能够说服自己放弃某个特定的理解，这个理解是如此高级，以至于使用它可能会显示您是一个有经验的 Python 程序员。</p><p id="5207" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是因为在某些情况下，不同的工具可以做得更好。我们将深入挖掘理解的实用性，我希望你不仅能从这篇文章中学到东西，还能喜欢阅读它。我会试着写下你需要知道的关于他们的一切，但这并不意味着我会写下关于他们的一切。但是一旦你理解了他们的要点并想学习更多，你就有足够的知识去做。</p><p id="4f51" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，本文旨在解释什么是 Python 理解，以及如何和何时使用它们。它也提供了理解和使用它们的一些重要的复杂性。</p><p id="e16c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我还会介绍一个新名词，Python 的不解。虽然基于 Python 的通用代码库充满了理解和不理解，但你应该争取合理数量的前者，而不是后者。</p><h1 id="9044" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">理解入门</h1><p id="872c" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated">关于理解，我想让你理解的第一件事是单词<em class="me">理解</em>的意思。虽然我在学习 Python 理解之前已经知道这个词的意思很多年了，但是我没能把这个意思放到 Python 的上下文中。<a class="ae lh" href="https://dictionary.cambridge.org/dictionary/english/comprehension" rel="noopener ugc nofollow" target="_blank">剑桥词典</a>对<em class="me">理解</em>一词给出了如下定义:</p><blockquote class="ng nh ni"><p id="868a" class="li lj me lk b ll lm kd ln lo lp kg lq nj ls lt lu nk lw lx ly nl ma mb mc md im bi translated">完全理解和熟悉情况、事实的能力…</p></blockquote><p id="269b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，这是我想让你记住的事情——这正是 Python 理解所做的事情:它们帮助理解代码正在做的动作。所以，你可以用另一种方式做这个动作，但这个动作是通过理解来完成的，它有助于理解正在发生的事情。这对他们的作者和读者都有帮助。</p><p id="e31e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">尽管如此，要注意<a class="ae lh" href="https://dictionary.cambridge.org/dictionary/english/incomprehension" rel="noopener ugc nofollow" target="_blank"> <em class="me">不理解</em> </a>这个词，是<em class="me">理解</em>的反义词。虽然 Python 不提供<em class="me">不解</em>，但当我们过度理解并使其不可读时，它们就会变成<em class="me">不解。</em>下图介绍了<em class="me"> Python 不解</em>这个术语，就是一个 Python 的领悟变成了一个无法理解的东西；也就是说，与理解存在的目的相反的东西:帮助理解代码正在做的动作。相反，不理解使得理解代码要做什么变得困难。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/87f89f9273ef68298041750b065a1c48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E5CKcxjuftBo59CYUXuI2A.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">一句 Python 不解，意思是“<em class="nn">不要试图理解我！”</em>。图片作者。</p></figure><p id="e254" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将讨论如何让我们的理解变得可理解，而不是变得不可理解；如何<em class="me">不</em>把它们变成 Python 的不解；因此，反过来，如何使你的代码 Pythonic 化，简单易懂。</p><p id="bf94" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我将理解视为语法糖，使我能够使用更简洁的代码而不是不同的编码工具，如<code class="fe mf mg mh mi b">for</code>循环，来创建列表、字典、集合或生成器表达式。如你所见，你可以使用理解来创建四种不同类型的对象。在继续之前，让我们分析一个简单的例子，类似于您可能在许多其他资源中看到的例子。</p><p id="5915" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在第一个例子中，我将向您展示如何使用最简单的理解类型来创建一个列表、一个集合、一个生成器表达式和一个字典。稍后，我们将主要使用列表或字典，这取决于我们将要讨论的内容。生成器表达式虽然使用相同的语法-糖语法创建，但提供了完全不同的行为，所以我将把它们留到另一篇文章中，专门讨论它们以及它们与列表理解的比较。</p><p id="a4f7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="me">列表理解(又名列表组件)</em></p><p id="02d0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设在 Python 中没有理解，我们想做以下事情。我们有一个数值列表，比如说<code class="fe mf mg mh mi b">x</code>，我们想要创建一个包含平方值<code class="fe mf mg mh mi b">x</code>的列表。让我们开始吧:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="cd86" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; x = [1, 2, 3]<br/>&gt;&gt;&gt; x_squared = []<br/>&gt;&gt;&gt; for x_i in x:<br/>...     x_squared.append(x_i**2)<br/>&gt;&gt;&gt; x_squared<br/>[1, 4, 9]</span></pre><p id="18e8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在让我们回到现实:Python 确实提供了列表理解。我们可以用更短、更容易理解的代码达到同样的效果:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="f846" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; x = [1, 2, 3]<br/>&gt;&gt;&gt; x_squared = [x_i**2 for x_i in x]<br/>&gt;&gt;&gt; x_squared<br/>[1, 4, 9]</span></pre><p id="9551" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里的列表理解为<code class="fe mf mg mh mi b">[x_i**2 for x_i in x]</code>。可以这样读:对<code class="fe mf mg mh mi b">x</code>中的每个值计算<code class="fe mf mg mh mi b">x_i**2</code>，并以列表形式返回新值。</p><p id="07ac" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了比较两种方法的长度，让我来定义理解率:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="fb86" class="ns mk it mi b be nt nu l nv nw">n_for / n_comprehension</span></pre><p id="6fd9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">其中<code class="fe mf mg mh mi b">n_for</code>代表<code class="fe mf mg mh mi b">for</code>循环中的字符数，而<code class="fe mf mg mh mi b">n_comprehension</code>代表相应理解中的字符数。为了公平起见，我将只使用一个字符的名称。该比率可以用百分比表示。</p><p id="6182" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">理解率显示理解代码与<code class="fe mf mg mh mi b">for</code>循环相比有多短。警告:这只代表了故事的一个方面:理解的简洁。虽然对于某些示例来说，这种简洁是一件好事，但在其他一些示例中却不是，因为代码可能会变得太难理解。我们无论如何都会使用这个比率，这样你就可以知道与<code class="fe mf mg mh mi b">for</code>循环相比，理解的时间有多短。此外，有时另一个编码工具可以比<code class="fe mf mg mh mi b">for</code>循环做得更好，例如<a class="ae lh" rel="noopener" target="_blank" href="/does-python-still-need-the-map-function-96787ea1fb05"/><code class="fe mf mg mh mi b"><a class="ae lh" rel="noopener" target="_blank" href="/does-python-still-need-the-map-function-96787ea1fb05">map()</a></code><a class="ae lh" rel="noopener" target="_blank" href="/does-python-still-need-the-map-function-96787ea1fb05">函数</a>。</p><p id="57f5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这个简单的例子中，最初的<code class="fe mf mg mh mi b">for</code>循环需要 26 个字符(不含空格)；列表理解，15 个字符。为了说明这一点，我计算了以下文本中的字符:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="a001" class="ns mk it mi b be nt nu l nv nw">for loop:<br/>y=[]foriinx:y.append(i**2)<br/><br/>list comprehension:<br/>y=[i**2foriinx]</span></pre><p id="21c7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这个例子中，理解率是 173%。还不错！</p><p id="ebbb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="me">集合理解(又名集合组合)</em></p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="866c" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; x = [1, 2, 3]<br/>&gt;&gt;&gt; x_squared = set()<br/>&gt;&gt;&gt; for x_i in x:<br/>...     x_squared.add(x_i**2)<br/>&gt;&gt;&gt; x_squared<br/>{1, 4, 9}</span></pre><p id="d6cf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面是相应的集合理解:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="8280" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; x = [1, 2, 3]<br/>&gt;&gt;&gt; x_squared = {x_i**2 for x_i in i}<br/>&gt;&gt;&gt; x_squared<br/>{1, 4, 9}</span></pre><p id="541a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">理解率为 186%。</p><p id="e836" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="me">字典理解(又名字典理解，字典组合)</em></p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="4551" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; x = [1, 2, 3]<br/>&gt;&gt;&gt; x_squared = {}<br/>&gt;&gt;&gt; for x_i in x:<br/>...     x_squared[x_i] = x_i**2<br/>&gt;&gt;&gt; x_squared<br/>{1: 1, 2: 4, 3: 9}</span></pre><p id="1ec1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一句名言理解成了现在:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="ebe0" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; x = [1, 2, 3]<br/>&gt;&gt;&gt; x_squared = {x_i: x_i**2 for x_i in x}<br/>&gt;&gt;&gt; x_squared<br/>{1: 1, 2: 4, 3: 9}</span></pre><p id="3329" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它的理解率比 listcomps 和 setcomps 低，为 124%。</p><p id="1f2d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="me">生成器表达式</em></p><p id="08f9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可能想知道，术语<em class="me">生成器表达式</em>与理解有什么关系？应该是类似<em class="me">发电机领悟</em>的东西吧？</p><p id="7b42" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有效的观点。我想…我想可能是。对我来说，这很有意义。但我们就是这么叫的:<em class="me">生成器表达式</em>。它们在这里是因为生成器表达式是使用与其他理解相同的语法糖创建的，尽管它们的行为非常不同。我不会讨论这种行为上的差异，因为这个话题太重要了，不能藏在一篇关于理解的普通文章里。因此，我在这里只展示生成器表达式，并保证以后会写更多关于它们的内容。</p><p id="5df8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要创建一个生成器表达式，只需将 listcomp 代码放在方括号(<code class="fe mf mg mh mi b">[]</code>)内，并用括号(<code class="fe mf mg mh mi b">()</code>)括起来:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="ca80" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; x = [1, 2, 3]<br/>&gt;&gt;&gt; x_squared = (x_i**2 for x_i in x)</span></pre><p id="4994" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里，<code class="fe mf mg mh mi b">x_squared</code>是一个基于列表创建的生成器表达式。很容易看出，生成器表达式的理解率与相应的列表理解率相同。</p><h1 id="cc65" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">扩展理解</h1><p id="5a74" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated">上面的理解是最简单的，因为它们包含了对 iterable 的每个元素的操作。我说的<em class="me">操作</em>是指理解的这一部分:<code class="fe mf mg mh mi b">x_i**2</code>；不管我们还在对<code class="fe mf mg mh mi b">x_i</code>做什么——请看下图，它解释了什么是<em class="me">操作</em>。我们可以扩展这一部分，但不仅仅是这一部分；有很多扩展 Python 理解的可能性，这就是这个工具的强大之处。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/5c0f21fa61a59fa865c32bbacade361d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*ObYImbOE11HW01xgymsoYA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">列表理解的结构。图片作者。</p></figure><p id="e3e7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面的列表显示了我们如何扩展最简单的理解。我们可以使用</p><ul class=""><li id="c4bc" class="ny nz it lk b ll lm lo lp lr oa lv ob lz oc md od oe of og bi translated">操作中的一个或多个功能</li><li id="7928" class="ny nz it lk b ll oh lo oi lr oj lv ok lz ol md od oe of og bi translated">使用<code class="fe mf mg mh mi b">if</code>语句对原始数据进行一个或多个过滤</li><li id="7b2b" class="ny nz it lk b ll oh lo oi lr oj lv ok lz ol md od oe of og bi translated">操作输出的一个或多个过滤器，使用<code class="fe mf mg mh mi b">if</code>语句</li><li id="a261" class="ny nz it lk b ll oh lo oi lr oj lv ok lz ol md od oe of og bi translated">在操作中使用条件表达式，以对原始数据使用一个或多个过滤器；或者对操作的输出使用一个或多个过滤器</li><li id="9e3f" class="ny nz it lk b ll oh lo oi lr oj lv ok lz ol md od oe of og bi translated">使用高级循环</li><li id="4fee" class="ny nz it lk b ll oh lo oi lr oj lv ok lz ol md od oe of og bi translated">以上各项的组合</li></ul><p id="e50c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这就是事情变得复杂的地方，我们的任务是确保我们的理解不会变成不理解。在讨论原因之前，我们先来看一下上述场景的例子。分析每一个例子，如果可能的话，在你的 Python 解释器中运行它，特别是当你对 Python 理解还是新手的时候。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi om"><img src="../Images/aaf5925c14a2019d9966d47b3f34c388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xH6QGdiZkx0M-UOaXZK5BA.png"/></div></div></figure><p id="5371" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的分类旨在帮助你理解理解是如何工作的。这不是正式的，老实说，你甚至不需要记住它。我用它来告诉你理解是多么的不同和强大。所以，分析例子，理解它们，如果你认为它们能帮助你，试着记住它们。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi on"><img src="../Images/84df5d4ef8b1cb03651755dbbbd826f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*Hmjgga08e00oI6NQWIfEkg.png"/></div></figure><h2 id="cba7" class="oo mk it bd ml op oq dn mp or os dp mt lr ot ou mv lv ov ow mx lz ox oy mz iz bi translated">在操作中使用函数</h2><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="7ab1" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; def square(x):<br/>...     return x**2<br/>&gt;&gt;&gt; x = [1, 2, 3]<br/>&gt;&gt;&gt; x_squared_list = [square(x_i) for x_i in x]<br/>&gt;&gt;&gt; x_square_list<br/>[1, 4, 9]<br/>&gt;&gt;&gt; x_squared_dict = {x_i: square(x_i) for x_i in x}<br/>{1: 1, 2: 4, 3: 9}</span></pre><p id="273d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，将<code class="fe mf mg mh mi b">[square(x_i) for x_i in x]</code>理解为:为<code class="fe mf mg mh mi b">x</code>中的每个值计算<code class="fe mf mg mh mi b">square(x_i)</code>，并将结果作为列表返回。</p><p id="76b1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面，我们使用了一个函数。我们可以使用更多:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="88eb" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; def multiply(x, m):<br/>...     return x*m<br/>&gt;&gt;&gt; def square(x):<br/>...     return x**2<br/>&gt;&gt;&gt; x = [1, 2, 3]<br/>&gt;&gt;&gt; x_squared_list = [multiply(square(x_i), 3) for x_i in x]<br/>&gt;&gt;&gt; x_squared_dict = {x_i: multiply(square(x_i), 3) for x_i in x}<br/>&gt;&gt;&gt; x_square_list<br/>[3, 12, 27]<br/>&gt;&gt;&gt; x_squared_dict = {x_i: square(x_i) for x_i in x}<br/>{1: 3, 2: 12, 3: 27}</span></pre><p id="5838" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从现在开始，我将只列出理解。我希望在这一点上你知道不同类型的理解是如何工作的，所以没有必要一遍又一遍地重复它们，那样会弄乱代码。</p><h2 id="23fe" class="oo mk it bd ml op oq dn mp or os dp mt lr ot ou mv lv ov ow mx lz ox oy mz iz bi translated">过滤原始数据</h2><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="b3de" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; x = [1, 2, "a", 3, 5]<br/>&gt;&gt;&gt; integers = [x_i for x_i in x if isinstance(x_i, int)]<br/>&gt;&gt;&gt; integers<br/>[1, 2, 3, 5]</span></pre><p id="6691" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们从<code class="fe mf mg mh mi b">x</code>开始创建这个列表，只取整数(所以，当<code class="fe mf mg mh mi b">x_i</code>的类型是<code class="fe mf mg mh mi b">int</code>，也就是<code class="fe mf mg mh mi b">if isinstance(x_i, int)</code>)。</p><p id="6f4f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你看出这个版本和上一个版本有多相似了吗？是因为两者都使用了<code class="fe mf mg mh mi b">if</code>语句过滤原始数据；他们只是以稍微不同的方式做它。以前，我们将其添加到操作中；这里，我们在循环之后添加了它。</p><p id="1433" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个版本和以前的版本过滤原始数据，与我们将在下一点所做的相反，即过滤操作的结果。换句话说，在这里您可以通过首先过滤数据并对过滤的数据应用列表理解来达到同样的目的。在下面的版本中，您将首先使用 list comprehension，然后过滤其值。</p><h2 id="b0bf" class="oo mk it bd ml op oq dn mp or os dp mt lr ot ou mv lv ov ow mx lz ox oy mz iz bi translated">过滤操作的输出</h2><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="ce65" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; x = [1, 2, 3, 4, 5, 6]<br/>&gt;&gt;&gt; x_squared = [x_i**2 for x_i in x if x_i**2 % 2 == 0]</span></pre><p id="5dab" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里，我们只保留那些偶数的结果，拒绝奇数的结果。</p><p id="c5f2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意这段代码并不完美:我们两次运行相同的操作<em class="me"/>，第一次在操作中，然后在条件表达式中(以<code class="fe mf mg mh mi b">if</code>开始)。从 Python 3.8 开始，我们可以使用 walrus 操作符来改进这段代码:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="22f2" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; x = [1, 2, 3, 4, 5, 6]<br/>&gt;&gt;&gt; x_squared = [y for x_i in x if (y := x_i**2) % 2 == 0]</span></pre><p id="5665" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如您所见，walrus 操作符使我们能够在这个列表理解中节省一半的计算。这就是为什么，如果你想使用比最简单的更高级的理解，你应该和海象算子成为朋友。</p><p id="f1f7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了好玩和学习，我们可以使用<a class="ae lh" href="https://medium.com/towards-data-science/benchmarking-python-code-with-timeit-80827e131e48" rel="noopener"> timeit </a>来测试这两种理解，看看 walrus 操作符是否真的帮助我们提高了 listcomp 的性能。对于基准测试，我使用了下面的<em class="me">性能</em>部分中的代码，代码片段如下:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="e2c7" class="ns mk it mi b be nt nu l nv nw">setup = """x = list(range(1000))"""<br/>code_comprehension = """[x_i**2 for x_i in x if x_i**2 % 2 == 0]"""<br/>code_alternative = """[y for x_i in x if (y := x_i**2) % 2 == 0]"""</span></pre><p id="abb0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是我在我的机器上得到的(32 GB 内存，Windows 10，WSL 1):</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="aaa4" class="ns mk it mi b be nt nu l nv nw">Time for the comprehension : 26.3394<br/>Time for the alternative   : 31.1244<br/>comprehension-to-alternative ratio: 0.846</span></pre><p id="14e3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">显然，使用 walrus 操作符绝对是值得的——尽管性能增益没有达到人们预期和希望的 50%。一旦你知道这个操作符和这个版本的理解是如何工作的，你就可以使代码不仅性能更好，而且更容易理解。</p><p id="933f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个理解比前几个稍微难读一点，虽然意思也一样简单:为<code class="fe mf mg mh mi b">x</code>中的每个值计算<code class="fe mf mg mh mi b">x_i**2</code>，拒绝输出(<code class="fe mf mg mh mi b">x_i**2</code>)的所有偶数值；以列表形式返回结果。</p><p id="3c54" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如你所看到的，你需要理解错综复杂的理解来阅读这一篇，但是一旦它们对你不构成问题，这样的理解就变得容易阅读了。然而，正如你稍后会看到的，有些理解一点也不容易读懂…</p><h2 id="589f" class="oo mk it bd ml op oq dn mp or os dp mt lr ot ou mv lv ov ow mx lz ox oy mz iz bi translated">在运算中使用条件表达式过滤数据</h2><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="0a8b" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; x = [1, 2, "a", 3, 5]<br/>&gt;&gt;&gt; res = [x_i**2 if isinstance(x_i, int) else x_i for x_i in x]<br/>&gt;&gt;&gt; res<br/>[1, 4, 'a', 9, 25]</span></pre><p id="6e18" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个列表理解应该这样理解:对于<code class="fe mf mg mh mi b">x</code>中的每一个值，使用以下算法:当它是整数时，求平方；否则不要碰它；将结果收集到列表中。</p><p id="aacb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个版本非常类似于数据过滤；事实上，它是一种特定类型的数据过滤，是作为操作内部(而不是外部)的条件表达式(<code class="fe mf mg mh mi b">x if condition else y</code>)来实现的。老实说，你可以使用上面介绍的数据过滤很容易地重写这个列表理解。为了避免混淆，我不会在这里展示它。但是你可以认为这是一个很好的练习:在操作之外，也就是在理解循环之后，使用数据过滤重写这个理解。</p><p id="5c37" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="me">注释</em>:参见下一小节中的注释块，了解什么时候可以使用条件表达式，什么时候最好避免使用。</p><h2 id="df75" class="oo mk it bd ml op oq dn mp or os dp mt lr ot ou mv lv ov ow mx lz ox oy mz iz bi translated">在运算中使用条件表达式过滤结果</h2><p id="0113" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated">上面的 listcomp 过滤了数据；我们还可以使用条件表达式来过滤操作的结果，如下所示:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="1ec9" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; x = [1, 2, 70, 3, 5]<br/>&gt;&gt;&gt; res = [y if (y := x_i**2) &lt; 10 else 10 for x_i in x]<br/>&gt;&gt;&gt; res<br/>[1, 4, 10, 9, 10]</span></pre><p id="36fd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了避免两次使用相同的计算，我们再次使用了 walrus 运算符，如下所示:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="77c7" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; res = [x_i**2 if x_i**2 &lt; 10 else 10 for x_i in x]</span></pre><p id="1d61" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然这个版本不是<em class="me">不正确的</em>(特别是对于 Python 3.7 和更早的版本)，但它不是高性能的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi om"><img src="../Images/aaf5925c14a2019d9966d47b3f34c388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xH6QGdiZkx0M-UOaXZK5BA.png"/></div></div></figure><p id="c825" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于在操作码中添加了条件表达式，所以当条件较短时，它会很有用。否则会弄乱操作码。在这种情况下，最好使用常规过滤，在理解循环之后出现<code class="fe mf mg mh mi b">if</code>条件。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi om"><img src="../Images/b8397a4f4b1c870e04ae5c6a57b955a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Y2kUU4KKM-rvvnaAfLN5g.png"/></div></div></figure><h2 id="bb3b" class="oo mk it bd ml op oq dn mp or os dp mt lr ot ou mv lv ov ow mx lz ox oy mz iz bi translated">使用高级循环</h2><p id="7c08" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated">你不必像我们到目前为止所做的那样，只使用简单的循环。例如，我们可以在理解循环中使用<code class="fe mf mg mh mi b">enumerate()</code>，就像在<code class="fe mf mg mh mi b">for</code>循环中一样:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="9cca" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; texts = ["whateveR! ", "\n\tZulugula RULES!\n", ]<br/>&gt;&gt;&gt; d = {i: txt for i, txt in enumerate(texts)}<br/>&gt;&gt;&gt; d<br/>{1: "whateveR! ", 2: "\n\tZulugula RULES!\n"}</span></pre><p id="bd87" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，让我们遍历一下<code class="fe mf mg mh mi b">d</code>字典的键值对:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="51f8" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; [(k, v.lower().strip()) for k, v in d.items()]<br/>[(1, 'whatever!'), (2, 'zulugula rules!')]</span></pre><p id="6cb4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">基本上，你可以使用任何可以在<code class="fe mf mg mh mi b">for</code>循环中工作的方法。</p><h2 id="9bcf" class="oo mk it bd ml op oq dn mp or os dp mt lr ot ou mv lv ov ow mx lz ox oy mz iz bi translated">上述场景的组合</h2><p id="1cc5" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated">上述情景是基本的，通常你不需要考虑这样的理解是否太难；他们不是。然而，情况可能会变得更加困难，尤其是当它包含不止一个正义的操作或过滤时；换句话说，当它结合了上述场景(包括在一次理解中使用同一个场景两次甚至更多次)。</p><p id="6922" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你听说过 Python 的理解会变得太复杂，那你一定没听错。这就是为什么你可以经常读到你不应该过度使用理解；这也是事实。这就是我提出术语<em class="me">不理解</em>的原因。你应该<em class="me">绝对</em>避免在你的 Python 代码中使用不理解。</p><p id="548c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们考虑几个例子，这样你就可以自己看到理解会变得困难。虽然不是所有的例子都太复杂——但有些肯定会。</p><p id="5a31" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">考虑这个 listcomp，它结合了过滤数据和过滤输出:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="0a51" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; x = range(50)<br/>&gt;&gt;&gt; [y for x_i in x if x_i % 4!= 0 if (y := x_i**2) % 2 == 0]<br/>[4, 36, 100, 196, 324, 484, 676, 900, 1156, 1444, 1764, 2116]</span></pre><p id="f59f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">看看我们在这里做了什么:计算所有能被 4 整除的<code class="fe mf mg mh mi b">x</code>值的<code class="fe mf mg mh mi b">x_i**2</code>，并且只取那些能被 2 整除的结果输出值。</p><p id="4f87" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里我们有两个<code class="fe mf mg mh mi b">if</code>条件。在这种情况下，我们可以通过使用<code class="fe mf mg mh mi b">and</code>连接两个条件来简化理解:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="b56e" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; [y for x_i in x if x_i % 4!= 0 and (y := x_i**2) % 2 == 0]<br/>[4, 36, 100, 196, 324, 484, 676, 900, 1156, 1444, 1764, 2116]</span></pre><p id="6568" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">老实说，对我来说，两个<code class="fe mf mg mh mi b">if</code>块中的两个条件似乎比一个<code class="fe mf mg mh mi b">if</code>块中的两个条件用<code class="fe mf mg mh mi b">and</code>操作符连接起来更容易理解。如果你不同意，那么如果你认为<code class="fe mf mg mh mi b">and</code>有助于增加可读性，请在评论中分享。这个<em class="me">在某种程度上是一个主观的问题，所以我不期望你们所有人都同意我。</em></p><p id="ed0a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不管你对使用<code class="fe mf mg mh mi b">and</code>有什么想法，我们可以通过将它分成几行来提高这种理解的可读性，每一行代表一个块，该块表示<em class="me">意味着某些事情</em>和/或<em class="me">做某些事情</em>:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="20e9" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; [y for x_i in x<br/>...  if x_i % 4 != 0<br/>...  and (y := x_i**2) % 2 == 0]<br/>[4, 36, 100, 196, 324, 484, 676, 900, 1156, 1444, 1764, 2116]</span></pre><p id="8210" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">或者</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="dc12" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; [<br/>...     y for x_i in x<br/>...     if x_i % 4 != 0<br/>...     and (y := x_i**2) % 2 == 0<br/>... ]<br/>[4, 36, 100, 196, 324, 484, 676, 900, 1156, 1444, 1764, 2116]</span></pre><p id="795d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以至</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="9836" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; [<br/>...     y<br/>...     for x_i in x<br/>...     if x_i % 4 != 0<br/>...     and (y := x_i**2) % 2 == 0<br/>... ]<br/>[4, 36, 100, 196, 324, 484, 676, 900, 1156, 1444, 1764, 2116]</span></pre><p id="ea1f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当我们在第一行应用一个或多个函数时，最后一个版本更有用，所以这一行比一个名字要长，就像这里。</p><p id="57b6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如我提到的，两个<code class="fe mf mg mh mi b">if</code>块对我来说更具可读性:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="d704" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; [<br/>...     y for x_i in x<br/>...     if x_i % 4 != 0<br/>...     if (y := x_i**2) % 2 == 0<br/>... ]<br/>[4, 36, 100, 196, 324, 484, 676, 900, 1156, 1444, 1764, 2116]</span></pre><p id="17a8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个版本中我特别喜欢的是左边<code class="fe mf mg mh mi b">if</code>积木的视觉对称性。你看到了吗？如果没有，返回到前面的代码块，并注意这两部分的区别:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="2441" class="ns mk it mi b be nt nu l nv nw">...     if x_i % 4 != 0<br/>...     if (y := x_i**2) % 2 == 0</span></pre><p id="7552" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这一部分:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="4d1f" class="ns mk it mi b be nt nu l nv nw">...     if x_i % 4 != 0<br/>...     and (y := x_i**2) % 2 == 0</span></pre><p id="20a4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然这些方面不太重要，但至少对我来说是有帮助的。我的意思是，当我在做一个更长的理解时，我会把它们考虑进去——我想建议你也把这些方面考虑进去。首先，信不信由你，这给了我乐趣。第二，当你确实注意到你理解的这些小方面时，你会觉得你非常了解它们；你会觉得他们已经(或者还没有，当他们没有准备好的时候)准备好了，完成了，完整了。</p><p id="3bcb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种理解并没有那么难，是吗？所以，让我们把情况变得更复杂一点，从而理解列表:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="5019" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; [<br/>...     y for x_i in x<br/>...     if x_i % 4 != 0 and x_i % 5 != 0<br/>...     if (y := square(multiply(x_i, 3))) % 2 == 0<br/>... ]<br/>[36, 324, 1764, 2916, 4356, 6084, 10404, 12996, 15876, 19044]</span></pre><p id="e251" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个<em class="me">比</em>更复杂，但是我认为从这个角度来说，即使是这个理解也是非常可读的。然而，随着越来越多的条件被加入，它会变得越来越复杂——最终，在某一点上，越过了太复杂的界限。</p><h1 id="bec9" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">备选方案和示例</h1><p id="e61d" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated">正如我已经写的，有时候一个<code class="fe mf mg mh mi b">for</code>循环比理解更具可读性。然而，还有更多选择，比如<code class="fe mf mg mh mi b">map()</code>和<code class="fe mf mg mh mi b">filter()</code>功能。你可以在本文的<a class="ae lh" href="https://medium.com/towards-data-science/does-python-still-need-the-map-function-96787ea1fb05" rel="noopener">中阅读更多关于<code class="fe mf mg mh mi b">map()</code>的内容，在这篇文章中，我解释了为什么了解这个函数的工作原理是有好处的，以及它何时可能是比理解更好的解决方案。</a></p><p id="c98d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这些函数甚至比相应的理解更快，所以每当性能很重要时，你可能希望检查基于<code class="fe mf mg mh mi b">map()</code>和<code class="fe mf mg mh mi b">filter()</code>的代码是否比你使用的理解更好。</p><p id="8a6e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在简单的场景中，理解通常更好；在复杂的情况下，情况不一定如此。最好用例子来说明这一点。因此，下面我展示了几个理解的例子(包括生成器表达式)和相应的替代解决方案。</p><p id="3d82" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="me">例 1。</em><code class="fe mf mg mh mi b">map()</code>函数代替了简单的生成器表达式。</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="00c8" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; x = range(100)<br/>&gt;&gt;&gt; gen = (square(x_i) for x_i in x)<br/>&gt;&gt;&gt; other = map(square, x)</span></pre><p id="01db" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这种情况下，这两个版本对我来说似乎同样可读，但理解看起来更熟悉。<code class="fe mf mg mh mi b">map()</code>函数是一个抽象:你需要知道它是如何工作的，哪个参数必须先去(callable ),哪个参数必须后去(iterable)。</p><p id="e2a9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不像<code class="fe mf mg mh mi b">map()</code>，在我看来，简单的理解，就像上面这个，看起来并不抽象。我可以直接阅读它们，从左到右写:我正在将函数<code class="fe mf mg mh mi b">square()</code>应用到<code class="fe mf mg mh mi b">x_i</code>，而<code class="fe mf mg mh mi b">x_i</code>是<code class="fe mf mg mh mi b">x</code>的后续元素；我将结果存储在一个<code class="fe mf mg mh mi b">generator</code>对象中。</p><p id="4fd3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">听起来很容易，但是我知道要阅读这样的理解(是的，我确实是这样读的！)，你需要知道这个特定的 Python 语法糖。这就是为什么对于高级(甚至中级)Python 程序员来说，这个生成器表达式(以及其他类似的简单理解)看起来很简单，但是对于初级 Python 开发人员来说，它们很少看起来简单。所以，理解也可以是抽象的。然而，我们很快就会看到，这种语法比它的直接替代方法要清晰得多。</p><p id="f520" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当您在<code class="fe mf mg mh mi b">map()</code>中使用<code class="fe mf mg mh mi b">lambda </code>函数时，<code class="fe mf mg mh mi b">map()</code>函数的使用变得不那么清晰。比较:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="ccab" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; x = range(100)<br/>&gt;&gt;&gt; gen = (x_i**2 for x_i in x)<br/>&gt;&gt;&gt; other = map(lambda x_i: x_**2, x)</span></pre><p id="c969" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然<code class="fe mf mg mh mi b">lambda</code>在 Python 中确实有它们的位置并且非常有用，但是在某些情况下它们会降低可读性——这就是这样的情况。在这里，比起<code class="fe mf mg mh mi b">map()</code>版本，我更喜欢生成器表达式。</p><p id="d78a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="me">例 2 </em>:使用<code class="fe mf mg mh mi b">filter()</code>函数代替带有<code class="fe mf mg mh mi b">if</code>块的生成器表达式进行数据过滤。</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="0b9d" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; x = range(100)<br/>&gt;&gt;&gt; gen = (x_i for x_i in x if x_i % 5 == 0)<br/>&gt;&gt;&gt; other = filter(lambda x_i: x_i % 5 == 0, x)</span></pre><p id="1a23" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以上所有关于<code class="fe mf mg mh mi b">map()</code>的注释都适用于<code class="fe mf mg mh mi b">filter()</code>功能。和<code class="fe mf mg mh mi b">map()</code>一样，可以带(像这里)也可以不带<code class="fe mf mg mh mi b">lambda</code>使用。这里，我还是更喜欢发电机的说法。</p><p id="bda8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="me">例 3 </em>:结合<code class="fe mf mg mh mi b">map()</code>和<code class="fe mf mg mh mi b">filter()</code>代替使用函数处理元素和<code class="fe mf mg mh mi b">if</code>块过滤数据的生成器表达式。</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="857f" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; x = range(100)<br/>&gt;&gt;&gt; gen = (square(x_i) for x_i in x if x_i % 5 == 0)<br/>&gt;&gt;&gt; other = map(square, filter(lambda x_i: x_i % 5 == 0, x))</span></pre><p id="3128" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以分两步完成同样的操作:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="edb0" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; x_filtered = filter(lambda x_i: x_i % 5 == 0, x)<br/>&gt;&gt;&gt; other = map(square, x_filtered)</span></pre><p id="88d7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是结合<code class="fe mf mg mh mi b">map()</code>和<code class="fe mf mg mh mi b">filter()</code>功能来处理和过滤数据的情况之一。但这也是我需要一些时间来理解这段代码在做什么的情况之一，同时能够几乎立即理解相应的理解(这里是一个生成器表达式)。在这里，我肯定会选择生成器表达式版本。</p><p id="8eef" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="me">例 4: </em>用<code class="fe mf mg mh mi b">map()</code>带包装器功能代替字典理解。</p><p id="e624" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">字典理解使得创建字典非常简单。考虑这个例子:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="2116" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; def square(x):<br/>...     return x**2<br/>&gt;&gt;&gt; y = {x: square(x) for x in range(5)}<br/>&gt;&gt;&gt; y<br/>{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}</span></pre><p id="d5ae" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这看起来很简单，不是吗？现在尝试使用<code class="fe mf mg mh mi b">map()</code>达到同样的效果。</p><p id="71c2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">问题是你需要创建键值对，所以，如果我们想用<code class="fe mf mg mh mi b">map()</code>，函数返回输出是不够的；它也需要返回密钥。一个好的解决方案是在<code class="fe mf mg mh mi b">square()</code>周围使用一个包装函数:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="e15a" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; def wrapper_square(x):<br/>...     return x, square(x)<br/>&gt;&gt;&gt; y = dict(map(wrapper_square, range(5)))<br/>&gt;&gt;&gt; y<br/>{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}</span></pre><p id="591c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你同意上面的字典理解比这个基于 T6 的版本可读性更好，更容易写，更容易读吗？这里，<code class="fe mf mg mh mi b">for</code>循环比<code class="fe mf mg mh mi b">map()</code>版本更容易理解:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="07b7" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; y = {}<br/>&gt;&gt;&gt; for x in range(5):<br/>...     y[x] = square(x)<br/>&gt;&gt;&gt; y<br/>{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}</span></pre><p id="2041" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="me">例 5 </em>:一个<code class="fe mf mg mh mi b">for</code>循环，用于过滤数据和过滤输出。</p><p id="d809" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们回到我们实现了一个相当复杂的 listcomp 的例子:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="817b" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; [<br/>...     y for x_i in x<br/>...     if x_i % 4 != 0 and x_i % 5 != 0<br/>...     if (y := square(multiply(x_i, 3))) % 2 == 0<br/>... ]<br/>[36, 324, 1764, 2916, 4356, 6084, 10404, 12996, 15876, 19044]</span></pre><p id="94f6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">相应的<code class="fe mf mg mh mi b">for</code>循环如下所示:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="dfc5" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; output = []<br/>&gt;&gt;&gt; for x_i in x:<br/>...     y = square(multiply(x_i, 3))<br/>...     if y % 2 == 0 and x_i % 4 != 0 and x_i % 5 != 0:<br/>...         output.append(y)<br/>&gt;&gt;&gt; output<br/>[36, 324, 1764, 2916, 4356, 6084, 10404, 12996, 15876, 19044]</span></pre><p id="4f57" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">实际上，没那么糟。我认为这是一种边缘情况，有些人仍然会选择 listcomp 版本，而其他人会认为它不可读，而选择<code class="fe mf mg mh mi b">for</code>循环。对我来说，listcomp 仍然很好，但我很确定对一些人来说，它已经越过了太难的界限。</p><p id="67a1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="me">例 6 </em>:拆分 listcomp。</p><p id="344f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们用和上面完全一样的例子。让我们试着做一些我不太喜欢的事情；也就是说，让我们将这个复杂的理解分成几个部分，希望这样可以简化代码:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="e72d" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; y_1 = [x_i for x_i in x]<br/>&gt;&gt;&gt; y_2 = [<br/>...     y_1_i<br/>...     for y_1_i in y_1<br/>...     if y_1_i % 4 != 0 and y_1_i% 5 != 0<br/>... ]<br/>&gt;&gt;&gt; y = [<br/>...     y_final<br/>...     for y_2_i in y_2<br/>...     if (y_final := square(multiply(y_2_i, 3))) % 2 == 0<br/>... ]<br/>&gt;&gt;&gt; y<br/>[36, 324, 1764, 2916, 4356, 6084, 10404, 12996, 15876, 19044]</span></pre><p id="40ce" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">尽管进行了拆分，但在我看来，这个版本甚至比之前的版本可读性更差。它不仅长得多；对我来说，它的可读性也更差。我不会选择这个，但是我想给你看一下，以防你想知道这样的方法是否可行。这一次，不会了。</p><p id="75d4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="me">例 7 </em>:使用函数简化运算和过滤。</p><p id="5ef0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有时，您可以通过将一些要完成的工作导出到外部函数来简化理解。在我们的例子中，我们可以通过操作和过滤器来实现:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="9a1c" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; def filter_data(x_i):<br/>...     return x_i % 4 != 0 and x_i % 5 != 0<br/>&gt;&gt;&gt; def filter_output(y_i):<br/>...     return y_i % 2 == 0<br/>&gt;&gt;&gt; def pipeline(x_i):<br/>...     return square(multiply(x_i, 3))<br/>&gt;&gt;&gt; def get_generator(x):<br/>...     return (<br/>...         y for x_i in x<br/>...         if filter_output(y := pipeline(x_i))<br/>...         and filter_data(x_i)<br/>..      )<br/>&gt;&gt;&gt; list(get_generator(x))<br/>[36, 324, 1764, 2916, 4356, 6084, 10404, 12996, 15876, 19044]</span></pre><p id="80f9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我认为这使得理解更容易阅读。然而，我们可以用<code class="fe mf mg mh mi b">for</code>循环做同样的事情:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="c488" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; output = []<br/>&gt;&gt;&gt; for x_i in x:<br/>...     y = pipeline(x_i)<br/>...     if filter_output(y) and filter_data(x_i):<br/>...         output.append(y)<br/>&gt;&gt;&gt; output<br/>[36, 324, 1764, 2916, 4356, 6084, 10404, 12996, 15876, 19044]</span></pre><p id="b277" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是这个<code class="fe mf mg mh mi b">for</code>循环比下面对应的生成器好吗(从上面的片段复制过来的)？</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="db90" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; (<br/>...     y for x_i in x<br/>...     if filter_output(y := pipeline(x_i))<br/>...     and filter_data(x_i)<br/>... )</span></pre><p id="e3ed" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我会选择 listcomp。它更简洁，看起来可读性更强，至少对我来说是这样。</p><h1 id="17f0" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">命名</h1><p id="64c9" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated">这是一个提到命名的好时机。再看一遍以上理解中使用的函数名:<code class="fe mf mg mh mi b">filter_data</code>、<code class="fe mf mg mh mi b">filter_output</code>和<code class="fe mf mg mh mi b">pipeline</code>。这些都是清楚的名字，这些名字告诉他们该负责什么；这样，他们应该帮助我们理解在理解中发生了什么。</p><p id="2751" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">也许有些人会说它们不是函数的好选择，因为理解应该很短，而更短的函数名将有助于我们写出更简洁的理解。他们只有一点是对的:理解会更简洁。但是写<em class="me">简短的</em>理解并不意味着写<em class="me">好的因为可读的</em>理解。将上面的理解与下面的进行比较，在下面的理解中，我使用了更短但同时意义更小的名称:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="5690" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; def fd(x_i):<br/>...     return x_i % 4 != 0 and x_i % 5 != 0<br/>&gt;&gt;&gt; def fo(y_i):<br/>...     return y_i % 2 == 0<br/>&gt;&gt;&gt; def pi(x_i):<br/>...     return square(multiply(x_i, 3))<br/>&gt;&gt;&gt; def g_g(x):<br/>...     return (y for x_i in x if fo(y := pi(x_i)) and fd(x_i))<br/>&gt;&gt;&gt; list(get_generator(x))<br/>[36, 324, 1764, 2916, 4356, 6084, 10404, 12996, 15876, 19044]</span></pre><p id="466f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">肯定更短——也肯定更糟。</p><p id="db69" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意，虽然这样理解的作者会知道<code class="fe mf mg mh mi b">fd</code>代表<code class="fe mf mg mh mi b">filter_data</code>而<code class="fe mf mg mh mi b">pi</code>代表<code class="fe mf mg mh mi b">pipeline</code>，但是其他人会知道吗？一个月后作者还会记得吗？还是一年？我不这么认为。因此，这是一个糟糕的命名，它没有函数所负责的真正含义，并且它的秘密代码(<code class="fe mf mg mh mi b">fo</code>代表<code class="fe mf mg mh mi b">filter_output</code>)将很快被遗忘。</p><p id="c133" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你决定在理解中使用外部函数，一定要记住使用好的名字——好的含义<em class="me">简短而有意义的</em>。这同样适用于理解中使用的所有名称。然而，在这里，我们应该使用尽可能短的名字，而不是更长。有一个不成文的规则，当一个变量有一个狭窄的范围，它不需要一个长名字。虽然这条规则并不总是合理的，但在理解中它往往是合理的。例如，考虑这些列表组合:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="0f9e" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; y = [square(x_i) for x_i in x if x_i % 2 == 0]<br/>&gt;&gt;&gt; y = [square(xi) for xi in x if xi % 2 == 0]<br/>&gt;&gt;&gt; y = [square(p) for p in x if p% 2 == 0]<br/>&gt;&gt;&gt; y = [square(element_of_x) for element_of_x in x if element_of_x % 2 == 0]</span></pre><p id="d64c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">前两个对我来说几乎一样好，尽管我会选择第一个。这是因为<code class="fe mf mg mh mi b">x_i</code>看起来像带下标<code class="fe mf mg mh mi b">i</code>的<code class="fe mf mg mh mi b">x</code>；<code class="fe mf mg mh mi b">xi</code>看起来不是那样。所以，我准备用额外的<code class="fe mf mg mh mi b">_</code>字符来连接<code class="fe mf mg mh mi b">x</code>和<code class="fe mf mg mh mi b">i</code>，来表达这个额外的意思。这样，<code class="fe mf mg mh mi b">x_i</code>在数学上看起来有点像<code class="fe mf mg mh mi b">x_i</code>，意味着<code class="fe mf mg mh mi b">x_i</code>属于<code class="fe mf mg mh mi b">x</code>。虽然<code class="fe mf mg mh mi b">xi</code>版本看起来非常相似，但它错过了数学方程的这种良好的相似性。因此我选择了前者。</p><p id="dd1b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我不喜欢第三个版本。为什么使用<code class="fe mf mg mh mi b">p</code>作为循环变量的名称？<code class="fe mf mg mh mi b">p</code>是什么意思？如果从我们实现的算法的角度来看，这意味着什么，那很好。但除此之外，就不好了。基本上，使用有意义的名字是好的——但是记住在理解中，你应该使用有意义的<em class="me">简称。</em></p><blockquote class="oz"><p id="7651" class="pa pb it bd pc pd pe pf pg ph pi md dk translated">在理解中，你应该使用有意义的简短名字。</p></blockquote><p id="bc18" class="pw-post-body-paragraph li lj it lk b ll pj kd ln lo pk kg lq lr pl lt lu lv pm lx ly lz pn mb mc md im bi translated">这也是我不喜欢第四版的原因。虽然名称<code class="fe mf mg mh mi b">element_of_x</code>确实具有正确的含义，但该名称不必要太长。不要用长名字，因为短名字同样能提供信息。这里的情况是:<code class="fe mf mg mh mi b">x_i</code>比<code class="fe mf mg mh mi b">element_of_x</code>短得多，至少和<code class="fe mf mg mh mi b">element_of_x</code>一样信息量大，如果不是更多的话——这要归功于<code class="fe mf mg mh mi b">x_i</code>与数学方程式的共鸣。</p><p id="c36c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">还有一件事。当<em class="me">不</em>使用循环变量时，使用<code class="fe mf mg mh mi b">_</code>作为其名称。例如:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="e742" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; template = [(0, 0) for _ in range(10)]</span></pre><p id="9afe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里不需要使用<code class="fe mf mg mh mi b">i</code>或任何我们想要的东西。</p><h1 id="d3e5" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">太复杂还是还没？</h1><p id="7962" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated">随着时间和经验的积累，你会发现有时候很难决定一个特定的理解是否仍然可以理解，或者是否已经达到了太难的界限。如果你不知所措，选择<code class="fe mf mg mh mi b">for</code>循环会更安全，因为几乎每个人都能理解它——虽然不是每个人都能理解复杂的列表组件。</p><p id="c439" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，请记住，要尽可能使理解变得简单。例如，我们通过将一些或所有的计算转移到命名良好的外部函数来实现(在上面的例子中，这些函数是<code class="fe mf mg mh mi b">pipeline()</code>、<code class="fe mf mg mh mi b">filter_data()</code>和<code class="fe mf mg mh mi b">filter_output()</code>)。但是，不要过度使用这种方法，因为它比纯粹的理解更罗嗦。更重要的是，定义只在代码中使用一次的函数并不是一个好主意。</p><p id="c080" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">关键是，任何时候你写了一个看起来复杂的理解，你应该分析它，并决定它是否足够容易理解。如果没有，用不同的方法替换它。有时基于函数组合的生成器管道可能是一个很好的解决方案，正如这里提出的<a class="ae lh" href="https://medium.com/towards-data-science/building-generator-pipelines-in-python-8931535792ff" rel="noopener"/>。</p><p id="e369" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">决定哪个理解太复杂并不总是容易的。操作的数量不一定是一个好的指标，因为有时长的理解可能比短的理解更容易理解，这取决于它的目标和使用的命名。</p><p id="e02d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">还有一点需要记住的是，一个难理解的意思是<em class="me">对一般开发者来说很难</em>，对你来说并不难。所以，如果你写了一篇非常复杂的理解文章，而且你理解起来没有问题，这并不意味着你应该去做。这可能是你理解它的原因，因为你花了三个小时写了这几行代码！因此，记住要让你的理解——就此而言，还有代码——对其他人来说也是可理解的。</p><h1 id="a784" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">变量作用域</h1><p id="182c" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated">变量作用域在理解中的工作方式使它们不同于<code class="fe mf mg mh mi b">for</code>循环——不同之处在于:<em class="me">理解中使用的循环变量在理解的外部作用域中不可见，也不会覆盖外部作用域中的变量</em>。</p><p id="2444" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">用一个例子来解释会更容易些:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="1c79" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; x = [i**2 for i in range(10)]<br/>&gt;&gt;&gt; x<br/>[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]<br/>&gt;&gt;&gt; i<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>NameError: name 'i' is not defined</span></pre><p id="e894" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你看到发生了什么吗？虽然我们在列表理解中使用了<code class="fe mf mg mh mi b">i</code>作为循环变量，但是它只在这个理解的范围内有效。在这个范围之外它是不可见的——一旦理解完成了列表的创建，它就被删除了。</p><blockquote class="oz"><p id="2e4c" class="pa pb it bd pc pd pe pf pg ph pi md dk translated"><em class="nn">理解中使用的循环变量在理解的外部作用域中不可见，也不会覆盖外部作用域中的变量</em>。</p></blockquote><p id="ebda" class="pw-post-body-paragraph li lj it lk b ll pj kd ln lo pk kg lq lr pl lt lu lv pm lx ly lz pn mb mc md im bi translated">这还不是全部。如下面的代码片段所示，即使在外部作用域中使用了同名的变量，也可以在理解中使用名称。所以，会同时出现两个不同的同名对象！但是这些名称只在它们的作用域中可见。</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="901d" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; i = "this is i"<br/>&gt;&gt;&gt; x = [i**2 for i in range(10)]<br/>&gt;&gt;&gt; x<br/>[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]<br/>&gt;&gt;&gt; i<br/>'this is i'</span></pre><p id="6c60" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当然，如果循环变量有相同的名字，你不能在理解中使用外作用域变量。换句话说，您无法从使用内部作用域<code class="fe mf mg mh mi b">i</code>变量进行循环(或任何其他操作)的列表理解内部访问外部作用域<code class="fe mf mg mh mi b">i</code>。</p><p id="a7e6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="me">警告</em>:记住这条规则不适用于使用<a class="ae lh" rel="noopener" target="_blank" href="/the-walrus-operator-in-python-a315e4f84583">walrus 运算符</a>赋值的变量:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="83e7" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; i = "this is i"<br/>&gt;&gt;&gt; x = [i for j in range(10) if (i := j**2) &lt; 10]<br/>&gt;&gt;&gt; x<br/>[0, 1, 4, 9]<br/>&gt;&gt;&gt; i<br/>81</span></pre><p id="648e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如您所见，使用 walrus 操作符将赋值变量(这里是<code class="fe mf mg mh mi b">i</code>)放在理解的外部范围内。</p><p id="fcd5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">再警告一次。不要过度使用这个特性，因为生成的代码会变得难以阅读，如下所示:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="cd62" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; x = range(10)<br/>&gt;&gt;&gt; x = [x**2 for x in range(10)]<br/>&gt;&gt;&gt; x<br/>[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span></pre><p id="2044" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这太过分了。</p><p id="fc4c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种处理变量范围的方法使得使用理解变得安全，因为你不必担心理解的循环变量会覆盖一个重要的变量。如上所述，这是<em class="me">而不是</em>循环如何工作:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="ff4d" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; i = "this is i"<br/>&gt;&gt;&gt; for i in range(3):<br/>...     print(i)<br/>...<br/>0<br/>1<br/>2<br/>&gt;&gt;&gt; i<br/>2</span></pre><p id="92aa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如你所见，如果你在一个<code class="fe mf mg mh mi b">for</code>循环中使用相同的名字，在外部作用域中以相同方式命名的变量将被循环变量的当前值覆盖；最终用它的最后一个值。</p><h1 id="ee1f" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">表演</h1><p id="20a8" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated">许多开发人员在决定使用语法糖时考虑的一个方面是性能。有人说没那么重要；也有人说是。</p><p id="a41c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我的意见介于两者之间。请不要嘲笑我，但是我认为性能很重要，当…当性能很重要的时候。当它不存在时，不需要考虑它。</p><blockquote class="oz"><p id="7303" class="pa pb it bd pc pd pe pf pg ph pi md dk translated">当…当性能很重要时，性能很重要。</p></blockquote><p id="1038" class="pw-post-body-paragraph li lj it lk b ll pj kd ln lo pk kg lq lr pl lt lu lv pm lx ly lz pn mb mc md im bi translated">即使这听起来有点滑稽，如果不是愚蠢的，这是完全有道理的。如果您的应用程序是否快速并不重要，那么您为什么要担心性能呢？在这种情况下，最好使用其他因素来选择编码风格，比如简洁和可读性。然而，当性能很重要时，尤其是当性能很重要时(例如，在仪表板中)，您可以牺牲可读性来优化代码。</p><p id="9ab5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一件重要的事情是开发时间。如果这很重要，那么也许你不应该花整整两天的时间来优化代码，这样可以节省两秒钟的应用程序执行时间。</p><p id="1925" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好了，现在我们知道了什么时候考虑性能，让我们讨论性能理解是什么。一般来说，性能很大程度上取决于数据和理解本身，所以如果性能对特定的理解很重要，你应该对这种理解进行基准测试(如果可能的话)。</p><p id="718a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这里，我将向您展示如何使用内置的<code class="fe mf mg mh mi b"><a class="ae lh" href="https://docs.python.org/3/library/timeit.html" rel="noopener ugc nofollow" target="_blank">timeit</a></code>模块来执行这样的基准测试。你可以从这篇介绍性文章中了解更多。您可以使用下面的片段作为模板，来进行您自己的基准测试。然而，在不久的将来，我将写另一篇文章，专门讨论这类基准测试。它们将被设计成能让我们对理解的表现得出深刻的结论。</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="9687" class="ns mk it mi b be nt nu l nv nw"># benchmark_comprehension.py<br/>import timeit<br/><br/><br/>def benchmark(code_comprehension: str,<br/>              code_alternative: str,<br/>              setup: str,<br/>              n: int,<br/>              rep: int) -&gt; None:<br/>    t_comprehension = timeit.repeat(<br/>        code_comprehension,<br/>        setup=setup,<br/>        number=n,<br/>        repeat=rep<br/>    )<br/>    t_alternative = timeit.repeat(<br/>        code_alternative,<br/>        setup=setup,<br/>        number=n,<br/>        repeat=rep<br/>   )<br/>    print(<br/>        "Time for the comprehension :"<br/>        f" {round(min(t_comprehension), 4)}"<br/>        "\nTime for the  alternative : "<br/>        f"{round(min(t_alternative), 4)}"<br/>        "\ncomprehension-to-alternative ratio: "<br/>        f"{round(min(t_comprehension)/min(t_alternative), 3)}"<br/>    )<br/><br/># timeit settings<br/>n = 100<br/>rep = 7<br/><br/># code<br/>setup = """pass"""<br/>code_comprehension = """<br/>for _ in [x**2 for x in range(1_000_000)]:<br/>    pass<br/>"""<br/>code_alternative = """<br/>for _ in map(lambda x: x**2, range(1_000_000)):<br/>    pass<br/>"""<br/><br/>if __name__ == "__main__":<br/>    benchmark(code_comprehension, code_alternative, setup, n, rep)</span></pre><p id="c11e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了运行这段代码，使用下面的 shell 命令(在 Windows 和 Linux 中都有效):</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="c35c" class="ns mk it mi b be nt nu l nv nw">$ python benchmark_comprehension.py</span></pre><p id="9b62" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这将运行基准并将结果打印到控制台。例如，这个在我的机器上提供了以下输出:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="6d7f" class="ns mk it mi b be nt nu l nv nw">Time for the comprehension : 20.3807<br/>Time for the alternative   : 19.9166<br/>comprehension-to-alternative ratio: 1.023</span></pre><p id="80d2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以更改代码片段的以下部分:</p><ul class=""><li id="aec9" class="ny nz it lk b ll lm lo lp lr oa lv ob lz oc md od oe of og bi translated">设置代码→改变<code class="fe mf mg mh mi b">setup</code>；这是在运行基准代码之前<em class="me">运行的代码。</em></li><li id="f0c6" class="ny nz it lk b ll oh lo oi lr oj lv ok lz ol md od oe of og bi translated">代码→改变<code class="fe mf mg mh mi b">code_comprehension</code>和<code class="fe mf mg mh mi b">code_alternative</code>；注意代码是用三重引号写的，所以你可以把它拆分成更多的行；但是，您也可以使用一行程序。</li><li id="93f1" class="ny nz it lk b ll oh lo oi lr oj lv ok lz ol md od oe of og bi translated">传递到<code class="fe mf mg mh mi b">timeit.repeat()</code>的重复次数→改变<code class="fe mf mg mh mi b">rep</code>。</li><li id="bff5" class="ny nz it lk b ll oh lo oi lr oj lv ok lz ol md od oe of og bi translated">运行代码的次数，传递到<code class="fe mf mg mh mi b">timeit.repeat()</code> →改变<code class="fe mf mg mh mi b">n</code>。</li></ul><p id="79db" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">(如果您不确定<code class="fe mf mg mh mi b">number</code>和<code class="fe mf mg mh mi b">repeat</code>参数在<code class="fe mf mg mh mi b">timeit.repeat()</code>中是如何工作的，您将在<a class="ae lh" rel="noopener" target="_blank" href="/benchmarking-python-code-with-timeit-80827e131e48">这篇文章</a>中找到这一点以及更多内容。)</p><p id="362c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我使代码尽可能简单，这就是为什么我没有使用命令行参数；只是一个简单的基准测试应用程序。当然，你可以随心所欲地改进它。</p><h2 id="bc99" class="oo mk it bd ml op oq dn mp or os dp mt lr ot ou mv lv ov ow mx lz ox oy mz iz bi translated">我们应该根据什么来衡量理解？</h2><p id="3af4" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated">这可能是我们在进行此类基准测试之前需要问的最重要的问题。明显但不令人满意的答案是，反对最佳对应方法；它不能令人满意，因为它没有真正回答问题。让我们考虑一下。</p><ul class=""><li id="205c" class="ny nz it lk b ll lm lo lp lr oa lv ob lz oc md od oe of og bi translated"><em class="me">生成器表达式</em></li></ul><p id="0496" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">很容易决定我们应该对哪些生成器表达式进行基准测试:<code class="fe mf mg mh mi b">map()</code>和<code class="fe mf mg mh mi b">filter()</code>和/或它们的组合，或者反对任何其他返回生成器的方法。这两个函数分别返回<code class="fe mf mg mh mi b">map</code>和<code class="fe mf mg mh mi b">filter</code>对象，它们是生成器，就像生成器表达式一样。</p><ul class=""><li id="5a34" class="ny nz it lk b ll lm lo lp lr oa lv ob lz oc md od oe of og bi translated">列举理解</li></ul><p id="bf57" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个显而易见的比较方法是<code class="fe mf mg mh mi b">for</code>循环。我们需要记住，在简单的场景中，列表理解将比相应的<code class="fe mf mg mh mi b">for</code>循环更具可读性；然而，在复杂的场景中，通常情况相反。</p><p id="2296" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一种方法是使用<code class="fe mf mg mh mi b">map()</code>和/或<code class="fe mf mg mh mi b">filter()</code>，随后使用<code class="fe mf mg mh mi b">list()</code>。然而，在这种情况下，请注意这不是一个自然的比较，因为当您需要一个列表时，您使用的是列表理解，而不是生成器理解。</p><ul class=""><li id="19e6" class="ny nz it lk b ll lm lo lp lr oa lv ob lz oc md od oe of og bi translated"><em class="me">词典释义</em></li></ul><p id="7a6c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">像上面一样，我们有两个最自然的版本:<code class="fe mf mg mh mi b">for</code>循环和<code class="fe mf mg mh mi b">map()</code>和/或<code class="fe mf mg mh mi b">filter()</code>函数。然而，这次使用这两个函数有点棘手，因为我们需要使用键值对，所以函数也必须返回它们。我已经在上面展示了如何使用包装函数来实现这一点。然而，事实是，在这方面，字典理解在这里更容易使用。</p><ul class=""><li id="7879" class="ny nz it lk b ll lm lo lp lr oa lv ob lz oc md od oe of og bi translated"><em class="me">集合理解</em></li></ul><p id="defd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于集合，情况几乎和列表一样，所以使用上面的建议。</p><h2 id="1889" class="oo mk it bd ml op oq dn mp or os dp mt lr ot ou mv lv ov ow mx lz ox oy mz iz bi translated">一些基准</h2><p id="34f9" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated">如前所述，我们甚至不会试图在这里分析理解的表现，因为对于它们是否比它们的替代品更有表现的问题，没有一个简单的答案。答案取决于上下文。然而，我想在使用理解的这个方面给你们一些启发——至少向你们展示一些基础。</p><p id="a9d8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在下面的例子中，我将提供</p><ul class=""><li id="de06" class="ny nz it lk b ll lm lo lp lr oa lv ob lz oc md od oe of og bi translated">分别作为<code class="fe mf mg mh mi b">number</code>和<code class="fe mf mg mh mi b">repeat</code>传递给<code class="fe mf mg mh mi b">timeit.repeat()</code>的参数<code class="fe mf mg mh mi b">n</code>和<code class="fe mf mg mh mi b">rep</code>；</li><li id="4e41" class="ny nz it lk b ll oh lo oi lr oj lv ok lz ol md od oe of og bi translated">上面提供的基准测试代码片段中的<code class="fe mf mg mh mi b">setup</code>、<code class="fe mf mg mh mi b">code_comprehension</code>和<code class="fe mf mg mh mi b">code_alternative</code>；和</li><li id="39a9" class="ny nz it lk b ll oh lo oi lr oj lv ok lz ol md od oe of og bi translated">输出，如前面提供的示例中的格式。</li></ul><p id="32f4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="me">基准 1 </em></p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="f5ba" class="ns mk it mi b be nt nu l nv nw">n = 1_000_000<br/>rep = 7<br/><br/># code<br/>length = 10<br/>setup = """pass"""<br/>code_comprehension = f"""y = [x**2 for x in range({length})]"""<br/>code_alternative = f"""<br/>y = []<br/>for x_i in range({length}):<br/>    y.append(x_i**2)<br/>"""</span></pre><pre class="po no mi np bn nq nr bi"><span id="be6c" class="ns mk it mi b be nt nu l nv nw">Time for the comprehension : 1.6318<br/>Time for the  alternative : 1.7296<br/>comprehension-to-alternative ratio: 0.943</span></pre><p id="0c69" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe mf mg mh mi b">length = 100</code>(对于<code class="fe mf mg mh mi b">100</code>元素列表也是如此)和<code class="fe mf mg mh mi b">n = 100_000</code>的结果:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="8ee4" class="ns mk it mi b be nt nu l nv nw">Time for the comprehension : 1.4767<br/>Time for the  alternative : 1.6281<br/>comprehension-to-alternative ratio: 0.907</span></pre><p id="9e09" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在对于<code class="fe mf mg mh mi b">length = 1000</code>(【T4 元素】列表)和<code class="fe mf mg mh mi b">n = 10_000</code>:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="ced5" class="ns mk it mi b be nt nu l nv nw">Time for the comprehension : 1.5612<br/>Time for the  alternative : 1.907<br/>comprehension-to-alternative ratio: 0.819</span></pre><p id="88ec" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，对于<code class="fe mf mg mh mi b">length = 10_000</code>(<code class="fe mf mg mh mi b">10_000 </code>元素列表)和<code class="fe mf mg mh mi b">n = 1000</code>:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="5ecd" class="ns mk it mi b be nt nu l nv nw">Time for the comprehension : 1.5692<br/>Time for the  alternative : 1.9641<br/>comprehension-to-alternative ratio: 0.799</span></pre><p id="0e0b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在输出中，要查看的最重要的元素是比率，因为它是无单位的，而前两行中的时间不是，这取决于<code class="fe mf mg mh mi b">number</code>(在我们的例子中是<code class="fe mf mg mh mi b">n</code>)。如您所见，构造的列表的长度有所不同:列表越长，<code class="fe mf mg mh mi b">for</code>循环相对越慢。</p><p id="94dd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="me">基准 2 </em></p><p id="9349" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将定义一个函数<code class="fe mf mg mh mi b">length(x: Any) -&gt; int</code>，它</p><ul class=""><li id="b0d4" class="ny nz it lk b ll lm lo lp lr oa lv ob lz oc md od oe of og bi translated">当<code class="fe mf mg mh mi b">x</code>为空可迭代或<code class="fe mf mg mh mi b">None</code>时返回<code class="fe mf mg mh mi b">0</code>；</li><li id="e9b4" class="ny nz it lk b ll oh lo oi lr oj lv ok lz ol md od oe of og bi translated">返回可以确定的对象的长度；和</li><li id="1223" class="ny nz it lk b ll oh lo oi lr oj lv ok lz ol md od oe of og bi translated">否则返回<code class="fe mf mg mh mi b">1</code>。</li></ul><p id="6881" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，例如，一个数字的长度为<code class="fe mf mg mh mi b">1</code>。我们将使用这个函数创建一个字典</p><ul class=""><li id="aeeb" class="ny nz it lk b ll lm lo lp lr oa lv ob lz oc md od oe of og bi translated">键是来自 iterable 的值；和</li><li id="f2bd" class="ny nz it lk b ll oh lo oi lr oj lv ok lz ol md od oe of og bi translated">如上所述，值是对象长度的元组；以及 iterable <code class="fe mf mg mh mi b">x</code>中该元素的计数。</li></ul><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="f153" class="ns mk it mi b be nt nu l nv nw">setup = """<br/>def length(x):<br/>    if not x:<br/>        return 0<br/>    try:<br/>        return len(x)<br/>    except:<br/>        return 1<br/><br/>x = [1, 1, (1, 2, 3), 2, "x", "x", 1, 2, 1.1,<br/>     "x", 66, "y", 34, 34, "44", 690.222, "bubugugu", "44"]<br/>"""<br/>code_comprehension = """<br/>y = {el: (length(el), x.count(el)) for el in set(x)}<br/>"""<br/>code_alternative = """<br/>y = {}<br/>for el in set(x):<br/>    y[el] = (length(el), x.count(el))<br/>"""</span></pre><pre class="po no mi np bn nq nr bi"><span id="44af" class="ns mk it mi b be nt nu l nv nw">Time for the comprehension : 0.5727<br/>Time for the  alternative : 0.5736<br/>comprehension-to-alternative ratio: 0.998</span></pre><p id="1419" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当我们制作由 100 个<code class="fe mf mg mh mi b">x</code>列表组成的<code class="fe mf mg mh mi b">x</code>时，我们得到了<code class="fe mf mg mh mi b">comprehension-to-alternative ratio: 1.009</code>。正如我们所看到的，在这种情况下，列表的长度并不重要:两种方法都具有相同的性能——尽管 dict comprehension 要短得多，也很优雅，但是我认为您需要了解 Python comprehensions 才能理解它们。</p><blockquote class="oz"><p id="557e" class="pa pb it bd pc pd pe pf pg ph pi md dk translated">你需要了解 Python 的理解才能欣赏它们。</p></blockquote><h1 id="6c2b" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki pp kj mv kl pq km mx ko pr kp mz na bi translated">需要的时候使用理解</h1><p id="4581" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated">这可能看起来很奇怪，但是即使你不需要结果对象，使用理解也是很有诱惑力的。这是一个例子:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="677e" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; def get_int_and_float(x):<br/>...     [print(i) for i in x]<br/>...     return [i for i in x if isinstance(i, (int, float))]<br/>&gt;&gt;&gt; y = get_int_and_float([1, 4, "snake", 5.56, "water"])<br/>1<br/>4<br/>snake<br/>5.56<br/>water<br/>&gt;&gt;&gt; y<br/>[1, 4, 5.56]</span></pre><p id="93df" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意这个函数的作用:它接受一个 iterable 并过滤数据，通过删除那些不属于<code class="fe mf mg mh mi b">int</code>和<code class="fe mf mg mh mi b">float</code>类型的数据。我们在<code class="fe mf mg mh mi b">return</code>行中看到的列表理解的这种用法很好。尽管如此，我们还可以看到函数中使用的另一个列表理解:<code class="fe mf mg mh mi b">[print(i) for i in x]</code>。这个列表只理解<em class="me">打印</em>所有的条目，结果列表既不被存储也不被使用。那么，它是为了什么而创造的呢？我们需要它吗？当然不是。我们应该使用一个<code class="fe mf mg mh mi b">for</code>循环来代替:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="c542" class="ns mk it mi b be nt nu l nv nw">&gt;&gt;&gt; def get_int_and_float(x):<br/>...     for i in x:<br/>...         print(i)<br/>...     return [i for i in x if isinstance(i, (int, float))]<br/>&gt;&gt;&gt; y = get_int_and_float([1, 4, "snake", 5.56, "water"])<br/>1<br/>4<br/>snake<br/>5.56<br/>water<br/>&gt;&gt;&gt; y<br/>[1, 4, 5.56]</span></pre><p id="3fa3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这个例子中，<code class="fe mf mg mh mi b">for</code>循环是一种自然的方法。</p><p id="1952" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是一个非常简单的例子，可能看起来有点太简单了。那么，让我们考虑另一个例子。想象一个从文件中读取文本，以某种方式处理文本，并将输出(处理后的文本)写入另一个文件的函数:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="04ad" class="ns mk it mi b be nt nu l nv nw">import pathlib<br/><br/>def process_text_from(input_path: pathlib.Path<br/>                      output_path: pathlib.Path) -&gt; None:<br/>    # text is read from input_path, as string;<br/>    # it is then processed somehow;<br/>    # the resulting processed_text object (also string)<br/>    # is written to an output file (output_path)<br/><br/>def make_output_path(path: pathlib.Path):<br/>    return path.parent / path.name.replace(".", "_out.")</span></pre><p id="8750" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">重要提示:注意<code class="fe mf mg mh mi b">process_text_from()</code>函数不返回任何东西。</p><p id="b0f4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，我们需要实现一个函数，它为路径的 iterable 的每个元素运行<code class="fe mf mg mh mi b">process_text_from()</code>，<code class="fe mf mg mh mi b">input_paths</code>:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="8acb" class="ns mk it mi b be nt nu l nv nw">from typing import List<br/><br/>def process_texts(input_paths: List[pathlib.Path]) -&gt; None:<br/>    [process_text_from(p, make_output_path(p)) for p in input_paths]</span></pre><p id="c05e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">同样，这是<em class="me">而不是</em>一个全功能的列表理解:我们创建一个既不存储也不使用的列表。如果你看到这样的东西，这是一个暗示，你不应该使用理解。想另一种方法。</p><p id="d056" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里，再一次，一个<code class="fe mf mg mh mi b">for</code>循环似乎是最好的选择:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="996c" class="ns mk it mi b be nt nu l nv nw">def process_texts(input_paths: List[pathlib.Path]) -&gt; None:<br/>    for p in input_paths:<br/>        process_text_from(p, make_output_path(p))</span></pre><h1 id="6395" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">结论</h1><p id="b974" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated">Python 简单易读，或者至少这是我们被告知的——这也是大多数 python 爱好者对它的看法。简单性和可读性至少部分源于语言提供的语法优势。也许这种句法糖最重要的元素是理解。</p><p id="7897" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我把理解和优雅联系在一起。它们使我们能够编写简洁易读的代码——以及优雅的代码。有时代码很复杂，但通常很简单——至少对那些了解 Python 的人来说是这样。这就是为什么 Python 初学者理解理解有问题，从而欣赏它们；这就是为什么他们一有机会就开始学习。</p><blockquote class="oz"><p id="0e73" class="pa pb it bd pc pd pe pf pg ph pi md dk translated">我把理解和优雅联系在一起。它们使我们能够编写简洁易读的代码——以及优雅的代码。</p></blockquote><p id="4c2c" class="pw-post-body-paragraph li lj it lk b ll pj kd ln lo pk kg lq lr pl lt lu lv pm lx ly lz pn mb mc md im bi translated">这是个好主意，因为理解在 Python 代码中随处可见。我无法想象一个不写理解的中级 Python 开发人员，更不用说高级 Python 开发人员了。它们对 Python 来说是如此自然，以至于没有理解就没有 Python。至少我不能——也不想——想象没有它们的 Python。</p><p id="dc0b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">本文旨在介绍 Python 的理解:列表、字典和集合理解；和生成器表达式。最后一种类型与其他类型完全不同，所以这可能是它的名字如此不同的原因。生成器表达式的语法与其他类型的语法相似，但它们生成生成器。因此，他们应该有自己的文章，我很快就要写了。</p><p id="4139" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里有一个总结，以及几个关于理解的附加想法:</p><ol class=""><li id="8124" class="ny nz it lk b ll lm lo lp lr oa lv ob lz oc md ps oe of og bi translated">使用理解来帮助用户理解代码负责什么。</li><li id="b77b" class="ny nz it lk b ll oh lo oi lr oj lv ok lz ol md ps oe of og bi translated">当你需要创建一个列表时，使用列表理解，而不是不同类型的理解。同理，当你需要创建一个特定类型的对象时，使用相应的 list comprehension: dictcomp 用于字典，setcomp 用于集合，generator expression 用于生成器。</li><li id="276f" class="ny nz it lk b ll oh lo oi lr oj lv ok lz ol md ps oe of og bi translated">有时候，使用一个特别复杂的理解可能很有诱惑力。一些人屈服于这种诱惑，希望通过这种方式，他们可以证明他们可以编写复杂和高级的 Python 代码。不惜任何代价抵制这样的诱惑。而不是炫耀，写清楚代码；当理解不清楚时，无论如何都要抵制住把它保留在代码中的诱惑。永远不要把你的理解变成不理解，就像永远不要放弃可读性一样。</li><li id="3bd7" class="ny nz it lk b ll oh lo oi lr oj lv ok lz ol md ps oe of og bi translated">当你看到理解变得比可读性更复杂时，是时候考虑简化代码了——要么通过简化理解代码，要么通过使用替代解决方案。也许更好的名字会有用？或者把理解拆分成几行？或者，如果你已经这样做了，也许你可以尝试改变这种分裂？如果没有效果，请尝试不同的解决方案。有时一个<code class="fe mf mg mh mi b">for</code>循环会工作得最好；有时候是别的东西。</li><li id="5a91" class="ny nz it lk b ll oh lo oi lr oj lv ok lz ol md ps oe of og bi translated">如果你选择使用理解力，即使你知道它太难了，要知道大多数高级程序员会认为你想炫耀。我知道这有多诱人！我陷入这种诱惑的次数比我愿意承认的要多。如果你意识到这个问题，并努力克服它，随着时间和经验的积累，你会发现它更容易抵挡诱惑。</li><li id="2992" class="ny nz it lk b ll oh lo oi lr oj lv ok lz ol md ps oe of og bi translated">在某些情况下，你可以用一个<a class="ae lh" rel="noopener" target="_blank" href="/building-generator-pipelines-in-python-8931535792ff">生成器管道</a>来代替一个过于复杂的理解；在这种情况下，你会显示出对 Python 编程相当<em class="me">深刻</em>的理解，不像前一种情况。</li><li id="a9c3" class="ny nz it lk b ll oh lo oi lr oj lv ok lz ol md ps oe of og bi translated">记住理解范围是如何工作的。为你的目的使用它——但是不要过度使用它。</li><li id="9ee4" class="ny nz it lk b ll oh lo oi lr oj lv ok lz ol md ps oe of og bi translated">在理解的时候，注意它的每一个细节。这包括你是否把它分成更多的行；要拆分的行数，以及如何拆分；是用<code class="fe mf mg mh mi b">if</code>还是<code class="fe mf mg mh mi b">and</code>；理解是否看起来视觉上很好；等等。考虑你理解中的每一个微小的细节可以帮助你更好地理解它们。</li><li id="9659" class="ny nz it lk b ll oh lo oi lr oj lv ok lz ol md ps oe of og bi translated">命名很重要，有几个原因:理解是简洁的，因此是微妙的，一个错误可能会弄糟整个理解；它们通常承担很多责任，比如应用一个或多个函数，过滤数据和/或输出，循环遍历一个 iterable 他们需要使用至少一个局部范围的变量(也就是说，一个被<em class="me">限制</em>在理解范围内的变量)。因此，在理解内部和外部如何命名对象是有区别的。使用下面的建议来命名理解中的变量:<em class="me">使用简短且有意义的名字</em>。</li><li id="87a7" class="ny nz it lk b ll oh lo oi lr oj lv ok lz ol md ps oe of og bi translated">当你不需要结果对象时，不要使用理解。</li></ol><blockquote class="oz"><p id="a45f" class="pa pb it bd pc pd pt pu pv pw px md dk translated">永远不要把你的理解变成不理解，就像永远不要放弃可读性一样。</p></blockquote><h1 id="6780" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki pp kj mv kl pq km mx ko pr kp mz na bi translated">资源</h1><div class="py pz gp gr qa qb"><a rel="noopener follow" target="_blank" href="/does-python-still-need-the-map-function-96787ea1fb05"><div class="qc ab fo"><div class="qd ab qe cl cj qf"><h2 class="bd jd gy z fp qg fr fs qh fu fw jc bi translated">Python 还需要 map()函数吗？</h2><div class="qi l"><h3 class="bd b gy z fp qg fr fs qh fu fw dk translated">有了各种备选方案，Python 的 map()似乎就显得多余了。那么，Python 到底需不需要呢？</h3></div><div class="qj l"><p class="bd b dl z fp qg fr fs qh fu fw dk translated">towardsdatascience.com</p></div></div><div class="qk l"><div class="ql l qm qn qo qk qp lb qb"/></div></div></a></div><div class="py pz gp gr qa qb"><a rel="noopener follow" target="_blank" href="/building-generator-pipelines-in-python-8931535792ff"><div class="qc ab fo"><div class="qd ab qe cl cj qf"><h2 class="bd jd gy z fp qg fr fs qh fu fw jc bi translated">用 Python 构建生成器管道</h2><div class="qi l"><h3 class="bd b gy z fp qg fr fs qh fu fw dk translated">本文提出了一种构建生成器管道的优雅方法</h3></div><div class="qj l"><p class="bd b dl z fp qg fr fs qh fu fw dk translated">towardsdatascience.com</p></div></div><div class="qk l"><div class="qq l qm qn qo qk qp lb qb"/></div></div></a></div><div class="py pz gp gr qa qb"><a href="https://docs.python.org/3/library/timeit.html" rel="noopener  ugc nofollow" target="_blank"><div class="qc ab fo"><div class="qd ab qe cl cj qf"><h2 class="bd jd gy z fp qg fr fs qh fu fw jc bi translated">timeit —测量小代码片段的执行时间— Python 3.11.0 文档</h2><div class="qi l"><h3 class="bd b gy z fp qg fr fs qh fu fw dk translated">源代码:Lib/timeit.py 这个模块提供了一种简单的方法来为小部分 Python 代码计时。它既有…</h3></div><div class="qj l"><p class="bd b dl z fp qg fr fs qh fu fw dk translated">docs.python.org</p></div></div></div></a></div><div class="py pz gp gr qa qb"><a rel="noopener follow" target="_blank" href="/benchmarking-python-code-with-timeit-80827e131e48"><div class="qc ab fo"><div class="qd ab qe cl cj qf"><h2 class="bd jd gy z fp qg fr fs qh fu fw jc bi translated">用 timeit 对 Python 代码进行基准测试</h2><div class="qi l"><h3 class="bd b gy z fp qg fr fs qh fu fw dk translated">作为 Python 代码时间基准测试最流行的工具，内置的 timeit 模块提供了比大多数…</h3></div><div class="qj l"><p class="bd b dl z fp qg fr fs qh fu fw dk translated">towardsdatascience.com</p></div></div><div class="qk l"><div class="qr l qm qn qo qk qp lb qb"/></div></div></a></div><div class="py pz gp gr qa qb"><a rel="noopener follow" target="_blank" href="/the-walrus-operator-in-python-a315e4f84583"><div class="qc ab fo"><div class="qd ab qe cl cj qf"><h2 class="bd jd gy z fp qg fr fs qh fu fw jc bi translated">Python 中的海象算子</h2><div class="qi l"><h3 class="bd b gy z fp qg fr fs qh fu fw dk translated">了解什么是 walrus 操作符以及如何在 Python 中使用它</h3></div><div class="qj l"><p class="bd b dl z fp qg fr fs qh fu fw dk translated">towardsdatascience.com</p></div></div><div class="qk l"><div class="qs l qm qn qo qk qp lb qb"/></div></div></a></div><h1 id="b131" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">脚注</h1><p id="abc5" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated">在 R，情况稍微差一点。内置的<code class="fe mf mg mh mi b">Map()</code>函数(以 R 为基数)将一个函数作为第一个参数，将一个向量作为第二个参数:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="9eeb" class="ns mk it mi b be nt nu l nv nw">&gt; Map(function(x) x^2, 1:3)<br/>[[1]]<br/>[1] 1<br/><br/>[[2]]<br/>[1] 4<br/><br/>[[3]]<br/>[1] 9</span></pre><p id="c997" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，<code class="fe mf mg mh mi b">purrr::map()</code>函数更受欢迎，尤其是在<code class="fe mf mg mh mi b">dplyr</code>用户中，它采用相同的参数，但顺序相反:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="36b3" class="ns mk it mi b be nt nu l nv nw">&gt; purrr::map(1:3, function(x) x^2)<br/>[[1]]<br/>[1] 1<br/><br/>[[2]]<br/>[1] 4<br/><br/>[[3]]<br/>[1] 9</span></pre><p id="db64" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是因为当您使用 pip 操作符<code class="fe mf mg mh mi b">%&gt;%</code>时，您使用了一个管道向量:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="f146" class="ns mk it mi b be nt nu l nv nw">&gt; library(dplyr)<br/>&gt; 1:3 %&gt;% purrr::map(function(x) x^2)</span></pre><p id="a48e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">理论上，你可以用相反的顺序来做这件事，使用<code class="fe mf mg mh mi b">Map()</code>:</p><pre class="ks kt ku kv gt no mi np bn nq nr bi"><span id="17c7" class="ns mk it mi b be nt nu l nv nw">&gt; (function(x) x^2) %&gt;% Map(1:3)<br/>[[1]]<br/>[1] 1<br/><br/>[[2]]<br/>[1] 4<br/><br/>[[3]]<br/>[1] 9</span></pre><p id="afd4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但在我看来这不自然。</p><p id="e661" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你懂围棋，你可能已经注意到了两者的相似之处，因为这就是作用域在围棋中的工作方式。</p></div><div class="ab cl qt qu hx qv" role="separator"><span class="qw bw bk qx qy qz"/><span class="qw bw bk qx qy qz"/><span class="qw bw bk qx qy"/></div><div class="im in io ip iq"><div class="ks kt ku kv gt qb"><a href="https://medium.com/@nyggus/membership" rel="noopener follow" target="_blank"><div class="qc ab fo"><div class="qd ab qe cl cj qf"><h2 class="bd jd gy z fp qg fr fs qh fu fw jc bi translated">加入我的介绍链接媒体-马尔钦科萨克</h2><div class="qi l"><h3 class="bd b gy z fp qg fr fs qh fu fw dk translated">阅读马尔钦·科萨克(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="qj l"><p class="bd b dl z fp qg fr fs qh fu fw dk translated">medium.com</p></div></div><div class="qk l"><div class="ra l qm qn qo qk qp lb qb"/></div></div></a></div></div></div>    
</body>
</html>