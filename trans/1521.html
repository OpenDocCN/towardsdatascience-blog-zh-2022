<html>
<head>
<title>Two ways to create custom transformers with Scikit-learn</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Scikit-learn创建自定义变压器的两种方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/two-ways-to-create-custom-transformers-with-scikit-learn-b9089acacd37#2022-04-13">https://towardsdatascience.com/two-ways-to-create-custom-transformers-with-scikit-learn-b9089acacd37#2022-04-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/3c1c862b1b87f71987476f36344443c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iZWJNbiUgmW_5cMy"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@v2osk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> v2osk </a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="ae95" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph">数据科学基础</h2><div class=""/><div class=""><h2 id="4b79" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">提升你的预处理技能</h2></div><p id="fff8" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">预处理是构建成功的机器学习模型的重要部分。Scikit-learn的开箱即用的变形器如<code class="fe md me mf mg b">OneHotEncoder</code>和它的其他对象如<code class="fe md me mf mg b">Pipeline</code>使这个过程变得容易和简化。然而，当我们需要以定制的方式对数据进行预处理时，这些预构建的转换器有时是不够的。在这些情况下，我们可以用Scikit-learn构建定制的转换器来满足我们的定制数据预处理需求。在这篇文章中，我们将熟悉两种方法来创建这样的自定义变压器。</p><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mh"><img src="../Images/fa3403b1a58e4a8d4af0acc3ac4e5140.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hIci6rNJ8Lxf-txT"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://unsplash.com/@davidmarcu?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> David Marcu </a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="3dd2" class="mt mu jj bd mv mw mx my mz na nb nc nd ky ne kz nf lb ng lc nh le ni lf nj nk bi translated">设置📦</h1><p id="6a13" class="pw-post-body-paragraph lh li jj lj b lk nl kt lm ln nm kw lp lq nn ls lt lu no lw lx ly np ma mb mc im bi translated">让我们从导入库和创建样本数据集开始:</p><figure class="mi mj mk ml gt iv"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/bd73ae191a251e4beb578b1456cdf3b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*qkjq-FKLTTcKzYJebao4Ug.png"/></div></figure><p id="c071" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们有两个分类特征来保持简单和集中。我们现在将对数据进行分区，并构建一个简单的管道:</p><figure class="mi mj mk ml gt iv"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/b84a1011d1fab87ca28c6e1b71583222.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*1NwvTVUveuzuHQr4aXaRAQ.png"/></div></figure><p id="ccb4" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们想象一下，我们想要通过以下额外的预处理步骤来构建这条管道:<br/> 1️⃣ <strong class="lj jt">分组类别:</strong>分组<code class="fe md me mf mg b">b_</code>与<code class="fe md me mf mg b">b<br/></code> 2️⃣ <strong class="lj jt">一起减少基数:</strong>将少数类别分组在一起</p><p id="f660" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们保持了简单的预处理步骤，这样我们就可以专注于构建定制的转换器。让我们检查一下这些特征的出现频率:</p><figure class="mi mj mk ml gt iv"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/a64c616c60c7eb5238e9d1905d9ae3da.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*RUvHY9E2bA5KLi-sPZx6vw.png"/></div></figure><p id="b2e9" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对于这两个预处理示例，我们将看看如何使用<br/> 1️⃣ <code class="fe md me mf mg b">FunctionTransformer</code>和<br/> 2️⃣ <code class="fe md me mf mg b">BaseEstimator</code>和<code class="fe md me mf mg b">TransformerMixin</code>构建定制的转换器。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="d931" class="mt mu jj bd mv mw mx my mz na nb nc nd ky ne kz nf lb ng lc nh le ni lf nj nk bi translated">📍示例1:分组类别</h1><p id="9cbd" class="pw-post-body-paragraph lh li jj lj b lk nl kt lm ln nm kw lp lq nn ls lt lu no lw lx ly np ma mb mc im bi translated">在本节中，我们将重点关注<code class="fe md me mf mg b">feature1</code>，因为<code class="fe md me mf mg b">feature2</code>没有名为<code class="fe md me mf mg b">b_</code>的类别。让我们首先手动预处理数据，以说明我们想要实现的目标:</p><figure class="mi mj mk ml gt iv"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/acb9acd0f1b9a4d1fe97ec5ebccd22dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*2y3bkAALjd6OflMPsaeJOQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">左边是训练数据中特征1的频率，右边是测试数据</p></figure><p id="3d83" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以看到<code class="fe md me mf mg b">b_</code>已经和<code class="fe md me mf mg b">b</code>分在了一起。现在让我们用<code class="fe md me mf mg b">FunctionTransformer</code>将它转换成一个定制的转换器:</p><figure class="mi mj mk ml gt iv"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/acb9acd0f1b9a4d1fe97ec5ebccd22dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*2y3bkAALjd6OflMPsaeJOQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">左边是训练数据中特征1的频率，右边是测试数据</p></figure><p id="efae" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们传递了一个预处理函数，并在<code class="fe md me mf mg b">kw_args</code>中指定了参数。我们可以看到<code class="fe md me mf mg b">FunctionTransformer</code>的名字是不言自明的:它将函数转换为转换器。</p><p id="7e25" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们看看另一种方法。我们现在将创建继承了<code class="fe md me mf mg b">BaseEstimator</code>和<code class="fe md me mf mg b">TransformerMixin</code>的<code class="fe md me mf mg b">CategoryGrouper</code>对象。通过继承这些父类并定义<code class="fe md me mf mg b">__init__()</code>、<code class="fe md me mf mg b">fit()</code>和<code class="fe md me mf mg b">transform()</code>方法，我们得到了一个定制的转换器:</p><figure class="mi mj mk ml gt iv"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/acb9acd0f1b9a4d1fe97ec5ebccd22dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*2y3bkAALjd6OflMPsaeJOQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">左边是训练数据中特征1的频率，右边是测试数据</p></figure><p id="d16f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">很好，我们得到了相同的结果。对于这个预处理任务，两种方法都同样有效。然而，情况并非总是如此。这个特定的预处理任务被认为是无状态的转换，在训练期间什么也没有学到。我们可以看到<code class="fe md me mf mg b">CategoryGrouper</code>中的<code class="fe md me mf mg b">fit()</code>方法只是<code class="fe md me mf mg b">return self</code>。在一些预处理任务中，我们需要做<em class="nw">一个</em> <a class="ae jg" href="https://stackoverflow.com/a/25582424/9724079" rel="noopener ugc nofollow" target="_blank"> <em class="nw">有状态</em> </a> <em class="nw">转换</em>在训练过程中学习到的信息。在下一个例子中，我们将看到这两种方法在有状态转换中的不同之处。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="e293" class="mt mu jj bd mv mw mx my mz na nb nc nd ky ne kz nf lb ng lc nh le ni lf nj nk bi translated">📍示例2:减少基数</h1><p id="f62d" class="pw-post-body-paragraph lh li jj lj b lk nl kt lm ln nm kw lp lq nn ls lt lu no lw lx ly np ma mb mc im bi translated">让我们检查变量的频率:</p><figure class="mi mj mk ml gt iv"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/def0fe8914e7c813aa07ae49f19838ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*cZyLd61pSnWvJYeNyHIbqg.png"/></div></figure><p id="c782" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们将使用20%的任意阈值来定义不常见的类别，并将少数类别组合在一起。由于<code class="fe md me mf mg b">feature1</code>的类别高于阈值，我们将在本节重点关注<code class="fe md me mf mg b">feature2</code>。让我们首先手动转换它:</p><figure class="mi mj mk ml gt iv"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/05e0d6cf6fa89f5c8b075ca35549d2ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*Aqg3Z7r-Xu77V-BBLYF2dw.png"/></div></figure><p id="4fbd" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们将用<code class="fe md me mf mg b">FunctionTransformer:</code>将它翻译成一个定制的转换器</p><figure class="mi mj mk ml gt iv"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/ae057ac162ed4e37ac73f0153cb3d043.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*jB21-CBkMICU6mNsNmVI_g.png"/></div></figure><p id="e2d6" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">预处理的测试数据看起来与我们预期的不同。看起来在培训中没有学到最重要的类别。这个例子说明了为什么<code class="fe md me mf mg b">FunctionTransformer</code>不应该用于有状态转换。</p><p id="6763" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们看看另一种方法。在本例中，我们将创建一个名为<code class="fe md me mf mg b">find_top_categories</code>的额外方法，使代码更有条理:</p><figure class="mi mj mk ml gt iv"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/05e0d6cf6fa89f5c8b075ca35549d2ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*Aqg3Z7r-Xu77V-BBLYF2dw.png"/></div></figure><p id="0d2f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这个输出看起来是正确的！这种使用<code class="fe md me mf mg b">BaseEstimator</code>和<code class="fe md me mf mg b">TransformerMixin</code>的方法更加通用，可以用于任何转换。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="7aa7" class="mt mu jj bd mv mw mx my mz na nb nc nd ky ne kz nf lb ng lc nh le ni lf nj nk bi translated">📍超参数调谐</h1><p id="c4c2" class="pw-post-body-paragraph lh li jj lj b lk nl kt lm ln nm kw lp lq nn ls lt lu no lw lx ly np ma mb mc im bi translated">通过创建定制的变压器，我们可以用<a class="ae jg" rel="noopener" target="_blank" href="/pipeline-columntransformer-and-featureunion-explained-f5491f815f"> Scikit-learn的</a> <code class="fe md me mf mg b"><a class="ae jg" rel="noopener" target="_blank" href="/pipeline-columntransformer-and-featureunion-explained-f5491f815f">Pipeline</a></code>集中并简化我们的预处理步骤。创建自定义转换器的另一个好处是，我们可以微调模型和其他转换器的参数。让我们看一个例子:</p><figure class="mi mj mk ml gt iv"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/951044ad7c733c920626796164348bbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*C9gk0fvdHLLKEZurH68rvA.png"/></div></figure><p id="b8ab" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">学会了两种制造定制变形金刚的方法，你可以制造的变形金刚的范围是无限的！这项技能将派上用场，尤其是在将ML管道部署到生产环境中时。如果您想了解更多关于Scikit-learn的数据转换，请查看本文档。</p><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ob"><img src="../Images/154930a8d182a1be2731c6e0f0b1e888.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sfjbPZdRvEUvs246"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">汤姆·亨德森在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4838" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="nw">您想访问更多这样的内容吗？媒体会员可以无限制地访问媒体上的任何文章。如果您使用</em> <a class="ae jg" href="https://zluvsand.medium.com/membership" rel="noopener"> <em class="nw">我的推荐链接</em> </a>，<em class="nw">成为会员，您的一部分会费将直接用于支持我。</em></p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><p id="6e0e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">谢谢你看我的帖子。如果你感兴趣，这里有我的一些帖子的链接:<br/> ◼️️ <a class="ae jg" rel="noopener" target="_blank" href="/pipeline-columntransformer-and-featureunion-explained-f5491f815f?source=your_stories_page-------------------------------------">管道，ColumnTransformer和FeatureUnion解释</a> <br/> ◼️️ <a class="ae jg" rel="noopener" target="_blank" href="/featureunion-columntransformer-pipeline-for-preprocessing-text-data-9dcb233dbcb6"> FeatureUnion，ColumnTransformer &amp;管道用于预处理文本数据</a> <br/> ◼️ <a class="ae jg" rel="noopener" target="_blank" href="/enrich-your-jupyter-notebook-with-these-tips-55c8ead25255">用这些提示丰富你的Jupyter笔记本</a> <br/> ◼️ <a class="ae jg" rel="noopener" target="_blank" href="/organise-your-jupyter-notebook-with-these-tips-d164d5dcd51f">用这些提示组织你的Jupyter笔记本</a> <br/> ◼️ <a class="ae jg" rel="noopener" target="_blank" href="/explaining-scikit-learn-models-with-shap-61daff21b12a">解释scikit-用SHAP </a> <br/> ◼️️ <a class="ae jg" rel="noopener" target="_blank" href="/feature-selection-in-scikit-learn-dc005dcf38b7">特性选择学习模型</a></p><p id="ce7c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">再见🏃💨</p></div></div>    
</body>
</html>