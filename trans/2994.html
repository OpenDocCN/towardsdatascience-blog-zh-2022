<html>
<head>
<title>Real-Time Typeahead Search with Elasticsearch (AWS OpenSearch)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Elasticsearch进行实时预输入搜索(AWS OpenSearch)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/real-time-typeahead-search-with-elasticsearch-aws-opensearch-88410d5b31a1#2022-06-30">https://towardsdatascience.com/real-time-typeahead-search-with-elasticsearch-aws-opensearch-88410d5b31a1#2022-06-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f6ed" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用MovieLens数据集在云上构建可扩展的智能搜索引擎的端到端示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6f910f86da4618f69a63763bda1715c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*XmdngUfaULtDZzbF.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在谷歌搜索的例子。作者图片</p></figure><p id="d9fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="#f88c" rel="noopener ugc nofollow"> 1。</a> <br/>简介<a class="ae lu" href="#5d90" rel="noopener ugc nofollow"> 2。数据集准备</a> <br/> <a class="ae lu" href="#7699" rel="noopener ugc nofollow"> 3。设置OpenSearch </a> <br/> <a class="ae lu" href="#39ad" rel="noopener ugc nofollow"> 4。索引数据</a> <br/> <a class="ae lu" href="#8385" rel="noopener ugc nofollow"> 5。基本查询同匹配</a> <br/> <a class="ae lu" href="#87ea" rel="noopener ugc nofollow"> 6。用Jupyter笔记本和ipywidgets </a> <br/> <a class="ae lu" href="#0beb" rel="noopener ugc nofollow"> 7基本前端实现。一些高级查询</a> <br/> ∘ <a class="ae lu" href="#7bad" rel="noopener ugc nofollow"> 7.1匹配短语前缀</a> <br/> ∘ <a class="ae lu" href="#7041" rel="noopener ugc nofollow"> 7.2匹配+前缀带布尔</a> <br/> ∘ <a class="ae lu" href="#cd74" rel="noopener ugc nofollow"> 7.3多字段搜索</a> <br/> <a class="ae lu" href="#e539" rel="noopener ugc nofollow"> 8。结论</a> <br/> <a class="ae lu" href="#a593" rel="noopener ugc nofollow">关于我的</a> <br/> <a class="ae lu" href="#4a40" rel="noopener ugc nofollow">参考文献</a></p><h1 id="f88c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">1.介绍</h1><p id="cb95" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">你有没有想过谷歌是如何让它的搜索引擎变得如此智能，以至于它可以预测我们的想法，甚至在我们不输入整个内容的情况下自动完成整个搜索词？它被称为<strong class="la iu">类型预搜索</strong>。这是一个非常有用的语言预测工具，许多搜索界面使用它来为用户输入查询提供建议。[1]</p><p id="7f7a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为一名数据科学家或任何从事数据后端工作的人，有时我们可能需要这样一个交互式搜索引擎界面，让我们的用户能够以最少的努力查询结构化/非结构化数据。这样总能让用户体验更上一层楼。</p><p id="2fac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">幸运的是，我们不必从头开始构建它。有很多开源工具可以使用，其中之一就是<strong class="la iu"> Elasticsearch </strong>。</p><p id="44eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://www.elastic.co/what-is/elasticsearch" rel="noopener ugc nofollow" target="_blank"><strong class="la iu">elastic search</strong></a>是一个分布式、免费和开放的搜索和分析引擎，适用于所有类型的数据，包括文本、数字、地理空间、结构化和非结构化数据。Elasticsearch以其简单的REST APIs、分布式特性、速度和可伸缩性而闻名，是Elastic Stack的核心组件，是一套用于数据摄取、丰富、存储、分析和可视化的免费开放工具。[2]</p><p id="83d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，亚马逊创建的<a class="ae lu" href="https://aws.amazon.com/opensearch-service/?nc=bc&amp;pg=wik" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu"> AWS OpenSearch </strong> </a>是Elasticsearch的分叉版本，适合其AWS生态系统。它有一个非常相似的界面与基础结构与弹性搜索。在这篇文章中，为了<strong class="la iu">简化</strong>在本地机器上下载、安装和设置Ealsticsearch的过程，我将带您浏览一个使用<strong class="la iu"> AWS Open Search </strong>索引和查询数据的端到端示例。</p><p id="73af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在现实世界中，使用这种云服务的另一个重要原因是<strong class="la iu">可扩展性。</strong>我们可以轻松调整所需的资源，以适应任何数据复杂性。</p><p id="a363" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请记住，即使我们在这里使用AWS OpenSearch，如果您已经设置了Elasticsearch，您仍然可以按照其中的步骤操作。这些工具在本质上非常相似。</p><h1 id="5d90" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak"> 2。数据集准备</strong></h1><p id="a946" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">在本例中，我们将使用<a class="ae lu" href="https://grouplens.org/datasets/movielens/20m/" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu"> MovieLens 20M数据集</strong> </a>，这是一个受欢迎的开放电影数据集，被许多数据专业人员用于各种项目。之所以称之为20M，是因为数据集中包含了2000万个收视率。此外，整个数据集中包含465，000个标签应用、27，000部电影和138，000个用户。</p><p id="841d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个数据集包含几个文件，可以用于非常复杂的例子，但是假设我们只想在这里构建一个可以查询<strong class="la iu">电影名称、年份和流派</strong>的电影搜索引擎，我们只需要一个文件<strong class="la iu"> <em class="ms"> movies.csv </em> </strong>。</p><p id="406e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个非常干净的数据集。结构如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/798a7cee9cb84b599064036376f9627d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*hc8LucGGKaGbmvjN7BVNvQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">movies.csv (MovieLense 20M)。作者图片</p></figure><p id="d1c9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">只有3个字段:<strong class="la iu"> movieId </strong>、<strong class="la iu">片名</strong>(括号内为年份)、以及<strong class="la iu">流派</strong>(用|)隔开。我们将使用标题和流派对数据集进行索引，但看起来有些电影没有指定流派(例如，movieId = 131260)，因此我们可能希望将这些流派替换为NA，以防止它们作为不需要的流派关键字被查询。几行处理就足够了:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="66ec" class="mz lw it mv b gy na nb l nc nd">import pandas as pd<br/>import numpy as np</span><span id="680e" class="mz lw it mv b gy ne nb l nc nd">df = pd.read_csv('../data/movies.csv')<br/>df['genres'] = df['genres'].replace('(no genres listed)', np.NaN)<br/>df.to_csv('../data/movies_clean.csv', index=False)</span></pre><p id="3ffd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过这一小段代码，我们刚刚清理了数据集，并将其保存为一个名为<code class="fe nf ng nh mv b">movie_clean.csv</code>的新文件。现在，我们可以继续创建一个AWS OpenSearch域。</p><h1 id="7699" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">3.设置开放搜索</h1><p id="17b0" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">下面是来自AWS OpenSearch的<a class="ae lu" href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/gsg.html" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">官方文档</strong> </a>。你可以跟着它做更详细的介绍，也可以通读我下面做的简化版。</p><p id="7e40" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你没有<strong class="la iu"> AWS账号</strong>，可以按照这个<a class="ae lu" href="https://portal.aws.amazon.com/billing/signup?nc2=h_ct&amp;src=header_signup&amp;redirect_url=https%3A%2F%2Faws.amazon.com%2Fregistration-confirmation#/start/email" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">链接</strong> </a>报名AWS。您还需要为AWS服务添加一种支付方式。然而，不要惊慌，因为在本教程中，我们将使用最少的资源，成本应该不超过1美元。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/efcd516b0e1b518380c8ef50c613a041.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*INGzZIc47YmzwOLFj4xOwQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lu" href="https://portal.aws.amazon.com/billing/signup?nc2=h_ct&amp;src=header_signup&amp;redirect_url=https%3A%2F%2Faws.amazon.com%2Fregistration-confirmation#/start/email" rel="noopener ugc nofollow" target="_blank">报名AW </a> S .图片作者</p></figure><p id="6a07" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建您的帐户后，只需登录您的<a class="ae lu" href="https://aws.amazon.com/console/" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu"> AWS管理控制台</strong> </a>，搜索OpenSearch服务，或点击<a class="ae lu" href="https://us-east-1.console.aws.amazon.com/esv3/home?region=us-east-1#opensearch/dashboard" rel="noopener ugc nofollow" target="_blank">此处</a>进入<strong class="la iu"> OpenSearch仪表盘</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/485a4c945a5d5bf2d4cebcab38338c17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lPY2EHuugk5xFWU7TfKcTA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">打开搜索仪表板。作者图片</p></figure><p id="62bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在仪表板中，按照以下步骤操作:</p><ol class=""><li id="012c" class="nk nl it la b lb lc le lf lh nm ll nn lp no lt np nq nr ns bi translated">选择<strong class="la iu">创建域</strong>。</li><li id="613d" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated">给个<strong class="la iu">域名</strong>。</li><li id="e1e5" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated">在开发类型中，选择<strong class="la iu">开发和测试</strong>。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/bebfaa85f55ff47c81a931468c4b2aab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CSMYdfP0rB297JnjI0fS7w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lu" href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/gsgcreate-domain.html" rel="noopener ugc nofollow" target="_blank"> AWS OpenSearch设置</a>。用户图像</p></figure><p id="597b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">4.将实例类型更改为<strong class="la iu"> t3.small.search </strong>，并保留所有其他类型的默认值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/1a5b91635809da5822fbf9925e21b3d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_pcgJj5FMCb_Mwl034vOTw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lu" href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/gsgcreate-domain.html" rel="noopener ugc nofollow" target="_blank"> AWS OpenSearch设置</a>。用户图像</p></figure><p id="302a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">5.为了项目的简单，在网络中，选择<strong class="la iu">公共接入</strong></p><p id="a820" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">6.在细粒度访问控制中，通过设置用户名和密码来创建<strong class="la iu">主用户</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/7a51e83e9675501ec250f14b45dd5f50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZqwQgoqT7OCCBDy1gM8q6A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lu" href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/gsgcreate-domain.html" rel="noopener ugc nofollow" target="_blank"> AWS开放搜索设置</a>。用户图像</p></figure><p id="e64c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">7.在访问策略中，选择<strong class="la iu">只使用细粒度的访问控制</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/e58df72c12b3f19800601bfe9e4cbdbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yAa0K7mT8-O7GA6rNzk4DA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lu" href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/gsgcreate-domain.html" rel="noopener ugc nofollow" target="_blank"> AWS OpenSearch设置</a>。用户图像</p></figure><p id="8f69" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">8.通过保留默认设置来忽略所有其他设置。点击<strong class="la iu">创建</strong>。这可能需要15-30分钟才能完成，但根据我的经验，通常会更快。</p><h1 id="39ad" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak"> 4。索引数据</strong></h1><p id="76c0" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">AWS OpenSearch或Elasticsearch足够智能，可以自动索引我们上传的任何数据，之后我们可以用任何逻辑规则编写查询来查询结果。然而，可能需要一些预处理工作来简化我们的查询工作。</p><p id="06d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们记得，我们的数据由3列组成:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/798a7cee9cb84b599064036376f9627d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*hc8LucGGKaGbmvjN7BVNvQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">movies.csv (MovieLense 20M)。作者图片</p></figure><p id="33dc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">标题和类型对我们来说都很重要，因为我们可能希望在任一/两者中输入任何关键字来搜索我们想要的电影。<strong class="la iu">open search支持多字段搜索</strong>，但是为了查询的简单性，我们也可以通过将我们感兴趣的所有关键词放入一个专门的列来对其进行预处理，这样<strong class="la iu">提高了效率，降低了查询复杂度</strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">预处理以创建新的search_index列。作者代码</p></figure><p id="3556" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用上面的预处理代码，我们将一个名为<strong class="la iu"> search_index </strong>的新列插入到包含标题和所有流派的数据帧中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/5fe00a581db4f7b46e4338f41cc3377c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9dWQmAGhGz6nvtEPONaQPA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">添加了search_index的数据帧。作者图片</p></figure><p id="eb30" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一步是将数据转换成JSON格式，以便<strong class="la iu">批量上传到我们的域。为批量数据上传指定的格式可以在<a class="ae lu" href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/gsgupload-data.html?sc_icampaign=docs_console-es_upload-data_20201706&amp;sc_ichannel=ha&amp;sc_icontent=awssm-4561&amp;sc_iplace=console-es&amp;trk=ha_awssm-4561" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">开发人员指南</strong> </a>选项2中找到。大概是这样的:</strong></p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="a485" class="mz lw it mv b gy na nb l nc nd">{"index": {"_index": "movies", "_id": "2"}}<br/>{"title": "Jumanji (1995)", "genres": "Adventure|Children|Fantasy", "search_index": "Jumanji (1995) Adventure Children Fantasy"}</span></pre><p id="8941" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中<strong class="la iu">第一行</strong>指定要保存在域中的索引(文档)名称以及记录id(这里我使用movieId列作为惟一标识符)。第二行包括数据集中的所有其他字段。</p><p id="1e90" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下代码用于转换:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从dataframe转换到JSON。作者代码</p></figure><p id="0fca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">转换后，数据以<code class="fe nf ng nh mv b">movies.json</code>的名称存储在数据文件夹中。现在我们需要将它上传到域中，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将JSON数据批量上传到域中。作者代码</p></figure><p id="f0f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，<strong class="la iu">端点</strong>可以在您的OpenSearch域页面上找到。<strong class="la iu">用户名和密码</strong>是我们在创建该域名时设置的主用户名&amp;密码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/0e046dc3f4c01dfd80eb7711b47160f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LccOGT5FxwIADB2fy35Cmg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">域仪表板。作者图片</p></figure><p id="aeff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果它返回一个<strong class="la iu"> &lt;响应【200】&gt;</strong>，那么我们就可以开始了。数据集已成功上传到AWS OpenSearch域。</p><h1 id="8385" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">5.带有匹配的基本查询</h1><p id="cc82" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">现在，随着数据的上传，我们已经完成了服务器端的所有工作。OpenSearch自动索引数据以备查询。我们现在可以开始在客户端<strong class="la iu">上查询来自域的数据。</strong></p><p id="754b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要了解关于查询语言的更多信息，这里有两个选项:</p><ol class=""><li id="ad51" class="nk nl it la b lb lc le lf lh nm ll nn lp no lt np nq nr ns bi translated">开始使用<a class="ae lu" href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/gsgsearch.html" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu"> AWS OpenSearch服务开发者指南</strong> </a></li><li id="7b72" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated">在这个<a class="ae lu" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">官方Elasticsearch指南查询DSL </strong> </a>中有一些关于从Elasticsearch和OpenSearch中查询数据的非常详细的文档。</li></ol><p id="f8d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，在这个例子中，我们不需要非常高级的功能。我们将主要使用围绕标准<a class="ae lu" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">匹配查询</strong> </a> <strong class="la iu"> </strong>的一些小变化。</p><p id="29a9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是一个基本的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基本匹配查询。作者代码</p></figure><p id="014e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我们编写查询来查找任何与title = "jumanji "匹配的记录，将JSON查询序列化为字符串，并将其与端点和凭证一起发送到域。让我们看看返回的结果:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="740d" class="mz lw it mv b gy na nb l nc nd">{'took': 4,<br/> 'timed_out': False,<br/> '_shards': {'total': 5, 'successful': 5, 'skipped': 0, 'failed': 0},<br/> 'hits': {'total': {'value': 1, 'relation': 'eq'},<br/>  'max_score': 10.658253,<br/>  'hits': [{'_index': 'movies',<br/>    '_type': '_doc',<br/>    '_id': '2',<br/>    '_score': 10.658253,<br/>    '_source': {'title': 'Jumanji (1995)',<br/>     'genres': 'Adventure|Children|Fantasy',<br/>     'search_index': 'Jumanji (1995) Adventure Children Fantasy'}}]}}</span></pre><p id="0534" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我们看到的，它返回标题等于<code class="fe nf ng nh mv b">jumanji</code>的记录。我们的数据集中只有一个匹配的结果，确切的标题是<code class="fe nf ng nh mv b">Jumanji (1995)</code>，还有其他信息，如id、流派和search_index。</p><p id="8a91" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">OpenSearch自动处理<strong class="la iu">大写/小写字母、任何符号和空格</strong>，因此它可以很好地找到我们的记录。此外，<strong class="la iu">分数</strong>意味着返回的结果与我们的查询匹配的可信度，越高越好。这种情况下是<code class="fe nf ng nh mv b">10.658253</code>。如果我们在搜索查询中包括年份，比如“jumanji 1995”，那么分数将增加到<code class="fe nf ng nh mv b">16.227726</code>。当查询返回多个结果时，<strong class="la iu">对结果进行排序</strong>是一个重要的指标。</p><h1 id="87ea" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">6.Jupyter笔记本和ipywidgets的基本前端实现</h1><p id="99e0" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">作为一个数据科学家，<strong class="la iu"> Jupyter笔记本</strong>是一个很好的朋友，配合现在流行的<a class="ae lu" href="https://ipywidgets.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu"> ipywidgets </strong> </a>，我们可以让笔记本变得很有互动性。下面是构建一个基本GUI的一些代码，该GUI包括一个<strong class="la iu">文本框</strong>(用于输入关键字)和一个<strong class="la iu">文本输出</strong>(用于显示查询结果)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="a9bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该准则有5个部分:</p><ol class=""><li id="2b4d" class="nk nl it la b lb lc le lf lh nm ll nn lp no lt np nq nr ns bi translated"><strong class="la iu">搜索功能</strong>:上一节介绍的基本查询的包装器。通过输入，它搜索并返回包含输入关键字的结果。</li><li id="643c" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated"><strong class="la iu">加粗</strong>:这个功能使用Markdown来加粗结果中的关键词，以便更好地可视化结果。</li><li id="2fbd" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated"><strong class="la iu"> printmd </strong>:在IPython中显示Markdown的包装函数</li><li id="3279" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated"><strong class="la iu"> text_change </strong>:处理<strong class="la iu"> widget事件</strong>的函数。在这种情况下，只要文本框中的值发生变化，它就会执行搜索功能，并返回按分数排序的前10个结果。还实现了一个计时模块来显示搜索需要多长时间。</li><li id="2a0a" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated">代码的最后一部分定义了要显示的小部件元素:一个<strong class="la iu">文本框</strong>和一个<strong class="la iu">输出</strong>。当框中的值改变时，小部件事件被触发，结果将显示在输出中。</li></ol><p id="9acb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是我们执行代码时的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/65e3fee52a9166a86cf76cd46fa3c311.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*u8dmrvPyUEOIqaUr.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用GUI的基本查询。作者图片</p></figure><p id="cdbb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们输入关键字“jumanji”时，它会不断搜索更新的关键字。在此过程中，关键字“j”、“ju”和“jumanji”分别返回3组结果。但是，对于“jum”、“juma”、“juman”或“jumanj”，它是空的，因为我们在这里使用的匹配查询将输入的关键字视为<strong class="la iu">精确术语</strong>，并且我们的数据集中没有包含这些单词的电影。</p><p id="cf3e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这看起来不像我们预期的typeahead功能。为了提高性能，我们将在下面研究一些高级查询选项，包括<strong class="la iu">前缀</strong>、<strong class="la iu">布尔</strong>和<strong class="la iu">多字段</strong>搜索。</p><h1 id="0beb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">7.一些高级查询</h1><h2 id="7bad" class="mz lw it bd lx of og dn mb oh oi dp mf lh oj ok mh ll ol om mj lp on oo ml op bi translated">7.1匹配短语前缀</h2><p id="f8bb" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">一个简单的解决方法是使用<a class="ae lu" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">匹配短语前缀查询</strong> </a>代替<a class="ae lu" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">匹配查询</strong> </a>。匹配短语前缀查询可以按照与所提供的相同的顺序<strong class="la iu">返回包含所提供文本的单词的文档。所提供文本的最后一个术语<strong class="la iu">被视为前缀<strong class="la iu"/>，匹配以该术语开头的任何单词。[5]</strong></strong></p><p id="3583" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这似乎是我们想要的:当我们输入查询时，我们不必在它可以告诉结果之前完成术语。</p><p id="6817" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以让我们这样修改我们的查询！</p><p id="bd6f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我不会再展示Python代码，因为除了对<strong class="la iu">搜索函数中的查询稍作修改之外，一切都保持不变。</strong>现在<code class="fe nf ng nh mv b">match</code>变成了<code class="fe nf ng nh mv b">match_phrase_prefix</code>:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="c324" class="mz lw it mv b gy na nb l nc nd">query = {<br/>    'query': {<br/>        'match_phrase_prefix': {<br/>            'title': prefix<br/>            }<br/>        }<br/>    }</span></pre><p id="82c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更改后，现在看起来是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/27162d5e53efe62ff4e6ddbc294c7b5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*F4koqiowoXdNT_6P.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">匹配短语前缀查询的结果。作者图片</p></figure><p id="ce29" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们在这里尝试了3个例子:</p><ol class=""><li id="e39c" class="nk nl it la b lb lc le lf lh nm ll nn lp no lt np nq nr ns bi translated"><strong class="la iu">巨漫记</strong>:现在修好了！当我们输入时，搜索引擎使用输入的文本作为前缀，完美地呈现所有想要的输出。</li><li id="0f58" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated">《哈利·波特》:和上一个例子做的一样。当我们到第二个学期“波特”时，它开始显示所有的哈利波特电影。</li><li id="a842" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated"><strong class="la iu">哈利波特</strong>:然而，如果我们将“哈利波特”反转为“哈利波特”，它不会显示任何结果，因为在<strong class="la iu">匹配短语前缀查询</strong>中顺序很重要。</li></ol><p id="5ffc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">想象一下，当我们使用搜索引擎时，我们并不总是100%确定我们记住了按<strong class="la iu">正确顺序排列的所有关键词，</strong>，所以我们可能想要改进搜索引擎，使它变得更加<strong class="la iu">智能</strong>来帮助我们解决问题。</p><h2 id="7041" class="mz lw it bd lx of og dn mb oh oi dp mf lh oj ok mh ll ol om mj lp on oo ml op bi translated">7.2用布尔值匹配+前缀</h2><p id="a9cc" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">要分解此类查询的<strong class="la iu">需求</strong>:</p><ol class=""><li id="0f73" class="nk nl it la b lb lc le lf lh nm ll nn lp no lt np nq nr ns bi translated"><strong class="la iu">最后一项</strong>需要作为<strong class="la iu">前缀</strong>处理</li><li id="40a4" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated"><strong class="la iu">其他术语</strong>需要与<strong class="la iu">完全匹配</strong></li><li id="d3ac" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated">我们不需要确切的顺序来得到想要的结果</li></ol><p id="b039" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">遗憾的是，Elasticsearch/OpenSearch中没有这种我们可以直接使用的查询类型，但是工具足够灵活，我们可以使用<a class="ae lu" href="https://www.elastic.co/guide/en/elasticsearch/client/net-api/8.2/bool-query-usage.html" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">布尔查询</strong> </a>来实现逻辑。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">search_prefix函数，它将最后一项视为前缀，而忽略顺序。作者代码</p></figure><p id="b850" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面显示的代码是更新后的搜索功能。正如我们在这里看到的，在合并了<strong class="la iu"> bool </strong>操作<strong class="la iu"> must </strong>之后，查询变得更长了:</p><ul class=""><li id="0922" class="nk nl it la b lb lc le lf lh nm ll nn lp no lt oq nq nr ns bi translated">如果我们输入的搜索文本包含不止一个单词<strong class="la iu">，那么我们将把最后一个单词<strong class="la iu">视为前缀</strong>，<strong class="la iu">和</strong>，<strong class="la iu">前面的单词与</strong>完全匹配。</strong></li><li id="423e" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt oq nq nr ns bi translated">如果搜索文本是<strong class="la iu">只有一个单词</strong>(或更少)，那么我们就把它当作一个<strong class="la iu">前缀</strong>来搜索。</li></ul><p id="92a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实施更改后，让我们看看结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/d30cb0bf00e405752c3edce20a956136.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*CYZ0lO28_rfq5nap.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用前缀和布尔语句的复合查询的结果。作者图片</p></figure><p id="6704" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，当以完全混合的顺序输入:“波特哈利王子血”时，搜索引擎知道我们在寻找什么，它能够返回正确的结果:<strong class="la iu">哈利波特与混血王子(2009) </strong>。</p><h2 id="cd74" class="mz lw it bd lx of og dn mb oh oi dp mf lh oj ok mh ll ol om mj lp on oo ml op bi translated">7.3多字段搜索</h2><p id="6acc" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">到目前为止，我们只在电影标题字段中进行搜索，但是我们可以进一步改进搜索引擎，通过利用一些<strong class="la iu">隐藏字段，例如我们案例中的类型</strong>，使其更加智能。</p><p id="c1ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要在<strong class="la iu">多个字段</strong>中进行搜索，弹性搜索用户指南中有<a class="ae lu" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">多匹配查询</strong> </a>。但是，它没有提供足够的能力来搜索前缀，同时像我们刚才所做的那样忽略订单。我们仍然需要布尔来进行复合查询。</p><p id="89f8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有一个捷径:记住，我们之前处理了数据集，并准备了一个组合的<strong class="la iu"> search_index </strong>列来包含标题和流派信息。有了这个新字段，我们可以很容易地修改我们以前的查询，以包含隐藏的流派信息，而无需显式地使用多匹配查询。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">search_prefix函数，在不显式使用多匹配的情况下进行多字段搜索。作者代码</p></figure><p id="4d03" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是修改后的<code class="fe nf ng nh mv b">search_prefix</code>函数，但是如果你仔细看，它和上一个函数没有什么变化，除了我们用<code class="fe nf ng nh mv b">search_index</code>代替了<code class="fe nf ng nh mv b">title</code>来搜索标题和流派。</p><p id="6c2a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是更改后的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/91d05e73ed96d0171d84336e1e41720c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*1d9KEwgKiWJNg-16.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用标题和类型信息的多字段搜索结果。作者图片</p></figure><p id="a907" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们尝试了两个例子:</p><ol class=""><li id="ded7" class="nk nl it la b lb lc le lf lh nm ll nn lp no lt np nq nr ns bi translated">假设我们记得有一部冒险电影，关键词是“不可能”。然后我们输入“不可能的冒险”，它会返回所有不可能完成的任务的电影，因为它们被归类为“冒险”电影。</li><li id="c2ac" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated">哈利·波特也一样。如果输入“波特冒险”，它将返回所有的哈利波特电影，因为它们都是“冒险”电影。</li></ol><h1 id="e539" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">8.结论</h1><p id="7dc1" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">在这篇文章中，我们通过一个端到端的例子来构建一个智能的预输入搜索引擎，步骤如下:</p><ul class=""><li id="015d" class="nk nl it la b lb lc le lf lh nm ll nn lp no lt oq nq nr ns bi translated">准备电影数据集</li><li id="11df" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt oq nq nr ns bi translated">设置AWS OpenSearch域</li><li id="f169" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt oq nq nr ns bi translated">将数据集批量上传到OpenSearch服务进行索引</li><li id="b526" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt oq nq nr ns bi translated">构建一个简单的预输入搜索引擎GUI</li><li id="b212" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt oq nq nr ns bi translated">从基础到高级主题，从域中查询数据的几种方法</li></ul><p id="d6e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果令人印象深刻:我们能够像谷歌一样模仿预输入搜索。在键入关键字的同时，搜索引擎在<strong class="la iu">中近乎实时</strong> (0.2秒)地分析和搜索数据库，以呈现最接近的匹配，并指导我们进一步缩小搜索结果列表的方向。</p><p id="57e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，我们使用布尔运算修改了查询，使我们能够<strong class="la iu">混合关键字顺序</strong>。我们还可以输入属于<strong class="la iu">隐藏字段</strong>的值，例如流派名称，以帮助我们缩小范围并找到想要的结果。这两个特性使得搜索引擎更加智能。</p><p id="c642" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中，我们还有很多地方可以在将来改进:</p><ol class=""><li id="e04d" class="nk nl it la b lb lc le lf lh nm ll nn lp no lt np nq nr ns bi translated">Jupyter笔记本和它的<code class="fe nf ng nh mv b">ipywidgets</code>在构建GUI方面非常强大。这里我们只使用了文本框和输出，但是本例中可以使用更多的小部件，例如触发搜索的<strong class="la iu">按钮</strong>、在结果上添加过滤器的<strong class="la iu">复选框</strong>或<strong class="la iu">下拉列表</strong>，或者点击Google提供的建议结果的<strong class="la iu">选择框</strong>。</li><li id="ba40" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated">然而，与前端开发人员使用的工具包(如JavaScript)相比，<code class="fe nf ng nh mv b">ipywidgets</code>仍然具有<strong class="la iu">有限的功能</strong>。本例中显示的工作流仅用于数据科学家的<strong class="la iu">快速测试和开发</strong>用途，他们非常熟悉Jupyter笔记本电脑，但在前端开发方面经验有限。如果我们想建立一个强大的搜索引擎应用程序，这不是最好的做法。</li><li id="ca3b" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated">Elasticsearch/OpenSearch <strong class="la iu">领域特定语言(DSL) </strong>是一个非常<strong class="la iu">通用的</strong>工具，我们可以用它来编写几乎可以满足任何需求的查询。在这个例子中，我们只是覆盖了它的一个非常肤浅的层面。如果你有兴趣了解更多，这里有Elasticsearch提供的完整的<a class="ae lu" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">文档</strong> </a>。</li><li id="5d71" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated">AWS OpenSearch是<strong class="la iu">可扩展的</strong>。在这个例子中，我们为这个27，000部电影的数据集选择了<code class="fe nf ng nh mv b">t3.small.search</code>，但是如果我们扩大资源，我们通常可以期待更好的结果。在现实世界中，数据量也可能是完全不同的数量级，因此需要为实际的数据大小选择适当的资源。</li><li id="0020" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated">对于任何云服务来说，安全性都是一个严肃的话题。在这个例子中，我们几乎完全忽略了所有的安全设置，但是如果是在生产环境中，我们需要付出更多的努力来增强安全级别。</li></ol><p id="c45a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在帖子的最后，最后提醒一句:如果你不再需要AWS OpenSearch域名，请记得<strong class="la iu">将其删除，否则会产生不必要的费用！</strong></p><p id="19c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢您的阅读！如果你喜欢这篇文章，请<strong class="la iu">关注我的频道</strong>和/或<a class="ae lu" href="https://zhouxu-ds.medium.com/membership" rel="noopener"> <strong class="la iu">成为我今天的推荐会员</strong> </a>(非常感谢🙏).我会继续写下去，分享我关于数据科学的想法和项目。如果你有任何问题，请随时联系我。</p><div class="or os gp gr ot ou"><a href="https://zhouxu-ds.medium.com/membership" rel="noopener follow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">加盟传媒与我的引荐链接——周(乔)徐</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">阅读周(Joe)徐(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">zhouxu-ds.medium.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi ks ou"/></div></div></a></div><h1 id="a593" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">关于我</h1><p id="897c" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我是赛诺菲的数据科学家。我拥抱技术，每天都在学习新技能。欢迎您通过<a class="ae lu" href="https://zhouxu-ds.medium.com/" rel="noopener">媒体博客</a>、<a class="ae lu" href="https://www.linkedin.com/in/zhouxu-ds/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>或<a class="ae lu" href="https://github.com/zhouxu-ds" rel="noopener ugc nofollow" target="_blank"> GitHub </a>联系我。我的观点是我自己的，而不是我雇主的观点。</p><p id="4e39" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请看我的其他文章:</p><ul class=""><li id="9b10" class="nk nl it la b lb lc le lf lh nm ll nn lp no lt oq nq nr ns bi translated"><a class="ae lu" rel="noopener" target="_blank" href="/time-series-pattern-recognition-with-air-quality-sensor-data-4b94710bb290">利用空气质量传感器数据进行时间序列模式识别</a></li><li id="1992" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt oq nq nr ns bi translated"><a class="ae lu" rel="noopener" target="_blank" href="/loan-default-prediction-for-profit-maximization-45fcd461582b">利润最大化的贷款违约预测</a></li><li id="e8e9" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt oq nq nr ns bi translated"><a class="ae lu" rel="noopener" target="_blank" href="/loan-default-prediction-an-end-to-end-ml-project-with-real-bank-data-part-1-1405f7aecb9e">使用Berka数据集进行贷款违约预测</a></li><li id="9c4f" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt oq nq nr ns bi translated"><a class="ae lu" rel="noopener" target="_blank" href="/build-rest-api-for-machine-learning-models-using-python-and-flask-restful-7b2cd8d87aa0">使用Python和Flask-RESTful为机器学习模型构建REST API</a></li><li id="a75c" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt oq nq nr ns bi translated"><a class="ae lu" rel="noopener" target="_blank" href="/understanding-sigmoid-logistic-softmax-functions-and-cross-entropy-loss-log-loss-dbbbe0a17efb#4dd4">理解分类问题中的Sigmoid、Logistic、Softmax函数和交叉熵损失(对数损失)</a></li></ul><h1 id="4a40" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">参考文献</strong></h1><p id="df89" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">[1]动态Web-type ahead搜索:<a class="ae lu" href="https://doc.dynamicweb.com/documentation-9/how-tos/general/implementing-typeahead-search" rel="noopener ugc nofollow" target="_blank">https://doc . Dynamic Web . com/documentation-9/how-tos/general/implementing-type ahead-Search</a></p><p id="fc82" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[2]弹性——什么是弹性搜索:<a class="ae lu" href="https://www.elastic.co/what-is/elasticsearch" rel="noopener ugc nofollow" target="_blank">https://www.elastic.co/what-is/elasticsearch</a></p><p id="bbe6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[3] MovieLens 20M数据集:<a class="ae lu" href="https://grouplens.org/datasets/movielens/20m/" rel="noopener ugc nofollow" target="_blank">https://grouplens.org/datasets/movielens/20m/</a></p><p id="540e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">F.麦克斯韦·哈珀和约瑟夫·a·康斯坦。2015.电影镜头数据集:历史和背景。ACM交互式智能系统汇刊(TiiS) 5，4，第19篇(2015年12月)，19页。http://dx.doi.org/10.1145/2827872</p><p id="f978" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[4]亚马逊OpenSearch服务开发者指南:<a class="ae lu" href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/gsg.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/open search-Service/latest/Developer Guide/gsg . html</a></p><p id="001f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[5] Elasticsearch Guide —查询DSL:<a class="ae lu" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html" rel="noopener ugc nofollow" target="_blank">https://www . elastic . co/Guide/en/elastic search/reference/current/Query-DSL . html</a></p></div></div>    
</body>
</html>