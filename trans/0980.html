<html>
<head>
<title>Land Cover Image Classification Using a TensorFlow CNN in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于 Python 语言的张量流 CNN 土地覆盖图像分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/land-cover-classification-using-tensorflow-in-python-791036eaa373#2022-03-15">https://towardsdatascience.com/land-cover-classification-using-tensorflow-in-python-791036eaa373#2022-03-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6ef5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用张量流卷积神经网络的欧洲卫星土地覆盖图像分类</h2></div></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="d416" class="kp kq it bd kr ks kt dn ku kv kw dp kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">介绍</h2><p id="c101" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt ky lu lv lw lc lx ly lz lg ma mb mc md im bi translated"><strong class="ln iu">土地覆盖</strong>是探测到的地球表面的<em class="me">生物物理覆盖</em>，包括草、森林、牧场、水等物质。吸收土地覆被信息的方法多种多样。一个主要过程包括使用<strong class="ln iu">遥感图像</strong>结合<strong class="ln iu">实地调查</strong>。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mf"><img src="../Images/fd243d20beb97b11c506405c99a1db27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cQQ2s2NOti4E8heP"/></div></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">美国宇航局在<a class="ae mv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="12d6" class="kp kq it bd kr ks kt dn ku kv kw dp kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">资料组</h2><p id="fa73" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt ky lu lv lw lc lx ly lz lg ma mb mc md im bi translated"><strong class="ln iu">欧洲卫星数据集</strong>由来自<strong class="ln iu">哨兵-2 </strong>卫星图像的瓦片组成。数据集<strong class="ln iu">公开</strong>到<a class="ae mv" href="https://github.com/phelber/EuroSAT" rel="noopener ugc nofollow" target="_blank">下载</a>。</p><p id="b563" class="pw-post-body-paragraph ll lm it ln b lo mw ju lq lr mx jx lt ky my lv lw lc mz ly lz lg na mb mc md im bi translated">图 1 显示了从集合中随机选择的 15 个样本，描述了 10 个可能类别中的 8 个。剩下的两个看不见的类是<code class="fe nb nc nd ne b">HerbaceousVegetation</code>和<code class="fe nb nc nd ne b">River</code>。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nf"><img src="../Images/0550103ad8df7aa5db397fd064985818.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RlWbFYXrt8zYPW0us4m53Q.png"/></div></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">图 1 —欧洲卫星组织样本训练数据(图片由作者提供)</p></figure><p id="e695" class="pw-post-body-paragraph ll lm it ln b lo mw ju lq lr mx jx lt ky my lv lw lc mz ly lz lg na mb mc md im bi translated">从图 1 中可以看出，每种土地覆被类别之间有明显的视觉差异。因此，一个合理的先验假设预计<code class="fe nb nc nd ne b">Forest</code>、<code class="fe nb nc nd ne b">Pasture</code>和<code class="fe nb nc nd ne b">AnnualCrop</code>类别之间的<em class="me">潜在混淆</em>。另外，<code class="fe nb nc nd ne b">Highway</code>和<code class="fe nb nc nd ne b">River</code>图像可能趋于相似。然而，一般来说，对于神经网络来说，似乎存在适当的区别属性来充分学习适当的<em class="me">特征映射</em>。</p><p id="b67c" class="pw-post-body-paragraph ll lm it ln b lo mw ju lq lr mx jx lt ky my lv lw lc mz ly lz lg na mb mc md im bi translated">图 2 显示了<em class="me">十个土地覆盖类别</em>中每个类别的<strong class="ln iu">计数分布</strong>，总共有<em class="me"> 27，000 张</em>带标签和地理参考的图像。</p><blockquote class="ng nh ni"><p id="fa90" class="ll lm me ln b lo mw ju lq lr mx jx lt nj my lv lw nk mz ly lz nl na mb mc md im bi translated">地理参照意味着<strong class="ln iu">航空照片的坐标系统与地理坐标的地面系统</strong>相关。因此，地理信息系统(GIS)可以将图像“放置”在适当的真实位置。</p></blockquote><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nm"><img src="../Images/c51cfb29bf283a8ef874f76e605909b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2W7PgrXutMjeNAxTevnezQ.png"/></div></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">图 2—训练数据计数分布(图片由作者提供)</p></figure><p id="dfe1" class="pw-post-body-paragraph ll lm it ln b lo mw ju lq lr mx jx lt ky my lv lw lc mz ly lz lg na mb mc md im bi translated">机器学习任务通常利用<strong class="ln iu">三个数据子集</strong> : <em class="me">训练、测试和验证</em> <strong class="ln iu">。</strong>训练/验证/测试百分比分割根据可用数据集的大小而变化:</p><ul class=""><li id="2284" class="nn no it ln b lo mw lr mx ky np lc nq lg nr md ns nt nu nv bi translated"><em class="me">训练</em> (60%):标记数据，用于通过反向传播算法进行梯度下降以调整 CNN 的参数</li><li id="ddd7" class="nn no it ln b lo nw lr nx ky ny lc nz lg oa md ns nt nu nv bi translated"><em class="me">验证</em> (20%):用于在每个训练周期后确定模型性能指标的标记数据</li><li id="818c" class="nn no it ln b lo nw lr nx ky ny lc nz lg oa md ns nt nu nv bi translated"><em class="me">测试</em> (20%):用于评估模型功效的看不见的标记数据</li></ul><p id="049f" class="pw-post-body-paragraph ll lm it ln b lo mw ju lq lr mx jx lt ky my lv lw lc mz ly lz lg na mb mc md im bi translated">要点 1 显示了<strong class="ln iu"> Keras </strong>实用函数<a class="ae mv" href="https://www.tensorflow.org/api_docs/python/tf/keras/utils/image_dataset_from_directory" rel="noopener ugc nofollow" target="_blank">image _ dataset _ from _ directory</a>，该函数加载目录结构与文档匹配的图像文件。</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ob oc l"/></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">要点 1 —使用 Tensorflow 加载训练/验证数据集</p></figure><p id="ff47" class="pw-post-body-paragraph ll lm it ln b lo mw ju lq lr mx jx lt ky my lv lw lc mz ly lz lg na mb mc md im bi translated">加载图像后，检查数据并确定有用的变量。例如，使用以下命令查找<strong class="ln iu"> </strong>类的<strong class="ln iu">名称</strong>和<strong class="ln iu">编号</strong>:</p><pre class="mg mh mi mj gt od ne oe of aw og bi"><span id="efd7" class="kp kq it ne b gy oh oi l oj ok">class_names = <strong class="ne iu">train_dataset.class_names</strong><br/>num_classes = <strong class="ne iu">len(class_names)</strong></span></pre><p id="d28c" class="pw-post-body-paragraph ll lm it ln b lo mw ju lq lr mx jx lt ky my lv lw lc mz ly lz lg na mb mc md im bi translated">上面使用的 Keras 函数批量加载数据。从<code class="fe nb nc nd ne b">BatchDataset</code>检索单个体积，检查输入和输出形状以及图像值范围，如要点 2 所示。</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ob oc l"/></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">要点 2——用于<code class="fe nb nc nd ne b">BatchData</code>检查的 Python 代码</p></figure><p id="4a99" class="pw-post-body-paragraph ll lm it ln b lo mw ju lq lr mx jx lt ky my lv lw lc mz ly lz lg na mb mc md im bi translated">根据要点 2 的规定，<em class="me">批量= 32 </em>。因此，输入<code class="fe nb nc nd ne b">image_batch</code>是一个<code class="fe nb nc nd ne b">(32, 64, 64, 3)</code>张量，其中图像是<code class="fe nb nc nd ne b"><em class="me">64 (height) x 64 (width) x 3 (RGB channels)</em></code>。每个图像都有一个对应的<strong class="ln iu">整数标签</strong>用于类别识别，因此<code class="fe nb nc nd ne b">label_batch</code>的形状为<code class="fe nb nc nd ne b">(32)</code>。</p></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="6dbe" class="kp kq it bd kr ks kt dn ku kv kw dp kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">预处理</h2><p id="17aa" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt ky lu lv lw lc lx ly lz lg ma mb mc md im bi translated">数据预处理是指为建立和训练机器学习模型准备原始数据。随后，卷积神经网络(CNN)模型执行欧洲卫星土地覆盖分类。</p><p id="37ea" class="pw-post-body-paragraph ll lm it ln b lo mw ju lq lr mx jx lt ky my lv lw lc mz ly lz lg na mb mc md im bi translated">输入图像是张量，可解释为 8 位无符号整数(十进制 0 到 255)的 NumPy 数组。因此，r <strong class="ln iu"> escaling </strong>从 0–255 到 0–1<strong class="ln iu">T32】的值提高了性能和训练稳定性。</strong></p><p id="6ae2" class="pw-post-body-paragraph ll lm it ln b lo mw ju lq lr mx jx lt ky my lv lw lc mz ly lz lg na mb mc md im bi translated">Keras 提供了一个<code class="fe nb nc nd ne b"><a class="ae mv" href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/Rescaling" rel="noopener ugc nofollow" target="_blank">Rescaling</a></code> <strong class="ln iu">预处理层</strong>，它将输入值修改为一个新的范围。使用下面的 Python 代码定义该图层。</p><pre class="mg mh mi mj gt od ne oe of aw og bi"><span id="6425" class="kp kq it ne b gy oh oi l oj ok">rescaling_layer = layers.experimental.preprocessing.<strong class="ne iu">Rescaling</strong>(<br/>    <strong class="ne iu">scale</strong>=1. / 255,<br/>    <strong class="ne iu">input_shape</strong>=(img_height, img_width, 3)<br/>)</span></pre><p id="b42a" class="pw-post-body-paragraph ll lm it ln b lo mw ju lq lr mx jx lt ky my lv lw lc mz ly lz lg na mb mc md im bi translated">输入图像的每个值都乘以<code class="fe nb nc nd ne b">scale</code>。</p></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="2564" class="kp kq it bd kr ks kt dn ku kv kw dp kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">模型架构</h2><p id="6865" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt ky lu lv lw lc lx ly lz lg ma mb mc md im bi translated">随着预处理的完成和 CNN 训练可接受格式的数据，下一步是定义<strong class="ln iu">网络架构</strong>。图 3 图示了<em class="me">六层</em>模型架构。</p><blockquote class="ng nh ni"><p id="4af3" class="ll lm me ln b lo mw ju lq lr mx jx lt nj my lv lw nk mz ly lz nl na mb mc md im bi translated">当计算 CNN 网络的深度时，我们只考虑具有可调/可训练权重/参数的层。⁵</p></blockquote><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi ol"><img src="../Images/a753ce53d2e04c08a061329a984c5b49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j5bTQItCm3cu33av3_bj7g.png"/></div></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">图 3-土地覆盖分类的卷积神经网络结构(图片由作者提供)</p></figure><p id="3073" class="pw-post-body-paragraph ll lm it ln b lo mw ju lq lr mx jx lt ky my lv lw lc mz ly lz lg na mb mc md im bi translated">基本张量流 CNN 模型通常采用相同的元素。这些层包括:</p><ul class=""><li id="3625" class="nn no it ln b lo mw lr mx ky np lc nq lg nr md ns nt nu nv bi translated"><code class="fe nb nc nd ne b"><a class="ae mv" href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/Conv2D" rel="noopener ugc nofollow" target="_blank">Conv2D</a></code>层<em class="me">幻灯片</em> <strong class="ln iu">内核</strong> <em class="me">，</em>例如八个<em class="me">滤波器</em>以给定的<em class="me">步距</em>穿过输入图像<em class="me"> (3x3)，</em>提取适合于解决分类问题的特征。通过<strong class="ln iu">卷积</strong>操作，或者更准确地说是<em class="me">互相关</em>来进行特征提取。过滤器在模型编译期间被随机初始化。<br/> <em class="me">通过反向传播学习滤波器参数，在训练网络时提取输入图像的本质特征。</em></li><li id="a380" class="nn no it ln b lo nw lr nx ky ny lc nz lg oa md ns nt nu nv bi translated"><code class="fe nb nc nd ne b"><a class="ae mv" href="https://keras.io/api/layers/pooling_layers/max_pooling2d/" rel="noopener ugc nofollow" target="_blank">MaxPooling2D</a></code>层对像素组进行操作，例如<em class="me">(2 x2)</em><em class="me"/>，并通过<strong class="ln iu">选择最大值</strong>来过滤值。汇集<em class="me">在保持特征信息的同时，对输入图像尺寸进行向下采样</em>。<em class="me">填充</em>可维持或减缓空间尺寸的缩小；然而，“<code class="fe nb nc nd ne b">valid</code>就是没有填充的意思。</li><li id="bce2" class="nn no it ln b lo nw lr nx ky ny lc nz lg oa md ns nt nu nv bi translated"><code class="fe nb nc nd ne b"><a class="ae mv" href="https://keras.io/api/layers/core_layers/dense/" rel="noopener ugc nofollow" target="_blank">Dense</a></code> : <em class="me">“只是你的正则密连 NN 层”。</em></li></ul><p id="4ac5" class="pw-post-body-paragraph ll lm it ln b lo mw ju lq lr mx jx lt ky my lv lw lc mz ly lz lg na mb mc md im bi translated">Gist 3 给出了定义<strong class="ln iu">tensor flow</strong><code class="fe nb nc nd ne b">Sequential</code><em class="me">CNN</em>模型的 Python 代码。</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ob oc l"/></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">Gist 3 —使用 Python 中的 Keras 定义的 CNN 架构</p></figure><p id="a8e6" class="pw-post-body-paragraph ll lm it ln b lo mw ju lq lr mx jx lt ky my lv lw lc mz ly lz lg na mb mc md im bi translated">模型编译<code class="fe nb nc nd ne b">model.compile()</code>包括定义:</p><ul class=""><li id="9fb6" class="nn no it ln b lo mw lr mx ky np lc nq lg nr md ns nt nu nv bi translated"><code class="fe nb nc nd ne b">optimiser=’adam’</code> : <a class="ae mv" href="https://keras.io/api/optimizers/adam/" rel="noopener ugc nofollow" target="_blank"> <strong class="ln iu"> Adam </strong> </a>是一种<em class="me">随机梯度下降(SGD) </em> <strong class="ln iu">优化</strong>方法，其本质上是<em class="me">基于损失函数的反向传播输出来更新可训练参数</em>。</li><li id="cb32" class="nn no it ln b lo nw lr nx ky ny lc nz lg oa md ns nt nu nv bi translated"><code class="fe nb nc nd ne b">loss=’<strong class="ln iu">SparseCategoricalCrossentropy</strong></code>':计算标签和预测之间的交叉熵<strong class="ln iu">损失</strong>。<code class="fe nb nc nd ne b"><a class="ae mv" href="https://www.tensorflow.org/api_docs/python/tf/keras/losses/SparseCategoricalCrossentropy" rel="noopener ugc nofollow" target="_blank">SparseCategoricalCrossentropy</a></code>损失适用于标签类别计数≥2，以整数提供。由于模型<em class="me">不</em>包含一个<em class="me"> softmax 层</em>作为最后一层，<code class="fe nb nc nd ne b">from_logits=True</code>是必要的，以指示概率没有被归一化。⁴</li><li id="2720" class="nn no it ln b lo nw lr nx ky ny lc nz lg oa md ns nt nu nv bi translated"><code class="fe nb nc nd ne b">metrics=[‘<a class="ae mv" href="https://www.tensorflow.org/api_docs/python/tf/keras/metrics/Accuracy" rel="noopener ugc nofollow" target="_blank"><strong class="ln iu">accuracy</strong></a>’]</code>:计算预测等于标签的频率，并用于评估训练期间的模型性能。</li></ul><p id="8c31" class="pw-post-body-paragraph ll lm it ln b lo mw ju lq lr mx jx lt ky my lv lw lc mz ly lz lg na mb mc md im bi translated">参见本文<a class="ae mv" href="https://medium.com/@andrewdaviesul/chain-rule-differentiation-log-loss-function-d79f223eae5" rel="noopener">文章</a>确定如何推导分类应用的二元(0 或 1)交叉熵损失函数。</p><div class="om on gp gr oo op"><a href="https://medium.com/@andrewdaviesul/chain-rule-differentiation-log-loss-function-d79f223eae5" rel="noopener follow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">二元交叉熵分类损失函数的推导</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">逻辑回归机器学习任务中使用的对数损失函数的导数。</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">medium.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd mp op"/></div></div></a></div><p id="5e59" class="pw-post-body-paragraph ll lm it ln b lo mw ju lq lr mx jx lt ky my lv lw lc mz ly lz lg na mb mc md im bi translated">图 4 是<code class="fe nb nc nd ne b">model.summary()</code>的输出。层、输出形状和参数计数与图 3 中所示的等效。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi pe"><img src="../Images/f85e3359db47cf6997f56d71db5a0ddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z9KG7GooAhPq8uh9pG03xw.png"/></div></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">图 4——CNN 模型总结(图片由作者提供)</p></figure></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="b6ec" class="kp kq it bd kr ks kt dn ku kv kw dp kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">培养</h2><p id="ca44" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt ky lu lv lw lc lx ly lz lg ma mb mc md im bi translated">训练可以使用下面的 Python 代码开始，因为训练/验证数据在 TensorFlow <code class="fe nb nc nd ne b">BatchDatasets</code>结构和定义的模型架构中。</p><pre class="mg mh mi mj gt od ne oe of aw og bi"><span id="8b06" class="kp kq it ne b gy oh oi l oj ok"># number of training cycles<br/>epochs = 15</span><span id="dddd" class="kp kq it ne b gy pf oi l oj ok"># trains the model for 15 iterations on the dataset<br/>history = <strong class="ne iu">model.fit</strong>(<br/>    train_dataset,<br/>    validation_data=validation_dataset,<br/>    epochs=epochs<br/>)</span><span id="0059" class="kp kq it ne b gy pf oi l oj ok"># save model<br/>model.save(f'{os.getcwd()}/land_cover_model')</span></pre><p id="4ffc" class="pw-post-body-paragraph ll lm it ln b lo mw ju lq lr mx jx lt ky my lv lw lc mz ly lz lg na mb mc md im bi translated">许多网络<strong class="ln iu">超参数</strong>，如<em class="me">学习率、<em class="me">历元数</em>、<em class="me">批量</em>、<em class="me">隐含层数和单元数、</em>都是<strong class="ln iu">通过试错调整</strong>。尝试使用不同的超参数来提高分类性能。</em></p><p id="417c" class="pw-post-body-paragraph ll lm it ln b lo mw ju lq lr mx jx lt ky my lv lw lc mz ly lz lg na mb mc md im bi translated">图 5 是<strong class="ln iu">装配</strong>期间<strong class="ln iu">控制台日志</strong>输出的片段。它显示了定型数据集和验证数据集的损失。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi pg"><img src="../Images/bd6a95f0eb4e3e610f276e408d114b4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Kl37lICy9oFY-qHo9heEQ.png"/></div></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">图 5 —模型拟合的详细输出(图片由作者提供)</p></figure><p id="632a" class="pw-post-body-paragraph ll lm it ln b lo mw ju lq lr mx jx lt ky my lv lw lc mz ly lz lg na mb mc md im bi translated">图 6 绘出了感兴趣的训练<em class="me">度量</em>，训练和验证<strong class="ln iu">精度</strong>，以及训练和验证<strong class="ln iu">损失</strong>。随着时间的推移，网络通过反向传播学习合适的<code class="fe nb nc nd ne b">Conv2D</code>过滤器权重，以最小化损失，随着损失的减少，模型的准确性增加。</p><p id="a1a7" class="pw-post-body-paragraph ll lm it ln b lo mw ju lq lr mx jx lt ky my lv lw lc mz ly lz lg na mb mc md im bi translated">最终的训练和验证准确率分别约为<strong class="ln iu"> 90% </strong>和<strong class="ln iu">86%</strong>。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi ph"><img src="../Images/b29bd6893018f1cffa840564b665526a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mErNjBv_fTbCWSvkFLmAnQ.png"/></div></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">图 6 —培训和验证指标的图表(图片由作者提供)</p></figure></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="8274" class="kp kq it bd kr ks kt dn ku kv kw dp kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">预言；预测；预告</h2><p id="1ef4" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt ky lu lv lw lc lx ly lz lg ma mb mc md im bi translated">在训练土地覆盖分类网络之后，进一步的测试通常是有价值的。如前所述，数据集的一个保存部分(约为<em class="me"> 20% </em>)保留下来，用于对<strong class="ln iu">不可见数据</strong>进行额外评估。</p><p id="c92e" class="pw-post-body-paragraph ll lm it ln b lo mw ju lq lr mx jx lt ky my lv lw lc mz ly lz lg na mb mc md im bi translated">首先，使用与图 3 中相同的代码加载数据集，除了更新后的 path 变量指向测试文件夹。使用以下命令从磁盘加载<strong class="ln iu">预训练的 Keras 模型</strong>:</p><pre class="mg mh mi mj gt od ne oe of aw og bi"><span id="6e65" class="kp kq it ne b gy oh oi l oj ok"># load keras model and print summary<br/>model = keras.models.load_model('path/to/model')<br/>model.summary()</span></pre><p id="1e02" class="pw-post-body-paragraph ll lm it ln b lo mw ju lq lr mx jx lt ky my lv lw lc mz ly lz lg na mb mc md im bi translated">随着模型加载到内存中，可以进行<strong class="ln iu">预测</strong>。Gist 4 详细描述了用于迭代<em class="me">测试图像</em>的<code class="fe nb nc nd ne b">BatchDataset</code>并进行预测的 Python 代码。</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ob oc l"/></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">要点 4——用于<code class="fe nb nc nd ne b">BatchDataset Iteration</code>预测的 Python 代码(图片由作者提供)</p></figure><p id="041e" class="pw-post-body-paragraph ll lm it ln b lo mw ju lq lr mx jx lt ky my lv lw lc mz ly lz lg na mb mc md im bi translated">对于每个推理<code class="fe nb nc nd ne b">model.predict()</code>返回与每个类别相关联的类别可能性的概率的<em class="me">数组。概率指数最高的是模型的整数标签预测，<code class="fe nb nc nd ne b">argmax()</code>提取这个位置。</em></p><p id="0155" class="pw-post-body-paragraph ll lm it ln b lo mw ju lq lr mx jx lt ky my lv lw lc mz ly lz lg na mb mc md im bi translated">图 7 显示的是 CNN 的预测。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi pi"><img src="../Images/8dfbd4ae74071ebb068f7f38b16657a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tbAe4n66cVUrvFQ-WGhwMw.png"/></div></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">图 7-CNN 土地覆盖等级预测(图片由作者提供)</p></figure></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="5f16" class="kp kq it bd kr ks kt dn ku kv kw dp kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">估价</h2><p id="875e" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt ky lu lv lw lc lx ly lz lg ma mb mc md im bi translated">一个<strong class="ln iu">混淆矩阵</strong>是一个评估分类准确度<em class="me">的可用度量。</em>通过一个模型预测类列表、<code class="fe nb nc nd ne b">y_pred</code>和一个实际类别列表，SciKit-Learn Python 库<code class="fe nb nc nd ne b">y_true</code>具有一个内置函数来快速计算矩阵。</p><p id="2528" class="pw-post-body-paragraph ll lm it ln b lo mw ju lq lr mx jx lt ky my lv lw lc mz ly lz lg na mb mc md im bi translated">图 8 是从测试数据集的预测中生成的混淆矩阵。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi pj"><img src="../Images/4fc77b5c817b768e735fa78b2f1c0b1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8rXPs4NVllLnD6Ha3jaaow.png"/></div></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">图 8-土地覆被混淆矩阵(图片由作者提供)</p></figure><p id="c453" class="pw-post-body-paragraph ll lm it ln b lo mw ju lq lr mx jx lt ky my lv lw lc mz ly lz lg na mb mc md im bi translated">矩阵的每个<strong class="ln iu">行</strong>表示<strong class="ln iu">实际</strong>类，而每个<strong class="ln iu"> <em class="me">列</em> </strong>描述了<strong class="ln iu"> <em class="me">预测</em> </strong>类。</p><ul class=""><li id="56cc" class="nn no it ln b lo mw lr mx ky np lc nq lg nr md ns nt nu nv bi translated">True Positive ( <strong class="ln iu"> TP </strong>):标识正确预测的类。TPs 位于实际值和预测值交点处的矩阵对角线上。</li><li id="e636" class="nn no it ln b lo nw lr nx ky ny lc nz lg oa md ns nt nu nv bi translated">True Negative ( <strong class="ln iu"> TN </strong>):指定正确预测的负类。TNs 是所有列和行的值的总和，不包括当前类。</li><li id="f463" class="nn no it ln b lo nw lr nx ky ny lc nz lg oa md ns nt nu nv bi translated"><em class="me">误报</em> ( <strong class="ln iu"> FP </strong>):误报类，当前列的和减去 TP 值</li><li id="fe00" class="nn no it ln b lo nw lr nx ky ny lc nz lg oa md ns nt nu nv bi translated"><em class="me">假阴性</em> ( <strong class="ln iu"> FN </strong>):一个错误预测的阴性类，除 TP 值外对应的类行总和</li></ul><p id="a55e" class="pw-post-body-paragraph ll lm it ln b lo mw ju lq lr mx jx lt ky my lv lw lc mz ly lz lg na mb mc md im bi translated">以<code class="fe nb nc nd ne b">River</code>类为例，图 9 描绘了度量细目:<strong class="ln iu"> <em class="me"> TP = 15 </em> </strong>，<strong class="ln iu"> <em class="me"> TN = 350 </em> </strong>，<strong class="ln iu"> <em class="me"> FP = 5 </em> </strong>和<strong class="ln iu"> <em class="me"> FN = 10 </em> </strong> <em class="me">。</em></p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi pk"><img src="../Images/cb3ad2a29e7c2bb04bab50bc6086984b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v9IbOx6ENIxp5QloTgPS9w.png"/></div></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">图 9-河流等级的混淆矩阵分解(图片由作者提供)</p></figure><p id="ab4b" class="pw-post-body-paragraph ll lm it ln b lo mw ju lq lr mx jx lt ky my lv lw lc mz ly lz lg na mb mc md im bi translated">最初，可以预见的是<code class="fe nb nc nd ne b">Highway</code>组和<code class="fe nb nc nd ne b">River</code>组之间的混乱。根据混淆矩阵，模型<em class="me">错误地将</em> f <em class="me"> ive 河流标注为高速公路(</em> <strong class="ln iu"> <em class="me">漏报</em> </strong> <em class="me">)。</em>同样，<em class="me">两条高速公路被误划为河流(</em> <strong class="ln iu"> <em class="me">误报</em> </strong> <em class="me"> ) </em>。</p><p id="5439" class="pw-post-body-paragraph ll lm it ln b lo mw ju lq lr mx jx lt ky my lv lw lc mz ly lz lg na mb mc md im bi translated">总的来说，预测<strong class="ln iu">精度</strong>在<strong class="ln iu"> 86% </strong>左右，如图 8 所示，并且在训练期间确定的预期值附近。准确度的提高当然是可能的。<em class="me">欧洲卫星 paper⁷ </em>报告高<em class="me">九十</em>范围内的性能指标值。<strong class="ln iu">实验</strong>用 CNN 网络架构和超参数调谐来增强结果。</p></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="4fe0" class="kp kq it bd kr ks kt dn ku kv kw dp kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">结论</h2><p id="d581" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt ky lu lv lw lc lx ly lz lg ma mb mc md im bi translated"><em class="me">本文展示了如何用 Python 实现卷积神经网络，用于卫星影像土地覆盖分类。</em></p><p id="c312" class="pw-post-body-paragraph ll lm it ln b lo mw ju lq lr mx jx lt ky my lv lw lc mz ly lz lg na mb mc md im bi translated">找到下面使用的所有 Python 代码。感谢阅读。</p><div class="om on gp gr oo op"><a href="https://medium.com/@andrewdaviesul/membership" rel="noopener follow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">通过我的推荐链接加入媒体-安德鲁·约瑟夫·戴维斯</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">medium.com</p></div></div><div class="oy l"><div class="pl l pa pb pc oy pd mp op"/></div></div></a></div></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="00fc" class="kp kq it bd kr ks kt dn ku kv kw dp kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">CNN 培训的 Python 代码(要点 5)</h2><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ob oc l"/></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">Gist 5 — CNN 土地覆盖分类培训</p></figure><h2 id="17c7" class="kp kq it bd kr ks kt dn ku kv kw dp kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">CNN 预测的 Python 代码(要点 6)</h2><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ob oc l"/></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">要点 5 — CNN 对土地覆盖分类的预测</p></figure></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="886f" class="kp kq it bd kr ks kt dn ku kv kw dp kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">参考</h2><p id="f397" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt ky lu lv lw lc lx ly lz lg ma mb mc md im bi translated">[1] <a class="ae mv" href="https://arxiv.org/abs/1709.00029" rel="noopener ugc nofollow" target="_blank"> Eurosat:土地利用和土地覆盖分类的新型数据集和深度学习基准</a>。帕特里克·赫尔伯，本杰明·比斯克，安德烈亚斯·登格尔，达米安·博斯。IEEE 应用地球观测与遥感选题期刊，2019<br/>【2】<a class="ae mv" href="https://www.tensorflow.org/datasets/catalog/eurosat" rel="noopener ugc nofollow" target="_blank">euros at | tensor flow 数据集</a>(2022 年 2 月)<br/>【3】<a class="ae mv" href="https://serc.carleton.edu/research_education/geopad/georeferencing.html" rel="noopener ugc nofollow" target="_blank">地理配准</a> —用 GeoPads 教学<br/>【4】<a class="ae mv" href="https://datascience.stackexchange.com/questions/73093/what-does-from-logits-true-do-in-sparsecategoricalcrossentropy-loss-function" rel="noopener ugc nofollow" target="_blank">from _ logits = True 在 SparseCategoricalcrossEntropy loss 函数中做什么？</a> —数据科学栈交换(2020 年 4 月)<br/>【5】<a class="ae mv" href="https://stackoverflow.com/a/65061642/12040795" rel="noopener ugc nofollow" target="_blank">统计 CNN 层数</a>。ran mal de wage—stack overflow<br/>【6】<a class="ae mv" href="https://github.com/phelber/EuroSAT" rel="noopener ugc nofollow" target="_blank">EuroSAT 公开可用数据集</a>—GitHub.com<br/>【7】<a class="ae mv" href="https://ieeexplore.ieee.org/document/8519248" rel="noopener ugc nofollow" target="_blank">介绍 euros at:一种新型数据集和深度学习基准，用于土地利用和土地覆盖分类</a>。帕特里克·赫尔伯，本杰明·比斯克，安德烈亚斯·登格尔。2018 IEEE 国际地球科学与遥感研讨会，2018。</p></div></div>    
</body>
</html>