<html>
<head>
<title>Two Ways to Build Your Own Custom Scikit Learn Transformers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">两种方法来建立自己的自定义Scikit学习变形金刚</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/2-ways-to-build-your-own-custom-scikit-learn-transformers-a8aeefbf8bf8#2022-10-17">https://towardsdatascience.com/2-ways-to-build-your-own-custom-scikit-learn-transformers-a8aeefbf8bf8#2022-10-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8054" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何(以及为什么应该)创建定制的变压器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/072bf65d366f9225e8d339304facad25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hiiAEX2hkhhv_Ke1"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@eugen1980?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">欧根·斯特伦</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="0cef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Scikit学习转换器(不要与深度学习转换器混淆)是Scikit学习包中的类，有助于给定数据集中的转换。</p><p id="c76f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些转换器可以执行各种操作，如归一化和主成分分析。但是，某些情况下可能需要使用所提供的工具无法执行的操作。</p><p id="f6f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这种情况，用户可以选择创建满足其特定需求的自定义函数。然而，对于机器学习应用程序来说，有一个更好的选择:创建定制的转换器。</p><p id="2e1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们探索在Scikit中使用定制转换器而不是定制函数的好处——了解并回顾用户创建它们的两种不同方式。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="1f91" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">为什么要定制变压器(相对于函数)？</h2><p id="b51b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Scikit学习变压器设计高效。他们实现了<code class="fe na nb nc nd b">fit</code>方法和<code class="fe na nb nc nd b">transform</code>方法，前者从训练集获得所需的模型参数，后者使用这些模型参数来转换训练集和测试集。</p><p id="dc99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，Scikit Learn包提供了Pipeline和ColumnTransformer之类的类。这些工具与变压器携手并进，使用户能够构建一个整洁有序的特征工程程序。</p><p id="1ec6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自定义函数的主要问题是它们不能集成到前面提到的许多Scikit学习工具中。结果，用户将被迫以一种既低效又容易出错的方式把这些功能硬塞到他们的特征工程过程中。</p><p id="d7ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个更好的选择是使用定制转换器执行定制操作。这将确保它们可以通过管道等工具与其他变压器一起使用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="1fb8" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">你真的需要定制变压器吗？</h2><p id="0251" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">下一个要考虑的问题是，您是否首先需要一个定制的转换器。Scikit学习包可能没有您需要的转换器，但这并不意味着您必须额外工作来创建自己的转换器。</p><p id="86eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有许多专门研究与Scikit Learn兼容的特征工程的开源Python包，如<a class="ae ky" href="https://feature-engine.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> feature_engine </a>和<a class="ae ky" href="https://contrib.scikit-learn.org/category_encoders/" rel="noopener ugc nofollow" target="_blank"> category_encoders </a>包。这些软件包提供了自己的一套变压器，可以满足您的需求。</p><p id="316b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在你开始考虑编写任何额外的代码之前，要彻底地探索所有可用的工具。从长远来看，稍微挖掘一下可以省去你很多麻烦。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="6fec" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">在Scikit-Learn中创建自定义转换器</h2><p id="fe1f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">创建一个transformer的想法可能看起来令人望而生畏，但是由于Scikit Learn包的巨大特性，它几乎不需要任何努力。</p><p id="c4cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于那些希望构建自己的定制转换器的人来说，有两个主要的选择。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="05d6" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">选项1 -使用FunctionTransformer</h2><p id="e6d4" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Scikit学习模块提供了<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.FunctionTransformer.html" rel="noopener ugc nofollow" target="_blank"> FunctionTransformer </a>类，顾名思义，该类将函数转换成转换器。此外，转换是通过一个简单的一行程序实现的！</p><p id="fd5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">FunctionTransformer可用于将预先存在的numpy或pandas函数转换为转换器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="9758" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还可以用于将自定义函数转换为转换器。如果感兴趣的函数需要参数，可以在<code class="fe na nb nc nd b">kw_args</code>参数中输入。</p><p id="dd88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们想要创建一个将所有值乘以给定数字的转换器，我们可以创建一个执行该任务的函数，然后将其转换为转换器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="ade4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦该函数被转换成一个转换器，它就拥有了<code class="fe na nb nc nd b">fit</code>和<code class="fe na nb nc nd b">transform</code>方法，这使得它很容易与其他转换器一起使用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="219d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，FunctionTransformer有一个明显的限制。</p><p id="cacd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，它不存储用于拟合训练数据的参数，这对于某些需要保留模型参数的操作来说可能是一个问题，例如规范化和一次热编码。</p><p id="3424" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为可能很难将这个缺陷概念化，所以使用一个例子将是有益的。我们可以使用通过转换<code class="fe na nb nc nd b">pandas.get_dummies</code>函数创建的转换器对数据集执行一次性编码。</p><p id="0325" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有以下数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/aaa37ba80bdc3569d7609e3d774b1379.png" data-original-src="https://miro.medium.com/v2/resize:fit:204/format:webp/1*88HQYb2YrkLSzuzVboNdUQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><p id="f106" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以将<code class="fe na nb nc nd b">get_dummies</code>函数转换成一个转换器，然后使用它的<code class="fe na nb nc nd b">fit_transform</code>方法对数据进行编码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/2b47f45f11cd0e76db9c0a80e1062dfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*TSUHqeXEb35Xe_qoS3g8Bw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><p id="a5b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出显示列“水果_苹果”和“水果_香蕉”。为了使转换器可行，它需要在处理不可见数据时生成相同的列。</p><p id="5493" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们的变压器是这样吗？它将如何处理以下包含不可见数据的数据集？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/2ccce1e69bdaed5efe8f54e743fb5226.png" data-original-src="https://miro.medium.com/v2/resize:fit:236/format:webp/1*eezKD-h9d0lhethAEVhCIA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/72a0f3e2eeac2d82d1b5be6c5704c69f.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*1lUysxTweDRO4i5uon2Ntw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><p id="bdef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转换器现在生成“Fruit_Blueberry”和“Fruit_Strawberry”列，它们与定型集的输出不匹配。这是因为新列来自测试数据，而不是定型数据。</p><p id="7a07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，我在另一篇文章中讨论了这个难题的解决方案:</p><div class="nl nm gp gr nn no"><a rel="noopener follow" target="_blank" href="/why-you-shouldnt-use-pandas-get-dummies-for-machine-learning-e088a435beef"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">为什么不应该用pandas.get_dummies进行机器学习</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">反对用熊猫做热门编码的理由</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">towardsdatascience.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc ks no"/></div></div></a></div><p id="a6cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总而言之，FunctionTransformer类是一种将函数转换为转换器的简单方法，但对于必须保留来自训练数据的参数的情况，它并不理想。</p><h2 id="a179" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">选项2—从头开始创建Scikit学习转换器</h2><p id="7049" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">第二种选择是从头开始创建一个转换器。同样，这种前景并不像看起来那么具有挑战性。</p><p id="b269" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说明这种方法的最好方式是用一个例子。</p><p id="c93c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们正在构建一个转换器，通过将少数类别转换成一个特定的类别来解决高基数(即，太多的唯一值)问题。</p><p id="ea2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变压器将利用以下模块:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="5bae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们可以创建名为<code class="fe na nb nc nd b">ReplaceMinority</code>的类。为此，我们需要继承两个导入的基类<code class="fe na nb nc nd b">BaseEstimator</code>和<code class="fe na nb nc nd b">TransformMixin</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="8ca8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们需要用<code class="fe na nb nc nd b">__init__</code>构造函数初始化属性。这个转换器将有<code class="fe na nb nc nd b">threshold</code>参数和<code class="fe na nb nc nd b">replace_with</code>参数，前者规定了非少数民族类别的最小比例，后者规定了少数民族应该被替换的类别。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="8f27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们可以创建<code class="fe na nb nc nd b">fit</code>方法。对于这个应用程序，我们需要输入数据，并记录给定数据框中每一列的所有非少数类别。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="ed01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们可以创建<code class="fe na nb nc nd b">transform</code>方法。在这里，我们用每列的<code class="fe na nb nc nd b">replace_with</code>参数中的参数替换所有少数类别，并返回结果数据集。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="dca8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！</p><p id="0fd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们把所有的东西放在一起，这就是这个类的样子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="9c4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那并不需要太多的工作，不是吗？</p><p id="238c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来测试一下变压器。假设我们有一个水果数据集，其中有几个少数群体。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/536dc5fbd31d75e88dbf44a8a4854550.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*9jwQbH7U3_KJfc4xc0mMqQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><p id="2d32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过使用这个转换器将少数民族替换为“其他水果”来减少独特类别的数量。</p><p id="0ca0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个<code class="fe na nb nc nd b">ReplaceMinority</code>对象，然后使用<code class="fe na nb nc nd b">fit_transform</code>方法将少数民族替换为“其他水果”。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/08d89faba3cff295f35be116eeed5065.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*zcwnVq9HloGIbS2Md5UHOg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><p id="74eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，变形金刚已经将“苹果”和“香蕉”识别为非少数民族。所有其他水果都换成了“其他水果”。这导致唯一值的数量减少。</p><p id="362e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转换器现在将根据训练数据中的参数处理任何看不见的数据。我们可以通过转换测试集数据来证明这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/00c6f5f77be1893e32689bfa0248ba7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:192/format:webp/1*z505intpDboWxrakUy06CQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><p id="7269" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅在测试集中，<em class="og">没有一个</em>类别是少数，但是转换器已经将“苹果”和“香蕉”识别为唯一的非少数类别，因此任何其他类别都将被替换为“其他水果”。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/83238fd2da6de922a59ace5c5ab96db6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*2qo6jqAN3mfM-v1kDOT63A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><p id="a0c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们可以将新的转换器嵌入到Scikit学习管道中。在这里，我们可以用一个<code class="fe na nb nc nd b">OneHotEncoder</code>对象来链接它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="ac1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，从零开始构建一个转换器使用户能够为更具体的用例执行过程。它还使用户能够基于来自训练集的参数来转换测试集。然而，这种方法更费时，而且容易出错。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="1f55" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">结论</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/8a2e563dbcdfab10a4de40b232bab5ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MstxjcDvlYBLUr0h"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@prateekkatyal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Prateek Katyal </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="1832" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，Scikit Learn transformers功能强大，因为它们的效率以及与Pipeline和ColumnTransformer等工具的兼容性。为了保持这种效率，最好坚持使用与Scikit Learn功能工程兼容的变压器。</p><p id="cb3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果Scikit Learn中没有一个变形金刚可以完成这项工作，请探索其他兼容的软件包。如果所需的转换器不可用，您可以选择将自定义函数转换为转换器，或者从头开始创建自己的Scikit Learn转换器。</p><p id="7f98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我祝你在数据科学的努力中好运！</p></div></div>    
</body>
</html>