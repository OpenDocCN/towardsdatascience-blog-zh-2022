<html>
<head>
<title>The Next Big Thing in Python: Data Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的下一件大事:数据类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/all-you-need-to-start-coding-with-data-classes-db421bf78a64#2022-12-30">https://towardsdatascience.com/all-you-need-to-start-coding-with-data-classes-db421bf78a64#2022-12-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2f74" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">全面了解 Python 中的数据类基础知识</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/46e7260f84ceac8f66d8824ce53e22aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kzsi5sbiAu2XNp7O"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@tmwsiy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> J Gowell </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="3e27" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">什么是数据类？</h1><p id="b426" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">数据类是 Python 版内置的一项新功能。它们提供了装饰器和函数来创建更简单、更方便、更安全的类，这些类主要用于处理数据，因此得名。</p><p id="7913" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">数据类的一个主要好处是，它们会自动为你生成几个特殊的方法，比如<code class="fe ms mt mu mv b">__init__</code>、<code class="fe ms mt mu mv b">__repr__</code>和<code class="fe ms mt mu mv b">__eq__</code>。当定义主要用于处理数据的类时，这可以为您节省大量时间和冗余代码。</p><p id="4109" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">数据类的另一个主要好处是使用了强类型，这可以确保定义实例的属性。这是通过使用类型注释来实现的，类型注释允许您在定义类时指定每个属性的类型。这可以防止由于类型不明确而导致的错误，也使代码更容易被其他开发人员理解。</p><h1 id="8b67" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">如何使用数据类</h1><p id="b7c8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">要使用数据类，首先需要从<code class="fe ms mt mu mv b">dataclasses</code>模块导入 dataclass 装饰器。这个装饰器是 Python 3.7 和更高版本中固有的。</p><p id="0eec" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用数据类非常简单。只需用<code class="fe ms mt mu mv b">@dataclass</code>装饰器装饰你的类定义来定义一个数据类。</p><p id="7557" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下面是一个带有默认参数的简单数据类的示例:</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="53dd" class="na la it mv b be nb nc l nd ne">from dataclasses import dataclass, field<br/><br/>@dataclass<br/>class Point:<br/>    x: float<br/>    y: float<br/><br/>p = Point(1.0, 2.0)<br/>print(p)  # Output: Point(x=1.0, y=2.0)</span></pre><p id="d892" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们定义了一个带有两个字段<code class="fe ms mt mu mv b">x</code>和<code class="fe ms mt mu mv b">y</code>的<code class="fe ms mt mu mv b">Point</code>数据类，这两个字段都是浮点数。当您创建一个<code class="fe ms mt mu mv b">Point</code>类的实例时，您可以指定<code class="fe ms mt mu mv b">x</code>和<code class="fe ms mt mu mv b">y</code>的值作为构造函数的参数。</p><p id="5296" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">默认情况下，数据类将为您生成一个<code class="fe ms mt mu mv b">__init__</code>方法，该方法将类的字段作为参数。它们还将生成一个返回对象的字符串表示的<code class="fe ms mt mu mv b">__repr__</code>方法，这是在上面的例子中调用<code class="fe ms mt mu mv b">print(p)</code>时输出的内容。</p><p id="55ad" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您可以通过传递额外的参数来自定义由装饰器生成的方法，例如<em class="nf"> repr=False </em>来停用<code class="fe ms mt mu mv b">__repr__</code>方法。</p><h1 id="2041" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">场函数</h1><p id="3cfd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">您还可以通过使用<code class="fe ms mt mu mv b">field()</code>函数的<code class="fe ms mt mu mv b">default</code>和<code class="fe ms mt mu mv b">default_factory</code>参数来指定数据类字段的默认值。</p><p id="a399" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">例如:</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="28f7" class="na la it mv b be nb nc l nd ne">@dataclass<br/>class Point:<br/>    x: float = 0.0<br/>    y: float = field(default=0.0)<br/><br/>p1 = Point(x=1.0, y=2.0)<br/>print(p1)  # Output: Point(x=1.0, y=2.0)<br/><br/>p2 = Point(1.0)<br/>print(p2)  # Output: Point(x=1.0, y=0.0)</span></pre><p id="4a62" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这个例子中，我们定义了一个具有两个字段<code class="fe ms mt mu mv b">x</code>和<code class="fe ms mt mu mv b">y</code>的<code class="fe ms mt mu mv b">Point</code>类。x 字段的默认值为 0.0，直接在字段定义中指定，而 y 字段的默认值为 0.0，使用<code class="fe ms mt mu mv b">field()</code>函数指定。</p><p id="343e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当我们创建一个<code class="fe ms mt mu mv b">Point</code>类的实例时，我们可以指定<code class="fe ms mt mu mv b">x</code>和<code class="fe ms mt mu mv b">y</code>的值作为构造函数的参数。如果我们没有为<code class="fe ms mt mu mv b">y</code>指定一个值，它将使用默认值 0.0。</p><p id="5aaf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在数据类内部，指定默认值的两种用法对于<strong class="lt iu">不可变的</strong>属性是等效的。</p><p id="d6a9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，<code class="fe ms mt mu mv b">field()</code>函数允许更多的灵活性和额外的选项来定义属性。</p><h2 id="c6ab" class="ng la it bd lb nh ni dn lf nj nk dp lj ma nl nm ll me nn no ln mi np nq lp nr bi translated">字段 repr 和 init 参数</h2><p id="cad6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">事实上，<code class="fe ms mt mu mv b">field()</code>函数将默认参数<code class="fe ms mt mu mv b">__repr__</code>和<code class="fe ms mt mu mv b">__init__</code>设置为<em class="nf">真</em>。我们可以将这些设置为<em class="nf">假</em>来修改它们的行为。</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="e445" class="na la it mv b be nb nc l nd ne">@dataclass<br/>class Point:<br/>    x: float = field(default=0.0, repr=False)<br/>    y: float = field(default=0.0, init=False)<br/><br/>p1 = Point(3.0) <br/>print(p1) # Output: Point(y=0.0)<br/>p2 = Point(3.0, 2.0) # TypeError: Point.__init__() takes from 1 to 2 positional arguments but 3 were given</span></pre><p id="23aa" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在第一个例子中，实例<code class="fe ms mt mu mv b">p1</code>没有在其字符串表示中显示<code class="fe ms mt mu mv b">x</code>的值，这对于隐藏临时或敏感变量(至少从字符串表示中)是有用的。</p><p id="d2f5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在第二个例子中，实例<code class="fe ms mt mu mv b">p2</code>不能被创建，因为 init 参数被设置为 False，我们试图初始化<code class="fe ms mt mu mv b">y</code>变量。这对于只应由方法返回的变量很有用。让我们向我们的数据类添加一个方法，该方法仅使用<code class="fe ms mt mu mv b">y</code>作为函数<code class="fe ms mt mu mv b">compute_y_with_x</code>中计算的输出:</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="1742" class="na la it mv b be nb nc l nd ne">@dataclass<br/>class Point:<br/>    x: float = field(default=0.0, repr=False)<br/>    y: float = field(default=0.0, init=False)<br/>    def compute_y_with_x(self):<br/>        self.y = self.x ** 2<br/><br/>p2 = Point(x=2.0)<br/>p2.compute_y_with_x()<br/>print(p2) # Output: Point(y=4.0)</span></pre><p id="0498" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里，我们注意到<code class="fe ms mt mu mv b">p2</code>使用<code class="fe ms mt mu mv b">y</code>作为未初始化的变量(<em class="nf"> init=False </em>)，这是我们的输入变量<code class="fe ms mt mu mv b">x</code>转换的结果。我们不关心初始化后的<code class="fe ms mt mu mv b">x</code>，所以我们移除了它的字符串表示<em class="nf"> (repr=False)。</em></p><h2 id="aedc" class="ng la it bd lb nh ni dn lf nj nk dp lj ma nl nm ll me nn no ln mi np nq lp nr bi translated">默认工厂字段</h2><p id="21a2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">你还记得我们讨论过使用类的默认参数或者用默认参数设置一个字段对不可变的对象有同样的影响，但是对可变的对象没有影响吗？</p><p id="29a9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们看一个例子，我们试图初始化一个<strong class="lt iu">可变</strong>对象的属性，比如一个列表。我们还将创建一个方法，允许我们将元素添加到名为<code class="fe ms mt mu mv b">add_a_dimension</code>的列表中:</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="a23f" class="na la it mv b be nb nc l nd ne">@dataclass<br/>class Points:<br/>    coord: list = field(default=[])<br/>    def add_a_dimension(self, element):<br/>        self.coord.append(element)<br/># Output: ValueError</span></pre><p id="af9c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个类不能被构造，因为如上所述，“不允许对字段<coord>使用可变默认值(比如列表)。”这是由数据类添加的安全措施，对于防止我们在常规类中可能遇到的错误非常有用。</coord></p><p id="ad47" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">事实上，如果我们想使用一个常规类来定义<code class="fe ms mt mu mv b">Points</code>数据类，它将完全等同于:</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="eb6b" class="na la it mv b be nb nc l nd ne">class Points:<br/>    coord = []<br/>    def __init__(self, coord=coord):<br/>        self.coord = coord<br/>    def add_a_dimension(self, element):<br/>        self.coord.append(element)</span></pre><p id="d8f7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">而且我们在定义这个类的时候不会有任何错误！然而，如果我们使用一个常规类以这种方式定义该类，我们会看到意想不到的行为:</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="f581" class="na la it mv b be nb nc l nd ne">p1 = Points()<br/>p2 = Points()<br/>p1.coord, p2.coord # Output: ([],[])<br/>p1.add_a_dimension(3)</span></pre><p id="2226" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">好了，我们实例化了一个空列表，并将 3 添加到实例<code class="fe ms mt mu mv b">p1</code>中。你认为现在<code class="fe ms mt mu mv b">p1.coord</code>和<code class="fe ms mt mu mv b">p2.coord</code>的价值会是多少？</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="ae59" class="na la it mv b be nb nc l nd ne">p1.coord, p2.coord # Output: ([3], [3])</span></pre><p id="d0b0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">难以置信，实例<code class="fe ms mt mu mv b">p2</code>也受到了列表附加 3 的影响！</p><p id="2f54" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是因为在 Python 中，当你创建一个类的实例时，这个实例将共享类属性的同一个<em class="nf">副本</em>。因为列表<strong class="lt iu">是可变的</strong>，所以<code class="fe ms mt mu mv b">p1</code>和<code class="fe ms mt mu mv b">p2</code>将共享<code class="fe ms mt mu mv b">coord</code>列表的相同副本。</p><p id="80c3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了正确地实现这个类以避免这种意外的结果，数据类为被称为<code class="fe ms mt mu mv b">default_factory</code>的<code class="fe ms mt mu mv b">field()</code>提供了参数。</p><p id="1fac" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">该参数允许您指定一个函数，每次创建一个新的类实例时，都会调用该函数为字段<em class="nf">创建一个新的默认值。这确保了类的每个实例都有它自己唯一的字段副本</em>，而不是共享同一个<em class="nf">可变</em>对象。</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="eaac" class="na la it mv b be nb nc l nd ne">@dataclass<br/>class Points:<br/>    coord: list = field(default_factory=lambda: [])<br/>    def add_a_dimension(self, element):<br/>        self.coord.append(element)<br/>p1 = Points()<br/>p2 = Points()<br/>p1.coord, p2.coord # Output ([], [])</span></pre><p id="85e4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">值得注意的是，即使我们将一个可变列表定义为<code class="fe ms mt mu mv b">coord</code>的默认值，也没有<em class="nf"> ValueError </em>。</p><p id="538c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们只在一个实例上调用<code class="fe ms mt mu mv b">add_a_dimension</code>方法后检查输出:</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="8b60" class="na la it mv b be nb nc l nd ne">p1.add_a_dimension(3)<br/>p1.coord, p2.coord # Output ([3], [])</span></pre><p id="34fc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">啊，我们终于有了想要的结果！实例<code class="fe ms mt mu mv b">p2</code>未被实例<code class="fe ms mt mu mv b">p1</code>调用的方法更改。正是因为每个实例都有其<em class="nf">字段<code class="fe ms mt mu mv b">coord</code>的唯一副本</em>。</p><p id="b95e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正如我们所见，数据类通过正确处理可变和不可变对象来提供安全性。</p><h1 id="fc0b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">遗产</h1><p id="c615" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">要考虑的最后一点是数据类如何处理继承。默认情况下，数据类没有一个<code class="fe ms mt mu mv b">__init__</code>方法，所以需要一个允许您覆盖继承属性的方法。这个方法叫做<code class="fe ms mt mu mv b">__post_init__</code>，在实例初始化之后调用。</p><p id="3ee1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里有一个例子来帮助说明这个概念:</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="6a6d" class="na la it mv b be nb nc l nd ne">@dataclass<br/>class Point:<br/>    x: float = field(default=0.0)<br/>    y: float = field(default=0.0)<br/>    <br/>    def __post_init__(self):<br/>        self.x = self.x ** 2<br/>        self.y = self.y ** 2<br/><br/>@dataclass<br/>class ColoredPoint(Point):<br/>    color: str = field(default='black')<br/>    <br/>    def __post_init__(self):<br/>        self.color = self.color.upper()</span></pre><p id="ef2c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这个例子中，<code class="fe ms mt mu mv b">Point</code>类有一个<code class="fe ms mt mu mv b">__post_init__</code>方法，它对<code class="fe ms mt mu mv b">x</code>和<code class="fe ms mt mu mv b">y</code>的值求平方。<code class="fe ms mt mu mv b">ColoredPoint</code>类继承自<code class="fe ms mt mu mv b">Point</code>，也有自己的<code class="fe ms mt mu mv b">__post_init__</code>方法，该方法大写<code class="fe ms mt mu mv b">color</code>属性的值。</p><p id="8aee" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们创建一个<code class="fe ms mt mu mv b">Point</code>的实例:</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="9422" class="na la it mv b be nb nc l nd ne">p0 = Point(2.0,2.0)<br/>print(p0) # Output: Point(x=4.0, 4.0)</span></pre><p id="26b8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们从输出中注意到，调用了<code class="fe ms mt mu mv b">__post_init__</code>方法，并且<code class="fe ms mt mu mv b">x</code>和<code class="fe ms mt mu mv b">y</code>的值都是平方的。</p><p id="5e5b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在让我们创建一个<code class="fe ms mt mu mv b">ColoredPoint</code>的实例:</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="0d91" class="na la it mv b be nb nc l nd ne">p1 = ColoredPoint(2.0, 2.0, 'red')<br/>print(p1) # Output: ColoredPoint(x=2.0, y=2.0, color='RED')</span></pre><p id="beb1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">创建<code class="fe ms mt mu mv b">ColoredPoint</code>的实例时，调用了<code class="fe ms mt mu mv b">__post_init__</code>方法，并且<code class="fe ms mt mu mv b">color</code>的值是大写的，但是<code class="fe ms mt mu mv b">x</code>和<code class="fe ms mt mu mv b">y</code>的值不是平方的，知道为什么吗？</p><p id="2f2f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是因为我们<code class="fe ms mt mu mv b">ColoredPoint</code>的<code class="fe ms mt mu mv b">__post_init__</code>方法中没有调用<code class="fe ms mt mu mv b">Point</code>的<code class="fe ms mt mu mv b">__post_init__</code>方法！</p><p id="780b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要调用基类的<code class="fe ms mt mu mv b">__post_init__</code>方法，可以使用<code class="fe ms mt mu mv b">super()</code>函数，该函数返回对基类的引用。以下是<code class="fe ms mt mu mv b">ColoredPoint</code>的修正版:</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="8643" class="na la it mv b be nb nc l nd ne">@dataclass<br/>class ColoredPoint(Point):<br/>    color: str = field(default='red')<br/><br/>    def __post_init__(self):<br/>        super().__post_init__()<br/>        self.color = self.color.upper()<br/>p2 = ColoredPoint(2.0, 2.0, 'red')<br/>print(p2) # Output: ColoredPoint(x=4.0, y=4.0, color='RED')</span></pre><p id="57e2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">随着这一改变，当创建<code class="fe ms mt mu mv b">ColoredPoint</code>的实例时，将调用<code class="fe ms mt mu mv b">Point</code>类的<code class="fe ms mt mu mv b">__post_init__</code>方法，并且<code class="fe ms mt mu mv b">x</code>和<code class="fe ms mt mu mv b">y</code>的值将如预期的那样平方。</p><p id="4f1f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我很高兴能够帮助您了解数据类。如您所见，数据类提供了常规类的增强版本，更加安全并强调强类型。我希望您对自己在未来项目中使用数据类的能力更有信心。</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><p id="f62a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">无需额外费用，您可以通过我的推荐链接订阅 Medium。</p><div class="nz oa gp gr ob oc"><a href="https://medium.com/@arli94/membership" rel="noopener follow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">通过我的推荐链接加入 Medium—Arli</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">阅读 Arli 和媒体上成千上万的其他作家的每一个故事。你的会员费直接支持 Arli 和…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">medium.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq ks oc"/></div></div></a></div><p id="a7b5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="nf">或者你可以在收件箱里收到我所有的帖子。</em><strong class="lt iu"><em class="nf"/></strong><a class="ae ky" href="https://arli94.medium.com/subscribe" rel="noopener"><strong class="lt iu"><em class="nf">在这里做</em> </strong> <em class="nf">！</em>T15】</a></p></div></div>    
</body>
</html>