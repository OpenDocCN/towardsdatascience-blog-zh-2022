<html>
<head>
<title>Autoencoders (AE) — A Smart Way to Process Your Data Using Unsupervised Neural Networks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动编码器(AE)——一种使用无监督神经网络处理数据的智能方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/autoencoders-ae-a-smart-way-to-process-your-data-using-unsupervised-neural-networks-9661f93a8509#2022-03-21">https://towardsdatascience.com/autoencoders-ae-a-smart-way-to-process-your-data-using-unsupervised-neural-networks-9661f93a8509#2022-03-21</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="3bbd" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph">神经网络</h2><div class=""/><div class=""><h2 id="42f9" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">什么是 Autoencoder，如何用 Python 构建一个？</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/428b76af88b44684555933545be22523.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JgMGbqdPXCpDjfbQWzyAzQ.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">欠完整自动编码器。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者、</a>使用<a class="ae li" href="http://alexlenail.me/NN-SVG/index.html" rel="noopener ugc nofollow" target="_blank"> AlexNail 的 NN-SVG 工具</a>创建。</p></figure><h1 id="f6a8" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">介绍</h1><p id="80e5" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">自动编码器提供了一种有效的方式来学习数据的表示，它侧重于信号，而不是噪声。您可以将它们用于各种任务，例如:</p><ul class=""><li id="a1c5" class="mx my iu md b me mz mh na mk nb mo nc ms nd mw ne nf ng nh bi translated">降维</li><li id="5580" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated">特征抽出</li><li id="43b8" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated">数据/图像去噪</li><li id="02b6" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated">输入缺失数据</li></ul><p id="290b" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nn mm mn mo no mq mr ms np mu mv mw in bi translated">本文将简要介绍自动编码器(AE)，并深入探讨一种称为<strong class="md je">的特定类型，Undercomplete Autoencoder </strong>，适用于降维和特征提取。</p><p id="d2be" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nn mm mn mo no mq mr ms np mu mv mw in bi translated">同时，我未来的文章将涵盖其他种类，如<a class="ae li" rel="noopener" target="_blank" href="/vae-variational-autoencoders-how-to-employ-neural-networks-to-generate-new-images-bdeb216ed2c0">变分</a>、<a class="ae li" rel="noopener" target="_blank" href="/denoising-autoencoders-dae-how-to-use-neural-networks-to-clean-up-your-data-cd9c19bc6915">去噪</a>和<a class="ae li" rel="noopener" target="_blank" href="/sparse-autoencoder-neural-networks-how-to-utilise-sparsity-for-robust-information-encoding-6aa9ff542bc9">稀疏自动编码器</a>。所以，<a class="ae li" href="https://bit.ly/3sItbfx" rel="noopener ugc nofollow" target="_blank">订阅</a>不要错过我以后的任何帖子。</p><h1 id="4e6e" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">内容</h1><ul class=""><li id="7c49" class="mx my iu md b me mf mh mi mk nq mo nr ms ns mw ne nf ng nh bi translated">自动编码器在机器学习算法领域中的地位</li><li id="4a5b" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated">自动编码器是如何构造的，它们是如何工作的？</li><li id="be56" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated">一个完整的 Python 示例，展示了如何使用 Keras/Tensorflow 在 Python 中构建自动编码器。</li></ul><h1 id="19c1" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">自动编码器在机器学习领域的地位</h1><p id="4a3d" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">下面的图表是我对最常见的机器学习算法进行分类的尝试。</p><p id="8723" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nn mm mn mo no mq mr ms np mu mv mw in bi translated">虽然我们经常以<strong class="md je">监督</strong>的方式使用带有标签的训练数据的神经网络，但我们也可以以<strong class="md je">非监督或自我监督的方式</strong>使用它们，例如通过使用<strong class="md je">自动编码器</strong>。因此，我觉得神经网络的普遍性和它们对机器学习的独特方法值得一个单独的类别。</p><p id="bb08" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nn mm mn mo no mq mr ms np mu mv mw in bi translated">下图是<strong class="md je">互动，</strong>所以请点击不同的类别<strong class="md je">放大并展示更多</strong>👇。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="nt nu l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">机器学习算法分类。由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>创建的互动图表。</p></figure><p id="b418" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nn mm mn mo no mq mr ms np mu mv mw in bi translated"><strong class="md je"> <em class="nv">如果你喜欢数据科学和机器学习</em> </strong> <em class="nv">，请</em> <a class="ae li" href="https://bit.ly/3sItbfx" rel="noopener ugc nofollow" target="_blank"> <em class="nv">订阅</em> </a> <em class="nv">获取我的新文章的邮件。如果你不是中等会员，可以在这里</em>  <em class="nv">加入</em> <a class="ae li" href="https://bit.ly/3ueQFbR" rel="noopener ugc nofollow" target="_blank"> <em class="nv">。</em></a></p><h1 id="1ffa" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">自动编码器是如何构造的，它们是如何工作的？</h1><p id="555a" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">让我们从下图中显示的高级视图开始，查看每个部分。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj nw"><img src="../Images/c5488f2bcf2c771d36973da30e3efbee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1JwnlfIm4MmlFcPH5QaUIg.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">自动编码器神经网络中各层的高级图示。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><ul class=""><li id="f5dd" class="mx my iu md b me mz mh na mk nb mo nc ms nd mw ne nf ng nh bi translated">自动编码器具有类似于其他类型的神经网络的输入、隐藏和输出层。</li><li id="2348" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated">自动编码器的隐藏层包含两个重要部分:<strong class="md je">编码器</strong>和<strong class="md je">解码器</strong>。</li><li id="ab76" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated">自动编码器中的输出节点与输入节点相匹配。因此，自动编码器神经网络试图重新创建它在输入层接收到的相同特征值。</li><li id="b476" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated">因为我们试图重建(预测)特征本身，所以我们不需要带标签的目标数据。因此，我们可以将自动编码器称为<strong class="md je">无监督</strong>模型，尽管一些文献将它们称为<strong class="md je">自监督</strong>模型。</li></ul><h2 id="7034" class="nx lk iu bd ll ny nz dn lp oa ob dp lt mk oc od lv mo oe of lx ms og oh lz ja bi translated"><strong class="ak">自动编码器的类型</strong></h2><p id="84a3" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">每层中节点数量之间的关系决定了自动编码器的类型，例如:</p><ul class=""><li id="97bf" class="mx my iu md b me mz mh na mk nb mo nc ms nd mw ne nf ng nh bi translated"><strong class="md je">欠完整自动编码器</strong>(本文的重点)——与输入和输出层相比，中间的节点(维度)较少。在这样的设置中，我们倾向于称中间层为“瓶颈”</li><li id="96aa" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated"><strong class="md je">过完全自动编码器</strong> —与输入和输出层相比，中间有更多的节点(维度)。</li></ul><h2 id="953c" class="nx lk iu bd ll ny nz dn lp oa ob dp lt mk oc od lv mo oe of lx ms og oh lz ja bi translated">有什么意义？</h2><p id="9fba" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">关键问题是，为什么我们要通过神经网络传递数据，以获得与我们作为输入输入到网络中的输出值相同的输出值？</p><p id="133c" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nn mm mn mo no mq mr ms np mu mv mw in bi translated">在欠完整自动编码器的情况下，我们将信息压缩到更少的维度中(因此成为瓶颈),同时试图确保我们仍然可以回到原始值。因此，我们正在创建一个压缩数据的自定义函数，这是一种降低维度并提取有意义信息的方法。</p><p id="3325" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nn mm mn mo no mq mr ms np mu mv mw in bi translated">在训练欠完整自动编码器之后，我们通常<strong class="md je">丢弃解码器</strong>并且只有<strong class="md je">使用编码器</strong>部分。</p><p id="9cc1" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nn mm mn mo no mq mr ms np mu mv mw in bi translated">现在，让我们使用 Keras functional API 在 Python 中构建一个 Autoencoder 来实现这些例子。</p><div class="kt ku kv kw gu ab cb"><figure class="oi kx oj ok ol om on paragraph-image"><a href="https://solclover.com/membership"><img src="../Images/63320331b74bd98eea6402472b4209ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*qkXay39OnVc2IosW6rkxtw.png"/></a></figure><figure class="oi kx oj ok ol om on paragraph-image"><a href="https://www.linkedin.com/in/saulius-dobilas/"><img src="../Images/60fb21d1cb2701bfb6b71f61c99403e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*vabxOXtQ4T034N_mscHSmQ.png"/></a></figure></div><h1 id="eedc" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated"><strong class="ak">如何用 Python 构建 Autoencoder？</strong></h1><p id="3fa8" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">我们将构建一个欠完整的自动编码器，它有 17 个输入和输出节点，我们在“瓶颈”层将它们压缩到 8 个。这是我们将要创建的神经网络的层和连接的图形:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj oo"><img src="../Images/23a1aae577d9029cf3b7234893c0e6ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cc-HFI93fc3mc56YWPn95A.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">欠完整自动编码器。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>，使用<a class="ae li" href="http://alexlenail.me/NN-SVG/index.html" rel="noopener ugc nofollow" target="_blank"> AlexNail 的 NN-SVG 工具</a>创建。</p></figure><h2 id="3f67" class="nx lk iu bd ll ny nz dn lp oa ob dp lt mk oc od lv mo oe of lx ms og oh lz ja bi translated">设置</h2><p id="1810" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">我们需要获得以下数据和库:</p><ul class=""><li id="8579" class="mx my iu md b me mz mh na mk nb mo nc ms nd mw ne nf ng nh bi translated"><a class="ae li" href="https://www.kaggle.com/jsphyg/weather-dataset-rattle-package" rel="noopener ugc nofollow" target="_blank">澳大利亚天气数据来自 Kaggle </a>(许可:<a class="ae li" href="http://www.bom.gov.au/other/copyright.shtml?ref=ftr" rel="noopener ugc nofollow" target="_blank"> Creative Commons </a>，数据原始来源:<a class="ae li" href="http://www.bom.gov.au/climate/data/" rel="noopener ugc nofollow" target="_blank">澳大利亚联邦气象局</a>)。</li><li id="7601" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated"><a class="ae li" href="https://pandas.pydata.org/docs/" rel="noopener ugc nofollow" target="_blank">熊猫</a>进行数据操作</li><li id="32e0" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated"><a class="ae li" href="https://matplotlib.org/stable/api/index.html" rel="noopener ugc nofollow" target="_blank"> Matplotlib </a>和<a class="ae li" href="https://graphviz.org/" rel="noopener ugc nofollow" target="_blank"> Graphviz </a>用于一些基本的可视化</li><li id="035d" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated"><a class="ae li" href="https://scikit-learn.org/stable/index.html" rel="noopener ugc nofollow" target="_blank">sci kit-学习库</a>用于特征缩放(<a class="ae li" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html" rel="noopener ugc nofollow" target="_blank">最小最大缩放器</a>)和拆分数据(<a class="ae li" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html" rel="noopener ugc nofollow" target="_blank"> train_test_split </a></li><li id="99b6" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated"><a class="ae li" href="https://www.tensorflow.org/api_docs/python/tf" rel="noopener ugc nofollow" target="_blank"> Tensorflow/Keras </a>用于构建和自动编码神经网络</li></ul><p id="a905" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nn mm mn mo no mq mr ms np mu mv mw in bi translated">让我们导入库:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="op nu l"/></div></figure><p id="7b4b" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nn mm mn mo no mq mr ms np mu mv mw in bi translated">上面的代码打印了我在这个例子中使用的包版本:</p><pre class="kt ku kv kw gu oq or os ot aw ou bi"><span id="4b83" class="nx lk iu or b gz ov ow l ox oy">Tensorflow/Keras: 2.7.0<br/>pandas: 1.3.4<br/>sklearn: 1.0.1<br/>matplotlib: 3.5.1<br/>graphviz: 0.19.1</span></pre><p id="3410" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nn mm mn mo no mq mr ms np mu mv mw in bi translated">接下来，下载并摄取澳大利亚的天气数据(来源:<a class="ae li" href="https://www.kaggle.com/jsphyg/weather-dataset-rattle-package" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>)。此外，我们执行一些简单的数据操作，并派生出一个名为“RainTodayFlag”的附加变量。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="op nu l"/></div></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj oz"><img src="../Images/6fce7428bda5c161d54ece4026e80d3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C7cJ7SUyZ0TL5OW-H5EdAg.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">一小段<a class="ae li" href="https://www.kaggle.com/jsphyg/weather-dataset-rattle-package" rel="noopener ugc nofollow" target="_blank"> Kaggle 的澳大利亚天气数据</a>做了一些修改。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="066b" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nn mm mn mo no mq mr ms np mu mv mw in bi translated">对于最后的数据准备步骤，我们将把数据添加到一个数组中，应用最小-最大缩放，并把它分成训练和测试样本。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="op nu l"/></div></figure><h2 id="da0c" class="nx lk iu bd ll ny nz dn lp oa ob dp lt mk oc od lv mo oe of lx ms og oh lz ja bi translated"><strong class="ak">建立并训练一个自动编码器模型</strong></h2><p id="26f6" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">我们将使用功能性的 Keras API，它允许我们在定义模型结构时有更大的灵活性。它还可以在训练模型后轻松丢弃解码器部分，仅保留编码器部分。</p><p id="5486" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nn mm mn mo no mq mr ms np mu mv mw in bi translated">下面的代码组装了模型并打印出摘要和图表。我们的 X_train 数据中的特征数量是 17。因此，我们将有 17 个输入节点和 17 个输出节点。隐藏层将由编码器和解码器组成，每个编码器和解码器有 17 个节点，瓶颈有 8 个节点。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="op nu l"/></div></figure><p id="77fc" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nn mm mn mo no mq mr ms np mu mv mw in bi translated">上面的代码打印了两项内容。第一个是模型总结:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pa"><img src="../Images/18e643ad9ba9ffba609d9c069e1c282b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P3m2edKPTzoX-JJetMkYsA.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">自动编码器型号摘要。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="c582" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nn mm mn mo no mq mr ms np mu mv mw in bi translated">第二部分是看待模型结构的一种略微不同的方式，有些人更喜欢这种方式:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pb"><img src="../Images/9031aee3ecc5a26c72d381e5f0fd007c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EgSCTvKKxh1-bMCUaKkpgw.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">自动编码器模型图。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="f34d" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nn mm mn mo no mq mr ms np mu mv mw in bi translated">请注意，我们使用了批处理归一化，它应用了一个变换，使平均输出接近 0，输出标准偏差接近 1。虽然这不是强制性的，但它通常有助于模型性能。</p><p id="61df" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nn mm mn mo no mq mr ms np mu mv mw in bi translated">组装好模型后，让我们对其进行十个时期的训练，并绘制损失图。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="op nu l"/></div></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pc"><img src="../Images/69f7faa081c0b35435d823b6c9a0d7a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TVXOmG9-0k6T_IXB6mth-A.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">自动编码器按历元的模型丢失。图片作者<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>。</p></figure><p id="87a8" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nn mm mn mo no mq mr ms np mu mv mw in bi translated">我们可以看到，我们的自动编码器模型能够以最小的损失重建数据。</p><p id="2115" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nn mm mn mo no mq mr ms np mu mv mw in bi translated">最后一部分将编码器和解码器分离，并保存模型。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="op nu l"/></div></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pb"><img src="../Images/f5ddf9ba2511f77501df2fade859fba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6VBiWFiTu0ex1FW-pILKEg.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">编码器模型图。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="6966" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nn mm mn mo no mq mr ms np mu mv mw in bi translated">如果需要，您也可以通过在新的解码器模型中更改<code class="fe pd pe pf or b">inputs = bottlneck</code>和<code class="fe pd pe pf or b">outputs = output</code>以同样的方式保存解码器部分。</p><p id="8515" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nn mm mn mo no mq mr ms np mu mv mw in bi translated">无论何时您想要使用编码器模型，您都可以加载它，并以如下所示的方式应用它，它采用 17 个特征(维度)并将其减少到 8 个:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="op nu l"/></div></figure><h1 id="035e" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">结束语</h1><p id="2adf" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">您已经学习了如何构建、训练和保存自动编码器模型。您可以通过多种方式使用它，从对数据执行降维到提取用于监督模型训练的要素。</p><p id="24d8" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nn mm mn mo no mq mr ms np mu mv mw in bi translated">为了您的方便，我在我的<a class="ae li" href="https://github.com/SolClover/Art047_NN_Auto_Encoder" rel="noopener ugc nofollow" target="_blank"> GitHub 库</a>中保存了一个 Jupyter 笔记本，它构建了一个自动编码器模型，并使用编码的功能来训练一个受监督的天气预测模型。</p><p id="a1ff" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nn mm mn mo no mq mr ms np mu mv mw in bi translated">我真诚地希望这篇文章对你有所帮助。如果您有任何问题或建议，请随时联系我们。</p><p id="bd24" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nn mm mn mo no mq mr ms np mu mv mw in bi translated">干杯！🤓<br/> <strong class="md je">索尔·多比拉斯</strong></p></div><div class="ab cl pg ph hy pi" role="separator"><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl"/></div><div class="in io ip iq ir"><p id="8f97" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nn mm mn mo no mq mr ms np mu mv mw in bi translated"><strong class="md je"> <em class="nv">通过以下我的个性化链接加入 Medium，继续您的数据科学学习之旅</em> </strong> <em class="nv"/></p><div class="pn po gq gs pp pq"><a href="https://bit.ly/3ueQFbR" rel="noopener  ugc nofollow" target="_blank"><div class="pr ab fp"><div class="ps ab pt cl cj pu"><h2 class="bd je gz z fq pv fs ft pw fv fx jd bi translated">通过我的推荐链接加入 Medium 索尔·多比拉斯</h2><div class="px l"><h3 class="bd b gz z fq pv fs ft pw fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="py l"><p class="bd b dl z fq pv fs ft pw fv fx dk translated">solclover.com</p></div></div><div class="pz l"><div class="qa l qb qc qd pz qe lc pq"/></div></div></a></div></div></div>    
</body>
</html>