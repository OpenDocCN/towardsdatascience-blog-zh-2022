<html>
<head>
<title>How to Select Loss Function and Activation Function for Classification Problems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分类问题如何选择损失函数和激活函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-select-loss-function-and-activation-function-for-classification-problems-b7f32c724507#2022-04-14">https://towardsdatascience.com/how-to-select-loss-function-and-activation-function-for-classification-problems-b7f32c724507#2022-04-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ec30" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何选择神经网络最后一层的激活函数和损失函数</h2></div><p id="6a7f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">机器学习模型由遵循特定流程适应的数学过程组成。这需要一定的和谐与平衡。在构建模型时，从导入数据到评估结果的过程可能会有大量不同的组合。所以，机器学习，尤其是深度学习架构，可以称之为多种选择融合调和的数字艺术架构。深度学习粗略地产生前向传播和反向传播，意味着为了降低损失值而更新权重。本文介绍了如何在训练模型之前选择集合损失函数和激活函数变量。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/bf03e8b5f6db5af33b962d9fb987519f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cZC-iSUaaPWFJSDO"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">照片由<a class="ae lu" href="https://unsplash.com/@denisseleon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹尼斯·莱昂</a>在<a class="ae lu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="1d1d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在进入内容之前，先澄清问题类型和一些术语:</p><ul class=""><li id="8143" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld ma mb mc md bi translated"><strong class="kk iu">目标:</strong>输入的最终输出，例如，物种列是Iris数据集的目标。</li><li id="cd0d" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated"><strong class="kk iu">标签:</strong>输入的结果，例如，鸢尾、海滨鸢尾、杂色鸢尾是鸢尾数据集的标签。</li></ul><p id="24c6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">分类可以是:</p><ul class=""><li id="eee4" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld ma mb mc md bi translated"><strong class="kk iu">二元分类:</strong>目标中有2个标签。示例:[0]或[1]</li><li id="d533" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated"><strong class="kk iu">多类分类:</strong>有两个以上的目标，但只有一个标签被分配给一个输入。示例:[0 0 1]或[1 0 0]或[0 1 0]。</li><li id="9513" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated"><strong class="kk iu">多标签分类:</strong>有两个以上的目标，但一个输入可以分配多个标签。示例[ 1 1 0]或[1 0 1]或[0 1 1]</li></ul><h1 id="581a" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">激活功能</h1><p id="0541" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">如介绍中所述，模型的训练基于正向传播和反向传播。当从更广的角度来看该模型时，借助于设计的深度学习模型中的层提取的信息被转移到最终层用于分类过程。所选择的最终激活函数对于确定估计结果非常重要，这里的<a class="ae lu" href="https://7-hiddenlayers.com/wp-content/uploads/2020/06/NEURONS-IN-NUERAL-NETWORK.gif" rel="noopener ugc nofollow" target="_blank">是可视化</a>的链接。</p><p id="adb8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，最终层中神经元的数量和最终层中使用的激活函数是相关的。这种关系如下:</p><p id="f0ab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果是<strong class="kk iu">二元分类</strong>，即目标值集中只有2个标签:</p><h2 id="8d2c" class="ng mk it bd ml nh ni dn mp nj nk dp mt kr nl nm mv kv nn no mx kz np nq mz nr bi translated"><strong class="ak"> -逻辑/乙状结肠激活功能</strong></h2><p id="baa6" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">Sigmoid激活函数取0到1之间的值。值&lt;0.5 are assigned to 0, values &gt; 0.5被赋值为1，通过将它们与测试数据集进行比较来执行模型评估。</p><p id="4693" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于目标值将被分配给一个输入，<code class="fe ns nt nu nv b">model.add(Dense(1,activation = “sigmoid”))</code>用于最终层。该模型建立在包含2个标签(二进制分类)的<code class="fe ns nt nu nv b">breast_cancer dataset</code>之上，在下面的sklearn库中提供。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="ee39" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">前10个<code class="fe ns nt nu nv b">prediction</code>值是:</p><pre class="lf lg lh li gt ny nv nz oa aw ob bi"><span id="f38b" class="ng mk it nv b gy oc od l oe of">0.99996, 0.999997, 0.999995, 0.999813, 0.00298241, 5.99027e-06, 0.0589639, 0.985855, 0.999954, 8.34465e-07, 0.999944</span></pre><p id="98e8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而前10个<code class="fe ns nt nu nv b">y_test</code>值是:</p><pre class="lf lg lh li gt ny nv nz oa aw ob bi"><span id="3020" class="ng mk it nv b gy oc od l oe of">1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1</span></pre><p id="9dae" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里，阈值被设置为0.5，预测值被舍入为0或1。Sigmoid激活函数主要用于二分类问题。</p><h2 id="128f" class="ng mk it bd ml nh ni dn mp nj nk dp mt kr nl nm mv kv nn no mx kz np nq mz nr bi translated">- Softmax激活功能</h2><p id="610d" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">Softmax激活函数也采用0到1之间的值，这些值是矢量值，表示概率比。获得的矢量结果分别给出了输入的每个目标(标签)的概率。具有明显最高概率的结果被选为预测结果。当然，对于那个过程，数据集必须是多类的，这意味着一个热编码。</p><p id="6143" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于概率数据将被分配给每个目标值，<code class="fe ns nt nu nv b">model.add(Dense(10,activation = “softmax”))</code>被用于包括10个不同标签的数据集的最终层。以下是sklearn库中提供的数字数据集的示例:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="0aa3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在图1中，显示了一个截面的预测结果和已知的<code class="fe ns nt nu nv b">y_test</code>值。在下一步中，如代码块所示，通过使用<code class="fe ns nt nu nv b">np.argmax</code>确定每一行中的最大数据属于哪个目标来执行模型评估。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi og"><img src="../Images/db82cd5d0e9acf5074196859cb1e2ce9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o-eOHoOIiDEllmOXh8oT2Q.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">图一。y _测试值(左)和预测结果(右)，作者图片</p></figure><h2 id="f007" class="ng mk it bd ml nh ni dn mp nj nk dp mt kr nl nm mv kv nn no mx kz np nq mz nr bi translated"><strong class="ak"> - ReLu、Tanh等</strong></h2><p id="86ca" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">在最后一层中，出于上述原因，sigmoid和softmax是优选的。此外，有各种激活功能应用于模型中的层。其中一些可以在<a class="ae lu" href="https://en.wikipedia.org/wiki/Activation_function" rel="noopener ugc nofollow" target="_blank">维基百科链接</a>上找到。</p><p id="0cb0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> — ReLu </strong></p><p id="69dd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">整流线性激活单元是最优选的激活函数之一，因为它的消失梯度减小。虽然最小值为0，但最大值没有限制。</p><pre class="lf lg lh li gt ny nv nz oa aw ob bi"><span id="3128" class="ng mk it nv b gy oc od l oe of">the input&lt;0, output=0<br/>the input&gt;0, output=input</span></pre><p id="76ad" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在MLP和美国有线电视新闻网的模型中，它经常被首选。</p><p id="6fee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> — Tanh </strong></p><p id="2afb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它取值在-1和1之间。它类似于sigmoid激活函数，是递归神经网络(RNN)的首选。它相对于sigmoid激活函数的优点是，它是围绕中心= 0成形的，因为它取-1和1之间的值，对于sigmoid来说，相同的情况是0.5。这导致对下一层更有意义的学习。</p><h1 id="285f" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">损失函数</h1><h2 id="a20f" class="ng mk it bd ml nh ni dn mp nj nk dp mt kr nl nm mv kv nn no mx kz np nq mz nr bi translated"><strong class="ak">二元交叉熵</strong></h2><p id="817b" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">二元交叉熵考虑真实标签和预测标签的值来计算损失值。顾名思义，在第一个代码块中可以看到,<code class="fe ns nt nu nv b">binary_crossentropy</code>被用作损失函数来在二进制标签之间进行分类。使用通过sigmoid激活函数获得的概率估计结果和通过二进制交叉熵计算的损失来更新权重，然后进行训练。</p><h2 id="9268" class="ng mk it bd ml nh ni dn mp nj nk dp mt kr nl nm mv kv nn no mx kz np nq mz nr bi translated"><strong class="ak">分类交叉熵</strong></h2><p id="8e7c" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">在多类数据集中，概率结果作为阵列输出估计获得。这里用<code class="fe ns nt nu nv b">categorical_crossentropy</code>把这个分布训练成正确的方向。数学公式如下:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/907c8f91c79f46f3d89e4f740fb89178.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*7aFvgRLPQ1XhlMqS3L5ITg.png"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">图二。分类交叉熵的数学公式，作者图像</p></figure><h2 id="ab47" class="ng mk it bd ml nh ni dn mp nj nk dp mt kr nl nm mv kv nn no mx kz np nq mz nr bi translated">稀疏分类交叉熵</h2><p id="9514" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">它用于多个标签。分类交叉熵和稀疏分类交叉熵之间的主要区别在于，分类交叉熵用于一次性编码的目标([1 0 0]、[0 1 0]、[0 0 1])，而稀疏分类交叉熵用于编码的标签([0]、[1]、[2])。</p><p id="de45" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，在第二代码块中，标签被转换为(n_samples，10)，即标签-9对应于[0 0 0 0 0 0 0 0 0 0 0 0 0 0 1]，从而<code class="fe ns nt nu nv b">categorical_crossentropy</code>被用作损失函数。如果标签被转换为整数，即标签-9对应于[9]，则首选<code class="fe ns nt nu nv b">sparse_categorical_crossentropy</code>。</p><h1 id="d6ee" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="3248" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">深度学习架构不仅应该与使用的层保持一定的和谐，还应该与模型的编译保持一定的和谐。为了实现这种和谐，从数据集的维度开始，应该考虑模型的输出维度并做出选择。</p><p id="d485" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">如果问题是二元分类:</strong></p><ul class=""><li id="991f" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld ma mb mc md bi translated">在最后一层使用<code class="fe ns nt nu nv b">model.add(Dense(1,activation = “sigmoid”))</code>可以选择<code class="fe ns nt nu nv b">Binary_crossentropy</code>作为损耗。预测输出将是包括概率值的(n_test_samples，1)数组，并且选择0.5阈值将其设置为0或1。</li><li id="1a0e" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">或者，通过选择<code class="fe ns nt nu nv b">sparse_categorical_crossentropy</code>作为损耗，可以在最终层中使用<code class="fe ns nt nu nv b">model.add(Dense(2,activation = “softmax”))</code>。预测输出将是(n_test_samples，2)数组，其包括分别属于标签的概率值。然后，使用<code class="fe ns nt nu nv b">pred_labels = np.argmax(predictions, axis = 1)</code>，选择最大值，并通过与y_test比较进行模型评估。</li></ul><p id="960b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">如果问题是多类分类:</strong></p><ul class=""><li id="8d9d" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld ma mb mc md bi translated">目标值被转换为一键编码格式，并且在最后一层使用<code class="fe ns nt nu nv b">model.add(Dense(n_labels, activation = “softmax”))</code>可以选择<code class="fe ns nt nu nv b">categorical_crossentropy</code>作为损失。预测输出将是(n_test_samples，n_layers)，并且使用包括概率值和<code class="fe ns nt nu nv b">np.argmax(predictions, axis = 1)</code>的数组来确定最大值。</li><li id="988f" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">目标值被转换为整数(使用LabelEncoder)，然后在最后一层添加<code class="fe ns nt nu nv b">model.add(Dense(n_labels ,activation = “softmax”))</code>或<code class="fe ns nt nu nv b">model.add(Dense(n_labels ,activation = “sigmoid”))</code>，并设置损失函数<code class="fe ns nt nu nv b">sparse_categorical_crossentropy</code>。由于预测结果的形状将是(n_test_samples，n_labels)，因此可以通过使用<code class="fe ns nt nu nv b">np.argmax</code>选择最大概率，使用y_test值来评估模型。</li></ul><blockquote class="oi oj ok"><p id="ba02" class="ki kj ol kk b kl km ju kn ko kp jx kq om ks kt ku on kw kx ky oo la lb lc ld im bi translated">由于其性质，校正线性单元(ReLu)不能用作最终图层，而是应用于模型中的图层。</p></blockquote><blockquote class="op"><p id="7d4a" class="oq or it bd os ot ou ov ow ox oy ld dk translated">通过在python环境中使用上面的代码块尝试各种版本并观察维度，可以探索更多。</p></blockquote></div><div class="ab cl oz pa hx pb" role="separator"><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe"/></div><div class="im in io ip iq"><div class="lf lg lh li gt pg"><a href="https://ibrahimkovan.medium.com/machine-learning-guideline-959da5c6f73d" rel="noopener follow" target="_blank"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd iu gy z fp pl fr fs pm fu fw is bi translated">机器学习指南</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">所有与机器学习相关的文章</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">ibrahimkovan.medium.com</p></div></div><div class="pp l"><div class="pq l pr ps pt pp pu lo pg"/></div></div></a></div></div></div>    
</body>
</html>