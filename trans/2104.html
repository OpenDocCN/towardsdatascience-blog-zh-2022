<html>
<head>
<title>Building a Text Preprocessing Microservice with FastAPI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用FastAPI构建文本预处理微服务</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-text-preprocessing-microservice-with-fastapi-ca7912050ba#2022-05-11">https://towardsdatascience.com/building-a-text-preprocessing-microservice-with-fastapi-ca7912050ba#2022-05-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="24a0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用Python创建和分发一个简单的NLP应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ccef68eacee8db3b65ae77d32f4f544f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YQ83Hk0ddZ_Jfctm"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@timelabpro?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Timelab Pro </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="8be0" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="4b5f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">预处理是机器学习/数据科学应用中最重要的步骤之一。在现实世界中，大多数数据集都是脏的，有缺失值，并且充满了不正确的列，如字符串、日期和其他类型的非数字特征。</p><p id="ae00" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在常规应用程序中，原始数据主要在表格中，标准化、缩放和编码等方法对于机器学习模型正常工作至关重要。</p><p id="3e1f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在NLP(自然语言处理)应用中，预处理是一个更加关键的步骤，因为文本本来就是非数字、非结构化和杂乱的数据。因此，文本预处理通常包括一些常见的步骤，比如清理(删除特殊字符、标点符号、停用词等)和规范化(将文本转换成小写、词干化和词汇化)。</p><p id="1497" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">通常，这些步骤在不同的应用程序之间共享，而一个<em class="mp">微服务</em>可能是封装、分发和重用预处理功能的好方法。</p><p id="fc53" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">在这篇文章</strong>中，使用FastAPI库在Python中构建了一个简单的文本预处理API。在这个例子中，我们将使用RegEx(正则表达式)来规范化文本“噪声”，但是所提出的概念可以很容易地扩展到更复杂的应用程序。</p><h1 id="65db" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">在Python中查看正则表达式</h1><p id="bc03" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Regex是一个结构化的字符串，用来表达一个文本通用模式，该模式用于搜索文本中的术语。Regex是NLP 应用程序中一个非常强大的工具，绝对值得关注，但是这篇文章不会涉及它的所有实现细节，只涉及它的功能。</p><p id="adcb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如上所述，正则表达式是描述通用模式的字符串。例如，假设您有一个人与人之间交换的纯文本消息的数据库，您的任务是检索对话中引用的所有电子邮件地址。</p><p id="845c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">电子邮件地址是常见模式的一个很好的例子。它们都有一个“@”符号，并以点结束，如foo@email.com或bar_@emailx.edu.br。正则表达式允许我们以结构化的明确方式描述这种模式。对于这个例子，它将是这样的:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="fdcf" class="mv kx iq mr b gy mw mx l my mz">r"\w+\@\w+(?:\.\w+)+"</span></pre><blockquote class="na nb nc"><p id="b8d5" class="lo lp mp lq b lr mk jr lt lu ml ju lw nd mm lz ma ne mn md me nf mo mh mi mj ij bi translated">这个正则表达式并不完美，但它适用于大多数情况。</p></blockquote><p id="43bb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在Python中，我们可以使用原生regex模块对字符串执行搜索和替换。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">正则表达式查找所有电子邮件地址</p></figure><p id="b6a4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">输出:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="f7d8" class="mv kx iq mr b gy mw mx l my mz">&gt; ['<a class="ae kv" href="mailto:joaozinho@email.com" rel="noopener ugc nofollow" target="_blank">joaozinho@email.com</a>', '<a class="ae kv" href="mailto:john123@edu.us" rel="noopener ugc nofollow" target="_blank">john123@edu.us</a>']</span></pre><p id="ef7a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但是这对文本预处理有什么帮助呢？</p><p id="f836" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">通过使用replace函数，regex模块在文本规范化中非常有用。这个函数允许我们找到一个模式并用一些预定义的文本替换它。通过这样做，我们能够以更有意义的独特方式在文本中表示概念(这可以进一步提高ML模型的性能)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">正则表达式子示例</p></figure><p id="bd58" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">输出:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="cf23" class="mv kx iq mr b gy mw mx l my mz">This is a valid email address:  &lt;EMAIL&gt;  <br/>This is another valid email address:  &lt;EMAIL&gt;  <br/>This is not: antunes@@abc.br</span></pre><h1 id="31ba" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">什么是微服务？</strong></h1><p id="a9ae" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">一个<em class="mp">微服务</em>是一个小应用程序，负责系统上一个非常具体的任务。它独立运行，与其他应用程序隔离，并且在资源上也是自给自足的。</p><p id="5d2d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">微服务一旦运行，就可以通过API调用在其公开的端点上使用。我们将使用FastAPI来构建我们的微服务端点，FastAPI是一个Python web框架，可以用最少的代码轻松实现API。</p><p id="1509" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这篇文章也不会深入API和HTTP请求的所有细节，但是所提出的应用程序非常简单，应该很容易理解。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/d85221f3c96baede40375c4ede4c220d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*u1hYjKR1h7ITggYIK5ak5Q.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">微服务示例。图片作者。由<a class="ae kv" href="https://www.flaticon.com/free-icons/text" rel="noopener ugc nofollow" target="_blank"> Freepik </a>创作的图标。</p></figure><blockquote class="na nb nc"><p id="100c" class="lo lp mp lq b lr mk jr lt lu ml ju lw nd mm lz ma ne mn md me nf mo mh mi mj ij bi translated">提示:Docker是软件开发中必不可少的工具，并且与微服务的概念密切相关，因此值得一试。</p></blockquote><h1 id="6844" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">履行</h1><h2 id="8621" class="mv kx iq bd ky nj nk dn lc nl nm dp lg lx nn no li mb np nq lk mf nr ns lm nt bi translated">设置环境</h2><p id="3a52" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">首先要做的是创建一个隔离的python环境，只包含所需的依赖项。您可以使用Anaconda或PyEnv。</p><p id="f9cd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">创建环境后，安装以下软件包:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="daa0" class="mv kx iq mr b gy mw mx l my mz">fastapi<br/>uvicorn[standard]<br/>requests</span></pre><p id="8c8a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir"><em class="mp">uvicon【standard】</em></strong>:本地服务器托管API <br/> <strong class="lq ir">请求:</strong> Python库进行HTTP请求<br/><strong class="lq ir">FastAPI:</strong>FastAPI包</p><h2 id="a2d4" class="mv kx iq bd ky nj nk dn lc nl nm dp lg lx nn no li mb np nq lk mf nr ns lm nt bi translated">构建我们的第一个API端点</h2><p id="f8b4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们与API通信的方式是通过在其公开的端点上发出请求。在Web APIs的上下文中，端点在URL上公开。</p><p id="fe58" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">使用API服务的应用程序/个人被称为<em class="mp">客户端</em>，它可以通过HTTP请求(如GET、POST或PUT)与端点进行交互。这些请求中的每一个都有预定的行为。例如，GET可用于从数据库中检索一个条目，并提交以供插入。</p><p id="ac6c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">以下示例基于<a class="ae kv" href="https://fastapi.tiangolo.com/#example" rel="noopener ugc nofollow" target="_blank"> FastAPI官方页面</a>。用下面的代码创建一个文件<strong class="lq ir"> main.py </strong>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">API示例</p></figure><p id="e5db" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，在终端上运行:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="e515" class="mv kx iq mr b gy mw mx l my mz">uvicorn main:app --reload</span></pre><blockquote class="na nb nc"><p id="f8da" class="lo lp mp lq b lr mk jr lt lu ml ju lw nd mm lz ma ne mn md me nf mo mh mi mj ij bi translated">“reload”参数仅用于开发，不要用于生产。</p></blockquote><p id="f1cf" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在http://127.0.0.1:8000/上打开浏览器，您应该会看到以下响应:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="421d" class="mv kx iq mr b gy mw mx l my mz">{"Hello":"World"}</span></pre><p id="340c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">恭喜你，你已经构建了你的第一个API！</p><p id="3b62" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">那么，我们来了解一下是怎么回事。</p><ul class=""><li id="0262" class="nu nv iq lq b lr mk lu ml lx nw mb nx mf ny mj nz oa ob oc bi translated"><em class="mp"> app </em>变量引用将要运行的API应用程序；</li><li id="465f" class="nu nv iq lq b lr od lu oe lx of mb og mf oh mj nz oa ob oc bi translated">“uvicon main:app-reload”使用文件<em class="mp"> main中的变量<em class="mp"> app </em>启动服务器。</em></li><li id="0654" class="nu nv iq lq b lr od lu oe lx of mb og mf oh mj nz oa ob oc bi translated">默认情况下，API运行在端口为<em class="mp">=</em>8000(http://127 . 0 . 0 . 1:8000)<em class="mp">的<em class="mp">本地主机</em>上。这是根，这意味着所有的端点都是从它开始的路径，比如http://127 . 0 . 0 . 1:8000/do/something/</em></li><li id="f9ce" class="nu nv iq lq b lr od lu oe lx of mb og mf oh mj nz oa ob oc bi translated">当发出get请求时，<em class="mp"> decorator app.get("/") </em>将路径"/"链接到函数<em class="mp"> read_root </em>。<br/>这意味着当在http://127.0.0.1:8000/上发出GET请求时(注意末尾的“/”)，函数<em class="mp"> read_root </em>被调用，返回作为响应被发送回来。</li><li id="8188" class="nu nv iq lq b lr od lu oe lx of mb og mf oh mj nz oa ob oc bi translated">当您的浏览器打开http://127.0.0.1:8000/时，它在链接上发出GET请求并显示响应。</li></ul><h2 id="3a97" class="mv kx iq bd ky nj nk dn lc nl nm dp lg lx nn no li mb np nq lk mf nr ns lm nt bi translated">在端点中接收数据</h2><p id="b382" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">构建一个端点来接收信息与我们之前所做的并没有太大的不同。主要区别在于该函数还需要接收参数。例如，下面的端点接收两个参数:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="f1c9" class="mv kx iq mr b gy mw mx l my mz">@app.get("/example/") <br/>def read_item(id: int, name: string): <br/>    return {"your_id": id, "your_name": name}</span></pre><p id="a190" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">该信息由客户端在请求中以JSON格式发送(进一步详述)，如下所示:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="1b45" class="mv kx iq mr b gy mw mx l my mz">{ "id":123, "name": "Joao" }</span></pre><p id="573e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最酷的是FastAPI自动为我们验证数据。因此，如果客户端发送一个带有{"name":123}或根本没有名称的请求，它将返回一个类型/字段错误。除了默认的python类型，FastAPI还支持验证Pydantic类。</p><h2 id="5910" class="mv kx iq bd ky nj nk dn lc nl nm dp lg lx nn no li mb np nq lk mf nr ns lm nt bi translated"><strong class="ak">用Pydantic验证输入</strong></h2><p id="0ed3" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Pydantic是一种更健壮的验证数据的方法。它允许我们使用python类描述我们期望的输入(模型)，设置必填字段、允许的间隔和值、可选参数以及更多的<a class="ae kv" href="https://pydantic-docs.helpmanual.io/" rel="noopener ugc nofollow" target="_blank"/>。例如，下面的类描述了一个<em class="mp">人物</em>应该具有什么样的价值观。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Pydantic示例</p></figure><p id="c40e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，可以将该类插入到函数的参数字段中，就像上一个示例中描述的本地python类型一样。</p><h2 id="de6b" class="mv kx iq bd ky nj nk dn lc nl nm dp lg lx nn no li mb np nq lk mf nr ns lm nt bi translated">构建我们的预处理端点</h2><p id="6c3c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在，终于是实现API本身的时候了。</p><p id="dd59" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们的<em class="mp">微服务</em>的目的是基于一个定义好的需求列表对文本进行预处理。例如，用户可以请求删除所有货币值并返回小写文本。</p><p id="9ba1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">它将具有以下功能:<em class="mp">删除标点符号，替换数字，替换金钱，替换电话号码，替换电子邮件，并把文本小写。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/c0cf8f00e78385c823927c989f0459a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*LEVAwVIaafFn70w51_a0_g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">文本预处理微服务。图片作者。由<a class="ae kv" href="https://www.flaticon.com/free-icons/text" rel="noopener ugc nofollow" target="_blank"> Freepik </a>制作的图标。</p></figure><p id="5471" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">总结一下，我们需要实现:</p><ol class=""><li id="ecd4" class="nu nv iq lq b lr mk lu ml lx nw mb nx mf ny mj oj oa ob oc bi translated">文本预处理功能。</li><li id="18f4" class="nu nv iq lq b lr od lu oe lx of mb og mf oh mj oj oa ob oc bi translated">端点的输入验证模型。</li><li id="6902" class="nu nv iq lq b lr od lu oe lx of mb og mf oh mj oj oa ob oc bi translated">将接收文本和预处理步骤列表并返回预处理文本的端点。</li></ol><p id="4392" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">先说文本预处理函数。如前所述，我们将使用正则表达式来规范化文本。下面的代码展示了几个负责它的类的实现。BaseRegExPreprocessing类充当抽象类。每个继承的类都用其代表系统功能的值覆盖了<em class="mp"> regex </em>和<em class="mp"> replace_token </em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">文本预处理类</p></figure><p id="efa4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">输入验证非常简单，我们只需要创建一个类来描述客户端发送的数据应该是什么样子。下面的代码展示了这个实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Pydantic验证类</p></figure><p id="3c2f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">StringTransformation类枚举PreprocessingRequest类中变量<em class="mp">步骤</em>的所有可接受值，每个值代表一个功能。PreprocessingRequest是主类，它描述了发送的数据应该是什么样子。</p><p id="5d96" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最后，我们可以将它们放在主FastAPI应用程序中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">主要API代码</p></figure><p id="8312" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，用uvicorn运行服务器即可。</p><h1 id="c66c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">对一些例子进行测试</h1><p id="b357" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了正确测试我们的API，我们将使用python请求库。</p><p id="0050" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">第一个例子是替换字符串中的所有电话号码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="fad9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在查看响应的输出之前，让我们先看一下代码。</p><p id="260c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="mp">数据</em>是我们发送给API的信息。它的格式如pydantic类中所述:“text”字段包含要预处理的文本，而“steps”字段包含预处理步骤的列表。它作为<em class="mp"> json在get()方法中传递。</em></p><p id="6cd6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">requests.get()在HTTP://<em class="mp">localhost</em>/preprocess/上发出HTTP GET请求，这是我们端点的URL。</p><p id="d72a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">可以通过调用<em class="mp"> response.json() </em>来检索返回的输出</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="c8ae" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">API的一个优点是客户端与应用程序完全无关。我们的客户端是用python编写的，但它可以是C++应用程序、web浏览器或任何可以发出HTTP请求的东西。</p><blockquote class="na nb nc"><p id="0dcc" class="lo lp mp lq b lr mk jr lt lu ml ju lw nd mm lz ma ne mn md me nf mo mh mi mj ij bi translated">事实上，测试端点的另一种方法是访问<em class="iq"> localhost </em>上的http://127.0.0.1:8000/docs路径。这个路径指向FastAPI自动文档，构建一个迭代窗口来运行请求。</p></blockquote><p id="d5d1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们以一个更复杂的例子来结束，这个例子探索了系统的许多功能:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="a38d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">输出:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="9ef2" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="3f64" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在本文中，我们使用python regex和FastAPI构建了一个用于文本规范化的API。我们探索了regex规范化文本的能力，这是NLP应用程序中的一个基本过程，并描述了如何使用<em class="mp">微服务</em>和API <em class="mp"> s </em>的概念封装和分发这个过程。尽管这是一个简单的应用程序，但它展示了可以扩展到更复杂情况的基本概念。</p><p id="0bcb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">文中讨论的所有主题都进行了简要的探讨，以使帖子更小，并允许我们在主要目标的方向上更快地移动。要建立更坚实的基础，请查看以下参考资料:)</p><p id="8d4d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我希望你喜欢这次旅行，如果你喜欢讨论的任何话题，我强烈建议你进行更深入的研究。</p><p id="2726" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">感谢您的阅读！；)</p><h1 id="47e8" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">参考</h1><blockquote class="na nb nc"><p id="6429" class="lo lp mp lq b lr mk jr lt lu ml ju lw nd mm lz ma ne mn md me nf mo mh mi mj ij bi translated">Github上的代码:<a class="ae kv" href="https://github.com/jaumpedro214/posts/tree/main/text_pre_fast_api" rel="noopener ugc nofollow" target="_blank">https://Github . com/jaumpedro 214/posts/tree/main/text _ pre _ fast _ API</a></p></blockquote><p id="ed32" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">[1] CodingEntrepreneurs Youtube频道，<a class="ae kv" href="https://www.youtube.com/watch?v=JxH7cdDCFwE&amp;ab_channel=CodingEntrepreneurs" rel="noopener ugc nofollow" target="_blank"> Python &amp; FastAPI教程:创建一个ai微服务，从图像中提取文本</a>。<br/>【2】aa shish Nair，<a class="ae kv" rel="noopener" target="_blank" href="/regular-expressions-the-swiss-knife-for-text-analysis-76a34ac71c97">正则表达式:文本分析的瑞士刀</a>。在媒体上，走向数据科学。<br/>【3】AmigosCode Youtube频道，<a class="ae kv" href="https://www.youtube.com/watch?v=GN6ICac3OXY&amp;ab_channel=Amigoscode" rel="noopener ugc nofollow" target="_blank"> FastAPI教程——用Python构建RESTful API</a><br/>【3】<a class="ae kv" href="https://www.redhat.com/en/topics/api/what-is-a-rest-api" rel="noopener ugc nofollow" target="_blank">什么是REST API？</a>。在红帽子上。<br/>【4】<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods" rel="noopener ugc nofollow" target="_blank">HTTP请求方法</a>。关于MDN Web文档<br/>【5】<a class="ae kv" href="http://fastapi.tiangolo.com" rel="noopener ugc nofollow" target="_blank">Fast API官方文档。</a><br/>【6】<a class="ae kv" href="http://pydantic-docs.helpmanual.io" rel="noopener ugc nofollow" target="_blank">Pydantic官方文件</a></p></div></div>    
</body>
</html>