<html>
<head>
<title>Finding the Best Wordle Opener with Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用机器学习寻找最好的开瓶器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/finding-the-best-wordle-opener-with-machine-learning-ce81331c5759#2022-02-09">https://towardsdatascience.com/finding-the-best-wordle-opener-with-machine-learning-ce81331c5759#2022-02-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7389" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我是如何几乎和 3blue1brown 一样得出相同的开头词的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f7c2d72fba35b573aeca705f3b606d09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rqj1Dih3uqMZRIZ6ZC2hcQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">芬恩·哈克肖在<a class="ae ky" href="https://unsplash.com/s/photos/words?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="30a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你正在看这篇文章，那么你可能听说过流行的网络游戏“Wordle”。这是一个非常容易上瘾、分裂家庭的脑筋急转弯，最近被《T4 时报》收购。这个游戏的目的是以尽可能少的尝试来猜测每日单词，通常是 5 个字母的单词。当你尝试不同的单词时，游戏会提供反馈，表明猜测的质量；灰色方块表示字母不在单词中，黄色方块表示字母在单词中但位置错误，绿色方块表示字母在单词中且位置正确。</p><p id="85f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在这个游戏中获得持续的成功，<strong class="lb iu">玩家必须进行初步猜测，以揭示仅与 5 个字母单词的一小部分相关的模式</strong>。也就是说，每次猜测都需要排除尽可能多的潜在答案，只给玩家留下几个词来选择下一次猜测。因此，自然的问题是“最好的第一个猜测是什么”？</p><p id="3e50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多人试图用数学和计算机模拟来回答这个问题。在我看来，最佳答案是由 Grant Sanderson(又名 3blue1brown)在一个视频中发现的，他在视频中使用了来自<a class="ae ky" href="https://en.wikipedia.org/wiki/Information_theory" rel="noopener ugc nofollow" target="_blank">信息论</a>的概念来寻找平均来说揭示了关于目标词的最多信息的开头词。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="4c1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将采用不同的方法，利用无监督学习来寻找最佳的 Wordle 开启器。我将首先展示如何创建一个数据集，以数字形式表示 5 个字母单词的分布，然后我将展示一个机器学习模型如何帮助我们找到与所有可能的 Wordle 解决方案“最相似”的世界。这篇文章的所有代码可以在这里找到<a class="ae ky" href="https://github.com/hfhoffman1144/Best-Wordle-Opener-ML" rel="noopener ugc nofollow" target="_blank"/>。尽情享受吧！</p><h1 id="2a05" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">属国</h1><p id="4b4c" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">对于这个项目，我们需要在 Python 中进行以下导入:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="d762" class="mz ly it mv b gy na nb l nc nd">import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>import string<br/>import re<br/>from collections import Counter<br/>from tqdm import tqdm<br/>from pyod.models.copod import COPOD</span></pre><h1 id="cca6" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">数据</h1><p id="c390" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">和任何机器学习问题一样，我们需要一些数据来学习。截至今天，Wordle 将接受 12，972 个单词作为猜测。然而，在这些被接受的猜测中，只有 2315 个是解字。为了一致，我将把 12，972 个被接受的猜测称为“被接受的单词”，把 2，315 个解称为“解单词”。</p><p id="9fa3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从查看“接受的单词”的字母频率开始我们的分析。我们首先从文本文件中读入单词:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="a7c0" class="mz ly it mv b gy na nb l nc nd">def read_word_list(file_name:str):<br/>    result = []<br/>    with open(file_name) as fp:<br/>        result.extend([word.strip() for word in fp.readlines()])<br/>    return result</span><span id="7f1d" class="mz ly it mv b gy ne nb l nc nd"># Read in word lists<br/>possible_words_list = read_word_list("possible_answers.txt")<br/>accepted_words_list = read_word_list("accepted_words.txt")</span></pre><p id="c345" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是“已接受单词”的列表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/229b2bb6bfa4cd3aad0ece2d554759d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:388/format:webp/1*RhgI07D_aYB5mE5dSPRd8Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">前 8 个“接受词”。图片作者。</p></figure><p id="2f27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以及“可能的单词”列表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/ae2a6b5e082743615f8999dbe52b188d.png" data-original-src="https://miro.medium.com/v2/resize:fit:372/format:webp/1*Cfl9yte16FCXYAoJqIMgbg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">前 8 个“可能的单词”。图片作者。</p></figure><p id="6df9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以计算每个字母在所有“接受的单词”中的频率——这也可以理解为每个字母包含在单词中的比例。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="7fb0" class="mz ly it mv b gy na nb l nc nd"># Create a letter occurrence dictionary <br/>words_string = ''.join(accepted_words_list)<br/>letter_counts = dict(Counter(words_string))</span><span id="bd53" class="mz ly it mv b gy ne nb l nc nd"># Create letter frequency dictionary<br/>letter_frequencies = {k:v/len(accepted_words_list) for k,v in letter_counts.items()}</span><span id="e09b" class="mz ly it mv b gy ne nb l nc nd"># Create letter frequency DataFrame<br/>letter_frequencies = pd.DataFrame({'Letter':list(letter_frequencies.keys()),                      'Frequency':list(letter_frequencies.values())}).sort_values('Frequency',                                                                                  ascending=False)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/cc19b63a0e15f002612656d1d1e04c1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w2VjhypERm18Mnmaq_UxMA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">字母频率。图片作者。</p></figure><p id="2eb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个柱状图让我们了解了“已接受单词”列表中每个字母的常见程度。例如，它告诉我们，字母“s”出现在超过 50%的“公认单词”中。</p><p id="ac24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最初，人们可能会尝试使用原始频率作为一种好的初步猜测的方式。例如，我们最初的猜测可能是“soare ”,因为“soare”包含了最常出现的前 5 个字母。这样做的问题是，它没有考虑字母的相对顺序。以“soare”为例，一个单词包含一个“o”后跟一个“a”的情况非常罕见。事实上，这种情况只出现在 2315 个“可能单词”中的 23 个中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/619d4dbb5294dea7b53dec2bd2053369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gu80SlJhmz1whCWkQzfmOA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">包含“oa”的 23 个“可能单词”。图片作者。</p></figure><p id="9c70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，使用“soare”作为第一个猜测最有可能得到一堆黄色方块。因此，我们需要创建一个数据集，它不仅要捕获字母的常见程度，还要捕获字母在单词中的排序方式。让我们先看看这个数据集是什么样子，以获得一些直觉，然后看看如何创建它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/7c7d0d4af34b2941674732848d06d93f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I9HkpvTJYBWK9hNhqC77ig.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">单词编码数据集。图片作者。</p></figure><p id="e539" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个数据集中的每一行代表一个“接受的单词”，每一列告诉我们字母<em class="nk"> i </em>是否在单词<em class="nk">中的位置<em class="nk"> j </em>。</em>我们来看第一个词，“aahed”，作为例子。假设我们将每个单词看作一个包含 5 个元素的数组。那么我们将用下面的数组表示“aahed ”:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/74c26a16700b8de5a36240b53612349d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ie5526SOIgrqgQjTxkOekA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">“aahed”数组表示。图片作者。</p></figure><p id="0408" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据集中的每一行都代表这个数组编码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/983692a7047887bdceaacebd8a05b126.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E1p-CWNows9cDqExuHrlvw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">“aahed”的编码。图片作者。</p></figure><p id="2624" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列“a0”的值为 1，表示字母“a”位于单词的第 0 个位置(或第一个方块)。列“a1”的值为 1，表示字母“a”位于单词的第一个位置(或第二个方块)。列“d4”的值为 1，表示字母“d”位于单词的第四个位置(或第五个方块)。这个模式对单词中的每个字母都是如此。</p><p id="0336" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为字母表中有 26 个字母，而我们只考虑 5 个字母单词，所以数据集包含 26*5 = 130 列。每一列代表单词中的一个字母和一个位置，可以认为是一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Bernoulli_distribution" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">伯努利</strong> </a>随机变量，因为它只能取{0，1}中的值。</p><p id="5d24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用下面的代码创建这个数据集:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="ce1c" class="mz ly it mv b gy na nb l nc nd"># Create letter/position occurrence matrix<br/>letter_pos_freq = pd.DataFrame()</span><span id="6cf7" class="mz ly it mv b gy ne nb l nc nd"># For each word in the list of accepted words<br/>for word in tqdm(accepted_words_list):<br/>    <br/>    # Convert the word to it letter-position format<br/>    word_and_pos = ''.join([f"{letter}{pos}" for pos, letter in enumerate(word)])<br/>    <br/>    # Create letter-position counter dictionary<br/>    letter_pos_counter = {}<br/>    for wp in letter_freq_cols:<br/>        letter_pos_counter[wp] = len(re.findall(wp, word_and_pos))</span><span id="55f8" class="mz ly it mv b gy ne nb l nc nd">    tmp_pos_freq = pd.DataFrame(letter_pos_counter, index=[word])<br/>    letter_pos_freq = pd.concat([letter_pos_freq, tmp_pos_freq])<br/></span></pre><p id="cce7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个数据集允许我们表示字母频率和字母排序。通过将我们的数据视为来自具有相依成分的多元伯努利分布，我们可以计算出我们想要的任何概率。例如，单词中第一个字母是“a”的概率由以下代码给出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/d57ee6c93a7d56918f0b56e90d08d4d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OFaIdedW-yXwJz0ob8IvFQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</p></figure><p id="d6e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以看看更复杂的概率，比如假设前三个字母是“s”、“h”和“a”，那么第四个字母是“r”的概率:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/3521eadfcc512183dc39b574cecad06b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nuem-CvJNVZAx8OUn7TXzg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</p></figure><p id="bbcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们如何利用这个数据集找到最佳的开头词呢？继续读下去就知道了(悬念)。</p><h1 id="baee" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">基于 Copula 的孤立点检测模型</h1><p id="611e" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">对于这个项目，我们将利用最常用于异常检测的最先进的无监督学习算法。如果你想知道算法背后的理论，请查阅<a class="ae ky" href="https://arxiv.org/abs/2009.09463" rel="noopener ugc nofollow" target="_blank">的论文</a>或者这篇<a class="ae ky" rel="noopener" target="_blank" href="/fast-accurate-anomaly-detection-based-on-copulas-copod-3133ce9041fa">文章</a>。COPOD 算法的核心是试图通过逼近累积分布函数(CDF)来模拟数据集的潜在概率分布。然后，它可以使用近似的 CDF 为数据集中的每个观察值分配“异常值分数”,较高的分数表示该观察值位于分布的较低密度区域(更有可能是异常值)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/26903b0d02d5ef93f1e81ac5614e04ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yjRmPVSX2YaPMQdUYmX7wQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">COPOD 算法。来源:<a class="ae ky" href="https://arxiv.org/pdf/2009.09463.pdf" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/pdf/2009.09463.pdf</a></p></figure><p id="4581" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不使用 COPOD 来查找离群值，而是使用它来查找内嵌值。也就是说，<strong class="lb iu">我们要找到位于所有单词分布最可能位置的单词</strong>。想象一下，我们可以以某种方式将每个单词表示为一个数字，这个数字编码了字母出现的频率以及它们通常是如何排序的。然后，假设这个分布是对称的，我们可能会选择最接近分布平均值的世界作为我们的初始猜测。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/a8ba81b1550e22223053ab06d06bbdc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8uZtYJA6OvrX4qNIJe0JHQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</p></figure><p id="0866" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">粗略地说，这就是我们试图通过将 COPOD 算法应用于我们的数据集来实现的。</p><h1 id="683c" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">模型——实施和结果</h1><p id="0c99" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">让我们将 COPOD 算法应用于我们的数据集，并查看它认为哪个单词具有与单词分布的“核心”最接近的结构。为简单起见，我们将只考虑“可能的单词”:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="e15f" class="mz ly it mv b gy na nb l nc nd">letter_pos_freq_possible = letter_pos_freq[letter_pos_freq.index.isin(possible_words_list)]</span><span id="5d33" class="mz ly it mv b gy ne nb l nc nd"># Drop columns with all zeros<br/>for col in letter_pos_freq_possible.columns:<br/>    <br/>    if letter_pos_freq_possible[col].sum() == 0:<br/>        letter_pos_freq_possible.drop(col, axis=1, inplace=True)<br/>        letter_pos_freq.drop(col, axis=1, inplace=True)</span></pre><p id="c249" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们所要做的就是实例化并拟合 COPOD 模型，将其应用于我们的数据集，并按离群值对单词进行排序:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="d1a6" class="mz ly it mv b gy na nb l nc nd"># Fit COPOD model<br/>copod_model = COPOD(contamination=0.01)<br/>copod_model.fit(letter_pos_freq_possible)</span><span id="3908" class="mz ly it mv b gy ne nb l nc nd"># Add outlier scores to dataset and sort<br/>letter_pos_freq_possible['score'] = copod_model.decision_scores_<br/>letter_pos_freq_possible.sort_values('score',inplace=True)</span><span id="da51" class="mz ly it mv b gy ne nb l nc nd">letter_pos_freq_possible['rank'] = range(1,len(letter_pos_freq_possible)+1)</span></pre><p id="e8ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是 COPOD 算法认为最接近单词分布“核心”的前 10 个单词:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/20ffc09c8bb5f7ad5983383668caf14e.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*KVVvu5djW9-eNVsH9h33hw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">COPOD 十大开场白。图片作者。</p></figure><p id="1594" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你有它！根据问题被框定的方式，科波德认为‘圣人’是最好的开场。请注意，Grant Sanderson 推荐的开场词“crane”在 2315 个“可能单词”中排名第五。这可能表明 COPOD 算法已经完成了一些类似于在“3blue1brown”上进行的信息论模拟的事情。</p><h1 id="1239" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">最后的想法</h1><p id="8221" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">在本文中，我们学习了如何创建一个数据集来充分表示 Wordle 中使用的 5 个字母单词的结构。然后，我们使用无监督学习算法来寻找与所有其他单词结构最相似的单词。请对本实验的思考过程提供反馈——我很想听到创建单词结构数据的更好方法或更好的算法的想法。感谢阅读！</p><p id="60f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nk">喜欢我的文章？给我买杯咖啡:</em><a class="ae ky" href="https://www.buymeacoffee.com/HarrisonfhU" rel="noopener ugc nofollow" target="_blank"><em class="nk">【https://www.buymeacoffee.com/HarrisonfhU】</em>T5】</a></p></div></div>    
</body>
</html>