<html>
<head>
<title>Does Python still need the map() function?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python还需要map()函数吗？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/does-python-still-need-the-map-function-96787ea1fb05#2022-10-06">https://towardsdatascience.com/does-python-still-need-the-map-function-96787ea1fb05#2022-10-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2fd0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有了各种备选方案，Python的map()似乎就显得多余了。那么，Python到底需不需要呢？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7622f49d5594235527e9e08bb7075852.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4aFVvJ9IpSrNQT4V"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Python需要map()函数吗？Muhammad Haikal Sjukri 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="ec8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">别担心，这不会是第一百万篇关于如何在Python中使用<code class="fe lv lw lx ly b">map()</code>的文章。我不会告诉你这比列表理解或循环更好或更差。我不打算将它与相应的生成器或列表理解进行对比。我不会说使用<code class="fe lv lw lx ly b">map()</code>会让你看起来像一个高级Python开发者…</p><p id="d5f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在Medium上发表的其他文章中读到所有这些内容。尽管内置的<code class="fe lv lw lx ly b">map()</code>函数在Python开发人员中并不太受欢迎(你很少会在产品代码中发现它)，但它在Python作者中却很受欢迎(例如，参见<a class="ae ky" href="https://medium.com/swlh/higher-order-functions-in-python-map-filter-and-reduce-34299fee1b21" rel="noopener">这里的</a>、这里的<a class="ae ky" rel="noopener" target="_blank" href="/pythons-map-filter-and-reduce-functions-explained-2b3817a94639">这里的</a>和<a class="ae ky" href="https://medium.com/towards-data-science/understanding-the-use-of-lambda-expressions-map-and-filter-in-python-5e03e4b18d09" rel="noopener">这里的</a>)。这是为什么呢？也许因为这是一个有趣的函数。类似于函数式编程；或者可以用它的替代品作为基准，而基准通常会引起注意？</p><p id="ddf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数关于Python的<code class="fe lv lw lx ly b">map()</code>的文章仅仅展示了如何使用，而没有展示为什么:在展示如何使用它的同时，他们通常没有解释为什么应该使用它。难怪，尽管它在Python作者中很受欢迎，但在中级开发人员中似乎没有得到应有的重视。</p><p id="3899" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解更多关于<code class="fe lv lw lx ly b">map()</code>的知识，这篇文章就是为你准备的。我们将讨论<code class="fe lv lw lx ly b">map()</code>函数在Python代码路线图中的位置，以及为什么不管你是否会使用它，了解这个函数都是值得的。</p><h1 id="046c" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">几句关于<code class="fe lv lw lx ly b">map()</code>的话</h1><p id="b667" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">做一些大多数Python开发人员经常做的事情:为iterable的每个元素调用一个函数(实际上是一个callable)。</p><p id="1d33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它接受一个可调用函数作为参数，所以它是一个高阶函数。因为这是函数式编程语言的典型特征，<code class="fe lv lw lx ly b">map()</code>符合函数式编程风格。比如，你会在洛特的《T21函数式Python编程》一书中发现很多<code class="fe lv lw lx ly b">map()</code>的应用。我认为<code class="fe lv lw lx ly b">map()</code>使用了类似的API，而不是真正的函数式编程。这是因为我们可以把<code class="fe lv lw lx ly b">map()</code>用于不纯的函数，也就是有副作用的函数；这在真正的函数式编程中是不可接受的。</p><p id="bf6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是时候看看<code class="fe lv lw lx ly b">map()</code>的行动了。</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="44fd" class="nb ma it ly b gy nc nd l ne nf">&gt;&gt;&gt; numbers = [1, 4, 5, 10, 17]<br/>&gt;&gt;&gt; def double(x):<br/>...     return x*2</span></pre><p id="1f11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，我们有一个数字列表，我们有一个函数可以将一个数字加倍。<code class="fe lv lw lx ly b">double()</code>适用于单个号码:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="81ef" class="nb ma it ly b gy nc nd l ne nf">&gt;&gt;&gt; double(10)<br/>20</span></pre><p id="2a79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们用<code class="fe lv lw lx ly b">double()</code>代替<code class="fe lv lw lx ly b">numbers</code>会怎么样？</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="3c90" class="nb ma it ly b gy nc nd l ne nf">&gt;&gt;&gt; double(numbers)</span><span id="201c" class="nb ma it ly b gy ng nd l ne nf">[1, 4, 5, 10, 17, 1, 4, 5, 10, 17]</span></pre><p id="73c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你知道Python中列表相乘的工作原理，这不会让你吃惊。虽然这是正常的行为，但这绝对不是我们想要达到的目标。上图，<code class="fe lv lw lx ly b">double(numbers)</code>将函数<code class="fe lv lw lx ly b">double()</code>应用到<code class="fe lv lw lx ly b">numbers</code> <em class="mw">整体</em>(作为对象)。这不是我们想要的；我们要将<code class="fe lv lw lx ly b">double()</code>应用到<em class="mw">中</em>的每一个元素<code class="fe lv lw lx ly b">numbers</code>。这有很大的不同，这就是<code class="fe lv lw lx ly b">map()</code>的用武之地:当你想对iterable的每个元素应用callable时，你可以使用它。</p><p id="8065" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mw">警告</em>:一些语言使用名称<code class="fe lv lw lx ly b">map</code>作为哈希映射；在Python中，字典是哈希映射。所以，请注意，当你在另一种语言中看到术语“地图”时，首先检查它代表什么。比如R中的<code class="fe lv lw lx ly b">map()</code>相当于Python的<code class="fe lv lw lx ly b">map()</code>；但是在Go中，<code class="fe lv lw lx ly b">map()</code>创建一个哈希映射，工作方式类似于Python的<code class="fe lv lw lx ly b">dict()</code>。当我第一次开始学习围棋时，这让我很困惑，但过一段时间后，你就会明白了。</p><p id="f40d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你应该这样使用<code class="fe lv lw lx ly b">map()</code>:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="3732" class="nb ma it ly b gy nc nd l ne nf">&gt;&gt;&gt; doubled_numbers = map(double, numbers)</span></pre><p id="7707" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，您向<code class="fe lv lw lx ly b">map()</code>提供了一个callable作为第一个参数，一个iterable作为第二个参数。它返回一个map对象(在Python 3中，但是在Python 2中，您将获得一个列表):</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="f85d" class="nb ma it ly b gy nc nd l ne nf">&gt;&gt;&gt; doubled_numbers #doctest: +ELLIPSIS<br/>&lt;map object at ...&gt;</span></pre><p id="dc78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(请注意，我使用了<code class="fe lv lw lx ly b">#doctest: +ELLIPSIS</code>指令，因为本文档包含在<code class="fe lv lw lx ly b">doctest</code> s中。它帮助我确保所有示例都是正确的。你可以在文档中读到更多关于T2的内容。)</p><p id="2db0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe lv lw lx ly b">map</code>对象像一个发电机一样工作。所以，即使我们在<code class="fe lv lw lx ly b">map()</code>中使用了一个列表，我们得到的不是一个列表，而是一个生成器。按需评估生成器(延迟)。如果你想把一个<code class="fe lv lw lx ly b">map</code>对象转换成一个列表，使用<code class="fe lv lw lx ly b">list()</code>函数，它将评估所有的元素:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="2acd" class="nb ma it ly b gy nc nd l ne nf">&gt;&gt;&gt; list(doubled_numbers)<br/>[2, 8, 10, 20, 34]</span></pre><p id="7ad1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，您可以用任何其他方式评估<code class="fe lv lw lx ly b">map</code>的元素，比如在<code class="fe lv lw lx ly b">for</code>循环中。为了避免不愉快的头痛，请记住，一旦这样的对象被评估，它是空的，因此不能再被评估:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="2825" class="nb ma it ly b gy nc nd l ne nf">&gt;&gt;&gt; list(doubled_numbers)<br/>[]</span></pre><p id="66fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面，我们为单个iterable应用了<code class="fe lv lw lx ly b">map()</code>，但是我们可以使用多个iterable。该函数将根据它们的索引来使用它们，也就是说，首先，它将为iterables的第一个元素调用callable(在索引0处)；然后进行第二次；诸如此类。</p><p id="3112" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个简单的例子:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="ed9e" class="nb ma it ly b gy nc nd l ne nf">&gt;&gt;&gt; def sum_of_squares(x, y, z):<br/>...     return x**2 + y**2 + z**2</span><span id="3357" class="nb ma it ly b gy ng nd l ne nf">&gt;&gt;&gt; x = range(5)<br/>&gt;&gt;&gt; y = [1, 1, 1, 2, 2]<br/>&gt;&gt;&gt; z = (10, 10, 5, 5, 5)<br/>&gt;&gt;&gt; SoS = map(sum_of_squares, x, y, z)<br/>&gt;&gt;&gt; list(SoS)<br/>[101, 102, 30, 38, 45]<br/>&gt;&gt;&gt; list(map(sum_of_squares, x, x, x))<br/>[0, 3, 12, 27, 48]</span></pre><h1 id="af33" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated"><code class="fe lv lw lx ly b">map()</code>的替代品</h1><p id="1afc" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">代替<code class="fe lv lw lx ly b">map()</code>，你可以使用一个生成器，例如，通过一个生成器表达式:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="95b0" class="nb ma it ly b gy nc nd l ne nf">&gt;&gt;&gt; doubled_numbers_gen = (double(x) for x in numbers)</span></pre><p id="8ebb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这提供了一个发电机，就像<code class="fe lv lw lx ly b">map()</code>一样。当你需要一个清单时，你会更好地理解相应的清单:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="0cd6" class="nb ma it ly b gy nc nd l ne nf">&gt;&gt;&gt; doubled_numbers_list = [double(x) for x in numbers]</span></pre><p id="9260" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哪个可读性更强:<code class="fe lv lw lx ly b">map()</code>版本还是生成器表达式(或者列表理解)？对我来说，没有一秒钟的犹豫，生成器表达式和列表理解更清晰，即使我理解<code class="fe lv lw lx ly b">map()</code>版本没有问题。但是我知道有些人会选择<code class="fe lv lw lx ly b">map()</code>版本，尤其是那些最近从另一种使用类似<code class="fe lv lw lx ly b">map()</code>功能的语言迁移到Python的人。</p><p id="933c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">人们经常将<code class="fe lv lw lx ly b">map()</code>与<code class="fe lv lw lx ly b">lambda</code>函数结合使用，当您不想在其他地方重用该函数时，这是一个很好的解决方案。我认为对<code class="fe lv lw lx ly b">map() </code>的部分负面看法来自于这种用法，因为<code class="fe lv lw lx ly b">lambda</code>函数经常会降低代码的可读性。在这种情况下，通常情况下，生成器表达式的可读性会更好。下面比较两个版本:一个是<code class="fe lv lw lx ly b">map()</code>结合<code class="fe lv lw lx ly b">lambda</code>，另一个是对应生成器表达式。这一次，我们将不使用我们的<code class="fe lv lw lx ly b">double()</code>函数，但是我们将在调用中直接定义它:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="2480" class="nb ma it ly b gy nc nd l ne nf"># map-lambda version<br/>map(lambda x: x*2, numbers)</span><span id="f5c4" class="nb ma it ly b gy ng nd l ne nf"># generator version<br/>(x*2 for x in numbers)</span></pre><p id="a19e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两行导致相同的结果，唯一的区别是返回对象的类型:返回一个<code class="fe lv lw lx ly b">map</code>对象，而后者返回一个<code class="fe lv lw lx ly b">generator</code>对象。</p><p id="fb00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们暂时回到<code class="fe lv lw lx ly b">map()</code>的多次使用:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="1a03" class="nb ma it ly b gy nc nd l ne nf">&gt;&gt;&gt; SoS = map(sum_of_squares, x, y, z)</span></pre><p id="b848" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以按照以下方式使用生成器表达式重写它:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="398f" class="nb ma it ly b gy nc nd l ne nf">&gt;&gt;&gt; SoS_gen = (<br/>...     sum_of_squares(x_i, y_i, z_i)<br/>...     for x_i, y_i, z_i in zip(x, y, z)<br/>... )</span><span id="f7b6" class="nb ma it ly b gy ng nd l ne nf">&gt;&gt;&gt; list(SoS_gen)<br/>[101, 102, 30, 38, 45]</span></pre><p id="fe49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这次我投票给<code class="fe lv lw lx ly b">map()</code>版本！除了更简洁之外，在我看来，它更清晰。发电机版本利用<code class="fe lv lw lx ly b">zip()</code>功能；即使这是一个简单的函数，它也增加了命令的难度。</p><h1 id="536b" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">所以，我们不需要map()，不是吗？</h1><p id="729a" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">根据以上讨论，不存在我们必须使用<code class="fe lv lw lx ly b">map()</code>功能的情况；相反，我们可以使用生成器表达式、循环或其他东西。</p><p id="a9c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">知道了这一点，我们还需要什么吗？</p><p id="9763" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">思考这个问题，我得出了我们需要Python中的<code class="fe lv lw lx ly b">map()</code>的三个主要原因。</p><h2 id="cf5f" class="nb ma it bd mb nh ni dn mf nj nk dp mj li nl nm ml lm nn no mn lq np nq mp nr bi translated"><strong class="ak"> <em class="ns">原因一:性能</em> </strong></h2><p id="1f26" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">如前所述，<code class="fe lv lw lx ly b">map()</code>被懒洋洋地评估。然而，在许多情况下，评估<code class="fe lv lw lx ly b">map()</code>比评估相应的生成器表达式更快。尽管相应的列表理解并不一定是这种情况，但是在优化Python应用程序时，我们应该记住这一点。</p><p id="6b3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，请记住，这不是一个普遍的规则，所以你不应该假设这一点。每次都需要检查<code class="fe lv lw lx ly b">map()</code>在你的代码片段中是否会更快。</p><p id="5f42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有在性能上的细微差异也很重要时，才考虑这个原因。否则，以牺牲可读性为代价使用<code class="fe lv lw lx ly b">map()</code>将会收获甚微，所以你应该三思而后行。通常，节省一分钟没有任何意义。其他时候，节省一秒钟意味着很多。</p><h2 id="e14f" class="nb ma it bd mb nh ni dn mf nj nk dp mj li nl nm ml lm nn no mn lq np nq mp nr bi translated"><strong class="ak"> <em class="ns">原因二:平行度和穿线</em> </strong></h2><p id="3325" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">当您并行化您的代码或使用线程池时，您通常会使用类似于<code class="fe lv lw lx ly b">map()</code>的函数。这可以包括诸如<code class="fe lv lw lx ly b">multiprocessing.Pool.map()</code>、<code class="fe lv lw lx ly b">pathos.multiprocessing.ProcessingPool.map()</code>或<code class="fe lv lw lx ly b">concurrent.futures.ThreadPoolExecutor.map()</code>之类的方法。所以，学会使用<code class="fe lv lw lx ly b">map()</code>会帮助你理解如何使用这些功能。通常，您会希望在并行和非并行版本之间切换。由于这些函数之间的相似性，您可以非常容易地做到这一点。看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="bdc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，在这个简单的例子中，并行化没有意义，而且会更慢，但是我想向您展示如何做到这一点。</p><h2 id="f46c" class="nb ma it bd mb nh ni dn mf nj nk dp mj li nl nm ml lm nn no mn lq np nq mp nr bi translated"><strong class="ak"> <em class="ns">原因3:对于来自其他语言的Python新人来说简单</em> </strong></h2><p id="0294" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">这个原因是非典型的，并不涉及语言本身，但它有时很重要。对我来说，生成器表达式几乎总是更容易编写，可读性更好。然而，当我刚接触Python时，理解对我来说并不容易，无论是写还是理解。但是自从我在16年的R编程后来到Python，我非常熟悉R的<code class="fe lv lw lx ly b">map()</code>函数，它的工作方式与Python的<code class="fe lv lw lx ly b">map()</code>完全一样。然后，对我来说，使用<code class="fe lv lw lx ly b">map()</code>比使用相应的生成器表达式或列表理解要容易得多。</p><p id="3fc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更重要的是，对<code class="fe lv lw lx ly b">map()</code>的熟悉帮助我理解。我也能够编写Pythonic代码；没错，用<code class="fe lv lw lx ly b">map()</code>就是Pythonic。我们知道，第三种选择是<code class="fe lv lw lx ly b">for</code>循环，但这很少是更好的(甚至是好的)选择。因此，如果有人使用Python并且知道这些函数是如何工作的，那么他们编写Python代码就容易多了。例如，从C语言转向Python的人可能会使用一个<code class="fe lv lw lx ly b">for</code>循环，这在这种情况下被认为是非Python的。</p><p id="ee38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着<code class="fe lv lw lx ly b">map()</code>是Python和其他语言之间的桥梁——一座可以帮助其他人理解语言和编写Python代码的桥梁。</p><h2 id="52be" class="nb ma it bd mb nh ni dn mf nj nk dp mj li nl nm ml lm nn no mn lq np nq mp nr bi translated"><strong class="ak"> <em class="ns">原因4:多个可迭代的情况下的可读性</em> </strong></h2><p id="7405" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">如上图所示，当你想同时为多个iterables使用一个callable时，<code class="fe lv lw lx ly b">map()</code>可以比对应的生成器表达式更易读、更简洁。因此，即使在简单的情况下,<code class="fe lv lw lx ly b">map()</code>可读性较差，但在更复杂的情况下，可读性成为了它的优势。</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><h1 id="ad7a" class="lz ma it bd mb mc oc me mf mg od mi mj jz oe ka ml kc of kd mn kf og kg mp mq bi translated"><strong class="ak">结论</strong></h1><p id="25c4" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">有人说Python不需要<code class="fe lv lw lx ly b">map()</code>。<a class="ae ky" href="https://www.artima.com/weblogs/viewpost.jsp?thread=98196" rel="noopener ugc nofollow" target="_blank">回到2005年</a>，Guido自己想把它从Python中移除，还有<code class="fe lv lw lx ly b">filter()</code>和<code class="fe lv lw lx ly b">reduce()</code>。但是17年后的今天，我们仍然可以使用它，我认为——并真诚地希望——这一点不会改变。这给我们带来了本文所要讨论的两个关键问题:</p><p id="da41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"><em class="mw"/></strong><code class="fe lv lw lx ly b"><strong class="lb iu"><em class="mw">map()</em></strong></code><strong class="lb iu"><em class="mw">函数是Python中必须的吗？</em> </strong>不，不是。你可以用其他方法达到同样的效果。</p><p id="0fc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="mw">既然如此，Python还需要</em> </strong> <code class="fe lv lw lx ly b"><strong class="lb iu"><em class="mw">map()</em></strong></code> <strong class="lb iu"> <em class="mw">函数吗？</em> </strong> <em class="mw"> </em>是的，确实如此。不是因为它是必须的，而是因为它仍然被使用，它服务于各种有价值的目的。</p><p id="7c7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为Python开发者应该知道如何使用<code class="fe lv lw lx ly b">map()</code>，即使他们不经常使用它。在某些情况下，它可以帮助提高性能，并行化代码，只需很小的改动，或者提高代码的可读性。它有助于理解。它还可以帮助来自其他语言的开发人员使用地道的Python——因为，是的，<code class="fe lv lw lx ly b">map()</code>仍然是Python。</p><p id="4dd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正是因为这些原因，我认为<code class="fe lv lw lx ly b">map()</code>值得在Python代码库中占有一席之地，即使它并不经常被使用。</p><h2 id="764c" class="nb ma it bd mb nh ni dn mf nj nk dp mj li nl nm ml lm nn no mn lq np nq mp nr bi translated"><strong class="ak">资源</strong></h2><ul class=""><li id="a248" class="oh oi it lb b lc mr lf ms li oj lm ok lq ol lu om on oo op bi translated"><a class="ae ky" href="https://medium.com/swlh/higher-order-functions-in-python-map-filter-and-reduce-34299fee1b21" rel="noopener">https://medium . com/swlh/higher-order-functions-in-python-map-filter-and-reduce-34299 fee1b 21</a></li><li id="2752" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/pythons-map-filter-and-reduce-functions-explained-2b3817a94639">https://towards data science . com/python-map-filter-and-reduce-functions-explained-2b 3817 a 94639</a></li><li id="4b7e" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated"><a class="ae ky" href="https://medium.com/towards-data-science/understanding-the-use-of-lambda-expressions-map-and-filter-in-python-5e03e4b18d09" rel="noopener">https://medium . com/forward-data-science/understanding-the-use-of-lambda-expressions-map-and-filter-in-python-5e 03 E4 b 18d 09</a></li><li id="d66f" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">https://docs.python.org/3/library/doctest.html<a class="ae ky" href="https://docs.python.org/3/library/doctest.html" rel="noopener ugc nofollow" target="_blank"/></li><li id="a812" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">【https://www.artima.com/weblogs/viewpost.jsp?thread=98196 T4】</li><li id="7f0b" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">洛特，S.F. (2018)。<em class="mw">函数式Python编程</em>。第二版。包装出版公司。</li></ul></div></div>    
</body>
</html>