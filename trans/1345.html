<html>
<head>
<title>Map Tiles: Locating Areas, Nested/Parent Tiles, Coordinates, and Bounding Boxes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">地图切片:定位区域、嵌套/父切片、坐标和边界框</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/map-tiles-locating-areas-nested-parent-tiles-coordinates-and-bounding-boxes-e54de570d0bd#2022-04-04">https://towardsdatascience.com/map-tiles-locating-areas-nested-parent-tiles-coordinates-and-bounding-boxes-e54de570d0bd#2022-04-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="425c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用位置或缩放级别来确定要使用的图块，并以编程方式计算它们的坐标。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cf1b75920a44af7b963c2465a4517c56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gdJwxZOhLlLVhRdB"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@darshan394?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Deva Darshan </a>拍摄的照片</p></figure><p id="c681" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在可视化地理信息时，数据通常被分割成段——跨越整个地球并根据缩放级别递减的块。这意味着作为用户，我们可以只加载我们感兴趣的信息。</p><p id="aaca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，问题在于希望从tileset中提取数据，而不必每次都手动重新定位地图。为此，我们有两种方法:</p><ul class=""><li id="d53e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">使用缩放级别和地理坐标查找单幅图块</li><li id="6fb3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">找到一个缩放级别上的图块，并从另一个缩放级别定位任何相应的图块。</li><li id="0c66" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">最后，我们可以颠倒整个过程，以获得瓷砖坐标，因此包围盒</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="9c21" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">基于坐标定位图块</h1><p id="c4b4" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">查找相关图块的最简单方法(除了手动操作加载的地图)是从感兴趣的地方开始，决定我们想要的细节，并直接搜索它。</p><h2 id="e13c" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">选择缩放级别</h2><p id="ce7e" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">第一步是决定我们在地图上需要多少细节。OpenStreetMap 的下表给出了每个级别的规模。对于此示例，我将查看纽约，因此将基于代表列的“<em class="nz">区域示例”选择缩放级别11。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/4fac5904342b6ff46af6fd7963d18120.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-rAgHmvdeJE3axGAhjwwzQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">显示不同缩放级别及其相对比例的表格。来源:<a class="ae ky" href="https://wiki.openstreetmap.org/wiki/Zoom_levels" rel="noopener ugc nofollow" target="_blank">https://wiki.openstreetmap.org/wiki/Zoom_levels</a></p></figure><h2 id="db2c" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">从坐标计算图块</h2><p id="ff79" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">接下来，我们需要获得我们感兴趣的城市的纬度和经度。对于纽约，这是:<code class="fe ob oc od oe b">40.7128° N, 74.0060° W</code>。</p><p id="91b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以使用上面的下列函数来确定我们需要什么样的图块，如下等式:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="dbdb" class="nn mr it oe b gy oj ok l ol om">import mpmath as mp<br/></span><span id="88ed" class="nn mr it oe b gy on ok l ol om"><strong class="oe iu">def</strong> get_tile(<strong class="oe iu">lat_deg,lon_deg,zoom</strong>):</span><span id="cd2e" class="nn mr it oe b gy on ok l ol om">   <em class="nz">''' A function to get the relevant tile from lat,lon,zoom)'''</em><br/>   <br/>   lat_rad = mp.radians(lat_deg)<br/>   n = 2 ** zoom<br/>   <br/>   xtile = n * ((lon_deg + 180) / 360)<br/>   ytile = n * (1 - (mp.log(mp.tan(lat_rad) + mp.sec(lat_rad)) / mp.pi)) / 2</span><span id="b556" class="nn mr it oe b gy on ok l ol om">   <strong class="oe iu">return</strong> 'tile %d/%d/%d '%(zoom,xtile,ytile)</span></pre><p id="e575" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nz">注意:由于我们坐标系的性质，由于这是向西74度，我们需要在计算时将其输入为负数。</em> <code class="fe ob oc od oe b"><em class="nz">40.7128, </em><strong class="lb iu"><em class="nz">—</em></strong><em class="nz"> 74.0060</em></code></p><div class="kj kk kl km gt ab cb"><figure class="oo kn op oq or os ot paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/20150b650f4fff1d30bedf28f03a2e9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/0*wlNV4clU2BnfPufY"/></div></figure><figure class="oo kn ou oq or os ot paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/898f20a71820a5e3e280784a54758006.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*nTcrL8MJHNL4TbJ1CY0W2g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk ov di ow ox translated">返回的卫星视图左(<code class="fe ob oc od oe b">© Mapbox, © OpenStreetMap</code>)和缩小的谷歌地图(地图数据:2022谷歌)在右边。</p></figure></div><p id="78de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将<code class="fe ob oc od oe b">get_tile(<em class="nz">40.7128, </em><strong class="lb iu"><em class="nz">—</em></strong><em class="nz"> 74.0060 , 11)</em></code> <em class="nz"> </em>与Mapbox卫星tileset一起使用，我们得到了纽约最左边的图像<code class="fe ob oc od oe b">tile: 11/602/770</code>。这可以与谷歌地图进行比较，以确保我们有正确的位置。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="3034" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">从另一缩放级别查找嵌套或父平铺</h1><p id="f687" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们可能面临的另一个问题是希望同一区域的分辨率更高或更低。在这种情况下，我们可能只有一个单独的位置，而没有产生它所需的坐标。我们可以简单地使用“n”来调整缩放级别，而不是逆向工程上述等式:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="90bb" class="nn mr it oe b gy oj ok l ol om">def tile_translator(z,x,y,newzoom):</span><span id="6426" class="nn mr it oe b gy on ok l ol om"><em class="nz">'''Find the linking (left top) most tile from another zoom level'''</em></span><span id="ffb3" class="nn mr it oe b gy on ok l ol om">   n = 2 ** z<br/>   x /= n<br/>   y /= n</span><span id="5684" class="nn mr it oe b gy on ok l ol om">   n2 = 2 ** newzoom<br/>   x *= n2<br/>   y *= n2</span><span id="8dd6" class="nn mr it oe b gy on ok l ol om">   return '%d/%d/%d'%(newzoom,x,y)</span></pre><p id="973c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在英国东北部<code class="fe ob oc od oe b">(10/510/330)</code>随机取一块瓷砖，我们可以根据<code class="fe ob oc od oe b">newzoom</code>参数的值生成它的父元素和子元素。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/53edcd634393be2882d2145637820ecc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*llpMhH1JTG4ggxsSvdWLvw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">` tile_translator的输出(<code class="fe ob oc od oe b">10,510,330,9). — via © Mapbox, © OpenStreetMap</code></p></figure><p id="a4d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在需要右边单元格的坐标的情况下，我们可以将1加到<code class="fe ob oc od oe b">x</code> (511)并将<code class="fe ob oc od oe b">+1</code>加到<code class="fe ob oc od oe b">y</code> (331)以得到向下的单元格。如果探索子块，这个过程也是有用的(见下文)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/ca8090ef0449118df21946853c458b2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gINiKiktg0MVqjQBwMckGg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">` tile_translator( <code class="fe ob oc od oe b">10,510,330,11) — via © Mapbox, © OpenStreetMap</code>的输出</p></figure><p id="c10c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将所有这些放在一起会产生以下结果:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="a917" class="nn mr it oe b gy oj ok l ol om">def get_children(z,x,y):<br/>   ''' Return the children of a tile '''<br/>   <br/>   tile = list(tile_translator(z,x,y,z+1).split('/').map(float))</span><span id="ff10" class="nn mr it oe b gy on ok l ol om">   return [[tile[0],tile[1]+i,tile[2]+j] for i in [0,1] for j in [0,1]]</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="1bec" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">查找图块边界</h1><p id="3870" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">最后，我们可以颠倒这个过程来获得每个瓷砖的角点:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="436d" class="nn mr it oe b gy oj ok l ol om">def tile2lon(z,x,y) :<br/>   return x / 2**z * 360 - 180;</span><span id="0bca" class="nn mr it oe b gy on ok l ol om">def tile2lat(z,x,y) :<br/>   n = mp.pi - 2 * mp.pi * y / 2**z;<br/>   return float((180 / mp.pi) * (mp.atan(0.5 * (mp.exp(n) - mp.exp(-n)))))</span></pre><p id="a0a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将数字<code class="fe ob oc od oe b">x</code>和<code class="fe ob oc od oe b">y</code>加1，我们现在可以计算包围我们的图块的边界框:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="b44a" class="nn mr it oe b gy oj ok l ol om">def tile_bbox(z,x,y):<br/>'''Return the bounding box of a tile'''<br/>   <br/>   w = tile2lon(z,x,y)<br/>   s = tile2lat(z,x,y) <br/>   e = tile2lon(z,x+1,y)<br/>   n = tile2lat(z,x,y+1)</span><span id="09c6" class="nn mr it oe b gy on ok l ol om">   return [w,s,e,n]</span></pre><h1 id="9b2f" class="mq mr it bd ms mt pa mv mw mx pb mz na jz pc ka nc kc pd kd ne kf pe kg ng nh bi translated">结论</h1><p id="0e25" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们已经学习了如何使用经度和纬度以编程方式定位图块，以及在另一个缩放级别上找到相应的图块。其用途包括提取特定领域的信息，然后用于机器学习(文章即将发表)。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="ebea" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">资源</h1><p id="bcad" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">代码的完整副本，以及一些进一步的阅读材料。</p><h2 id="1b8e" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">密码</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pf pg l"/></div></figure><h2 id="2b8b" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">关于Tilesets的更多信息</h2><div class="ph pi gp gr pj pk"><a href="https://docs.microsoft.com/en-us/bingmaps/articles/bing-maps-tile-system?redirectedfrom=MSDN" rel="noopener  ugc nofollow" target="_blank"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd iu gy z fp pp fr fs pq fu fw is bi translated">Bing地图平铺系统- Bing地图</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">Bing地图提供了一个世界地图，用户可以直接操纵它进行平移和缩放。为了让这种互动变得快速和…</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">docs.microsoft.com</p></div></div><div class="pt l"><div class="pu l pv pw px pt py ks pk"/></div></div></a></div><div class="ph pi gp gr pj pk"><a href="https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames" rel="noopener  ugc nofollow" target="_blank"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd iu gy z fp pp fr fs pq fu fw is bi translated">滑动地图磁贴名称</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">本文描述Slippy地图应用程序的文件命名约定。拼贴是256 × 256像素的PNG文件…</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">wiki.openstreetmap.org</p></div></div><div class="pt l"><div class="pz l pv pw px pt py ks pk"/></div></div></a></div></div></div>    
</body>
</html>