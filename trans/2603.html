<html>
<head>
<title>Train &amp; Predict Sci-Kit Learn Models in Parallel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">并行训练和预测Sci-Kit学习模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/train-predict-sci-kit-learn-models-in-parallel-510aee478426#2022-06-06">https://towardsdatascience.com/train-predict-sci-kit-learn-models-in-parallel-510aee478426#2022-06-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fa3c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Sci-Kit Learn上并行化您的模型训练和预测</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eb3e4c6a3727c80c70d7372368333d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mglZVL58Rs6x4GWHHf1LzQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由马克·卡吉尔从<a class="ae ky" href="https://unsplash.com/photos/Zg9Jwm86LRw" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="362b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将概述如何在sci-kit learn上并行训练和调优某些模型，以优化时间。我还将概述如何并行化这些模型的预测过程。我将介绍如何将数据划分为多个部分，并为每个部分生成预测，以及如何将整个数据集传递到多个模型中。我以前写过一篇关于多重处理以及如何将它用于单参数和多参数函数的文章。你可以在这里阅读它<a class="ae ky" rel="noopener" target="_blank" href="/parallelization-w-multiprocessing-in-python-bd2fc234f516">，因为我们将为这篇文章的内容使用多重处理模块。以下是这篇文章的提纲:</a></p><h2 id="eb27" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">目录</h2><ul class=""><li id="99b3" class="mo mp it lb b lc mq lf mr li ms lm mt lq mu lu mv mw mx my bi translated">Sci-Kit学习并行化</li><li id="5968" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">数据<br/> -需求<br/> -生成数据</li><li id="654e" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">训练模式<br/> -正常训练<br/> -平行训练</li><li id="a87e" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">并行模型评估(交叉验证)<br/> -正常实施<br/> -并行实施</li><li id="64b2" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">并行模型预测—单一模型<br/>—架构<br/>—正常实现<br/>—并行实现</li><li id="8291" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">并行模型预测—多模型<br/>—架构<br/>—正常实现<br/>—并行实现</li><li id="4f82" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">结束语</li><li id="6b32" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">资源</li></ul><h1 id="3341" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">Sci-Kit学习并行化</h1><p id="6b1d" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">大多数机器学习项目有4个主要部分，需要大量的计算能力和时间。</p><ol class=""><li id="356a" class="mo mp it lb b lc ld lf lg li ns lm nt lq nu lu nv mw mx my bi translated">模型训练<br/> -在各种列车测试分段上训练多个ML模型</li><li id="0faf" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu nv mw mx my bi translated">模型的超参数调整<br/> -调整与模型相关的各种超参数，以最大化模型性能，而不过度拟合原始数据</li><li id="ea44" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu nv mw mx my bi translated">模型评估<br/> -通过各种评估方法评估模型，如交叉验证、准确性、分类报告等。</li><li id="11a4" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu nv mw mx my bi translated">模型预测<br/>——为模型生成预测，使得推理时间很短。<br/> -与机器学习模型相关的推理时间是指模型处理输入数据并生成预测所需的时间。<br/> -您希望在最小化推理时间的同时最大化模型性能。推理时间短有助于生产环境中的可扩展机器学习。</li></ol><p id="295f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这4个组件对于数据科学管道至关重要，每个组件都扮演着重要角色，并且每个组件都需要大量时间。令人欣慰的是，当通过sci-kit learn(一个用于模型开发的开源库)进行机器学习建模时，大量的并行化已经内置于您训练的许多常见函数和模型中。sklearn中函数的<code class="fe nw nx ny nz b">n_jobs</code>参数指定了运行该函数时要使用的内核数量。</p><blockquote class="oa ob oc"><p id="15bb" class="kz la od lb b lc ld ju le lf lg jx lh oe lj lk ll of ln lo lp og lr ls lt lu im bi translated"><code class="fe nw nx ny nz b">n_jobs</code>是一个整数，指定并发运行的工作线程的最大数量。如果给定1，则根本不使用joblib并行，这对调试很有用。如果设置为-1，则使用所有CPU。对于低于-1的<code class="fe nw nx ny nz b">n_jobs</code>，使用(n _ CPU+1+n _ jobs)。例如使用<code class="fe nw nx ny nz b">n_jobs=-2</code>，除了一个CPU之外，所有的CPU都被使用。<br/> <code class="fe nw nx ny nz b">n_jobs</code>默认为<code class="fe nw nx ny nz b">None</code>，表示<em class="it">未置位</em>；一般会解释为<code class="fe nw nx ny nz b">n_jobs=1</code><br/><em class="it">【1】</em><a class="ae ky" href="https://scikit-learn.org/stable/glossary.html#term-n-jobs" rel="noopener ugc nofollow" target="_blank">https://scikit-learn.org/stable/glossary.html#term-n-jobs</a></p></blockquote><p id="4655" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，并非所有的函数和模型都可以使用该参数，这意味着并非sklearn模块的所有特性都是并行的。例如，<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html#sklearn.ensemble.RandomForestClassifier" rel="noopener ugc nofollow" target="_blank">随机森林</a>和<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html" rel="noopener ugc nofollow" target="_blank"> K近邻</a>等模型具有n_jobs参数，而<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.ElasticNet.html" rel="noopener ugc nofollow" target="_blank">弹性网</a>和<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.GradientBoostingClassifier.html" rel="noopener ugc nofollow" target="_blank">梯度提升</a>等模型则没有。要确定该参数是否可用于您正在使用的sklearn中的功能，您可以查阅与该功能相关的文档，并检查<code class="fe nw nx ny nz b">n_jobs</code>是否在该功能的参数部分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/d6aa50857baca81a96792d449f63db45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6zDV5uJKuMAEu8KMdCjk5A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html" rel="noopener ugc nofollow" target="_blank">knighborsclassifier</a>的n_jobs参数。图片由作者提供。</p></figure><h1 id="4aa4" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">数据</h1><p id="b3c7" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我们将为下面的教程合成数据。我将强调如何生成一些假数据，以常规方式并通过并行化来训练、调整、评估和预测机器学习模型。在本教程中，我们将引用的主要模块是<code class="fe nw nx ny nz b">sklearn</code>、<code class="fe nw nx ny nz b">multiprocessing</code>、<code class="fe nw nx ny nz b">pandas</code>和<code class="fe nw nx ny nz b">numpy</code>。以下是本教程中必须遵循的版本和要求。如果只是想参考与本教程相关的Jupyter笔记本，可以在我的GitHub <a class="ae ky" href="https://github.com/vatsal220/medium_articles/blob/main/parallel/sklearn_parallel.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="94ef" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">要求</h2><pre class="kj kk kl km gt oi nz oj ok aw ol bi"><span id="3bb0" class="lv lw it nz b gy om on l oo op">Python&gt;=3.8.8<br/>pandas&gt;=1.2.4<br/>numpy&gt;=1.20.1<br/>sklearn=0.24.1</span></pre><p id="a9bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也将依赖于<code class="fe nw nx ny nz b">multiprocessing</code>、<code class="fe nw nx ny nz b">random</code>和<code class="fe nw nx ny nz b">itertools</code>库。不要担心，因为这些库已经预装了Python。</p><h2 id="78ca" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">生成数据</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="0b92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的函数将随机生成一个与图书相关数据相关的CSV。数据将用于生成两个模型，一个通常没有并行化，另一个通过并行化。不会对数据进行任何特征工程或预处理，因为本文的范围是强调如何在sklearn模型上进行训练和预测。上面的函数应该产生如下所示的样本数据帧:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/d2eb70f31d03ff174819b56226241735.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tTuokV6zJsb6FYjk33apKA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">生成样本书数据。图片由作者提供。</p></figure><h1 id="370d" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">培训模型</h1><h2 id="27be" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">正常训练</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="9ad2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">梯度推进分类器没有<code class="fe nw nx ny nz b">n_jobs</code>参数，因此您无法并行化该模型的模型训练过程。</p><h2 id="7ef6" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">平行训练</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="9d98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随机森林分类器有<code class="fe nw nx ny nz b">n_jobs</code>参数，因此您可以将它指定为您想要使用的内核数量。</p><h1 id="f35a" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">并行模型评估(交叉验证)</h1><h2 id="1e2b" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">正常交叉验证</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="7002" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">平行交叉验证</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><h1 id="99bf" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">并行模型预测—单一模型</h1><p id="2f7f" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我们将把传递给模型的输入数据分成多个批次。这些批处理的大小相同，对应于您要用于并行化预测的内核数量。</p><h2 id="5ec4" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak">架构</strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/3298c41d2efd3f092324064e0c4625d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*wMlPkEIb6Ih22EjRFSkeuQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">模型架构，用于将输入数据并行化为多个分区，并将每个分区并行传递给模型。图片由作者提供。</p></figure><h2 id="a20e" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak">正常执行</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="c179" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">并行实现</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="bf79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于并行实现，我们将利用我们在正常实现期间创建的函数，并进行优化，以便使用numpy提供的<code class="fe nw nx ny nz b">array_split</code>函数将1个参数分成n个分区。</p><h1 id="d047" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">并行模型预测—多个模型</h1><p id="50da" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">现在，我们的目标是将两个单独的模型传递到两个不同的核心中，第一个模型将是我们上面生成的体裁模型，第二个将是语言模型。我们将把相同的数据传递到这些模型中的每一个，并并行地为这两个模型生成预测。</p><h2 id="95c8" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak">架构</strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/332c6360e6d8b4a09d06bffb97112950.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*gaPadKgDHhIGB8iox3-M_g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将相同的数据并行传递给多个模型的架构。每个模型将属于它自己的核心。图片由作者提供。</p></figure><h2 id="970e" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak">正常执行</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="d659" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将从创建<code class="fe nw nx ny nz b">model_data</code>开始，这是一个包含模型、特性列和目标名称的嵌套列表。我们可以迭代地传递输入数据和相关特征来生成预测。</p><h2 id="b5e9" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">并行实现</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="9ec7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以再次利用来自<code class="fe nw nx ny nz b">numpy</code>的<code class="fe nw nx ny nz b">array_split</code>函数来分割我们上面创建的<code class="fe nw nx ny nz b">model_data</code>，并将每个模型数据传递到一个核心中。每个内核本质上都将运行上述正常实现中概述的<code class="fe nw nx ny nz b">multi_prediction</code>功能。</p><h1 id="5f83" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">结束语</h1><p id="4acd" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">本文概述了如何通过并行处理将sci-kit learn中花费在训练、调整和预测模型上的时间减到最少。sci-kit learn已经在内部完成了并行训练模型的大部分繁重工作。</p><p id="1b78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我提供了一个深入的教程，展示了并行生成预测的不同方法。概述的一种方法是，当您有多个模型时，您希望将数据传递给每个模型以生成预测。您试图预测的每个模型都将作为独立的进程并行运行。概述的另一种方法是当您有一个大型数据集，您想要更快地生成预测。在这种方法中，您可以将数据集划分为多个较小的段(您应该拥有的最大段数相当于您想要使用的最大内核数)。您可以将每个部分与模型一起传递，以并行生成预测，并将结果合并在一起。</p><p id="9963" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这在您拥有大量内核和大型数据集时非常有用。当在少量数据上运行该过程时，正常(非并行)实现将在与并行实现相似的时间内运行。与该存储库相关的笔记本运行在少量数据上以提高效率，因为我没有太多可用的内存或内核。但是，您可以轻松地增加生成的数据量，从而增加为训练、评估和预测组件传递的数据量。</p><p id="9b10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种优化模型预测时间的方法是通过稀疏矩阵。这个概念超出了本文的范围，但是如果您感兴趣，您可以在这里阅读相关内容。</p><p id="a141" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解与本文相关的代码，你可以查看我的GitHub，我把笔记本<a class="ae ky" href="https://github.com/vatsal220/medium_articles/blob/main/parallel/sklearn_parallel.ipynb" rel="noopener ugc nofollow" target="_blank">放在这里</a>。</p><p id="0a85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想转型进入数据行业，并希望得到经验丰富的导师的指导和指引，那么你可能想看看最敏锐的头脑。Sharpest Minds是一个导师平台，导师(他们是经验丰富的实践数据科学家、机器学习工程师、研究科学家、首席技术官等。)将有助于你的发展和学习在数据领域找到一份工作。点击这里查看<a class="ae ky" href="https://www.sharpestminds.com/?r=vatsal-patal" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="cd96" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">资源</h1><ul class=""><li id="9129" class="mo mp it lb b lc mq lf mr li ms lm mt lq mu lu mv mw mx my bi translated">[1]<a class="ae ky" href="https://scikit-learn.org/stable/glossary.html#term-n-jobs" rel="noopener ugc nofollow" target="_blank">https://scikit-learn.org/stable/glossary.html#term-n-jobs</a></li></ul></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><p id="9511" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢读这篇文章，你可能会发现我写的关于数据科学和机器学习的其他文章也很有趣。下面来看看吧。</p><div class="pc pd gp gr pe pf"><a rel="noopener follow" target="_blank" href="/recommendation-system-matrix-factorization-svd-explained-c9a50d93e488"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">推荐系统—矩阵分解(SVD)解释</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">利用潜在因素推荐构建推荐系统管道</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">towardsdatascience.com</p></div></div><div class="po l"><div class="pp l pq pr ps po pt ks pf"/></div></div></a></div><div class="pc pd gp gr pe pf"><a rel="noopener follow" target="_blank" href="/link-prediction-recommendation-engines-with-node2vec-c97c429351a8"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">使用Node2Vec的链接预测推荐引擎</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">在Python中使用节点嵌入进行链接预测</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">towardsdatascience.com</p></div></div><div class="po l"><div class="pu l pq pr ps po pt ks pf"/></div></div></a></div><div class="pc pd gp gr pe pf"><a rel="noopener follow" target="_blank" href="/recommendation-systems-explained-a42fc60591ed"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">推荐系统解释</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">用Python解释和实现基于内容的协同过滤和混合推荐系统</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">towardsdatascience.com</p></div></div><div class="po l"><div class="pv l pq pr ps po pt ks pf"/></div></div></a></div></div></div>    
</body>
</html>