<html>
<head>
<title>Dickey-Fuller Optimization: Tackle Time Series Cointegration Head-on</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Dickey-Fuller优化:正面解决时间序列协整问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dickey-fuller-optimization-tackle-time-series-cointegration-head-on-f924f7c51477#2022-05-23">https://towardsdatascience.com/dickey-fuller-optimization-tackle-time-series-cointegration-head-on-f924f7c51477#2022-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="424c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不要介意演习；直接最小化Dickey-Fuller统计量以获得平稳的时间序列。完整的Python代码。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/49515cc522765d9be8599b880554ee13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XO46BRJtfESPsDhPbBM2aA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</p></figure><p id="86a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有许多方法可以找到协整向量。一些方法利用OLS，其他矩阵特征分解。不管采用哪种方法，通常都要对结果时间序列进行平稳性测试，以此来进行健全性检查。</p><p id="607e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">工作流程是这样的:</p><ol class=""><li id="763c" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">找到协整向量(你选择的方法)</li><li id="e1e7" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">对步骤1的向量生成的时间序列进行平稳性测试，并丢弃虚假结果</li></ol><p id="98a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">参加迪基-富勒测试。通常情况下，我们将在步骤2中使用的平稳性检验正是Dickey-Fuller检验统计量。</p><p id="9582" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们最终检查Dickey-Fuller统计量是否足够小，以说明我们的协整方法是否成功，为什么不首先简单地最小化Dickey-Fuller统计量？</p><p id="5e6c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文将通过直接最小化Dickey-Fuller检验统计量来解决协整问题。通常，在使用普通函数优化作为算法的主要驱动力之前，我会三思而行。当然，我们可以将Python中许多可用库中的任何函数扔给优化器，看看会发生什么。我以前做过很多次了。这通常不是一个好主意。</p><p id="3fa5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">函数优化可能会出错，尤其是在函数相对未知的情况下；其中包括:</p><ul class=""><li id="a15d" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt mi ma mb mc bi translated">函数调用可能很昂贵</li><li id="7d3c" class="lu lv it la b lb md le me lh mf ll mg lp mh lt mi ma mb mc bi translated">该函数可能有噪声</li><li id="c7a9" class="lu lv it la b lb md le me lh mf ll mg lp mh lt mi ma mb mc bi translated">该函数可以是非凸的</li></ul><p id="107c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">即使优化效果很好，也可能会非常慢。</p><p id="2c7a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个故事中，我们将解决所有这些问题。我们将编写一个在速度上与约翰森方法和<a class="ae mj" href="https://medium.com/towards-data-science/canonical-decomposition-a-forgotten-method-for-time-series-cointegration-and-beyond-4d1213396da1" rel="noopener"> BTCD </a>相当的方法，并且具有相同甚至更高的可靠性。然而，会涉及到一些数学问题，所以要小心。为了成功地优化函数(而不是永远这样)，我们将计算Dickey-Fuller检验统计量的梯度和Hessian矩阵。</p><h2 id="c49b" class="mk ml it bd mm mn mo dn mp mq mr dp ms lh mt mu mv ll mw mx my lp mz na nb nc bi translated">故事结构</h2><ul class=""><li id="27cd" class="lu lv it la b lb nd le ne lh nf ll ng lp nh lt mi ma mb mc bi translated">协整，问题设置</li><li id="e5a8" class="lu lv it la b lb md le me lh mf ll mg lp mh lt mi ma mb mc bi translated">迪基-富勒统计，直接估计</li><li id="9e40" class="lu lv it la b lb md le me lh mf ll mg lp mh lt mi ma mb mc bi translated">梯度</li><li id="4747" class="lu lv it la b lb md le me lh mf ll mg lp mh lt mi ma mb mc bi translated">黑森矩阵</li><li id="b9fb" class="lu lv it la b lb md le me lh mf ll mg lp mh lt mi ma mb mc bi translated">轻视</li><li id="99c7" class="lu lv it la b lb md le me lh mf ll mg lp mh lt mi ma mb mc bi translated">代码摘要</li><li id="3c43" class="lu lv it la b lb md le me lh mf ll mg lp mh lt mi ma mb mc bi translated">最后的话</li></ul><p id="7c0f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想跳过数学，跳过故事的渐变和粗麻布部分。完整的代码将出现在代码摘要部分。</p><h2 id="4a8d" class="mk ml it bd mm mn mo dn mp mq mr dp ms lh mt mu mv ll mw mx my lp mz na nb nc bi translated">协整，问题设置</h2><p id="cad3" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">实际上，协整是指多个时间序列(过程)的一阶整合。也就是说，这些时间序列(另一个时间序列)的线性组合是平稳的。谁不喜欢平稳的时间序列？</p><p id="bcdb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数学上，给定N个时间序列<em class="nl"> P_i，i=1，2，.., .n，样本大小为</em><em class="nl">T+1，</em>我们试图找到一个向量<strong class="la iu"> <em class="nl"> w </em> </strong>与分量<em class="nl"> w_i </em>这样的线性组合:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/8cd3ac907220b4dd10b88949ae426688.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*OcJm7SJaBTcYMSmlO4qG1A@2x.jpeg"/></div></figure><p id="1d5e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是静止的。</p><p id="fc02" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">给定向量<strong class="la iu"><em class="nl">w</em></strong>(“w _ vec”)和进程<em class="nl"> P_i </em>，编码为矩阵(“p_mat”)，每列一个进程，得到<em class="nl"> S </em>非常简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="42fa" class="mk ml it bd mm mn mo dn mp mq mr dp ms lh mt mu mv ll mw mx my lp mz na nb nc bi translated">迪基-富勒统计，直接估计</h2><p id="43b5" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">我们要解决的第一件事是优化函数调用速度。通常，为了计算迪基-富勒检验，我们会做OLS回归。那是昂贵的。相反，我们对测试统计数据使用<a class="ae mj" href="https://medium.com/towards-data-science/dickey-fuller-direct-estimation-speed-up-to-50x-test-statistic-computation-af3cb28b9803" rel="noopener">直接估计:</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/9e2be82a7ac9dd46800375f8a8054290.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Go-7wUrpDvJK5c5ZEKl5ZQ@2x.jpeg"/></div></div></figure><p id="7a2a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中<em class="nl"> ρ_SL，Sd是</em>滞后<em class="nl"> S </em>序列(<em class="nl"> S_L </em>)和差分<em class="nl"> S </em>序列(S_d)的相关性(Pearson)。注意<em class="nl"> S_L </em>和<em class="nl"> S_d </em>的样本量都是<em class="nl"> T </em>。</p><p id="f591" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想知道更多关于上述结果的细节，请查看我的<a class="ae mj" href="https://medium.com/towards-data-science/dickey-fuller-direct-estimation-speed-up-to-50x-test-statistic-computation-af3cb28b9803" rel="noopener">之前的故事</a>和数学证明。</p><p id="1050" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用这种形式的Dickey-Fuller统计更快，因为计算相关系数在计算上比OLS矩阵求逆和乘法更有效。此外，它还有另一个优点；统计量对向量<strong class="la iu"> <em class="nl"> w </em> </strong>的依赖性是清楚的。因为相关性是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/ad9c91cd5bf688a985d2aaa26fdbf8a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BGKcQ_2QxqwgdK4ZxkobMA@2x.jpeg"/></div></div></figure><p id="aab8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">并且<em class="nl"> S_L </em>和<em class="nl"> S_d </em>的协方差和方差可以使用协方差矩阵和<strong class="la iu"> <em class="nl"> w </em> </strong>向量写成二次型，即</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/9db38e93dafad5e0fce8ab470cab112a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*R69Yc3OqJIwdw7M7TE99iA@2x.jpeg"/></div></figure><p id="2662" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">和</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/f850a69c5ad4306906882712c4f73f3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IP-5dEDpu9kIHbbyTmN0mQ@2x.jpeg"/></div></div></figure><p id="4f84" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中<em class="nl"> V_L </em>为滞后<em class="nl"> P_i </em>时间序列的协方差矩阵，<em class="nl"> V_d </em>为差分<em class="nl"> P_i </em>时间序列的协方差矩阵，<em class="nl"> V_L，d </em>和<em class="nl"> V_d，L </em>为滞后差分时间序列的互协方差矩阵，定义为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/90ef8508df4a7a5587b1af6dff3a62bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IpQ3r556DYRqV99KI0SKzQ@2x.jpeg"/></div></figure><p id="93ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">具有以下属性:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/260f24e87a424bcb2c6453cc6655b2fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*2Puv0U74XQTztgZ4wIvQgQ@2x.jpeg"/></div></figure><p id="105e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上标表示矩阵转置。</p><p id="c8db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对谈话进行编码时，我们用计算中需要的基本变量初始化“_SInit”对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="140b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后是另一个对象“_ PCovMatrices”，它包含我们需要的协方差矩阵:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="5a76" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，滞后和差异<em class="nl"> S </em>系列的标准偏差对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="a228" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了编码的初始对象，我们现在可以陈述我们的目标函数，Dickey-Fuller统计直接估计:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="fea4" class="mk ml it bd mm mn mo dn mp mq mr dp ms lh mt mu mv ll mw mx my lp mz na nb nc bi translated">梯度</h2><p id="9c8e" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated"><em class="nl"> DF </em>(迪基-富勒)相对于<strong class="la iu"> <em class="nl"> w </em> </strong>的梯度为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/b2c59762b6b49b50fc852a0f2d8aa119.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xLInK9gM4RBXKP37oXOZww@2x.jpeg"/></div></div></figure><p id="8912" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">相关性的梯度是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/f011433dbf307eefeb96ebfbcf86ecad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MNjIXDQnaf5-zMw23RIYRg@2x.jpeg"/></div></div></figure><p id="6382" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用二次型的梯度，标准差和协方差的梯度为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/8e669f5d132e19a13bfce55788364ab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*o1rbXTZjBSIn0r_OyZ9n6g@2x.jpeg"/></div></figure><p id="3d86" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">和</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/56113520f280310ad82bec5b309131e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jT8Bn7hS-hZLW3M9MSJfBA@2x.jpeg"/></div></div></figure><p id="0d1e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/ac415424ec7ad6e24b691ace9fe8aaf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0wOMPJAFFrC8ylFpVvdxEw@2x.jpeg"/></div></div></figure><p id="fc27" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">编码渐变:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="982b" class="mk ml it bd mm mn mo dn mp mq mr dp ms lh mt mu mv ll mw mx my lp mz na nb nc bi translated">黑森矩阵</h2><p id="9e4a" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">为了得到Hessian矩阵，我们将使用张量微积分，因为我们需要处理矩阵对向量的导数，以及这类有趣的数学，所以张量微积分是最适合的。</p><p id="feef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将使用爱因斯坦的重复指数求和约定；因为我们有许多指数，所以求和符号会使一切变得更加复杂。此外，我们将使用以下简化:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/c7915d5d7d4aff5746376a95ee98c8a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*3hiPk0QSptKZsaLgg7CUZw@2x.jpeg"/></div></figure><p id="2ed4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在协方差矩阵中，我们将下标字段用于索引:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/f6671214d1ae231c45d9e91156cc9812.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*ROsErwuDJFM_y6T6LZ6REw@2x.jpeg"/></div></figure><p id="546c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">索引将用希腊字母书写，以区别于其他下标和上标。</p><p id="2b83" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">黑森是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/49f53fb52cb7a621a980aeed0013c9c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6j-8oo4YOrrJx6PzsuXosg@2x.jpeg"/></div></div></figure><p id="3bb6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在哪里</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/5e7ed42e650c6c336b9b1ea475319256.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*bZD_hWGfyrBe1PUfUE0UBA@2x.jpeg"/></div></figure><p id="55a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是相关的梯度，用向量微积分符号表示</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/dd4b15e313dacf4c36f0a50bfd8f271b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6x6Q_imxQJHUjQ8DpiZdgw@2x.jpeg"/></div></div></figure><p id="3b6e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设梯度是列向量。</p><p id="f0ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要计算ρ的海森数。也就是说，让我们定义我们将使用的两个矩阵:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/8ea95065dd7c4c1f80d9c020bd9f5d0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*8QMoPW4CHZrPPDdYQjbOJA@2x.jpeg"/></div></figure><p id="031e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">和一个4张量:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/c1487b055f8abcb47461e5ecdc6e6c7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*90INF-_Ursiqlzf_JPC_iw@2x.jpeg"/></div></div></figure><p id="a4a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么ρ的梯度(在前面的部分中已经在向量微积分符号中)在张量微积分符号中是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/1f05aee282e3824929f472d74dbf9ffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eki0ecoflOFLmr3RAlTE7Q@2x.jpeg"/></div></div></figure><p id="ac24" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很难不喜欢张量微积分的优雅。</p><p id="0b0c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，ρ的黑森式是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/be51de03c27ded14482bc5a54e5482f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZhknU4DH_oiwlvllhB7V_A@2x.jpeg"/></div></div></figure><p id="3557" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然它看起来像广义相对论中坍缩黑洞的方程(开玩笑)，但用Python编写这个非常简单，这要感谢NumPy的“einsum”:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="e8a5" class="mk ml it bd mm mn mo dn mp mq mr dp ms lh mt mu mv ll mw mx my lp mz na nb nc bi translated">轻视</h2><p id="8c3b" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">一旦我们有了目标函数、梯度和Hessian，最小化代码块就非常简单了。本质上，我们用协整问题的参数来包装SciPy的最小化函数:</p><ul class=""><li id="436f" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt mi ma mb mc bi translated">“p_mat”是<em class="nl"> P_i </em>过程矩阵。</li><li id="f12e" class="lu lv it la b lb md le me lh mf ll mg lp mh lt mi ma mb mc bi translated">“w_vec_init”是对w_vec的初始猜测。不供一个也不用担心；将生成一个随机猜测。</li><li id="18e5" class="lu lv it la b lb md le me lh mf ll mg lp mh lt mi ma mb mc bi translated">“方法”只能取两个值，要么是“信任-克雷洛夫”，要么是“信任-精确”。</li></ul><p id="e112" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意:这不是一个全局优化器，所以给定一个初始的<strong class="la iu"> <em class="nl"> w </em> </strong>向量对于收敛是必不可少的。在某些问题中，随机选取的向量足以收敛。但是，最好是针对您的特定情况生成一个更好的初始猜测。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="a51b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将生成离散采样的相关布朗运动(单位根过程)，并使用该矩阵作为“p_mat”来测试算法。如果你不知道布朗运动或如何产生它们，不要担心；看看我之前关于这个话题的报道。我们将使用那个故事中的代码来生成“p_mat ”,因此将来自<a class="ae mj" rel="noopener" target="_blank" href="/stochastic-processes-simulation-brownian-motion-the-basics-c1d71585d9f9">布朗运动故事</a>的代码保存为“brownian_motion.py ”,并将其放在运行以下代码的同一个目录中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="15e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最小化并绘图:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/8f47f17baa5503272393872731841903.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X-lQHKQOaIpq-i7bI6Xu2g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</p></figure><p id="2b78" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一切都按计划进行。</p><h2 id="2c51" class="mk ml it bd mm mn mo dn mp mq mr dp ms lh mt mu mv ll mw mx my lp mz na nb nc bi translated">代码摘要</h2><p id="862a" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">为了完整起见，这里是故事中开发的所有代码。通过最小化Dickey-Fuller检验统计量来获得协整向量所需的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="a86e" class="mk ml it bd mm mn mo dn mp mq mr dp ms lh mt mu mv ll mw mx my lp mz na nb nc bi translated">最后的话</h2><p id="bb7e" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">开发的优化算法按预期工作。速度不如特征分解算法，但不相上下。它非常健壮和可靠。</p><p id="b2a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，唯一的缺点是协整向量的初始猜测的选择。我已经看到该方法对于初始猜测的错误选择是非常宽容的；大多数时候，随机的初始猜测非常有效。然而，做出好的选择可以提高解决方案的速度和可靠性。记住，这是局部优化器，不是全局优化器。</p><p id="e272" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，使用梯度和hessian，很容易将此代码扩展为约束优化，这更适合于现实世界的问题。可以很容易地将约束添加到该方法中。特征分解方法必须重写以适应约束。</p><h2 id="d6c2" class="mk ml it bd mm mn mo dn mp mq mr dp ms lh mt mu mv ll mw mx my lp mz na nb nc bi translated">参考</h2><p id="1819" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">[1] M. L. de Prado，D. Leinweber，<a class="ae mj" href="http://.../" rel="noopener ugc nofollow" target="_blank">协整和子集相关套期保值方法的进展</a> (2012)，《投资策略杂志》，第1卷第2期，第67–115页</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><p id="3787" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望这个故事对你有用。在<a class="ae mj" href="https://medium.com/@diego-barba" rel="noopener"> Medium </a>上关注我，如果你想要更多这样的故事，请订阅。</p><div class="oj ok gp gr ol om"><a href="https://medium.com/subscribe/@diego-barba" rel="noopener follow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">每当迭戈·巴尔巴出版时，就收到一封电子邮件。</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">每当迭戈·巴尔巴出版时，就收到一封电子邮件。通过注册，您将创建一个中型帐户，如果您还没有…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">medium.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa ks om"/></div></div></a></div><p id="473d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我错过了什么，请让我知道。对于任何质疑、批评等。，留言评论。</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><p id="8441" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">喜欢这个故事吗？通过我的推荐链接成为媒体会员，可以无限制地访问我的故事和许多其他内容。</p><div class="oj ok gp gr ol om"><a href="https://medium.com/@diego-barba/membership" rel="noopener follow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">通过我的推荐链接加入Medium-Diego Barba</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">medium.com</p></div></div><div class="ov l"><div class="pb l ox oy oz ov pa ks om"/></div></div></a></div></div></div>    
</body>
</html>