<html>
<head>
<title>A/B Tests, Privacy, and Online Regression</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">A/B测试、隐私和在线回归</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-b-tests-privacy-and-online-regression-b07ab46aa782#2022-09-08">https://towardsdatascience.com/a-b-tests-privacy-and-online-regression-b07ab46aa782#2022-09-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="e3d8" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/causal-data-science" rel="noopener" target="_blank">因果数据科学</a></h2><div class=""/><div class=""><h2 id="b4fd" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated"><em class="ko">如何在不存储个体水平数据的情况下运行实验</em></h2></div><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/50e54a890faddd00c7cbffe8798886c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0GcFwxDY8LWDdmpRm0JpEw.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">封面图片，由作者使用<a class="ae lf" href="https://creator.nightcafe.studio/" rel="noopener ugc nofollow" target="_blank">nightcafe</a>生成</p></figure><p id="a569" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated"><strong class="li ja"> AB测试</strong>，又名<a class="ae lf" href="https://en.wikipedia.org/wiki/Randomized_controlled_trial" rel="noopener ugc nofollow" target="_blank">随机对照试验</a>，被广泛认为是计算治疗(药物、广告、产品等)对相关结果(疾病、公司收入、客户满意度等)的<strong class="li ja">因果</strong>影响的黄金标准技术。该程序包括将一组受试者(患者、使用者、顾客……)随机分为治疗组和对照组，并对治疗组进行治疗。<strong class="li ja">随机性</strong>确保两组之间的预期差异由治疗引起。</p><p id="aaf6" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">在A/B测试中，一个潜在的隐私问题是，为了评估治疗的效果，需要在整个实验过程中存储许多用户的数据。如果我们可以即时运行实验，这不是问题，但是当实验持续时间很长时，这可能会成为一个问题。在这篇文章中，我们将探索这个问题的一个解决方案:<strong class="li ja">在线回归</strong>。我们将看到如何估计(有条件的)平均治疗效果，以及如何使用中心极限定理和bootstrapping进行推断，一次一个观察值，仅存储汇总信息。</p><p id="2889" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">⚠️:我已经省略了一些方程式后面的代数运算。如果你想看更多的背景代数，让我知道，我会很高兴地添加另一部分。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="baa4" class="mj mk iq bd ml mm mn mo mp mq mr ms mt kf mu kg mv ki mw kj mx kl my km mz na bi translated">简单的例子</h1><p id="2e64" class="pw-post-body-paragraph lg lh iq li b lj nb ka ll lm nc kd lo lp nd lr ls lt ne lv lw lx nf lz ma mb ij bi translated">假设我们是一家金融科技公司。我们为我们的移动应用程序设计了一个新的用户界面(UI ),我们希望了解它是否会降低我们的交易速度。为了评估新用户界面对交易速度的因果影响，我们计划运行一个<strong class="li ja"> A/B测试</strong>或随机控制试验:我们将用户随机分成两组，向其中一组展示新用户界面，并比较两组的平均交易速度。</p><p id="5816" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们有一个主要问题:由于隐私原因，我们不能存储事务级信息。此外，我们不能一次性完成实验，因为我们只在交易完成时观察交易。我们能做什么？</p><p id="c352" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">先来看看<strong class="li ja">数据</strong>。我从<code class="fe ng nh ni nj b"><a class="ae lf" href="https://github.com/matteocourthoud/Blog-Posts/blob/main/notebooks/src/dgp.py" rel="noopener ugc nofollow" target="_blank">src.dgp</a></code>导入数据生成过程<code class="fe ng nh ni nj b">dgp_credit()</code>，从<code class="fe ng nh ni nj b"><a class="ae lf" href="https://github.com/matteocourthoud/Blog-Posts/blob/main/notebooks/src/utils.py" rel="noopener ugc nofollow" target="_blank">src.utils</a></code>导入一些绘图函数和库。为了不仅包括代码，还包括数据和表格，我使用了<a class="ae lf" href="https://deepnote.com" rel="noopener ugc nofollow" target="_blank"> Deepnote </a>，一个类似Jupyter的基于网络的协作笔记本环境。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3adf" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">首先，我生成整个数据集。然后，我们将研究如何在数据动态到达的情况下执行实验分析。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nm nl l"/></div></figure><p id="86b4" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们有100个用户的信息，我们观察他们是否被随机分配了<code class="fe ng nh ni nj b">newUI</code>，他们的<code class="fe ng nh ni nj b">connection</code>速度和<code class="fe ng nh ni nj b">transfer</code>速度。</p><p id="3cba" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">首先，让我们通过在治疗指标(<code class="fe ng nh ni nj b">newUI</code>)上回归感兴趣的结果(<code class="fe ng nh ni nj b">transfer</code>速度)来估计治疗效果。随机化确保<code class="fe ng nh ni nj b">newUI</code>的系数是因果治疗效果的<strong class="li ja">无偏</strong>估计。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nn nl l"/></div></figure><p id="9645" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated"><code class="fe ng nh ni nj b">newUI</code>的系数为正(6.5008)，但无统计学意义(p=0.113)。</p><p id="dca1" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们怀疑<code class="fe ng nh ni nj b">connection</code>速度也会影响<code class="fe ng nh ni nj b">transfer</code>速度，对其进行分析可能会增加其功率。让我们运行同样的回归，添加<code class="fe ng nh ni nj b">log(connection)</code>作为<strong class="li ja">协变量</strong>。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="no nl l"/></div></figure><p id="4654" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">实际上，估计的系数没有太大变化，但是标准误差已经减小，系数现在在5%的水平上<strong class="li ja">具有统计显著性</strong>(p = 0.031)。</p><p id="f621" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">为了理解我们如何一次运行一个数据点的线性回归，我们首先需要一个简单的线性代数回顾。</p><p id="e25f" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">首先，让我们定义<em class="np"> y </em>因变量，<code class="fe ng nh ni nj b">transfer</code>速度，以及<em class="np"> X </em>解释变量，<code class="fe ng nh ni nj b">newUI</code>指示器，<code class="fe ng nh ni nj b">log(connection)</code>速度和一个常数项。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nq nl l"/></div></figure><p id="5b57" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">OLS估计量由下式给出</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nr"><img src="../Images/b4947138d1e08c27becd79d47585affa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vvrc31rozJw54QlgPMkwnA.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">OLS估算公式，作者图片</p></figure><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ns nl l"/></div></figure><p id="3e3a" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">事实上，我们得到了与使用<code class="fe ng nh ni nj b">smf.ols</code>命令完全相同的数字！</p><p id="5e08" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们可以一次一个观察值地计算OLS系数<em class="np">β</em>T4吗？</p><p id="f47b" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">答案是肯定的！假设我们有<em class="np"> n </em>个观察值，并且我们刚刚收到第<em class="np"> n+1 </em>个观察值:一对(xₙ₊₁，yₙ₊₁).为了计算<em class="np"> β̂ₙ₊₁，</em>我们只需要在内存中存储两个对象:</p><ul class=""><li id="f7b5" class="nt nu iq li b lj lk lm ln lp nv lt nw lx nx mb ny nz oa ob bi translated"><em class="np"> β̂ₙ，</em>先前估计的<em class="np"> β </em></li><li id="05a0" class="nt nu iq li b lj oc lm od lp oe lt of lx og mb ny nz oa ob bi translated">(Xₙ'Xₙ)⁻，X'X)⁻的前值</li></ul><p id="5573" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">首先，我们如何更新(X'X)⁻？</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi oh"><img src="../Images/0280a68247334560bed649ed02ad4b6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V5PXuYYwQM0lOxp3YYtbIw.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">更新规则(X'X)⁻，图片由作者提供</p></figure><p id="bef4" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">更新完(X'X)⁻)之后，我们可以更新<em class="np"> β̂ </em>。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi oi"><img src="../Images/40a83c574fc4ca829fb83b595588acb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yahgTOHmRPBVgYeOHXRQ6w.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">更新β <em class="ko">的规则，图片作者</em></p></figure><p id="bb0d" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">请注意，这个过程不仅是隐私友好的，而且是记忆友好的。我们的数据集是一个100×4的矩阵，而X'X)⁻是一个3×3的矩阵，β是一个3×1的矩阵。我们只存储12个号码，而不是多达400个！</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="oj nl l"/></div></figure><p id="6fe4" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们现在准备<strong class="li ja">估算</strong>我们的OLS系数，一次一个数据点。然而，我们不能真的从第一次观察开始，因为我们不能对矩阵X'X求逆。我们至少需要<em class="np"> k+1 </em>个观测值，其中<em class="np"> k </em>是<em class="np"> X </em>中变量的个数。</p><p id="af0f" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">为了安全起见，我们使用10次观察中的一次<strong class="li ja">热启动</strong>。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nm nl l"/></div></figure><p id="25eb" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们得到了完全相同的系数！不错！</p><p id="d57f" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们是如何到达那里的？随着数据的积累，我们可以绘制出β̂估计值的演变图。动态标绘功能稍微麻烦一点，不过你可以在<code class="fe ng nh ni nj b"><a class="ae lf" href="https://github.com/matteocourthoud/Blog-Posts/blob/main/notebooks/src/figures.py" rel="noopener ugc nofollow" target="_blank">src.figures</a></code>里找到。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ok nl l"/></div></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl ol"><img src="../Images/2ee99551f5decca1565fba73e8a118a7.png" data-original-src="https://miro.medium.com/v2/1*nP5YeVXUQ4JYYJ6WrmxJKw.gif"/></div></figure><p id="740b" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">正如我们所看到的，随着数据点数量的增加，估计值似乎变得越来越不稳定。</p><p id="63ba" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">这是真的吗？像往常一样，我们不仅对<code class="fe ng nh ni nj b">newUI</code>对支出影响的点估计感兴趣，我们还想了解这个估计有多精确。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="fe74" class="mj mk iq bd ml mm mn mo mp mq mr ms mt kf mu kg mv ki mw kj mx kl my km mz na bi translated">推理</h1><p id="ec0e" class="pw-post-body-paragraph lg lh iq li b lj nb ka ll lm nc kd lo lp nd lr ls lt ne lv lw lx nf lz ma mb ij bi translated">我们已经看到了如何“在线”估计治疗效果:一次一个观察。我们可以用同样的方法计算估计量的方差吗？</p><p id="5c2a" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">首先，让我们回顾一下OLS估计量的方差是什么样子的。在基线假设下，OLS估计量的方差由下式给出:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi om"><img src="../Images/30ca2f0f8d5b0a92c5f8c3f1dbe09d7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-qXhBCLCdljV2IqJsBDb_w.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">OLS估计量的方差公式，作者图片</p></figure><p id="0b35" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">其中<em class="np"> σ̂ </em>是残差<em class="np">e=(y−x'β̂</em>的方差。</p><p id="d134" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">回归表报告了系数的标准误差，即<em class="np"> Var(β̂) </em>对角元素的平方根。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="on nl l"/></div></figure><p id="610d" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">让我们检查一下，使用矩阵代数我们确实会得到相同的数。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="oo nl l"/></div></figure><p id="a5e9" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">的确，我们得到了完全相同的数字！</p><p id="1c6e" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们已经有方法在线更新<em class="np"> β̂: </em> (X'X)⁻ <em class="np">)的一部分方差。</em>我们如何更新σ̂？这是更新残差平方和的公式。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi op"><img src="../Images/460d22c796ff6eca5fce6655c2fc6783.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fm9ZoFZm9vvlIWQggFaOaA.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">按作者更新图像的规则</p></figure><p id="3822" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">为了从残差平方和<em class="np"> S </em>中得到残差方差<em class="np"> σ̂ </em>，我们需要除以自由度:n–k = 100–3。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="oq nl l"/></div></figure><p id="3961" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">注意顺序很重要！S 是使用X'X)⁻和β̂ 的旧值计算的，因此必须首先更新。</p><p id="2865" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们现在可以一次一个观测值地计算<em class="np"> β̂ </em>及其估计方差。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="or nl l"/></div></figure><p id="564e" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们确实得到了同样的结果！</p><p id="76e6" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">如前所述，我们可以<strong class="li ja">绘制OLS系数估计值随时间的演变</strong>，并增加正负一个标准差的置信区间。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="os nl l"/></div></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl ol"><img src="../Images/3b963d4ad830e5bfaa4cabc769d2b7f9.png" data-original-src="https://miro.medium.com/v2/1*qI2PzSXIQqFasjxlQcHTPQ.gif"/></div></figure><p id="2cda" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">正如我们所看到的，OLS估计量的估计方差确实随着样本量的增加而减小。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="bac7" class="mj mk iq bd ml mm mn mo mp mq mr ms mt kf mu kg mv ki mw kj mx kl my km mz na bi translated">引导程序</h1><p id="204f" class="pw-post-body-paragraph lg lh iq li b lj nb ka ll lm nc kd lo lp nd lr ls lt ne lv lw lx nf lz ma mb ij bi translated">到目前为止，我们已经使用了中心极限定理背后的渐近假设来计算估计量的标准误差。然而，我们有一个特别小的样本。我们进一步检查模型<strong class="li ja">残差</strong>的经验分布。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="os nl l"/></div></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl ol"><img src="../Images/c5120bc78f620e713c0344bc88f47651.png" data-original-src="https://miro.medium.com/v2/format:webp/1*8OA-87Aviqfz-AxF33IXnw.png"/></div></figure><p id="3fb1" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">残差好像特别<strong class="li ja">偏</strong>！在如此小的样本中，这可能是一个问题。</p><p id="dc36" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">大样本理论的另一种选择是自助法。我们不再依赖<a class="ae lf" href="https://en.wikipedia.org/wiki/Central_limit_theorem" rel="noopener ugc nofollow" target="_blank">中心极限定理</a>，而是通过替换对数据集进行重新采样来近似估计量的分布。我们可以在线自举吗？</p><p id="d01b" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">答案再次是肯定的！关键是<strong class="li ja">用从均值(和方差)等于1的泊松分布中提取的整数权重对每个观察值</strong>进行加权。对于每个观察值，我们重复这个过程多次，并存储各自的中间估计值。我们将得到<em class="np"> K </em>，即自举样本的数量，而不是在任何时间点对<em class="np"> β </em>的单一中间估计。</p><p id="a8a3" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">(X'X)⁻和<em class="np"> β̂ </em>的更新规则变为</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ot"><img src="../Images/d87f7670ba05923157e64a381541ec16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NPtFHK14zXiR7yoqD0DZsw.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">更新规则(X'X)⁻与引导权重，按作者排序的图像</p></figure><p id="2a83" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">和</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ou"><img src="../Images/275d9faf793bb90800e059454d44ea9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z2fWidPAR_eWf--g6gNbiw.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">使用引导权重更新<em class="ko"> β̂ </em>的规则，图片作者</p></figure><p id="77d6" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">其中<em class="np"> w </em>是泊松权重。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="oj nl l"/></div></figure><p id="f76d" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们现在可以运行在线评估。我们自举<em class="np"> K=1000 </em>不同于<em class="np"> β̂ </em>的估计。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ov nl l"/></div></figure><p id="ec82" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们可以通过计算自举系数向量的标准差来估计治疗效果的标准差。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ow nl l"/></div></figure><p id="2b65" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">估计的标准误差与以前的值[5.05，3.01，1.49]略有不同，但相差不是很远。</p><p id="8d3b" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">最后，有些人可能想知道"<em class="np">为什么对离散重量而不是连续重量进行采样？</em>”。的确，我们可以。这个过程被称为<strong class="li ja">贝叶斯引导</strong>，你可以在这里找到更详细的解释<a class="ae lf" rel="noopener" target="_blank" href="/6ca4a1d45148">。</a></p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="bdd6" class="mj mk iq bd ml mm mn mo mp mq mr ms mt kf mu kg mv ki mw kj mx kl my km mz na bi translated">结论</h1><p id="b1cf" class="pw-post-body-paragraph lg lh iq li b lj nb ka ll lm nc kd lo lp nd lr ls lt ne lv lw lx nf lz ma mb ij bi translated">在这篇文章中，我们看到了如何运行一个实验，而不存储个人水平的数据。我们如何能够做到这一点？为了计算平均治疗效果，我们不需要每一个单独的观察值，但是存储一个更紧凑的表示就足够了。</p><p id="2a33" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">该过程不仅是隐私友好的，而且是<strong class="li ja">存储器高效的</strong>，因为反向得分矩阵(X'X)⁻和估计系数<em class="np"> β̂ </em>通常具有比数据集小得多的维度(只要<em class="np"> X </em>的维度小，这可能是随机控制试验中的情况)。</p><h2 id="e74c" class="ox mk iq bd ml oy oz dn mp pa pb dp mt lp pc pd mv lt pe pf mx lx pg ph mz iw bi translated">参考</h2><p id="2fa1" class="pw-post-body-paragraph lg lh iq li b lj nb ka ll lm nc kd lo lp nd lr ls lt ne lv lw lx nf lz ma mb ij bi translated">[1] W. Chou，<a class="ae lf" href="https://arxiv.org/abs/2102.03316" rel="noopener ugc nofollow" target="_blank">无资料保留的随机对照试验</a> (2021)，<em class="np">工作论文</em>。</p><h2 id="f459" class="ox mk iq bd ml oy oz dn mp pa pb dp mt lp pc pd mv lt pe pf mx lx pg ph mz iw bi translated">相关文章</h2><ul class=""><li id="d99b" class="nt nu iq li b lj nb lm nc lp pi lt pj lx pk mb ny nz oa ob bi translated"><a class="ae lf" rel="noopener" target="_blank" href="/954506cec665">实验、窥视和最佳停止</a></li><li id="6b76" class="nt nu iq li b lj oc lm od lp oe lt of lx og mb ny nz oa ob bi translated"><a class="ae lf" rel="noopener" target="_blank" href="/6ca4a1d45148">贝叶斯自举</a></li></ul><h2 id="f8ad" class="ox mk iq bd ml oy oz dn mp pa pb dp mt lp pc pd mv lt pe pf mx lx pg ph mz iw bi translated">密码</h2><p id="b939" class="pw-post-body-paragraph lg lh iq li b lj nb ka ll lm nc kd lo lp nd lr ls lt ne lv lw lx nf lz ma mb ij bi translated">你可以在这里找到Jupyter的原始笔记本:</p><div class="pl pm gp gr pn po"><a href="https://github.com/matteocourthoud/Blog-Posts/blob/main/notebooks/online_reg.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="pp ab fo"><div class="pq ab pr cl cj ps"><h2 class="bd ja gy z fp pt fr fs pu fu fw iz bi translated">Blog-Posts/online _ reg . ipynb at main matter courthoud/Blog-Posts</h2><div class="pv l"><h3 class="bd b gy z fp pt fr fs pu fu fw dk translated">我的中型博客文章的代码和笔记本。为matteocourthoud/Blog-Posts的发展作出贡献</h3></div><div class="pw l"><p class="bd b dl z fp pt fr fs pu fu fw dk translated">github.com</p></div></div><div class="px l"><div class="py l pz qa qb px qc kz po"/></div></div></a></div></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h2 id="6d95" class="ox mk iq bd ml oy oz dn mp pa pb dp mt lp pc pd mv lt pe pf mx lx pg ph mz iw bi translated">感谢您的阅读！</h2><p id="ccf8" class="pw-post-body-paragraph lg lh iq li b lj nb ka ll lm nc kd lo lp nd lr ls lt ne lv lw lx nf lz ma mb ij bi translated">我真的很感激！🤗<em class="np">如果你喜欢这个帖子并且想看更多，可以考虑</em> <a class="ae lf" href="https://medium.com/@matteo.courthoud" rel="noopener"> <strong class="li ja"> <em class="np">关注我</em> </strong> </a> <em class="np">。我每周发布一次与因果推断和数据分析相关的主题。我尽量让我的帖子简单而精确，总是提供代码、例子和模拟。</em></p><p id="3127" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated"><em class="np">还有，一个小小的</em> <strong class="li ja"> <em class="np">免责声明</em> </strong> <em class="np">:我写作是为了学习所以错误是家常便饭，尽管我尽力了。当你发现他们的时候，请告诉我。也很欣赏新话题的建议！</em></p></div></div>    
</body>
</html>