<html>
<head>
<title>Time series prediction with LSTM in Tensorflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">张量流中的LSTM时间序列预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/time-series-prediction-with-lstm-in-tensorflow-42104db39340#2022-06-22">https://towardsdatascience.com/time-series-prediction-with-lstm-in-tensorflow-42104db39340#2022-06-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ec66" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki">了解如何创建基于LSTM的神经网络来预测单变量时间序列</em></h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kj"><img src="../Images/1170de13d8c45606bde536dbd6d79b35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Y-aya4xwd80Qn6-nAzqsDw.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@agebarros?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">阿格巴洛斯</a>在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="5343" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">在本文中，您将学习如何使用Python中的Tensorflow和Keras对时间序列进行预测。</p><p id="6c6d" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们将使用基于<strong class="ky iu">双向LSTM层</strong>在Tensorflow中创建的序列神经网络来捕获我们将输入到模型中的单变量序列中的模式。</p><p id="211c" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">特别是我们将看到如何</p><ul class=""><li id="cd18" class="ls lt it ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky iu">生成合成数据</strong>模拟具有不同特征的时间序列</li><li id="8a63" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky iu">处理训练和验证集中的数据</strong>并基于时间窗口创建数据集</li><li id="b073" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">使用LSTM (长短期记忆)为我们的神经网络定义一个<strong class="ky iu">架构</strong></li><li id="a383" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky iu">训练和评估模型</strong></li></ul><p id="c2de" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">本教程的目标是在给定一系列数据的情况下预测未来的某一点。不包括多步情况，即预测了前一个点，而该点又被模型预测了。</p><p id="3c27" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这个指南的灵感来自于Coursera的DeepLearning。AI TensorFlow开发者专精，我强烈建议任何感兴趣的读者去看看。</p><p id="e43c" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们开始吧。</p><h1 id="5e27" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">生成数据</h1><p id="70c7" class="pw-post-body-paragraph kw kx it ky b kz my ju lb lc mz jx le lf na lh li lj nb ll lm ln nc lp lq lr im bi translated">我们将使用允许我们为我们的情况生成合成时间序列的函数，而不是从网上下载数据集。我们还将使用<strong class="ky iu"> dataclasses </strong>将我们的时间序列参数存储在一个类中，这样我们就可以使用它们而不用考虑范围。数据类名称将为<strong class="ky iu"> <em class="nd"> G </em> </strong>，代表“全局”。</p><p id="1203" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我决定使用这种方法，而不是使用真实的数据集，因为这种方法允许我们测试多个时间序列，并在项目的创作过程中具有灵活性。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="b8b6" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">让我们用这段代码生成一个合成时间序列</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="bda4" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这是获得的系列</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/e9acb40ec2c2ac710b33d1cb835e5f37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/0*ZMaTNPUl74eCvzWf.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">通过我们的功能创造的合成系列。图片作者。</p></figure><p id="07f8" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">现在我们有了可用的时间序列，让我们继续进行<strong class="ky iu">预处理</strong>。</p><h1 id="4028" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">深度学习时间序列的预处理</h1><p id="3985" class="pw-post-body-paragraph kw kx it ky b kz my ju lb lc mz jx le lf na lh li lj nb ll lm ln nc lp lq lr im bi translated">时间序列的特点是，它们必须分为训练集和验证集，而训练集和验证集又必须分为长度由我们的配置定义的序列。这些序列被称为<em class="nd">窗口</em>，模型将使用这些序列生成预测。</p><p id="fd5c" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">让我们再看两个助手函数来实现这一点。</p><p id="a95b" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这里需要一些解释。<em class="nd"> train_val_split </em>函数只是根据之前在G数据类中定义的<em class="nd"> G.SPLIT_TIME </em>值来划分我们的序列。此外，我们将传递给它G.TIME和G.SERIES参数。</p><p id="234c" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">让我们回忆一下G数据类的定义。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nh"><img src="../Images/09b5dc738a1ff1f0d3ce7540e285b7ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PBlWCsHtikEHWkAsXAYq1Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用于存储和维护数据的全局数据类。图片作者。</p></figure><p id="8cfc" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">通过调用<em class="nd"> generate_time_series，</em>我们得到</p><p id="9af8" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated"><em class="nd">时间=范围(0，1439) </em></p><p id="f163" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated"><em class="nd"> SERIES = array([ 0.81884814，0.82252744，0.77998762，…, -0.44389692，-0.42693424，-0.39230758]) </em></p><p id="542e" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">长度都是1439。</p><p id="f5b6" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated"><em class="nd"> train_val_split </em>的分割将等于</p><p id="aefb" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated"><em class="nd"> time_train = range(0，1100) </em></p><p id="5f70" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated"><em class="nd"> time_val = range(1100，1439) </em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/afcce1411bb9427d1061591e1c32092f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/0*CEkYxelG6MPufnLU.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">如何将时间序列分为X和y。图片由作者提供。</p></figure><p id="1cdb" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">分成训练集和验证集后，我们将使用一些Tensorflow函数来创建一个数据集对象，它将允许我们创建X要素和y目标。回想一下，X是模型将用来预测下一个值(即y)的n个值。</p><p id="c5ca" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">让我们看看如何实现这些功能</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="ef8d" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们会用Tensorflow的<em class="nd">。window() </em>方法在dataset对象上对我们的点应用1的移位。这里可以看到一个应用逻辑的例子:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nn"><img src="../Images/3e6135a9b55c866b1c5ffcb66aff6d2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KcVy77VW1XbXfyhc.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">如何制作窗口数据集。图片作者。</p></figure><p id="4626" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">在示例中，我们使用Tensorflow创建了一个从0到10的范围，并应用了一个5的窗口。然后，我们将总共创建5列。传递<em class="nd"> shift = 1 </em>每一列将从顶部开始减少一个值，并且<em class="nd"> drop_remainder = True </em>将确保您总是有一个相同大小的矩阵。</p><p id="5d77" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">让我们应用这两个函数。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a9f0" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">现在数据已经准备好了，我们可以继续构建我们的神经网络。</p><h1 id="92db" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">神经网络体系结构</h1><p id="f005" class="pw-post-body-paragraph kw kx it ky b kz my ju lb lc mz jx le lf na lh li lj nb ll lm ln nc lp lq lr im bi translated">正如文章开头提到的，我们的神经网络将主要基于<strong class="ky iu"> LSTM(长短期记忆)层</strong>。LSTM之所以适合这种任务，是因为它的内部结构能够通过长序列传播信息。</p><p id="fd23" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这使得它们在自然语言处理(NLP)和时间序列中非常有用，因为这两种类型的任务可能需要在整个序列中传递信息。</p><p id="b922" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">在下面的代码中，我们将看到LSTM层是如何包含在一个双向层中的。该层允许LSTM考虑两个方向上的数据序列，因此<strong class="ky iu">不仅具有过去的上下文，还具有未来的上下文</strong>。它将帮助我们建立一个比单向网络更精确的网络。</p><p id="f8b8" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">除了LSTMs，还有gru(门控递归单元)可用于时间序列预测任务。</p><p id="3fe7" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们还将使用<em class="nd"> Lambda </em>层，这将允许我们根据网络正确调整输入数据格式，最后使用密集层来计算最终输出。</p><p id="abc8" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">让我们看看如何在Keras和Tensorflow中依次实现这一切。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="e7ed" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">Lambda层允许我们在一个层中使用自定义函数。我们使用它来确保输入的维数对于LSTM是足够的。因为我们的数据集由二维时间窗口组成，其中第一个是<em class="nd"> batch_size </em>，另一个是<em class="nd">时间步长</em>。</p><p id="f377" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">然而，LSTM接受第三维，这表明我们输入的维数。通过使用Lambda函数和<em class="nd">input _ shape =【None】</em>，我们有效地告诉Tensorflow接受任何类型的输入维度。这很方便，因为我们不必编写额外的代码来确保维度是正确的。</p><p id="2e4f" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">为了阅读更多关于LSTM和图层如何工作的信息，我邀请读者在这里查阅官方的张量流指南。</p><p id="70b1" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">所有LSTM层都包含在一个双向层中，每个层都通过<em class="nd"> return_sequences = True将处理后的序列传递给下一层。</em></p><p id="1950" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">如果该参数为假，Tensorflow将会给出一个错误，因为下一个LSTM将不会找到要处理的序列。唯一不能返回序列的层是最后的LSTM，因为最后的密集层是负责提供最终预测的层，而不是另一个序列。</p><h1 id="dcd5" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">提前停止回调</h1><p id="6b05" class="pw-post-body-paragraph kw kx it ky b kz my ju lb lc mz jx le lf na lh li lj nb ll lm ln nc lp lq lr im bi translated">正如您在文章<a class="ae kv" rel="noopener" target="_blank" href="/control-the-training-of-your-neural-network-in-tensorflow-with-callbacks-ba2cc0c2fbe8">中看到的，在Tensorflow中使用回调</a>控制您的神经网络的训练，当我们的性能指标达到指定级别时，我们将使用回调来停止训练。我们将使用平均绝对误差(MAE)来衡量我们的网络正确预测系列中下一个点的能力。</p><p id="6f0a" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">事实上，这是一个类似于回归任务的任务，因此<a class="ae kv" rel="noopener" target="_blank" href="/assessing-model-performance-for-regression-7568db6b2da0">将使用类似的性能指标</a>。</p><p id="fde1" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">让我们看看实现提前停止的代码。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="d334" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">模特培训</h1><p id="a33b" class="pw-post-body-paragraph kw kx it ky b kz my ju lb lc mz jx le lf na lh li lj nb ll lm ln nc lp lq lr im bi translated">我们准备训练我们的LSTM模型。我们定义一个调用<em class="nd">create _ un compiled _ model</em>的函数，并为模型提供一个损失函数和一个优化器。</p><p id="a054" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">Huber损失函数可用于平衡平均绝对误差(MAE)和均方误差(MSE)。因此，当您有各种数据或只有几个异常值时，这是一个很好的损失函数，就像在这种情况下。</p><p id="e7f5" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">Adam优化器通常是一个有效的选择—让我们将任意的learning_rate设置为0.001。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="3134" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">让我们开始训练吧</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi no"><img src="../Images/a72b8ba736e051f5525e81a7108445a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LV71VVYohTEqiK-3.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">训练神经网络。图片作者。</p></figure><p id="1297" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们看到，在第20个时期，达到了目标MAE，训练停止。</p><h1 id="0efa" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">模型评估</h1><p id="7010" class="pw-post-body-paragraph kw kx it ky b kz my ju lb lc mz jx le lf na lh li lj nb ll lm ln nc lp lq lr im bi translated">让我们画出损失和MAE的曲线。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi np"><img src="../Images/d1df114144544aa746d9b2bedab2ce5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/0*7EL6KRzdK0GRaBUj.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">MAE和loss绘制了。图片作者。</p></figure><p id="dd38" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">曲线显示了网的改善，直到在第5个时期后稳定。还是一个不错的结果。</p><p id="9498" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">让我们写一个helper函数，方便访问MAE和MSE。此外，我们还定义了一个函数来创建预测。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="379f" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">现在让我们看看模型的表现如何！让我们对整个系列和验证集进行预测。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="22fa" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">让我们看看验证集的结果</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/663d56662ac689cb3efbcd8bdfa2f716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/0*p56kkp-UBYtXSLLZ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">对验证集的预测。图片作者。</p></figure><p id="1934" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">在整个系列中</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nr"><img src="../Images/d705f6de8c63ac49a878dad968ee8cd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ehxl1QLcYeJXk0rT.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">对整个系列的预测。图片作者。</p></figure><p id="1f6b" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">结果似乎不错。也许我们有办法通过增加训练周期或调整学习速率来提高模型的性能。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="28be" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated"><strong class="ky iu"> <em class="nd"> mse: 30.91，mae: 3.32 </em> </strong> <em class="nd">预测。</em></p><h1 id="1610" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">预测未来新的一点</h1><p id="801b" class="pw-post-body-paragraph kw kx it ky b kz my ju lb lc mz jx le lf na lh li lj nb ll lm ln nc lp lq lr im bi translated">现在让我们看看，给定序列中的最后一个序列，如何预测未来的某一点。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="af19" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">下面是结果(修改后——图片显示200分)。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi ns"><img src="../Images/ab9dc559e73d4f572d67b511f38d0745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*u3wGMAIarBtb-dFl.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">对未来a点的预测。图片作者。</p></figure><h1 id="fca0" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="a728" class="pw-post-body-paragraph kw kx it ky b kz my ju lb lc mz jx le lf na lh li lj nb ll lm ln nc lp lq lr im bi translated">总之，我们已经了解了如何</p><ul class=""><li id="f10b" class="ls lt it ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">生成合成时间序列</li><li id="c1d6" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">将系列适当地分成X和y</li><li id="89f9" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">基于双向LSTMs在Keras和Tensorflow中构造神经网络</li><li id="885a" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">提前停止训练并评估表现</li><li id="a25a" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">对培训系列、验证和未来进行预测</li></ul><p id="0175" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">如果你有任何关于如何改善这种流程的建议，请写在评论中并分享你的方法。希望文章能对你的项目有所帮助。</p><h2 id="7344" class="nt mh it bd mi nu nv dn mm nw nx dp mq lf ny nz ms lj oa ob mu ln oc od mw oe bi translated">推荐阅读</h2><p id="a19b" class="pw-post-body-paragraph kw kx it ky b kz my ju lb lc mz jx le lf na lh li lj nb ll lm ln nc lp lq lr im bi translated">对于感兴趣的人来说，这里有一个我为每个与ML相关的主题推荐的书籍列表。在我看来，有一些必不可少的书籍对我的职业生涯产生了巨大影响。<br/> <em class="nd">免责声明:这些是亚马逊会员链接。我会收到亚马逊为你推荐这些项目的一小笔佣金。你的体验不会改变，你也不会被收取更多费用，但它将帮助我扩大业务规模，围绕人工智能制作更多内容。</em></p><ul class=""><li id="1412" class="ls lt it ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky iu">ML简介</strong> : <a class="ae kv" href="https://amzn.to/3WZ51cE" rel="noopener ugc nofollow" target="_blank"> <em class="nd">自信的数据技能:掌握处理数据的基本原理，为你的职业生涯增压</em> </a> <em class="nd"> </em>作者:基里尔·叶列缅科</li><li id="7283" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky iu">sk Learn/tensor flow</strong>:<a class="ae kv" href="https://amzn.to/3jseVGb" rel="noopener ugc nofollow" target="_blank"><em class="nd">使用Scikit-Learn、Keras和TensorFlow </em> </a>进行实际操作的机器学习</li><li id="b419" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky iu"> NLP </strong> : <a class="ae kv" href="https://amzn.to/3l9FO22" rel="noopener ugc nofollow" target="_blank"> <em class="nd">文本作为数据:机器学习和社会科学的新框架</em> </a> <em class="nd"> </em>作者贾斯汀·格里默</li><li id="98e2" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky iu">sk Learn/PyTorch</strong>:<a class="ae kv" href="https://amzn.to/3wYZf0e" rel="noopener ugc nofollow" target="_blank"><em class="nd">用py torch和Scikit进行机器学习——Learn:用Python开发机器学习和深度学习模型</em></a>Sebastian Raschka</li><li id="d4a6" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky iu">数据即</strong> : <a class="ae kv" href="https://amzn.to/3HUtGtB" rel="noopener ugc nofollow" target="_blank"> <em class="nd">用数据讲故事:商务人士数据可视化指南</em> </a>作者Cole Knaflic</li></ul><h2 id="1dd0" class="nt mh it bd mi nu nv dn mm nw nx dp mq lf ny nz ms lj oa ob mu ln oc od mw oe bi translated">有用的链接(我写的)</h2><ul class=""><li id="70b3" class="ls lt it ky b kz my lc mz lf of lj og ln oh lr lx ly lz ma bi translated"><strong class="ky iu">了解如何在Python中执行顶层探索性数据分析</strong>:<a class="ae kv" rel="noopener" target="_blank" href="/exploratory-data-analysis-in-python-a-step-by-step-process-d0dfa6bf94ee"><em class="nd">Python中的探索性数据分析——一步一步的过程</em> </a></li><li id="e0cd" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky iu">学习TensorFlow的基础知识</strong>:<a class="ae kv" href="https://medium.com/towards-data-science/a-comprehensive-introduction-to-tensorflows-sequential-api-and-model-for-deep-learning-c5e31aee49fa" rel="noopener"><em class="nd">tensor flow 2.0入门—深度学习入门</em> </a></li><li id="d72f" class="ls lt it ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky iu">用Python中的TF-IDF进行文本聚类</strong> : <a class="ae kv" href="https://medium.com/mlearning-ai/text-clustering-with-tf-idf-in-python-c94cd26a31e7" rel="noopener"> <em class="nd">用Python中的TF-IDF进行文本聚类</em> </a></li></ul><blockquote class="oi"><p id="fde3" class="oj ok it bd ol om on oo op oq or lr dk translated"><strong class="ak">如果你想支持我的内容创作活动，欢迎点击我下面的推荐链接，加入Medium的会员计划</strong>。</p></blockquote><p id="6038" class="pw-post-body-paragraph kw kx it ky b kz os ju lb lc ot jx le lf ou lh li lj ov ll lm ln ow lp lq lr im bi translated">我将收到你投资的一部分，你将能够以无缝的方式访问Medium的大量数据科学文章。</p><div class="ox oy gp gr oz pa"><a href="https://medium.com/@theDrewDag/membership" rel="noopener follow" target="_blank"><div class="pb ab fo"><div class="pc ab pd cl cj pe"><h2 class="bd iu gy z fp pf fr fs pg fu fw is bi translated">通过我的推荐链接加入Medium-Andrew D # data science</h2><div class="ph l"><h3 class="bd b gy z fp pf fr fs pg fu fw dk translated">阅读Andrew D #datascience(以及媒体上成千上万的其他作者)的每一个故事。您的会员费直接…</h3></div><div class="pi l"><p class="bd b dl z fp pf fr fs pg fu fw dk translated">medium.com</p></div></div><div class="pj l"><div class="pk l pl pm pn pj po kp pa"/></div></div></a></div><p id="3ce9" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">感谢您的关注，很快再见！👋</p></div></div>    
</body>
</html>