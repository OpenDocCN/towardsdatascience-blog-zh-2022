<html>
<head>
<title>psmpy: Propensity Score Matching in Python — and why it’s needed</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PSP py:Python 中的倾向评分匹配——以及为什么需要它</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/psmpy-propensity-score-matching-in-python-a3e0cd4d2631#2022-03-21">https://towardsdatascience.com/psmpy-propensity-score-matching-in-python-a3e0cd4d2631#2022-03-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f50372467d28d26d7b387d44050bb267.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KztiF_4E28Ss8AoyHglrmw.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">作者图片</p></figure><p id="a4bc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当我们试图回答这样的问题时:</p><p id="d7b3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">“服用β受体阻滞剂能降低心脏病发作的风险吗？”</p><p id="2197" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">“吸烟会致癌吗？”</strong></p><p id="bfb0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">“小学的 STEM 项目鼓励更多的学生进入科学领域吗？”</strong></p><p id="9e01" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们经常尝试使用随机对照试验(RCT)来回答问题，我们用它来进行 A|B 测试。我们试图控制可能影响这一结果的变量的种类和数量，以确定某些干预(或缺乏干预)是否与结果有潜在的因果联系！在上面提出的第三个问题中，你可能想控制社会经济地位(SES)，邻里关系或父母教育。在药物治疗的情况下，我们可能要考虑:年龄、性别、种族、潜在/先存健康状况等。输入 RCTs</p><p id="7f18" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">RCT 是前瞻性的(计划好的，未来会有结果),患者通常是匹配的(共享相似的特征——SES、年龄等)。)对于我们想要控制的所有变量，1:1，其中 1 接受干预，1 不接受。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi ld"><img src="../Images/4b72cb32eab8dc708160c08805b2caf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*fLbAZt04KHBJVA66yfLsZQ.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">作者图片</p></figure><p id="6db2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">随机对照试验的问题:</p><ul class=""><li id="dcf0" class="li lj it kh b ki kj km kn kq lk ku ll ky lm lc ln lo lp lq bi translated">昂贵的美元</li><li id="8e31" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq bi translated">不要扩展(随着我们想要控制的变量数量的增加)</li><li id="2278" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq bi translated">患者/参与者退出</li><li id="9fbc" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq bi translated">可能最终不会产生有意义的结果</li></ul><p id="202c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">倾向评分匹配(PSM)是一种使用回顾性数据的统计技术，试图完成通常发生在 RCT 中的任务。它是以观察到的基线协变量为条件的治疗分配概率:</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/2672e0208b2164a984993face0f0bc53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*PwUVrKwTg_htXU2IXWqrvg.png"/></div></figure><p id="6f57" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因此，它的工作原理如下:</p><ol class=""><li id="1111" class="li lj it kh b ki kj km kn kq lk ku ll ky lm lc lx lo lp lq bi translated">已经收集的大量患者/参与者数据(历史数据还记得吗？)—年龄、性别、SES、体重。这些是<strong class="kh iu">协变量</strong>。通常我们的协变量是潜在的混杂因素，可能会使我们的结果产生偏差。<strong class="kh iu">干预=服药(是/否)</strong>并跟进我们的<strong class="kh iu">结果=心脏病发作(是/否)</strong>。想象一下电子健康记录数据！</li><li id="d519" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc lx lo lp lq bi translated">试着找一个与服用药物的 X 夫人“匹配”的人，她有许多与她相同的<strong class="kh iu">协变量</strong>，但没有服用药物【2】。我们需要为尽可能多的人这样做，以建立一个治疗/未治疗的队列。</li><li id="eddf" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc lx lo lp lq bi translated">我们对我们的人口进行了一系列逻辑回归，其中所有的“预测”变量都是我们的协变量(年龄、性别、体重)，我们试图预测我们的<strong class="kh iu">干预</strong>。与大多数机器学习任务不同，我们在这里不计算准确性。我们感兴趣的是预测的可能性。使用索引(参与者 id ),我们知道谁来自哪个干预组、治疗组或对照组。</li><li id="d496" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc lx lo lp lq bi translated">使用计算出的概率，我们从对立的组中找到最接近的匹配。例如，X 夫人的概率(倾向)得分为 0.4，并接受了药物治疗，而 Y 先生没有接受药物治疗，其概率得分为 0.42。k-最近邻通常用于寻找这些匹配，我们可以进行 1:1 匹配或 1:多匹配(允许重复)。如果概率上的差异被认为太大，匹配可能被排除。</li><li id="357e" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc lx lo lp lq bi translated">效应大小是我们能够控制所有这些协变量的程度的量度[4]。我们希望它们越小越好，这样结果的任何变化都可以归因于所进行的干预，给我们一个潜在的因果联系。所以我们要计算匹配前后的这些来了解我们的数据！</li><li id="e005" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc lx lo lp lq bi translated">匹配后，我们确定了研究人群中的一个亚组，我们可以研究我们的干预如何影响我们的结果。虽然干预是二元的，但是<strong class="kh iu">结果</strong>可以是连续的，也可以是二元的，我们只需要正确的统计检验。</li></ol><p id="1beb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">PSM 的优势:</p><ul class=""><li id="5f62" class="li lj it kh b ki kj km kn kq lk ku ll ky lm lc ln lo lp lq bi translated">快的</li><li id="4cba" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq bi translated">便宜——这是一个数学匹配</li><li id="6ca3" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq bi translated">无患者退出问题(自历史数据以来)</li><li id="0f03" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq bi translated">尺度——可以有任意多的协变量！</li><li id="c0db" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq bi translated">轻松地重复这个过程，并随心所欲地改变变量(假设我们有数据支持这一努力)</li></ul><p id="da6b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">PSM 的缺点:</p><ul class=""><li id="0da0" class="li lj it kh b ki kj km kn kq lk ku ll ky lm lc ln lo lp lq bi translated">数学匹配可能不是流行病学匹配</li></ul><p id="ed11" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">数学匹配意味着接受药物治疗的 68 岁女性 X 夫人不一定与未接受药物治疗的 68 岁女性匹配。使用 PSM，如果模型中具有更大权重的其他协变量相似，她可能与一名 55 岁男性匹配。</p><p id="61da" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">虽然不如随机对照试验准确，但随着更多的数据被转移到数字领域，PSM 可以提供对现实世界设置的见解。它可以自动检测有意义的结果，没有自动 RCT 的麻烦或成本。</p><p id="9d19" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">由于目前 python 中还没有一个广泛适用且性能良好的 PSM 库，所以输入— <strong class="kh iu"> PsmPy </strong>！【https://pypi.org/project/psmpy/ T4】</p><p id="6b9c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">该库的功能包括:</p><ul class=""><li id="c743" class="li lj it kh b ki kj km kn kq lk ku ll ky lm lc ln lo lp lq bi translated">评估前后平衡的附加绘图功能</li><li id="bdc2" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq bi translated">更加模块化、用户指定的匹配流程</li><li id="d2f1" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq bi translated">能够定义一对一或一对多匹配</li></ul><h1 id="f6d3" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">装置</h1><p id="21a3" class="pw-post-body-paragraph kf kg it kh b ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky nb la lb lc im bi translated">PsmPy 在 pypi.org 有售，可以通过终端中的 pip 安装:</p><pre class="le lf lg lh gt nc nd ne nf aw ng bi"><span id="b55f" class="nh ma it nd b gy ni nj l nk nl">$ pip install psmpy</span></pre><h1 id="05e8" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">数据准备</h1><p id="4229" class="pw-post-body-paragraph kf kg it kh b ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky nb la lb lc im bi translated">读入你的数据。</p><pre class="le lf lg lh gt nc nd ne nf aw ng bi"><span id="c3a2" class="nh ma it nd b gy ni nj l nk nl"># import other relevant libraries (that you want) </span><span id="ca75" class="nh ma it nd b gy nm nj l nk nl"># set the figure shape and size of outputs (optional)<br/>sns.set(rc={'figure.figsize':(10,8)}, font_scale = 1.3)</span><span id="d170" class="nh ma it nd b gy nm nj l nk nl"># read in your data<br/>data = pd.read_csv(path)</span></pre><h1 id="e7d8" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">导入 psmpy 类和函数</h1><p id="8980" class="pw-post-body-paragraph kf kg it kh b ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky nb la lb lc im bi translated">将 PsmPy 库导入 python 和其他两个支持函数:</p><p id="8dee" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">CohenD 计算效果大小，并可用于计算匹配前后变量施加的效果大小。这个数字越接近 0，我们就越能有效地控制协变量</p><pre class="le lf lg lh gt nc nd ne nf aw ng bi"><span id="6989" class="nh ma it nd b gy ni nj l nk nl">from psmpy import PsmPy<br/>from psmpy.functions import cohenD<br/>from psmpy.plotting import *</span></pre><h1 id="e8f1" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">实例化 PsmPy 类</h1><pre class="le lf lg lh gt nc nd ne nf aw ng bi"><span id="9603" class="nh ma it nd b gy ni nj l nk nl">psm = PsmPy(df, treatment='treatment', indx='pat_id', exclude = [])</span></pre><p id="9cdb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">注意:</p><ul class=""><li id="78da" class="li lj it kh b ki kj km kn kq lk ku ll ky lm lc ln lo lp lq bi translated"><code class="fe nn no np nd b">PsmPy</code> -上课。它将使用数据集中的所有协变量，除非在<code class="fe nn no np nd b">exclude</code>参数中正式排除。</li><li id="a417" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq bi translated"><code class="fe nn no np nd b">df</code> -传递给类的数据帧</li><li id="36b3" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq bi translated"><code class="fe nn no np nd b">exclude</code> -(可选)参数，将忽略模型拟合过程中传递给它的任何协变量(列)。这将是一个字符串列表。没有必要在这里传递唯一索引列。</li><li id="be00" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq bi translated"><code class="fe nn no np nd b">indx</code> -必需参数，引用数据集中每个案例的唯一 ID 号。</li></ul><h1 id="ec2b" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">预测分数</h1><p id="3a3c" class="pw-post-body-paragraph kf kg it kh b ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky nb la lb lc im bi translated">计算逻辑倾向得分/逻辑:</p><pre class="le lf lg lh gt nc nd ne nf aw ng bi"><span id="a785" class="nh ma it nd b gy ni nj l nk nl">psm.logistic_ps(balance = True)</span></pre><p id="889b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">注意:</p><ul class=""><li id="ad90" class="li lj it kh b ki kj km kn kq lk ku ll ky lm lc ln lo lp lq bi translated"><code class="fe nn no np nd b">balance</code> -逻辑回归是否以平衡方式运行，默认值= True。</li></ul><p id="b56b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在数据中经常存在显著的类别不平衡。这将被自动检测。我们通过在调用<code class="fe nn no np nd b">psm.logistic_ps()</code>时设置<code class="fe nn no np nd b">balance=True</code>来说明这一点。这告诉<code class="fe nn no np nd b">PsmPy</code>在拟合逻辑回归模型时创建平衡样本。这将计算每个条目的逻辑倾向得分和 logits。你可以这样想，例如:</p><p id="344b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">较小类别 n=10 <br/>较大类别 n=30</p><p id="9816" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe nn no np nd b">psm.logistic_ps(balance=True)</code>导致发生 3 次逻辑回归(较小类别的 n=10，较大类别的 n=10)，然后重复 3 次，直到较大类别的所有条目都有分数。它们是主要类别的重复条目的平均值。</p><p id="e460" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe nn no np nd b">psm.logistic_ps(balance=False)</code>导致发生符合 n=10 和 n=30(不平衡)的单一回归</p><p id="3289" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">要查看数据框架中的概率/逻辑:</p><pre class="le lf lg lh gt nc nd ne nf aw ng bi"><span id="63f9" class="nh ma it nd b gy ni nj l nk nl">psm.predicted_data</span></pre><h1 id="8c81" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">匹配算法-版本 1</h1><p id="ed93" class="pw-post-body-paragraph kf kg it kh b ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky nb la lb lc im bi translated">该方法将创建一系列 1:1 或 1:多的匹配(因为替换是假的，所以它是多的)，因此仍然是 1:1 匹配，但是来自较大类的一些条目被重复。</p><p id="1354" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">执行 KNN 匹配</p><pre class="le lf lg lh gt nc nd ne nf aw ng bi"><span id="b1f5" class="nh ma it nd b gy ni nj l nk nl">psm.knn_matched(matcher='propensity_logit', replacement=False, caliper=None)</span></pre><p id="a2f4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">注意:</p><ul class=""><li id="5c77" class="li lj it kh b ki kj km kn kq lk ku ll ky lm lc ln lo lp lq bi translated"><code class="fe nn no np nd b">matcher</code> - <code class="fe nn no np nd b">propensity_logit</code>(默认)并且在上一步中生成的替代选项是<code class="fe nn no np nd b">propensity_score</code>，指定匹配将要进行的自变量</li><li id="e5c8" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq bi translated"><code class="fe nn no np nd b">replacement</code> - <code class="fe nn no np nd b">False</code>(默认)，决定替换与否，当替换为假匹配时，1:1 匹配</li><li id="4510" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq bi translated"><code class="fe nn no np nd b">caliper</code> - <code class="fe nn no np nd b">None</code>(默认)，用户可以指定相对于标准的卡尺尺寸。对照样本的标准差，限制符合匹配条件的邻居</li></ul><h1 id="f8b0" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">匹配算法-版本 2</h1><p id="32be" class="pw-post-body-paragraph kf kg it kh b ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky nb la lb lc im bi translated">此方法将创建一系列 1:1 或 1:n 的匹配，其中“n”是将较小的类与较大的类进行匹配的次数。</p><p id="59c6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">执行 KNN 匹配:</p><pre class="le lf lg lh gt nc nd ne nf aw ng bi"><span id="bdaa" class="nh ma it nd b gy ni nj l nk nl">psm.knn_matched_12n(matcher='propensity_logit', how_many=2)</span></pre><p id="56f8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">注意:</p><ul class=""><li id="faa0" class="li lj it kh b ki kj km kn kq lk ku ll ky lm lc ln lo lp lq bi translated"><code class="fe nn no np nd b">matcher</code> - <code class="fe nn no np nd b">propensity_logit</code>(缺省值)，上一步生成的备选项是<code class="fe nn no np nd b">propensity_score</code>，指定匹配将要进行的自变量</li><li id="d923" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq bi translated"><code class="fe nn no np nd b">how_many</code> - <code class="fe nn no np nd b">1</code>(默认-1:1 匹配)，确定匹配是以 1:1 还是 1:n 的方式进行，其中“n”是您希望从较小类别(治疗类别)匹配到较大类别的唯一次数</li></ul><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/b9ea2c069f23948e4377e04d9803ef97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*Nhoh6awhEoaFCW8WL-wXxA.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">作者图片</p></figure><h1 id="b679" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">图形输出</h1><h1 id="777d" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">绘制倾向得分或倾向对数</h1><p id="7255" class="pw-post-body-paragraph kf kg it kh b ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky nb la lb lc im bi translated">并排绘制两组的倾向分数(或对数)分布图。</p><pre class="le lf lg lh gt nc nd ne nf aw ng bi"><span id="5de3" class="nh ma it nd b gy ni nj l nk nl">psm.plot_match(Title='Side by side matched controls', Ylabel='Number of patients', Xlabel= 'Propensity logit', names = ['treatment', 'control'], save=True)</span></pre><p id="70fa" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">注意:</p><ul class=""><li id="f1c5" class="li lj it kh b ki kj km kn kq lk ku ll ky lm lc ln lo lp lq bi translated"><code class="fe nn no np nd b">title</code>--"并排匹配控件"(默认)，创建绘图标题</li><li id="bd26" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq bi translated"><code class="fe nn no np nd b">Ylabel</code>--"患者数量"(默认)，字符串，y 轴标签</li><li id="7272" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq bi translated"><code class="fe nn no np nd b">Xlabel</code>--‘倾向逻辑’(默认)，字符串，x 轴标签</li><li id="ad6f" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq bi translated"><code class="fe nn no np nd b">names</code> - ['治疗'，'控制'](默认)，图例字符串列表</li><li id="71e5" class="li lj it kh b ki lr km ls kq lt ku lu ky lv lc ln lo lp lq bi translated"><code class="fe nn no np nd b">save</code> - False(默认)，如果为 True，则将生成的图形保存到当前工作目录</li></ul><p id="a3ea" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">使用心脏病健康指标数据集[3]证明了这一点。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/81aa364c7d2599d9faaf62e5fffc6380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SO7Q_ypvIZaOG-XQ85-DOw.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">作者图片</p></figure><p id="1d4d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在这里，我们可以看到治疗组和对照组相互对照(匹配后)。这两个分布越相似，我们的匹配就越好。</p><h1 id="a9a2" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">绘制效果尺寸图</h1><pre class="le lf lg lh gt nc nd ne nf aw ng bi"><span id="38be" class="nh ma it nd b gy ni nj l nk nl">psm.effect_size_plot(save=False)</span></pre><p id="9f07" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">注意:</p><ul class=""><li id="2b83" class="li lj it kh b ki kj km kn kq lk ku ll ky lm lc ln lo lp lq bi translated"><code class="fe nn no np nd b">save</code> - False(默认)，如果为 True，则将生成的图形保存到当前工作目录</li></ul><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/185ac1332a82f9885c0e7c469f5d4455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UgigtfSkWkUiqQiw33NRSQ.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">作者图片</p></figure><p id="9364" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们可以使用上面的代码绘制效果大小。这里我们可以看到影响大小(使用 Cohen 的 D 计算),这是一个修改的卡方检验。这在群组匹配之前和之后对每个变量执行。</p><h1 id="d12f" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">额外属性</h1><p id="2b3d" class="pw-post-body-paragraph kf kg it kh b ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky nb la lb lc im bi translated">用户可用的其他属性:</p><h2 id="2b70" class="nh ma it bd mb nt nu dn mf nv nw dp mj kq nx ny mn ku nz oa mr ky ob oc mv od bi translated">原始数据帧</h2><pre class="le lf lg lh gt nc nd ne nf aw ng bi"><span id="2927" class="nh ma it nd b gy ni nj l nk nl">psm.df_matched</span></pre><ul class=""><li id="481f" class="li lj it kh b ki kj km kn kq lk ku ll ky lm lc ln lo lp lq bi translated"><code class="fe nn no np nd b">df_matched</code> -返回数据框架中所有案例的计算倾向得分和倾向逻辑</li></ul><h2 id="5c60" class="nh ma it bd mb nt nu dn mf nv nw dp mj kq nx ny mn ku nz oa mr ky ob oc mv od bi translated">匹配的 id</h2><pre class="le lf lg lh gt nc nd ne nf aw ng bi"><span id="1c21" class="nh ma it nd b gy ni nj l nk nl">psm.matched_ids</span></pre><ul class=""><li id="7c44" class="li lj it kh b ki kj km kn kq lk ku ll ky lm lc ln lo lp lq bi translated"><code class="fe nn no np nd b">matched_ids</code> -从次要类别返回指数的数据帧，并从主要类别 psm 返回相关的匹配指数。</li></ul><p id="96c5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">注意:不是所有的匹配都是唯一的，如果<code class="fe nn no np nd b">replacement=True</code></p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/75e2b9086af7026a7465220a57183c45.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*HI82_Cr_Xd_PevJINCSD5w.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">作者图片</p></figure><h1 id="c6bc" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">每个变量的效果大小</h1><pre class="le lf lg lh gt nc nd ne nf aw ng bi"><span id="4dc4" class="nh ma it nd b gy ni nj l nk nl">psm.effect_size</span></pre><ul class=""><li id="ca8c" class="li lj it kh b ki kj km kn kq lk ku ll ky lm lc ln lo lp lq bi translated"><code class="fe nn no np nd b">effect_size</code> -返回包含“变量”、“匹配”(之前或之后)和“效果大小”列的数据帧</li></ul><p id="5e99" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">注:Cohen [4]描述了小、中和大效应大小的阈值。其中相对尺寸效应分为:小≤ 0.2，中≤ 0.5，大≤0.8。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi of"><img src="../Images/287603ebb8a5a85a977a4f81fd8ba6ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*3NgiHMBHjQ3JEIA6SeNOHg.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">作者图片</p></figure><p id="2b6b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">理想情况下，“匹配后”变量产生的效果大小应该小于匹配前。这些效应大小越接近 0，我们感兴趣的结果就越不依赖于协变量。</p><p id="1874" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">目前在 Python 环境中还不存在易于使用的 PSM 技术。R 环境[5]中有 package <em class="og"> MatchIt </em>和 SPSS 中的另一个备选项。<em class="og"> MatchIt </em>软件包提供了一些基本的绘图功能，然而，<strong class="kh iu">PSP py</strong>是开源的(与 SPSS 不同),提供了易于使用/定制的视觉愉悦的图形，以确定匹配有多“好”,以及几个类属性，以使最终用户能够获得算法计算的原始数据。</p><h1 id="a979" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">引用这部作品！: )</h1><p id="d56a" class="pw-post-body-paragraph kf kg it kh b ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky nb la lb lc im bi translated">A.Kline，Y. Luo，PSP py:<em class="og">用 Python 编写的回顾性队列匹配包</em>，(2022 年接受)[1]</p><p id="bbd2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">联系预印本！</p><p id="625f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">此外，如果你喜欢看到这样的文章，并希望无限制地访问我的文章和所有由 Medium 提供的文章，请考虑使用下面的我的推荐链接注册。会员费为 5 美元/月；我赚一小笔佣金，这反过来有助于推动更多的内容和文章！</p><div class="oh oi gp gr oj ok"><a href="https://medium.com/@askline1/membership" rel="noopener follow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">通过我的推荐链接加入 Medium-Adrienne Kline</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">medium.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy jz ok"/></div></div></a></div></div><div class="ab cl oz pa hx pb" role="separator"><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe"/></div><div class="im in io ip iq"><h1 id="ff32" class="lz ma it bd mb mc pg me mf mg ph mi mj mk pi mm mn mo pj mq mr ms pk mu mv mw bi translated">参考</h1><p id="1229" class="pw-post-body-paragraph kf kg it kh b ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky nb la lb lc im bi translated">[1] A. Kline，Y. Luo，PSP py:<em class="og">Python 中的回顾性队列匹配包</em>，(2022 年在接受)，doi:10.1109/embc 48229 . 2022 . 9871333 .<br/>【2】<a class="ae ly" href="https://academic.oup.com/biomet/article/70/1/41/240879" rel="noopener ugc nofollow" target="_blank">Paul r . Rosenbaum&amp;Donald b . Rubin</a>，<a class="ae ly" href="https://academic.oup.com/biomet/article/70/1/41/240879" rel="noopener ugc nofollow" target="_blank">“倾向评分在因果效应观察研究中的核心作用”，1983al，“MatchIt:参数化<br/>因果推断的非参数预处理”，《统计软件学报》，第 42 卷第 8 期，2011<br/>doi:10.18637/jss . v 042 . i08</a></p></div></div>    
</body>
</html>