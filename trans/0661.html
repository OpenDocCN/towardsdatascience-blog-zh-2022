<html>
<head>
<title>Use simulations to optimize customer wait time, systems load, and cost</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用模拟来优化客户等待时间、系统负载和成本</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/use-simulations-to-optimize-customer-wait-time-systems-load-and-cost-774d2b154ace#2022-02-26">https://towardsdatascience.com/use-simulations-to-optimize-customer-wait-time-systems-load-and-cost-774d2b154ace#2022-02-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d46f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设你的基础设施是一个由M台相同的机器组成的车队，每台机器一次处理一个任务。每个新客户都被放在一个等待机器空闲的队列中。您知道每个处理任务需要多长时间才能完成，但它不是一个固定的数字——相反，它有一个最短持续时间、一个最长持续时间和一些最可能的持续时间。你大概知道客户流入量(客户/秒)会是多少。您需要多少台机器来处理所有这些客户—M的值是多少？</p><p id="dc4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者，您有一个固定的预算，允许您构建正好M台机器。车队每秒可以处理多少客户？</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/3b1c6c587edb6238c9168c176214143c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Om6nYmKYRQRkPpRR9gncOw.png"/></div></div></figure><p id="8116" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者，可能每个客户都需要通过一系列任务来处理，每个任务都在不同的集群上执行，每个集群都有不同的处理时间——但是所有客户都需要通过一系列任务来处理。你需要回答和上面一样的问题。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kx"><img src="../Images/9df5ac3d88c232abec0d076f671711e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*52RhRoHgSJ8vGjpxSGxmVQ.png"/></div></div></figure><p id="75af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者可能不同的处理任务，每个都具有不同的处理时间，竞争同一机器集群上的资源——因此每个客户的任务循环回到同一集群，直到每个客户都被处理。</p><p id="c41a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可能有资源，如能源或材料，用于完成任务，您可能希望优化流程，以便以最佳方式使用资源。</p><p id="19cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，可能会有与运行这些机器相关的成本，但也会有与客户等待时间过长相关的成本—您可能希望将总体成本降至最低。</p><p id="2dad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何找到合适的基础设施规模，以确保快速处理客户，同时优化资源使用并最大限度地降低成本？或者，给定一定的基础架构规模，在处理时间、成本和资源方面的最佳结果是什么？在一个简单的设置中，您可以做一个大概的估计，但是如果事情变得足够复杂(想象多个不同的任务在同一个集群上竞争机器)，那么最佳估计可能就不明显了。</p><p id="a3da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对上述所有情况几乎都有效的一个解决方案是模拟。如果你能足够精确地描述整个工作流程，你就能在软件中模拟整个事情，让模拟及时向前运行，收集结果，并分析它们。</p><h1 id="e53d" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">优势</h1><p id="d05f" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">如果你计划建立的基础设施足够大，运行模拟几乎总是更便宜和更快。模拟甚至可能比运行基础设施的缩小模型更容易。</p><p id="245c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为模拟很便宜，你可以运行它很多次，每次都改变参数，寻找优化结果的方法。你甚至可以在仿真的参数空间中进行系统的搜索，以确保找到可能的最佳结果——在成本、时间等方面。</p><h1 id="410e" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">警告</h1><p id="ba44" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">模拟的好坏取决于你输入的数据。确保您详细描述了基础设施的特征。在模拟中使用真实世界的数据非常重要。</p><p id="b6b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">比如:你怎么知道每项任务要花多长时间？您可以为每种类型构建一台机器，运行数百个任务，并收集关于任务持续时间的数据。您很可能会在那里获得某种时间分布，然后在您的模型中使用它。</p><p id="714c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些准备是强制性的。<strong class="jp ir">不要随便编造数据</strong>，否则模拟会不准确。</p><h1 id="af55" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">我们的例子</h1><p id="0dfa" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">请参考第一张图，即本文顶部的那张图。我们正在模拟一个最简单的例子:只有一个集群，每个客户只生成一个需要处理的任务。</p><p id="d122" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们不讨论成本或资源优化。成本和资源消耗基本上是更多的变量集(每个客户的成本、每台机器的成本等)，您需要在您的模型中进行跟踪和总结。随着模拟时间的推移，跟踪成本、资源等。为了让这个例子简单明了，我们在这里不考虑成本和资源(除了不同的时间和持续时间)。</p><p id="2256" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将假设机队的规模是固定的:M = 100台机器。</p><p id="3dd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每位客户的处理时间大约为2分钟，但这不是一个固定的持续时间，而是变化的，最短的时间为30秒，最长的时间为4分钟。总体分布呈三角形。</p><p id="28d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们怀疑客户的涌入少于1个客户/秒，但不会少很多。可能会出现短时间内大大超过平均速率的客户激增。</p><p id="ce33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">鉴于上述所有情况，我们正在努力找出我们能够处理的最高顾客到达率。</p><p id="6d05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们生成处理时间的分布，以及客户到达时间的分布。</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="be05" class="mg kz iq mc b gy mh mi l mj mk">import pandas as pd<br/>import numpy as np<br/>from scipy import stats as st<br/>from matplotlib import pyplot as plt<br/>from matplotlib import ticker<br/>import seaborn as sns<br/>sns.set_theme()<br/>sns_col = sns.color_palette()</span><span id="302b" class="mg kz iq mc b gy ml mi l mj mk">######## Customer arrival parameters ########</span><span id="ac6f" class="mg kz iq mc b gy ml mi l mj mk"># duration of initial wave in seconds<br/>cust_peak_length = 3600<br/>cust_peak_center = cust_peak_length // 2<br/># number of customers in the initial wave<br/>cust_peak_count = 5000<br/># val=3 makes sure the edges of the peak are near zero<br/>cust_peak_sigmas = 3</span><span id="9fba" class="mg kz iq mc b gy ml mi l mj mk">cust_peak_dist = st.truncnorm.rvs(<br/>    -cust_peak_sigmas,<br/>    cust_peak_sigmas,<br/>    loc=cust_peak_center,<br/>    scale=cust_peak_center / cust_peak_sigmas,<br/>    size=cust_peak_count,<br/>)</span><span id="5f25" class="mg kz iq mc b gy ml mi l mj mk"># steady state inflow, customers / second<br/>cust_flow_rate = 0.8<br/>cust_per_min = 60 * cust_flow_rate<br/>cust_per_hour = 60 * cust_per_min<br/># steady state begin moment<br/>cust_flow_start = cust_peak_center<br/># steady state end moment<br/>cust_flow_end = cust_flow_start * 10<br/># total number of customers in the steady state flow<br/>cust_flow_total = int((cust_flow_end - cust_flow_start) * cust_flow_rate)</span><span id="2023" class="mg kz iq mc b gy ml mi l mj mk"># Generate customer arrival times distribution<br/>cust_flow_dist = np.random.uniform(cust_flow_start, cust_flow_end, size=cust_flow_total)<br/>cust_dist = np.concatenate((cust_peak_dist, cust_flow_dist)).astype(int)</span><span id="dd66" class="mg kz iq mc b gy ml mi l mj mk">######## Infrastructure parameters ########</span><span id="9640" class="mg kz iq mc b gy ml mi l mj mk"># number of machines<br/>M = 100</span><span id="2fba" class="mg kz iq mc b gy ml mi l mj mk"># processing time central value in seconds<br/>proc_time_center = 120<br/># processing time minimum<br/>proc_time_min = 30<br/># processing time maximum<br/>proc_time_max = 240</span><span id="bf56" class="mg kz iq mc b gy ml mi l mj mk"># Generate pre-ordained processing times<br/>proc_time_dist = np.random.triangular(proc_time_min, proc_time_center, proc_time_max, size=cust_dist.shape[0])</span></pre><p id="6197" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们想象一下分布情况:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="e0ba" class="mg kz iq mc b gy mh mi l mj mk">fig, ax = plt.subplots(1, 2, figsize=(16, 5))<br/>label_format = '{:,.2f}'<br/>bins = 50</span><span id="23fc" class="mg kz iq mc b gy ml mi l mj mk">ax[0].hist(proc_time_dist, bins=50, color=sns_col[0])</span><span id="5320" class="mg kz iq mc b gy ml mi l mj mk">ax[0].set_title("Distribution of processing durations", fontsize=18)<br/>ax[0].set_xlabel("durations of tasks (sec)")<br/>ax[0].set_ylabel("count of tasks")</span><span id="64aa" class="mg kz iq mc b gy ml mi l mj mk">ax[1].hist(cust_dist, bins=50, color=sns_col[1])<br/>ax1_bin_width = cust_flow_end / bins</span><span id="06d3" class="mg kz iq mc b gy ml mi l mj mk">ax1_xticks_loc = ax[1].get_xticks().tolist()<br/>ax[1].xaxis.set_major_locator(ticker.FixedLocator(ax1_xticks_loc))<br/>ax[1].set_xticklabels([label_format.format(x / 3600) for x in ax1_xticks_loc])</span><span id="975e" class="mg kz iq mc b gy ml mi l mj mk">ax1_yticks_loc = ax[1].get_yticks().tolist()<br/>ax[1].yaxis.set_major_locator(ticker.FixedLocator(ax1_yticks_loc))<br/>ax[1].set_yticklabels([label_format.format(y / ax1_bin_width) for y in ax1_yticks_loc])</span><span id="64ce" class="mg kz iq mc b gy ml mi l mj mk">ax[1].set_title("Rate of customer arrivals", fontsize=18)<br/>ax[1].set_xlabel("time (hours)")<br/>ax[1].set_ylabel("customers / second")<br/>plt.show()</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mm"><img src="../Images/10f60d3bb0b875df77cb0b7bfdbfe0e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*al0a5AQQSSC1nCTBzbzsVQ.png"/></div></div></figure><p id="4f39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所说，处理时间呈三角形分布，峰值在2分钟。</p><p id="7015" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们首先要尝试的客户到达率是0.8客户/秒，或48客户/分钟。但是最初将会有5000名顾客的激增，他们都在1小时内到达，服从截断的正态分布。</p><p id="e46e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经定义了模型参数。让我们看一下代码。</p><h1 id="35be" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">实际的模拟代码</h1><p id="6929" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">模拟完全在此函数中执行:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="95b6" class="mg kz iq mc b gy mh mi l mj mk">def avg_wait_time(mn, cust_dist, proc_time_dist, DEBUG=False):<br/>    <br/>    # the state of each machine<br/>    # 0 = idle<br/>    # 1 = busy<br/>    machine = np.full((mn,), 0, dtype=int)<br/>    <br/>    # total number of customers<br/>    c = cust_dist.shape[0]</span><span id="f685" class="mg kz iq mc b gy ml mi l mj mk"># status column:<br/>    # -1 = not here yet<br/>    # 0 = waiting customer<br/>    # 1 = processing customer<br/>    # 2 = customer is done<br/>    state_dict = {<br/>        "pt": proc_time_dist,  # pre-destined processing times<br/>        "status": np.full((c,), -1, dtype=int),<br/>        "machine": np.full((c,), -1, dtype=int),  # machine ID assigned to customer<br/>        "time_went_in": cust_dist,  # arrival time<br/>        "time_went_out": np.zeros((c,), dtype=int),  # task complete time<br/>        "time_wait": np.zeros((c,), dtype=int),  # length of wait<br/>    }<br/>    state = pd.DataFrame(state_dict)<br/>    <br/>    # average wait times of currently waiting customers<br/>    # updated every time increment<br/>    proc_history = {<br/>        'curr_wait_avg': [],<br/>        'busy_machines': [],<br/>        'waiting_cust': []<br/>    }</span><span id="a89b" class="mg kz iq mc b gy ml mi l mj mk">t = 0<br/>    while True:<br/>        <br/>        #### update history<br/>        # current average wait time for waiting and processing customers<br/>        cwt = state[(state['status'] == 0) | (state['status'] == 1)]['time_wait'].mean()<br/>        cwt = 0 if cwt != cwt else cwt<br/>        proc_history['curr_wait_avg'] += [cwt]<br/>        proc_history['busy_machines'] += [machine.sum()]<br/>        proc_history['waiting_cust'] += [state[(state['status'] == 0) | (state['status'] == 1)].shape[0]]<br/>        <br/>        if DEBUG and t % 100 == 0:<br/>            print(t, cwt, machine.sum(), proc_history['waiting_cust'][-1])<br/>        <br/>        # clock tick for waiting customers<br/>        dfmask = (state['status'] == 0) | (state['status'] == 1)<br/>        state.loc[dfmask, 'time_wait'] += 1<br/>        <br/>        # customers have just arrived, put them in the queue<br/>        dfmask = (state["status"] == -1) &amp; (t &gt;= state["time_went_in"])<br/>        state.loc[dfmask, "status"] = 0<br/>        <br/>        # processing has just completed for these customers<br/>        # take them out of the machine pool<br/>        dfmask = (state["status"] == 1) &amp; (t - state["time_went_in"] &gt;= state["pt"])<br/>        state.loc[dfmask, "status"] = 2<br/>        state.loc[dfmask, "time_went_out"] = t<br/>        machines_go_idle = list(state.loc[dfmask, 'machine'].values)<br/>        machine[machines_go_idle] = 0<br/>        state.loc[dfmask, "machine"] = -1<br/>        <br/>        # find any idle machines<br/>        # if there are any, find waiting customers for them<br/>        idle_machines = list(np.where(machine == 0)[0])<br/>        dfmask = (state['status'] == 0)<br/>        waiting_customers = dfmask.loc[dfmask == True].index.to_list()<br/>        if len(idle_machines) &gt; 0 and len(waiting_customers) &gt; 0:<br/>            num_changes = min(len(idle_machines), len(waiting_customers))<br/>            for i in range(0, num_changes):<br/>                cust = waiting_customers[i]<br/>                mach = idle_machines[i]<br/>                machine[mach] = 1<br/>                state.at[cust, "status"] = 1<br/>                state.at[cust, "machine"] = mach<br/>        <br/>        if np.all((machine == 0)) and (state['status'] == 2).all():<br/>            break<br/>        <br/>        t += 1<br/>    return state, proc_history</span></pre><p id="abf0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该函数的参数是:</p><ul class=""><li id="c652" class="mn mo iq jp b jq jr ju jv jy mp kc mq kg mr kk ms mt mu mv bi translated">机器的数量</li><li id="134c" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">顾客到达时间的分布</li><li id="db47" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">加工时间的分布</li></ul><p id="7f98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">状态数据框跟踪模拟的状态。每条线都是客户。各列记录分配给每个客户的数据:</p><ul class=""><li id="09cb" class="mn mo iq jp b jq jr ju jv jy mp kc mq kg mr kk ms mt mu mv bi translated">他们的处理时间(因为它是随机的，所以可以预先指定)</li><li id="4b87" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">它们的状态:尚未到达、已到达但未处理、正在处理、完成</li><li id="4ff7" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">分配给客户的机器</li><li id="4124" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">到达时间、结束时间和处理时间(最后一个是多余的，但很方便)</li></ul><p id="061b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">状态数据框架将贯穿整个模拟过程，并将根据每个客户的结果在每一步进行更新。</p><p id="1830" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">proc_history包含几个列表，我们在这些列表中跟踪模拟的每一步的各种统计数据，可以把它看作一个日志:</p><ul class=""><li id="0dab" class="mn mo iq jp b jq jr ju jv jy mp kc mq kg mr kk ms mt mu mv bi translated">模拟每一步的平均等待时间</li><li id="6824" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">每一步的繁忙机器数量</li><li id="20b8" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">每个步骤中等待的顾客数量</li></ul><p id="2f65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每次模拟在时间上向前迭代，新的值都被添加到proc_history中的列表中。这个变量随着时间不断增长。</p><p id="2c5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">算法:</p><ul class=""><li id="a40a" class="mn mo iq jp b jq jr ju jv jy mp kc mq kg mr kk ms mt mu mv bi translated">我们从t = 0开始，在时间上向前迭代</li><li id="992a" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">在每一步，我们更新proc_history</li><li id="8bd7" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">如果客户正在等待，我们会更新他们的等待时间</li><li id="e92e" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">如果客户刚刚到达，我们会将他们的状态更改为“等待”</li><li id="ba30" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">如果客户完成了处理，我们会更新他们的统计数据和机器状态</li><li id="1037" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">如果我们发现闲置的机器，并且有客户在等待，我们就开始处理它们</li><li id="7245" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">我们每走一步，时间就增加1秒</li><li id="69f0" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">如果所有机器都空闲并且所有客户都完成了处理，我们就停止模拟</li></ul><p id="38aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该函数返回状态数据帧和proc_history列表。这是模拟的典型情况，您可能希望在结束时返回详细的最终状态，以及整个运行过程中重要变量的历史记录。</p><h1 id="6aaf" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">向量数学</h1><p id="be39" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">你可能已经注意到在整个函数中只有一个for循环。这是故意的。</p><p id="39cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实上，函数中隐藏了许多循环(大多数代码块实际上都是循环),有一种方法可以编写包含许多循环的函数——迭代数据框中的所有行，等等。那会非常慢。所示代码在我的笔记本电脑上运行大约需要1分钟。对于for循环，至少需要10倍的时间，甚至更长。</p><p id="93a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您必须尽可能使用这种编码风格Numpy和Pandas代码的矢量化形式——否则模拟会很慢。事实上，那个单独的for循环也可能被消除。</p><p id="f023" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果不熟悉向量形式，代码可能很难读懂，但是性能提升绝对值得。</p><h1 id="1972" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结果</h1><p id="47f5" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">让我们调用函数并收集结果。</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="67c2" class="mg kz iq mc b gy mh mi l mj mk">%%time<br/>final_state, proc_history = avg_wait_time(M, cust_dist, proc_time_dist)</span></pre><p id="a01a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的笔记本电脑的总运行时间是1分4秒。</p><p id="023a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有很多方法可以探索结果。让我们来看看这些数据的几个横截面:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="f06c" class="mg kz iq mc b gy mh mi l mj mk">fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 9))<br/>plt.subplots_adjust(hspace = 0.4)</span><span id="a5ce" class="mg kz iq mc b gy ml mi l mj mk">ax1.plot(np.convolve(proc_history['curr_wait_avg'], np.ones(100), 'valid') / 100, color=sns_col[0])<br/>ax1.set_title("Current average wait duration for customers", fontsize=18)<br/>ax1.set_xlabel("time (hours)")<br/>ax1.set_ylabel("wait duration (sec)")<br/>ax1_xticks_loc = ax1.get_xticks().tolist()<br/>ax1.xaxis.set_major_locator(ticker.FixedLocator(ax1_xticks_loc))<br/>ax1.set_xticklabels([label_format.format(x / 3600) for x in ax1_xticks_loc])</span><span id="b329" class="mg kz iq mc b gy ml mi l mj mk">ax2.plot(proc_history['busy_machines'], color=sns_col[1])<br/>ax2.set_title("Current number of busy machines", fontsize=18)<br/>ax2.set_xlabel("time (hours)")<br/>ax2.set_ylabel("busy machines")<br/>ax2_xticks_loc = ax2.get_xticks().tolist()<br/>ax2.xaxis.set_major_locator(ticker.FixedLocator(ax2_xticks_loc))<br/>ax2.set_xticklabels([label_format.format(x / 3600) for x in ax2_xticks_loc])</span><span id="81ac" class="mg kz iq mc b gy ml mi l mj mk">ax3.plot(proc_history['waiting_cust'], color=sns_col[2])<br/>ax3.set_title("Current number of waiting customers", fontsize=18)<br/>ax3.set_xlabel("time (hours)")<br/>ax3.set_ylabel("waiting customers")<br/>ax3_xticks_loc = ax3.get_xticks().tolist()<br/>ax3.xaxis.set_major_locator(ticker.FixedLocator(ax3_xticks_loc))<br/>ax3.set_xticklabels([label_format.format(x / 3600) for x in ax3_xticks_loc])</span><span id="f863" class="mg kz iq mc b gy ml mi l mj mk">ax4.hist(final_state['time_wait'], bins=50, color=sns_col[3])<br/>ax4.set_title("Final distribution of wait durations", fontsize=18)<br/>ax4.set_xlabel("wait duration (sec)")<br/>ax4.set_ylabel("count")</span><span id="e0a9" class="mg kz iq mc b gy ml mi l mj mk">plt.savefig("user_load.png", bbox_inches="tight")<br/>plt.show()</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nb"><img src="../Images/6bc434b9372a6104528e894c2dd78f6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1RJjh7frPunB9EDo-Fw9pg.png"/></div></div></figure><p id="8e15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">左上角的蓝线是所有“当前正在等待”的客户在不同时刻的平均等待时间。在最初的高峰期间，等待时间很长，但随后会减少到接近平均处理时间。</p><p id="d9c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">右上角的橙色线是繁忙机器的数量。他们大部分时间都很忙。</p><p id="1a9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">左下角的绿线是顾客排队的长度。这符合你对到达率的预期。</p><p id="ad14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">右下角是整个人群等待时间的最终分布。按照处理时间，大多数客户只等待1 … 4分钟，但也有少数例外，他们等待的时间要长得多。让我们仔细看看异常值:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="816f" class="mg kz iq mc b gy mh mi l mj mk">fig, ax = plt.subplots(figsize=(7.22, 4))<br/>ax.hist(<br/>    final_state[final_state["time_wait"] &gt; proc_time_max]["time_wait"],<br/>    bins=50,<br/>    color=sns_col[3],<br/>)<br/>ax.set_title("Distribution of wait durations for outliers", fontsize=18)<br/>ax.set_xlabel("wait duration (sec)")<br/>ax.set_ylabel("count")<br/>plt.savefig("outlier_wait.png", bbox_inches="tight")<br/>plt.show()</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/fa9455bd299c78fd29b682feeb58d82b.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*H0TOdPZbAqDC-3TWOPO9Yg.png"/></div></figure><p id="d6c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些大多是最初激增时的客户。他们中的一些人等了相当长的时间，有时超过30分钟，但他们不是很多。</p><h1 id="4838" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">探索不同的场景</h1><p id="2ec8" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">让我们再次运行模拟。这一次，我们将客户流量从每秒0.8个增加到0.9个。其他一切保持不变。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nb"><img src="../Images/a3c615c31a00dc04bbeee964b9fe2ed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_b7grhT4b8KxC1GacOOqMA.png"/></div></div></figure><p id="8801" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显然，没什么变化。但是有一个警告信号:目前的等待时间已经变得很长了。有时，由于随机波动，等待时间会显著增加。这可能表明我们已经接近临界点了。</p><p id="00a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们把客户涌入量提高到1个客户/秒。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nd"><img src="../Images/2811d3613dc436269668472c7b893d51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KABUZFK8WT7dbuTTo1hPxQ.png"/></div></div></figure><p id="7883" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你基本上是在看一场灾难。在整个模拟过程中，所有的机器都全力以赴地运行，然而这还不够:有许多客户被困在等待中，等待时间很长。对异常值的观察证实了这一点:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/cf51ca0b21572d5350451d0d901c663a.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*pgUnN7u2642BtMFoTAp2UA.png"/></div></figure><p id="c6db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数百名顾客等待长达30分钟，还有一些等待几个小时。显然，就这台机器集群所能做的事情而言，我们已经达到了一个阈值。</p><p id="c649" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有一件事可以尝试:让我们将持续的客户流入保持在1个客户/秒，同时消除最初的激增。换句话说，如果我们假设没有大的波动，集群能处理这样的到达率吗？</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nb"><img src="../Images/061e01a3c0266ade88608cc81c4e244c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2I6vCUZQqiVSOiHqf8y1Tg.png"/></div></div></figure><p id="eba2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">答案是否定的。排队的队伍越来越长。最初的激增在最终结果中只起了很小的作用。集群根本没有能力处理这种流入。</p><h1 id="b8a3" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">进一步分析</h1><p id="3fc7" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">到目前为止，我们所做的只是视觉化，我们将到此为止。本文旨在介绍与模拟相关的基本概念。</p><p id="7c22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是在实际场景中，可能会涉及到几个变量:不同大小的多个集群、不同的处理时间、消耗的各种资源等。您可能必须将一些结果作为优化度量(比如:平均等待时间)，并系统地探索参数空间(就像scikit-learn中的GridSearchCV)以寻找最佳结果。</p><p id="c19d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行这样的模拟很多很多次，寻找参数的最佳组合，这并不罕见。如果你已经为机器学习模型进行了超参数调整，这在概念上是非常相似的——你正在参数空间中寻找最佳结果。</p><p id="33d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果这听起来很开放，那是因为它是。在某些方面，您在这里比在机器学习模型中有更多的自由，但一些相同的通用技术仍然适用。</p><p id="b6a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就时间(任务持续时间、客户等待时间)而言，100台机器和5000个客户与10台机器和500个客户是一样的，但前一个模型给出的结果对波动的依赖性较小。中心极限定理对你有利。总是运行你能负担得起的最大模拟，或者多次运行小模拟，以确保波动不会影响结果。</p><h1 id="2a72" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">最佳化</h1><p id="9b89" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们已经对大部分代码进行了矢量化，但是Numpy和Pandas是单线程的，这是这些库的基本限制。对于非常大的模拟，您可能需要研究分布式处理库，如Apache Spark。</p><p id="1346" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，模拟的最外层循环是顺序的，您不能将其并行化，因为它反映了时间的流动，并且时刻t取决于之前的所有时刻t-1、t-2……。但是您绝对可以并行化内部代码块。</p><p id="38d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了更大的速度提升，丢弃数据帧，到处使用数组，并使用GPU加速的Numpy等效物，如Cupy。对于小型模拟来说，这不值得麻烦，事实上它可能会更慢。对于大型模拟，速度提升非常大，通常至少一个数量级，并且随着模拟的变大，速度提升也会变大。</p><p id="b5ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，您可以编写跨多个GPU运行的分布式代码，以获得最终的速度提升。但是代码的复杂性将会非常大。</p><h1 id="98ff" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">最后的话</h1><p id="78b8" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">包含所有代码的笔记本可在此处获得:</p><div class="nf ng gp gr nh ni"><a href="https://github.com/FlorinAndrei/misc/blob/master/load_simulation/user_wait_time.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">主服务器上的misc/user_wait_time.ipynb</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">随意的东西。在GitHub上创建一个帐户，为FlorinAndrei/misc开发做贡献。</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw kv ni"/></div></div></a></div><p id="f778" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有图片均由作者创作。</p></div></div>    
</body>
</html>