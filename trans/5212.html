<html>
<head>
<title>Threshold Autoregressive Models — beyond ARIMA + R Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">门限自回归模型——超越 ARIMA + R 码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/threshold-autoregressive-models-beyond-arima-r-code-6af3331e2755#2022-11-22">https://towardsdatascience.com/threshold-autoregressive-models-beyond-arima-r-code-6af3331e2755#2022-11-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6acb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">满足 TAR——自回归模型的非线性扩展。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5217c45abadcd7e8be095091f79ae4c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nMDvssOnUojqsd4a.jpg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://pixabay.com/pl/users/3844328-3844328/" rel="noopener ugc nofollow" target="_blank"> 3844328 </a></p></figure><h2 id="0432" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">介绍</h2><p id="4386" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">当谈到时间序列分析时，在学术上你最有可能从自回归模型开始，然后扩展到自回归移动平均模型，然后扩展到积分使其成为 ARIMA。接下来的步骤通常是季节性分析类型，包含额外的内生和外生变量(ARDL，VAR)最终面临协整。<em class="ml">从这一刻开始，事情变得越来越有趣</em>。</p><p id="f1c6" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">这是因为这是严格而美好的程序的终结，例如在 Box-Jenkins 方法中。<a class="ae kv" href="https://medium.com/@michacukrowski/nonlinear-time-series-an-intuitive-introduction-7390aae8b446" rel="noopener">如前所述，时间序列中非线性排列的可能数量几乎是无限的</a>——因此通用程序不再适用。是不是意味着游戏结束了？见鬼不要。如今，处理非线性时间序列最流行的方法是使用机器学习和深度学习技术——由于我们不知道时刻<em class="ml"> t-1 </em>和<em class="ml"> t </em>之间的真实关系，我们将使用一种不假设依赖类型的算法。</p><p id="19d4" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">在机器学习之前，计量经济学家是如何管理这个问题<em class="ml">的？这就是 TAR 模型的用武之地。</em></p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h2 id="21f5" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">阈值自回归模型</h2><p id="0f98" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">让我们从简单的 AR 模型开始。其公式确定为:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="d214" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">一切都只存在于一个等式中——美丽。在我们继续讨论焦油的分析公式之前，我需要告诉你它实际上是如何工作的。首先，在 TAR 模型中，我们称之为<em class="ml">机制</em>。它们是什么？它们是由<em class="ml">阈值</em>分隔的区域，根据这些阈值我们切换 AR 方程。<em class="ml">我们交换，什么？</em>为简单起见，让我们考虑最简单的双机制 TAR 模型:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/bebe3a73106681e09b1a28d960663a5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DOyq3nup1PXB1dAJRe6ffg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">阈值自回归的一般方程，作者的图形。</p></figure><p id="264a" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">其中:</p><p id="1913" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">p1，p2——自回归子方程的阶数，</p><p id="1fb7" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">r —已知的阈值，</p><p id="04b5" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">z _ t——取决于状态的力矩<em class="ml"> t </em>中的已知值</p><p id="8c41" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">现在让我们来读一下这个公式，以便更好地理解它:</p><blockquote class="nb"><p id="59c2" class="nc nd iq bd ne nf ng nh ni nj nk mk dk translated">时间序列在时刻<em class="nl"> t </em>的值等于满足<em class="nl">条件的自回归模型的输出:</em><strong class="ak"><em class="nl">Z≤r</em></strong><em class="nl">或</em> Z <em class="nl"> &gt; r. </em></p></blockquote><p id="6497" class="pw-post-body-paragraph ls lt iq lu b lv nm jr lx ly nn ju ma lf no mc md lj np mf mg ln nq mi mj mk ij bi translated">听起来有点抽象，对吧？难怪 TAR 模型是阈值转换模型的概括。<strong class="lu ir">这意味着在建立政权转换发生的条件模型时，你是最灵活的。我建议你读完整篇文章后再读一遍这一部分——我保证到时会更清楚。现在，让我们来看一个更实际的例子。</strong></p><p id="5217" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">如果我们用<em class="ml">时间序列的前一个值</em>代替 Z_t 值，TAR 模型就变成了一个自激门限自回归模型— SETAR(k，p1，…，pn)，其中<em class="ml">k</em>是模型中的状态数，【T10]p 是每个自回归分量的连续阶数。两种状态的 SETAR(2，p1，p2)模型可以描述为:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/493044506a0aee431ae36690259610ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z-cctqBvaA6ZqpPjlOVOJA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">两种状态下的一般方程。</p></figure><p id="ecee" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">现在它看起来更贴近地面了，对吗？让我们用散点图来形象化它，这样你就有了直觉:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/a13ed3dd734e69dbddb5fd2d3206f0b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ihp5ZXE-ZEpmfUFG0g3Img.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">生成的 SETAR(2，1，1)的散点图，其上绘制了黄土线和标记阈值的垂直红线，由作者绘制。(由 tsDyn 生成)</p></figure><p id="119f" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">在这种情况下，<code class="fe nt nu nv nw b">k = 2</code>、<code class="fe nt nu nv nw b">r = 0</code>、<code class="fe nt nu nv nw b">p1 = p2 = 1</code>和<code class="fe nt nu nv nw b">d = 1</code>、<em class="ml">。</em>你可以清楚地看到状态转换发生的阈值。但是在实际的时间序列上看起来如何呢？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/33aa5f5528b2dee152ab9bbedf775ca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*amxEn3KEik4QT0UBrWSX_w.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">生成的 SETAR(2，1，1)及其累积和，由作者绘制。</p></figure><p id="0aba" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">正如你所看到的，仅仅从外观上很难说我们正在处理一个阈值时间序列。那我们能做什么？让我们解决一个没有生成的例子，这样你就可以重复整个过程。</p><h2 id="61a6" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">建模程序</strong></h2><p id="a2cf" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">让我们开始编码吧，我会一路解释这个过程。我们将使用 Lynx 数据集，并将其分为训练集和测试集(我们将进行预测):</p><pre class="kg kh ki kj gt ny nw nz bn oa ob bi"><span id="9fbf" class="oc kx iq nw b be od oe l of og">library("quantmod")<br/>library("tsDyn")<br/>library("stats")<br/>library("nonlinearTseries")<br/>library("datasets")<br/>library("NTS")<br/><br/>data &lt;- log10(datasets::lynx)<br/><br/>train &lt;- data[1:80]<br/>test &lt;- data[81:114]</span></pre><p id="7381" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">我记录了整个数据集，因此我们可以获得整个数据集的更好的统计属性。现在，让我们检查自相关和偏自相关:</p><pre class="kg kh ki kj gt ny nw nz bn oa ob bi"><span id="e4c0" class="oc kx iq nw b be od oe l of og">{par(mfrow=c(2,1))<br/>acf(train)<br/>pacf(train)}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/03994b9efd4549c2c887b36b5b1734dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LEJUVeYlMkb1Cb61hZF9Qw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">按作者</p></figure><p id="e43e" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">看起来这个系列有可能以 ARIMA 为模型——也将在路上尝试一下。然而，让我们来看看滞后图:</p><pre class="kg kh ki kj gt ny nw nz bn oa ob bi"><span id="5ae2" class="oc kx iq nw b be od oe l of og">{par(mfrow=c(2,2))<br/>  scatter.smooth(Lag(train, 1), train, span = 2/3, degree = 1,<br/>                 family = c("symmetric", "gaussian"), evaluation = 50, <br/>  xlab = "t-1", ylab = "t")<br/>  scatter.smooth(Lag(train, 2), train, span = 2/3, degree = 1,<br/>                 family = c("symmetric", "gaussian"), evaluation = 50, <br/>  xlab = "t-2", ylab = "t")<br/>  scatter.smooth(Lag(train, 3), train, span = 2/3, degree = 1,<br/>                 family = c("symmetric", "gaussian"), evaluation = 50, <br/>  xlab = "t-3", ylab = "t")<br/>  scatter.smooth(Lag(train, 4), train, span = 2/3, degree = 1,<br/>                 family = c("symmetric", "gaussian"), evaluation = 50, <br/>  xlab = "t-4", ylab = "t")<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/beb1057d9640c03f5935b1d61eb286a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zYiS0SQQSMXuwyv2N8-TQA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">黄土线打开时训练集的滞后散点图，作者</p></figure><p id="56dc" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">在第一个滞后中，这种关系似乎确实适合 ARIMA，但从第二个滞后上看，非线性关系是显而易见的。然而，有时事情就是这样发生的，要决定这种类型的非线性是否存在并不那么简单<em class="ml"/>。在这种情况下，我们必须进行统计测试——这种方法是汉森和 Tsay 最推荐的方法。然而，为了做到这一点，最好首先建立我们或多或少在谈论的滞后次序。为此，我们将使用平均互信息，并将订单限制为其第一个本地最小值:</p><pre class="kg kh ki kj gt ny nw nz bn oa ob bi"><span id="35e9" class="oc kx iq nw b be od oe l of og">mutualInformation(train)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/18eb441a666587bbb375f9da2931ac25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7YRzTRUlVyoLmlNu23CfMQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者为训练集创建的 AMI</p></figure><p id="d500" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">因此，嵌入维度被设置为<code class="fe nt nu nv nw b"><em class="ml">m=3</em></code>。当然，这只是一种方法，你可以用不同的方法。请注意，我们可以再次看到强烈的季节性。现在，我们已经建立了最大滞后，让我们执行统计测试。我们将使用似然比检验来检验阈值非线性。它的假设是:</p><blockquote class="ok ol om"><p id="0b35" class="ls lt ml lu b lv mm jr lx ly mn ju ma on mo mc md oo mp mf mg op mq mi mj mk ij bi translated">H0:这个过程是一个 AR(p)</p><p id="b60a" class="ls lt ml lu b lv mm jr lx ly mn ju ma on mo mc md oo mp mf mg op mq mi mj mk ij bi translated">H1:这个过程是一个集合</p></blockquote><p id="6a24" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">这意味着我们想要拒绝关于过程是 AR(p)的零假设——但是记住过程应该是自相关的——否则，H0 可能没有多大意义。</p><pre class="kg kh ki kj gt ny nw nz bn oa ob bi"><span id="ade4" class="oc kx iq nw b be od oe l of og">for (d in 1:3){<br/>  for (p in 1:3){<br/>    cat("p = ", p, " d = ", d, " P-value = ", thr.test(train, p=p, d=d), "\n")<br/>  }<br/>}</span></pre><pre class="oq ny nw nz bn oa ob bi"><span id="7c08" class="oc kx iq nw b be od oe l or og">SETAR model is entertained <br/>Threshold nonlinearity test for (p,d):  1 1 <br/>F-ratio and p-value:  0.5212731 0.59806 <br/><br/>SETAR model is entertained <br/>Threshold nonlinearity test for (p,d):  2 1 <br/>F-ratio and p-value:  2.240426 0.1007763 <br/><br/>SETAR model is entertained <br/>Threshold nonlinearity test for (p,d):  3 1 <br/>F-ratio and p-value:  1.978699 0.1207424 <br/><br/>SETAR model is entertained <br/>Threshold nonlinearity test for (p,d):  1 2 <br/>F-ratio and p-value:  37.44167 1.606391e-09 <br/><br/>SETAR model is entertained <br/>Threshold nonlinearity test for (p,d):  2 2 <br/>F-ratio and p-value:  8.234537 0.0002808383 <br/><br/>SETAR model is entertained <br/>Threshold nonlinearity test for (p,d):  3 2 <br/>F-ratio and p-value:  7.063951 0.0003181314 <br/><br/>SETAR model is entertained <br/>Threshold nonlinearity test for (p,d):  1 3 <br/>F-ratio and p-value:  30.72234 1.978433e-08 <br/><br/>SETAR model is entertained <br/>Threshold nonlinearity test for (p,d):  2 3 <br/>F-ratio and p-value:  3.369506 0.02961576 <br/><br/>SETAR model is entertained <br/>Threshold nonlinearity test for (p,d):  3 3 <br/>F-ratio and p-value:  3.842919 0.01135399 </span></pre><p id="80e8" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">正如你所看到的，在<code class="fe nt nu nv nw b">alpha = 0.05</code> <em class="ml"> </em>我们不能拒绝只有参数<code class="fe nt nu nv nw b">d = 1</code>的零假设，但是如果你回头看看滞后曲线，你就会明白为什么会发生这种情况。</p><p id="7937" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">另一个可以进行的测试是汉森线性测试。它的假设是:</p><blockquote class="ok ol om"><p id="7b10" class="ls lt ml lu b lv mm jr lx ly mn ju ma on mo mc md oo mp mf mg op mq mi mj mk ij bi translated">H0:时间序列遵循一些 AR 过程</p><p id="b287" class="ls lt ml lu b lv mm jr lx ly mn ju ma on mo mc md oo mp mf mg op mq mi mj mk ij bi translated">H1:时间序列遵循某种特定的过程</p></blockquote><p id="1529" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">然而，这一次，假设被指定得更好一点——我们可以测试 AR 与 SETAR(2)、AR 与 SETAR(3)甚至 SETAR(2)与 SETAR(3)！让我们测试我们的数据集:</p><pre class="kg kh ki kj gt ny nw nz bn oa ob bi"><span id="c9ee" class="oc kx iq nw b be od oe l of og">setarTest(train, m=3, nboot=400)<br/>setarTest(train, m=3, nboot=400, test='2vs3')</span></pre><pre class="oq ny nw nz bn oa ob bi"><span id="bbef" class="oc kx iq nw b be od oe l or og">Test of linearity against setar(2) and setar(3)<br/><br/>         Test   Pval<br/>1vs2 25.98480 0.0175<br/>1vs3 46.31897 0.0150<br/><br/><br/>Test of setar(2) against  setar(3)<br/><br/>         Test   Pval<br/>2vs3 15.20351 0.2425</span></pre><p id="3126" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">这个测试基于 bootstrap 分布，因此计算可能会变得有点慢——不要放弃，你的计算机没有死，它需要时间:)在第一种情况下，我们可以拒绝两个空值——时间序列遵循 SETAR(2)或 SETAR(3)。从第二个测试中，我们发现我们不能拒绝 SETAR(2)的空值，因此没有理由怀疑 SETAR(3)的存在。因此，SETAR(2，p1，p2)是要估计的模型。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><p id="3078" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">到目前为止，我们已经估计了<em class="ml"> m </em>、<em class="ml"> d </em>和<em class="ml">k</em>的值的<em class="ml">可能范围</em>，仍然需要的是阈值<em class="ml"> r </em>。不幸的是，它的估计是最棘手的，几十年来一直是计量经济学家的一大难题。我不知道任何计算它的分析方法(如果你知道，请在评论中告诉我！)，而是通常执行网格搜索。</p><p id="17af" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">背后的直觉有点类似于决策树中的递归二进制分裂——我们用增加的阈值连续地估计模型。幸运的是，我们不必从 0 开始编写代码，这个特性在 r 中是可用的。</p><p id="772c" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">对于给定的阈值，我们希望实现<em class="ml">最小的可能信息标准值。尽管如此，这种方法总会给你一些输出！你要找的是一个<strong class="lu ir">清晰的最小值</strong>。这看起来不错:</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/2b83a133f5c0efdf3a9e1e3e25f2270c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r0ymhn6JGp9cKVwQ2Xj2Hw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">对 tsDyn 生成的数据集进行网格搜索</p></figure><p id="3a26" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">有一个<em class="ml">明确</em>最低一点点低于 2.6。图表越呈 V 形越好——但这并不意味着你总能得到漂亮的结果，因此解释和滞后图对你的推断至关重要。这就是<em class="ml">不</em>好看的地方:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/4212eef7fa2b82affafded82adef5d89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cvsMSxguT_1dTRTf9JJ8Vg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">生成数据集的网格搜索</p></figure><p id="ccb2" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">虽然这个也有一些局部最小值，但不像以前那么明显——让 SETAR 来取这个阈值，你就有过度拟合的风险。实际上，虽然它看起来从来没有这么好——你在寻找许多组合，因此会有许多像这样的线。让我们回到我们的例子:</p><pre class="kg kh ki kj gt ny nw nz bn oa ob bi"><span id="3162" class="oc kx iq nw b be od oe l of og">selectSETAR(train, m=3, thDelay=1:2)</span></pre><pre class="oq ny nw nz bn oa ob bi"><span id="3a56" class="oc kx iq nw b be od oe l or og">Using maximum autoregressive order for low regime: mL = 3 <br/>Using maximum autoregressive order for high regime: mH = 3 <br/>Searching on 50 possible threshold values within regimes with sufficient ( 15% ) number of observations<br/>Searching on  900  combinations of thresholds ( 50 ), thDelay ( 2 ), mL ( 3 ) and MM ( 3 ) <br/>Results of the grid search for 1 threshold<br/>   thDelay mL mH       th pooled-AIC<br/>1        2  3  3 2.940018  -26.88059<br/>2        2  3  3 2.980912  -26.44335<br/>3        2  3  2 2.940018  -24.66521<br/>4        2  3  2 2.980912  -24.43568<br/>5        2  3  3 2.894316  -24.20612<br/>6        2  3  3 3.399847  -22.98202<br/>7        2  3  2 2.894316  -22.89391<br/>8        2  2  3 2.940018  -22.15513<br/>9        2  3  2 3.399847  -21.34704<br/>10       2  1  3 2.940018  -20.52942</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/b5d6f1fcfe0c4bb4a687837c68edec1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nFUrFNwzwsWI2ma0jDPCuA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">训练集的网格搜索</p></figure><p id="48d4" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">因此，首选系数为:</p><pre class="kg kh ki kj gt ny nw nz bn oa ob bi"><span id="d48a" class="oc kx iq nw b be od oe l or og">thDelay mL mH       th pooled-AIC<br/>2        3  3 2.940018  -26.88059</span></pre><p id="0b8f" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">太好了！是时候进行最终的模型估算了:</p><pre class="kg kh ki kj gt ny nw nz bn oa ob bi"><span id="5990" class="oc kx iq nw b be od oe l of og">model &lt;- setar(train, m=3, thDelay = 2, th=2.940018)<br/>summary(model)</span></pre><pre class="oq ny nw nz bn oa ob bi"><span id="6d28" class="oc kx iq nw b be od oe l or og">Non linear autoregressive model<br/><br/>SETAR model ( 2 regimes)<br/>Coefficients:<br/>Low regime:<br/>   const.L     phiL.1     phiL.2     phiL.3 <br/> 0.8765919  0.9752136  0.0209953 -0.2520500 <br/><br/>High regime:<br/>   const.H     phiH.1     phiH.2     phiH.3 <br/> 0.3115240  1.6467881 -1.3961317  0.5914694 <br/><br/>Threshold:<br/>-Variable: Z(t) = + (0) X(t)+ (0)X(t-1)+ (1)X(t-2)<br/>-Value: 2.94 (fixed)<br/>Proportion of points in low regime: 55.84%   High regime: 44.16% <br/><br/>Residuals:<br/>       Min         1Q     Median         3Q        Max <br/>-0.5291117 -0.1243479 -0.0062972  0.1211793  0.4866163 <br/><br/>Fit:<br/>residuals variance = 0.03438,  AIC = -254, MAPE = 5.724%<br/><br/>Coefficient(s):<br/><br/>         Estimate  Std. Error  t value  Pr(&gt;|t|)    <br/>const.L  0.876592    0.227234   3.8577 0.0002469 ***<br/>phiL.1   0.975214    0.142437   6.8466 2.117e-09 ***<br/>phiL.2   0.020995    0.196830   0.1067 0.9153498    <br/>phiL.3  -0.252050    0.121473  -2.0749 0.0415656 *  <br/>const.H  0.311524    0.685169   0.4547 0.6507163    <br/>phiH.1   1.646788    0.172511   9.5460 2.027e-14 ***<br/>phiH.2  -1.396132    0.277983  -5.0224 3.576e-06 ***<br/>phiH.3   0.591469    0.272729   2.1687 0.0334088 *  <br/>---<br/>Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1<br/><br/>Threshold<br/>Variable: Z(t) = + (0) X(t) + (0) X(t-1)+ (1) X(t-2)<br/><br/>Value: 2.94 (fixed)</span></pre><p id="62b4" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">SETAR 模型已安装。现在，由于我们正在进行预测，让我们将其与 ARIMA 模型(通过 auto-arima 拟合)进行比较:</p><pre class="kg kh ki kj gt ny nw nz bn oa ob bi"><span id="6185" class="oc kx iq nw b be od oe l or og">ARIMA(4,0,1) with non-zero mean <br/><br/>Coefficients:<br/>         ar1     ar2      ar3      ar4     ma1    mean<br/>      0.3636  0.4636  -0.4436  -0.2812  0.9334  2.8461<br/>s.e.  0.1147  0.1290   0.1197   0.1081  0.0596  0.0515<br/><br/>sigma^2 = 0.0484:  log likelihood = 8.97<br/>AIC=-3.93   AICc=-2.38   BIC=12.74<br/><br/>Training set error measures:<br/>                        ME      RMSE       MAE        MPE     MAPE      MASE<br/>Training set -0.0002735047 0.2115859 0.1732282 -0.6736612 6.513606 0.5642003<br/>                     ACF1<br/>Training set -0.002296863</span></pre><p id="144d" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">SETAR 似乎更适合训练。现在让我们比较测试集的 MSE 和 RMSE 的结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/eb2dd5d9be945c8d141742e13f14db11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HWZkIUTSqkN0IRj-EiO18Q.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者对塞塔和 ARIMA 的样本外预测</p></figure><pre class="kg kh ki kj gt ny nw nz bn oa ob bi"><span id="d556" class="oc kx iq nw b be od oe l or og">SETAR MSE: 0.04988592<br/>SETAR RMSE: 0.2233516<br/><br/>ARIMA MSE: 0.06146426<br/>ARIMA RMSE: 0.2479199</span></pre><p id="3a46" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">如您所见，SETAR 能够为训练集和测试集提供更好的结果。</p><h2 id="aee1" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">最终注释</h2><ol class=""><li id="5736" class="ov ow iq lu b lv lw ly lz lf ox lj oy ln oz mk pa pb pc pd bi translated">TAR 的平稳性——这是一个非常复杂的话题，我强烈建议您从科学资源中寻找相关信息。然而，你可以应用一个不完整的规则:<strong class="lu ir">如果在任何一个机制中有一个单位根，那么整个过程是非平稳的</strong>。</li><li id="3a81" class="ov ow iq lu b lv pe ly pf lf pg lj ph ln pi mk pa pb pc pd bi translated">第一个生成的模型是平稳的，但在某些条件下，TAR 也可以模拟非平稳的时间序列。当它的状态都是稳定的时候，这样做是安全的。在这种情况下，你很可能会处理结构性变化。</li><li id="b929" class="ov ow iq lu b lv pe ly pf lf pg lj ph ln pi mk pa pb pc pd bi translated">制度的数量——理论上，制度的数量是不受限制的，但是根据我的经验，我可以告诉你，如果制度的数量超过 2，通常最好使用机器学习。</li><li id="9d2b" class="ov ow iq lu b lv pe ly pf lf pg lj ph ln pi mk pa pb pc pd bi translated"><strong class="lu ir"> SETAR 模型经常与 TAR 混淆</strong>——如果您在统计包中看到一个实际上是 SETAR 的 TAR 模型，请不要惊讶。每个星都是星，但不是每个星都是星。</li><li id="f0a0" class="ov ow iq lu b lv pe ly pf lf pg lj ph ln pi mk pa pb pc pd bi translated">为了适应模型，我使用了 AIC 和 pooled-AIC(SETAR)。如果您的案例需要不同的衡量标准，您可以轻松地更改信息标准。</li></ol><h2 id="54a4" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">摘要</h2><p id="6f67" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">阈值自回归模型曾经是过去最流行的非线性模型，但今天主要被机器学习算法取代。尽管如此，多年来它们已经被证明是有用的，而且因为你总是为任务选择工具，我希望你会发现它有用。</p><p id="ec18" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">当然，SETAR 是一个可以扩展的基本模型。如果你对获得更好的结果感兴趣，请确保关注我的<a class="ae kv" href="https://medium.com/@michacukrowski" rel="noopener">个人资料</a>！</p><p id="5bd2" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">你也可以在<a class="ae kv" href="https://www.linkedin.com/in/micha%C5%82-cukrowski/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上找到我。</p><p id="8e49" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated"><a class="ae kv" href="https://www.picostat.com/dataset/r-dataset-package-datasets-lynx" rel="noopener ugc nofollow" target="_blank">链接</a>到数据(GNU)。</p><div class="pj pk gp gr pl pm"><a rel="noopener follow" target="_blank" href="/nonlinear-time-series-an-intuitive-introduction-7390aae8b446"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd ir gy z fp pr fr fs ps fu fw ip bi translated">非线性时间序列——直观介绍</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">为什么你的标准时间序列分析程序有时会失败？</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">towardsdatascience.com</p></div></div><div class="pv l"><div class="pw l px py pz pv qa kp pm"/></div></div></a></div></div></div>    
</body>
</html>