<html>
<head>
<title>How to Bin Numerical Data with Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将数字数据与熊猫绑定</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-bin-numerical-data-with-pandas-fe5146c9dc55#2022-04-18">https://towardsdatascience.com/how-to-bin-numerical-data-with-pandas-fe5146c9dc55#2022-04-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b9b5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用熊猫离散化数值变量，介于，cut，qcut和值计数之间</h2></div><h1 id="bfa0" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">介绍</h1><p id="9bea" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">宁滨也称为分桶或离散化，是一种常见的数据预处理技术，用于将连续数据的间隔分组到“箱”或“桶”中。在本文中，我们将讨论使用python熊猫库计算宁滨数值的4种方法。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi lw"><img src="../Images/7819156ab90167f790beedc3bbd65779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S0pVatBrbF9hLMPd"/></div></div><p class="mi mj gj gh gi mk ml bd b be z dk translated">Pawel Czerwinski 在<a class="ae mm" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="7ec5" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">方法</h1><p id="b7ca" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了便于说明，我们创建了以下合成数据。</p><pre class="lx ly lz ma gt mn mo mp mq aw mr bi"><span id="9e74" class="ms kj it mo b gy mt mu l mv mw">import pandas as pd # version 1.3.5<br/>import numpy as np</span><span id="6a53" class="ms kj it mo b gy mx mu l mv mw">def create_df():</span><span id="419e" class="ms kj it mo b gy mx mu l mv mw">    df = pd.DataFrame({'score': np.random.randint(0,101,1000)})</span><span id="008e" class="ms kj it mo b gy mx mu l mv mw">    return df</span><span id="67f2" class="ms kj it mo b gy mx mu l mv mw">df = create_df()</span><span id="63e0" class="ms kj it mo b gy mx mu l mv mw">df.head()</span></pre><p id="ff5a" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">这些数据包括1000名学生从0到100的学习成绩。任务是将数值分数分为“A”、“B”和“C”三个等级，其中“A”是最好的等级，“C”是最差的等级。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/ecc18ba9ef5b67420ef522b9ba0f3e60.png" data-original-src="https://miro.medium.com/v2/resize:fit:174/0*CJo0ci4cPnW6gvk_"/></div><p class="mi mj gj gh gi mk ml bd b be z dk translated">作者图片</p></figure><h1 id="3521" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">1.&amp; loc之间</h1><blockquote class="ne nf ng"><p id="bafb" class="la lb nh lc b ld my ju lf lg mz jx li ni na ll lm nj nb lp lq nk nc lt lu lv im bi translated"><em class="it"> Pandas </em> <code class="fe nl nm nn mo b"><em class="it">.between</em></code> <em class="it">方法返回一个包含True的布尔向量，无论相应的Series元素在边界值left和right[1]之间。</em></p></blockquote><p id="95b6" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated"><strong class="lc iu">参数</strong></p><ul class=""><li id="fad5" class="no np it lc b ld my lg mz lj nq ln nr lr ns lv nt nu nv nw bi translated"><code class="fe nl nm nn mo b">left</code>:左边界</li><li id="9def" class="no np it lc b ld nx lg ny lj nz ln oa lr ob lv nt nu nv nw bi translated"><code class="fe nl nm nn mo b">right</code>:右边界</li><li id="606b" class="no np it lc b ld nx lg ny lj nz ln oa lr ob lv nt nu nv nw bi translated"><code class="fe nl nm nn mo b">inclusive</code>:包含哪个边界。可接受的值是<em class="nh"> {“两者”、“两者都不是”、“左”、“右”}。</em></li></ul><p id="493e" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">让我们根据以下间隔将学生的分数分成几个等级:</p><ul class=""><li id="db7b" class="no np it lc b ld my lg mz lj nq ln nr lr ns lv nt nu nv nw bi translated">答:(80，100)</li><li id="f025" class="no np it lc b ld nx lg ny lj nz ln oa lr ob lv nt nu nv nw bi translated">乙:(50，80)</li><li id="c7be" class="no np it lc b ld nx lg ny lj nz ln oa lr ob lv nt nu nv nw bi translated">丙:[0，50]</li></ul><p id="515e" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">其中方括号<code class="fe nl nm nn mo b">[</code>和圆括号<code class="fe nl nm nn mo b">)</code>分别表示边界值包含和不包含。</p><p id="ccaa" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">我们识别哪些<code class="fe nl nm nn mo b">score</code>位于感兴趣的区间之间，并为其分配相应的<code class="fe nl nm nn mo b">grade</code>值。对于等级“A”和“B ”,只有右边界包含在内，因此我们将<code class="fe nl nm nn mo b">right</code>传递给<code class="fe nl nm nn mo b">inclusive</code>参数。对于等级“C ”,两个边界都包含在内，因此我们将<code class="fe nl nm nn mo b">both</code>传递给<code class="fe nl nm nn mo b">inclusive</code>参数。</p><pre class="lx ly lz ma gt mn mo mp mq aw mr bi"><span id="109f" class="ms kj it mo b gy mt mu l mv mw">df.loc[df['score'].between(0, 50, 'both'), 'grade'] = 'C'<br/>df.loc[df['score'].between(50, 80, 'right'), 'grade'] = 'B'<br/>df.loc[df['score'].between(80, 100, 'right'), 'grade'] = 'A'</span></pre><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/08911d84097500270da8200851e2c0bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:272/0*2Jey-FOADIQiFx3D"/></div><p class="mi mj gj gh gi mk ml bd b be z dk translated">作者图片</p></figure><p id="3b6a" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">这是每个箱子里的学生人数</p><pre class="lx ly lz ma gt mn mo mp mq aw mr bi"><span id="ea11" class="ms kj it mo b gy mt mu l mv mw">df.grade.value_counts()</span></pre><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi od"><img src="../Images/6797b7d6069c42231d1e1eefb267839d.png" data-original-src="https://miro.medium.com/v2/resize:fit:432/0*Gr4_kZhLikrvqVRK"/></div><p class="mi mj gj gh gi mk ml bd b be z dk translated">作者图片</p></figure><p id="f9a1" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">这种方法需要为每一个bin添加一行新的代码，因此它只适用于bin很少的情况。</p><h1 id="9b17" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">2.切口</h1><blockquote class="ne nf ng"><p id="a9da" class="la lb nh lc b ld my ju lf lg mz jx li ni na ll lm nj nb lp lq nk nc lt lu lv im bi translated"><em class="it">将值装入离散区间。当您需要将数据值分段和排序到箱中时，请使用cut。这个函数对于从连续变量到分类变量也很有用[2]。</em></p></blockquote><p id="2735" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">基于与上述示例相同的间隔对学生进行分组。这些是所使用的参数:</p><ul class=""><li id="99a9" class="no np it lc b ld my lg mz lj nq ln nr lr ns lv nt nu nv nw bi translated"><code class="fe nl nm nn mo b">x</code>:要入库的输入数组。必须是一维的。</li><li id="e04d" class="no np it lc b ld nx lg ny lj nz ln oa lr ob lv nt nu nv nw bi translated"><code class="fe nl nm nn mo b">bins</code>:标量序列:定义允许非均匀宽度的bin边缘。</li><li id="2b2b" class="no np it lc b ld nx lg ny lj nz ln oa lr ob lv nt nu nv nw bi translated"><code class="fe nl nm nn mo b">labels</code>:指定退回箱子的标签。必须与生成的条柱长度相同。</li><li id="3279" class="no np it lc b ld nx lg ny lj nz ln oa lr ob lv nt nu nv nw bi translated"><code class="fe nl nm nn mo b">include_lowest</code> : (bool)第一个区间是否应该左包含。</li></ul><pre class="lx ly lz ma gt mn mo mp mq aw mr bi"><span id="bb33" class="ms kj it mo b gy mt mu l mv mw">bins = [0, 50, 80, 100]<br/>labels = ['C', 'B', 'A']<br/>df['grade'] = pd.cut(x = df['score'], bins = bins, labels = labels, include_lowest = True)</span></pre><p id="3b69" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">我们创建一个包含面元边界值的<code class="fe nl nm nn mo b">bins</code>列表和一个包含相应面元标签的<code class="fe nl nm nn mo b">labels</code>列表。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/81bac5b3b2a0397c1bef4f105a560cfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:272/0*K9tPDgkxLokqvW2f"/></div><p class="mi mj gj gh gi mk ml bd b be z dk translated">作者图片</p></figure><p id="cd10" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">这是每个箱子里的学生人数</p><pre class="lx ly lz ma gt mn mo mp mq aw mr bi"><span id="2412" class="ms kj it mo b gy mt mu l mv mw">df.grade.value_counts()</span></pre><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi od"><img src="../Images/ebc85190edf103b4bcc21424580fa044.png" data-original-src="https://miro.medium.com/v2/resize:fit:432/0*s2uuMALEBKXFNfQ0"/></div><p class="mi mj gj gh gi mk ml bd b be z dk translated">作者图片</p></figure><p id="71cf" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">结果与第一个示例相同。</p><h1 id="a01c" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">3.qcut</h1><blockquote class="ne nf ng"><p id="c641" class="la lb nh lc b ld my ju lf lg mz jx li ni na ll lm nj nb lp lq nk nc lt lu lv im bi translated"><em class="it">基于分位数的离散化函数。根据等级或样本分位数将变量离散化为大小相等的桶[3]。</em></p></blockquote><p id="6a96" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">在前面的例子中，我们已经为每个年级定义了分数区间，这导致每个年级箱中的学生数量不均匀。在下面的例子中，我们尝试将学生分成3个年级组，每个组有相同(大约)数量的学生。我们有1000名学生，因此每个库应该有大约333名学生。首先根据分数对学生进行排名，前三分之一、中三分之一和后三分之一的学生分别被分配到“A”、“B”和“C”等级。</p><p id="631b" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">以下是以下示例中使用的参数:</p><ul class=""><li id="4792" class="no np it lc b ld my lg mz lj nq ln nr lr ns lv nt nu nv nw bi translated"><code class="fe nl nm nn mo b">x</code>:要入库的输入数组。必须是一维的。</li><li id="0ff4" class="no np it lc b ld nx lg ny lj nz ln oa lr ob lv nt nu nv nw bi translated"><code class="fe nl nm nn mo b">q</code>:分位数的个数。十分位数为10，四分位数为4，等等。分位数的交替排列，例如[0，. 25，. 5，. 75，1。]对于四分位数。</li><li id="cb58" class="no np it lc b ld nx lg ny lj nz ln oa lr ob lv nt nu nv nw bi translated"><code class="fe nl nm nn mo b">labels</code>:指定退回箱子的标签。必须与生成的条柱长度相同。</li><li id="58af" class="no np it lc b ld nx lg ny lj nz ln oa lr ob lv nt nu nv nw bi translated"><code class="fe nl nm nn mo b">retbins</code> : (bool)是否退回(箱子，标签)。如果条块以标量形式给出，则非常有用。</li></ul><pre class="lx ly lz ma gt mn mo mp mq aw mr bi"><span id="f280" class="ms kj it mo b gy mt mu l mv mw">df['grade'], cut_bin = pd.qcut(df['score'], q = 3, labels = ['C', 'B', 'A'], retbins = True)<br/>df.head()</span></pre><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/b5bbc3ad1112f29733a520b113dd19dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:266/0*x4uUFrQoWjBuldWe"/></div><p class="mi mj gj gh gi mk ml bd b be z dk translated">作者图片</p></figure><p id="e53e" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">将<code class="fe nl nm nn mo b">retbins</code>作为<code class="fe nl nm nn mo b">True</code>传递会返回容器边界。</p><pre class="lx ly lz ma gt mn mo mp mq aw mr bi"><span id="8680" class="ms kj it mo b gy mt mu l mv mw">print (cut_bin)<br/>&gt;&gt; [  0.  36.  68. 100.]</span></pre><p id="6ae6" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">箱子的间隔如下:</p><ul class=""><li id="9fb7" class="no np it lc b ld my lg mz lj nq ln nr lr ns lv nt nu nv nw bi translated">丙:[0，36]</li><li id="f3bb" class="no np it lc b ld nx lg ny lj nz ln oa lr ob lv nt nu nv nw bi translated">乙:(36，68)</li><li id="bef4" class="no np it lc b ld nx lg ny lj nz ln oa lr ob lv nt nu nv nw bi translated">答:(68，100)</li></ul><p id="13cf" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">我们可以使用<code class="fe nl nm nn mo b">.value_counts()</code>检查每个年级组中有多少学生。理想情况下，每个箱子应该有大约333名学生。</p><pre class="lx ly lz ma gt mn mo mp mq aw mr bi"><span id="5224" class="ms kj it mo b gy mt mu l mv mw">df.grade.value_counts()</span></pre><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi of"><img src="../Images/67e5913b335b0d5e4961e8613f14f9e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/0*9h7SUJN8yyoePQ9_"/></div><p class="mi mj gj gh gi mk ml bd b be z dk translated">作者图片</p></figure><h1 id="8881" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">4.值计数</h1><p id="e429" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">虽然pandas <code class="fe nl nm nn mo b">.value_counts</code>通常用于计算一个系列中唯一值的数量，但它也可用于使用<code class="fe nl nm nn mo b">bins</code>参数[4]将值分组到半开的箱中。</p><pre class="lx ly lz ma gt mn mo mp mq aw mr bi"><span id="3b10" class="ms kj it mo b gy mt mu l mv mw">df['score'].value_counts(bins = 3, sort = False)</span></pre><p id="365d" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">默认情况下，<code class="fe nl nm nn mo b">.value_counts</code>按值的降序对返回的序列进行排序。将<code class="fe nl nm nn mo b">sort</code>设置为<code class="fe nl nm nn mo b">False</code>,按照索引的升序对系列进行排序。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi og"><img src="../Images/82ac9e329381d82b51323b39ccbdcb7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/0*TdDbFxLyRHHN5nhx"/></div><p class="mi mj gj gh gi mk ml bd b be z dk translated">作者图片</p></figure><p id="0bb8" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">序列索引是指每个bin的区间范围，其中方括号<code class="fe nl nm nn mo b">[</code>和圆括号<code class="fe nl nm nn mo b">)</code>分别表示边界值包含和不包含。返回系列的值指示每个箱中有多少条记录。</p><p id="f705" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">与<code class="fe nl nm nn mo b">.qcut</code>示例不同，每个箱中的记录数量不一定相同(大约)。<code class="fe nl nm nn mo b">.value_counts</code>不会将相同数量的记录分配到每个等级箱中，而是根据最高和最低分数将分数范围分成三个相等的部分。分数的最小值为0，最大值为100，因此3个部分的范围约为33.33。这也解释了为什么除了最低的左边界之外，仓的边界是33.33的倍数。</p><p id="f71b" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">我们还可以通过传入一个边界列表来定义bin的边界。</p><pre class="lx ly lz ma gt mn mo mp mq aw mr bi"><span id="1588" class="ms kj it mo b gy mt mu l mv mw">df['score'].value_counts(bins = [0,50,80,100], sort = False)</span></pre><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/08a35fddf87064770679650a16556f04.png" data-original-src="https://miro.medium.com/v2/resize:fit:410/0*LIyFbkAlj8hdVvQ7"/></div><p class="mi mj gj gh gi mk ml bd b be z dk translated">作者图片</p></figure><p id="90bc" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">这给出了与实施例1和2相同的结果。</p><h1 id="04dc" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">摘要</h1><p id="1e5c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在本文中，我们研究了如何使用<code class="fe nl nm nn mo b">.between</code>、<code class="fe nl nm nn mo b">.cut</code>、<code class="fe nl nm nn mo b">.qcut</code>和<code class="fe nl nm nn mo b">.value_counts</code>对连续值进行装箱。上面例子的Colab笔记本可以在<a class="ae mm" href="https://colab.research.google.com/drive/1yWTl2OzOnxG0jCdmeIN8nV1MoX3KQQ_1?usp=sharing" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="fbb0" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">参考</h1><p id="9e5e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">[1] <a class="ae mm" href="https://pandas.pydata.org/docs/reference/api/pandas.Series.between.html" rel="noopener ugc nofollow" target="_blank">熊猫之间</a></p><p id="c774" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">【2】<a class="ae mm" href="https://pandas.pydata.org/docs/reference/api/pandas.cut.html" rel="noopener ugc nofollow" target="_blank">熊猫切</a></p><p id="74f8" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">熊猫qcut </p><p id="fa5e" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">[4] <a class="ae mm" href="https://pandas.pydata.org/docs/reference/api/pandas.Series.value_counts.html" rel="noopener ugc nofollow" target="_blank">熊猫价值统计</a></p></div></div>    
</body>
</html>