<html>
<head>
<title>Need for speed: optimizing Facebook-Prophet fit method to run 20X faster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">速度需求:优化脸书-预言家拟合方法，运行速度提高20倍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/need-for-speed-optimizing-facebook-prophet-fit-method-to-run-20x-faster-166cd258f456#2022-05-10">https://towardsdatascience.com/need-for-speed-optimizing-facebook-prophet-fit-method-to-run-20x-faster-166cd258f456#2022-05-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="eb78" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">简化贝叶斯模型</h2></div><p id="675c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是优化Prophet内部机制系列文章的第二部分。<a class="ae lb" rel="noopener" target="_blank" href="/how-to-run-facebook-prophet-predict-x100-faster-cce0282ca77d">第一部分</a>不是理解这部分的先决条件，但推荐。</p><p id="1876" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自从我发布了第一部，先知套装的<a class="ae lb" href="https://pepy.tech/project/fbprophet" rel="noopener ugc nofollow" target="_blank">下载量</a>达到了3000万。这是最常见的时间序列预测软件包之一。尽管<a class="ae lb" href="https://www.microprediction.com/blog/prophet" rel="noopener ugc nofollow" target="_blank">不是最准确的</a>算法，但它开箱即用，效果相对较好，但仍允许微调其超参数，并添加额外的回归变量(即，可能与您的目标相关的任何数据，如油价、天气)，这使它成为许多用例的良好基线算法。</p><p id="0f1c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是它的速度仍然是一个问题。在第一部分中，我们看到预测可能需要整整一秒钟，但我们设法将这个时间减少到了15毫秒左右。尽管如此，根据变化点的数量和是否使用季节性，拟合一个项目需要50-100毫秒。这些运行时将Prophet的可扩展性限制在相对较小的数据集，因为每个项目都需要单独进行调整。但它不必如此；就像预测一样Prophet的拟合方法可以通过几个技巧进行显著优化。</p><p id="1d45" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但在我们继续之前，一个免责声明:在第一部分的结尾，我提供了可以取代预言家的不确定性预测的代码；在这篇文章中，我将展示如何优化拟合，但编写完整的功能代码，包括Prophet可以接受的所有参数，需要更多的工作。但是在这个过程中，我们将探索时间序列建模中的新思想，更好地理解幕后的预言家，甚至学习一点贝叶斯统计。</p><h2 id="2f23" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">先知入门</h2><p id="3851" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">Prophet模型是一个加法回归模型，有三个主要部分:</p><p id="3d80" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">趋势、季节性、节假日(我们可以添加其他回归变量，因为它们的功能是相同的)</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi ma"><img src="../Images/4ff30949c89b19f3ddd968d460505d90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZQ-bGnCyfYVUd5xOk0aI8Q.png"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">先知模型组件(图片由作者提供)</p></figure><p id="faab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将从关注趋势因素开始，随着我们对它的优化，我们将看到添加其他项并不是一个挑战。我们将局限于趋势是线性的情况。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mq"><img src="../Images/ad0c7fedfd090910a2d08772c7e8f7bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EkAsId4bxQY7SLQ6m0WAfQ.png"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">预言家用变点拟合线性趋势(图片由作者提供)</p></figure><p id="08de" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如上所述，Prophet为数据拟合了线性斜率，但为斜率创建了变点。当预测未来时，仅使用最终斜率，但变点的数量和大小会影响不确定性区间(见<a class="ae lb" rel="noopener" target="_blank" href="/how-to-run-facebook-prophet-predict-x100-faster-cce0282ca77d">第一部分</a>)。</p><p id="9228" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">变点数由用户设置(默认为25)，并且均匀分布在数据中，不包括最后的20%。先知没有“找到”变点；它创造了许多变化点，并让拟合过程使用正确的。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mr"><img src="../Images/35e7428c14c56e4e41f69de7a83a36e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6xj0kH7g4nsfGp1Uo2LC1Q.png"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">由预言者放置潜在的改变点(图片由作者提供)</p></figure><p id="9791" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上图中，垂直线代表由Prophet创建的变点，但是正如您所看到的，它们中的大多数不会导致斜率发生有意义的变化。Prophet使用贝叶斯模型来查找数据的最佳参数(截距、当前初始斜率和斜率之间的差值)。由于贝叶斯模型的作用，大多数斜率之间的差值为0。</p><h2 id="2be0" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">贝叶斯先验和正则化</h2><p id="ee3d" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">无需深究贝叶斯建模的美妙之处，这里有一些基本的东西:当使用贝叶斯方法估计参数时，你必须提供一个“先验”，它代表你在看到数据之前<em class="ms">相信</em>你的参数会在哪里。贝叶斯模型采用这个先验和数据，并返回“后验”——这些参数值最可能位于何处的更新信念。</p><p id="3c35" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于Prophet中的斜率增量，使用的先验是拉普拉斯，如下所示:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mt"><img src="../Images/153a3faca58e86df6d9a18369195f11f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JdKXoinxZfKpPFSYRFZJ9A.png"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">平均值为0和不同标准差的拉普拉斯分布(图片由作者提供)</p></figure><p id="878c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">换句话说，Prophet告诉模型，它应该假设两个连续斜率之间的差值可能在零左右，除非数据高度表明斜率发生变化，否则没有差值。Prophet创建了许多潜在的变化点，但在拟合它们的参数时，它确保通过使用以零为中心的先验，大多数变化点将被忽略。这个想法就像在损失函数中添加一个正则项——它促使优化器倾向于小值。</p><p id="d4fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">修改拉普拉斯的比例会改变其对结果的影响:较小的标准偏差意味着我们确定大多数增量必须接近零，而较大的标准偏差意味着非零值也是可能的，因此模型不会将增量推向零。同样，就像调整线性回归中正则化的强度一样。在Prophet中，您可以使用changepoint_prior_scale参数调整拉普拉斯先验标准差。如下所示，它可以显著地影响模型实际使用的变点的数量。</p><div class="mb mc md me gt ab cb"><figure class="mu mf mv mw mx my mz paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><img src="../Images/7c5a8b2adf4a120841782f010487a55f.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*3pAX1t1ELAmeTCzHTRokJQ.png"/></div></figure><figure class="mu mf na mw mx my mz paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><img src="../Images/c05c1d4437e3ef28335fa269f86f6317.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*DgX2nmKB-kwBUJh0I7CkzQ.png"/></div></figure><figure class="mu mf nb mw mx my mz paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><img src="../Images/3968f04791a384f5ba5821dec272f353.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*CMKmBmhJZixVpo68XGJ_ZA.png"/></div><p class="mm mn gj gh gi mo mp bd b be z dk nc di nd ne translated">拉普拉斯先验对变点拟合的影响(作者图片)</p></figure></div><p id="7ae8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Prophet使用pystan，一个贝叶斯建模库，来寻找最佳增量。但是贝叶斯建模需要非常长的时间来拟合(几十毫秒！).如果我们可以用简单的线性回归来代替它，我们可以在不牺牲性能的情况下减少运行时间，增加算法的可伸缩性。</p><h2 id="30eb" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">模拟坡度</h2><p id="2672" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">为了用线性回归模型代替pystan，我们需要找到一种使用特征来表示斜率和斜率变化的方法。</p><p id="ddbc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了模拟单个斜率，我们可以创建一个线性要素，其值为1，2，3，4，5，…，n，对应于手头的时间序列，其中n是时间序列的长度。如果我们在线性回归中使用这个特性，很容易想象它能完成什么。</p><div class="mb mc md me gt ab cb"><figure class="mu mf nf mw mx my mz paragraph-image"><img src="../Images/74ea9436af7a94461efa43cc57ad9dc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*J2G0iu5ym8Iyi9hLsB5exA.png"/></figure><figure class="mu mf ng mw mx my mz paragraph-image"><img src="../Images/2bc1ad0db97bc8d0dde6a954519e6191.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*vhPm2djn-Lu3UhQRO6ZOEA.png"/><p class="mm mn gj gh gi mo mp bd b be z dk nh di ni ne translated">作为线性回归特征的简单线性趋势(图片由作者提供)</p></figure></div><div class="ab cb"><figure class="mu mf nj mw mx my mz paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><img src="../Images/00552972449a4dab4d8e41bb27127d59.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*2wJRlFe1etPoAYECovzq_Q.png"/></div></figure><figure class="mu mf nk mw mx my mz paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><img src="../Images/96692fcfb9398930bb5070c3752049bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*nd0EltzZCvkAKYLDmbtV4w.png"/></div></figure><figure class="mu mf na mw mx my mz paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><img src="../Images/825472e3b911bd09badcced6bca3891e.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*t1w_boLuRYMgJODsMysJtA.png"/></div><p class="mm mn gj gh gi mo mp bd b be z dk nc di nd ne translated">仅使用线性趋势拟合的时间序列(作者图片)</p></figure></div><p id="96a7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">线性回归找到最佳系数——代表这个斜率应该有多陡；回归也可以产生一个负系数的向下斜率。我们可以很容易地将这个特性添加到其他表示季节性和额外回归量的特性中。</p><p id="56c9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但这是一个单一的斜坡。我们能创建一个特征来表示坡度变化吗？这个怎么样:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/146865f1d552295b3a17b1800e559478.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*LtRrDlPm7SlIsu7Y_biQHA.png"/></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">线性趋势变点特征(图片由作者提供)</p></figure><p id="7e4f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">新的特征值是0，0，0，0，…，0，1，2，3，4…这可能会让你想起Relu activation函数，但这里是作为一个特性，而不是作为一个函数。</p><p id="b066" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其系数表示变点前后斜率之间的差值。加上初始坡度特征，您可以创建此形状:</p><div class="mb mc md me gt ab cb"><figure class="mu mf nm mw mx my mz paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><img src="../Images/26f2eb8b52fc44451ad7c96466ece87c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*6LZISu7_yHkxnCS6H4EA5g.png"/></div></figure><figure class="mu mf nn mw mx my mz paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><img src="../Images/3a40db99c1efe7e274250557dd2f43ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*kUxoi1Xfxu_F4B4JjbLGWQ.png"/></div><p class="mm mn gj gh gi mo mp bd b be z dk no di np ne translated">寻找线性趋势和变点特征的系数的线性回归。每个特征乘以其系数(左)。他们的总和(右)。图片作者。</p></figure></div><p id="caf2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以创建任意数量的这些变点特征，允许回归在每个变点采用新的斜率。</p><div class="mb mc md me gt ab cb"><figure class="mu mf nq mw mx my mz paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><img src="../Images/f05a176cf0e4e0f68d7564c490f96043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*f781aQrK4MCDdT-ivvXqog.png"/></div></figure><figure class="mu mf nr mw mx my mz paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><img src="../Images/a7398b423dcfb4869e5e166fa71df07e.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*_MueXTpp9vOs-eMRmAyKwA.png"/></div><p class="mm mn gj gh gi mo mp bd b be z dk ns di nt ne translated">“梳状”特征-固定间隔的变点特征和基于特征的拟合(图片由作者提供)</p></figure></div><p id="c532" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们称之为“梳子”特征。我们可以通过训练Prophet并使用其训练的增量作为这些特征的系数来确认这些特征表示与Prophet相同的增量。</p><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="075d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">给了我们:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi nw"><img src="../Images/06dca9815f52a656034fdd3d32ccba53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MnOnBbDCE2xIClvp7VKrvA.png"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">将预言者的delta系数与梳状特征一起使用，得到与预言者相同的结果(图片由作者提供)</p></figure><p id="9f0f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">梳状特征乘以Prophet找到的增量，然后相加得到完全相同的预测。我们已经表明，我们可以使用“梳子”将Prophet转换成线性模型。</p><p id="a2f0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但这不是我们想要的——我们想要自己训练那些deltas系数，没有pystan。我们能使用线性回归模拟拉普拉斯先验吗？</p><h2 id="8b94" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">没有先知的训练先知</h2><p id="f620" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">回想一下，之前的要点是将系数推向0。这可能会让你想起L1正则化——惩罚系数的绝对值——这不是没有原因的:可以证明具有拉普拉斯先验的贝叶斯模型的最大后验(MAP)估计等价于具有L1正则化的线性回归(也称为Lasso回归)。拉普拉斯先验是同一概念的贝叶斯解释。贝叶斯主义者不考虑成本函数，而是考虑先验知识。</p><p id="acd3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以在梳状特征上训练回归，并得到与Prophet完全相同的结果。正如我提到的——标准差决定了模型将系数“推向”零的力度，就像L1阿尔法一样，但相反:标准差越大意味着正则化程度越低，而阿尔法值越大意味着正则化程度越高(系数越高，则“成本”或“损失”越大)。我们所需要的是将拉普拉斯先验的标准偏差(在changepoint_prior_scale中给出)转换成等效的L1α的公式。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/5ffeaa0b9efe6b9543c21aa7dca7a18c.png" data-original-src="https://miro.medium.com/v2/resize:fit:436/format:webp/1*WdVjbZjePzh54FmLYFxdWw.png"/></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">从b(拉普拉斯标准)到L1正则化参数的转换公式(图片由作者提供)</p></figure><p id="192b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中b是拉普拉斯的标准偏差，sigma是模型预测误差的标准偏差。</p><p id="939b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">等等，什么？在我们训练一个模型之前，如何使用误差的标准差？我们不能，但我们可以估计一下。让我们假设它是0.3，用这个转换运行套索:</p><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="nu nv l"/></div></figure><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi ma"><img src="../Images/d1d21bc38bf1b5c351c3adba425aa498.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oGlMjzgajrJF9ZgwlmB3Aw.png"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">Prophet和comb-Lasso训练与估计sigma的比较(图片由作者提供)</p></figure><p id="e506" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不坏，但不完全是；我们的阿尔法不符合拉普拉斯先验，因为我们的西格玛估计是错的。但现在我们有了一个预测，我们可以更好地估计误差，并重新计算正确的阿尔法。我们可以迭代地重复这个过程:创建一个模型，估计误差的标准偏差，并重新计算alpha。</p><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="60b7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过使用changepoint_prior_scale，我们将得到以下比较结果:</p><div class="mb mc md me gt ab cb"><figure class="mu mf nb mw mx my mz paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><img src="../Images/abf9fb00ff7e071bd1f0f9e74985ac7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*cLuE0J4mY947tICzI8IUtQ.png"/></div></figure><figure class="mu mf nb mw mx my mz paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><img src="../Images/1f70c656d77174e470858c4aaeed5677.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*cL2fF62b8h4UbLFaCQMd8Q.png"/></div></figure><figure class="mu mf nb mw mx my mz paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><img src="../Images/b324ed897b46ed4bc92fac65a6e0c3c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*VRnaLinj3tiVguDXs_HO3Q.png"/></div><p class="mm mn gj gh gi mo mp bd b be z dk nc di nd ne translated">Prophet和Lasso结果的比较，给定prior_scale中的更改(图片由作者提供)</p></figure></div><p id="341c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你所看到的，我们可以创建一个几乎相同的符合先知，使用梳子的特点和这种转换从拉普拉斯标准。您可以对先前的std使用不同的值进行实验，并看到Prophet和Lasso都会相应地更改其正则化并保持相似。但是训练几个套索难道不比训练一个先知慢吗？没有。</p><pre class="mb mc md me gt ny nz oa ob aw oc bi"><span id="1ca3" class="lc ld iq nz b gy od oe l of og">%%timeit<br/>m = Prophet(n_changepoints=15, changepoint_prior_scale=changepoint_prior_scale, growth='linear', uncertainty_samples=None, yearly_seasonality=False)<br/>m.fit(ds)</span></pre><p id="79e7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="mb mc md me gt ny nz oa ob aw oc bi"><span id="b282" class="lc ld iq nz b gy od oe l of og">60.2 ms ± 658 µs per loop</span></pre><p id="6089" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Prophet需要60毫秒来拟合时间序列。我们的迭代套索呢？</p><pre class="mb mc md me gt ny nz oa ob aw oc bi"><span id="e531" class="lc ld iq nz b gy od oe l of og">%%timeit<br/>lr = lasso_by_laplace_prior(feat, ds.y / scale, changepoint_prior_scale)</span></pre><p id="177c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="mb mc md me gt ny nz oa ob aw oc bi"><span id="9f5d" class="lc ld iq nz b gy od oe l of og">11.2 ms ± 239 µs per loop</span></pre><p id="91f8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使5-10个套索也比pystan的优化器快得多。事实上，如果你分析套索拟合，你会发现每次拟合花费的大部分时间都花在预处理X和y上(例如归一化它们)。目前，预处理发生在每次迭代中，但它可以放在循环之外，只发生一次，这将减少套索训练时间至少50%。</p><p id="c381" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们不是特别关心模仿Prophet，而只是想对时间序列建模，我们可以简单地使用comb特性，添加季节性特性和其他回归变量，并设置一个单一的alpha。毕竟，先验的alpha和标准差都是任意值(可以使用交叉验证进行优化)，为什么我们要关心找到精确匹配呢？我想不出任何原因，除了它给了我们一个学习机会，让我们了解预测、正则化和时间序列建模。所以，假设我们想要精确地模仿Prophet，但是更快，还缺少什么？</p><h2 id="1177" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated"><strong class="ak">特定特征正则化</strong></h2><p id="e7e5" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">如果你仔细观察上面的例子，你会注意到，与Prophet相比，Lasso的初始斜率没有那么陡。原因是Prophet仅将拉普拉斯先验(或L1正则化)置于斜率之间的变化<strong class="kh ir">δ</strong>上，而不是初始斜率上。我们的套索模型调整了所有的特征，包括初始坡度，所以它不能完美地模仿它。</p><p id="1d01" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们继续之前，我想指出先知的建模在某种意义上有点奇怪。举以下例子:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi oh"><img src="../Images/ca709f4f9dfdb984ca213f9c60162071.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_IZxIyUKOGouOS0nEkwgjA.png"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">完全随机的数据符合线性趋势(图片由作者提供)</p></figure><p id="ea45" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个时间序列的值是完全随机产生的，但是你可以发现一些斜率完全是由于偶然。但是如果我们想要预测这个随机序列的未来，使用斜率会导致过度拟合，而最好的预测就是这些值的平均值。先相信根本没有斜率是有意义的，只有在斜率非常明显的情况下才相信没有斜率，这不太可能随机发生。</p><p id="a7c8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Prophet实际上在初始斜率上放置了一个先验(在任何贝叶斯模型中，技术上你都必须这样做)——先验是高斯分布，而不是拉普拉斯分布。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi oi"><img src="../Images/5d2ae7942900a33898f42c22f828d013.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CHzGOfxvFC3EmioVoHpJkQ.png"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">std=1的拉普拉斯和高斯分布(图片由作者提供)</p></figure><p id="eb73" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">高斯曲线比拉普拉斯曲线更平坦，因此它对零的限制更少，Prophet用于高斯先验的标准差是5。由于数据的最大值为1，初始斜率通常低于5。换句话说，Prophet在技术上在初始斜率上放置了一个先验，但它是一个“无信息先验”——它几乎没有限制其系数的值。正如我们刚刚看到的，不调整初始斜率可能会有问题。</p><p id="8732" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是让我们继续效仿Prophet:如果L1正则化等价于拉普拉斯先验，那么什么等价于高斯先验？你猜对了——你<a class="ae lb" href="https://bjlkeng.github.io/posts/probabilistic-interpretation-of-regularization/" rel="noopener ugc nofollow" target="_blank">可以证明</a>L2(惩罚平方系数)将产生与高斯先验相同的地图。因此，我们需要对不同的特征使用不同的正则化参数来仿真Prophet。遗憾的是，sklearn不允许这样做-相同的正则化值必须应用于所有要素。我们将解决这个问题，但在此之前，让我们谈谈季节性和Prophet中的其他组件。</p><h2 id="050f" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated"><strong class="ak">季节性和额外回归量</strong></h2><p id="220e" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">Prophet中的季节性是使用正弦波特征建模的。Prophet自动创建一组不同频率的正弦波来代表每周、每月和每年的季节性。Pystan找到正弦波的最佳系数，使它们的总和最符合数据。作为傅立叶级数，这些正弦波非常灵活，适合大多数季节性形状。</p><div class="mb mc md me gt ab cb"><figure class="mu mf oj mw mx my mz paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><img src="../Images/aa04af0ff828f8708262edfea6132154.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*ItGelZIwntqtMP3eUg-eEw.png"/></div></figure><figure class="mu mf ok mw mx my mz paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><img src="../Images/08610ca4a4d61caf27c7242527844537.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*eIN4jJ61oQe84bAjwOr_mw.png"/></div><p class="mm mn gj gh gi mo mp bd b be z dk no di np ne translated">使用正弦波特征训练时间序列(图片由作者提供)</p></figure></div><p id="9a5c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们的先验/正规化呢？Prophet对季节性要素使用高斯先验，您可以使用Prophet中的seasonality _ prior _ scale参数设置其比例。默认的等级是10，这也意味着——几乎没有规律可言。节假日和额外回归量被视为相同-默认为宽高斯先验。</p><h2 id="41ba" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">把所有的放在一起</h2><p id="7cdb" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">我们基本上完成了，我们所需要的是编写一个带有自定义损失函数的线性回归，该函数可以针对不同的要素采用不同的正则化参数-L2用于季节性和初始坡度，L1用于梳状要素。正则化损失为:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi ma"><img src="../Images/7b2f9d7d7633b9a41aafd592cce0d1a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sQ7jb20B538AEQYVythQlg.png"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">成本函数的正则化部分(图片由作者提供)</p></figure><p id="3eb2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中:</p><ul class=""><li id="4309" class="ol om iq kh b ki kj kl km ko on ks oo kw op la oq or os ot bi translated">σ是误差的标准偏差</li><li id="bcd5" class="ol om iq kh b ki ou kl ov ko ow ks ox kw oy la oq or os ot bi translated">b是变点先验标度(变点的拉普拉斯先验标准)</li><li id="fdb7" class="ol om iq kh b ki ou kl ov ko ow ks ox kw oy la oq or os ot bi translated">s是季节性先验标度(季节性的高斯先验标准差)</li><li id="4807" class="ol om iq kh b ki ou kl ov ko ow ks ox kw oy la oq or os ot bi translated">β_fs是第一个斜率的系数(线性上升特征)</li><li id="db04" class="ol om iq kh b ki ou kl ov ko ow ks ox kw oy la oq or os ot bi translated">β_cp是梳状特征的系数</li><li id="1410" class="ol om iq kh b ki ou kl ov ko ow ks ox kw oy la oq or os ot bi translated">β_s是季节系数</li></ul><p id="81c3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正则化损失被加到平方误差损失上以获得代价函数。</p><p id="6ec0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们使用Adam等梯度下降优化器来最小化成本。我们可以将sigma估计合并到流程中，而不是像Lasso那样迭代运行这个模型:优化器每k次迭代重新估计sigma。</p><p id="439b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，梳状和季节性正弦特征仅取决于时间序列的长度。这意味着除非添加额外的回归变量，否则该模型中的所有特征都不是特定于目标的。我们可以为整个数据集创建一次X。</p><p id="448d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我创建了一个PyTorch实现，它可以采用L1和L2正则化参数或拉普拉斯和高斯先验的标准偏差<strong class="kh ir">每个特征</strong>。因为只优化20-30个参数不是PyTorch的强项，所以这种实现采用包含多个项目的整个数据集，并同时但单独地估计每个项目的系数，这对于每个项目来说要快得多。用于将该模型的结果与原始预言家的结果进行比较的代码和示例脚本可以在这里找到<a class="ae lb" href="https://github.com/orenmatar/fast-prophet/tree/main/faster_fit" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="740d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有几个适合的例子:</p><div class="mb mc md me gt ab cb"><figure class="mu mf oz mw mx my mz paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><img src="../Images/453a0c9475c023578d9b73e68f4ea178.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*U2z1bmbhp5FvuMhxf_a_aA.png"/></div></figure><figure class="mu mf pa mw mx my mz paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><img src="../Images/2419d06f92b090acc365b8dcc2ba833e.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*d2DDHLsKYG03Hd4GWvHWFg.png"/></div></figure><figure class="mu mf pb mw mx my mz paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><img src="../Images/bbb21d61424c751d656f6ded97cfce73.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*apbbjbr_Xv_wU8AY-_a4pw.png"/></div></figure></div><div class="ab cb"><figure class="mu mf pc mw mx my mz paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><img src="../Images/a52d14e40fcdfae3fc919ee2adb7b10a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*xLxqMxiCl_eTH0ljfXqdiA.png"/></div></figure><figure class="mu mf pd mw mx my mz paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><img src="../Images/08c18b027f7267cff244f2483f928092.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*JDYgnC9mtb8mZLjdGXpDzw.png"/></div><p class="mm mn gj gh gi mo mp bd b be z dk ns di nt ne translated">Prophet预测和PyTorch实现的拉普拉斯模拟特定特征正则化的比较(图片由作者提供)</p></figure></div><p id="45cc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该实现和原始Prophet之间的平均Pearson相关是0.995。由于实现中的微小差异(我不会深入讨论，但它们可以通过更多的工作来减少)，以及梯度下降优化器的随机特性，它仍然有点偏离。无论如何，没有理由认为新的实现不太准确。</p><p id="fbd9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的模型模拟了贝叶斯模型，使用简单的线性回归，每个特征正则化。但是Prophet的运行时间大约是每个项目60毫秒，PyTorch实现的运行时间大约是每个项目3毫秒。可以做更多的事情来减少运行时间，当损失函数收敛时提前停止，并学习速率调度程序，但这超出了我们的范围。</p><h2 id="0133" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated"><strong class="ak">结论和要点</strong></h2><p id="d22c" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">在本系列的第一部分优化预测代码中，我提供了可以轻松替换Prophet原始预测代码的代码。但是对于fit来说，情况要复杂得多:一个完整的实现需要能够添加额外的回归量和假日，并自动检测是否使用每周、每月和每年的季节性，这可以从Prophet复制过来。产品化之前还需要做更多的工作，但都是技术性的。如果有人经常使用Prophet承担这个项目是值得的。</p><p id="52b3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，这个练习的目的是什么？</p><p id="0218" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，“梳状”特征作为一种创造性的建模斜率变点的方法可以被其他时间序列模型借鉴。</p><p id="6149" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其次，我希望这种解决问题的形式，在研究Prophet的具体机制时，贝叶斯回归和正则化的贝叶斯解释是有启发性的，所学到的经验教训可以帮助解决其他问题。</p><p id="7152" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，这足以证明我的座右铭:任何模型，<em class="ms">可以</em>是线性回归<em class="ms">应该</em>是线性回归。线性回归是优雅的，令人难以置信的快，并且尽可能的容易解释。许多数据科学家经常急于使用更复杂的模型，忽略了线性回归的力量，而线性回归通常也能达到同样的效果。在这种情况下，只需要一点创造性的特性工程就可以将Prophet简化为线性回归模型，并显著提高其运行时间。</p><h2 id="a591" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">我们将何去何从？</h2><p id="b906" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">进一步研究的一个领域是斜率变化点的自动检测。一个好的斜率变化检测算法可以同时提高精度和运行时间，而不是创建大量的变点并依靠正则化来避免过度拟合。</p><p id="c93d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本系列的第一篇文章中，我们发现拟合过程需要60-100毫秒，而预测可能需要整整一秒钟；然后，我们将预测减少到大约10毫秒。进一步优化预测方法没有多大意义，因为大部分时间都花在了拟合上。</p><p id="2527" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在fit减少到大约3毫秒，它再次成为消耗大部分运行时间的预测方法。在本系列的第3部分中，我们将回到我们在第1部分中开发的矢量化预测方法，看看我们如何在几微秒内实现类似的结果，完成fit &amp; predict的1000倍运行时改进。</p></div></div>    
</body>
</html>