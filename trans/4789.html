<html>
<head>
<title>Unit Testing for Data Science with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python进行数据科学的单元测试</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/unit-testing-for-data-science-with-python-16dfdcfe3232#2022-10-25">https://towardsdatascience.com/unit-testing-for-data-science-with-python-16dfdcfe3232#2022-10-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a940" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用nose2和参数化测试尽早发现代价高昂的错误</h2></div><p id="6e4f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你在工作中部署了一个新的机器学习模型。你终于可以享受周末了，你心想。你一点也不知道，一场迫在眉睫的错误风暴即将摧毁你的模型，毁掉你的周末。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/7c791e5b12ad7ff9c9725797ffaad471.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jYc6cj6yQuAEhtPv"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">不不不。请现在不要。图片作者。</p></figure><p id="50aa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为什么会这样？错误检查不足。数据科学家被教导执行数据探索和建模，但我们没有被教导执行单元测试，尤其是在边缘情况下。</p><p id="d58b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我将介绍一个我发现在日常工作中非常有用的技巧:使用nose2进行单元测试。特别是，我会分享</p><ul class=""><li id="e98a" class="lr ls iq kh b ki kj kl km ko lt ks lu kw lv la lw lx ly lz bi translated">什么是单元测试？</li><li id="e37e" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">为什么数据科学家应该执行单元测试？</li><li id="5ca2" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">什么是nose2？</li><li id="d494" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">如何执行简单的单元测试？</li><li id="15a8" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">什么是参数化单元测试？</li><li id="0b47" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">如何做一个简单的参数化测试？</li><li id="6659" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">如何进行检查错误的参数化测试？</li><li id="efaa" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">如何用pandas dataframe做参数化测试？</li></ul><h1 id="0a3c" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">什么是单元测试？</h1><p id="2a83" class="pw-post-body-paragraph kf kg iq kh b ki mx jr kk kl my ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">单元测试是数据科学家能够掌握的最强大的技能之一，它是编程的灵魂。这是一个测试，检查代码的单个组件，通常作为一个功能模块化，并确保它按预期执行</p><p id="fe0e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">理想情况下，我们希望我们的测试很小。越小越好。这是因为更小的测试不仅从实践的角度来看更有效——因为测试更小的单元将使您的测试运行得更快——而且从概念上来说，它将为您提供粒度代码如何运行的更详细的视图。</p><h1 id="f845" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">为什么要执行单元测试？</h1><p id="903b" class="pw-post-body-paragraph kf kg iq kh b ki mx jr kk kl my ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">有很多！这里有一个快速运行通过。</p><ul class=""><li id="d97b" class="lr ls iq kh b ki kj kl km ko lt ks lu kw lv la lw lx ly lz bi translated">您可以<strong class="kh ir">在开发周期中轻松找到bugs】由于功能/类是模块化/隔离的，因此每次只测试代码的一部分，这导致了效率的提高、停机时间的减少和成本的降低，否则成本会因整个设计过程停滞而增加。</strong></li><li id="ca2e" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">当你单独测试软件的每个组件时，你可以<strong class="kh ir">更容易地重构代码</strong>。早期发现的问题可以被消灭在萌芽状态。</li><li id="788e" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">做得好的话，你可以把它们作为一种<strong class="kh ir">形式的文档</strong>。</li></ul><p id="cf24" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看一个使用unittest的简单例子，unittest是从版本2.1开始内置到标准python库中的。</p><p id="7082" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建测试用例是通过子类化<a class="ae nc" href="https://docs.python.org/3/library/unittest.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> unittest来完成的。测试用例</strong> </a>。下面是一个例子。</p><pre class="lc ld le lf gt nd ne nf ng aw nh bi"><span id="b737" class="ni mg iq ne b gy nj nk l nl nm">import unittest</span><span id="b171" class="ni mg iq ne b gy nn nk l nl nm">def add(x):<br/>  return x + 1</span><span id="7ea8" class="ni mg iq ne b gy nn nk l nl nm">class MyTest(unittest.TestCase):<br/>  def test(self):<br/>  self.assertEqual(add(3), 4)</span></pre><p id="6a56" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您还可以在这里找到其他assert方法。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi no"><img src="../Images/717aa1f0a3b900e48a3241172b35f3ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zY8OQrKGqXCdfh1d"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated"><a class="ae nc" href="https://docs.python.org/3/library/unittest.html" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="c4b3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然unittest非常适合简单的测试，但在处理更复杂的代码时，它可能会很快变得有点麻烦。因此，开发了<a class="ae nc" href="https://docs.nose2.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> nose2 </a>来扩展unittest以简化测试过程。</p><h1 id="b5fd" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">什么是nose2？</h1><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi np"><img src="../Images/ed16308c65dd39477bf94d8623f18cca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v_oylOnNdpgAIW7A"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">由<a class="ae nc" href="https://unsplash.com/@braydona?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布雷登·安德森</a>在<a class="ae nc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="6ee9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与unittest相比，Nose2提供了更好的插件API，并简化了内部接口和过程。Nose2模块内置了很多插件，这些插件都是默认加载的。一些默认加载的<a class="ae nc" href="https://docs.nose2.io/en/latest/plugins.html" rel="noopener ugc nofollow" target="_blank">主要插件</a>有助于测试的参数化，将测试设备组织成层，捕获日志消息，提供测试覆盖报告，等等。</p><p id="a5fc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是python中不同的单元测试框架。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nq"><img src="../Images/b0583a98d62dadbc50c1e01153c0e1af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_BbJOgEYk1BeFSY4"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">现有的单元测试框架。图片作者。</p></figure><h1 id="a897" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">如何执行简单的单元测试？</h1><p id="d19f" class="pw-post-body-paragraph kf kg iq kh b ki mx jr kk kl my ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">在我们开始之前，您需要在您的系统中安装Nose2框架</p><pre class="lc ld le lf gt nd ne nf ng aw nh bi"><span id="61e2" class="ni mg iq ne b gy nj nk l nl nm">pip install nose2==0.9.2<br/>pip install parameterized</span></pre><p id="0e36" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将从一个简单的例子开始。考虑这样的情况，我们有一个考试的四个分数的列表。分数应该在0到100之间。</p><pre class="lc ld le lf gt nd ne nf ng aw nh bi"><span id="d9b5" class="ni mg iq ne b gy nj nk l nl nm">+-------+<br/>| score |<br/>+-------+<br/>|    44 |<br/>|    64 |<br/>|    -5 |<br/>|   101 |<br/>+-------+</span></pre><p id="6679" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们编写一个测试来帮助我们捕捉不符合标准的两个值(-5和101)，并告诉python运行测试。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="ba02" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经创建了test.py，我们必须运行它。为此，您可以打开终端，并运行以下命令。(请将“/directory/to/your/test.py”替换为存储test.py的目录。)</p><pre class="lc ld le lf gt nd ne nf ng aw nh bi"><span id="58ef" class="ni mg iq ne b gy nj nk l nl nm">python3 /directory/to/your/test.py</span></pre><p id="71b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行该命令后，您应该会看到以下内容。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nt"><img src="../Images/88aae2a3096bb5c2a6e84ac466b90f22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WkQ0EYZEARnUehZgtoP2VA.png"/></div></div></figure><p id="d55e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不出所料，我们的测试失败了！万岁。</p><h1 id="b54c" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">什么是参数化单元测试？</h1><p id="fbdd" class="pw-post-body-paragraph kf kg iq kh b ki mx jr kk kl my ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">开发人员倾向于为每个案例编写一个测试。然后将一些相关案例分组到“套件”中。考虑下面的情况。</p><pre class="lc ld le lf gt nd ne nf ng aw nh bi"><span id="37ad" class="ni mg iq ne b gy nj nk l nl nm">class CodeTestSuite(TestCase):<br/>    def test_for_int_input(self):<br/>        assert correct_output()</span><span id="7726" class="ni mg iq ne b gy nn nk l nl nm">    def test_for_float_input(self):<br/>        assert correct_output()</span><span id="c2b0" class="ni mg iq ne b gy nn nk l nl nm">    def test_for_string_input(self):<br/>       assert correct_input() </span></pre><p id="8634" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可想而知，这些案件大部分都是息息相关的。这可能会导致去冗余、大型测试代码库，以及在进行变更时需要偿还的潜在技术债务。</p><p id="dc73" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">进入参数化测试</strong>，生成一个<em class="nu">多参数</em>测试，方便测试。您可以通过测试套件中方法的装饰器来传递参数。</p><p id="e392" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的一些代码是建立在Richard D Jones的“你应该做参数化测试”之上的。一定要去看看！</p><h1 id="059e" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">带装饰器的参数化测试</h1><p id="33ae" class="pw-post-body-paragraph kf kg iq kh b ki mx jr kk kl my ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">假设我们想要测试这个简单的函数“compute”。</p><pre class="lc ld le lf gt nd ne nf ng aw nh bi"><span id="b042" class="ni mg iq ne b gy nj nk l nl nm">def compute(a, b):<br/>     return (a + b) / (a * b)</span></pre><p id="6a8f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下面的例子中，我们使用compute函数执行两个参数化测试。特别是:</p><ul class=""><li id="df2b" class="lr ls iq kh b ki kj kl km ko lt ks lu kw lv la lw lx ly lz bi translated">test_int测试compute(a=0，b=1)的输出是否为1。如果是，测试通过。</li><li id="a0f6" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">test_float测试compute(a=1，b=1)的输出是否为1。如果是，测试通过。</li></ul><p id="a4b5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码片段如下。</p><pre class="lc ld le lf gt nd ne nf ng aw nh bi"><span id="d341" class="ni mg iq ne b gy nj nk l nl nm">class TestSuite(unittest.TestCase):<br/>     @parameterized.expand([<br/>         # each tuple contains <br/>         # (name     , a  , b  , expected_output<br/>         ("test_int" , 1  , 1  , 2),<br/>         ("test_float", 1. , 1. , 2.)<br/>     ])</span><span id="4a8c" class="ni mg iq ne b gy nn nk l nl nm">def test_compute(self, name, a, b, expected_output):<br/>     assert compute(a, b) == expected_output</span></pre><p id="302a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意“@ parameterized.expand”装饰器是如何接受元组列表的。每个元组都是一个测试用例，其输出将被改变。</p><p id="ae62" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完整的代码块如下。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="873d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以使用以下命令运行上述测试。所有的测试都应该通过。</p><pre class="lc ld le lf gt nd ne nf ng aw nh bi"><span id="60e3" class="ni mg iq ne b gy nj nk l nl nm">python3 /directory/to/your/test_param.py</span></pre><h1 id="5a18" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">如何进行检查错误的参数化测试？</h1><p id="1e02" class="pw-post-body-paragraph kf kg iq kh b ki mx jr kk kl my ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">在某些情况下，我们还希望执行单元测试，以确保错误被正确地提出。为此，我们可以指定要引发的错误。</p><p id="ab23" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码片段如下。</p><pre class="lc ld le lf gt nd ne nf ng aw nh bi"><span id="a3e0" class="ni mg iq ne b gy nj nk l nl nm">def test_compute(self, name, a, b, expected_output, expected_error=None):<br/>     # If no error is expected from the test case,<br/>     # check if the actual output matches the expected output<br/>     if expected_error is None:<br/>          assert compute(a, b) == expected_output</span><span id="03d6" class="ni mg iq ne b gy nn nk l nl nm">     # If an error is expected from the test case,<br/>     # check if the actual error matches the expected error<br/>     else:<br/>          with self.assertRaises(expected_error):<br/>              compute(a, b)</span></pre><p id="9d13" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的示例“test_divisionbyzero”测试compute(0，0)是否正确地产生了ZeroDivisionError。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="a2e4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以使用以下命令运行上述测试。所有的测试都应该通过。</p><pre class="lc ld le lf gt nd ne nf ng aw nh bi"><span id="a22e" class="ni mg iq ne b gy nj nk l nl nm">python3 /directory/to/your/test_params_with_error.py</span></pre><h1 id="edc0" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">如何用pandas dataframe做参数化测试？</h1><p id="8b42" class="pw-post-body-paragraph kf kg iq kh b ki mx jr kk kl my ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">如果你想为你的测试传入一个熊猫数据帧呢？没问题。</p><p id="6009" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用下面的代码片段，其中load_test_case()是一个接收数据的函数。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="3a84" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以使用以下命令运行上述测试。所有的测试都应该通过。</p><pre class="lc ld le lf gt nd ne nf ng aw nh bi"><span id="2555" class="ni mg iq ne b gy nj nk l nl nm">python3 /directory/to/your/test_params_with_dataframe.py</span></pre><h1 id="37c0" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">单元测试是无压力周末的关键</h1><p id="4c9f" class="pw-post-body-paragraph kf kg iq kh b ki mx jr kk kl my ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">单元测试模块可以由nose2模块补充，以创建强大的单元测试。特别是，参数化测试提供了一种组织多个单元测试的便捷方式。</p><p id="68f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将在接下来的一周分享更多的单元测试策略。敬请期待！</p><p id="67af" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想了解更多关于数据分析、数据科学和机器学习的知识，可以考虑在Medium和LinkedIn上关注我！</p></div></div>    
</body>
</html>