<html>
<head>
<title>Efficiently iterating over rows in a Pandas DataFrame</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高效地迭代熊猫数据帧中的行</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/efficiently-iterating-over-rows-in-a-pandas-dataframe-7dd5f9992c01#2022-03-21">https://towardsdatascience.com/efficiently-iterating-over-rows-in-a-pandas-dataframe-7dd5f9992c01#2022-03-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="06cf" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">不再使用 iterrows 和 itertuples</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0ce5d0c945b97109430714bae5f89f1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lpFMIOWlWt6qFaSrsLnNbg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由作者，表情符号由<a class="ae kv" href="https://openmoji.org/" rel="noopener ugc nofollow" target="_blank">open moji</a>(<a class="ae kv" href="https://creativecommons.org/licenses/by-sa/4.0/#" rel="noopener ugc nofollow" target="_blank">CC BY-SA 4.0</a>)。</p></figure><p id="29c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我开始机器学习时，我遵循这些准则，并通过组合我的数据集中的多个列来创建自己的特征。这一切都很好，但我做这件事的方式<strong class="ky ir">非常低效</strong>。我必须等几分钟才能完成最基本的操作。</p><p id="6aee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的问题很简单:我不知道在 Pandas 中迭代行的最快方法。</p><p id="2d7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我经常在网上看到有人使用我曾经用过的技术。不优雅但是数据不多也还行。然而，如果您处理超过 10k 行的数据，这很快就会成为一个明显的性能问题。</p><p id="b525" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将向您介绍在 Pandas DataFrame 中迭代行的<strong class="ky ir">最佳方法，不需要额外的代码。这不仅仅是关于性能:这也是关于了解在引擎盖下发生了什么，以成为更好的数据科学家。</strong></p><p id="b2f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在 Pandas 中导入一个数据集。在这种情况下，我选择了我开始时所做的:是时候修正我过去的错误了！🩹</p><p id="d216" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以用下面的<a class="ae kv" href="https://colab.research.google.com/drive/1v9v4j1MnklaCd9eFcuGnB5x_5FoINmRe?usp=sharing" rel="noopener ugc nofollow" target="_blank"> Google Colab 笔记本</a>运行代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="7843" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该数据集有 22k 行和 43 列，包含分类值和数值。每行描述两台计算机之间的连接。</p><p id="4058" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们想要创建一个新特性:连接中的<strong class="ky ir">总字节数</strong>。我们只要总结两个现有的特征:<code class="fe lu lv lw lx b">src_bytes</code>和<code class="fe lu lv lw lx b">dst_bytes</code>。让我们看看计算这个新特性的不同方法。</p><h1 id="0666" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">❌❌ 1.Iterrows</h1><p id="43ae" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">根据<a class="ae kv" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.iterrows.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>，<code class="fe lu lv lw lx b">iterrows()</code>迭代“熊猫数据帧的行作为(索引，序列)对”。它将每一行转换为一个系列对象，这导致了两个问题:</p><ol class=""><li id="b48e" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated">它可以<strong class="ky ir">改变你数据的类型</strong>(dtypes)；</li><li id="69ed" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">转换<strong class="ky ir">大大降低了性能</strong>。</li></ol><p id="bcf9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出于这些原因，不恰当的<code class="fe lu lv lw lx b">iterrows()</code>是实际迭代行的最差方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><pre class="kg kh ki kj gt nj lx nk nl aw nm bi"><span id="3bd9" class="nn lz iq lx b gy no np l nq nr">10 loops, best of 5: <strong class="lx ir">1.07 s</strong> per loop</span></pre><p id="f4f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们看看稍微好一点的技术…</p><h1 id="f027" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">❌ 2.For 循环 with。loc 或。iloc(快 3 倍)</h1><p id="13db" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">这是我开始时经常做的:一个循环的<strong class="ky ir">基础，通过索引选择行(用<code class="fe lu lv lw lx b">.loc</code>或<code class="fe lu lv lw lx b">.iloc</code>)。</strong></p><p id="a6d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么不好？因为数据帧不是为此目的而设计的。与前面的方法一样，行被转换成 Pandas 系列对象，这会降低性能。</p><p id="a947" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有趣的是，<code class="fe lu lv lw lx b">.iloc</code>比<code class="fe lu lv lw lx b">.loc</code>更快。这很有意义，因为 Python 不必检查用户定义的标签，直接查看行在内存中的存储位置。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><pre class="kg kh ki kj gt nj lx nk nl aw nm bi"><span id="c121" class="nn lz iq lx b gy no np l nq nr">10 loops, best of 5: <strong class="lx ir">600 ms</strong> per loop</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><pre class="kg kh ki kj gt nj lx nk nl aw nm bi"><span id="4109" class="nn lz iq lx b gy no np l nq nr">10 loops, best of 5: <strong class="lx ir">377 ms</strong> per loop</span></pre><p id="9cb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">甚至这种用<code class="fe lu lv lw lx b">.iloc</code>的基本 for 循环也比第一种方法快 3 倍！</p><h1 id="949a" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">❌ 3.应用(速度提高 4 倍)</h1><p id="e7e0" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated"><code class="fe lu lv lw lx b">apply()</code>方法是另一种流行的行迭代方法。它创建了易于理解的代码，但这是有代价的:性能几乎和前面的 for 循环一样差。</p><p id="4359" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么我强烈建议您为了这个特定的目的<strong class="ky ir">避免这个函数</strong>(对于其他应用程序也可以)。</p><p id="4de9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我使用<code class="fe lu lv lw lx b">to_list()</code>方法将 DataFrame 转换成一个列表，以获得相同的结果。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><pre class="kg kh ki kj gt nj lx nk nl aw nm bi"><span id="39d1" class="nn lz iq lx b gy no np l nq nr">10 loops, best of 5: <strong class="lx ir">282 ms</strong> per loop</span></pre><p id="90df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个<code class="fe lu lv lw lx b">apply()</code>方法是一个伪装的 for 循环，这就是为什么性能没有提高那么多的原因:它只比第一种方法快了<strong class="ky ir"> 4 倍</strong>。</p><h1 id="4f75" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">❌ 4.Itertuples(快 10 倍)</h1><p id="fcca" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">如果你知道<code class="fe lu lv lw lx b">iterrows()</code>，你大概也知道<code class="fe lu lv lw lx b">itertuples()</code>。根据官方文档，它“遍历数据帧的行，命名为值对”。实际上就是把<strong class="ky ir">行转换成元组</strong>，元组<strong class="ky ir">是比熊猫系列</strong>轻得多的对象。</p><p id="e7bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么<code class="fe lu lv lw lx b">itertuples()</code>是<code class="fe lu lv lw lx b">iterrows()</code>的更好版本。这一次，我们需要访问带有<strong class="ky ir">属性</strong>(或索引)的值。如果您想用一个<strong class="ky ir">字符串</strong>来访问它们(例如，如果字符串中有一个空格)，您可以使用<code class="fe lu lv lw lx b">getattr()</code>函数来代替。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><pre class="kg kh ki kj gt nj lx nk nl aw nm bi"><span id="8c53" class="nn lz iq lx b gy no np l nq nr">10 loops, best of 5: <strong class="lx ir">99.3 ms</strong> per loop</span></pre><p id="6274" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这开始变得更好了:现在<strong class="ky ir">比<code class="fe lu lv lw lx b">iterrows()</code>快 10 倍。</strong></p><h1 id="b758" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">❌ 5.列表理解(快 200 倍)</h1><p id="ed37" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">列表理解是作为一行程序迭代列表的一种奇特方式。</p><p id="eb22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，<code class="fe lu lv lw lx b">[print(i) for i in range(10)]</code>打印从 0 到 9 的数字<strong class="ky ir">，而没有任何显式 For 循环</strong>。我说“显式”是因为如果我们看字节码，Python 实际上将它作为 for 循环处理。</p><p id="4660" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么为什么会更快呢？很简单，因为在这个版本中我们不调用<code class="fe lu lv lw lx b">.append()</code>方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><pre class="kg kh ki kj gt nj lx nk nl aw nm bi"><span id="ba44" class="nn lz iq lx b gy no np l nq nr">100 loops, best of 5: <strong class="lx ir">5.54 ms</strong> per loop</span></pre><p id="b475" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">的确，这种技术比第一种技术快 200 倍！但是我们仍然可以做得更好。</p><h1 id="ede5" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">✅ 6.熊猫矢量化(速度提高 1500 倍)</h1><p id="d504" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">到目前为止，所有使用的技术只是简单地将单个值相加。与其将单个值相加，为什么不<strong class="ky ir">将它们组合成向量</strong>来求和呢？两个数字或两个向量相加的差别对于 CPU 来说并不重要，这应该会加快速度。</p><p id="5cf2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最重要的是，Pandas 可以使用所有可用的 CPU 内核<strong class="ky ir">并行处理系列对象</strong>！</p><p id="c760" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">语法也是最简单的:这个解决方案非常直观。在引擎盖下，Pandas 使用连续的内存块，通过优化的 C 代码对我们的数据进行矢量化处理。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><pre class="kg kh ki kj gt nj lx nk nl aw nm bi"><span id="121f" class="nn lz iq lx b gy no np l nq nr">1000 loops, best of 5: <strong class="lx ir">734 µs</strong> per loop</span></pre><p id="0f5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这段代码比 T2 快 1500 倍，而且写起来更简单。</p><h1 id="a13b" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">✅✅ 7.NumPy 矢量化(速度提高 1900 倍)</h1><p id="d998" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">NumPy 被设计用来处理科学计算。它比 Pandas 方法有更少的开销，因为行和数据帧都变成了<code class="fe lu lv lw lx b">np.array</code>。它依赖于与熊猫矢量化相同的优化。</p><p id="301b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有两种<strong class="ky ir">方法</strong>将一个系列转换成<code class="fe lu lv lw lx b">np.array</code>:使用<code class="fe lu lv lw lx b">.values</code>或<code class="fe lu lv lw lx b">.to_numpy()</code>。前者已经被废弃多年，这就是我们在这个例子中使用<code class="fe lu lv lw lx b">.to_numpy()</code>的原因。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><pre class="kg kh ki kj gt nj lx nk nl aw nm bi"><span id="b028" class="nn lz iq lx b gy no np l nq nr">1000 loops, best of 5: <strong class="lx ir">575 µs</strong> per loop</span></pre><p id="2123" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们用比第一个竞争对手快 1900 倍的技术找到了我们的赢家！让我们把东西包起来。</p><h1 id="d275" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">🏆结论</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/59654af42d3aeb5d5391fd19870ae34b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7y3ZhqXG1fsLwjL773eZNw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">数据集中的行数会极大地影响某些技术的性能(图片由作者提供)。</p></figure><p id="4548" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要像我一样:如果您需要迭代数据帧中的行，那么<strong class="ky ir">矢量化</strong>是一个不错的选择！你可以在这个地址找到重现实验<a class="ae kv" href="https://mlabonne.github.io/blog/" rel="noopener ugc nofollow" target="_blank">的代码。矢量化不会更难阅读，也不会花费更长的时间来编写，而且性能提升令人难以置信。</a></p><p id="630e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这不仅仅是关于性能:理解每个方法是如何工作的帮助我<strong class="ky ir">写出更好的代码</strong>。性能提升总是基于相同的技术:将数据转换成向量和矩阵，以利用并行处理。唉，这通常是以牺牲可读性为代价的。但不一定非要这样。</p><p id="fe89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对行进行迭代<strong class="ky ir">只是一个例子</strong>，但它表明，有时，你可以拥有蛋糕并吃掉它。🎂</p><p id="0187" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你喜欢这篇文章，<strong class="ky ir">在 Twitter 上关注我</strong><a class="ae kv" href="https://twitter.com/maximelabonne" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">@ maxime labanne</strong></a><strong class="ky ir"/>了解更多关于数据科学和机器学习的技巧！</p></div></div>    
</body>
</html>