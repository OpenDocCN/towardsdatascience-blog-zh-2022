<html>
<head>
<title>REST APIs on Industrial PLCs Part 2: System Health Monitoring</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">工业PLC上的REST APIs第2部分:系统健康监控</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/rest-apis-on-industrial-plcs-part-2-system-health-monitoring-1ad470f7f896#2022-09-28">https://towardsdatascience.com/rest-apis-on-industrial-plcs-part-2-system-health-monitoring-1ad470f7f896#2022-09-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="800e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">监控系统中每个设备的运行状况</h2></div><h2 id="919c" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">介绍</h2><p id="2f78" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">API对于卸载计算和运行在给定编程语言中不容易完成的进程非常有用。在本系列的第一部分<a class="ae lx" rel="noopener" target="_blank" href="/rest-apis-on-industrial-plcs-eb17e8c4d51b">工业PLC上的REST APIs】中，我们实现了一个简单的API，它从SQL数据库中添加和检索条目。输入数据库的数据用于训练机器学习模型，以检测连接到控制器的伺服驱动器中的异常。</a></p><p id="758c" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">在这个例子中，我们将为收集的数据运行一个基本的训练循环，并对伺服系统进行推理，以查看它们是否表现异常。为此，我们将使用具有未标记数据的自动编码器网络，并测量重建损失以确定当前伺服状态的分类。</p><h2 id="10f6" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">动机</h2><p id="8291" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">通过实施异常检测模型，我们可以监控配置中每个伺服系统的健康状况。肉眼和耳朵可能不明显的东西将被模型捕捉到，用户可以相应地采取行动。及早发现伺服系统的问题，让我们有时间安排预防性维护，这大大减少了停机时间，并有助于防止因伺服系统故障而造成的任何损坏。</p><h2 id="4d0a" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">背景</h2><p id="e149" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">自动编码器网络将用于识别伺服状态中的异常。自动编码器网络是合适的，因为它将从输入数据中滤除噪声，并利用可能存在的非线性关系提供更精确的重建。由于将使用未标记的数据，自动编码器网络的重建损失将用于分类异常。具有高于设定阈值的高重建损失的数据将被视为异常，而具有低于设定阈值的低重建损失的数据将被视为非异常。</p><p id="c188" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">3D打印是伺服系统的一种流行用途；以高速度和加速度运行打印机会加快打印机的吞吐量，也会导致更高的动态负载。打印机可能几乎100%的时间都在不停地运行，因此以潜在的方式监控伺服系统的状态是很有用的。</p><h2 id="3aed" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">配置</h2><p id="cbd2" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">在这个例子中，我们将创建一个<a class="ae lx" href="https://www.yaskawa.com/products/motion/machine-controllers/software-tools/yaskawa-compass" rel="noopener ugc nofollow" target="_blank"> Compass </a>插件，它为数据采样和推断发出API请求。虽然API请求可以直接从PLC发出，但它们将从运行Compass的PC发出，以省去将请求路由到适当外部网络的麻烦。发出API请求的网络架构如下所示:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi md"><img src="../Images/60c2915683127fff1d87fe93d363463f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WignHsZztboKbs0uvpqYaA.jpeg"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">图1:带有PLC的REST API网络架构，图片由作者提供</p></figure><p id="f687" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">图上的箭头是以太网/IP连接。在本例中，MPiec控制器将与中间的可选DNS服务器进行对话。运行Compass的PC将自动处理DNS路由，并将请求发送到适当的服务器。</p><p id="808b" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">REST API服务器托管在AWS ec2实例上，具有以下可用端点:</p><pre class="me mf mg mh gt mt mu mv mw aw mx bi"><span id="0bc6" class="ki kj it mu b gy my mz l na nb">/api/v2/store_data #store a row(s) of data values for training</span><span id="5079" class="ki kj it mu b gy nc mz l na nb">/api/v2/inference #run inference on row(s)</span><span id="0039" class="ki kj it mu b gy nc mz l na nb">/api/v2/check #check on model availability</span></pre><h2 id="7c60" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">模型</h2><p id="497d" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">来自<a class="ae lx" href="https://github.com/yzhao062/pyod" rel="noopener ugc nofollow" target="_blank"> PyOD GitHub </a>库的自动编码器模型将用于检测伺服驱动器上的异常状态。自动编码器的网络结构如下所示:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/665ad2f814e509349cfa8851f0425d8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*wKE69-fX180Q_gkzYzGbwg.png"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">图2:自动编码器神经网络结构，图像由Chervinskii⁴</p></figure><p id="1238" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">与我的前一篇文章⁵<a class="ae lx" rel="noopener" target="_blank" href="/anomaly-detection-on-servo-drives-f711f3e6022f">中使用的可以直接在PLC上运行的异常检测模型不同，AutoEncoder计算量很大，必须在一个支持矢量化计算的不同设备上运行。如果你有兴趣了解更多关于自动编码器网络的信息，可以考虑阅读这篇</a><a class="ae lx" href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.703.5244&amp;rep=rep1&amp;type=pdf" rel="noopener ugc nofollow" target="_blank">⁵.的论文通过使用API来运行推理，我们显著降低了PLC的cpu负载并避免了性能问题。</a></p><h2 id="d466" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">数据</h2><p id="a128" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">来自伺服系统的所有可用的和相关的数据将用于这个例子。一些关键变量包括:</p><ul class=""><li id="9c74" class="ne nf it lg b lh ly lk lz kr ng kv nh kz ni lw nj nk nl nm bi translated">反馈位置、速度、加速度和扭矩</li><li id="6518" class="ne nf it lg b lh nn lk no kr np kv nq kz nr lw nj nk nl nm bi translated">指令位置、速度、加速度和扭矩</li></ul><p id="a2bf" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">最终，减少采样变量的数量，以减少读取变量的cpu负载，而不会对自动编码器模型产生重大影响，这将是最佳选择。在本例中，将从以下列表中读取所有与运动相关的轴参数:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/b316360c3a1610082672c39b692cd21a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*193ycjrbdzEe12NPm0Ykiw.png"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">图3:变量采样的轴参数列表，作者图片</p></figure><h2 id="1f18" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">插件布局</h2><p id="860f" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">该插件在启用时，将自动从伺服系统中批量采样数据，并使用<code class="fe nt nu nv mu b">/api/v2/store_data</code>端点将数据行发送给API以供将来训练。我们将启用插件，并运行几个g代码文件几个小时，这样就可以采样一组不同的数据。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nw"><img src="../Images/82471bbda2a01fdc952a82a76dc8cfae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sHK3CRbSjp3RJ4tU09HmiA.png"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">图Compass中的插件，作者图片</p></figure><p id="d6ad" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">一旦收集了足够多的数据，就会调用<code class="fe nt nu nv mu b">/api/v2/check</code>端点。端点被编程为:</p><ol class=""><li id="fc01" class="ne nf it lg b lh ly lk lz kr ng kv nh kz ni lw nx nk nl nm bi translated">检查自动编码器型号的状态/可用性</li><li id="a579" class="ne nf it lg b lh nn lk no kr np kv nq kz nr lw nx nk nl nm bi translated">如果存在足够的数据，则启动培训课程</li></ol><p id="6814" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">第一次调用<code class="fe nt nu nv mu b">/api/v2/check</code>端点将返回以下内容:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/8e25a759093d73366837e370037924df.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*Dw73zHdkSOmho4GzRN4yHw.png"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">图5 :/ API/v2/check端点的API响应，作者图片</p></figure><p id="a2d9" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">一旦自动编码器完成训练并可用于推断，端点<code class="fe nt nu nv mu b">/api/v2/check</code>将返回以下内容:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/5b15e8af6eeb561ccbddee606e9cdcc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*AZFwo7-DXUi6OGJKjPQ54g.png"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">图6:具有可用模型的/api/v2/check端点的API响应，图片由作者提供</p></figure><h2 id="a64e" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">插件客户端代码</h2><p id="a040" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">Compass插件通过POST方法发出HTTP请求来与API通信。该请求包含给定端点的JSON格式的相关数据。在推断过程中，一行或多行被发送到API，服务器将返回每一行的异常状态。该请求是用c#完成的，代码如下:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi oa"><img src="../Images/c991bd7f501d16ae3ffbb3fc0ed86856.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lxSfwepQwZ-XN2gWIZDUPQ.png"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">图7:c#中的API请求，作者图片</p></figure><p id="6e6d" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">图7的复制粘贴友好格式:</p><pre class="me mf mg mh gt mt mu mv mw aw mx bi"><span id="a796" class="ki kj it mu b gy my mz l na nb">private async Task&lt;InferenceResponse&gt; InferenceRequestAPI(Dictionary&lt;string,string&gt; data)</span><span id="4d85" class="ki kj it mu b gy nc mz l na nb">{</span><span id="fde4" class="ki kj it mu b gy nc mz l na nb">HttpClient client = new HttpClient();</span><span id="7ca1" class="ki kj it mu b gy nc mz l na nb">client.BaseAddress = new Uri(URL);</span><span id="f1ae" class="ki kj it mu b gy nc mz l na nb">client.DefaultRequestHeaders.Accept.Add(</span><span id="a9b3" class="ki kj it mu b gy nc mz l na nb">new MediaTypeWithQualityHeaderValue("application/json"));</span><span id="7260" class="ki kj it mu b gy nc mz l na nb">var jsonData = JsonConvert.SerializeObject(data);</span><span id="7cf9" class="ki kj it mu b gy nc mz l na nb">var contentData = new StringContent(jsonData, Encoding.UTF8, "application/json");</span><span id="07d6" class="ki kj it mu b gy nc mz l na nb">var response = await client.PostAsync(urlParameters, contentData);</span><span id="7679" class="ki kj it mu b gy nc mz l na nb">string contents = await response.Content.ReadAsStringAsync();</span><span id="4991" class="ki kj it mu b gy nc mz l na nb">client.Dispose();</span><span id="93d3" class="ki kj it mu b gy nc mz l na nb">InferenceResponse responseJSON = JsonConvert.DeserializeObject&lt;InferenceResponse&gt;(contents);</span><span id="15e7" class="ki kj it mu b gy nc mz l na nb">return responseJSON;</span><span id="4332" class="ki kj it mu b gy nc mz l na nb">}</span></pre><p id="4712" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">服务器将以下列格式返回响应:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/e14662b4614b5f67bce5fc7467f232c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*nbOBKPgykVFo2Ddm0tv5Ag.png"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">图8:来自服务器的自动编码器推理响应，图片由作者提供</p></figure><p id="e394" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">在上面图8的例子中，一行数据用于推断。该响应有三个关键响应项:</p><ol class=""><li id="1709" class="ne nf it lg b lh ly lk lz kr ng kv nh kz ni lw nx nk nl nm bi translated"><code class="fe nt nu nv mu b">class</code> —推理的分类(如果异常则为真，如果没有检测到异常则为假)</li><li id="63d2" class="ne nf it lg b lh nn lk no kr np kv nq kz nr lw nx nk nl nm bi translated"><code class="fe nt nu nv mu b">loss</code> —自动编码器模型返回的重建损失，用于推理</li><li id="0578" class="ne nf it lg b lh nn lk no kr np kv nq kz nr lw nx nk nl nm bi translated"><code class="fe nt nu nv mu b">time</code>——推论的时间</li></ol><p id="338f" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">分类输出基于一个<code class="fe nt nu nv mu b">threshold</code>值，该值使用重建损失将自动编码器的输出二进制化。在这个例子中，服务器的训练系统基于最初给出的训练数据预先选择阈值。服务器预先选择值0.4作为截止阈值，这意味着任何重建损失高于0.4的推断都将被视为异常。</p><p id="6794" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">对于生产应用，用户应仔细选择阈值。此外，应实施后处理算法来跟踪肯定分类的频率和幅度，以便单个肯定分类不会触发任何操作。</p><p id="0085" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">监控异常频率的一个简单有效的方法是在不同的时间间隔跟踪3个SMA(简单移动平均线)并相互比较。例如，使用一组5/30/120分钟的SMA，我们可以根据120分钟的SMA建立一个“标称”值，并将其与5分钟和30分钟的SMA进行比较。当较低的间隔SMAs超过标称值以上3个标准差时，我们可以考虑向用户发送需要检查3D打印机的通知。</p><h2 id="b933" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">结论</h2><p id="1890" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">出于各种原因，REST APIs与PLC的结合非常有用，包括能够轻松集成高性能机器学习模型来监控设备的健康状况。通过利用API，几乎任何东西都可以与PLC及其连接的设备集成。</p><p id="b48e" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">如果你对现成的指南针插件感兴趣，<a class="ae lx" href="https://www.linkedin.com/in/peter-lebiedzinski-4012a8123/" rel="noopener ugc nofollow" target="_blank">联系我</a>。</p><h2 id="94d2" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">来源</h2><p id="36c0" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">[1] Lebiedzinski，P. (2022年5月27日)。工业PLC上的REST APIs。中等。2022年9月26日检索，来自<a class="ae lx" rel="noopener" target="_blank" href="/rest-apis-on-industrial-plcs-eb17e8c4d51b">https://towards data science . com/a-single-number-metric-for-evaluating-object-detection-models-c 97 F4 a 98616d</a>。</p><p id="42f2" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">[2] <em class="oc">安川指南针</em>。安川。(未注明)。2022年9月26日检索，来自<a class="ae lx" href="https://www.yaskawa.com/products/motion/machine-controllers/software-tools/yaskawa-compass" rel="noopener ugc nofollow" target="_blank">https://www . yaskawa . com/products/motion/machine-controllers/software-tools/yaskawa-compass</a></p><p id="9d96" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">[3]赵，杨，纳斯鲁拉，李，2019 .PyOD:用于可伸缩异常检测的Python工具箱。机器学习研究杂志(JMLR)，20(96)，第1–7页。</p><p id="3daf" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">[4]作者切尔文斯基—自己的作品，CC BY-SA 4.0，<a class="ae lx" href="https://commons.wikimedia.org/w/index.php?curid=45555552" rel="noopener ugc nofollow" target="_blank">https://commons.wikimedia.org/w/index.php?curid=45555552</a></p><p id="7ca7" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">[5] Lebiedzinski，P. (2021年11月12日)。<em class="oc">伺服驱动器上的异常检测。</em>中等。2022年5月12日检索，来自<a class="ae lx" rel="noopener" target="_blank" href="/anomaly-detection-on-servo-drives-f711f3e6022f">https://towards data science . com/a-single-number-metric-for-evaluating-object-detection-models-c97f 4a 98616d</a>。</p><p id="8715" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">[6]乐，2015 .深度学习教程第2部分:自动编码器，卷积神经网络和递归神经网络。<em class="oc">谷歌大脑，谷歌公司</em></p></div></div>    
</body>
</html>