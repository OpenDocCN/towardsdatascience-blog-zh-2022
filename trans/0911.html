<html>
<head>
<title>Reshaping a DataFrame with Pandas stack() and unstack()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Pandas stack()和 unstack()重塑数据帧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/reshaping-a-dataframe-with-pandas-stack-and-unstack-925dc9ce1289#2022-03-11">https://towardsdatascience.com/reshaping-a-dataframe-with-pandas-stack-and-unstack-925dc9ce1289#2022-03-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="93f2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有效使用 Pandas stack()和 unstack()的 7 个技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e1bbda7a70d163a66b349aae3f85ab22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L8kOGS-8MwfdOsX6haPYPA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@pinewatt?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">派恩瓦特</a>在<a class="ae ky" href="https://unsplash.com/s/photos/frame?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><blockquote class="kz la lb"><p id="9f21" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><em class="it">当您处理包含具有某种序列的变量的数据集时，例如时间序列数据，通常需要进行整形。</em></p><p id="ef8c" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><em class="it">来源于弗吉尼亚大学研究数据服务部[1] </em></p></blockquote><p id="8a5e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">Pandas 提供了各种用于重塑数据帧的内置方法。其中，<code class="fe mc md me mf b">stack()</code>和<code class="fe mc md me mf b">unstack()</code>是重组<strong class="lf iu">列</strong>和<strong class="lf iu">行</strong>(也称为<strong class="lf iu">索引</strong>)最常用的两种方法。</p><ul class=""><li id="f5f8" class="mg mh it lf b lg lh lj lk lz mi ma mj mb mk ly ml mm mn mo bi translated"><code class="fe mc md me mf b">stack()</code>:从列到行堆叠规定的层次。</li><li id="d066" class="mg mh it lf b lg mp lj mq lz mr ma ms mb mt ly ml mm mn mo bi translated"><code class="fe mc md me mf b">unstack()</code>:从行到列拆分规定的级别。来自堆栈的逆操作。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/7395ed504fddd7087e3dacf19d607d32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DYDOif_qBEgtWfFKUDSf0Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">熊猫栈()和解散栈()(图片由作者提供)</p></figure><p id="67ba" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><code class="fe mc md me mf b">stack()</code>和<code class="fe mc md me mf b">unstack()</code>看起来使用起来相当简单，但是仍然有一些技巧你应该知道来加速你的数据分析。在本文中，您将学习熊猫应对以下用例的技巧:</p><ol class=""><li id="46ab" class="mg mh it lf b lg lh lj lk lz mi ma mj mb mk ly mv mm mn mo bi translated">个别能级</li><li id="a114" class="mg mh it lf b lg mp lj mq lz mr ma ms mb mt ly mv mm mn mo bi translated">多层次:简单案例</li><li id="95b4" class="mg mh it lf b lg mp lj mq lz mr ma ms mb mt ly mv mm mn mo bi translated">多个级别:缺少值</li><li id="67bd" class="mg mh it lf b lg mp lj mq lz mr ma ms mb mt ly mv mm mn mo bi translated">多个级别:指定要堆叠的级别</li><li id="e379" class="mg mh it lf b lg mp lj mq lz mr ma ms mb mt ly mv mm mn mo bi translated">多个级别:删除缺少的值</li><li id="b948" class="mg mh it lf b lg mp lj mq lz mr ma ms mb mt ly mv mm mn mo bi translated">拆分:简单情况</li><li id="df3c" class="mg mh it lf b lg mp lj mq lz mr ma ms mb mt ly mv mm mn mo bi translated">拆分:更多级别</li></ol><blockquote class="mw"><p id="9426" class="mx my it bd mz na nb nc nd ne nf ly dk translated">源代码请查看<a class="ae ky" href="https://github.com/BindiChen/machine-learning/blob/main/data-analysis/067-pandas-stack/pandas-stack-unstack.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>。更多教程可从<a class="ae ky" href="https://github.com/BindiChen/machine-learning" rel="noopener ugc nofollow" target="_blank"> Github Repo </a>获取。</p></blockquote></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="48fe" class="nn no it bd np nq nr ns nt nu nv nw nx jz ny ka nz kc oa kd ob kf oc kg od oe bi translated">1.个别能级</h1><p id="a04a" class="pw-post-body-paragraph lc ld it lf b lg of ju li lj og jx ll lz oh lo lp ma oi ls lt mb oj lw lx ly im bi translated">最简单的<code class="fe mc md me mf b">stack()</code>可以应用在具有单级列的数据帧上。它只是将标签从<strong class="lf iu">列</strong>堆叠到<strong class="lf iu">行</strong>并输出一系列。</p><pre class="kj kk kl km gt ok mf ol om aw on bi"><span id="0d83" class="oo no it mf b gy op oq l or os">df_single_level = pd.DataFrame(<br/>    [['Mostly cloudy', 10], ['Sunny', 12]],<br/>    index=['London', 'Oxford'],<br/>    columns=['Weather', 'Wind']<br/>)</span><span id="3558" class="oo no it mf b gy ot oq l or os">df_single_level<strong class="mf iu">.stack()</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/26e375aae0fb39f3c6aed5fc7ab9a8ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PTALtqeKYaMNmO7g8yWj1w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数据帧上最简单的堆栈()并输出一系列数据(图片由作者提供)</p></figure><h1 id="4079" class="nn no it bd np nq ov ns nt nu ow nw nx jz ox ka nz kc oy kd ob kf oz kg od oe bi translated">2.多层次:简单案例</h1><p id="b30e" class="pw-post-body-paragraph lc ld it lf b lg of ju li lj og jx ll lz oh lo lp ma oi ls lt mb oj lw lx ly im bi translated">通常，我们会在具有多级列的数据帧上使用<code class="fe mc md me mf b">stack()</code>。让我们为演示创建一个数据帧。创建具有多级列的 DataFrame 有多种方法，最简单的方法之一是创建一个 MultiIndex 对象<code class="fe mc md me mf b">MultiIndex.from_tuples()</code>，并将结果传递给<code class="fe mc md me mf b">pd.DataFrame()</code>中的<code class="fe mc md me mf b">columns</code>参数:</p><pre class="kj kk kl km gt ok mf ol om aw on bi"><span id="a49c" class="oo no it mf b gy op oq l or os">multi_col_1 = pd.<strong class="mf iu">MultiIndex</strong>.from_tuples(<br/>    [('Wind', 'mph'), ('Wind', 'm/s')]<br/>)</span><span id="281e" class="oo no it mf b gy ot oq l or os">df_multi_level_1 = pd.DataFrame(<br/>    [[13, 5.5], [19, 8.5]],<br/>    index=['London', 'Oxford'],<br/>    <strong class="mf iu">columns=multi_col_1</strong><br/>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/3ec7247af1fb8d572e715b8008a9ec4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*9zp_4m33Nn96CIkh23rpRA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">多索引数据框</p></figure><p id="98dc" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">通过调用<code class="fe mc md me mf b">stack()</code>，它将获取列级<code class="fe mc md me mf b">(mph, m/s)</code>并将其堆叠到行轴上。</p><pre class="kj kk kl km gt ok mf ol om aw on bi"><span id="bd21" class="oo no it mf b gy op oq l or os">df_multi_level_1.stack()</span><span id="1d87" class="oo no it mf b gy ot oq l or os"># Same as <br/>df_multi_level_1.stack(<strong class="mf iu">level=-1</strong>)<br/>df_multi_level_1.stack(<strong class="mf iu">-1</strong>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/0347dc74ef2878fcabeb50b88296ec9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EKdycb7E_7qG1YTVT-XXQQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">熊猫在多索引数据框架上堆叠()</p></figure><p id="0f59" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">在幕后，它根据参数<code class="fe mc md me mf b">level</code>运行操作。参数<code class="fe mc md me mf b">level</code>默认为<code class="fe mc md me mf b">-1</code>，它获取最内层，并将其从列轴堆叠到行轴上。</p><p id="d5f1" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">如果您想了解更多关于 MultiIndex 的内容，可以查看这篇文章:</p><div class="pc pd gp gr pe pf"><a rel="noopener follow" target="_blank" href="/accessing-data-in-a-multiindex-dataframe-in-pandas-569e8767201d"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">在熊猫的多索引数据框架中访问数据</h2><div class="pm l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">towardsdatascience.com</p></div></div><div class="pn l"><div class="po l pp pq pr pn ps ks pf"/></div></div></a></div><h1 id="65a8" class="nn no it bd np nq ov ns nt nu ow nw nx jz ox ka nz kc oy kd ob kf oz kg od oe bi translated">3.多个级别:缺少值</h1><p id="bbd2" class="pw-post-body-paragraph lc ld it lf b lg of ju li lj og jx ll lz oh lo lp ma oi ls lt mb oj lw lx ly im bi translated">当堆叠具有多级列的数据帧时，缺少值是很常见的。让我们创建另一个数据帧示例:</p><pre class="kj kk kl km gt ok mf ol om aw on bi"><span id="8329" class="oo no it mf b gy op oq l or os">multi_col_2 = pd.MultiIndex.from_tuples(<br/>    <strong class="mf iu">[('Wind', 'mph'), ('Temperature', '°C')]</strong><br/>)</span><span id="7f27" class="oo no it mf b gy ot oq l or os">df_multi_level_2 = pd.DataFrame(<br/>    [[13, 8], [19, 6]],<br/>    index=['London', 'Oxford'],<br/>    columns=multi_col_2<br/>)</span><span id="4b41" class="oo no it mf b gy ot oq l or os">df_multi_level_2.stack()</span></pre><p id="797a" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">与第一级中具有相同值<code class="fe mc md me mf b">'Wind'</code>的前一示例<code class="fe mc md me mf b">multi_col_1</code>不同，<code class="fe mc md me mf b">multi_col_2</code>具有 2 个不同的值<code class="fe mc md me mf b">'Wind'</code>和<code class="fe mc md me mf b">'Temperature'</code>。现在，我们得到缺失值，因为堆叠的数据帧比原始数据帧有更多的值，缺失值用<code class="fe mc md me mf b">NaN</code>填充。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pt"><img src="../Images/3631e92860167e17a839ddd16dde745a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h_6pr_RG1PeUtnlPIocJ1A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">熊猫栈()(图片由作者提供)</p></figure><h1 id="c35a" class="nn no it bd np nq ov ns nt nu ow nw nx jz ox ka nz kc oy kd ob kf oz kg od oe bi translated">4.多个级别:指定要堆叠的级别</h1><p id="d0a7" class="pw-post-body-paragraph lc ld it lf b lg of ju li lj og jx ll lz oh lo lp ma oi ls lt mb oj lw lx ly im bi translated"><code class="fe mc md me mf b">stack()</code>中的第一个参数是<code class="fe mc md me mf b">level</code>，它控制堆叠哪一层。让我们创建一个具有两个不同级别的多指数:</p><pre class="kj kk kl km gt ok mf ol om aw on bi"><span id="6e6a" class="oo no it mf b gy op oq l or os">multi_col_2 = pd.MultiIndex.from_tuples(<br/>    [('Wind', 'mph'), ('Temperature', '°C')]<br/>)</span><span id="b006" class="oo no it mf b gy ot oq l or os"># <strong class="mf iu">Level 0</strong><br/>multi_col_2.<strong class="mf iu">get_level_values(0)<br/></strong># Index(<strong class="mf iu">['Wind', 'Temperature']</strong>, dtype='object')</span><span id="23eb" class="oo no it mf b gy ot oq l or os"># <strong class="mf iu">Level 1</strong><br/>multi_col_2.<strong class="mf iu">get_level_values(1)<br/></strong># Index(<strong class="mf iu">['mph', '°C']</strong>, dtype='object')</span></pre><p id="d354" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">我们可以传递一个数字来指定要堆叠的级别。要指定要堆叠的多个级别，我们可以传递一个列表:</p><pre class="kj kk kl km gt ok mf ol om aw on bi"><span id="a525" class="oo no it mf b gy op oq l or os">df_multi_level_2.stack(<strong class="mf iu">0</strong>)</span><span id="8c96" class="oo no it mf b gy ot oq l or os">df_multi_level_2.stack(<strong class="mf iu">[0, 1]</strong>)</span><span id="a940" class="oo no it mf b gy ot oq l or os">df_multi_level_2.stack(<strong class="mf iu">[1, 0]</strong>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pu"><img src="../Images/685934723e4f8177b904fe06df11e097.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3PEmD7RF3uXV00jc2hwAgA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">熊猫栈()(图片由作者提供)</p></figure><h1 id="4fe3" class="nn no it bd np nq ov ns nt nu ow nw nx jz ox ka nz kc oy kd ob kf oz kg od oe bi translated">5.多个级别:删除缺少的值</h1><p id="93c3" class="pw-post-body-paragraph lc ld it lf b lg of ju li lj og jx ll lz oh lo lp ma oi ls lt mb oj lw lx ly im bi translated">默认情况下，当调用<code class="fe mc md me mf b">stack()</code>时，所有值缺失的行将被删除。这种行为可以通过将<code class="fe mc md me mf b">dropna</code>设置为<code class="fe mc md me mf b">False</code>来控制:</p><pre class="kj kk kl km gt ok mf ol om aw on bi"><span id="53ef" class="oo no it mf b gy op oq l or os">df_multi_level_3 = pd.DataFrame(<br/>    [[<strong class="mf iu">None</strong>, 10], [11, 7.0]],<br/>    index=['London', 'Oxford'],<br/>    columns=multi_col_2<br/>)</span><span id="fa86" class="oo no it mf b gy ot oq l or os">df_multi_level_3.stack()</span><span id="3a1f" class="oo no it mf b gy ot oq l or os">df_multi_level_3.stack(<strong class="mf iu">dropna=False</strong>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pv"><img src="../Images/1228bb90ee66ab5e6105ab5b889b2886.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a-K5wM69DRO0vfbhc74D-Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用 Pandas stack()删除丢失的值(图片由作者提供)</p></figure><h1 id="1922" class="nn no it bd np nq ov ns nt nu ow nw nx jz ox ka nz kc oy kd ob kf oz kg od oe bi translated">6.拆分:简单情况</h1><p id="e692" class="pw-post-body-paragraph lc ld it lf b lg of ju li lj og jx ll lz oh lo lp ma oi ls lt mb oj lw lx ly im bi translated">类似地，Pandas <code class="fe mc md me mf b">unstack()</code>也支持参数<code class="fe mc md me mf b">level</code>,它默认为<code class="fe mc md me mf b">-1</code>,后者将对最内部的索引应用操作。</p><pre class="kj kk kl km gt ok mf ol om aw on bi"><span id="469f" class="oo no it mf b gy op oq l or os"><strong class="mf iu">index</strong> = pd.MultiIndex.from_tuples([<br/>  ('Oxford', 'Temperature'), <br/>  ('Oxford', 'Wind'),<br/>  ('London', 'Temperature'), <br/>  ('London', 'Wind')<br/>])</span><span id="d1c6" class="oo no it mf b gy ot oq l or os">s = pd.Series([1,2,3,4], <strong class="mf iu">index=index</strong>)</span></pre><p id="e214" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">通过对具有 MultiIndex 的系列调用<code class="fe mc md me mf b">unstack()</code>，它会将最内部的索引拆分到一列上。要指定要拆垛的级别，我们可以传递级别编号:</p><pre class="kj kk kl km gt ok mf ol om aw on bi"><span id="6e88" class="oo no it mf b gy op oq l or os">s.unstack()<br/># It's equivalent to<br/>s.unstack(<strong class="mf iu">level=-1</strong>)</span><span id="0e6e" class="oo no it mf b gy ot oq l or os"># Unstack a specific level<br/>s.unstack(<strong class="mf iu">level=0</strong>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pw"><img src="../Images/1e6f1f84457998f049617ee1e118491c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fYIQ02RiQtxKZd5pQ-Garg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">熊猫解散()(图片由作者提供)</p></figure><h1 id="5d9f" class="nn no it bd np nq ov ns nt nu ow nw nx jz ox ka nz kc oy kd ob kf oz kg od oe bi translated">7.拆分:更多级别</h1><p id="0638" class="pw-post-body-paragraph lc ld it lf b lg of ju li lj og jx ll lz oh lo lp ma oi ls lt mb oj lw lx ly im bi translated">通常，我们会在更多的层次上使用<code class="fe mc md me mf b">unstack()</code>。让我们来看一个包含 3 个级别的示例:</p><pre class="kj kk kl km gt ok mf ol om aw on bi"><span id="6c4f" class="oo no it mf b gy op oq l or os">index = pd.MultiIndex.from_tuples([<br/>  ('Oxford', 'Weather', '01-01-2022'), <br/>  ('Oxford', 'Temperature', '01-01-2022'), <br/>  ('Oxford', 'Weather', '02-01-2022'),<br/>  ('Oxford', 'Temperature', '02-01-2022'),<br/>  ('London', 'Weather', '01-01-2022'), <br/>  ('London', 'Temperature', '01-01-2022'),<br/>  ('London', 'Weather', '02-01-2022'),<br/>  ('London', 'Temperature', '02-01-2022'),<br/>])</span><span id="ce3d" class="oo no it mf b gy ot oq l or os">s = pd.Series(<br/>  ['Sunny', 10, 'Shower', 7, 'Shower', 5, 'Sunny', 8], <br/>  <strong class="mf iu">index=index</strong><br/>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi px"><img src="../Images/84728387bf12dc8ff7d8f277cf1df4e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*VIQtWg1u5T9O6GEM2UsTfg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">两级多指标</p></figure><p id="5e30" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">通过调用<code class="fe mc md me mf b">unstack()</code>，它将最里面的索引拆分到列上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi py"><img src="../Images/c462f8ce3269594fa8c32379cda8bb0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rBzh4YQeRwhAqPbOuZCPMg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">熊猫解散堆叠()</p></figure><p id="1e66" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">例如，我们可以使用<a class="ae ky" rel="noopener" target="_blank" href="/using-pandas-method-chaining-to-improve-code-readability-d8517c5626ac">方法链接</a>来运行另一个<code class="fe mc md me mf b">unstack()</code>或者传递一个列表</p><pre class="kj kk kl km gt ok mf ol om aw on bi"><span id="bf21" class="oo no it mf b gy op oq l or os"># Method chaining<br/>df<strong class="mf iu">.unstack().unstack()</strong><br/>df<strong class="mf iu">.unstack().unstack().unstack()</strong></span><span id="18b4" class="oo no it mf b gy ot oq l or os"># The equivalent<br/>df<strong class="mf iu">.unstack([2,1])</strong><br/>df<strong class="mf iu">.unstack([2,1,0])</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pz"><img src="../Images/646085d6013847c23677e3b22c38233e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y86edbyjpv3UCiKNCiU_fw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">熊猫解散堆叠()示例</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qa"><img src="../Images/5e513473ea79ece9cbfa6ff00b09f7a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j7QsJYGW5wA7ZY92AVMkUQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">熊猫解散()示例(图片由作者提供)</p></figure><p id="882a" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">如果您想了解更多关于方法链接的知识，可以查看这篇文章:</p><div class="pc pd gp gr pe pf"><a rel="noopener follow" target="_blank" href="/using-pandas-method-chaining-to-improve-code-readability-d8517c5626ac"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">使用 Pandas 方法链接提高代码可读性</h2><div class="qb l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">熊猫方法链接的最佳实践教程</h3></div><div class="pm l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">towardsdatascience.com</p></div></div><div class="pn l"><div class="qc l pp pq pr pn ps ks pf"/></div></div></a></div><h1 id="2c27" class="nn no it bd np nq ov ns nt nu ow nw nx jz ox ka nz kc oy kd ob kf oz kg od oe bi translated">结论</h1><p id="b124" class="pw-post-body-paragraph lc ld it lf b lg of ju li lj og jx ll lz oh lo lp ma oi ls lt mb oj lw lx ly im bi translated">在本文中，我们介绍了使用熊猫<code class="fe mc md me mf b">stack()</code>和<code class="fe mc md me mf b">unstack()</code>重塑数据帧的 7 个用例。这些方法本身使用起来非常简单，是数据预处理中操作数据的最受欢迎的方法之一。</p><p id="e981" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">感谢阅读。请查看<a class="ae ky" href="https://github.com/BindiChen/machine-learning/blob/main/data-analysis/067-pandas-stack/pandas-stack-unstack.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>获取源代码，如果您对机器学习的实用方面感兴趣，请继续关注。更多教程可从<a class="ae ky" href="https://github.com/BindiChen/machine-learning" rel="noopener ugc nofollow" target="_blank"> Github Repo </a>获得。</p><h1 id="6e4d" class="nn no it bd np nq ov ns nt nu ow nw nx jz ox ka nz kc oy kd ob kf oz kg od oe bi translated">参考</h1><ul class=""><li id="ea74" class="mg mh it lf b lg of lj og lz qd ma qe mb qf ly ml mm mn mo bi translated">[1]弗吉尼亚大学:<a class="ae ky" href="https://data.library.virginia.edu/stata-basics-reshape-data/" rel="noopener ugc nofollow" target="_blank">研究数据服务+科学</a></li></ul></div></div>    
</body>
</html>