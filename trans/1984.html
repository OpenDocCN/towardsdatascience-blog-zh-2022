<html>
<head>
<title>Part 12: Matrix Profiles For Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第12部分:机器学习的矩阵轮廓</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/part-12-matrix-profiles-for-machine-learning-2dfd98d7ff3f#2022-05-05">https://towardsdatascience.com/part-12-matrix-profiles-for-machine-learning-2dfd98d7ff3f#2022-05-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5b1d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在STUMPY发现Shapelet</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ad4e754cf13b8202ebaef75b7c7eeaca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bM2bc5qNAji5uyQBQ6pBEQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由<a class="ae kv" href="https://unsplash.com/@ninjason" rel="noopener ugc nofollow" target="_blank"> Jason Leung </a>提供)</p></figure><h1 id="5364" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">整体大于部分之和</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/76d64324c08fc58f1be4388db1892cb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/0*-Ljh5aAhePRv_Z1h.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="5c82" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated"><a class="ae kv" href="https://github.com/TDAmeritrade/stumpy" rel="noopener ugc nofollow" target="_blank"> STUMPY是一个强大且可扩展的Python库，用于现代时间序列分析</a>，在其核心，有效地计算出一种叫做<em class="ml">矩阵轮廓</em>的东西。这个多部分系列的目标是解释什么是matrix profile，以及如何开始利用<a class="ae kv" href="https://stumpy.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> STUMPY </a>完成所有现代时间序列数据挖掘任务！</p><p id="e465" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated"><em class="ml">注:这些教程最初出现在</em> <a class="ae kv" href="https://stumpy.readthedocs.io/en/latest/tutorials.html" rel="noopener ugc nofollow" target="_blank"> <em class="ml"> STUMPY文档</em> </a> <em class="ml">中。</em></p><p id="d32a" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">第1部分:<a class="ae kv" rel="noopener" target="_blank" href="/the-matrix-profile-e4a679269692">矩阵轮廓图</a> <br/>第2部分:<a class="ae kv" rel="noopener" target="_blank" href="/stumpy-basics-21844a2d2d92"> STUMPY基础知识</a> <br/>第3部分:<a class="ae kv" rel="noopener" target="_blank" href="/part-3-time-series-chains-da281450abbf">时间序列链</a> <br/>第4部分:<a class="ae kv" rel="noopener" target="_blank" href="/part-4-semantic-segmentation-b42c3792833d">语义分割</a> <br/>第5部分:<a class="ae kv" rel="noopener" target="_blank" href="/part-5-fast-approximate-matrix-profiles-with-scrump-c6d9c984c560">用STUMPY快速近似矩阵轮廓图</a> <br/>第6部分:<a class="ae kv" rel="noopener" target="_blank" href="/matrix-profiles-for-streaming-time-series-data-f877ff6f9eef">用于流式时间序列数据的矩阵轮廓图</a> <br/>第7部分:<a class="ae kv" rel="noopener" target="_blank" href="/part-7-fast-pattern-searching-with-stumpy-2baf610a8de1">用STUMPY快速模式搜索</a> 10: <a class="ae kv" rel="noopener" target="_blank" href="/part-10-discovering-multidimensional-time-series-motifs-45da53b594bb">发现多维时间序列模体</a> <br/>第11部分:<a class="ae kv" rel="noopener" target="_blank" href="/part-11-user-guided-motif-search-d3d317caf9ea">用户引导的模体搜索</a> <br/>第12部分:<a class="ae kv" rel="noopener" target="_blank" href="/part-12-matrix-profiles-for-machine-learning-2dfd98d7ff3f">机器学习的矩阵轮廓</a></p><h1 id="bfaa" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">Shapelet发现</h1><p id="5401" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">本教程探讨了来自研究论文的“Shapelet Discovery”案例研究:<a class="ae kv" href="https://www.cs.ucr.edu/~eamonn/Top_Ten_Things_Matrix_Profile.pdf" rel="noopener ugc nofollow" target="_blank">时间序列数据挖掘的瑞士军刀:你可以用矩阵概要和十行代码做的十件有用的事情】</a>(见3.7节)。此外，您可能想要参考<a class="ae kv" href="https://www.cs.ucr.edu/~eamonn/PID4481997_extend_Matrix%20Profile_I.pdf" rel="noopener ugc nofollow" target="_blank">矩阵概要I </a>和<a class="ae kv" href="https://www.cs.ucr.edu/~eamonn/shaplet.pdf" rel="noopener ugc nofollow" target="_blank">时间序列Shapelets:一种新的数据挖掘原语</a>论文以获得更多信息和其他相关示例。</p><h1 id="bc62" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">什么是Shapelet？</h1><p id="1cff" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">非正式地，时间序列“shapelets”是时间序列子序列，在某种意义上，它最大限度地代表了一个类。例如，想象一下，如果您有一个时间序列来跟踪您家中大型电器五年来每秒钟的耗电量。每次你运行干衣机、洗碗机或空调时，你的电表都会记录消耗的电力，只需查看时间序列，你就可以将电力消耗“特征”(即形状、持续时间、最大能源使用量等)与每台设备关联起来。这些模式可能显而易见，也可能很微妙，正是它们独特的“成形”时序子序列让您能够区分每个电器类别。因此，这些所谓的shapelet可用于对包含shape let出现的未标记时间序列进行分类。如果这听起来有点行话，不要担心，因为通过下面的例子，一切都会变得更清楚。</p><p id="1799" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">最近的研究(见上文)表明，矩阵配置文件可以用来有效地识别特定类的shape let，因此，在本教程中，我们将建立在我们的矩阵配置文件知识之上，并演示如何使用STUMPY轻松地发现有趣的shape let，只需几行额外的代码。</p><h1 id="120e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">入门指南</h1><p id="0a67" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">让我们导入加载、分析和绘制数据所需的包，然后构建简单的决策树模型。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="9470" class="mw kx iq ms b gy mx my l mz na"><strong class="ms ir">%</strong>matplotlib inline</span><span id="c4ff" class="mw kx iq ms b gy nb my l mz na"><strong class="ms ir">import</strong> stumpy<br/><strong class="ms ir">import</strong> pandas <strong class="ms ir">as</strong> pd<br/><strong class="ms ir">import</strong> numpy <strong class="ms ir">as</strong> np<br/><strong class="ms ir">import</strong> matplotlib.pyplot <strong class="ms ir">as</strong> plt<br/><strong class="ms ir">from</strong> sklearn <strong class="ms ir">import</strong> tree<br/><strong class="ms ir">from</strong> sklearn <strong class="ms ir">import</strong> metrics</span><span id="faab" class="mw kx iq ms b gy nb my l mz na">plt.style.use('https://raw.githubusercontent.com/TDAmeritrade/stumpy/main/docs/stumpy.mplstyle')</span></pre><h1 id="b2d3" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">加载枪口数据集</h1><p id="6f07" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">该数据集是一个运动捕捉时间序列，用于跟踪演员右手的运动，包含两个类:</p><blockquote class="nc nd ne"><p id="5d35" class="lp lq ml lr b ls lt jr lu lv lw ju lx nf lz ma mb ng md me mf nh mh mi mj mk ij bi translated"><code class="fe ni nj nk ms b">1. Gun</code></p><p id="72c3" class="lp lq ml lr b ls lt jr lu lv lw ju lx nf lz ma mb ng md me mf nh mh mi mj mk ij bi translated"><code class="fe ni nj nk ms b">2. Point</code></p></blockquote><p id="f398" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">在<code class="fe ni nj nk ms b">Gun</code>类中，演员从臀部安装的枪套中取出一把实体枪，将枪对准目标大约一秒钟，然后将枪放回枪套，并将手放松到身体两侧。在<code class="fe ni nj nk ms b">Point</code>类中，演员将枪放在身体两侧，相反，他们将食指指向目标(即没有枪)大约一秒钟，然后将手放回身体两侧。对于这两个类，演员的右手质心被跟踪，以代表其运动。</p><p id="e76b" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">下面，我们将检索原始数据，将它们分成<code class="fe ni nj nk ms b">gun_df</code>和<code class="fe ni nj nk ms b">point_df</code>，然后，对于每个相应的类，将所有单独的样本连接成一个长时间序列。此外，我们通过在每个样本后附加一个<code class="fe ni nj nk ms b">NaN</code>值，为每个样本建立一个清晰的边界(即样本开始和结束的地方)。这有助于确保所有矩阵分布计算不会返回跨越多个样本的人为子序列:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="e2ec" class="mw kx iq ms b gy mx my l mz na">train_df <strong class="ms ir">=</strong> pd.read_csv("https://zenodo.org/record/4281349/files/gun_point_train_data.csv?download=1")</span><span id="87d8" class="mw kx iq ms b gy nb my l mz na">gun_df <strong class="ms ir">=</strong> train_df[train_df['0'] <strong class="ms ir">==</strong> 0].iloc[:, 1:].reset_index(drop<strong class="ms ir">=True</strong>)</span><span id="08ac" class="mw kx iq ms b gy nb my l mz na">gun_df <strong class="ms ir">= </strong>(gun_df.assign(NaN<strong class="ms ir">=</strong>np.nan)<br/>                .stack(dropna<strong class="ms ir">=False</strong>)<br/>                .to_frame()<br/>                .reset_index(drop<strong class="ms ir">=True</strong>)<br/>                .rename({0: "Centroid Location"}, axis<strong class="ms ir">=</strong>'columns')<br/>)</span><span id="88cf" class="mw kx iq ms b gy nb my l mz na">point_df <strong class="ms ir">=</strong> train_df[train_df['0'] <strong class="ms ir">==</strong> 1].iloc[:, 1:].reset_index(drop<strong class="ms ir">=True</strong>)</span><span id="7ffe" class="mw kx iq ms b gy nb my l mz na">point_df <strong class="ms ir">=</strong> (point_df.assign(NaN<strong class="ms ir">=</strong>np.nan)<br/>                   .stack(dropna<strong class="ms ir">=False</strong>)<br/>                   .to_frame()<br/>                   .reset_index(drop<strong class="ms ir">=True</strong>)<br/>                   .rename({0: "Centroid Location"}, axis<strong class="ms ir">=</strong>'columns')<br/>)</span></pre><h1 id="5c35" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">可视化枪口数据集</h1><p id="96a6" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">接下来，让我们绘制我们的数据，并想象没有枪时和有枪时的运动差异:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="46b2" class="mw kx iq ms b gy mx my l mz na">fig, axs <strong class="ms ir">=</strong> plt.subplots(2, sharex<strong class="ms ir">=True</strong>, gridspec_kw<strong class="ms ir">=</strong>{'hspace': 0})<br/>plt.suptitle('Point vs. Gun', fontsize<strong class="ms ir">=</strong>'30')<br/>plt.xlabel('Time', fontsize <strong class="ms ir">=</strong>'20')<br/>fig.text(0.09, 0.5, 'Centroid Location', va<strong class="ms ir">=</strong>'center', rotation<strong class="ms ir">=</strong>'vertical', fontsize<strong class="ms ir">=</strong>'20')</span><span id="8103" class="mw kx iq ms b gy nb my l mz na">axs[0].plot(point_df, label<strong class="ms ir">=</strong>"Point")<br/>axs[0].legend()<br/>axs[1].plot(gun_df, color<strong class="ms ir">=</strong>"C1", label<strong class="ms ir">=</strong>"Gun")<br/>axs[1].legend()<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/55326dcffb81018bcf312435dc5913f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Azq7oxGBiE_dijPcIOmizw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="6742" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">在这个数据集中，您将看到<code class="fe ni nj nk ms b">Point</code>和<code class="fe ni nj nk ms b">Gun</code>分别有26个和24个样本。这两个类都包含窄/宽样本和垂直移动的质心位置，这使得区分它们具有挑战性。您是否能够识别出<code class="fe ni nj nk ms b">Point</code>和<code class="fe ni nj nk ms b">Gun</code>之间的任何细微差异(即shapelets ),从而帮助您区分这两个类别？</p><p id="9de9" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">事实证明，矩阵轮廓可能有助于我们自动识别潜在的形状！</p><h1 id="08f3" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">使用矩阵轮廓查找候选Shapelets</h1><p id="5a39" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">回想一下我们的<a class="ae kv" href="https://stumpy.readthedocs.io/en/latest/Tutorial_AB_Joins.html" rel="noopener ugc nofollow" target="_blank">寻找跨两个时间序列的保守模式教程</a>，从单个时间序列𝑇𝐴计算的矩阵分布图𝑃𝐴𝐴被称为“自连接”,它允许你识别𝑇𝐴.内的保守子序列然而，通过两个不同的时间序列(𝑇𝐴和𝑇𝐵)计算的矩阵分布图(𝑃𝐴𝐵)通常被称为“AB-join”。本质上，AB-join将𝑇𝐴的所有子序列与𝑇𝐵的所有子序列进行比较，以确定𝑇𝐴的任何子序列是否也能在𝑇𝐵.找到换句话说，产生的矩阵轮廓，𝑃𝐴𝐵，用它在𝑇𝐵.的最佳匹配子序列来注释在𝑇𝐴的每个子序列相比之下，如果我们交换时间序列并计算𝑃𝐵𝐴(即“BA-join”)，那么这会用𝑇𝐴.的最近邻子序列来注释𝑇𝐵的每个子序列</p><p id="2398" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">根据<a class="ae kv" href="https://www.cs.ucr.edu/~eamonn/PID4481997_extend_Matrix%20Profile_I.pdf" rel="noopener ugc nofollow" target="_blank"> Matrix Profile I </a>论文的h部分，声称我们可以利用Matrix Profile来试探性地“建议”候选shape let，并且主要直觉是，如果在<code class="fe ni nj nk ms b">Gun</code>类中存在区别性图案，而在<code class="fe ni nj nk ms b">Point</code>类中不存在区别性图案(反之亦然)，那么我们将期望在它们相应的𝑃(𝑃𝑜𝑖𝑛𝑡,𝑃𝑜𝑖𝑛t)- 𝑃(𝑃𝑜𝑖𝑛𝑡,𝐺𝑢𝑛(或𝑃(𝐺𝑢𝑛,𝐺𝑢n)- 𝑃(𝐺𝑢𝑛,𝑃𝑜𝑖𝑛t)矩阵Profile中看到一个或多个“凸起”，并且高度上的任何显著差异可能是良好候选shape let的强有力指示。</p><p id="f845" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">因此，首先，让我们计算矩阵轮廓，𝑃(𝑃𝑜𝑖𝑛𝑡,𝑃𝑜𝑖𝑛t(自连接)和𝑃(𝑃𝑜𝑖𝑛𝑡,𝐺𝑢n(a B-连接)，并且，为了简单起见，我们使用子序列长度<code class="fe ni nj nk ms b">m = 38</code>，这是为该数据集报告的最佳shapelet <a class="ae kv" href="https://www.cs.ucr.edu/~eamonn/shaplet.pdf" rel="noopener ugc nofollow" target="_blank">的长度:</a></p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="1ce0" class="mw kx iq ms b gy mx my l mz na">m <strong class="ms ir">=</strong> 38</span><span id="204c" class="mw kx iq ms b gy nb my l mz na">P_Point_Point <strong class="ms ir">=</strong> stumpy.stump(point_df["Centroid Location"], m)[:, 0].astype(float)</span><span id="c67c" class="mw kx iq ms b gy nb my l mz na">P_Point_Gun <strong class="ms ir">=</strong> stumpy.stump(<br/>    point_df["Centroid Location"], <br/>    m, <br/>    gun_df["Centroid Location"], <br/>    ignore_trivial<strong class="ms ir">=False<br/></strong>)[:, 0].astype(float)</span></pre><p id="78cb" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">由于我们的时间序列中有一些<code class="fe ni nj nk ms b">np.nan</code>值，矩阵配置文件的输出将包含几个<code class="fe ni nj nk ms b">np.inf</code>值。因此，我们将通过将其转换为<code class="fe ni nj nk ms b">np.nan</code>来手动调整:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="745f" class="mw kx iq ms b gy mx my l mz na">P_Point_Point[P_Point_Point <strong class="ms ir">==</strong> np.inf] <strong class="ms ir">=</strong> np.nan<br/>P_Point_Gun[P_Point_Gun <strong class="ms ir">==</strong> np.inf] <strong class="ms ir">=</strong> np.nan</span></pre><p id="8eb7" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">现在我们将它们一个叠一个地绘制出来:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="c936" class="mw kx iq ms b gy mx my l mz na">plt.plot(P_Point_Point, label<strong class="ms ir">=</strong>"$P_{Point,Point}$")<br/>plt.plot(P_Point_Gun, color<strong class="ms ir">=</strong>"C1", label<strong class="ms ir">=</strong>"$P_{Point,Gun}$")<br/>plt.xlabel("Time", fontsize<strong class="ms ir">=</strong>"20")<br/>plt.ylabel("Matrix Profile", fontsize<strong class="ms ir">=</strong>"20")<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/61e72de981bfaab5d7c667407f7383cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8nD5a5ScuOt3DPGRKFtIiw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="66e9" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">接下来，我们可以通过绘制𝑃(𝑃𝑜𝑖𝑛𝑡,𝑃𝑜𝑖𝑛t和𝑃(𝑃𝑜𝑖𝑛𝑡,𝐺𝑢n).之间的差异来突出两个矩阵图之间的主要偏差直觉上，𝑃(𝑃𝑜𝑖𝑛𝑡,𝑃𝑜𝑖𝑛t)将比𝑃(𝑃𝑜𝑖𝑛𝑡,𝐺𝑢n)小，因为我们期望同一类中的子序列比不同类中的子序列更相似:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="a9b1" class="mw kx iq ms b gy mx my l mz na">P_diff <strong class="ms ir">=</strong> P_Point_Gun <strong class="ms ir">-</strong> P_Point_Point<br/>idx <strong class="ms ir">=</strong> np.argpartition(np.nan_to_num(P_diff), <strong class="ms ir">-</strong>10)[<strong class="ms ir">-</strong>10:]  <em class="ml"># get the top 10 peak locations in P_diff<br/></em>plt.suptitle("", fontsize<strong class="ms ir">=</strong>"30")<br/>plt.xlabel("Time", fontsize<strong class="ms ir">=</strong>"20")<br/>plt.ylabel("$P_{diff} = P_{Point,Gun} - P_{Point, Point}$", fontsize<strong class="ms ir">=</strong>"20")<br/>plt.plot(idx, P_diff[idx], color<strong class="ms ir">=</strong>"C1", marker<strong class="ms ir">=</strong>"o", linewidth<strong class="ms ir">=</strong>0, markersize<strong class="ms ir">=</strong>10)<br/>plt.plot(P_diff)<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/6e2fd8b0b8dfc9b0b67567dfb314d196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cYcA0ZFVJCxne122BOUPlw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="ad45" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">𝑃_𝑑𝑖𝑓𝑓(橙色圆圈)中的峰值是良好shapelet候选者的指标，因为它们暗示了在它们自己的类(即，𝑃(𝑃𝑜𝑖𝑛𝑡,𝑃𝑜𝑖𝑛t自连接)中非常保守的模式，但是也与它们在另一类(即，𝑃(𝑃𝑜𝑖𝑛𝑡,𝐺𝑢n a B-连接)中最接近的匹配非常不同。有了这些知识，让我们提取发现的shapelets，然后绘制它们:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="f572" class="mw kx iq ms b gy mx my l mz na">point_shapelets <strong class="ms ir">=</strong> []<br/><strong class="ms ir">for</strong> i <strong class="ms ir">in</strong> idx:<br/>    shapelet <strong class="ms ir">=</strong> point_df.iloc[i : i <strong class="ms ir">+</strong> m, 0]<br/>    point_shapelets.append(shapelet)</span><span id="340c" class="mw kx iq ms b gy nb my l mz na">plt.xlabel("Time", fontsize<strong class="ms ir">=</strong>"20")<br/>plt.ylabel('Centroid Location', fontsize<strong class="ms ir">=</strong>'20')<br/>plt.plot(point_df, label<strong class="ms ir">=</strong>"Point")</span><span id="6910" class="mw kx iq ms b gy nb my l mz na"><strong class="ms ir">for</strong> i, shapelet <strong class="ms ir">in</strong> zip(idx, point_shapelets):<br/>    plt.plot(range(i, i <strong class="ms ir">+</strong> m), shapelet, color<strong class="ms ir">=</strong>"C1", linewidth<strong class="ms ir">=</strong>3.0)</span><span id="40ab" class="mw kx iq ms b gy nb my l mz na">plt.legend()<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/39f1cb456b6d0ebafdd0ea5ad07116d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r8Z7CvI-vgrSeiITz_L2IQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="48b5" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">基于这些候选形状(橙色)，似乎这两个类别之间的主要区别因素在于演员的手如何将(假想的)枪放回枪套，然后在演员身边放松。根据原作者的说法,<code class="fe ni nj nk ms b">Point</code>类“有一个‘下降’,演员将手放在身体两侧，这是惯性使她的手有点太远，她被迫纠正这一点——作者将这一现象称为“过度”。</p><h1 id="9eb0" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">构建一个简单的分类器</h1><p id="40a0" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">现在我们已经确定了10个候选shape let，让我们基于这些shape let构建10个独立的决策树模型，看看它们能在多大程度上帮助我们区分<code class="fe ni nj nk ms b">Point</code>类和<code class="fe ni nj nk ms b">Gun</code>类。幸运的是，这个数据集包括一个训练集(如上)和一个独立的测试集，我们可以用它们来评估我们的模型的准确性:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="39b7" class="mw kx iq ms b gy mx my l mz na">test_df <strong class="ms ir">=</strong> df <strong class="ms ir">=</strong> pd.read_csv("https://zenodo.org/record/4281349/files/gun_point_test_data.csv?download=1")</span><span id="8f8e" class="mw kx iq ms b gy nb my l mz na"><em class="ml"># Get the train and test targets<br/></em>y_train <strong class="ms ir">=</strong> train_df.iloc[:, 0]<br/>y_test <strong class="ms ir">=</strong> test_df.iloc[:, 0]</span></pre><p id="5afe" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">现在，对于我们的分类任务，需要评估每个shapelets的预测能力。因此，我们首先计算shapelet和每个时间序列或样本中的每个子序列之间的距离轮廓(成对欧几里德距离)。然后，保持最小值，以了解是否在时间序列中找到了shapelet的紧密匹配。<code class="fe ni nj nk ms b">stumpy.mass</code>功能非常适合这项任务:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="9844" class="mw kx iq ms b gy mx my l mz na"><strong class="ms ir">def</strong> distance_to_shapelet(data, shapelet):<br/>    """<br/>    Compute the minimum distance beteen each data sample<br/>    and a shapelet of interest<br/>    """<br/>    data <strong class="ms ir">=</strong> np.asarray(data)<br/>    X <strong class="ms ir">=</strong> np.empty(len(data))<br/>    <strong class="ms ir">for</strong> i <strong class="ms ir">in</strong> range(len(data)):<br/>        D <strong class="ms ir">=</strong> stumpy.mass(shapelet, data[i])<br/>        X[i] <strong class="ms ir">=</strong> D.min()</span><span id="4127" class="mw kx iq ms b gy nb my l mz na"><strong class="ms ir">    return</strong> X.reshape(<strong class="ms ir">-</strong>1, 1)</span><span id="e210" class="mw kx iq ms b gy nb my l mz na">clf <strong class="ms ir">=</strong> tree.DecisionTreeClassifier()<br/><strong class="ms ir">for</strong> i, shapelet <strong class="ms ir">in</strong> enumerate(point_shapelets):<br/>    X_train <strong class="ms ir">=</strong> distance_to_shapelet(train_df.iloc[:, 1:], shapelet)<br/>    X_test <strong class="ms ir">=</strong> distance_to_shapelet(test_df.iloc[:, 1:], shapelet)<br/>    clf.fit(X_train, y_train)<br/>    y_pred <strong class="ms ir">=</strong> clf.predict(X_test.reshape(<strong class="ms ir">-</strong>1, 1))<br/>    print(f"Accuracy for shapelet {i} = {round(metrics.accuracy_score(y_test, y_pred), 3)}")</span><span id="29bb" class="mw kx iq ms b gy nb my l mz na">Accuracy for shapelet 0 = 0.867<br/>Accuracy for shapelet 1 = 0.833<br/>Accuracy for shapelet 2 = 0.807<br/>Accuracy for shapelet 3 = 0.833<br/>Accuracy for shapelet 4 = 0.933<br/>Accuracy for shapelet 5 = 0.873<br/>Accuracy for shapelet 6 = 0.873<br/>Accuracy for shapelet 7 = 0.833<br/>Accuracy for shapelet 8 = 0.86<br/>Accuracy for shapelet 9 = 0.913</span></pre><p id="cac6" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">正如我们所看到的，所有的Shapelet都提供了一些合理的预测能力，有助于区分<code class="fe ni nj nk ms b">Point</code>和<code class="fe ni nj nk ms b">Gun</code>类，但Shapelet 4返回了93.3%的最佳准确度，该结果准确地再现了<a class="ae kv" href="https://www.cs.ucr.edu/~eamonn/Top_Ten_Things_Matrix_Profile.pdf" rel="noopener ugc nofollow" target="_blank">发布的结果</a>。太好了！</p><h1 id="953b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">附加部分—第二类的Shapelets</h1><p id="7992" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">作为额外的一点，我们还将从<code class="fe ni nj nk ms b">Gun</code>时间序列中提取shapelets，看看它们是否能为我们的模型增加任何额外的预测能力。该过程与我们在上面解释过的过程相同，只是我们关注的是从<code class="fe ni nj nk ms b">gun_df</code>派生的shapelets，所以我们在这里不打算进行过多的描述:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="1e5e" class="mw kx iq ms b gy mx my l mz na">m <strong class="ms ir">=</strong> 38</span><span id="ccce" class="mw kx iq ms b gy nb my l mz na">P_Gun_Gun <strong class="ms ir">=</strong> stumpy.stump(gun_df["Centroid Location"], m)[:, 0].astype(float)<br/>P_Gun_Point <strong class="ms ir">=</strong> stumpy.stump(gun_df["Centroid Location"], m, point_df["Centroid Location"], ignore_trivial<strong class="ms ir">=False</strong>)[:, 0].astype(float)</span><span id="53c1" class="mw kx iq ms b gy nb my l mz na">P_Gun_Gun[P_Gun_Gun <strong class="ms ir">==</strong> np.inf] <strong class="ms ir">=</strong> np.nan<br/>P_Gun_Point[P_Gun_Point <strong class="ms ir">==</strong> np.inf] <strong class="ms ir">=</strong> np.nan<br/>P_diff <strong class="ms ir">=</strong> P_Gun_Point <strong class="ms ir">-</strong> P_Gun_Gun<br/>idx <strong class="ms ir">=</strong> np.argpartition(np.nan_to_num(P_diff), <strong class="ms ir">-</strong>10)[<strong class="ms ir">-</strong>10:]  <em class="ml"># get the top 10 peak locations in P_diff<br/></em>plt.suptitle("", fontsize<strong class="ms ir">=</strong>"30")<br/>plt.xlabel("Time", fontsize<strong class="ms ir">=</strong>"20")<br/>plt.ylabel("$P_{diff} = P_{Gun, Point} - P_{Gun, Gun}$", fontsize<strong class="ms ir">=</strong>"20")<br/>plt.plot(idx, P_diff[idx], color<strong class="ms ir">=</strong>"C1", marker<strong class="ms ir">=</strong>"o", linewidth<strong class="ms ir">=</strong>0, markersize<strong class="ms ir">=</strong>10)<br/>plt.plot(P_diff)<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/eb76ec035408fd10c2057fe285a56bc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BbVuqxfzWEuTJnCwSvh6FQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="4a26" class="mw kx iq ms b gy mx my l mz na">gun_shapelets <strong class="ms ir">=</strong> []</span><span id="aeba" class="mw kx iq ms b gy nb my l mz na"><strong class="ms ir">for</strong> i <strong class="ms ir">in</strong> idx:<br/>    shapelet <strong class="ms ir">=</strong> gun_df.iloc[i : i <strong class="ms ir">+</strong> m, 0]<br/>    gun_shapelets.append(shapelet)<br/>plt.xlabel("Time", fontsize<strong class="ms ir">=</strong>"20")<br/>plt.ylabel('Centroid Location', fontsize<strong class="ms ir">=</strong>'20')<br/>plt.plot(gun_df, label<strong class="ms ir">=</strong>"Gun")</span><span id="529f" class="mw kx iq ms b gy nb my l mz na"><strong class="ms ir">for</strong> i, shapelet <strong class="ms ir">in</strong> zip(idx, gun_shapelets):<br/>    plt.plot(range(i, i <strong class="ms ir">+</strong> m), shapelet, color<strong class="ms ir">=</strong>"C1", linewidth<strong class="ms ir">=</strong>3.0)</span><span id="ef5c" class="mw kx iq ms b gy nb my l mz na">plt.legend()<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/376b240dc5c3637480855662907d20f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sEvnbYMGy02OrXnTuTTR9Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="b974" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">请注意，当存在物理枪时，在<code class="fe ni nj nk ms b">Gun</code>绘制动作开始时发现的shapelets不像<code class="fe ni nj nk ms b">Point</code>样本那样平滑。同样，给<code class="fe ni nj nk ms b">Gun</code>重新装上枪套似乎也需要一点微调。</p><p id="fd97" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">最后，我们构建我们的模型，但是这一次，我们结合了来自<code class="fe ni nj nk ms b">Gun</code>shape let和<code class="fe ni nj nk ms b">Point</code>shape let的距离特征:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="9945" class="mw kx iq ms b gy mx my l mz na">clf <strong class="ms ir">=</strong> tree.DecisionTreeClassifier()<br/><strong class="ms ir">for</strong> i, (gun_shapelet, point_shapelet) <strong class="ms ir">in</strong> numerate(zip(gun_shapelets, point_shapelets)):<br/>    X_train_gun <strong class="ms ir">=</strong> distance_to_shapelet(train_df.iloc[:, 1:], gun_shapelet)<br/>    X_train_point <strong class="ms ir">=</strong> distance_to_shapelet(train_df.iloc[:, 1:], point_shapelet)<br/>    X_train <strong class="ms ir">=</strong> np.concatenate((X_train_gun, X_train_point), axis<strong class="ms ir">=</strong>1)<br/>    X_test_gun <strong class="ms ir">=</strong> distance_to_shapelet(test_df.iloc[:, 1:], gun_shapelet)<br/>    X_test_point <strong class="ms ir">=</strong> distance_to_shapelet(test_df.iloc[:, 1:], point_shapelet)<br/>    X_test <strong class="ms ir">=</strong> np.concatenate((X_test_gun, X_test_point), axis<strong class="ms ir">=</strong>1)<br/>    clf.fit(X_train, y_train)<br/>    y_pred <strong class="ms ir">=</strong> clf.predict(X_test)<br/>    print(f"Accuracy for shapelet {i} = {round(metrics.accuracy_score(y_test, y_pred), 3)}")</span><span id="8298" class="mw kx iq ms b gy nb my l mz na">Accuracy for shapelet 0 = 0.913<br/>Accuracy for shapelet 1 = 0.853<br/>Accuracy for shapelet 2 = 0.813<br/>Accuracy for shapelet 3 = 0.953<br/>Accuracy for shapelet 4 = 0.933<br/>Accuracy for shapelet 5 = 0.94<br/>Accuracy for shapelet 6 = 0.873<br/>Accuracy for shapelet 7 = 0.867<br/>Accuracy for shapelet 8 = 0.867<br/>Accuracy for shapelet 9 = 0.913</span></pre><p id="2066" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">我们可以看到，如果我们包括来自<code class="fe ni nj nk ms b">Gun</code>类Shapelet和<code class="fe ni nj nk ms b">Point</code>类shape let的距离，分类器达到95.3%的准确度(Shapelet 3)！显然，添加与第二类的距离也为模型提供了额外的有用信息。这是一个很好的结果，因为它将结果提高了大约2%。同样，令人印象深刻的是，所有这些信息都可以通过利用矩阵配置文件“免费”提取。</p><h1 id="a12e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">摘要</h1><p id="1b9e" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">就是这样！您刚刚学习了如何利用矩阵配置文件来查找shapelets，并使用它们来构建机器学习分类器。</p><h1 id="6bd7" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">参考</h1><p id="76d4" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated"><a class="ae kv" href="https://www.cs.ucr.edu/~eamonn/Top_Ten_Things_Matrix_Profile.pdf" rel="noopener ugc nofollow" target="_blank">时间序列数据挖掘的瑞士军刀:矩阵概要和十行代码可以做的十件有用的事情</a>(参见第3.7节)<br/> <a class="ae kv" href="https://www.cs.ucr.edu/~eamonn/shaplet.pdf" rel="noopener ugc nofollow" target="_blank">时间序列Shapelets:数据挖掘的新原语</a> <br/> <a class="ae kv" href="https://stumpy.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> STUMPY文档</a> <br/> <a class="ae kv" href="https://github.com/TDAmeritrade/stumpy" rel="noopener ugc nofollow" target="_blank"> STUMPY矩阵概要Github代码库</a></p><h2 id="d863" class="mw kx iq bd ky nq nr dn lc ns nt dp lg ly nu nv li mc nw nx lk mg ny nz lm oa bi translated">← <a class="ae kv" href="https://medium.com/p/d3d317caf9ea#92dc-ad9c13147b05" rel="noopener">第11部分:用户导向的主题搜索</a> |第13部分即将推出→</h2></div></div>    
</body>
</html>