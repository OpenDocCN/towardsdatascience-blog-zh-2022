<html>
<head>
<title>If things are not ‘ready to use’ — Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如果事情还没有“准备好使用”——第 3 部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/part-iii-if-things-are-not-ready-to-use-59d2db378bec#2022-03-17">https://towardsdatascience.com/part-iii-if-things-are-not-ready-to-use-59d2db378bec#2022-03-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="bb70" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">使用 JULIA 及其生态系统的机器学习</h2><div class=""/><div class=""><h2 id="9987" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">朱莉娅有很高的可组合性。只需几行代码，就可以在现有软件包的基础上构建新的功能。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/16dbbb99d55d6397dfa780142aa20ac1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wB9-EseMDsLotQ35igiIeQ.jpeg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@ourlifeinpixels?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">在<a class="ae le" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上以像素</a>表示我们的生活</p></figure><h1 id="b9e7" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">教程概述</h1><p id="44b6" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">这是本教程的第三部分，它展示了 Julia 的特定语言特性和来自其生态系统的各种高质量的包是如何在一个典型的 ML 工作流中轻松组合使用的。</p><ul class=""><li id="3f05" class="mu mv iq lz b ma mw md mx mg my mk mz mo na ms nb nc nd ne bi translated"><a class="ae le" rel="noopener" target="_blank" href="/part-i-analyzing-the-glass-dataset-c556788a496f">第一部分</a>“<em class="mt">分析玻璃数据集”</em>集中讲述如何使用<code class="fe nf ng nh ni b">ScientificTypes</code>、<code class="fe nf ng nh ni b">DataFrames</code>、<code class="fe nf ng nh ni b">StatsBase</code>和<code class="fe nf ng nh ni b">StatsPlots</code>等软件包对数据进行预处理、分析和可视化。</li><li id="30f4" class="mu mv iq lz b ma nj md nk mg nl mk nm mo nn ms nb nc nd ne bi translated"><a class="ae le" rel="noopener" target="_blank" href="/part-ii-using-a-decision-tree-ddffa4004e47">第二部分</a>“<em class="mt">使用决策树”</em>关注 ML 工作流的核心:如何选择模型，以及如何使用它进行训练、预测和评估。这部分主要靠包<code class="fe nf ng nh ni b">MLJ</code>(=<strong class="lz ja">M</strong>achine<strong class="lz ja">L</strong>in<strong class="lz ja">J</strong>ulia<em class="mt">)</em>收入。</li><li id="f251" class="mu mv iq lz b ma nj md nk mg nl mk nm mo nn ms nb nc nd ne bi translated">第三部分"<em class="mt">如果事情还没有“准备好使用”"</em>解释了如果可用的软件包没有提供您需要的所有功能，那么用几行代码创建您自己的解决方案是多么容易。</li></ul><h1 id="056e" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">介绍</h1><p id="a0d3" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">在本教程的第二部分中，我们创建了一个决策树，并使用<code class="fe nf ng nh ni b">print_tree()</code>打印了以下表示:</p><pre class="kp kq kr ks gt no ni np nq aw nr bi"><span id="c92c" class="ns lg iq ni b gy nt nu l nv nw">Feature 3, Threshold 2.745<br/>L-&gt; Feature 2, Threshold 13.77<br/>    L-&gt; Feature 4, Threshold 1.38<br/>        L-&gt; 2 : 6/7<br/>        R-&gt; 5 : 9/12<br/>    R-&gt; Feature 8, Threshold 0.2<br/>        L-&gt; 6 : 8/10<br/>        R-&gt; 7 : 18/19<br/>R-&gt; Feature 4, Threshold 1.42<br/>    L-&gt; Feature 1, Threshold 1.51707<br/>        L-&gt; 3 : 5/11<br/>        R-&gt; 1 : 40/55<br/>    R-&gt; Feature 3, Threshold 3.42<br/>        L-&gt; 2 : 5/10<br/>        R-&gt; 2 : 23/26</span></pre><p id="4208" class="pw-post-body-paragraph lx ly iq lz b ma mw ka mc md mx kd mf mg nx mi mj mk ny mm mn mo nz mq mr ms ij bi translated">它描述了树的基本特征，但有点简陋:它只是 ASCII 文本，节点只显示属性号，而不是用于分支的属性名。此外，树叶不显示类名，在这一点上得到预测。</p><p id="1021" class="pw-post-body-paragraph lx ly iq lz b ma mw ka mc md mx kd mf mg nx mi mj mk ny mm mn mo nz mq mr ms ij bi translated">因此，最好有一个包含所有附加信息的图形表示。由于没有现成的函数可用于此目的，我们必须为自己创建一个。这就是本教程第三部分的内容。</p><h1 id="ef7b" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">积木</h1><p id="3807" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">我们自己实现这个需要什么？好吧，下面的成分肯定是主要的组成部分:</p><ol class=""><li id="5663" class="mu mv iq lz b ma mw md mx mg my mk mz mo na ms oa nc nd ne bi translated">决策树本身(数据结构)</li><li id="5cf1" class="mu mv iq lz b ma nj md nk mg nl mk nm mo nn ms oa nc nd ne bi translated">有关该数据结构外观的信息(内部)</li><li id="bbfe" class="mu mv iq lz b ma nj md nk mg nl mk nm mo nn ms oa nc nd ne bi translated">一个能够绘制树木的图形包</li></ol><p id="0a08" class="pw-post-body-paragraph lx ly iq lz b ma mw ka mc md mx kd mf mg nx mi mj mk ny mm mn mo nz mq mr ms ij bi translated">…当然，还有一个想法，关于如何将这些东西粘在一起:-)</p><h2 id="c2a2" class="ns lg iq bd lh ob oc dn ll od oe dp lp mg of og lr mk oh oi lt mo oj ok lv iw bi translated">1.决策树</h2><p id="5d34" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">MLJ 函数<code class="fe nf ng nh ni b">fitted_params()</code>为每台经过训练的机器提供训练产生的所有参数。当然，这很大程度上取决于所使用的模型。在决策树分类器的情况下，这些参数之一仅仅是树本身:</p><pre class="kp kq kr ks gt no ni np nq aw nr bi"><span id="ef39" class="ns lg iq ni b gy nt nu l nv nw">fp = fitted_params(dc_mach)<br/>typeof(fp.tree)     → DecisionTree.Node{Float64, UInt32}</span></pre><h2 id="f036" class="ns lg iq bd lh ob oc dn ll od oe dp lp mg of og lr mk oh oi lt mo oj ok lv iw bi translated">2.关于数据结构的信息</h2><p id="6eda" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">为了得到一些关于决策树内部结构的信息，我们不得不看看 GitHub 上的<code class="fe nf ng nh ni b">DecisionTree.jl</code> <a class="ae le" href="https://github.com/bensadeghi/DecisionTree.jl/blob/468720922bc18bda751bf937b03cac3d26247bbd/src/DecisionTree.jl" rel="noopener ugc nofollow" target="_blank">包</a>的源代码。</p><p id="edc4" class="pw-post-body-paragraph lx ly iq lz b ma mw ka mc md mx kd mf mg nx mi mj mk ny mm mn mo nz mq mr ms ij bi translated">在这里我们可以找到<code class="fe nf ng nh ni b">Leaf</code>和<code class="fe nf ng nh ni b">Node</code>的如下定义:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ol om l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">从“DecisionTree.jl”中摘录源代码</p></figure><p id="7c04" class="pw-post-body-paragraph lx ly iq lz b ma mw ka mc md mx kd mf mg nx mi mj mk ny mm mn mo nz mq mr ms ij bi translated">这告诉我们，树结构由<code class="fe nf ng nh ni b">Node</code>组成，它存储用于在该节点分支的特征号(<code class="fe nf ng nh ni b">featid</code>)和发生分支的阈值(<code class="fe nf ng nh ni b">featval</code>)。此外，每个节点都有一个<code class="fe nf ng nh ni b">left</code>和一个<code class="fe nf ng nh ni b">right</code>子树，子树又是一个<code class="fe nf ng nh ni b">Node</code>或<code class="fe nf ng nh ni b">Leaf</code>(如果到达了树的底部)。</p><p id="53e5" class="pw-post-body-paragraph lx ly iq lz b ma mw ka mc md mx kd mf mg nx mi mj mk ny mm mn mo nz mq mr ms ij bi translated"><code class="fe nf ng nh ni b">Leaf</code> s 知道到达该叶子时将被预测的多数类(<code class="fe nf ng nh ni b">majority</code>)以及已经被分类到该叶子中的所有目标值(<code class="fe nf ng nh ni b">values</code>)的列表。</p><h2 id="1378" class="ns lg iq bd lh ob oc dn ll od oe dp lp mg of og lr mk oh oi lt mo oj ok lv iw bi translated">3.图形包</h2><p id="3126" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">Julia 图形包<code class="fe nf ng nh ni b"><a class="ae le" href="https://github.com/JuliaPlots/Plots.jl" rel="noopener ugc nofollow" target="_blank">Plots.jl</a></code>本身并不能绘制树木。但是有一个叫做<code class="fe nf ng nh ni b"><a class="ae le" href="https://github.com/JuliaPlots/GraphRecipes.jl" rel="noopener ugc nofollow" target="_blank">GraphRecipes.jl</a></code>的‘助手’包，里面包含了几个所谓的绘图配方。这些规范描述了如何使用<code class="fe nf ng nh ni b">Plots</code>(或另一个理解这些配方的图形包)绘制不同的图形结构。在其他食谱中，有一种是针对<a class="ae le" href="https://docs.juliaplots.org/stable/graphrecipes/examples/#AbstractTrees-Trees" rel="noopener ugc nofollow" target="_blank">树</a>(叫做<code class="fe nf ng nh ni b">TreePlot</code>)的。</p><p id="8fcf" class="pw-post-body-paragraph lx ly iq lz b ma mw ka mc md mx kd mf mg nx mi mj mk ny mm mn mo nz mq mr ms ij bi translated"><code class="fe nf ng nh ni b">GraphRecipes</code>也作为要绘制的结构和执行绘制的图形包之间的抽象层。</p><h1 id="a4a8" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">将这一切结合在一起</h1><h2 id="f993" class="ns lg iq bd lh ob oc dn ll od oe dp lp mg of og lr mk oh oi lt mo oj ok lv iw bi translated">基本概念</h2><p id="6d65" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">现在我们已经确定了主要的构件，剩下的问题是我们如何将这些东西组合在一起，以获得想要的结果。主要问题是:绘图配方<code class="fe nf ng nh ni b">TreePlot</code>怎么知道，我们的决策树详细是什么样子的，以便<code class="fe nf ng nh ni b">TreePlot</code>绘图？两个包(<code class="fe nf ng nh ni b">DecisionTree.jl</code>和<code class="fe nf ng nh ni b">GraphRecipes.jl</code>)都是独立开发的。他们对彼此一无所知。</p><p id="46b6" class="pw-post-body-paragraph lx ly iq lz b ma mw ka mc md mx kd mf mg nx mi mj mk ny mm mn mo nz mq mr ms ij bi translated"><code class="fe nf ng nh ni b">TreePlot</code>的文档告诉我们，它需要一个<code class="fe nf ng nh ni b">AbstractTree</code>类型的结构(来自包<code class="fe nf ng nh ni b"><a class="ae le" href="https://github.com/JuliaCollections/AbstractTrees.jl" rel="noopener ugc nofollow" target="_blank">AbstractTree.jl</a></code>)。但是来自<code class="fe nf ng nh ni b">DecisionTree.jl</code>包的决策树不符合这种类型。我们现在被困住了吗？</p><p id="9ea0" class="pw-post-body-paragraph lx ly iq lz b ma mw ka mc md mx kd mf mg nx mi mj mk ny mm mn mo nz mq mr ms ij bi translated">如果我们使用一种“普通的”面向对象语言，我们会陷入困境。在这种情况下，我们也许可以尝试定义一个继承自<code class="fe nf ng nh ni b">Node</code>和<code class="fe nf ng nh ni b">AbstractTree</code>的新类。但是，只有在语言支持多重继承的情况下，这种方法才有效。如果没有，我们可以尝试定义一个继承自<code class="fe nf ng nh ni b">AbstractTree</code>的新类，并在其中包装<code class="fe nf ng nh ni b">Node</code>和<code class="fe nf ng nh ni b">Leaf</code>结构。所有这些可能需要相当多的工作，并且似乎不是一个优雅的解决方案。</p><p id="2f9e" class="pw-post-body-paragraph lx ly iq lz b ma mw ka mc md mx kd mf mg nx mi mj mk ny mm mn mo nz mq mr ms ij bi translated">幸运的是，我们使用朱莉娅。这里我们只需要(重新)定义决策树上<code class="fe nf ng nh ni b">AbstractTree</code>的几个函数，这使得<em class="mt">看起来像</em>和<code class="fe nf ng nh ni b">AbstractTree</code>。<code class="fe nf ng nh ni b">TreePlot</code>配方只期望从我们的决策树得到一个特定的<em class="mt">行为</em>(它真的不关心这个数据结构的类型):它希望树有</p><ul class=""><li id="94a7" class="mu mv iq lz b ma mw md mx mg my mk mz mo na ms nb nc nd ne bi translated">当应用于树<code class="fe nf ng nh ni b">t</code>(或树的一个节点)时，返回其子树列表的函数<code class="fe nf ng nh ni b">children(t)</code></li><li id="0388" class="mu mv iq lz b ma nj md nk mg nl mk nm mo nn ms nb nc nd ne bi translated">以及将节点<code class="fe nf ng nh ni b">node</code>的表示打印到输出流<code class="fe nf ng nh ni b">io</code>的函数<code class="fe nf ng nh ni b">printnode(io::IO, node)</code>。</li></ul><p id="e3f5" class="pw-post-body-paragraph lx ly iq lz b ma mw ka mc md mx kd mf mg nx mi mj mk ny mm mn mo nz mq mr ms ij bi translated">下图显示了所有这些组件以及它们之间的关系:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi on"><img src="../Images/269e6850f210cd5125c1b0e4f40277a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bBfvm4D-wGvcPS9Z7DN-XA.jpeg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">基本结构[图片由作者提供]</p></figure><p id="1ed9" class="pw-post-body-paragraph lx ly iq lz b ma mw ka mc md mx kd mf mg nx mi mj mk ny mm mn mo nz mq mr ms ij bi translated">我们只需要创建绿色部分(蓝色部分已经存在)。这就是我们所需要的。那么决策树符合一个<code class="fe nf ng nh ni b">AbstractTree</code>(就<code class="fe nf ng nh ni b">TreePlot</code>而言)。所以让我们开始吧:</p><h2 id="8477" class="ns lg iq bd lh ob oc dn ll od oe dp lp mg of og lr mk oh oi lt mo oj ok lv iw bi translated">第一个简单的实现</h2><p id="719c" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">这可以通过下面几行代码来完成:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="d088" class="pw-post-body-paragraph lx ly iq lz b ma mw ka mc md mx kd mf mg nx mi mj mk ny mm mn mo nz mq mr ms ij bi translated">当我们使用<code class="fe nf ng nh ni b">DecisionTree</code>和<code class="fe nf ng nh ni b">AbstractTree</code>包中的一些类型和函数定义时，我们必须声明它们的用法(用<code class="fe nf ng nh ni b">import</code>或<code class="fe nf ng nh ni b">using</code>)。</p><p id="2ee8" class="pw-post-body-paragraph lx ly iq lz b ma mw ka mc md mx kd mf mg nx mi mj mk ny mm mn mo nz mq mr ms ij bi translated"><code class="fe nf ng nh ni b">children</code>的实现是一个简单的单行函数，它只返回左边和右边的子树。</p><p id="2ee6" class="pw-post-body-paragraph lx ly iq lz b ma mw ka mc md mx kd mf mg nx mi mj mk ny mm mn mo nz mq mr ms ij bi translated">为了打印，我们必须区分节点和叶子，因为节点的输出看起来不同于叶子的输出。在大多数编程语言中，我们需要一个实现来检查要打印的节点/叶子的类型，并在这种情况下使用一个<code class="fe nf ng nh ni b">if ... then ... else</code>-语句。朱丽亚却不是这样！在这里，我们可以使用它的多重分派功能，实现两个版本的<code class="fe nf ng nh ni b">printnode</code>:一个用于<code class="fe nf ng nh ni b">Node</code> s，另一个用于<code class="fe nf ng nh ni b">Leaf</code> s。</p><p id="91ab" class="pw-post-body-paragraph lx ly iq lz b ma mw ka mc md mx kd mf mg nx mi mj mk ny mm mn mo nz mq mr ms ij bi translated">这里，我们为<code class="fe nf ng nh ni b">printnode</code>选择了一个非常简单的实现作为第一步。<code class="fe nf ng nh ni b">Node</code>的版本打印的信息与我们之前使用的内置<code class="fe nf ng nh ni b">print_tree()</code>相同(特征的 ID 和阈值)。<code class="fe nf ng nh ni b">Leaf</code>的变体甚至更简单:它打印预测类的 ID 和叶子中考虑的值的数量。</p><p id="57db" class="pw-post-body-paragraph lx ly iq lz b ma mw ka mc md mx kd mf mg nx mi mj mk ny mm mn mo nz mq mr ms ij bi translated"><code class="fe nf ng nh ni b">AbstractTree.jl</code>包还有一个函数<code class="fe nf ng nh ni b">print_tree</code>,它使用我们上面实现的两个函数来输出基于文本的树。让我们使用<code class="fe nf ng nh ni b">AbstractTree.print_tree</code>来测试我们的第一个实现:</p><pre class="kp kq kr ks gt no ni np nq aw nr bi"><span id="2485" class="ns lg iq ni b gy nt nu l nv nw">AbstractTrees.print_tree(fp.tree) --&gt;</span><span id="1117" class="ns lg iq ni b gy oo nu l nv nw">Feature: 3 — Threshold: 2.745<br/>├─ Feature: 2 — Threshold: 13.77<br/>│ ├─ Feature: 4 — Threshold: 1.38<br/>│ │ ├─ maj: 2 — vals: 7<br/>│ │ └─ maj: 5 — vals: 12<br/>│ └─ Feature: 8 — Threshold: 0.2<br/>│   ├─ maj: 6 — vals: 10<br/>│   └─ maj: 7 — vals: 19<br/>└─ Feature: 4 — Threshold: 1.42<br/>  ├─ Feature: 1 — Threshold: 1.51707<br/>  │ ├─ maj: 3 — vals: 11<br/>  │ └─ maj: 1 — vals: 55<br/>  └─ Feature: 3 — Threshold: 3.42<br/>    ├─ maj: 2 — vals: 10<br/>    └─ maj: 2 — vals: 26</span></pre><p id="453d" class="pw-post-body-paragraph lx ly iq lz b ma mw ka mc md mx kd mf mg nx mi mj mk ny mm mn mo nz mq mr ms ij bi translated">看起来很好，所有值都与上面决策树的第一个打印结果相对应。所以实现看起来完美无缺！</p><p id="7b3b" class="pw-post-body-paragraph lx ly iq lz b ma mw ka mc md mx kd mf mg nx mi mj mk ny mm mn mo nz mq mr ms ij bi translated">现在使用<code class="fe nf ng nh ni b">Plots</code>和<code class="fe nf ng nh ni b">GraphRecipes</code>的图形表示:因为我们已经实现了必要的功能，我们可以使用<code class="fe nf ng nh ni b">TreePlot</code>调用<code class="fe nf ng nh ni b">plot</code>(应用 Buchheim 树布局算法)。就是这样！</p><pre class="kp kq kr ks gt no ni np nq aw nr bi"><span id="455f" class="ns lg iq ni b gy nt nu l nv nw">using GraphRecipes</span><span id="93f5" class="ns lg iq ni b gy oo nu l nv nw">plot(TreePlot(fp.tree), <br/>        method = :buchheim, nodeshape = :rect,<br/>        root = :left, curves = false)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi op"><img src="../Images/995c683ae8f19d458a0d96bfa3cc3de6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7vS2pH3w1eK5Z2zJbMlW2Q.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">决策树的图形描述[图片由作者提供]</p></figure><h2 id="c062" class="ns lg iq bd lh ob oc dn ll od oe dp lp mg of og lr mk oh oi lt mo oj ok lv iw bi translated">微调输出</h2><p id="f68a" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">在下一步中，我们想要一个树，在它的节点上显示 feature<em class="mt">name</em>，在它的叶子上显示预测类的<em class="mt">name</em>(而不是之前使用的 id)。可惜 a <code class="fe nf ng nh ni b">DecisionTree</code>根本不知道这个信息。也就是说，我们必须以某种方式添加这些信息，以便它们可以被上一节中应用的机制所使用。</p><p id="6475" class="pw-post-body-paragraph lx ly iq lz b ma mw ka mc md mx kd mf mg nx mi mj mk ny mm mn mo nz mq mr ms ij bi translated">这个想法是在使用<code class="fe nf ng nh ni b">children</code>遍历决策树时添加这个信息，这样<code class="fe nf ng nh ni b">printnode</code>就可以访问它。那是我们唯一需要这些信息的地方。没有必要以任何方式改变决策树结构。</p><p id="8c0f" class="pw-post-body-paragraph lx ly iq lz b ma mw ka mc md mx kd mf mg nx mi mj mk ny mm mn mo nz mq mr ms ij bi translated">因此，<code class="fe nf ng nh ni b">children</code>不会直接从<code class="fe nf ng nh ni b">DecisionTree</code>返回<code class="fe nf ng nh ni b">Node</code>和<code class="fe nf ng nh ni b">Leaf</code>结构，而是返回带有附加信息的丰富结构。这些富集结构定义如下:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="74da" class="pw-post-body-paragraph lx ly iq lz b ma mw ka mc md mx kd mf mg nx mi mj mk ny mm mn mo nz mq mr ms ij bi translated">这些新的<code class="fe nf ng nh ni b">struct</code>中的属性<code class="fe nf ng nh ni b">info</code>可能包含我们想要在打印的树上显示的任何信息。<code class="fe nf ng nh ni b">dt_node</code>和<code class="fe nf ng nh ni b">dt_leaf</code>只是我们之前已经使用过的决策树元素。</p><p id="cfbc" class="pw-post-body-paragraph lx ly iq lz b ma mw ka mc md mx kd mf mg nx mi mj mk ny mm mn mo nz mq mr ms ij bi translated">为了在每次调用<code class="fe nf ng nh ni b">children</code>时创建这些丰富的结构，我们定义了一个具有两个实现的函数<code class="fe nf ng nh ni b">wrap_element()</code>:一个创建<code class="fe nf ng nh ni b">NamedNode</code>，另一个创建<code class="fe nf ng nh ni b">NamedLeaf</code>。这是我们依赖于 Julia 的多重调度机制的另一种情况。根据第二个参数的类型(a <code class="fe nf ng nh ni b">Node</code>或 a <code class="fe nf ng nh ni b">Leaf</code>)，将选择正确的方法。</p><p id="9706" class="pw-post-body-paragraph lx ly iq lz b ma mw ka mc md mx kd mf mg nx mi mj mk ny mm mn mo nz mq mr ms ij bi translated">这使得我们新的<code class="fe nf ng nh ni b">children</code>函数的实现非常容易:只需两次调用<code class="fe nf ng nh ni b">wrap_element()</code>，在这里我们添加属性名和类名作为参数(作为<code class="fe nf ng nh ni b">NamedTuple</code>；朱莉娅标准类型在这里派上用场)。</p><p id="6dff" class="pw-post-body-paragraph lx ly iq lz b ma mw ka mc md mx kd mf mg nx mi mj mk ny mm mn mo nz mq mr ms ij bi translated"><code class="fe nf ng nh ni b">printnode</code>的实现现在接收一个<code class="fe nf ng nh ni b">NamedNode</code>或者一个<code class="fe nf ng nh ni b">NamedLeaf</code>，并且可以使用这些元素中的信息进行打印:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="b50c" class="pw-post-body-paragraph lx ly iq lz b ma mw ka mc md mx kd mf mg nx mi mj mk ny mm mn mo nz mq mr ms ij bi translated">变量<code class="fe nf ng nh ni b">matches</code>(在<code class="fe nf ng nh ni b">printnode</code>的第二个实现中)包含已经被正确分类到这个叶子上的实例(在<code class="fe nf ng nh ni b">values</code>中这个叶子上的所有实例中)。因此可以显示正确分类的实例与所有实例的比率(<code class="fe nf ng nh ni b">match_count</code>与<code class="fe nf ng nh ni b">val_count</code>)。</p><p id="6091" class="pw-post-body-paragraph lx ly iq lz b ma mw ka mc md mx kd mf mg nx mi mj mk ny mm mn mo nz mq mr ms ij bi translated">为了绘制决策树，我们最后为决策树的根创建一个<code class="fe nf ng nh ni b">NamedNode</code>。然后我们再次使用<code class="fe nf ng nh ni b">plot</code>和<code class="fe nf ng nh ni b">TreePlot</code>配方来获得想要的结果。</p><pre class="kp kq kr ks gt no ni np nq aw nr bi"><span id="dc8e" class="ns lg iq ni b gy nt nu l nv nw">nn = NamedNode(<br/>        (atr = names(XGlass), cls = levels(yGlass)), <br/>        fp.tree)</span><span id="fc24" class="ns lg iq ni b gy oo nu l nv nw">plot(TreePlot(nn), <br/>        method = :buchheim, nodeshape = :rect,<br/>        root = :left, curves = false)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi op"><img src="../Images/ffecdf8e39e34320472004f1e6417629.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*quQ4FA1zJYUppD5Yk9VVhQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">决策树的丰富变体[图片由作者提供]</p></figure><h1 id="ca2e" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">结论</h1><p id="2164" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">上面的例子展示了用几行代码就可以组合几个不相关的 Julia 包，从而创建新的有用的功能。</p><p id="556a" class="pw-post-body-paragraph lx ly iq lz b ma mw ka mc md mx kd mf mg nx mi mj mk ny mm mn mo nz mq mr ms ij bi translated">尤其是第二个例子(“<em class="mt">微调</em> …”)，当然在(内存)效率和模块化/重用方面有一些优化的潜力。但是这也可以通过稍微多一点的努力来完成。</p><h1 id="a766" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">进一步的信息</h1><p id="de20" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">在 GitHub 上(在:<a class="ae le" href="https://github.com/roland-KA/JuliaForMLTutorial" rel="noopener ugc nofollow" target="_blank">Roland-KA/juliaformtutorial</a>)我提供了本教程所有三个部分的 Pluto 笔记本，并附有完整的代码示例。所以每个人都被邀请亲自尝试一下。</p></div></div>    
</body>
</html>