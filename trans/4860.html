<html>
<head>
<title>How to Find the Best Wordle First Combination Words with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python找到最佳的Wordle首组合词</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-find-the-best-wordle-first-combination-words-with-python-ded4b0679a5#2022-10-28">https://towardsdatascience.com/how-to-find-the-best-wordle-first-combination-words-with-python-ded4b0679a5#2022-10-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="99dd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">搜索最佳的第一和第二单词组合</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ac651220c95203507bd21c123073c35c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Rc0WtBAnE5W48JXA"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">尼尔斯·胡内尔弗斯特在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6da6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">玩Wordle时，找到正确的字母通常是由第一个单词决定的。第一个单词越有效，我们就能得到越多的线索来把字母拼对。通常，每个人都有自己的偏好。</p><p id="3a91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于那些不知道的人来说，wordle是一个由Josh Wardle创建的日常文字游戏，每天都会有一个新的文字难题需要解决。想了解更多，你可以去https://www.nytimes.com/games/wordle/index.html的<a class="ae ky" href="https://www.nytimes.com/games/wordle/index.html" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="a663" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将寻找一个解决方案来使用python获得最好的第一个单词。这里我只使用基本的统计方法，以便于大家理解。</p><p id="bbac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将这篇文章分为4个部分，即:</p><ol class=""><li id="38e1" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">搜索第一个单词</li><li id="7ce7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">寻找第二个词</li><li id="b5bf" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">寻找第一个和第二个单词的组合</li><li id="2c17" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">寻找最佳组合</li></ol></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="5127" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">搜索第一个单词</h1><p id="d8f1" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我使用了一个来自Donald E. Knuth的《计算机编程艺术》(TAOCP)<a class="ae ky" href="https://www-cs-faculty.stanford.edu/~knuth/taocp.html" rel="noopener ugc nofollow" target="_blank"><em class="nn"/></a><em class="nn"/>的 数据集。数据集包含由5个字母(根据wordle上的字母限制)组成的英语单词，总共5757个单词。</p><blockquote class="no np nq"><p id="e19d" class="kz la nn lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi translated"><strong class="lb iu">引用</strong>:以上数据集来自唐纳德·e·克努特教授。斯坦福大学计算机编程艺术荣誉退休教授。</p></blockquote><p id="1775" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我做的第一件事是导入依赖项并加载数据集文件。</p><pre class="kj kk kl km gt nu nv nw bn nx ny bi"><span id="8fe3" class="nz mr it nv b be oa ob l oc od">import pandas as pd<br/>import numpy as np<br/>import math</span></pre><pre class="oe nu nv nw bn nx ny bi"><span id="ab0b" class="nz mr it nv b be oa ob l oc od">words = []<br/>with open('sgb-words.txt') as f:<br/>    words = [line.rstrip() for line in f]</span></pre><p id="c2ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据集包含以下数据。</p><pre class="kj kk kl km gt nu nv nw bn nx ny bi"><span id="c56c" class="nz mr it nv b be oa ob l oc od">which<br/>there<br/>their<br/>about<br/>would<br/>...<br/>pupal</span></pre><p id="40f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个处理是通过删除每个单词中的相同字母来完成的。这是必要的，这样我们可以得到一个有5个不同字母的单词。方法如下。</p><pre class="kj kk kl km gt nu nv nw bn nx ny bi"><span id="7894" class="nz mr it nv b be oa ob l oc od">distinct_words = []<br/>for word in words:<br/>    distinct_words.append(list(set(word)))py</span></pre><p id="22ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果会是这样的。</p><pre class="kj kk kl km gt nu nv nw bn nx ny bi"><span id="6d70" class="nz mr it nv b be oa ob l oc od">[['w', 'h', 'i', 'c'],<br/>['t', 'h', 'e', 'r'],<br/>['t', 'h', 'e', 'i', 'r'],<br/>['a', 'b', 'o', 'u', 't'],<br/>['w', 'o', 'u', 'l', 'd'],<br/>...<br/>['p', 'u', 'a', 'l']]</span></pre><p id="4616" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们可以得到每个字母的重量。方法很简单，就是把每个字母加起来，结果以字典的形式呈现出来。权重将决定字母出现的频率，字母出现的越频繁，字母的权重越大。</p><pre class="kj kk kl km gt nu nv nw bn nx ny bi"><span id="78a9" class="nz mr it nv b be oa ob l oc od">letter_counter = {}<br/>for word in distinct_words:<br/>    for letter in word:<br/>        if letter in letter_counter:<br/>            letter_counter[letter] += 1<br/>        else:<br/>            letter_counter[letter] = 0py</span></pre><p id="8200" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果会是这样的。</p><pre class="kj kk kl km gt nu nv nw bn nx ny bi"><span id="7d5d" class="nz mr it nv b be oa ob l oc od">{'h': 790,<br/> 'w': 500,<br/> 'i': 1538,<br/> 'c': 919,<br/> 'e': 2657,<br/> 't': 1461,<br/> 'r': 1798,<br/> 'u': 1067,<br/> 'a': 2180,<br/> 'o': 1682,<br/> 'b': 668,<br/> 'l': 1433,<br/> 'd': 1099,<br/> 's': 2673,<br/> 'f': 501,<br/> 'g': 650,<br/> 'k': 573,<br/> 'n': 1218,<br/> 'y': 867,<br/> 'p': 894,<br/> 'v': 308,<br/> 'm': 793,<br/> 'q': 52,<br/> 'j': 87,<br/> 'x': 137,<br/> 'z': 120}</span></pre><p id="1627" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果排序，结果会是这样的。</p><pre class="kj kk kl km gt nu nv of og aw oh bi"><span id="f90e" class="oi mr it nv b gy oj ok l ol od">&gt;&gt;&gt; {key: val for key, val in sorted(letter_counter.items(), key = lambda x: x[1], reverse = True)}</span><span id="504b" class="oi mr it nv b gy om ok l ol od">{'s': 2673,<br/> 'e': 2657,<br/> 'a': 2180,<br/> 'r': 1798,<br/> 'o': 1682,<br/> 'i': 1538,<br/> 't': 1461,<br/> 'l': 1433,<br/> 'n': 1218,<br/> 'd': 1099,<br/> 'u': 1067,<br/> 'c': 919,<br/> 'p': 894,<br/> 'y': 867,<br/> 'm': 793,<br/> 'h': 790,<br/> 'b': 668,<br/> 'g': 650,<br/> 'k': 573,<br/> 'f': 501,<br/> 'w': 500,<br/> 'v': 308,<br/> 'x': 137,<br/> 'z': 120,<br/> 'j': 87,<br/> 'q': 52}</span></pre><p id="ca9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这些结果可以看出，出现频率最高的5个字母是<code class="fe on oo op nv b">s</code>、<code class="fe on oo op nv b">e</code>、<code class="fe on oo op nv b">a</code>、<code class="fe on oo op nv b">r</code>和<code class="fe on oo op nv b">o</code>。</p><p id="9f88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，这是以百分比表示的结果。</p><pre class="kj kk kl km gt nu nv of og aw oh bi"><span id="fb29" class="oi mr it nv b gy oj ok l ol od">&gt;&gt;&gt; values = letter_counter.values()<br/>&gt;&gt;&gt; total = sum(values)<br/>&gt;&gt;&gt; percent = [value * 100. / total for value in values]<br/>&gt;&gt;&gt; for i, letter in enumerate(letter_counter.keys()):<br/>...    print("{}: {}".format(letter, percent[i]))</span><span id="07c6" class="oi mr it nv b gy om ok l ol od">h: 2.962685167822989<br/>w: 1.8751171948246765<br/>i: 5.767860491280705<br/>c: 3.4464654040877556<br/>e: 9.964372773298331<br/>t: 5.479092443277705<br/>r: 6.742921432589537<br/>u: 4.00150009375586<br/>a: 8.17551096943559<br/>o: 6.307894243390212<br/>b: 2.505156572285768<br/>l: 5.374085880367523<br/>d: 4.121507594224639<br/>s: 10.024376523532721<br/>f: 1.878867429214326<br/>g: 2.4376523532720795<br/>k: 2.148884305269079<br/>n: 4.567785486592912<br/>y: 3.2514532158259892<br/>p: 3.3527095443465216<br/>v: 1.1550721920120008<br/>m: 2.973935870991937<br/>q: 0.19501218826176636<br/>j: 0.3262703918994937<br/>x: 0.5137821113819614</span></pre><p id="737a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们只需要找到字母权重最高的单词。方法如下。</p><pre class="kj kk kl km gt nu nv of og aw oh bi"><span id="dded" class="oi mr it nv b gy oj ok l ol od">word_values = []<br/>for word in distinct_words:<br/>    temp_value = 0<br/>    for letter in word:<br/>        temp_value += letter_counter[letter]<br/>    word_values.append(temp_value)<br/>words[np.argmax(word_values)]</span></pre><p id="f2f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而结果是<code class="fe on oo op nv b">arose</code>。如果从上面的数据来看，可以看到单词<code class="fe on oo op nv b">arose </code>的字母具有很高的权重。因此，根据统计结果，我们可以得出结论，单词<code class="fe on oo op nv b">arose </code>是用在单词的第一个单词中的最佳单词。</p><blockquote class="no np nq"><p id="05fe" class="kz la nn lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi translated">但是仅仅第一个词就够了吗？</p></blockquote><p id="b453" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时候我们需要多一个字才能得到足够的线索。因此，我们将搜索另一个词。</p><h1 id="7c28" class="mq mr it bd ms mt oq mv mw mx or mz na jz os ka nc kc ot kd ne kf ou kg ng nh bi translated">寻找第二个词</h1><p id="0556" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在我们得到第一个单词后，下一步是得到第一个单词中不包含字母的单词列表。比如我们得到的第一个词是<code class="fe on oo op nv b">arose</code>。所以数据集中的单词列表不能包含字母<code class="fe on oo op nv b">a</code>、<code class="fe on oo op nv b">r</code>、<code class="fe on oo op nv b">o</code>、<code class="fe on oo op nv b">s</code>和<code class="fe on oo op nv b">e</code>。如果有一个单词包含这些字母，那么这个单词将从列表中删除。方法如下。</p><pre class="kj kk kl km gt nu nv of og aw oh bi"><span id="bd3c" class="oi mr it nv b gy oj ok l ol od">result_word = []<br/>first_word_list = list(set(best_word))for word in words:<br/>    in_word = False<br/>    i = 0<br/>    while i &lt; len(first_word_list) and not in_word:<br/>        if first_word_list[i] in word:<br/>            in_word = True<br/>        i += 1<br/>    if not in_word:<br/>        result_word.append(word)</span></pre><p id="94aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果如下。</p><pre class="kj kk kl km gt nu nv of og aw oh bi"><span id="ceeb" class="oi mr it nv b gy oj ok l ol od">['which',<br/>'think',<br/>'might',<br/>'until',<br/>...<br/>'biffy']</span></pre><p id="5c4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">字数由之前的5757字缩减到310字。只剩下5%左右的单词了。</p><p id="78e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是我们将重复这个过程，就像我们搜索第一个单词一样。完整的代码如下。</p><pre class="kj kk kl km gt nu nv of og aw oh bi"><span id="84f0" class="oi mr it nv b gy oj ok l ol od">import pandas as pd<br/>import numpy as np<br/>import math</span><span id="350c" class="oi mr it nv b gy om ok l ol od">def best_words(words):<br/>    distinct_words = []<br/>    for word in words:<br/>        distinct_words.append(list(set(word)))<br/>    letter_counter = {}<br/>    for word in distinct_words:<br/>        for letter in word:<br/>            if letter in letter_counter:<br/>                letter_counter[letter] += 1<br/>            else:<br/>                letter_counter[letter] = 0<br/>    word_values = []<br/>    for word in distinct_words:<br/>        temp_value = 0<br/>        for letter in word:<br/>            temp_value += letter_counter[letter]<br/>        word_values.append(temp_value)<br/>    return word_values</span><span id="76ca" class="oi mr it nv b gy om ok l ol od">def get_best_word(words, word_values):<br/>    return words[np.argmax(word_values)]</span><span id="071d" class="oi mr it nv b gy om ok l ol od">def remove_word_contain_letters(words, first_word):<br/>    result_word = []<br/>    first_word_list = list(set(first_word))<br/>    <br/>    for word in words:<br/>        in_word = False<br/>        i = 0<br/>        while i &lt; len(first_word_list) and not in_word:<br/>            if first_word_list[i] in word:<br/>                in_word = True<br/>            i += 1<br/>        if not in_word:<br/>            result_word.append(word)<br/>    return result_word</span><span id="f467" class="oi mr it nv b gy om ok l ol od">words = []<br/>with open('sgb-words.txt') as f:<br/>    words = [line.rstrip() for line in f]</span><span id="afb1" class="oi mr it nv b gy om ok l ol od">word_values = best_words(words)<br/>first_word = get_best_word(words, word_values)<br/>second_words = remove_word_contain_letters(words, first_word)<br/>second_values = best_words(second_words)<br/>second_word = get_best_word(second_words, second_values)</span><span id="01c8" class="oi mr it nv b gy om ok l ol od">print(first_word)  # first word<br/>print(second_word)  # second word</span></pre><p id="d3b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个和第二个单词的结果是<code class="fe on oo op nv b">arose</code>和<code class="fe on oo op nv b">unity</code>。</p><p id="8875" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的方法可以得出结论，<code class="fe on oo op nv b">arose</code>和<code class="fe on oo op nv b">unity</code>是开始Wordle游戏的最佳单词。但如果我们看一下上一篇帖子的字母数量统计，可以看出<code class="fe on oo op nv b">u</code>和<code class="fe on oo op nv b">y</code>这两个字母并不在使用最多的前10个字母中。这表明，<code class="fe on oo op nv b">arose</code>和<code class="fe on oo op nv b">unity</code>这两个词可能不是最合适的词。</p><h1 id="050e" class="mq mr it bd ms mt oq mv mw mx or mz na jz os ka nc kc ot kd ne kf ou kg ng nh bi translated">寻找第一个和第二个单词的组合</h1><p id="eb81" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在这一节中，我们将讨论，以便我们可以得到两个单词，它们的字母都是出现频率最高的字母。</p><p id="a99f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只需要重复我们以前做过的过程。如果在之前的过程中我们只使用了具有最佳值的第一个单词，那么现在我们也使用第二好的单词作为第一个单词，这样我们可以得到更多的结果变化。</p><p id="1a00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">步骤如下。</p><p id="dc6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一种方法是计算所有单词的值，然后根据值对单词进行排序。</p><pre class="kj kk kl km gt nu nv of og aw oh bi"><span id="7cb3" class="oi mr it nv b gy oj ok l ol od">values = best_words(words)<br/>values_index = np.argsort(values)[::-1]</span></pre><p id="bf33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们将像以前一样搜索第一个和第二个单词。不同的是，这里我们将继续循环查找第一个和第二个单词的组合，以便产生具有最佳值的单词。</p><pre class="kj kk kl km gt nu nv of og aw oh bi"><span id="7c49" class="oi mr it nv b gy oj ok l ol od">best_val = 0<br/>best_word_list = []<br/>top_words = sorted(values, reverse=True)</span><span id="b0e8" class="oi mr it nv b gy om ok l ol od">for i, idx in enumerate(values_index):<br/>    best_word = words[idx]<br/>    second_words = remove_word_contain_letters(words, best_word)<br/>    second_values = best_words(second_words)<br/>    second_best_word = get_best_word(second_words, second_values)<br/>    temp_value = 0<br/>    for letter in second_best_word:<br/>        temp_value += letter_counter[letter]<br/>    if temp_value + top_words[i] &gt;= best_val:<br/>        best_val = temp_value + top_words[i]<br/>        print(best_word, second_best_word, top_words[i] + temp_value)</span></pre><p id="6aeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果是这样的。</p><pre class="kj kk kl km gt nu nv of og aw oh bi"><span id="adfb" class="oi mr it nv b gy oj ok l ol od">arose unity 17141<br/>tears doily 17388<br/>stare doily 17388<br/>tares doily 17388<br/>rates doily 17388<br/>aster doily 17388<br/>tales irony 17507<br/>taels irony 17507<br/>stale irony 17507<br/>least irony 17507<br/>tesla irony 17507<br/>steal irony 17507<br/>slate irony 17507<br/>teals irony 17507<br/>stela irony 17507<br/>store inlay 17507<br/>lores antic 17559<br/>...<br/>laird stone 17739<br/>adorn tiles 17739<br/>radon tiles 17739<br/>tonal rides 17739<br/>talon rides 17739<br/>lined roast 17739<br/>intro leads 17739<br/>nitro leads 17739<br/>nodal tries 17739</span></pre><p id="7731" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这些结果来看，第一列是第一个字，第二列是第二个字，第三列是第一个字和第二个字的值之和。</p><p id="4cf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果看上面的结果，<code class="fe on oo op nv b">arose</code>和<code class="fe on oo op nv b">unity</code>这两个词并不是价值最大的词组合。此外，有许多单词组合会获得值17739，如果您注意单词组合中获得该值的所有字母，则是在数据集中出现最多的十个字母。所以可以得出结论，得到值17739的单词组合是我们能得到的最高单词组合。</p><blockquote class="no np nq"><p id="e7e7" class="kz la nn lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi translated">但是哪个是最佳的单词组合呢？</p></blockquote><p id="e330" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了得到这个问题的答案，我们需要根据字母的位置知道它们的重量。</p><h1 id="83e1" class="mq mr it bd ms mt oq mv mw mx or mz na jz os ka nc kc ot kd ne kf ou kg ng nh bi translated">寻找最佳组合</h1><p id="2535" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">现在，我们将寻找最佳单词组合，作为Wordle游戏中的第一个和第二个单词。接下来我们需要做的是计算每个位置的字母权重。方法如下。</p><pre class="kj kk kl km gt nu nv of og aw oh bi"><span id="3f5a" class="oi mr it nv b gy oj ok l ol od">letter_list =['r', 'o', 'a', 's', 't', 'l', 'i', 'n', 'e', 's']<br/>letter_value = {}</span><span id="5eac" class="oi mr it nv b gy om ok l ol od">for letter in letter_list:<br/>    letter_counter = {}<br/>    for i in range(len(letter_list)//2):<br/>        loc_counter = 0<br/>        for j in range(len(words)):<br/>            if words[j][i] == letter:<br/>                loc_counter += 1<br/>        letter_counter[str(i)] = loc_counter<br/>    letter_value[letter] = letter_counter</span></pre><p id="3b40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变量<code class="fe on oo op nv b">letter_list</code>由出现次数最多的字母组成。之后，我们将从数据集中的所有单词中统计这些字母在单词的开头出现了多少次，依此类推。</p><p id="a807" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe on oo op nv b">letter_value</code>的内容如下。</p><pre class="kj kk kl km gt nu nv of og aw oh bi"><span id="8489" class="oi mr it nv b gy oj ok l ol od">{'r': {'0': 268, '1': 456, '2': 475, '3': 310, '4': 401},<br/> 'o': {'0': 108, '1': 911, '2': 484, '3': 262, '4': 150},<br/> 'a': {'0': 296, '1': 930, '2': 605, '3': 339, '4': 178},<br/> 's': {'0': 724, '1': 40, '2': 248, '3': 257, '4': 1764},<br/> 't': {'0': 376, '1': 122, '2': 280, '3': 447, '4': 360},<br/> 'l': {'0': 271, '1': 360, '2': 388, '3': 365, '4': 202},<br/> 'i': {'0': 74, '1': 673, '2': 516, '3': 284, '4': 45},<br/> 'n': {'0': 118, '1': 168, '2': 410, '3': 386, '4': 203},<br/> 'e': {'0': 129, '1': 660, '2': 397, '3': 1228, '4': 595}}</span></pre><p id="888f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些结果解释了，例如，字母<code class="fe on oo op nv b">r</code>作为第一个字母出现了268次，第二个字母出现了456次，等等。所以我们可以得到每个位置的值。</p><p id="1cd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将使用<code class="fe on oo op nv b">letter_value</code>来计算我们之前得到的单词组合的权重。方法如下。</p><pre class="kj kk kl km gt nu nv of og aw oh bi"><span id="a284" class="oi mr it nv b gy oj ok l ol od">result_list = []<br/>for i in range(len(best_word_list)):<br/>    word_value = 0<br/>    for word in best_word_list[i]:<br/>        for j, letter in enumerate(word):<br/>            if letter in letter_value:<br/>                word_value += letter_value[letter][str(j)]<br/>    result_list.append(word_value)</span></pre><p id="750d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是结果。</p><pre class="kj kk kl km gt nu nv of og aw oh bi"><span id="3963" class="oi mr it nv b gy oj ok l ol od">for i in range(len(result_list)):<br/>    print(best_word_list[i], result_list[i])</span><span id="1e37" class="oi mr it nv b gy om ok l ol od">=== result ===</span><span id="7b84" class="oi mr it nv b gy om ok l ol od">['arose', 'unity'] 3219<br/>['tears', 'doily'] 5507<br/>['stare', 'doily'] 4148<br/>['tares', 'doily'] 6565<br/>...<br/>['lined', 'roast'] 4983<br/>['intro', 'leads'] 4282<br/>['nitro', 'leads'] 4831<br/>['nodal', 'tries'] 5910</span></pre><p id="7f14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了获得最佳的值组合，我们可以输入下面的语法。</p><pre class="kj kk kl km gt nu nv of og aw oh bi"><span id="5b41" class="oi mr it nv b gy oj ok l ol od">result_index = np.argsort(result_list)[::-1]<br/>best_word_list[result_index[0]]</span></pre><p id="80d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而最好的单词组合是<code class="fe on oo op nv b">toned</code>和<code class="fe on oo op nv b">rails</code>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="8ae1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，这是Wordle首次使用Python系列进行单词搜索的完整代码。</p><pre class="kj kk kl km gt nu nv nw bn nx ny bi"><span id="0483" class="nz mr it nv b be oa ob l oc od">import pandas as pd<br/>import numpy as np<br/>import math</span></pre><pre class="oe nu nv nw bn nx ny bi"><span id="2eee" class="nz mr it nv b be oa ob l oc od">def best_words(words):<br/>    distinct_words = []<br/>    for word in words:<br/>        distinct_words.append(list(set(word)))<br/>    letter_counter = {}<br/>    for word in distinct_words:<br/>        for letter in word:<br/>            if letter in letter_counter:<br/>                letter_counter[letter] += 1<br/>            else:<br/>                letter_counter[letter] = 0<br/>    word_values = []<br/>    for word in distinct_words:<br/>        temp_value = 0<br/>        for letter in word:<br/>            temp_value += letter_counter[letter]<br/>        word_values.append(temp_value)<br/>    return word_values</span></pre><pre class="oe nu nv nw bn nx ny bi"><span id="0405" class="nz mr it nv b be oa ob l oc od">def get_best_word(words, word_values):<br/>    return words[np.argmax(word_values)]</span></pre><pre class="oe nu nv nw bn nx ny bi"><span id="8720" class="nz mr it nv b be oa ob l oc od">def remove_word_contain_letters(words, first_word):<br/>    result_word = []<br/>    first_word_list = list(set(first_word))<br/>    <br/>    for word in words:<br/>        in_word = False<br/>        i = 0<br/>        while i &lt; len(first_word_list) and not in_word:<br/>            if first_word_list[i] in word:<br/>                in_word = True<br/>            i += 1<br/>        if not in_word:<br/>            result_word.append(word)<br/>    return result_word</span></pre><pre class="oe nu nv nw bn nx ny bi"><span id="4888" class="nz mr it nv b be oa ob l oc od">words = []<br/>with open('sgb-words.txt') as f:<br/>    words = [line.rstrip() for line in f]<br/>    <br/>distinct_words = []<br/>for word in words:<br/>    distinct_words.append(list(set(word)))<br/>letter_counter = {}<br/>for word in distinct_words:<br/>    for letter in word:<br/>        if letter in letter_counter:<br/>            letter_counter[letter] += 1<br/>        else:<br/>            letter_counter[letter] = 0</span></pre><pre class="oe nu nv nw bn nx ny bi"><span id="1036" class="nz mr it nv b be oa ob l oc od">word_values = best_words(words)<br/>first_word = get_best_word(words, word_values)<br/>second_words = remove_word_contain_letters(words, first_word)<br/>second_values = best_words(second_words)<br/>second_word = get_best_word(second_words, second_values)</span></pre><pre class="oe nu nv nw bn nx ny bi"><span id="b412" class="nz mr it nv b be oa ob l oc od">values = best_words(words)<br/>values_index = np.argsort(values)[::-1]</span></pre><pre class="oe nu nv nw bn nx ny bi"><span id="15bf" class="nz mr it nv b be oa ob l oc od">best_val = 0<br/>best_word_list = []<br/>top_words = sorted(values, reverse=True)</span></pre><pre class="oe nu nv nw bn nx ny bi"><span id="d314" class="nz mr it nv b be oa ob l oc od">for i, idx in enumerate(values_index):<br/>    best_word = words[idx]<br/>    second_words = remove_word_contain_letters(words, best_word)<br/>    second_values = best_words(second_words)<br/>    second_best_word = get_best_word(second_words, second_values)<br/>    temp_value = 0<br/>    for letter in second_best_word:<br/>        temp_value += letter_counter[letter]<br/>    if temp_value + top_words[i] &gt;= best_val:<br/>        best_val = temp_value + top_words[i]<br/>        best_word_list.append([best_word, second_best_word])<br/>        <br/>letter_list =['r', 'o', 'a', 's', 't', 'l', 'i', 'n', 'e', 's']<br/>letter_value = {}</span></pre><pre class="oe nu nv nw bn nx ny bi"><span id="30a1" class="nz mr it nv b be oa ob l oc od">for letter in letter_list:<br/>    letter_counter = {}<br/>    for i in range(len(letter_list)//2):<br/>        loc_counter = 0<br/>        for j in range(len(words)):<br/>            if words[j][i] == letter:<br/>                loc_counter += 1<br/>        letter_counter[str(i)] = loc_counter<br/>    letter_value[letter] = letter_counter<br/>    <br/>result_list = []<br/>for i in range(len(best_word_list)):<br/>    word_value = 0<br/>    for word in best_word_list[i]:<br/>        for j, letter in enumerate(word):<br/>            if letter in letter_value:<br/>                word_value += letter_value[letter][str(j)]<br/>    result_list.append(word_value)</span></pre><pre class="oe nu nv nw bn nx ny bi"><span id="b0ab" class="nz mr it nv b be oa ob l oc od">result_index = np.argsort(result_list)[::-1]<br/>print(best_word_list[result_index[0]])</span></pre><p id="9a48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以得出结论，单词<code class="fe on oo op nv b">toned</code>和<code class="fe on oo op nv b">rails</code>是开始一个Wordle游戏的最佳单词组合。除了单词组合中的字母是在数据集中出现最多的字母之外，这些字母还被放置在具有最高值的位置。</p><p id="cf3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答案可能不是完全最优的，因为它只依赖于统计数据，而没有考虑其他因素。如果你有其他方法来获得Wordle游戏中的最优单词，请在评论中写下。</p></div></div>    
</body>
</html>