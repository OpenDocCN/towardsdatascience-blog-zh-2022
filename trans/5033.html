<html>
<head>
<title>Is Julia Really Faster than Python and Numpy?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Julia真的比Python和Numpy快吗？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/is-julia-really-faster-than-python-and-numpy-242e0a5fe34f#2022-11-09">https://towardsdatascience.com/is-julia-really-faster-than-python-and-numpy-242e0a5fe34f#2022-11-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="7de0" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">最佳化</h2><div class=""/><div class=""><h2 id="6bfd" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">C的速度和Python的简单性</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/4e8660f63d66f0b6235763dd0298f6c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eFlarMgCSRWHa7_Tztotxg.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">cottonbro工作室拍摄的照片</p></figure><p id="73ea" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> Python，连同numpy/pandas库，基本上已经成为数据科学专业的首选语言(…我将在这里快速添加一个R)。</strong></p><p id="d56d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">然而，众所周知，Python虽然快速且易于实现，却是一种缓慢的语言。因此需要像numpy这样优秀的库来提高效率…但是如果有更好的选择呢？</strong></p><p id="3546" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Julia声称使用起来至少和Python一样简单和直观，同时执行起来要快得多。让我们来验证一下这个说法……</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="0e32" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">朱莉娅是什么？</h1><p id="543b" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">万一你不知道朱莉娅是什么，这里有一个快速入门。</p><p id="2c54" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Julia 是一种开放源代码语言，它是动态类型的，直观的，像Python一样易于使用，但具有像c语言一样的执行速度。</p><p id="10fe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它已经存在了大约10年(诞生于2012年)，所以它是一种相对较新的语言。然而，它正处于一个成熟的阶段，你不会称之为时尚。</p><p id="8f1d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">语言的原创者活跃在相关的工作领域:</p><blockquote class="ni nj nk"><p id="e9f3" class="li lj nl lk b ll lm kd ln lo lp kg lq nm ls lt lu nn lw lx ly no ma mb mc md im bi translated">对于我们所做的工作—科学计算、机器学习、数据挖掘、大规模线性代数、分布式和并行计算— …</p><p id="29e3" class="li lj nl lk b ll lm kd ln lo lp kg lq nm ls lt lu nn lw lx ly no ma mb mc md im bi translated">——<a class="ae lh" href="https://julialang.org/blog/2012/02/why-we-created-julia/" rel="noopener ugc nofollow" target="_blank">julialang.org</a>——杰夫·贝赞森、斯特凡·卡尔平斯基、维尔卡·b·沙阿、艾伦·埃德尔曼</p></blockquote><p id="1d7e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">总而言之，它是一门<strong class="lk jd">专门设计用于数据科学领域的现代语言</strong>。创作者本身的目标告诉你很多:</p><blockquote class="ni nj nk"><p id="73b4" class="li lj nl lk b ll lm kd ln lo lp kg lq nm ls lt lu nn lw lx ly no ma mb mc md im bi translated">我们想要C的速度和Ruby的活力。我们想要一种同形异义的语言，既有像Lisp那样的真正的宏，又有像Matlab那样明显、熟悉的数学符号。我们想要像Python一样可用于一般编程，像R一样易于统计，像Perl一样自然用于字符串处理，像Matlab一样强大用于线性代数，像shell一样善于将程序粘合在一起。这种东西学习起来非常简单，却能让最严肃的黑客感到高兴。我们希望它是交互式的，我们希望它是编译过的。</p><p id="5a99" class="li lj nl lk b ll lm kd ln lo lp kg lq nm ls lt lu nn lw lx ly no ma mb mc md im bi translated">(我们有没有提到它应该和C一样快？)</p><p id="5d66" class="li lj nl lk b ll lm kd ln lo lp kg lq nm ls lt lu nn lw lx ly no ma mb mc md im bi translated">——<a class="ae lh" href="https://julialang.org/blog/2012/02/why-we-created-julia/" rel="noopener ugc nofollow" target="_blank">julialang.org</a>——杰夫·贝赞森、斯特凡·卡尔平斯基、维拉尔·b·沙阿、艾伦·埃德尔曼</p></blockquote><p id="8275" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">听起来很刺激，对吧？</p><h1 id="3b20" class="ml mm it bd mn mo np mq mr ms nq mu mv ki nr kj mx kl ns km mz ko nt kp nb nc bi translated">速度测试的基础</h1><p id="2772" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">我以前写过一篇文章，讨论使用Python中的numpy库进行矢量化:</p><div class="nu nv gp gr nw nx"><a rel="noopener follow" target="_blank" href="/how-to-speedup-data-processing-with-numpy-vectorization-12acac71cfca"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd jd gy z fp oc fr fs od fu fw jc bi translated">如何用Numpy矢量化加速数据处理</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">比普通功能快8000倍</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">towardsdatascience.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol lb nx"/></div></div></a></div><p id="a13e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">本文将要进行的速度测试基本上是本文的扩展/比较。</p><h1 id="a8ff" class="ml mm it bd mn mo np mq mr ms nq mu mv ki nr kj mx kl ns km mz ko nt kp nb nc bi translated">测试将如何进行？</h1><p id="4756" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">将在简单数学语句的执行速度之间进行比较:</p><p id="4136" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">功能1 —简单求和</strong></p><pre class="ks kt ku kv gt om on oo op aw oq bi"><span id="6a44" class="or mm it on b gy os ot l ou ov">#Python</span><span id="6f90" class="or mm it on b gy ow ot l ou ov">def sum_nums(a, b):<br/>    return a + b</span><span id="5b7a" class="or mm it on b gy ow ot l ou ov">#Julia</span><span id="0062" class="or mm it on b gy ow ot l ou ov">function sum_nums(x,y)<br/>    x + y<br/>end</span></pre><p id="f75a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">和更复杂的条件语句:</p><p id="7eb1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">功能2 —更复杂(逻辑和算术)</strong></p><pre class="ks kt ku kv gt om on oo op aw oq bi"><span id="33aa" class="or mm it on b gy os ot l ou ov">#Python</span><span id="7205" class="or mm it on b gy ow ot l ou ov">def categorise(a, b):<br/>    if a &lt; 0:<br/>        return a * 2 + b<br/>    elif b &lt; 0:<br/>        return a + 2 * b<br/>    else:<br/>        return None</span><span id="79b3" class="or mm it on b gy ow ot l ou ov">#Julia</span><span id="77db" class="or mm it on b gy ow ot l ou ov">function categorise(a, b)::Float32<br/>    if a &lt; 0<br/>        return a * 2 + b<br/>    elseif b &lt; 0<br/>        return a + 2 * b<br/>    else<br/>        return 0<br/>    end<br/>end</span></pre><p id="8591" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当通过以下方法运行时:</p><ol class=""><li id="88cb" class="ox oy it lk b ll lm lo lp lr oz lv pa lz pb md pc pd pe pf bi translated">Python- pandas.itertuples()</li><li id="6836" class="ox oy it lk b ll pg lo ph lr pi lv pj lz pk md pc pd pe pf bi translated">Python列表理解</li><li id="05e6" class="ox oy it lk b ll pg lo ph lr pi lv pj lz pk md pc pd pe pf bi translated">Python- numpy.vectorize()</li><li id="4176" class="ox oy it lk b ll pg lo ph lr pi lv pj lz pk md pc pd pe pf bi translated">Python-原生熊猫方法</li><li id="d136" class="ox oy it lk b ll pg lo ph lr pi lv pj lz pk md pc pd pe pf bi translated">Python- native numpy方法</li><li id="cea8" class="ox oy it lk b ll pg lo ph lr pi lv pj lz pk md pc pd pe pf bi translated">朱莉娅-本土方法</li></ol><h1 id="5426" class="ml mm it bd mn mo np mq mr ms nq mu mv ki nr kj mx kl ns km mz ko nt kp nb nc bi translated">本文的笔记本</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pl"><img src="../Images/296ee277e2a43aebe95fff2878a7d7a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oI7R1PaLmnUMbx3Zzf_bCg.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://www.pexels.com/photo/white-spiral-notebook-beside-orange-pencil-544115/" rel="noopener ugc nofollow" target="_blank">蒂拉查德·库姆塔农</a>拍摄</p></figure><p id="0726" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上一篇文章包括一个用Python写的Jupyter笔记本。我从上一篇文章中取出了这个笔记本(没有改变)，并使用利用Python 3.10的<a class="ae lh" href="https://deepnote.com/" rel="noopener ugc nofollow" target="_blank"> deepnote </a>实例重新运行它。</p><p id="91b6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Python运行和Julia运行的deepnote实例都有<strong class="lk jd">完全相同的</strong>基本CPU实例(即硬件)。这确保了本文包含的计时结果是直接可比的。</p><p id="882a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="nl">注意:</em> </strong> <em class="nl">我已经确保在每台笔记本电脑中都包含CPU信息，这样您就可以看到使用了什么确切的硬件，并且它们实际上完全相同。</em></p><h2 id="b0a5" class="or mm it bd mn pm pn dn mr po pp dp mv lr pq pr mx lv ps pt mz lz pu pv nb iz bi translated">运行朱莉娅笔记本</h2><p id="fd19" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">值得注意的是，无论你是希望像我一样使用<a class="ae lh" href="https://deepnote.com/" rel="noopener ugc nofollow" target="_blank"> deepnote </a>中的笔记本，还是使用<a class="ae lh" href="https://colab.research.google.com/" rel="noopener ugc nofollow" target="_blank"> colab </a>中的笔记本，你都需要在各自的环境中设置Julia。这主要是因为大多数公共在线实例目前只为Python设置(至少是现成的)。</p><h2 id="fd48" class="or mm it bd mn pm pn dn mr po pp dp mv lr pq pr mx lv ps pt mz lz pu pv nb iz bi translated">环境设置</h2><p id="7852" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated"><strong class="lk jd">深注</strong></p><p id="afeb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于deepnote使用了docker实例，你可以很容易地建立一个“本地”docker文件来包含Julia的安装说明。这意味着你不必像在Colab中那样用安装代码污染Jupyter笔记本。</p><p id="42ab" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在环境部分选择“本地”。/Dockerfile "。这将打开实际的docker文件，您应该在其中添加以下内容:</p><pre class="ks kt ku kv gt om on oo op aw oq bi"><span id="9db5" class="or mm it on b gy os ot l ou ov">FROM deepnote/python:3.10</span><span id="3bc7" class="or mm it on b gy ow ot l ou ov">RUN wget https://julialang-s3.julialang.org/bin/linux/x64/1.8/julia-1.8.2-linux-x86_64.tar.gz &amp;&amp; \<br/>    tar -xvzf julia-1.8.2-linux-x86_64.tar.gz &amp;&amp; \<br/>    mv julia-1.8.2 /usr/lib/ &amp;&amp; \<br/>    ln -s /usr/lib/julia-1.8.2/bin/julia /usr/bin/julia &amp;&amp; \<br/>    rm julia-1.8.2-linux-x86_64.tar.gz &amp;&amp; \<br/>    julia  -e "using Pkg;pkg\"add IJulia\""</span><span id="b668" class="or mm it on b gy ow ot l ou ov">ENV DEFAULT_KERNEL_NAME "julia-1.8"</span></pre><p id="97ad" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以从<a class="ae lh" href="https://julialang.org/downloads/" rel="noopener ugc nofollow" target="_blank">这个</a>页面把上面的更新到最新的Julia版本，但是在编写的时候1.8.2是最新的版本。</p><p id="916f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> Colab </strong></p><p id="9cad" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于colab，所有的下载和安装代码都必须包含在笔记本本身中，并且在安装代码运行后刷新页面。</p><p id="34a2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">幸运的是，<a class="ae lh" href="https://github.com/ageron" rel="noopener ugc nofollow" target="_blank">aurélien Geron</a>(…我发现这里的一些人会熟悉这个名字)已经在他的GitHub上为colab的Julia提供了一个<a class="ae lh" href="https://colab.research.google.com/github/ageron/julia_notebooks/blob/master/Julia_Colab_Notebook_Template.ipynb" rel="noopener ugc nofollow" target="_blank">入门笔记本</a>，这可能是最好的入门方式。</p><h2 id="ff69" class="or mm it bd mn pm pn dn mr po pp dp mv lr pq pr mx lv ps pt mz lz pu pv nb iz bi translated">笔记本</h2><p id="3ac2" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">原始笔记本可在以下位置找到:</p><div class="nu nv gp gr nw nx"><a href="https://github.com/thetestspecimen/notebooks/tree/main/julia-python-comparison" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd jd gy z fp oc fr fs od fu fw jc bi translated">笔记本/Julia-python-主测试样本比较/笔记本</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">Jupyter笔记本。在GitHub上创建一个帐户，为测试样本/笔记本的开发做出贡献。</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">github.com</p></div></div><div class="og l"><div class="pw l oi oj ok og ol lb nx"/></div></div></a></div><p id="30ac" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">…或者在deepnote或colab中快速启动。</p><p id="fc4d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Python笔记本:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><a href="https://deepnote.com/launch?url=https%3A%2F%2Fgithub.com%2Fthetestspecimen%2Fnotebooks%2Fblob%2Fmain%2Fjulia-python-comparison%2Fpython.ipynb"><div class="gh gi px"><img src="../Images/2589425fa59ea0462fa60c913015d133.png" data-original-src="https://miro.medium.com/v2/resize:fit:334/format:webp/1*sq2nvEUbjhdd9bKo4QbsRw.png"/></div></a></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><a href="https://colab.research.google.com/github/thetestspecimen/notebooks/blob/main/julia-python-comparison/python.ipynb"><div class="gh gi px"><img src="../Images/ab36cfbae94a8d3e5dd11db50b483d32.png" data-original-src="https://miro.medium.com/v2/resize:fit:334/format:webp/1*0rcFSSNzLLx1AuzpHApFuQ.png"/></div></a></figure><p id="d8e1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">朱莉娅笔记本:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><a href="https://deepnote.com/launch?url=https%3A%2F%2Fgithub.com%2Fthetestspecimen%2Fnotebooks%2Fblob%2Fmain%2Fjulia-python-comparison%2Fjulia.ipynb"><div class="gh gi px"><img src="../Images/2589425fa59ea0462fa60c913015d133.png" data-original-src="https://miro.medium.com/v2/resize:fit:334/format:webp/1*sq2nvEUbjhdd9bKo4QbsRw.png"/></div></a></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><a href="https://colab.research.google.com/github/thetestspecimen/notebooks/blob/main/julia-python-comparison/julia.ipynb"><div class="gh gi px"><img src="../Images/ab36cfbae94a8d3e5dd11db50b483d32.png" data-original-src="https://miro.medium.com/v2/resize:fit:334/format:webp/1*0rcFSSNzLLx1AuzpHApFuQ.png"/></div></a></figure><h1 id="5dbc" class="ml mm it bd mn mo np mq mr ms nq mu mv ki nr kj mx kl ns km mz ko nt kp nb nc bi translated">结果呢</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi py"><img src="../Images/66dbe306e84fcdb7906a8e4f0edfc287.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fkw1X_h1s4IQoN39rGmY0Q.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://www.pexels.com/photo/person-pointing-paper-line-graph-590041/" rel="noopener ugc nofollow" target="_blank">卢卡斯</a>拍摄</p></figure><p id="379b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你还没有阅读我之前关于numpy向量化的文章，我鼓励你去阅读(显然！)，因为在我们进入Julia结果之前，它将帮助您了解Python方法是如何堆叠的。</p><p id="783b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所有的都会在文末总结对比，如果没有时间也不用太担心。</p><h2 id="9518" class="or mm it bd mn pm pn dn mr po pp dp mv lr pq pr mx lv ps pt mz lz pu pv nb iz bi translated">输入数据</h2><p id="8406" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">定义一个随机数生成器，以及两列取自正态分布的一百万个随机数，就像numpy矢量化文章中的内容一样:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pz qa l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pz qa l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qb qa l"/></div></figure><p id="b8d6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">功能1 —简单求和</strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qc qa l"/></div></figure><p id="4547" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用Julia的<a class="ae lh" href="https://github.com/JuliaCI/BenchmarkTools.jl" rel="noopener ugc nofollow" target="_blank"> BenchmarkTools </a>可以自动获得对函数性能的合理估计，因为“@benchmark”方法会自动决定评估函数多少次，以获得对运行时的合理估计。它还提供了丰富的统计数据，如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qd qa l"/></div></figure><p id="ca2f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了更好地与Python方法进行比较，我们将使用平均时间，在本例中是711.7微秒(或<strong class="lk jd"> 0.71毫秒</strong>)来对一个一百万元素的数组和另一个一百万元素的数组求和。</p><p id="fb33" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">功能2 —更复杂(逻辑和算术)</strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qe qa l"/></div></figure><p id="b031" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该方法返回内容的示例:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qf qa l"/></div></figure><p id="332e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">基准:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qg qa l"/></div></figure><p id="1888" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以更复杂的方法导致平均执行时间为7.62毫秒。</p><h1 id="d580" class="ml mm it bd mn mo np mq mr ms nq mu mv ki nr kj mx kl ns km mz ko nt kp nb nc bi translated">这与Python相比如何？</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qh"><img src="../Images/3e7e06f5cb463e7615e18c460c3b75f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R03p9OPjsiq4-GNA8pczHw.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://www.pexels.com/photo/two-people-holding-pineapple-fruits-against-a-multicolored-wall-4412925/" rel="noopener ugc nofollow" target="_blank">马克西姆·冈查伦诺克</a>拍摄</p></figure><p id="d96b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在进行实际对比。首先让我们一起看看结果是什么样的:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qi"><img src="../Images/72944734d5870fbd990627eb740d41fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PTyBhj3wy15Q6vHeyX26Tw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">结果表—按作者分类的表</p></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qj qa l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图1 —所有结果—按作者分类</p></figure><p id="6fa3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后我们可以继续进行分解。</p><h2 id="cfc2" class="or mm it bd mn pm pn dn mr po pp dp mv lr pq pr mx lv ps pt mz lz pu pv nb iz bi translated">结果:功能1 —简单</h2><p id="ff1b" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">从图1中的简单求和函数可以很清楚地看出，确保使用优化的库(比如与Python相关的numpy)会有很多好处。差异如此之大，以至于更快的方法看起来几乎为零。</p><p id="e8fa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我在关于numpy矢量化的前一篇文章中介绍了这方面的原因，所以如果你想了解更多细节，请参考这篇文章。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qj qa l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图2 —简单函数最快的三个结果—按作者分类</p></figure><p id="029d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，即使是优化的Python库也不足以将执行速度提升到一种语言的水平，这种语言从一开始就被设计为快速的。</p><p id="2510" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如你在图2中看到的，在这个特定的测试中<strong class="lk jd"> Julia使用本机内置实现比使用C执行的Python (numpy)优化库快14%</strong>。</p><h2 id="8018" class="or mm it bd mn pm pn dn mr po pp dp mv lr pq pr mx lv ps pt mz lz pu pv nb iz bi translated">结果:功能2-复杂</h2><p id="db17" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">尽管之前的成绩已经令人印象深刻，但在第二次测试中，朱莉娅彻底击败了对手。</p><p id="074a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如我在<a class="ae lh" href="https://medium.com/towards-data-science/how-to-speedup-data-processing-with-numpy-vectorization-12acac71cfca" rel="noopener">的上一篇文章</a>中解释的那样，在numpy中实现复杂函数的“本地”版本是不可能的，所以我们立刻失去了前一轮中最接近的竞争对手。</p><p id="9342" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这种情况下，即使numpy的“矢量化”方法也无法与Julia相提并论。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qj qa l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图3—复杂函数最快的两个结果—作者图</p></figure><p id="5a16" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在完成更复杂的计算时，Julia比numpy矢量化整整快18倍。</p><h2 id="e62d" class="or mm it bd mn pm pn dn mr po pp dp mv lr pq pr mx lv ps pt mz lz pu pv nb iz bi translated">发生了什么事？</h2><p id="e780" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">numpy在某些情况下如此快速的一个方法是，它使用<strong class="lk jd">预编译</strong>和优化的C函数来执行计算。如你所知，如果使用正确，C是非常快的。但是，重要的一点是:如果某个东西是<strong class="lk jd">预编译</strong>的，那么它就是固有固定的。</p><p id="f88f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这说明，如果你的计算很简单(比如函数1)，并且在numpy库中有一个预定义的<strong class="lk jd">优化的</strong>函数，那么执行时间<em class="nl">几乎与Julia的</em>相同。</p><p id="62a5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，如果你要执行的计算有点复杂或定制，并且没有被优化的numpy函数覆盖，那么在速度方面你就不走运了。这是因为您必须依靠标准Python来填补空白，这导致了我们在图2中看到的“复杂”函数的巨大差异。</p><h1 id="0662" class="ml mm it bd mn mo np mq mr ms nq mu mv ki nr kj mx kl ns km mz ko nt kp nb nc bi translated">结论</h1><p id="d1e4" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">在回答方面:<strong class="lk jd">Julia真的比Python和Numpy快吗？</strong></p><p id="071e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">嗯，是的，在某些情况下，差距还很大。</p><p id="0287" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">和往常一样，重要的是要看到这些结果的本来面目，一些特定函数的小比较。即便如此，结果仍然是真实和相关的。Julia是一种快速的语言，虽然我们在本文中没有过多地涉及它，但它实际上也很容易使用。</p><p id="0304" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你想更全面地了解Julia与其他语言相比有多快，你可以看看Julia网站上的通用基准:</p><div class="nu nv gp gr nw nx"><a href="https://julialang.org/benchmarks/" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd jd gy z fp oc fr fs od fu fw jc bi translated">Julia微基准</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">这些微基准测试虽然不全面，但确实测试了一系列常见代码模式的编译器性能，例如…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">julialang.org</p></div></div><div class="og l"><div class="qk l oi oj ok og ol lb nx"/></div></div></a></div><p id="3de8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">同样的结果，它独树一帜，尤其是在数据科学领域。除非你用c写所有的代码。</p><h1 id="540a" class="ml mm it bd mn mo np mq mr ms nq mu mv ki nr kj mx kl ns km mz ko nt kp nb nc bi translated">最后一个问题…</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ql"><img src="../Images/6ab4ba7ef882156655e3c32c5dd71f0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qvFq20tTWlKfInHougtX4g.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片来自<a class="ae lh" href="https://pixabay.com//?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=1872634" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a></p></figure><p id="9408" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果Julia那么优秀，为什么没有Python/Pandas/NumPy/R那样的牵引力和认可度？</p><p id="e0b6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我觉得这个问题的答案主要是时间。它只是存在的时间还不够长，但现实是Julia正在崛起，在某个时候(至少在我看来)它可能会接管数据科学领域。例如，它已经被微软、谷歌、亚马逊、英特尔、IBM和Nasa等公司使用。</p><p id="273e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Python和R是现阶段的行业标准，这将需要很大的动力来改变，不管这个新贵有多好。</p><p id="8bda" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一个因素是学习资源的可用性。同样，由于时间的原因，以及大量的人使用Python和R进行数据科学研究，可供学习的资源非常丰富。而对于Julia来说，虽然有大量的文档，但它并不能真正竞争所有的学习资源(目前还不能！).</p><p id="8857" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">…但是如果你想冒险，我鼓励你给朱莉娅一个机会，看看你有什么想法。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="ced4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你觉得这篇文章有趣或者有用，记得关注我，或者<a class="ae lh" href="https://medium.com/@maclayton/subscribe" rel="noopener">注册我的时事通讯</a>来获取更多类似的内容。</p><p id="8be7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你还没有，你也可以考虑订阅媒体。你的会员费不仅直接支持我，也支持你所阅读的其他作家。你还可以完全不受限制地访问媒体上的每个故事。</p><p id="3b03" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用我的推荐链接注册会给我一点回扣，对你的会员资格没有影响，所以如果你选择这样做，谢谢你。</p><div class="nu nv gp gr nw nx"><a href="https://medium.com/@maclayton/membership" rel="noopener follow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd jd gy z fp oc fr fs od fu fw jc bi translated">加入我的介绍链接媒体-迈克克莱顿</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">阅读迈克·克莱顿(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">medium.com</p></div></div><div class="og l"><div class="qm l oi oj ok og ol lb nx"/></div></div></a></div></div></div>    
</body>
</html>