<html>
<head>
<title>How to Split and Sample a Dataset in BigQuery Using SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用SQL在BigQuery中对数据集进行分割和采样</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-split-and-sample-a-dataset-in-bigquery-using-sql-a94fc05fdc71#2022-06-28">https://towardsdatascience.com/how-to-split-and-sample-a-dataset-in-bigquery-using-sql-a94fc05fdc71#2022-06-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2cfc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">轻松地将数据划分为训练集、验证集和测试集</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ce26a16d43be634e297bd22806827d07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K_PYjiwU7URJAEAx"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">扎克·波特在Unsplash<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">上的照片</a></p></figure><h1 id="9ffc" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">为什么要分割我们的数据集？</h1><p id="1637" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">拆分数据意味着我们将把它分成子集。对于数据科学模型，数据集通常被划分为<strong class="lt iu">两个</strong>或<strong class="lt iu">三个子集</strong>:训练、验证和测试。</p><blockquote class="mn"><p id="c64f" class="mo mp it bd mq mr ms mt mu mv mw mm dk translated">从创建模型到确保其性能，每个数据子集都有其用途。</p></blockquote><p id="d863" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">不同细分市场的快速定义:</p><ul class=""><li id="c477" class="nc nd it lt b lu ne lx nf ma ng me nh mi ni mm nj nk nl nm bi translated"><strong class="lt iu">训练</strong>:本质上是我们用来训练模型的数据子集。</li><li id="3dd2" class="nc nd it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated"><strong class="lt iu">验证</strong>:当创建模型时，这用于改变或适应学习过程。它还有助于防止过拟合和微调输入参数。</li><li id="5702" class="nc nd it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated"><strong class="lt iu">测试:</strong>最后<strong class="lt iu">，</strong>我们确实需要一个数据子集<strong class="lt iu"> </strong>来评估模型性能和结果。</li></ul><h2 id="d979" class="ns la it bd lb nt nu dn lf nv nw dp lj ma nx ny ll me nz oa ln mi ob oc lp od bi translated">分割尺寸和比例</h2><p id="cf65" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了决定每个子集的大小，我们经常会看到标准的规则和比率。您可能会遇到使用<strong class="lt iu"> 80 -20 </strong> <strong class="lt iu">规则</strong> (80%用于培训分割，20%用于测试分割)，或<strong class="lt iu"> 70-20-10规则</strong> (70%培训，20%验证，10%测试)等分割的情况</p><p id="bba1" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma oe mc md me of mg mh mi og mk ml mm im bi translated">关于什么是最佳分割已经有过一些讨论，但总的来说，我建议记住，没有足够的数据，无论是训练集还是验证集，都将导致模型难以学习/训练，或者您将难以确定该模型实际上是否表现良好。</p><p id="d2f7" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma oe mc md me of mg mh mi og mk ml mm im bi translated">值得注意的是，不一定非要做三段。在BigQuery中，您通常只能生成训练和测试子集，因为可以在使用<code class="fe oh oi oj ok b">DATA_SPLIT</code>选项创建模型时处理验证。</p><div class="ol om gp gr on oo"><a href="https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-create-glm#data_split_method" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">通用线性模型的CREATE MODEL语句| BigQuery ML | Google Cloud</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">要在BigQuery中创建线性回归或逻辑回归模型，请使用带有…的BigQuery ML CREATE MODEL语句</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">cloud.google.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc ks oo"/></div></div></a></div><h2 id="c8d2" class="ns la it bd lb nt nu dn lf nv nw dp lj ma nx ny ll me nz oa ln mi ob oc lp od bi translated">陷阱和注意事项</h2><p id="9242" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在分割数据集之前，您应该了解一些常见的陷阱:</p><ul class=""><li id="ff49" class="nc nd it lt b lu ne lx nf ma ng me nh mi ni mm nj nk nl nm bi translated"><strong class="lt iu">低质量数据</strong>:如果用来创建你的模型的输入数据是嘈杂的或者不可信的，那么模型的输出很可能反映了这一点。</li><li id="ed14" class="nc nd it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated"><strong class="lt iu">过度拟合</strong>:当输入数据不足时，模型可能会学习训练数据，以至于任何噪声或波动都被认为会导致不可靠的预测。</li><li id="e6e5" class="nc nd it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated"><strong class="lt iu">不平衡数据集:</strong>假设您想要训练一个预测客户购买的模型，但是您有50万个非购买者和300个购买者，您将首先需要创建一个更加平等的数据集(使用<strong class="lt iu">重采样</strong>技术)。探索性数据分析(<strong class="lt iu"> EDA </strong>)将有助于发现不平衡的数据。</li><li id="b461" class="nc nd it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated"><strong class="lt iu">数据泄漏:</strong>它描述了在创建训练数据集之前或甚至在拆分期间(例如，当同一天的事件可能相关时，按日期拆分数据)输入数据已被操纵(缩放、转换)的事实，导致模型不能反映现实。</li></ul><h1 id="8d34" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">使用SQL拆分数据集</h1><p id="e318" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于我们的实验，我们有下面的数据集，由<strong class="lt iu"> 11k行</strong>和三个字段组成，一个订单ID、一个日期和一个关联的订单值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/dd734a72d1f3fe022e9c728a478fbf6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*nZCCwMOumUMFMnmAX6Fmqw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们将把这个表分成训练和测试子集。(图片由作者提供)</p></figure><h2 id="5f4b" class="ns la it bd lb nt nu dn lf nv nw dp lj ma nx ny ll me nz oa ln mi ob oc lp od bi translated">选择要拆分的右列</h2><p id="6169" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了进行适当的拆分，使用一列来单独区分你的基表的每一行。如果不是这样，就很难创建一个均匀分布的分割，并且可能会使分割的随机性产生偏差。</p><p id="8316" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma oe mc md me of mg mh mi og mk ml mm im bi translated">为了实现独特性，我们有几个选项，您将在我们即将推出的实践示例中看到:</p><ul class=""><li id="3307" class="nc nd it lt b lu ne lx nf ma ng me nh mi ni mm nj nk nl nm bi translated">我们可以创建一个具有唯一值的新字段(例如一个随机数生成器函数，如<code class="fe oh oi oj ok b">RAND()</code>或<code class="fe oh oi oj ok b">UUID()</code></li><li id="f296" class="nc nd it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated">我们可以创建单个已经唯一的字段的散列，或者创建一个唯一的行标识符的字段组合的散列。</li></ul><p id="569d" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma oe mc md me of mg mh mi og mk ml mm im bi translated">对于第二个选项，你最常听说的散列函数是<code class="fe oh oi oj ok b">FARM_FINGERPRINT()</code>。</p><p id="0298" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma oe mc md me of mg mh mi og mk ml mm im bi translated">但是，<strong class="lt iu">为什么是这个</strong>而不是其他的比如<code class="fe oh oi oj ok b">MD5()</code>或者<code class="fe oh oi oj ok b">SHA()</code>？</p><p id="6b78" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma oe mc md me of mg mh mi og mk ml mm im bi translated">这是由于<strong class="lt iu">的两个特点</strong>。首先，对于相同的输入，它总是给出相同的结果，其次，它返回一个<code class="fe oh oi oj ok b">INT64</code>值(本质上是一个数字，而不是数字和字符的组合)，我们可以用其他数学函数(如<code class="fe oh oi oj ok b">MOD()</code>来控制它，以产生我们的分割比。</p><h2 id="306e" class="ns la it bd lb nt nu dn lf nv nw dp lj ma nx ny ll me nz oa ln mi ob oc lp od bi translated">创建唯一的行标识符</h2><p id="cb93" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">要创建唯一的行标识符，可以使用<code class="fe oh oi oj ok b">FARM_FINGERPRINT()</code>函数。为了详细说明这个过程，下面是一行中的单个列和所有列的组合的每个转换步骤:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pe pf l"/></div></figure><p id="783d" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma oe mc md me of mg mh mi og mk ml mm im bi translated">最后，我们将在数据集中继续拆分的是最后一列(我们称之为<code class="fe oh oi oj ok b">hash_abs_mod</code>的列)。下表从左到右简单说明了哈希过程的每个步骤。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/3762599a2895802ede1fca152d71272a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ao1w1QbRh_3Ymx7rX_BFYA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">哈希和模函数对我们的基表的影响。(图片由<a class="ae ky" href="https://romaingranger.medium.com/" rel="noopener">作者</a>)</p></figure><p id="28f2" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma oe mc md me of mg mh mi og mk ml mm im bi translated">在我们的基表中，我们已经为每一行准备了一个惟一的值标识符，这就是我们的<code class="fe oh oi oj ok b">order_id</code>字段。在这种情况下，我们可以散列它，然后使用<code class="fe oh oi oj ok b">ABS(MOD(x,10))</code>函数将每一行分类到从0到9的桶中。</p><p id="f041" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma oe mc md me of mg mh mi og mk ml mm im bi translated">要创建整行(即所有列)的散列，最好的方法是首先标记您的表(我们称之为<code class="fe oh oi oj ok b">bt</code>)，然后使用<code class="fe oh oi oj ok b">TO_JSON_STRING(bt)</code>将其转换为JSON对象。然后可以对此进行哈希运算。这个方法的唯一目标是帮助您避免出现重复的行，这些行将总是以相同的分割结束，并偏向随机方面。</p><h2 id="aa73" class="ns la it bd lb nt nu dn lf nv nw dp lj ma nx ny ll me nz oa ln mi ob oc lp od bi translated">创建不可重复的拆分</h2><p id="fa3b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">要随机分割一个数据集，我们可以使用<code class="fe oh oi oj ok b">RAND()</code>函数。这将为每一行返回一个伪随机十进制数，区间为[0–1]，包括0，不包括1。</p><p id="c40c" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma oe mc md me of mg mh mi og mk ml mm im bi translated">该函数确实为<strong class="lt iu">提供了均匀分布，</strong>这意味着我们可以<strong class="lt iu">过滤所有小于0.8的值，例如</strong>，而<strong class="lt iu">将代表我们数据<strong class="lt iu">的80% </strong>。</strong></p><p id="4878" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma oe mc md me of mg mh mi og mk ml mm im bi translated">但是请记住，每次运行查询时，该函数将返回不同的数字，因此您的训练集和测试集将会不同。如果您想让结果持久化，您可以通过将查询结果存储为一个表来制作快照。</p><p id="fb17" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma oe mc md me of mg mh mi og mk ml mm im bi translated">让我们随机划分80%的培训和20%的测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pe pf l"/></div></figure><p id="0aac" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma oe mc md me of mg mh mi og mk ml mm im bi translated">您可以在结果中看到，我们确实有一个由我们的<code class="fe oh oi oj ok b">RAND()</code>函数生成的具有许多小数的数字，以及由我们的<code class="fe oh oi oj ok b">IF()</code>语句给出的标签(train/test)。</p><p id="862b" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma oe mc md me of mg mh mi og mk ml mm im bi translated">但是，请记住，如果不按原样存储结果，您将无法复制完全相同的分割。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/1e08eb54c2663a664caa68e19c5cefd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*kqEZhSmp7m5frmvKMtX8Ng.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用RAND()分为训练和测试。(图片由<a class="ae ky" href="https://romaingranger.medium.com/" rel="noopener">作者</a>提供)</p></figure><h2 id="97ec" class="ns la it bd lb nt nu dn lf nv nw dp lj ma nx ny ll me nz oa ln mi ob oc lp od bi translated">创建可重复的拆分</h2><p id="469a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了创建一个可以重用的<strong class="lt iu">分割，最好是使用<code class="fe oh oi oj ok b">MOD()</code>和<code class="fe oh oi oj ok b">FARM_FINGERPRINT()</code>功能的</strong>组合<strong class="lt iu">，因为对于相同的输入，输出将保持不变。</strong></p><p id="2455" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma oe mc md me of mg mh mi og mk ml mm im bi translated">让我们使用我们的唯一键(<code class="fe oh oi oj ok b">order_id</code>字段)。我们可以使用具有以下范围的CASE WHEN语句进行80/10/10可重复拆分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pe pf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">分成3个子集(培训、验证和测试)</p></figure><p id="4962" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma oe mc md me of mg mh mi og mk ml mm im bi translated">结果将与我们之前的不可重复分割相同，除了这个查询将<strong class="lt iu">总是产生相同的分割</strong>(train、validation和test的分配将总是进入相同的行)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/dc464660e8e4bfc99b311a395161c31a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*iJow2Shd8Ekt_ux0RSZ7sg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用MOD()和FARM_FINGERPRINT()分为训练、验证和测试。(图片由<a class="ae ky" href="https://romaingranger.medium.com/" rel="noopener">作者</a></p></figure><h2 id="b8fa" class="ns la it bd lb nt nu dn lf nv nw dp lj ma nx ny ll me nz oa ln mi ob oc lp od bi translated">结论和补充说明</h2><p id="0a62" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">你现在知道如何将你的数据集分割成子集，以可重用或不可重用的方式。因此，我们没有涵盖时间方面，例如，当在<strong class="lt iu">日期字段</strong>上拆分时。</p><p id="f1d0" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma oe mc md me of mg mh mi og mk ml mm im bi translated">这在为时序预测或回归模型定型时很常见，这意味着您可能希望保留日期的顺序。这也意味着您必须验证哪个<strong class="lt iu">时间范围覆盖了您基础数据的80% </strong>(在80/20分割的情况下)。</p><p id="aa71" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma oe mc md me of mg mh mi og mk ml mm im bi translated">此外，具有相同日期的行往往是相关的(某一天发生的事件可能会影响同一天的事件)，这就是为什么这些行应该保留在同一个拆分中。您还需要小心丢失的数据和数据质量，并且排除一些由于异常或季节性的数据。</p></div></div>    
</body>
</html>