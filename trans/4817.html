<html>
<head>
<title>Image Data Augmentation for Deep Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于深度学习的图像数据增强</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/image-data-augmentation-for-deep-learning-77a87fabd2bf#2022-10-26">https://towardsdatascience.com/image-data-augmentation-for-deep-learning-77a87fabd2bf#2022-10-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bc99" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解什么是图像数据增强，以及如何在深度学习项目中使用Keras</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b1a2b353fffb640b0925c9f93fa4bae0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7Cwbl8uMeYY0jc9e"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯·劳顿在Unsplash<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拍摄的照片</a></p></figure><p id="5711" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你曾经尝试过使用深度学习进行图像识别，你就会知道一个好的数据集对于训练的重要性。但是，找到足够的图像进行训练并不总是容易的，并且模型的准确性直接取决于训练数据的质量。</p><p id="4fc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，您可以使用一些技术来补充他们用于训练的图像数据集。其中一种技术叫做<em class="lv">图像数据增强</em>。在本文中，我将讨论什么是图像数据增强，它如何工作，为什么它在深度学习中有用，以及最后如何使用Keras库执行图像数据增强。</p><h1 id="cd40" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">什么是图像数据增强？</h1><p id="0425" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated"><em class="lv">图像数据增强</em>是一种<em class="lv">从现有图像</em>中创建新图像的技术。为此，您可以对它们进行一些小的更改，例如调整图像的亮度，旋转图像，或者水平或垂直移动图像中的主题。</p><p id="82c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">图像增强技术允许您人为地增加训练集的大小，从而为您的模型训练提供更多的数据。这允许您通过增强模型识别训练数据的新变量的能力来提高模型的准确性。</p><h2 id="e87a" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">图像数据增强的类型</h2><p id="cf85" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">图像增强有多种形式，下面是一些常见的形式——垂直移动、水平移动、垂直翻转、水平翻转、旋转、亮度调整和放大/缩小。</p><h1 id="6383" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">使用Keras的图像增强</h1><p id="1bf8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我将首先使用Python和Keras演示各种图像增强技术。如果您想尝试，请确保您安装了以下软件和软件包:</p><ul class=""><li id="d3c2" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated"><strong class="lb iu">蟒蛇</strong>。你可以从https://www.anaconda.com/products/distribution/下载蟒蛇。</li><li id="cdeb" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><strong class="lb iu">张量流</strong>。您可以使用命令<code class="fe nt nu nv nw b">pip install tensorflow</code>安装TensorFlow。</li></ul><p id="3199" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装Anaconda和TensorFlow后，创建一个新的Jupyter笔记本。</p><h2 id="59a4" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">垂直移位</h2><p id="4380" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我想展示的第一个图像增强技术是<em class="lv">垂直移动</em>。<em class="lv">垂直移动</em>随机上下垂直移动图像。对于这个例子，我将使用一个名为<strong class="lb iu">747.jpg</strong>的图片，它与我的Jupyter笔记本位于同一个文件夹中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/df4ce2b8a49d1f56f2295b8a942de8b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_0zrzfKvwjJrta8XFoIyHQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae ky" href="https://commons.wikimedia.org/wiki/File:Qantas_Boeing_747-438ER_VH-OEI_at_LAX.jpg" rel="noopener ugc nofollow" target="_blank">https://commons . wikimedia . org/wiki/File:Qantas _ Boeing _ 747-438 er _ VH-OEI _ at _ lax . jpg</a>。本文件在<a class="ae ky" href="https://en.wikipedia.org/wiki/en:Creative_Commons" rel="noopener ugc nofollow" target="_blank">知识共享</a> <a class="ae ky" href="https://creativecommons.org/licenses/by-sa/2.0/deed.en" rel="noopener ugc nofollow" target="_blank">署名-共享2.0通用</a>许可下获得许可。</p></figure><p id="ff79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码片段使用Keras中的<code class="fe nt nu nv nw b">ImageDataGenerator</code>类来垂直移动图像。</p><blockquote class="ny nz oa"><p id="b135" class="kz la lv lb b lc ld ju le lf lg jx lh ob lj lk ll oc ln lo lp od lr ls lt lu im bi translated">Keras的<code class="fe nt nu nv nw b">ImageDataGenerator</code>类通过实时数据扩充生成批量图像数据。</p></blockquote><pre class="kj kk kl km gt oe nw of og aw oh bi"><span id="0419" class="mt lx it nw b gy oi oj l ok ol">#---import the modules---<br/>import numpy as np<br/>import matplotlib.pyplot as plt</span><span id="8f9d" class="mt lx it nw b gy om oj l ok ol">from tensorflow.keras.preprocessing.image import load_img<br/>from tensorflow.keras.preprocessing.image import img_to_array<br/>from tensorflow.keras.preprocessing.image import ImageDataGenerator</span><span id="b28f" class="mt lx it nw b gy om oj l ok ol">#---load the image---<br/>image_filename = '747.jpg'<br/>img = load_img(image_filename)</span><span id="21e5" class="mt lx it nw b gy om oj l ok ol">#---convert the image to 3D array---<br/>image_data = img_to_array(img)</span><span id="e950" class="mt lx it nw b gy om oj l ok ol">#---convert into a 4-D array of 1 element of 3D array representing<br/># the image---<br/>images_data = np.expand_dims(image_data, axis=0)</span><span id="e3d6" class="mt lx it nw b gy om oj l ok ol">#---create image data augmentation generator---<br/>datagen = ImageDataGenerator(width_shift_range=0.2)</span><span id="3c45" class="mt lx it nw b gy om oj l ok ol">#---prepare the iterator; flow() takes in a 4D array and returns <br/># an iterator containing a batch of images---<br/>train_generator = datagen.flow(images_data, batch_size=1)</span><span id="b485" class="mt lx it nw b gy om oj l ok ol">rows = 5<br/>columns = 4</span><span id="c367" class="mt lx it nw b gy om oj l ok ol">#---plot 5 rows and 4 columns---<br/>fig, axes = plt.subplots(rows,columns)</span><span id="d9d0" class="mt lx it nw b gy om oj l ok ol">for r in range(rows):<br/>    for c in range(columns):<br/>        #---get the next image in the batch (one image since batch <br/>        # size is 1)---<br/>        image_batch = train_generator.next()<br/>        <br/>        #---convert to unsigned integers for viewing---<br/>        image = image_batch[0].astype('uint8')</span><span id="1f2f" class="mt lx it nw b gy om oj l ok ol">        #---show the image---<br/>        axes[r,c].imshow(image)</span><span id="e860" class="mt lx it nw b gy om oj l ok ol">#---set the size of the figure---<br/>fig.set_size_inches(15,10)</span></pre><p id="941e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述代码片段产生以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/2026ddc348e28f8a15dcff1d2f4317dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IzVjyOCZGEKZamDAb-XLlA.png"/></div></div></figure><p id="d3c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的输出可以看出，每次从<code class="fe nt nu nv nw b">train_generator</code>对象中调用<code class="fe nt nu nv nw b">next()</code>方法，都会得到一个略有变化的图像。在上面的代码片段中，每次调用<code class="fe nt nu nv nw b">next()</code>方法时，都会返回一个基于原始图像高度移动了20%的新图像:</p><pre class="kj kk kl km gt oe nw of og aw oh bi"><span id="5b54" class="mt lx it nw b gy oi oj l ok ol">datagen = ImageDataGenerator(<strong class="nw iu">width_shift_range=0.2</strong>)</span></pre><blockquote class="ny nz oa"><p id="758c" class="kz la lv lb b lc ld ju le lf lg jx lh ob lj lk ll oc ln lo lp od lr ls lt lu im bi translated">有趣的是，对于这个版本的<code class="fe nt nu nv nw b">ImageDataGenerator</code> ( <code class="fe nt nu nv nw b">tensorflow.keras.preprocessing.image</code>)类，指定<code class="fe nt nu nv nw b">width_shift_range</code>参数会垂直移动图像，而不是水平移动(这是来自<code class="fe nt nu nv nw b">keras.preprocessing.image</code>模块的旧<code class="fe nt nu nv nw b"><em class="it">ImageDataGenerator</em></code>的行为)。同样，如果你想让图像水平移动，你需要使用<code class="fe nt nu nv nw b">height_shift_range</code>参数(见下一节)。</p></blockquote><p id="d115" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，<code class="fe nt nu nv nw b">next()</code>方法将根据您的需要多次返回一个增强的图像。在上面的代码片段中，我们调用了它20次(5行乘以4列)。</p><h2 id="0c1c" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">水平移动</h2><p id="e20d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">您现在可以尝试使用<code class="fe nt nu nv nw b">height_shift_range</code>参数水平移动图像:</p><pre class="kj kk kl km gt oe nw of og aw oh bi"><span id="1842" class="mt lx it nw b gy oi oj l ok ol">datagen = ImageDataGenerator(<strong class="nw iu">height_shift_range=0.2</strong>)<br/>train_generator = datagen.flow(images_data, batch_size=1)</span><span id="007d" class="mt lx it nw b gy om oj l ok ol">rows = 5<br/>columns = 4</span><span id="e41a" class="mt lx it nw b gy om oj l ok ol">fig, axes = plt.subplots(rows,columns)<br/>for r in range(rows):<br/>    for c in range(columns):<br/>        image_batch = train_generator.next()<br/>        image = image_batch[0].astype('uint8')<br/>        axes[r,c].imshow(image)</span><span id="3c1e" class="mt lx it nw b gy om oj l ok ol">fig.set_size_inches(15,10)</span></pre><p id="b021" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述代码片段产生以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/1a01a61978eb94a5309215a4712b39cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EUFaAJ2Es9yaa6PUs2ORsw.png"/></div></div></figure><h2 id="3363" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">水平翻转</h2><p id="e07d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">有时水平翻转图像是有意义的。就飞机而言，飞机的前部可能面向左，也可能面向右:</p><pre class="kj kk kl km gt oe nw of og aw oh bi"><span id="6521" class="mt lx it nw b gy oi oj l ok ol">datagen = ImageDataGenerator(<strong class="nw iu">horizontal_flip=True</strong>)<br/>train_generator = datagen.flow(images_data, batch_size=1)</span><span id="ea37" class="mt lx it nw b gy om oj l ok ol">rows = 2<br/>columns = 2</span><span id="dc0c" class="mt lx it nw b gy om oj l ok ol">fig, axes = plt.subplots(rows,columns)<br/>for r in range(rows):<br/>    for c in range(columns):        <br/>        image_batch = train_generator.next()<br/>        image = image_batch[0].astype('uint8')<br/>        axes[r,c].imshow(image)</span><span id="95d2" class="mt lx it nw b gy om oj l ok ol">fig.set_size_inches(15,10)</span></pre><p id="a494" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于上面的代码片段，生成四个图像就足够了，因为飞机的正面可以面向左或右:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/e971393d066194c15f5f431226a81c99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tKqJB3YaRqBILTFR-QDLuw.png"/></div></div></figure><blockquote class="ny nz oa"><p id="235b" class="kz la lv lb b lc ld ju le lf lg jx lh ob lj lk ll oc ln lo lp od lr ls lt lu im bi translated">请记住，翻转是随机的(有时您会得到所有四个原始图像，有时您会得到水平翻转的图像)。很可能上面的四个图像都是相同的。如果发生这种情况，只需再次运行该代码块。</p></blockquote><h2 id="34cf" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">垂直翻转</h2><p id="2a6c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">就像水平翻转一样，您也可以执行垂直翻转:</p><pre class="kj kk kl km gt oe nw of og aw oh bi"><span id="abe2" class="mt lx it nw b gy oi oj l ok ol">datagen = ImageDataGenerator(<strong class="nw iu">vertical_flip=True</strong>)<br/>train_generator = datagen.flow(images_data, batch_size=1)</span><span id="82d4" class="mt lx it nw b gy om oj l ok ol">rows = 2<br/>columns = 2</span><span id="8c80" class="mt lx it nw b gy om oj l ok ol">fig, axes = plt.subplots(rows,columns)<br/>for r in range(rows):<br/>    for c in range(columns):<br/>        image_batch = train_generator.next()<br/>        image = image_batch[0].astype('uint8')<br/>        axes[r,c].imshow(image)</span><span id="4a59" class="mt lx it nw b gy om oj l ok ol">fig.set_size_inches(15,10)</span></pre><p id="4a47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以飞机为例，把我们的飞机翻个底朝天可能没什么意义！如果您正在尝试执行图像识别，那么您的平面图像很可能是垂直的，因此训练您的模型识别颠倒的平面可能不太常见。对于其他情况，垂直翻转很有意义。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/90ea718e97bbd3ea83b9f77a7b209c38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6jLyg60STuswypGnFaWaBw.png"/></div></div></figure><h2 id="78ae" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">旋转</h2><p id="052d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">旋转，顾名思义，就是旋转你的图像。这对我们的飞机图像非常有用。以下代码片段将图像随机旋转50度:</p><pre class="kj kk kl km gt oe nw of og aw oh bi"><span id="91a0" class="mt lx it nw b gy oi oj l ok ol">datagen = ImageDataGenerator(<strong class="nw iu">rotation_range=50</strong>)<br/>train_generator = datagen.flow(images_data)</span><span id="8f64" class="mt lx it nw b gy om oj l ok ol">rows = 5<br/>columns = 4</span><span id="dfd7" class="mt lx it nw b gy om oj l ok ol">fig, axes = plt.subplots(rows,columns)<br/>for r in range(rows):<br/>    for c in range(columns):<br/>        image_batch = train_generator.next()<br/>        image = image_batch[0].astype('uint8')<br/>        axes[r,c].imshow(image)</span><span id="e459" class="mt lx it nw b gy om oj l ok ol">fig.set_size_inches(15,10)</span></pre><p id="3e69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过旋转，输出显示了不同位置的飞机，模拟起飞和着陆位置:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/d98dde8a6ee6bd0c5d04ccdafb4eecf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tFmSZlTgOLVlAttw4MCTWA.png"/></div></div></figure><h2 id="885d" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">聪明</h2><p id="9e04" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">另一种增强技术是调整图像的亮度。以下代码片段设置了亮度偏移值的范围:</p><pre class="kj kk kl km gt oe nw of og aw oh bi"><span id="6331" class="mt lx it nw b gy oi oj l ok ol">datagen = ImageDataGenerator(<strong class="nw iu">brightness_range=[0.15,2.0]</strong>)<br/>train_generator = datagen.flow(images_data, batch_size=1)</span><span id="297d" class="mt lx it nw b gy om oj l ok ol">rows = 5<br/>columns = 4</span><span id="c165" class="mt lx it nw b gy om oj l ok ol">fig, axes = plt.subplots(rows,columns)<br/>for r in range(rows):<br/>    for c in range(columns):<br/>        image_batch = train_generator.next()<br/>        image = image_batch[0].astype('uint8')<br/>        axes[r,c].imshow(image)</span><span id="bcaf" class="mt lx it nw b gy om oj l ok ol">fig.set_size_inches(15,10)</span></pre><p id="7f55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出包含一系列不同亮度的图像:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/1fd96133a124af0ff27f404a2a1bbc7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OjkBI8n18dh9bePl05zm5g.png"/></div></div></figure><h2 id="e3c8" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">变焦</h2><p id="f43d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">您还可以放大或缩小图像:</p><pre class="kj kk kl km gt oe nw of og aw oh bi"><span id="7e83" class="mt lx it nw b gy oi oj l ok ol">datagen = ImageDataGenerator(<strong class="nw iu">zoom_range=[5,0.5]</strong>)<br/>train_generator = datagen.flow(images_data, batch_size=1)</span><span id="4834" class="mt lx it nw b gy om oj l ok ol">rows = 5<br/>columns = 4</span><span id="50d0" class="mt lx it nw b gy om oj l ok ol">fig, axes = plt.subplots(rows,columns)<br/>for r in range(rows):<br/>    for c in range(columns):<br/>        image_batch = train_generator.next()<br/>        image = image_batch[0].astype('uint8')<br/>        axes[r,c].imshow(image)</span><span id="67d8" class="mt lx it nw b gy om oj l ok ol">fig.set_size_inches(15,10)</span></pre><p id="fa19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出以各种缩放比例显示图像:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/a78b19cf45bdca71764f99d1684898c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cUqN7JMjmgd_R_pLa-FbKQ.png"/></div></div></figure><blockquote class="ny nz oa"><p id="e838" class="kz la lv lb b lc ld ju le lf lg jx lh ob lj lk ll oc ln lo lp od lr ls lt lu im bi translated">请注意，缩放图像会改变图像的纵横比。</p></blockquote><h2 id="3a3b" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">结合所有的增强</h2><p id="1be4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">当然，到目前为止我所讨论的各种增强技术都可以结合起来:</p><pre class="kj kk kl km gt oe nw of og aw oh bi"><span id="1410" class="mt lx it nw b gy oi oj l ok ol">datagen = ImageDataGenerator(<strong class="nw iu">width_shift_range=0.2,<br/>                             height_shift_range=0.2,<br/>                             horizontal_flip=True,<br/>                             rotation_range=50,<br/>                             brightness_range=[0.15,2.0],<br/>                             zoom_range=[5,0.5]</strong>)</span><span id="8eab" class="mt lx it nw b gy om oj l ok ol">train_generator = datagen.flow(images_data, batch_size=1)</span><span id="9aed" class="mt lx it nw b gy om oj l ok ol">rows = 8<br/>columns = 8</span><span id="a176" class="mt lx it nw b gy om oj l ok ol">fig, axes = plt.subplots(rows,columns)<br/>for r in range(rows):<br/>    for c in range(columns):<br/>        image_batch = train_generator.next()<br/>        image = image_batch[0].astype('uint8')<br/>        axes[r,c].imshow(image)</span><span id="8743" class="mt lx it nw b gy om oj l ok ol">fig.set_size_inches(15,10)</span></pre><blockquote class="ny nz oa"><p id="9849" class="kz la lv lb b lc ld ju le lf lg jx lh ob lj lk ll oc ln lo lp od lr ls lt lu im bi translated">请注意，我省略了垂直翻转，因为它对我们的示例没有意义。</p></blockquote><p id="9bee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，输出显示了应用了各种放大效果的图像:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/3e5febd5617372c610d7eb66f0254ff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FUXKgFVnXD_nZ4qzKoGCXg.png"/></div></div></figure><h1 id="684b" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">对图像类别使用ImageDataGenerator</h1><p id="ddb2" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">前面几节介绍了图像数据增强的基础知识，以及如何将其应用于单个图像。在深度学习中，我们经常会处理一组图像。现在让我们看看如何将图像增强应用于一组图像。为了便于说明，我假设在包含Jupyter笔记本的文件夹中，有一个<strong class="lb iu">水果</strong>文件夹和以下子文件夹:</p><pre class="kj kk kl km gt oe nw of og aw oh bi"><span id="c053" class="mt lx it nw b gy oi oj l ok ol"><strong class="nw iu">Fruits</strong><br/>  |<strong class="nw iu">__banana</strong><br/>       |__banana1.jpg<br/>       |__banana2.jpg<br/>       |__banana3.jpg<br/>       |__ ...<br/>  |<strong class="nw iu">__durian</strong><br/>       |__durian1.jpg<br/>       |__durian2.jpg<br/>       |__durian3.jpg<br/>       |__ ...<br/>  |<strong class="nw iu">__orange</strong><br/>       |__orange1.jpg<br/>       |__orange2.jpg<br/>       |__orange3.jpg<br/>       |__ ...<br/>  |<strong class="nw iu">__strawberry</strong><br/>       |__strawberry1.jpg<br/>       |__strawberry2.jpg<br/>       |__strawberry3.jpg<br/>       |__ ...</span></pre><p id="75a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个子文件夹包含一组图像。例如，<strong class="lb iu">香蕉</strong>文件夹包含许多名为<strong class="lb iu">banana1.jpg</strong>、<strong class="lb iu">banana2.jpg</strong>等的图像。子文件夹的名称将作为各种图像的标签。这意味着<strong class="lb iu">香蕉</strong>文件夹下的所有文件都包含香蕉的图像，以此类推。</p><p id="9254" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了从磁盘加载一系列图像，现在调用<code class="fe nt nu nv nw b">ImageDataGenerator</code>实例的<code class="fe nt nu nv nw b">flow_from_directory()</code>方法，而不是<code class="fe nt nu nv nw b">flow()</code>方法(用于从内存加载图像):</p><pre class="kj kk kl km gt oe nw of og aw oh bi"><span id="4e09" class="mt lx it nw b gy oi oj l ok ol">train_datagen = ImageDataGenerator(<br/>    horizontal_flip=True,<br/>    vertical_flip=True,<br/>    rotation_range=50,<br/>)</span><span id="efc1" class="mt lx it nw b gy om oj l ok ol"><strong class="nw iu">batch_size = 8</strong></span><span id="4221" class="mt lx it nw b gy om oj l ok ol">train_generator = <strong class="nw iu">train_datagen.flow_from_directory(<br/>    './Fruits',<br/>    target_size=(224,224), <br/>    color_mode='rgb', <br/>    batch_size=batch_size, <br/>    class_mode='categorical', <br/>    shuffle=True)</strong></span></pre><blockquote class="ny nz oa"><p id="f89f" class="kz la lv lb b lc ld ju le lf lg jx lh ob lj lk ll oc ln lo lp od lr ls lt lu im bi translated">注意，我现在将<code class="fe nt nu nv nw b">batch_size</code>设置为8。您将很快看到批量大小的用法。</p></blockquote><p id="f03b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用返回的迭代器，我可以找到各种水果的标签(香蕉、榴莲、橙子和草莓):</p><pre class="kj kk kl km gt oe nw of og aw oh bi"><span id="6241" class="mt lx it nw b gy oi oj l ok ol">class_dictionary = train_generator.class_indices</span><span id="c72e" class="mt lx it nw b gy om oj l ok ol">#---create a dictionary of labels---<br/>class_dictionary = { value:key for key,value in<br/>    class_dictionary.items()}</span><span id="39e8" class="mt lx it nw b gy om oj l ok ol">#---convert the dictionary to a list---<br/>class_list = [value for _,value in class_dictionary.items()]<br/>print(class_list)</span></pre><p id="2e5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将看到以下输出:</p><pre class="kj kk kl km gt oe nw of og aw oh bi"><span id="af67" class="mt lx it nw b gy oi oj l ok ol">Found 54 images belonging to 4 classes.<br/>['banana', 'durian', 'orange', 'strawberry']</span></pre><p id="eb6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总共有54张图片在4个文件夹中。另外，<code class="fe nt nu nv nw b">class_list</code>变量包含水果列表。</p><p id="c87d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我现在将打印出由<code class="fe nt nu nv nw b">ImageDataGenerator</code>类创建的一组增强图像。我将任意地将行数设置为10，对于每一行，我想打印出返回的一批图像(在本例中是8):</p><pre class="kj kk kl km gt oe nw of og aw oh bi"><span id="26bd" class="mt lx it nw b gy oi oj l ok ol">rows = 10</span><span id="3933" class="mt lx it nw b gy om oj l ok ol">fig, axes = plt.subplots(rows,batch_size)</span><span id="be6c" class="mt lx it nw b gy om oj l ok ol">for r in range(rows):    <br/>    #---get the batch of augmented images---<br/>    image_batch = train_generator.next()    </span><span id="27dd" class="mt lx it nw b gy om oj l ok ol">    #---get the number of images returned---<br/>    images_count = image_batch[0].shape[0]<br/>    <br/>    for c in range(images_count):<br/>        #---convert to unsigned integers for viewing---<br/>        image = image_batch[0][c].astype('uint8')<br/>        <br/>        #---display the image---<br/>        axes[r,c].imshow(image)</span><span id="3959" class="mt lx it nw b gy om oj l ok ol">        #---display the label of the image---<br/>        axes[r,c].title.set_text(<br/>            class_list[np.argmax(image_batch[1][c])])</span><span id="42a4" class="mt lx it nw b gy om oj l ok ol">        #---hides the x and y-ticks---<br/>        axes[r,c].set_xticks([])<br/>        axes[r,c].set_yticks([])</span><span id="2037" class="mt lx it nw b gy om oj l ok ol">fig.set_size_inches(15,18)</span></pre><p id="d1c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为<code class="fe nt nu nv nw b">batch_size</code>现在被设置为8(而不再是1)，所以每次调用<code class="fe nt nu nv nw b">train_generator.next()</code>方法时，它都会返回一批<em class="lv">的八幅增强图像。返回的图像数量基于您之前在<code class="fe nt nu nv nw b">flow_from_directory()</code>方法中设置的<code class="fe nt nu nv nw b">batch_size</code>:</em></p><pre class="kj kk kl km gt oe nw of og aw oh bi"><span id="44a2" class="mt lx it nw b gy oi oj l ok ol">train_generator = train_datagen.flow_from_directory(<br/>    './Fruits',<br/>    target_size=(224,224), <br/>    color_mode='rgb', <br/><strong class="nw iu">    batch_size=batch_size,</strong>        # batch_size = 8<br/>    class_mode='categorical', <br/>    shuffle=True)</span></pre><p id="37a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nt nu nv nw b">image_batch</code>变量的值(由<code class="fe nt nu nv nw b">next()</code>方法返回)是两个元素的元组:</p><ul class=""><li id="1fb6" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">第一个元素(<code class="fe nt nu nv nw b">image_batch[0]</code>)是一个由<em class="lv"> batch_size </em>图像组成的数组(4D数组)</li><li id="496c" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">第二个元素(<code class="fe nt nu nv nw b">image_batch[1]</code>)包含图像的标签</li></ul><p id="0df3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述代码片段产生以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/ea2e7038987eeadf9f302c4c24846423.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AyocHTZ_AyCAlsxISIm1vA.png"/></div></div></figure><p id="f89d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，在第七行，有两个没有图像的空图表。回想一下，图像集中总共有54幅图像，由于每批返回8幅图像(每行)，前七行将显示总共54幅图像(8x6 + 6)。下图说明了这一点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/f75cd68e1053568af13d66fccbe5815e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VVhvl5u3C3ApX7HTsgxWjg.png"/></div></div></figure><blockquote class="ny nz oa"><p id="6b16" class="kz la lv lb b lc ld ju le lf lg jx lh ob lj lk ll oc ln lo lp od lr ls lt lu im bi translated">请注意，您可以将<code class="fe nt nu nv nw b">rows</code>设置为任何数字，并且<code class="fe nt nu nv nw b">ImageDataGenerator</code>类将继续为您生成新的增强图像。</p></blockquote><h2 id="3fc1" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">使用迁移学习建立模型</h2><p id="9bdd" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">您现在知道如何使用<code class="fe nt nu nv nw b">ImageDataGenerator</code>从磁盘加载图像集以进行增强。但是怎么用它来训练呢？以下代码片段展示了如何使用<em class="lv">迁移学习</em>构建深度学习模型。</p><blockquote class="ny nz oa"><p id="9952" class="kz la lv lb b lc ld ju le lf lg jx lh ob lj lk ll oc ln lo lp od lr ls lt lu im bi translated">迁移学习是一种机器学习方法，其中为一项任务开发的模型被重新用作第二项任务模型的起点。迁移学习减少了你需要花在培训上的时间。</p></blockquote><pre class="kj kk kl km gt oe nw of og aw oh bi"><span id="d320" class="mt lx it nw b gy oi oj l ok ol">from tensorflow.keras.models import Model<br/>from tensorflow.keras.applications import VGG16<br/>from tensorflow.keras.layers import Dense, GlobalAveragePooling2D</span><span id="1c50" class="mt lx it nw b gy om oj l ok ol">#---number of fruits---<br/>NO_CLASSES = max(train_generator.class_indices.values()) + 1</span><span id="8f7a" class="mt lx it nw b gy om oj l ok ol">#---load the VGG16 model as the base model for training---<br/>base_model = VGG16(include_top=False, input_shape=(224, 224, 3))</span><span id="1d09" class="mt lx it nw b gy om oj l ok ol">#---add our own layers---<br/>x = base_model.output<br/>x = GlobalAveragePooling2D()(x)<br/>x = Dense(1024,activation='relu')(x)       # add dense layers so<br/>                                           # that the model can <br/>                                           # learn more complex <br/>                                           # functions and <br/>                                           # classify for better <br/>                                           # results.<br/>x = Dense(1024,activation='relu')(x)       # dense layer 2<br/>x = Dense(512,activation='relu')(x)        # dense layer 3</span><span id="643d" class="mt lx it nw b gy om oj l ok ol">preds = Dense(NO_CLASSES,<br/>              activation='softmax')(x)     # final layer with <br/>                                           # softmax activation</span><span id="f165" class="mt lx it nw b gy om oj l ok ol">#---create a new model with the base model's original <br/># input and the new model's output---<br/>model = Model(inputs = base_model.input, outputs = preds)</span><span id="58b3" class="mt lx it nw b gy om oj l ok ol">#---don't train the first 19 layers - 0..18---<br/>for layer in model.layers[:19]:<br/>    layer.trainable=False</span><span id="77ea" class="mt lx it nw b gy om oj l ok ol">#---train the rest of the layers - 19 onwards---<br/>for layer in model.layers[19:]:<br/>    layer.trainable=True<br/>        <br/>#---compile the model---    <br/>model.compile(optimizer='Adam',<br/>          loss='categorical_crossentropy',<br/>          metrics=['accuracy'])</span></pre><blockquote class="ny nz oa"><p id="f313" class="kz la lv lb b lc ld ju le lf lg jx lh ob lj lk ll oc ln lo lp od lr ls lt lu im bi translated">解释迁移学习如何工作超出了本文的范围。我将把它留给另一篇文章。</p></blockquote><h2 id="04d8" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">使用生成的图像进行训练</h2><p id="53cc" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">要使用增强图像进行训练，将<code class="fe nt nu nv nw b">train_generator</code>传递到模型的<code class="fe nt nu nv nw b">fit()</code>方法中:</p><pre class="kj kk kl km gt oe nw of og aw oh bi"><span id="07d8" class="mt lx it nw b gy oi oj l ok ol">#---train the model---<br/><strong class="nw iu">step_size_train = train_generator.n // train_generator.batch_size</strong></span><span id="7bb0" class="mt lx it nw b gy om oj l ok ol">model.fit(<strong class="nw iu">train_generator</strong>,<br/><strong class="nw iu">          steps_per_epoch=step_size_train,</strong><br/>          epochs=15)</span></pre><p id="eb0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nt nu nv nw b">steps_per_epoch</code>参数基本上表示一个纪元中有多少步骤——这取决于您拥有的图像数量以及之前定义的批次大小。如果你把这个设置得很高，那么你就是在做重复训练。您应该根据以下公式进行设置:</p><p id="eb92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">图像数量/批量</strong></p><p id="9f8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的示例中，我们总共有54幅图像。因此在每个纪元中<code class="fe nt nu nv nw b">ImageDataGenerator</code>类将变换所有54幅图像进行训练。在每个纪元中，模型将获得不同的图像变化。如果您有15个纪元，则总共将生成15x54个图像变体，并将其输入到训练模型中。</p><blockquote class="ny nz oa"><p id="e722" class="kz la lv lb b lc ld ju le lf lg jx lh ob lj lk ll oc ln lo lp od lr ls lt lu im bi translated"><code class="fe nt nu nv nw b"><em class="it">ImageDataGenerator</em></code>类允许您的模型在每个时期接收图像的新变体。但是请记住，它只返回转换后的图像，而不会将其添加到您已有的图像集中。</p></blockquote><div class="oq or gp gr os ot"><a href="https://weimenglee.medium.com/membership" rel="noopener follow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">加入我的推荐链接Medium李伟萌</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">阅读李伟萌(以及其他成千上万的媒体作家)的每一个故事。您的会员费直接支持…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">weimenglee.medium.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph ks ot"/></div></div></a></div><h1 id="a6fb" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">摘要</h1><p id="4a86" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我希望这篇文章已经给了你一个好主意，什么是图像数据增强的一切，为什么你需要他们在训练你的深度学习模型。特别是，我已经使用TensorFlow库中的Keras模块进行了演示。</p></div></div>    
</body>
</html>